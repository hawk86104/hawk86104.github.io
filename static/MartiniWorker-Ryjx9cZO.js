!function(){"use strict";class t{constructor(){this._controller=new AbortController,this.listeners=new Set}static{this.pendings=new Map}fetch(e,s={}){t.pendings.has(e)||(t.pendings.set(e,this),fetch(e,{...s,signal:this._controller.signal}).then(t=>{this.listeners.forEach(e=>e.resolve(t.clone()))}).catch(t=>{this.listeners.forEach(e=>e.reject(t))}).finally(()=>{t.pendings.delete(e)}))}abort(){this._controller.abort()}}class e{constructor(t,e){this.url=t,this.init=e,this.promise=new Promise((t,e)=>{this.resolve=t,this.reject=e})}ready(){let e=t.pendings.get(this.url);return e||(e=new t,e.fetch(this.url,this.init)),e.listeners.add(this),this.promise}abort(){this.reject("User abort.");const e=t.pendings.get(this.url);e&&(e.listeners.delete(this),0===e.listeners.size&&e.abort())}}class s{constructor(t=257){this.gridSize=t;const e=t-1;if(e&e-1)throw new Error(`Expected grid size to be 2^n+1, got ${t}.`);this.numTriangles=e*e*2-2,this.numParentTriangles=this.numTriangles-e*e,this.indices=new Uint32Array(this.gridSize*this.gridSize),this.coords=new Uint16Array(4*this.numTriangles);for(let s=0;s<this.numTriangles;s++){let t=s+2,r=0,i=0,n=0,a=0,o=0,h=0;for(1&t?n=a=o=e:r=i=h=e;(t>>=1)>1;){const e=r+n>>1,s=i+a>>1;1&t?(n=r,a=i,r=o,i=h):(r=n,i=a,n=o,a=h),o=e,h=s}const c=4*s;this.coords[c+0]=r,this.coords[c+1]=i,this.coords[c+2]=n,this.coords[c+3]=a}}createTile(t){return new r(t,this)}}class r{constructor(t,e){const s=e.gridSize;if(t.length!==s*s)throw new Error(`Expected terrain data of length ${s*s} (${s} x ${s}), got ${t.length}.`);this.terrain=t,this.martini=e,this.errors=new Float32Array(t.length),this.update()}update(){const{numTriangles:t,numParentTriangles:e,coords:s,gridSize:r}=this.martini,{terrain:i,errors:n}=this;for(let a=t-1;a>=0;a--){const t=4*a,o=s[t+0],h=s[t+1],c=s[t+2],l=s[t+3],g=o+c>>1,u=h+l>>1,f=g+u-h,M=u+o-g,p=(i[h*r+o]+i[l*r+c])/2,d=u*r+g,w=Math.abs(p-i[d]);if(n[d]=Math.max(n[d],w),a<e){const t=(h+M>>1)*r+(o+f>>1),e=(l+M>>1)*r+(c+f>>1);n[d]=Math.max(n[d],n[t],n[e])}}}getMesh(t=0){const{gridSize:e,indices:s}=this.martini,{errors:r}=this;let i=0,n=0;const a=e-1;function o(a,h,c,l,g,u){const f=a+c>>1,M=h+l>>1;Math.abs(a-g)+Math.abs(h-u)>1&&r[M*e+f]>t?(o(g,u,a,h,f,M),o(c,l,g,u,f,M)):(s[h*e+a]=s[h*e+a]||++i,s[l*e+c]=s[l*e+c]||++i,s[u*e+g]=s[u*e+g]||++i,n++)}s.fill(0),o(0,0,a,a,a,0),o(a,a,0,0,0,a);const h=new Uint16Array(2*i),c=new Uint32Array(3*n);let l=0;function g(i,n,a,o,u,f){const M=i+a>>1,p=n+o>>1;if(Math.abs(i-u)+Math.abs(n-f)>1&&r[p*e+M]>t)g(u,f,i,n,M,p),g(a,o,u,f,M,p);else{const t=s[n*e+i]-1,r=s[o*e+a]-1,g=s[f*e+u]-1;h[2*t]=i,h[2*t+1]=n,h[2*r]=a,h[2*r+1]=o,h[2*g]=u,h[2*g+1]=f,c[l++]=t,c[l++]=r,c[l++]=g}}return g(0,0,a,a,a,0),g(a,a,0,0,0,a),{vertices:h,triangles:c}}getMeshWithSkirts(t=0){const{gridSize:e,indices:s}=this.martini,{errors:r}=this;let i=0,n=0;const a=e-1;let o,h,c=0,l=[],g=[],u=[],f=[];function M(p,d,w,b,m,y){const x=p+w>>1,T=d+b>>1;Math.abs(p-m)+Math.abs(d-y)>1&&r[T*e+x]>t?(M(m,y,p,d,x,T),M(w,b,m,y,x,T)):(o=d*e+p,h=b*e+w,c=y*e+m,0===s[o]&&(0===p?l.push(i):p===a&&g.push(i),0===d?u.push(i):d===a&&f.push(i),s[o]=++i),0===s[h]&&(0===w?l.push(i):w===a&&g.push(i),0===b?u.push(i):b===a&&f.push(i),s[h]=++i),0===s[c]&&(0===m?l.push(i):m===a&&g.push(i),0===y?u.push(i):y===a&&f.push(i),s[c]=++i),n++)}s.fill(0),M(0,0,a,a,a,0),M(a,a,0,0,0,a);const p=2*(i+l.length+g.length+u.length+f.length),d=3*(n+2*(l.length-1)+2*(g.length-1)+2*(u.length-1)+2*(f.length-1)),w=new Uint16Array(p),b=new Uint32Array(d);let m=0;function y(i,n,a,o,h,c){const l=i+a>>1,g=n+o>>1;if(Math.abs(i-h)+Math.abs(n-c)>1&&r[g*e+l]>t)y(h,c,i,n,l,g),y(a,o,h,c,l,g);else{const t=s[n*e+i]-1,r=s[o*e+a]-1,l=s[c*e+h]-1;w[2*t]=i,w[2*t+1]=n,w[2*r]=a,w[2*r+1]=o,w[2*l]=h,w[2*l+1]=c,b[m++]=t,b[m++]=r,b[m++]=l}}y(0,0,a,a,a,0),y(a,a,0,0,0,a),l.sort((t,e)=>w[2*t+1]-w[2*e+1]),g.sort((t,e)=>w[2*e+1]-w[2*t+1]),u.sort((t,e)=>w[2*e]-w[2*t]),f.sort((t,e)=>w[2*t]-w[2*e]);let x,T,A,S,z=2*i,v=0;function P(t){v=t.length;for(var e=0;e<v-1;e++)x=t[e],T=t[e+1],A=z/2,S=(z+2)/2,w[z++]=w[2*x],w[z++]=w[2*x+1],b[m++]=x,b[m++]=A,b[m++]=T,b[m++]=A,b[m++]=S,b[m++]=T;w[z++]=w[2*t[v-1]],w[z++]=w[2*t[v-1]+1]}return P(l),P(g),P(u),P(f),{vertices:w,triangles:b,numVerticesWithoutSkirts:i}}}const i=180/Math.PI;function n(t,e){return t/Math.pow(2,e)*360-180}function a(t,e){const s=Math.PI-2*Math.PI*t/Math.pow(2,e);return i*Math.atan(.5*(Math.exp(s)-Math.exp(-s)))}function o(t){const e=n(t[0]+1,t[2]);return[n(t[0],t[2]),a(t[1]+1,t[2]),e,a(t[1],t[2])]}function h(t){return[t[0]>>1,t[1]>>1,t[2]-1]}const c="merc",l=6378137,g=Math.PI/180;function u(t,e){return[l*t*g,l*Math.log(Math.tan(.25*Math.PI+e*g*.5))]}function f(t){return t*Math.PI/180}const M={a:6378137,f:1/298.257223563};function p(t,e,s){if(!(-80<=e&&e<=84))throw new RangeError(`latitude ‘${e}’ outside UTM limits`);let r=s||Math.floor((t+180)/6)+1,i=f(6*(r-1)-180+3);const n="CDEFGHJKLMNPQRSTUVWXX".charAt(Math.floor(e/8+10));31===r&&"V"===n&&t>=3?(r++,i+=f(6)):32===r&&"X"===n&&t<9?(r--,i-=f(6)):32===r&&"X"===n&&t>=9?(r++,i+=f(6)):34===r&&"X"===n&&t<21?(r--,i-=f(6)):34===r&&"X"===n&&t>=21?(r++,i+=f(6)):36===r&&"X"===n&&t<33?(r--,i-=f(6)):36===r&&"X"===n&&t>=33&&(r++,i+=f(6));const a=f(e),o=f(t)-i,{a:h,f:c}=M,l=.9996,g=Math.sqrt(c*(2-c)),u=c/(2-c),p=u*u,d=u*p,w=u*d,b=u*w,m=u*b,y=Math.cos(o),x=Math.sin(o),T=Math.tan(a),A=Math.sinh(g*Math.atanh(g*T/Math.sqrt(1+T*T))),S=T*Math.sqrt(1+A*A)-A*Math.sqrt(1+T*T),z=Math.atan2(S,y),v=Math.asinh(x/Math.sqrt(S*S+y*y)),P=h/(1+u)*(1+1/4*p+1/64*w+1/256*m),D=[null,.5*u-2/3*p+5/16*d+41/180*w-127/288*b+7891/37800*m,13/48*p-.6*d+557/1440*w+281/630*b-1983433/1935360*m,61/240*d-103/140*w+15061/26880*b+167603/181440*m,49561/161280*w-179/168*b+6601661/7257600*m,34729/80640*b-3418889/1995840*m,.6650675310896665*m];let E=z;for(let f=1;f<=6;f++)E+=D[f]*Math.sin(2*f*z)*Math.cosh(2*f*v);let I=v;for(let f=1;f<=6;f++)I+=D[f]*Math.cos(2*f*z)*Math.sinh(2*f*v);let U=l*P*I,F=l*P*E;return U+=5e5,F<0&&(F+=1e7),[U,F]}class d{static getFromBitmap(t,e=256){this.offscreencanvas||(this.offscreencanvas=new OffscreenCanvas(512,512));const s=this.offscreencanvas.getContext("2d");if(!s)throw new Error("Get context 2d error.");s.drawImage(t,0,0,e,e);const r=s.getImageData(0,0,e,e).data,i=e+1,n=new Float32Array(i*i);for(let a=0;a<e;a++)for(let t=0;t<e;t++){const s=4*(a*e+t),o=r[s+0],h=r[s+1],c=r[s+2];n[a*i+t]=(256*o*256+256*h+c)/10-1e4}for(let a=0;a<i-1;a++)n[i*(i-1)+a]=n[i*(i-2)+a];for(let a=0;a<i;a++)n[i*a+i-1]=n[i*a+i-2];return n}static clip(t,e,s,r,i){if(s+i>e+1||r+i>e+1)throw console.log("clip: ",s,r,i),new RangeError("Clip terrain error");const n=i+1,a=e+1,o=new Float32Array(n*n);for(let h=0;h<n;h++)for(let e=0;e<n;e++)o[h*n+e]=t[(h+r)*a+(e+s)];return o}static getChildPosition(t,e,s){const r=o(t),i=o(s),n=r[2]-r[0],a=r[3]-r[1],h=(i[0]-r[0])/n,c=(r[3]-i[3])/a;return{x:Math.round(h*e),y:Math.round(c*e),bigBbox:r,smallBbox:i}}}class w{static{this.terrainDataMap=new Map}static{this.fetchingMap=new Map}static{this.martiniMap=new Map}static{this.baseSize=512}static getMartini(t){let e=this.martiniMap.get(t);return e||(e=new s(t+1),this.martiniMap.set(t,e)),e}static findAncestorTerrainData(t,e){const s=t[2];let r,i=t;const n=s>=e?s-e:5;for(let a=0;a<n;a++){i=h(i);const t=this.terrainDataMap.get(i.join("-"));if(t){r=t;break}}return{terrain:r,tileNo:i}}static async getTerrainData(t,s,r){const i=t.join("-"),{baseSize:n}=this,{terrain:a,tileNo:h}=this.findAncestorTerrainData(t,r);if(a){let e=t[2]-h[2],s=this.baseSize;for(;e>0;)s/=2,e--;const{x:r,y:i,smallBbox:o}=d.getChildPosition(h,n,t);return{terrain:d.clip(a,n,r,i,s),size:s,bbox:o}}const c=new e(s,{cache:"force-cache",mode:"cors"});this.fetchingMap.set(i,c);try{const e=await c.ready(),s=await e.blob(),r=await createImageBitmap(s),a=d.getFromBitmap(r,n);return this.terrainDataMap.set(i,a),{terrain:a,size:n,bbox:o(t)}}finally{this.fetchingMap.delete(i)}}static async getTileGeometryAttributes(t,e,s,r=c,i){const{terrain:n,size:a,bbox:o}=await this.getTerrainData(t,e,s),h=this.getMartini(a).createTile(n),{vertices:l,triangles:g,numVerticesWithoutSkirts:f}=h.getMeshWithSkirts(10),M=l.length/2,d=new Float32Array(3*M),w=new Float32Array(2*M),b=t[2],m=a+1,y=r===c?u:p;for(let c=0;c<M;c++){const t=l[2*c],e=l[2*c+1],s=e*m+t,r=(o[2]-o[0])*t/a+o[0],h=(o[3]-o[1])*(a-e)/a+o[1],[g,u]=y(r,h,i),M=n[s],p=10*(21-b);d[3*c]=g,d[3*c+1]=u,d[3*c+2]=c>=f?M-p:M,w[2*c+0]=t/a,w[2*c+1]=(a-e)/a}return{positions:d,uv:w,triangles:g}}}self.onmessage=async t=>{const{id:e,tileNo:s,maxZ:r,url:i,coordType:n,utmZone:a,abort:o,dispose:h}=t.data;if(o)return w.fetchingMap.get(e)?.abort(),w.fetchingMap.delete(e),void self.postMessage({id:e,error:!0});if(h)w.terrainDataMap.delete(e);else try{const{positions:t,uv:o,triangles:h}=await w.getTileGeometryAttributes(s,i,r,n,a),c=[t.buffer,o.buffer,h.buffer];self.postMessage({id:e,positions:t,uv:o,triangles:h},c)}finally{w.fetchingMap.delete(e)}}}();
