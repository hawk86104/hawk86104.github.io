(function(){"use strict";class j{constructor(){this._controller=new AbortController,this.listeners=new Set}static{this.pendings=new Map}fetch(i,n={}){j.pendings.has(i)||(j.pendings.set(i,this),fetch(i,{...n,signal:this._controller.signal}).then(t=>{this.listeners.forEach(r=>r.resolve(t.clone()))}).catch(t=>{this.listeners.forEach(r=>r.reject(t))}).finally(()=>{j.pendings.delete(i)}))}abort(){this._controller.abort()}}class Q{constructor(i,n){this.url=i,this.init=n,this.promise=new Promise((t,r)=>{this.resolve=t,this.reject=r})}ready(){let i=j.pendings.get(this.url);return i||(i=new j,i.fetch(this.url,this.init)),i.listeners.add(this),this.promise}abort(){this.reject("User abort.");const i=j.pendings.get(this.url);i&&(i.listeners.delete(this),i.listeners.size===0&&i.abort())}}class Z{constructor(i=257){this.gridSize=i;const n=i-1;if(n&n-1)throw new Error(`Expected grid size to be 2^n+1, got ${i}.`);this.numTriangles=n*n*2-2,this.numParentTriangles=this.numTriangles-n*n,this.indices=new Uint32Array(this.gridSize*this.gridSize),this.coords=new Uint16Array(this.numTriangles*4);for(let t=0;t<this.numTriangles;t++){let r=t+2,s=0,c=0,e=0,o=0,h=0,l=0;for(r&1?e=o=h=n:s=c=l=n;(r>>=1)>1;){const g=s+e>>1,M=c+o>>1;r&1?(e=s,o=c,s=h,c=l):(s=e,c=o,e=h,o=l),h=g,l=M}const f=t*4;this.coords[f+0]=s,this.coords[f+1]=c,this.coords[f+2]=e,this.coords[f+3]=o}}createTile(i){return new Y(i,this)}}class Y{constructor(i,n){const t=n.gridSize;if(i.length!==t*t)throw new Error(`Expected terrain data of length ${t*t} (${t} x ${t}), got ${i.length}.`);this.terrain=i,this.martini=n,this.errors=new Float32Array(i.length),this.update()}update(){const{numTriangles:i,numParentTriangles:n,coords:t,gridSize:r}=this.martini,{terrain:s,errors:c}=this;for(let e=i-1;e>=0;e--){const o=e*4,h=t[o+0],l=t[o+1],f=t[o+2],g=t[o+3],M=h+f>>1,m=l+g>>1,T=M+m-l,b=m+h-M,I=(s[l*r+h]+s[g*r+f])/2,a=m*r+M,S=Math.abs(I-s[a]);if(c[a]=Math.max(c[a],S),e<n){const d=(l+b>>1)*r+(h+T>>1),A=(g+b>>1)*r+(f+T>>1);c[a]=Math.max(c[a],c[d],c[A])}}}getMesh(i=0){const{gridSize:n,indices:t}=this.martini,{errors:r}=this;let s=0,c=0;const e=n-1;t.fill(0);function o(M,m,T,b,I,a){const S=M+T>>1,d=m+b>>1;Math.abs(M-I)+Math.abs(m-a)>1&&r[d*n+S]>i?(o(I,a,M,m,S,d),o(T,b,I,a,S,d)):(t[m*n+M]=t[m*n+M]||++s,t[b*n+T]=t[b*n+T]||++s,t[a*n+I]=t[a*n+I]||++s,c++)}o(0,0,e,e,e,0),o(e,e,0,0,0,e);const h=new Uint16Array(s*2),l=new Uint32Array(c*3);let f=0;function g(M,m,T,b,I,a){const S=M+T>>1,d=m+b>>1;if(Math.abs(M-I)+Math.abs(m-a)>1&&r[d*n+S]>i)g(I,a,M,m,S,d),g(T,b,I,a,S,d);else{const A=t[m*n+M]-1,k=t[b*n+T]-1,E=t[a*n+I]-1;h[2*A]=M,h[2*A+1]=m,h[2*k]=T,h[2*k+1]=b,h[2*E]=I,h[2*E+1]=a,l[f++]=A,l[f++]=k,l[f++]=E}}return g(0,0,e,e,e,0),g(e,e,0,0,0,e),{vertices:h,triangles:l}}getMeshWithSkirts(i=0){const{gridSize:n,indices:t}=this.martini,{errors:r}=this;let s=0,c=0;const e=n-1;let o,h,l=0,f=[],g=[],M=[],m=[];t.fill(0);function T(p,w,v,D,P,C){const W=p+v>>1,R=w+D>>1;Math.abs(p-P)+Math.abs(w-C)>1&&r[R*n+W]>i?(T(P,C,p,w,W,R),T(v,D,P,C,W,R)):(o=w*n+p,h=D*n+v,l=C*n+P,t[o]===0&&(p===0?f.push(s):p===e&&g.push(s),w===0?M.push(s):w===e&&m.push(s),t[o]=++s),t[h]===0&&(v===0?f.push(s):v===e&&g.push(s),D===0?M.push(s):D===e&&m.push(s),t[h]=++s),t[l]===0&&(P===0?f.push(s):P===e&&g.push(s),C===0?M.push(s):C===e&&m.push(s),t[l]=++s),c++)}T(0,0,e,e,e,0),T(e,e,0,0,0,e);const b=(s+f.length+g.length+M.length+m.length)*2,I=(c+(f.length-1)*2+(g.length-1)*2+(M.length-1)*2+(m.length-1)*2)*3,a=new Uint16Array(b),S=new Uint32Array(I);let d=0;function A(p,w,v,D,P,C){const W=p+v>>1,R=w+D>>1;if(Math.abs(p-P)+Math.abs(w-C)>1&&r[R*n+W]>i)A(P,C,p,w,W,R),A(v,D,P,C,W,R);else{const L=t[w*n+p]-1,H=t[D*n+v]-1,O=t[C*n+P]-1;a[2*L]=p,a[2*L+1]=w,a[2*H]=v,a[2*H+1]=D,a[2*O]=P,a[2*O+1]=C,S[d++]=L,S[d++]=H,S[d++]=O}}A(0,0,e,e,e,0),A(e,e,0,0,0,e),f.sort((p,w)=>a[2*p+1]-a[2*w+1]),g.sort((p,w)=>a[2*w+1]-a[2*p+1]),M.sort((p,w)=>a[2*w]-a[2*p]),m.sort((p,w)=>a[2*p]-a[2*w]);let k=s*2,E,B,X,V,F=0;function z(p){F=p.length;for(var w=0;w<F-1;w++)E=p[w],B=p[w+1],X=k/2,V=(k+2)/2,a[k++]=a[2*E],a[k++]=a[2*E+1],S[d++]=E,S[d++]=X,S[d++]=B,S[d++]=X,S[d++]=V,S[d++]=B;a[k++]=a[2*p[F-1]],a[k++]=a[2*p[F-1]+1]}return z(f),z(g),z(M),z(m),{vertices:a,triangles:S,numVerticesWithoutSkirts:s}}}const y=180/Math.PI;function _(u,i){return u/Math.pow(2,i)*360-180}function x(u,i){const n=Math.PI-2*Math.PI*u/Math.pow(2,i);return y*Math.atan(.5*(Math.exp(n)-Math.exp(-n)))}function q(u){const i=_(u[0]+1,u[2]),n=_(u[0],u[2]),t=x(u[1]+1,u[2]),r=x(u[1],u[2]);return[n,t,i,r]}function tt(u){return[u[0]>>1,u[1]>>1,u[2]-1]}const J="merc",K=6378137,N=Math.PI/180;function et(u,i){const n=K*u*N,t=K*Math.log(Math.tan(Math.PI*.25+i*N*.5));return[n,t]}function U(u){return u*Math.PI/180}const nt={a:6378137,f:1/298.257223563},st="CDEFGHJKLMNPQRSTUVWXX",it=5e5,rt=1e7;function ot(u,i,n){if(!(-80<=i&&i<=84))throw new RangeError(`latitude ‘${i}’ outside UTM limits`);let t=n||Math.floor((u+180)/6)+1,r=U((t-1)*6-180+3);const s=st.charAt(Math.floor(i/8+10));t===31&&s==="V"&&u>=3?(t++,r+=U(6)):t===32&&s==="X"&&u<9?(t--,r-=U(6)):t===32&&s==="X"&&u>=9?(t++,r+=U(6)):t===34&&s==="X"&&u<21?(t--,r-=U(6)):t===34&&s==="X"&&u>=21?(t++,r+=U(6)):t===36&&s==="X"&&u<33?(t--,r-=U(6)):t===36&&s==="X"&&u>=33&&(t++,r+=U(6));const c=U(i),e=U(u)-r,{a:o,f:h}=nt,l=.9996,f=Math.sqrt(h*(2-h)),g=h/(2-h),M=g*g,m=g*M,T=g*m,b=g*T,I=g*b,a=Math.cos(e),S=Math.sin(e),d=Math.tan(c),A=Math.sinh(f*Math.atanh(f*d/Math.sqrt(1+d*d))),k=d*Math.sqrt(1+A*A)-A*Math.sqrt(1+d*d),E=Math.atan2(k,a),B=Math.asinh(S/Math.sqrt(k*k+a*a)),X=o/(1+g)*(1+1/4*M+1/64*T+1/256*I),V=[null,1/2*g-2/3*M+5/16*m+41/180*T-127/288*b+7891/37800*I,13/48*M-3/5*m+557/1440*T+281/630*b-1983433/1935360*I,61/240*m-103/140*T+15061/26880*b+167603/181440*I,49561/161280*T-179/168*b+6601661/7257600*I,34729/80640*b-3418889/1995840*I,212378941/319334400*I];let F=E;for(let v=1;v<=6;v++)F+=V[v]*Math.sin(2*v*E)*Math.cosh(2*v*B);let z=B;for(let v=1;v<=6;v++)z+=V[v]*Math.cos(2*v*E)*Math.sinh(2*v*B);let p=l*X*z,w=l*X*F;return p=p+it,w<0&&(w=w+rt),[p,w]}class G{static getFromBitmap(i,n=256){this.offscreencanvas||(this.offscreencanvas=new OffscreenCanvas(512,512));const t=this.offscreencanvas.getContext("2d");if(!t)throw new Error("Get context 2d error.");t.drawImage(i,0,0,n,n);const r=t.getImageData(0,0,n,n).data,s=n+1,c=new Float32Array(s*s);for(let e=0;e<n;e++)for(let o=0;o<n;o++){const h=(e*n+o)*4,l=r[h+0],f=r[h+1],g=r[h+2];c[e*s+o]=(l*256*256+f*256+g)/10-1e4}for(let e=0;e<s-1;e++)c[s*(s-1)+e]=c[s*(s-2)+e];for(let e=0;e<s;e++)c[s*e+s-1]=c[s*e+s-2];return c}static clip(i,n,t,r,s){if(t+s>n+1||r+s>n+1)throw console.log("clip: ",t,r,s),new RangeError("Clip terrain error");const c=s+1,e=n+1,o=new Float32Array(c*c);for(let h=0;h<c;h++)for(let l=0;l<c;l++)o[h*c+l]=i[(h+r)*e+(l+t)];return o}static getChildPosition(i,n,t){const r=q(i),s=q(t),c=r[2]-r[0],e=r[3]-r[1],o=(s[0]-r[0])/c,h=(r[3]-s[3])/e,l=Math.round(o*n),f=Math.round(h*n);return{x:l,y:f,bigBbox:r,smallBbox:s}}}class ${static{this.terrainDataMap=new Map}static{this.fetchingMap=new Map}static{this.martiniMap=new Map}static{this.baseSize=512}static getMartini(i){let n=this.martiniMap.get(i);return n||(n=new Z(i+1),this.martiniMap.set(i,n)),n}static findAncestorTerrainData(i,n){const t=i[2];let r,s=i;const c=t>=n?t-n:5;for(let e=0;e<c;e++){s=tt(s);const o=this.terrainDataMap.get(s.join("-"));if(o){r=o;break}}return{terrain:r,tileNo:s}}static async getTerrainData(i,n,t){const r=i.join("-"),{baseSize:s}=this,{terrain:c,tileNo:e}=this.findAncestorTerrainData(i,t);if(c){let h=i[2]-e[2],l=this.baseSize;for(;h>0;)l=l/2,h--;const{x:f,y:g,smallBbox:M}=G.getChildPosition(e,s,i);return{terrain:G.clip(c,s,f,g,l),size:l,bbox:M}}const o=new Q(n,{cache:"force-cache",mode:"cors"});this.fetchingMap.set(r,o);try{const l=await(await o.ready()).blob(),f=await createImageBitmap(l),g=G.getFromBitmap(f,s);return this.terrainDataMap.set(r,g),{terrain:g,size:s,bbox:q(i)}}finally{this.fetchingMap.delete(r)}}static async getTileGeometryAttributes(i,n,t,r=J,s){const{terrain:c,size:e,bbox:o}=await this.getTerrainData(i,n,t),l=this.getMartini(e).createTile(c),{vertices:f,triangles:g,numVerticesWithoutSkirts:M}=l.getMeshWithSkirts(10),m=f.length/2,T=new Float32Array(m*3),b=new Float32Array(m*2),I=i[2],a=e+1,S=r===J?et:ot;for(let d=0;d<m;d++){const A=f[2*d],k=f[2*d+1],E=k*a+A,B=(o[2]-o[0])*A/e+o[0],X=(o[3]-o[1])*(e-k)/e+o[1],[V,F]=S(B,X,s),z=c[E],p=(21-I)*10;T[3*d]=V,T[3*d+1]=F,T[3*d+2]=d>=M?z-p:z,b[2*d+0]=A/e,b[2*d+1]=(e-k)/e}return{positions:T,uv:b,triangles:g}}}self.onmessage=async u=>{const{id:i,tileNo:n,maxZ:t,url:r,coordType:s,utmZone:c,abort:e,dispose:o}=u.data;if(e){$.fetchingMap.get(i)?.abort(),$.fetchingMap.delete(i),self.postMessage({id:i,error:!0});return}if(o){$.terrainDataMap.delete(i);return}try{const{positions:h,uv:l,triangles:f}=await $.getTileGeometryAttributes(n,r,t,s,c),g=[h.buffer,l.buffer,f.buffer];self.postMessage({id:i,positions:h,uv:l,triangles:f},g)}finally{$.fetchingMap.delete(i)}}})();
