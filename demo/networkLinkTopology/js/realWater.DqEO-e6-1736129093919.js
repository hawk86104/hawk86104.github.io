import{m as n,e,a as t,U as r,H as o}from"./@tresjs.C4A766dl1736129093919.js";import{P as i}from"./tweakpane.BCjFYDHx1736129093919.js";import{_ as c,a,aA as l,z as s,O as u,W as f,p,t as v,s as g}from"./three.ES53pcRR1736129093919.js";import{d,a6 as x,b as h,o as m,f as y,u as w,g as b,j as R,al as C,r as I,J as _,aj as z,ak as M}from"./@vue.uQKhJ3x71736129093919.js";import"./@vueuse.CaPKQ7tQ1736129093919.js";var T="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";!function(n,e){const t=L,r=O();for(;;)try{if(728658===parseInt(t(111))/1+parseInt(t(143))/2+-parseInt(t(137))/3*(parseInt(t(119))/4)+parseInt(t(134))/5*(-parseInt(t(138))/6)+parseInt(t(133))/7+parseInt(t(136))/8*(-parseInt(t(152))/9)+parseInt(t(124))/10*(parseInt(t(150))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const D=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[L(154)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){D(this,(function(){const n=L,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(146),"i"),r=F(n(158));e.test(r+n(148))&&t[n(116)](r+"input")?F():r("0")}))()}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[L(154)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function L(n,e){const t=O();return(L=function(n,e){return t[n-=111]})(n,e)}function O(){const n=["apply","BufferGeometry","string","uniforms","init","debu","info","console","365457CIuzgo","setIndex","action","waterTexture","water","test","gger",'{}.constructor("return this")( )',"1835036gouHhh","RawShaderMaterial","FrontSide","value","length","4400AQSYBa","prototype","render","Mesh","bind","toString","counter","constructor","BufferAttribute","6163759jZYYOl","55stkKKX","table","6491144aZzwvY","3cstMui","595290UVbxpz","light","warn","call","__proto__","1968842UJfFAU","causticTex","causticsTexture","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","setAttribute","chain","position","21494bgjYGY","while (true) {}","9QDLJEc","tiles"];return(O=function(){return n})()}A(void 0,(function(){const n=L,e=function(){const n=L;let e;try{e=Function("return (function() "+n(118)+");")()}catch(t){e=window}return e}(),t=e[n(161)]=e.console||{},r=["log",n(140),n(160),"error","exception",n(135),"trace"];for(let o=0;o<r[n(123)];o++){const e=A.constructor[n(125)].bind(A),i=r[o],c=t[i]||e;e[n(142)]=A.bind(A),e[n(129)]=c.toString[n(128)](c),t[i]=e}}))();const E=d({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=L,o=t,i=new(c[r(155)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(147)](r(149),new a(l,3)),i[r(112)](new(c[r(132)])(s,1));const u=new(c[r(120)])({uniforms:{light:{value:o[r(139)]},tiles:{value:o[r(153)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(121)]}),f=new(c[r(127)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{const n=r;((n,e)=>{const t=r;u[t(157)][t(115)].value=n,u[t(157)][t(144)][t(122)]=e,p[t(122)][t(126)](f,v[t(122)])})(o[n(114)],o[n(145)])})),(n,e)=>null}});function F(n){function e(n){const t=L;if(typeof n===t(156))return function(n){}[t(131)](t(151))[t(154)](t(130));1!==(""+n/n)[t(123)]||n%20==0?function(){return!0}[t(131)]("debu"+t(117))[t(141)](t(113)):function(){return!1}[t(131)](t(159)+"gger")[t(154)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const j=P;!function(n,e){const t=P,r=W();for(;;)try{if(879639===-parseInt(t(248))/1*(parseInt(t(200))/2)+-parseInt(t(194))/3+parseInt(t(254))/4+-parseInt(t(223))/5*(parseInt(t(201))/6)+parseInt(t(212))/7+parseInt(t(250))/8*(-parseInt(t(241))/9)+parseInt(t(240))/10*(parseInt(t(217))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(214)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function P(n,e){const t=W();return(P=function(n,e){return t[n-=194]})(n,e)}function W(){const n=["tiles","2466567lhYMil","debu","test","table","counter","info","2Ocrwlz","18264FUydRQ","neg-x.jpg","warn","pooRef","water","length","CubeTextureLoader","return (function() ","Mesh","toString","pos-x.jpg","11539031bWjTPz","stateObject","apply","gger","setPath","889064qioXAZ","load","neg-z.jpg","function *\\( *\\)","prototype","constructor","1635uouZPs","white","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","render","clear",'{}.constructor("return this")( )',"underwater","call","console","Color","causticsTexture","side","bind","BackSide","log","string","value","200FLDhCM","45iccTUm","error","geometry","waterTexture","setRenderTarget","light","chain","627178zMmimP","uniforms","1852472KhKRTB","causticTex","init","while (true) {}","4869104ogXvaA"];return(W=function(){return n})()}!function(){S(this,(function(){const n=P,e=new RegExp(n(220)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=H(n(252));e[n(196)](r+n(247))&&t.test(r+"input")?H():r("0")}))()}();const k=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(214)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();k(void 0,(function(){const n=P;let e;try{e=Function(n(208)+n(228)+");")()}catch(o){e=window}const t=e[n(231)]=e.console||{},r=[n(237),n(203),n(199),n(242),"exception",n(197),"trace"];for(let i=0;i<r[n(206)];i++){const e=k[n(222)][n(221)][n(235)](k),o=r[i],c=t[o]||e;e.__proto__=k[n(235)](k),e[n(210)]=c[n(210)][n(235)](c),t[o]=e}}))();const V=d({__name:j(205),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=j;let i,a;const u=r,f=u[o(243)],p=(new(c[o(207)]))[o(216)](o(225))[o(218)]([o(211),o(202),"pos-y.jpg","neg-y.jpg","pos-z.jpg",o(219)]),v=([i,a]=x((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),g=new l({uniforms:{light:{value:u[o(246)]},tiles:{value:v},sky:{value:p},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),d=new(c[o(209)])(f,g),b=h(null),R=new(c[o(232)])(o(224)),{renderer:C,camera:I}=n(),{onLoop:_}=e();return _((()=>{const n=o;C.value[n(245)](null),C[n(239)].setClearColor(R,1),C[n(239)][n(227)](),g.uniforms[n(205)][n(239)]=u.waterTexture,g[n(249)][n(251)].value=u[n(233)],g[n(234)]=s,g[n(249)][n(229)][n(239)]=!0,C.value[n(226)](d,I[n(239)]),g.side=c[n(236)],g[n(249)][n(229)].value=!1,C[n(239)].render(d,I.value)})),(n,e)=>{const t=o;return m(),y(E,{tiles:w(v),light:n[t(246)],waterTexture:n[t(244)],causticsTexture:n.causticsTexture,ref_key:t(204),ref:b},null,8,[t(255),"light","waterTexture",t(233)])}}});function H(n){function e(n){const t=P;if(typeof n===t(238))return function(n){}.constructor(t(253))[t(214)](t(198));1!==(""+n/n)[t(206)]||n%20==0?function(){return!0}[t(222)]("debugger")[t(230)]("action"):function(){return!1}[t(222)](t(195)+t(215)).apply(t(213)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function B(n,e){const t=X();return(B=function(n,e){return t[n-=457]})(n,e)}const Z=B;!function(n,e){const t=B,r=X();for(;;)try{if(963207===-parseInt(t(498))/1+parseInt(t(503))/2+-parseInt(t(475))/3+parseInt(t(489))/4+parseInt(t(504))/5+-parseInt(t(495))/6+parseInt(t(506))/7*(-parseInt(t(493))/8))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Y=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[B(496)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Y(this,(function(){const n=B,e=new RegExp(n(502)),t=new RegExp(n(473),"i"),r=U(n(497));e[n(460)](r+"chain")&&t[n(460)](r+"input")?U():r("0")}))()}();const G=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();G(void 0,(function(){const n=B,e=function(){const n=B;let e;try{e=Function(n(476)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(470)]=e[n(470)]||{},r=[n(492),n(480),n(501),n(491),"exception",n(463),n(469)];for(let o=0;o<r[n(461)];o++){const e=G[n(478)][n(505)][n(500)](G),i=r[o],c=t[i]||e;e[n(483)]=G[n(500)](G),e[n(466)]=c.toString[n(500)](c),t[i]=e}}))();const N=d({__name:Z(482),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=Z,o=t,i=new u(0,1,1,0,0,2e3),a=new(c[r(490)])(2,2,200,200),l=new f(1024,1024),s=new(c[r(477)])({uniforms:{light:{value:o.light},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new(c[r(459)])(a,s),v=new(c[r(472)])(r(487)),{renderer:g}=n(),{onBeforeLoop:d}=e();return d((()=>{const n=r;p[n(494)][n(471)][n(484)][n(481)]=o.waterTexture,g[n(481)][n(464)](l),g[n(481)].setClearColor(v,0),g[n(481)][n(467)](),g[n(481)].render(p,i)})),(n,e)=>{const t=r;return m(),y(C,null,{default:b((()=>[R(V,{waterTexture:n.waterTexture,causticsTexture:w(l).texture,light:n.light,geometry:w(a)},null,8,[t(499),t(462),t(488),t(465)])])),_:1})}}});function U(n){function e(n){const t=B;if(typeof n===t(479))return function(n){}[t(478)](t(457))[t(496)](t(468));1!==(""+n/n)[t(461)]||n%20==0?function(){return!0}[t(478)]("debu"+t(474))[t(485)](t(458)):function(){return!1}.constructor(t(486)+t(474))[t(496)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}function X(){const n=["7020660ssKzTD","prototype","7WlthwX","while (true) {}","action","Mesh","test","length","causticsTexture","table","setRenderTarget","geometry","toString","clear","counter","trace","console","uniforms","Color","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","gger","2561427lJcKtg","return (function() ","ShaderMaterial","constructor","string","warn","value","caustics","__proto__","water","call","debu","black","light","5636688FkXKxW","PlaneGeometry","error","log","9437384yaGvtY","material","2881608VitTEH","apply","init","461534PlEBfm","waterTexture","bind","info","function *\\( *\\)","2250374pBOmAn"];return(X=function(){return n})()}function $(){const n=["table","waterSimulation","removeEventListener","material","getBoundingClientRect","FloatType","position","height","domElement","chain","bind","value","autoClear","lightFrontGeometry","point","debu","setZ","gger","Vector2","stateObject","texture","info","center","string","setY","error","console","uniforms","795302nlPRfY","trace","apply","needsUpdate","6001315GAKwzj","setFromCamera","RawShaderMaterial","3065832mrlXtL","waterTexture","while (true) {}","log","init","test","mousemove","length","2189392TOmBGL","strength","addEventListener","580868ugqiEj","exception","input","attributes","render","WebGLRenderTarget","intersectObject","6XxlcPQ","clientX","Mesh","clientY","radius","left","6741763ljRhrr","return (function() ","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","1kOLUEn","7859030olmifD","constructor","__proto__","setRenderTarget","call","toString","warn","9xUBTRs","PlaneGeometry","light"];return($=function(){return n})()}const K=Q;!function(n,e){const t=Q,r=$();for(;;)try{if(999303===parseInt(t(368))/1*(parseInt(t(407))/2)+parseInt(t(414))/3+-parseInt(t(352))/4+parseInt(t(411))/5+parseInt(t(359))/6*(-parseInt(t(365))/7)+parseInt(t(349))/8+parseInt(t(376))/9*(-parseInt(t(369))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){q(this,(function(){const n=Q,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(367),"i"),r=en(n(418));e[n(419)](r+n(388))&&t[n(419)](r+n(354))?en():r("0")}))()}();const J=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Q(409)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Q(n,e){const t=$();return(Q=function(n,e){return t[n-=347]})(n,e)}J(void 0,(function(){const n=Q;let e;try{e=Function(n(366)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e.console=e[n(405)]||{},r=[n(417),n(375),n(400),n(404),n(353),n(379),n(408)];for(let i=0;i<r[n(348)];i++){const e=J.constructor.prototype[n(389)](J),o=r[i],c=t[o]||e;e[n(371)]=J.bind(J),e[n(374)]=c[n(374)][n(389)](c),t[o]=e}}))();const nn=d({__name:K(380),props:{light:{}},setup(t,{expose:r}){const o=K,i=new u(0,1,1,0,0,2e3),a=new(c[o(377)])(2,2),l=new f(256,256,{type:p}),s=new(c[o(357)])(256,256,{type:c[o(384)]}),d=new(c[o(413)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:T,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),x=new(c[o(413)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:T,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),h=new(c[o(413)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:T,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),b=new(c[o(361)])(a,d),R=new(c[o(361)])(a,x),C=new(c[o(361)])(a,h);let I=l;const _=(n,e)=>{const t=o,r=I,c=I===l?s:l;e[t(382)][t(406)].texture[t(390)]=r.texture,n[t(372)](c),n[t(356)](e,i),I=c},{renderer:z,camera:M,raycaster:D}=n();z[o(390)][o(391)]=!1;const{onBeforeLoop:A}=e();A((()=>{const n=o;var e,t;t=z[n(390)],_(t,C),e=z[n(390)],_(e,R)}));const L=(n,e,t,r)=>{const i=o;b[i(382)][i(406)][i(401)].value=[n,e],b[i(382)][i(406)][i(363)].value=t,b.material[i(406)][i(350)][i(390)]=r,_(z.value,b)},O=new(c[o(397)]),E=new v(2,2),F=E[o(355)][o(385)];for(let n=0;n<F.count;n++){const e=-F.getY(n);F[o(403)](n,0),F[o(395)](n,e)}F[o(410)]=!0;const j=new g(E),S={handleEvent:n=>{const e=o,t=z.value.domElement[e(383)](),r=t.width,i=t[e(386)];O.x=2*(n[e(360)]-t[e(364)])/r-1,O.y=2*-(n[e(362)]-t.top)/i+1,D.value[e(412)](O,M.value);const c=D[e(390)][e(358)](j);for(let o of c)L(o[e(393)].x,o[e(393)].z,.03,.04)}};return r({addDrop:L,mouseEvent:n=>{const e=o;n?z[e(390)][e(387)][e(351)](e(347),S):z[e(390)][e(387)][e(381)]("mousemove",S)}}),(n,e)=>{const t=o;return m(),y(N,{lightFrontGeometry:w(a),waterTexture:w(I)[t(399)],light:n[t(378)]},null,8,[t(392),t(415),t(378)])}}});function en(n){function e(n){const t=Q;if(typeof n===t(402))return function(n){}[t(370)](t(416))[t(409)]("counter");1!==(""+n/n).length||n%20==0?function(){return!0}.constructor(t(394)+t(396))[t(373)]("action"):function(){return!1}[t(370)](t(394)+t(396))[t(409)](t(398)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const tn=rn;function rn(n,e){const t=ln();return(rn=function(n,e){return t[n-=363]})(n,e)}!function(n,e){const t=rn,r=ln();for(;;)try{if(731964===-parseInt(t(385))/1+-parseInt(t(394))/2+-parseInt(t(379))/3*(parseInt(t(380))/4)+-parseInt(t(398))/5+-parseInt(t(397))/6+parseInt(t(389))/7+-parseInt(t(399))/8*(-parseInt(t(377))/9))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const on=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[rn(368)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){on(this,(function(){const n=rn,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(401),"i"),r=sn(n(387));e[n(363)](r+n(375))&&t.test(r+"input")?sn():r("0")}))()}();const cn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[rn(368)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();cn(void 0,(function(){const n=rn;let e;try{e=Function(n(395)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(366)]=e.console||{},r=[n(406),"warn",n(386),n(396),n(373),n(392),"trace"];for(let i=0;i<r[n(376)];i++){const e=cn.constructor[n(369)][n(400)](cn),o=r[i],c=t[o]||e;e.__proto__=cn.bind(cn),e[n(404)]=c[n(404)][n(400)](c),t[o]=e}}))();const an=d({__name:tn(372),setup(n){const e=tn,t=I({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(382)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=h(null),l=new i;l.addButton({label:e(402),title:e(403)}).on(e(384),(()=>{const n=e;for(var t=0;t<10;t++)a[n(371)][n(367)](2*Math[n(364)]()-1,2*Math.random()-1,.03,1&t?.02:-.02)}));const s=h(!1);return l.addBinding(s,e(371),{label:e(388)}).on(e(370),(n=>{const t=e;a[t(371)].mouseEvent(n[t(371)])})),(n,i)=>{const l=e;return m(),y(w(o),z(M(t)),{default:b((()=>[i[0]||(i[0]=_(l(374),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),R(w(r)),R(nn,{light:c,ref_key:l(365),ref:a},null,512)])),_:1},16)}}});function ln(){const n=["1932238hzEfxO","return (function() ","error","5329494XVUtQa","35975JcypRh","23776MemyDn","bind","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","点击按钮","随机增加波纹","toString","while (true) {}","log","test","random","waterSimulationRef","console","addDrop","apply","prototype","change","value","realWater","exception","TresPerspectiveCamera","chain","length","10764owkuKi","gger","3720819NYNLrT","4zEyBDX","debu","manual","stateObject","click","1001039wsmTyW","info","init","鼠标波纹","8962289bRziGA","counter","action","table","constructor"];return(ln=function(){return n})()}function sn(n){function e(n){const t=rn;if("string"==typeof n)return function(n){}[t(393)](t(405))[t(368)](t(390));1!==(""+n/n)[t(376)]||n%20==0?function(){return!0}[t(393)](t(381)+t(378)).call(t(391)):function(){return!1}[t(393)](t(381)+t(378)).apply(t(383)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{an as default};
