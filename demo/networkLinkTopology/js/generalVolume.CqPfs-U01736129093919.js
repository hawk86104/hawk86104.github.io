var n="out vec3 vOrigin; \nout vec3 vDirection;  \nvarying vec3 vPosition;\n\nvoid main() {\n  vPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n  \n  \n  vOrigin = vec3(inverse(modelMatrix) * vec4(cameraPosition, 1.0)).xyz;\n  \n  vDirection = position - vOrigin;\n\n  \n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",e="precision highp sampler3D; \nprecision highp float;     \n\nuniform sampler3D dataTexture;  \nuniform sampler2D colorTexture; \nuniform float samplingRate;     \nuniform float threshold;  \nuniform float alphaScale; \nuniform bool invertColor; \nuniform float composeType;\n\nin vec3 vOrigin;    \nin vec3 vDirection; \n\nuniform vec4 clipPlanesArray[3]; \nvarying vec3 vPosition;\nuniform vec2 u_clim;\n\nfloat sampleData(vec3 texcoords) {\n\t\treturn (texture(dataTexture, texcoords.xyz).r - u_clim[0]) / (u_clim[1] - u_clim[0]);\n}\n\nvec4 sampleColor(float value) {\n  \n  \n  float x = invertColor ? 1. - value : value;\n  return texture(colorTexture, vec2(x, .5));\n}\n\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n  vec3 tMin = (boxMin - rayOrigin) / rayDir;\n  vec3 tMax = (boxMax - rayOrigin) / rayDir;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n\n  return vec2(tNear, tFar);\n}\n\nvec4 compose_maximumIntensity(vec4 color, vec3 entryPoint, vec3 rayDir,\n                              float samples, float tStart, float tEnd,\n                              float tIncr) {\n  \n  \n  float density = 0.;\n  for (float i = 0.; i < samples; i += 1.) {\n    \n    float t = tStart + tIncr * i;     \n    vec3 p = entryPoint + rayDir * t; \n\n    \n    float value = sampleData(p);\n\n    \n    if (value > density) {\n      \n      density = value;\n    }\n\n    \n    \n    if (density >= 1. || t > tEnd) {\n      break;\n    }\n  }\n\n  \n  color.rgb = sampleColor(density).rgb;\n  \n  color.a = alphaScale * (invertColor ? 1. - density : density);\n\n  \n  return color;\n}\n\nvec4 compose_thresholding(vec4 color, vec3 entryPoint, vec3 rayDir,\n                          float samples, float tStart, float tEnd,\n                          float tIncr) {\n  \n  \n\n  \n  \n  for (float i = 0.; i < samples; i += 1.) {\n    \n    float t = tStart + tIncr * i;     \n    vec3 p = entryPoint + rayDir * t; \n\n    \n    float value = sampleData(p);\n\n    \n    if (value >= threshold || t > tEnd) {\n      \n      color.rgb = sampleColor(value).rgb;\n      \n      color.a = alphaScale;\n      break;\n    }\n  }\n\n  \n  return color;\n}\nvec4 compose_emissionAbsorption(vec4 color, vec3 entryPoint, vec3 rayDir,\n                                float samples, float tStart, float tEnd,\n                                float tIncr) {\n  \n\n  \n  \n  for (float i = 0.; i < samples; i += 1.) {\n    \n    float t = tStart + tIncr * i;     \n    vec3 p = entryPoint + rayDir * t; \n\n    \n    float value = sampleData(p);\n    \n    vec4 valueColor = sampleColor(value);\n\n    \n    valueColor.a *= value * alphaScale;\n    valueColor.rgb *= valueColor.a;\n\n    color.rgb += (1. - color.a) * valueColor.rgb;\n    color.a += (1. - color.a) * valueColor.a;\n\n    \n    \n    if (color.a >= .99 || t > tEnd) {\n      break;\n    }\n  }\n\n  \n  return color;\n}\nvec4 compose(vec4 color, vec3 entryPoint, vec3 rayDir, float samples,\n             float tStart, float tEnd, float tIncr) {\n  if (composeType == 1.) {\n    return compose_maximumIntensity(color, entryPoint, rayDir, samples, tStart,\n                                    tEnd, tIncr);\n  }\n  if (composeType == 2.) {\n    return compose_thresholding(color, entryPoint, rayDir, samples, tStart,\n                                tEnd, tIncr);\n  }\n  if (composeType == 3.) {\n    return compose_emissionAbsorption(color, entryPoint, rayDir, samples,\n                                      tStart, tEnd, tIncr);\n  }\n}\n\nvoid main() {\n  \n  vec3 rayDir = normalize(vDirection);\n  vec3 aabbmin = vec3(-.5);\n  vec3 aabbmax = vec3(.5);\n  vec2 intersection = intersectAABB(vOrigin, rayDir, aabbmin, aabbmax);\n\n  \n  vec4 color = vec4(0.);\n\n  \n  \n  if (intersection.x <= intersection.y) {\n    \n    \n    intersection.x = max(intersection.x, 0.);\n    \n    vec3 entryPoint = vOrigin + rayDir * intersection.x;\n    vec3 exitPoint = vOrigin + rayDir * intersection.y;\n\n    \n    \n    \n    vec3 dimensions = vec3(textureSize(dataTexture, 0));\n    vec3 entryToExit = exitPoint - entryPoint;\n    float samples =\n        ceil(samplingRate * length(entryToExit * (dimensions - vec3(1.))));\n    float tEnd = length(entryToExit);\n    float tIncr = tEnd / samples;\n    float tStart = .5 * tIncr;\n\n    \n    vec3 texEntry = (entryPoint - aabbmin) / (aabbmax - aabbmin);\n\n    \n    color = compose(color, texEntry, rayDir, samples, tStart, tEnd, tIncr);\n  }\n\n  \n  vec4 eeee = vec4(.0, .0, .0, 1.0);\n  eeee.x = dot(vPosition, clipPlanesArray[0].xyz)+clipPlanesArray[0].w;\n  if (eeee.x < 0.0)\n      discard; \n  eeee.y = dot(vPosition, clipPlanesArray[1].xyz)+clipPlanesArray[1].w;\n  if (eeee.y < 0.0)\n      discard; \n  eeee.z = dot(vPosition, clipPlanesArray[2].xyz)+clipPlanesArray[2].w;\n  if (eeee.z < 0.0)\n      discard; \n  \n  gl_FragColor = color;\n}";export{e as a,n as g};
