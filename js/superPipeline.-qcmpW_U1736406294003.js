import{e as n}from"./@tresjs.AACxYGk_1736406294003.js";import{a0 as t,aB as e}from"./three.jaHX2_hY1736406294003.js";import{_ as r}from"./argestCircle.iQbYZf4A1736406294003.js";import{d as o,e as a,o as c,f as i,g as f,J as l,aj as s,ak as d,m as p}from"./@vue.yG49nQHr1736406294003.js";import"./@vueuse.d_orRt1V1736406294003.js";const v=y;function u(){const n=["error","736064HzjzGu","trace","info","test","TresPerspectiveCamera","TresDirectionalLight","superPipeline","#ffffff","constructor","#000000","exception","7371189VlpVtk","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","apply","console","16426410UExYUm","chain","init","2749146nVfAYj","7urzhbZ","counter","264XvrvBw","stateObject","input","17204rfwokA","uniforms","prototype","table","83935jVLOjg","TresShaderMaterial","return (function() ","length","string","bind",'{}.constructor("return this")( )',"__proto__","quanMeshRef","toString","debu","72lBIKXt","gger","9875192uCtLNF","TresAmbientLight","value"];return(u=function(){return n})()}!function(n,t){const e=y,r=u();for(;;)try{if(703540===parseInt(e(311))/1+-parseInt(e(290))/2*(-parseInt(e(305))/3)+parseInt(e(287))/4*(-parseInt(e(294))/5)+parseInt(e(284))/6+parseInt(e(285))/7*(parseInt(e(307))/8)+parseInt(e(277))/9+-parseInt(e(281))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const m=function(){let n=!0;return function(t,e){const r=n?function(){if(e){const n=e.apply(t,arguments);return e=null,n}}:function(){};return n=!1,r}}();!function(){m(this,(function(){const n=y,t=new RegExp("function *\\( *\\)"),e=new RegExp(n(278),"i"),r=g(n(283));t.test(r+n(282))&&e[n(314)](r+n(289))?g():r("0")}))()}();const x=function(){let n=!0;return function(t,e){const r=n?function(){if(e){const n=e.apply(t,arguments);return e=null,n}}:function(){};return n=!1,r}}();function y(n,t){const e=u();return(y=function(n,t){return e[n-=275]})(n,t)}x(void 0,(function(){const n=y,t=function(){const n=y;let t;try{t=Function(n(296)+n(300)+");")()}catch(e){t=window}return t}(),e=t[n(280)]=t[n(280)]||{},r=["log","warn",n(313),n(310),n(276),n(293),n(312)];for(let o=0;o<r[n(297)];o++){const t=x[n(319)][n(292)].bind(x),a=r[o],c=e[a]||t;t[n(301)]=x[n(299)](x),t[n(303)]=c[n(303)][n(299)](c),e[a]=t}}))();const h={ref:"perspectiveCameraRef",position:[0,0,1800],fov:45,near:1,far:1e4},b=["rotation-x"],j=o({__name:v(317),setup(o){const u=v,m={clearColor:u(275),shadows:!0,alpha:!1,useLegacyLights:!0},x={uniforms:{uTime:{type:"f",value:0}},vertexShader:r,fragmentShader:"// 光线追踪实例，想学习每行代码的逻辑，请联系ICE社区-Jsonco\nvarying vec2 vUv;\nuniform float uTime;\n#define FAR 50.\nfloat svObjID,svObjID2;\nvec3 vObjID;\n#define TUN 0.\n#define ROD 1.\n#define BLT 2.\nmat2 rot(float th){vec2 a=sin(vec2(1.5707963,0)+th);return mat2(a,-a.y,a.x);}\nvec3 camPath(float t){\n  float a=sin(t*3.14159265/16.+1.5707963);\n  float b=cos(t*3.14159265/16.);\n  return vec3(a,b*a*.5,t);\n}\n\nvec3 camPathPL(float t){\n  float it=floor(t+1.);\n  float ft=t-it;\n  float a=sin(it*3.14159265/16.+1.5707963);\n  float b=cos(it*3.14159265/16.);\n  vec2 p0=vec2(a,b*a*.5);\n  a=sin((it+1.)*3.14159265/16.+1.5707963);\n  b=cos((it+1.)*3.14159265/16.);\n  vec2 p1=vec2(a,b*a*.5);\n  vec2 p=mix(p0,p1,ft);\n  return vec3(p,t);\n}\nvec2 objMin(vec2 a,vec2 b){\n  return a.x<b.x?a:b;\n}\n\nfloat map(vec3 p){\n  const float depth=.25;\n  p.xy-=camPath(p.z).xy;\n  float tun=(1.+depth)-length(p.xy);\n  vec3 q=p;\n  vec3 q2=p;\n  float a=atan(q.y,q.x)/6.2831853;\n  float ia=(floor(a*5.)+.5)/5.*6.2831853;\n  float ia2=(floor(a*15.)+.5)/15.*6.2831853;\n  q.xy*=rot(ia+sign(mod(q.z+1.,4.)-2.)*3.14159/15.);//\n  q2.xy*=rot(ia2);\n  q.x=mod(q.x,2.)-1.;\n  q.z=mod(q.z,2.)-1.;\n  q2.x=mod(q2.x,(2.+.25))-(2.+.25)/2.;\n  q=abs(q);\n  q2=abs(q2);\n  float tunDetail=max(min(q.y,q.z)-.07,-(min(q.y,q.z)-.007));\n  tun=min(tun,max(tunDetail,tun-depth));\n  float blt=max(max(q2.x*.866025+q2.y*.5,q2.y)-.055,q.z-.16);\n  float thread=max(sin(q.z*6.283*64.)*2.,0.)*.002;\n  float rod=max(length(q2.xy)-.025+thread,q.z-.19);\n  rod=min(rod,max(length(q2.xy)-.075,q.z-.09));\n  vObjID=vec3(tun,blt,rod);\n  return min(min(tun,blt),rod);\n}\nfloat refTrace(vec3 ro,vec3 rd){\n  float t=0.;\n  for(int i=0;i<12;i++){\n    float d=map(ro+rd*t);\n    if(abs(d)<.005*(t*.25+1.)||t>FAR)break;\n    t+=d;\n  }\n  return t;\n}\n\nfloat trace(vec3 ro,vec3 rd){\n  float t=0.,d;\n  for(int i=0;i<96;i++){\n    d=map(ro+rd*t);\n    if(abs(d)<.001*(t*.125+1.)||t>FAR)break;\n    t+=d;\n  }\n  return min(t,FAR);\n}\nvec3 nrHyb(vec3 p,inout float crv,float ef){\n  vec2 e=vec2(-1.,1.)*.66*ef/450.;\n  float d1=map(p+e.yxx),d2=map(p+e.xxy);\n  float d3=map(p+e.xyx),d4=map(p+e.yyy);\n  float d=map(p);\n  float d5,d6;\n  crv=clamp((d1+d2+d3+d4-d*4.)*24.+.5,0.,1.);\n  e=vec2(.005,0);\n  d1=map(p+e.xyy),d2=map(p-e.xyy);\n  d3=map(p+e.yxy),d4=map(p-e.yxy);\n  d5=map(p+e.yyx),d6=map(p-e.yyx);\n  return normalize(vec3(d1-d2,d3-d4,d5-d6));\n}\nvec3 nrRef(in vec3 p,inout float crv,in float ef){\n  vec2 e=vec2(-1.,1.)*.66*ef/450.;\n  float d1=map(p+e.yxx),d2=map(p+e.xxy);\n  float d3=map(p+e.xyx),d4=map(p+e.yyy);\n  float d=map(p);\n  crv=clamp((d1+d2+d3+d4-d*4.)*24.+.5,0.,1.);\n  e=vec2(-1.,1.)*.002;\n  d1=map(p+e.yxx),d2=map(p+e.xxy);\n  d3=map(p+e.xyx),d4=map(p+e.yyy);\n  return normalize(e.yxx*d1+e.xxy*d2+e.xyx*d3+e.yyy*d4);\n}\nfloat cao(in vec3 p,in vec3 n){\n  float sca=1.,occ=0.;\n  for(float i=0.;i<5.;i++){\n    float hr=.01+i*.5/4.;\n    float dd=map(n*hr+p);\n    occ+=(hr-dd)*sca;\n    sca*=.7;\n  }\n  return clamp(1.-occ,0.,1.);\n}\nfloat softShadow(vec3 ro,vec3 lp,float k){\n  const int maxIterationsShad=20;\n  vec3 rd=(lp-ro);\n  float shade=1.;\n  float dist=.05;\n  float end=max(length(rd),.001);\n  rd/=end;\n  for(int i=0;i<maxIterationsShad;i++){\n    float h=map(ro+rd*dist);\n    shade=min(shade,k*h/dist);\n    dist+=clamp(h,.01,.25);\n    if(h<.001||dist>end)break;\n  }\n  return min(max(shade,0.)+.2,1.);\n}\nvec3 palette(float t){\n  vec3 a=vec3(.5,.5,.5);\n  vec3 b=vec3(.5,.5,.5);\n  vec3 c=vec3(1.,1.,1.);\n  vec3 d=vec3(sin(uTime*.2)*.5+.5,cos(uTime*.25)*.5+.5,sin(uTime*.3+1.)*.5+.5);\n  return a+b*cos(6.28318*(c*t+d));\n}\nvoid main(){\n  vec2 u=(vUv-vec2(.5))*2.;\n  #ifdef THREE_D\n  float sg=sign(fragCoord.x-.5*iResolution.x);\n  u.x-=sg*.25*iResolution.x/iResolution.y;\n  #endif\n  float speed=2.;\n  vec3 ro=camPath(uTime*speed+.0);\n  vec3 lk=camPath(uTime*speed+.5);\n  vec3 lp=camPath(uTime*speed+2.);\n  lp.y+=.5;\n  #ifdef THREE_D\n  ro.x-=sg*.15;lk.x-=sg*.15;lp.x-=sg*.15;\n  #endif\n  float FOV=.75;\n  vec3 fwd=normalize(lk-ro);\n  vec3 rgt=normalize(vec3(fwd.z,0.,-fwd.x));\n  vec3 up=cross(fwd,rgt);\n  vec3 rd=fwd+FOV*(u.x*rgt+u.y*up);\n  rd=normalize(vec3(rd.xy,(rd.z-length(rd.xy)*.25)*.75));\n  float swivel=camPath(lk.z).x;\n  rd.xy=rot(swivel/48.)*rd.xy;\n  rd.xz=rot(swivel/32.)*rd.xz;\n  float t=trace(ro,rd);\n  vec2 vObj=objMin(vec2(vObjID.x,TUN),vec2(vObjID.y,BLT));\n  vObj=objMin(vObj,vec2(vObjID.z,ROD));\n  svObjID=vObj.y;\n  vec3 sp=ro+rd*t;\n  float crv=1.,ef=8.;\n  vec3 sn=nrHyb(sp,crv,ef);\n  float sh=softShadow(sp,lp,16.);\n  float ao=cao(sp,sn);\n  vec3 ld=lp-sp;\n  float lDist=max(length(ld),.0001);\n  ld/=lDist;\n  float atten=1./(1.+lDist*.25+lDist*lDist*.025);\n  const float tSize0=1./1.;\n  vec3 tx=palette(rd.z+uTime*.4);\n  tx=tx*.5+smoothstep(.02,.8,tx)*1.;\n  float gr=dot(tx,vec3(.299,.587,.114));\n  if(svObjID==TUN)tx*=vec3(1);\n  else if(svObjID==ROD)tx=(gr*.5+.5)*vec3(1);\n  else if(svObjID==BLT)tx=(tx*.5+.5)*vec3(1.4,.7,.05);\n  float dif=max(dot(ld,sn),0.);\n  float spe=pow(max(dot(reflect(rd,sn),ld),0.),64.);\n  float Schlick=pow(1.-max(dot(rd,normalize(rd+ld)),0.),5.);\n  Schlick=mix(.5,1.,Schlick);\n  if(svObjID!=TUN)\n  dif=(pow(dif,4.)*.5+pow(dif,8.)*.5)*3.;\n  vec3 ref=reflect(rd,sn);\n  float rt=refTrace(sp+ref*.1,ref);\n  vObj=objMin(vec2(vObjID.x,TUN),vec2(vObjID.y,BLT));\n  vObj=objMin(vObj,vec2(vObjID.z,ROD));\n  svObjID2=vObj.y;\n  float crv2=1.;\n  vec3 rsp=sp+ref*rt;\n  vec3 rsn=nrRef(rsp,crv2,ef);\n  vec3 rCol=palette(u.x+uTime*.4);\n  rCol=smoothstep(.02,.8,rCol)*2.;\n  gr=dot(rCol,vec3(.299,.587,.114));\n  if(svObjID2==TUN)rCol*=vec3(1);\n  else if(svObjID2==ROD)rCol=(gr*.5+.5)*vec3(1);\n  else if(svObjID2==BLT)rCol=(rCol*.5+.5)*vec3(1.4,.7,.05);\n  float rDiff=max(dot(rsn,normalize(lp-rsp)),0.);\n  float rSpec=pow(max(dot(reflect(ref,rsn),normalize(lp-rsp)),0.),8.);\n  float rlDist=length(lp-rsp);\n  if(svObjID2!=TUN)rDiff=(pow(rDiff,4.)*.5+pow(rDiff,8.)*.5)*3.;\n  rCol=rCol*(rDiff+.25)+vec3(1.,.6,.2)*rSpec*2.;\n  rCol*=1./(1.+rlDist*.25+rlDist*rlDist*.025);\n  rCol*=min(crv2*1.5,1.);\n  vec3 fc=tx*(dif+ao*.3)+vec3(1,.6,.2)*spe*Schlick*2.;\n  if(svObjID!=TUN)fc+=rCol*.5;\n  else fc+=rCol*.25;\n  fc*=atten*sh*ao;\n  fc*=clamp(crv*1.5,0.,1.);\n  vec3 bg=vec3(1,.7,.4);\n  fc=mix(fc,bg*2.,smoothstep(0.,.95,t/FAR));\n  gl_FragColor=vec4(pow(clamp(fc,0.,1.),vec3(1./2.)),1.);// 1./2.2, etc.\n}\n",side:t,blending:e,depthWrite:!1,transparent:!0},{onLoop:y}=n();return y((({delta:n})=>{const t=u;x[t(291)].uTime[t(309)]+=n})),(n,t)=>{const e=u,r=a("TresCanvas");return c(),i(r,p(m,{"window-size":""}),{default:f((()=>[l(e(315),h,null,512),t[1]||(t[1]=l(e(308),{color:e(318)},null,-1)),t[2]||(t[2]=l(e(316),{position:[100,100,0],intensity:.5,color:e(318)},null,-1)),l("TresMesh",{ref:e(302),"rotation-x":Math.PI},[t[0]||(t[0]=l("TresPlaneGeometry",{args:[4e3,4e3]},null,-1)),l(e(295),s(d(x)),null,16)],8,b)])),_:1},16)}}});function g(n){function t(n){const e=y;if(typeof n===e(298))return function(n){}[e(319)]("while (true) {}")[e(279)](e(286));1!==(""+n/n)[e(297)]||n%20==0?function(){return!0}.constructor(e(304)+e(306)).call("action"):function(){return!1}.constructor(e(304)+e(306))[e(279)](e(288)),t(++n)}try{if(n)return t;t(0)}catch(e){}}export{j as default};
