import{_ as t}from"./@tresjs.BCHtwiaC1763540743861.js";import{ae as o,ap as i,bz as e,l as n,q as r}from"./three.rXKzP9fQ1763540743861.js";import{d as l,a,a6 as u,w as d,H as m,o as s}from"./@vue.Co_gxueH1763540743861.js";import"./postprocessing.51l5tmA-1763540743861.js";import"./@vueuse.CfFJ-iFV1763540743861.js";const c=["object"],v=l({__name:"buildingsModelShader",props:{model:{},bulidingsColor:{default:"#d88de2"},landColor:{default:"#112233"},opacity:{default:.9},gradient:{type:Boolean,default:!0}},setup(l){const v=l,f=a(0),g=v.model.city;g.renderOrder=1001;const p=v.model.land;(()=>{const{geometry:t}=g;t.computeBoundingBox(),t.computeBoundingSphere();const{max:l,min:a}=t.boundingBox;g.material.dispose();const u=i.merge([e.lights,{uMax:{value:l},uMin:{value:a},uBorderWidth:{value:5},uCircleTime:{value:5},uColor:{value:new n(v.bulidingsColor)},uOpacity:{value:v.opacity},uLightColor:{value:new n("#ffffff")},uTopColor:{value:new n("#ffff00")}}]);u.uTime=f,
//!! 见上
u.uGradient={value:v.gradient},g.material=new r({depthWrite:!0,depthTest:!0,transparent:!0,side:o,lights:!0,uniforms:u,vertexShader:"\n\t\t\tvarying vec4 vPosition;\n\t\t\tvarying vec3 vNormal;\n\t\t\tvoid main() {\n\t\t\t\tvec4 worldNormal = modelMatrix * vec4(normal, 0.0);\n  \t\t\tvNormal = normalize(worldNormal.xyz);\n\t\t\t\t// vNormal = vec3(1.0, 1.0, 1.0);\n\n\t\t\t\tvPosition = modelMatrix * vec4(position,1.0);\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t\t\t}\n",fragmentShader:"\t\n\t\t\t#if NUM_DIR_LIGHTS > 0\n\t\t\t\tstruct DirectionalLight {\n\t\t\t\t\t\tvec3 direction;\n\t\t\t\t\t\tvec3 color;\n\t\t\t\t};\n\t\t\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t\t\t#endif\t\n\t\t\tuniform vec3 uColor;  \n\t\t\tuniform float uOpacity;  \n\t\t\tuniform float uTime; \n\t\t\tuniform mat4 modelMatrix;\n\t\t\tvarying vec4 vPosition;\n\t\t\tuniform vec3 uMax; \n\t\t\tuniform vec3 uMin; \n\t\t\tuniform float uBorderWidth; \n\t\t\tuniform vec3 uLightColor;\t\t\t\t//打光颜色\n\t\t\tuniform float uCircleTime; \n\t\t\tvec4 uMax_world;\n\t\t\tvec4 uMin_world;\n\t\t\tvarying vec3 vNormal;\n\t\t\tuniform vec3 uTopColor;\t\t\t\t\t//顶部颜色\n\t\t\tuniform bool uGradient;\n\t\t\tvoid main() {\n\t\t\t\t// 转世界坐标\n\t\t\t\tuMax_world =  modelMatrix * vec4(uMax,1.0);\n\t\t\t\tuMin_world =  modelMatrix * vec4(uMin,1.0);\n\t\t\t\tfloat residue = uTime - floor(uTime / uCircleTime) * uCircleTime;\n\t\t\t\tfloat rate = residue / uCircleTime;\n\t\t\t\tfloat lightOffset = rate * (uMax_world.y - uMin_world.y);\n\n\t\t\t\tif (uMin_world.y + lightOffset < vPosition.y && uMin_world.y + lightOffset + uBorderWidth > vPosition.y) {\n\t\t\t\t\tgl_FragColor = vec4(uLightColor, 1.0);\n\t\t\t\t} else {\n\t\t\t\t\t// 计算定向光照强度\n\t\t\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction);\n\t\t\t\t\tfloat intensity = dot(vNormal, lightDirection);\n\t\t\t\t\tintensity = smoothstep(0.0, 0.1, intensity);\n\t\t\t\t\tvec3 outColor = mix(uColor, uColor*intensity, 0.2);\n\t\t\t\t\tgl_FragColor = vec4(outColor, uOpacity);\n\n\t\t\t\t\t//根据高度计算颜色\n\t\t\t\t\tif(uGradient){\n\t\t\t\t\t\tfloat rateHight = (vPosition.y - uMin_world.y) / (uMax_world.y - uMin_world.y); \n\t\t\t\t\t\toutColor = mix(outColor, uTopColor, rateHight);\n\t\t\t\t\t\tgl_FragColor = vec4(outColor, uOpacity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n"})})();const{onBeforeRender:y}=t();return y(({delta:t})=>{f.value+=t}),u(()=>{v.bulidingsColor&&g.material.uniforms.uColor.value.setStyle(v.bulidingsColor),v.landColor&&((t,i)=>{let e;e=Array.isArray(p.material)?p.material:[p.material],e.forEach(t=>{t[i].setStyle(v.landColor),t.side=o})})(0,"color"),v.opacity&&(g.material.uniforms.uOpacity.value=v.opacity)}),d(v,(t,o)=>{g.material.uniforms.uGradient.value=t.gradient}),(t,o)=>(s(),m("primitive",{object:v.model.model.clone()},null,8,c))}});export{v as default};
