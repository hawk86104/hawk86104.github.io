import{e,g as n}from"./@tresjs.CIKSfeCC1746335712058.js";import{ah as t,C as a,ab as r,T as s}from"./three.Bj3hPI0l1746335712058.js";import{z as i}from"./three-custom-shader-material.CpCBu6881746335712058.js";import{p as o}from"./gl-noise.DYSJzQjl1746335712058.js";import{d as l,b as g,a3 as v,w as h,H as f,o as u,J as c,j as m,u as p}from"./@vue.DK6ok9LJ1746335712058.js";const d=["rotation-x"],b=["args"],w=l({__name:"customWaterMesh",props:{height:{default:.2},Flatshading:{type:Boolean,default:!1},waterColor:{default:"#52a7f7"},waterHighlight:{default:"#b3ffff"},brightness:{default:1},baseMaterial:{default:t}},setup(l){const w=l,_=g(null),x={vertex:"\nuniform float uTime;\nuniform float uHeight;\nvarying float vHeight;\n\nvec3 displace(vec3 point) {\n  vec3 p = point;\n  p.y += uTime * 2.0;\n  gln_tFBMOpts fbmOpts = gln_tFBMOpts(1.0, 0.4, 2.3, 0.4, 1.0, 5, false, false);\n  gln_tGerstnerWaveOpts A = gln_tGerstnerWaveOpts(vec2(0.0, -1.0), 0.5, 2.0);\n  gln_tGerstnerWaveOpts B = gln_tGerstnerWaveOpts(vec2(0.0, 1.0), 0.25, 4.0);\n  gln_tGerstnerWaveOpts C = gln_tGerstnerWaveOpts(vec2(1.0, 1.0), 0.15, 6.0);\n  gln_tGerstnerWaveOpts D = gln_tGerstnerWaveOpts(vec2(1.0, 1.0), 0.4, 2.0);\n  vec3 n = vec3(0.0);\n  if(p.z >= uHeight / 2.0) {\n      n.z += gln_normalize(gln_pfbm(p.xy + (uTime * 0.5), fbmOpts));\n      n += gln_GerstnerWave(p, A, uTime).xzy;\n      n += gln_GerstnerWave(p, B, uTime).xzy * 0.5;\n      n += gln_GerstnerWave(p, C, uTime).xzy * 0.25;\n      n += gln_GerstnerWave(p, D, uTime).xzy * 0.2;\n  }\n  vHeight = n.z;\n  return point + n;\n}\n\nvec3 orthogonal(vec3 v) {\n  return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n  : vec3(0.0, -v.z, v.y));\n}\n\nvec3 recalcNormals(vec3 newPos) {\n  float offset = 0.001;\n  vec3 tangent = orthogonal(normal);\n  vec3 bitangent = normalize(cross(normal, tangent));\n  vec3 neighbour1 = position + tangent * offset;\n  vec3 neighbour2 = position + bitangent * offset;\n\n  vec3 displacedNeighbour1 = displace(neighbour1);\n  vec3 displacedNeighbour2 = displace(neighbour2);\n\n  vec3 displacedTangent = displacedNeighbour1 - newPos;\n  vec3 displacedBitangent = displacedNeighbour2 - newPos;\n\n  return normalize(cross(displacedTangent, displacedBitangent));\n}\n\nvoid main() {\n  csm_Position = displace(position);\n  csm_Normal = recalcNormals(csm_Position);\n}\n\t",fragment:"\nvarying float vHeight;\nuniform vec3 waterColor;\nuniform vec3 waterHighlight;\nuniform float offset;\nuniform float contrast;\nuniform float brightness;\n\nvec3 calcColor() {\n  float mask = (pow(vHeight, 2.) - offset) * contrast;\n  vec3 diffuseColor = mix(waterColor, waterHighlight, mask);\n  diffuseColor *= brightness;\n  return diffuseColor;\n}\n\nvoid main() {\n  csm_DiffuseColor = vec4(calcColor(), 1.0);\n}\n\t"},T={uTime:{value:0},waterColor:{value:new a(w.waterColor).convertLinearToSRGB()},waterHighlight:{value:new a(w.waterHighlight).convertLinearToSRGB()},offset:{value:.4},contrast:{value:3.1},brightness:{value:w.brightness},uHeight:{value:w.height}},{onLoop:C}=e();return C((({elapsed:e})=>{T.uTime.value=-e/5})),v((()=>{w.height&&(T.uHeight.value=w.height),w.waterColor&&(T.waterColor.value=new a(w.waterColor).convertLinearToSRGB()),w.waterHighlight&&(T.waterHighlight.value=new a(w.waterHighlight).convertLinearToSRGB()),w.brightness&&(T.brightness.value=w.brightness)})),h((()=>w.Flatshading),(e=>{_.value.material.needsUpdate=!0})),h((()=>w.baseMaterial),(e=>{const n=new i({baseMaterial:s[e],vertexShader:o(x.vertex),fragmentShader:x.fragment,uniforms:T,flatShading:w.Flatshading,side:r,roughness:.2,metalness:.1,silent:!0});_.value.material.dispose(),_.value.material=n})),(e,a)=>(u(),f("TresMesh",{ref_key:"tmRef",ref:_,"rotation-x":-Math.PI/2},[c("TresBoxGeometry",{args:[5,5,e.height,64,64,1]},null,8,b),m(p(n),{baseMaterial:t,vertexShader:p(o)(x.vertex),fragmentShader:x.fragment,uniforms:T,side:r,roughness:.2,metalness:.1,flatShading:e.Flatshading,silent:""},null,8,["baseMaterial","vertexShader","fragmentShader","side","flatShading"])],8,d))}});export{w as _};
