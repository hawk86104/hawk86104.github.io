import{E as e,a as t,B as n,R as r,S as i,M as a,K as o,b as s,P as c}from"./postprocessing.51l5tmA-1763540743861.js";import{V as u,M as l,b as h,aC as d,r as m,a3 as p,aE as f,az as v,aF as g,aG as S,Q as w,R as y,v as _,aH as x,U as T,aI as E,aJ as A,aK as R,a2 as C,a5 as D,a4 as I,j as O,aL as N,t as b,k as P,B as L,S as M,ao as U,ar as H,aM as F,aN as z,aO as G,f as B,l as W,aP as k,aQ as V,p as j,aR as Y,aS as X,H as q,q as K,aT as Z,c as J,y as $,ad as Q,A as ee,aU as te}from"./three.rXKzP9fQ1763540743861.js";function ne(e,t){if(!e)throw new Error("Invariant failed")}const re=new u;function ie(e,t,n=new u,r){const{x:i,y:a,z:o}=e,s=t.x,c=t.y,l=t.z,h=i*i*s,d=a*a*c,m=o*o*l,p=h+d+m,f=Math.sqrt(1/p);if(!Number.isFinite(f))return;const v=re.copy(e).multiplyScalar(f);if(p<((null==r?void 0:r.centerTolerance)??.1))return n.copy(v);const g=v.multiply(t).multiplyScalar(2);let S,w,y,_,x=(1-f)*e.length()/(g.length()/2),T=0;do{x-=T,S=1/(1+x*s),w=1/(1+x*c),y=1/(1+x*l);const e=S*S,t=w*w,n=y*y;_=h*e+d*t+m*n-1,T=_/(-2*(h*(e*S)*s+d*(t*w)*c+m*(n*y)*l))}while(Math.abs(_)>1e-12);return n.set(i*S,a*w,o*y)}const ae=new u,oe=new u,se=new u,ce=class{constructor(e,t,n){this.radii=new u(e,t,n)}get minimumRadius(){return Math.min(this.radii.x,this.radii.y,this.radii.z)}get maximumRadius(){return Math.max(this.radii.x,this.radii.y,this.radii.z)}reciprocalRadii(e=new u){const{x:t,y:n,z:r}=this.radii;return e.set(1/t,1/n,1/r)}reciprocalRadiiSquared(e=new u){const{x:t,y:n,z:r}=this.radii;return e.set(1/t**2,1/n**2,1/r**2)}projectOnSurface(e,t=new u,n){return ie(e,this.reciprocalRadiiSquared(),t,n)}getSurfaceNormal(e,t=new u){return t.multiplyVectors(this.reciprocalRadiiSquared(ae),e).normalize()}getEastNorthUpVectors(e,t=new u,n=new u,r=new u){this.getSurfaceNormal(e,r),t.set(-e.y,e.x,0).normalize(),n.crossVectors(r,t).normalize()}getEastNorthUpFrame(e,t=new l){const n=ae,r=oe,i=se;return this.getEastNorthUpVectors(e,n,r,i),t.makeBasis(n,r,i).setPosition(e)}getNorthUpEastFrame(e,t=new l){const n=ae,r=oe,i=se;return this.getEastNorthUpVectors(e,n,r,i),t.makeBasis(r,i,n).setPosition(e)}getIntersection(e,t=new u){const n=this.reciprocalRadii(ae),r=oe.copy(n).multiply(e.origin),i=se.copy(n).multiply(e.direction),a=r.lengthSq(),o=i.lengthSq(),s=r.dot(i),c=s**2-o*(a-1);if(1===a)return t.copy(e.origin);if(a>1){if(s>=0||c<0)return;const n=Math.sqrt(c),r=(-s-n)/o,i=(-s+n)/o;return e.at(Math.min(r,i),t)}if(a<1){const n=s**2-o*(a-1),r=(-s+Math.sqrt(n))/o;return e.at(r,t)}return s<0?e.at(-s/o,t):void 0}getOsculatingSphereCenter(e,t,n=new u){ne(this.radii.x===this.radii.y);const r=this.radii.x**2,i=this.radii.z**2,a=ae.set(e.x/r,e.y/r,e.z/i).normalize();return n.copy(a.multiplyScalar(-t).add(e))}getNormalAtHorizon(e,t,n=new u){ne(this.radii.x===this.radii.y);const r=this.radii.x**2,i=this.radii.z**2,a=e,o=t;let s=(a.x*o.x+a.y*o.y)/r+a.z*o.z/i;s/=(a.x**2+a.y**2)/r+a.z**2/i;const c=ae.copy(o).multiplyScalar(-s).add(e);return n.set(c.x/r,c.y/r,c.z/i).normalize()}};ce.WGS84=new ce(6378137,6378137,6356752.314245179);let ue=ce;const le=new u,he=new u,de=class e{constructor(e=0,t=0,n=0){this.longitude=e,this.latitude=t,this.height=n}set(e,t,n){return this.longitude=e,this.latitude=t,null!=n&&(this.height=n),this}clone(){return new e(this.longitude,this.latitude,this.height)}copy(e){return this.longitude=e.longitude,this.latitude=e.latitude,this.height=e.height,this}equals(e){return e.longitude===this.longitude&&e.latitude===this.latitude&&e.height===this.height}setLongitude(e){return this.longitude=e,this}setLatitude(e){return this.latitude=e,this}setHeight(e){return this.height=e,this}normalize(){return this.longitude<e.MIN_LONGITUDE&&(this.longitude+=2*Math.PI),this}setFromECEF(e,t){const n=((null==t?void 0:t.ellipsoid)??ue.WGS84).reciprocalRadiiSquared(le),r=ie(e,n,he,t);if(null==r)throw new Error(`Could not project position to ellipsoid surface: ${e.toArray()}`);const i=le.multiplyVectors(r,n).normalize();this.longitude=Math.atan2(i.y,i.x),this.latitude=Math.asin(i.z);const a=le.subVectors(e,r);return this.height=Math.sign(a.dot(e))*a.length(),this}toECEF(e=new u,t){const n=(null==t?void 0:t.ellipsoid)??ue.WGS84,r=le.multiplyVectors(n.radii,n.radii),i=Math.cos(this.latitude),a=he.set(i*Math.cos(this.longitude),i*Math.sin(this.longitude),Math.sin(this.latitude)).normalize();return e.multiplyVectors(r,a),e.divideScalar(Math.sqrt(a.dot(e))).add(a.multiplyScalar(this.height))}fromArray(e,t=0){return this.longitude=e[t],this.latitude=e[t+1],this.height=e[t+2],this}toArray(e=[],t=0){return e[t]=this.longitude,e[t+1]=this.latitude,e[t+2]=this.height,e}*[Symbol.iterator](){yield this.longitude,yield this.latitude,yield this.height}};de.MIN_LONGITUDE=-Math.PI,de.MAX_LONGITUDE=Math.PI,de.MIN_LATITUDE=-Math.PI/2,de.MAX_LATITUDE=Math.PI/2;let me=de;class pe extends d{load(e,t,n,r){const i=new b(this.manager);i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setPath(this.path),i.setWithCredentials(this.withCredentials),i.load(e,n=>{ne(n instanceof ArrayBuffer);try{t(n)}catch(hi){null!=r?r(hi):console.error(hi),this.manager.itemError(e)}},n,r)}}function fe(e){var t;const{attributes:n,index:r,boundingBox:i,boundingSphere:a}=e;return[{attributes:n,index:r,boundingBox:i,boundingSphere:a},[...Object.values(e.attributes).map(e=>e.array.buffer),null==(t=e.index)?void 0:t.array.buffer].filter(e=>null!=e)]}function ve(e,t=new O){for(const[n,r]of Object.entries(e.attributes))t.setAttribute(n,new P(r.array,r.itemSize,r.normalized));if(t.index=null!=e.index?new P(e.index.array,e.index.itemSize,e.index.normalized):null,null!=e.boundingBox){const{min:n,max:r}=e.boundingBox;t.boundingBox=new L(new u(n.x,n.y,n.z),new u(r.x,r.y,r.z))}if(null!=e.boundingSphere){const{center:n,radius:r}=e.boundingSphere;t.boundingSphere=new M(new u(n.x,n.y,n.z),r)}return t}const ge="This constructor is not a subclass of Float16Array",Se="The constructor property value is not an object",we="Attempting to access detached ArrayBuffer",ye="Cannot convert undefined or null to object",_e="Cannot mix BigInt and other types, use explicit conversions",xe="@@iterator property is not callable",Te="Reduce of empty array with no initial value",Ee="Offset is out of bounds";function Ae(e){return(t,...n)=>Ce(e,t,n)}function Re(e,t){return Ae(Ne(e,t).get)}const{apply:Ce,construct:De,defineProperty:Ie,get:Oe,getOwnPropertyDescriptor:Ne,getPrototypeOf:be,has:Pe,ownKeys:Le,set:Me,setPrototypeOf:Ue}=Reflect,He=Proxy,{EPSILON:Fe,MAX_SAFE_INTEGER:ze,isFinite:Ge,isNaN:Be}=Number,{iterator:We,species:ke,toStringTag:Ve,for:je}=Symbol,Ye=Object,{create:Xe,defineProperty:qe,freeze:Ke,is:Ze}=Ye,Je=Ye.prototype,$e=Je.__lookupGetter__?Ae(Je.__lookupGetter__):(e,t)=>{if(null==e)throw jt(ye);let n=Ye(e);do{const e=Ne(n,t);if(void 0!==e)return Qe(e,"get")?e.get:void 0}while(null!==(n=be(n)))},Qe=Ye.hasOwn||Ae(Je.hasOwnProperty),et=Array,tt=et.isArray,nt=et.prototype,rt=Ae(nt.join),it=Ae(nt.push),at=Ae(nt.toLocaleString),ot=nt[We],st=Ae(ot),{abs:ct,trunc:ut}=Math,lt=ArrayBuffer,ht=lt.isView,dt=lt.prototype,mt=Ae(dt.slice),pt=Re(dt,"byteLength"),ft=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:null,vt=ft&&Re(ft.prototype,"byteLength"),gt=be(Uint8Array),St=gt.from,wt=gt.prototype,yt=wt[We],_t=Ae(wt.keys),xt=Ae(wt.values),Tt=Ae(wt.entries),Et=Ae(wt.set),At=Ae(wt.reverse),Rt=Ae(wt.fill),Ct=Ae(wt.copyWithin),Dt=Ae(wt.sort),It=Ae(wt.slice),Ot=Ae(wt.subarray),Nt=Re(wt,"buffer"),bt=Re(wt,"byteOffset"),Pt=Re(wt,"length"),Lt=Re(wt,Ve),Mt=Uint8Array,Ut=Uint16Array,Ht=(...e)=>Ce(St,Ut,e),Ft=Uint32Array,zt=Float32Array,Gt=be([][We]()),Bt=Ae(Gt.next),Wt=Ae(function*(){}().next),kt=be(Gt),Vt=Ae(DataView.prototype.getUint16),jt=TypeError,Yt=RangeError,Xt=WeakSet,qt=Xt.prototype,Kt=Ae(qt.add),Zt=Ae(qt.has),Jt=WeakMap,$t=Jt.prototype,Qt=Ae($t.get),en=Ae($t.has),tn=Ae($t.set),nn=new Jt,rn=Xe(null,{next:{value:function(){const e=Qt(nn,this);return Bt(e)}},[We]:{value:function(){return this}}});function an(e){if(e[We]===ot&&Gt.next===Bt)return e;const t=Xe(rn);return tn(nn,t,st(e)),t}const on=new Jt,sn=Xe(kt,{next:{value:function(){const e=Qt(on,this);return Wt(e)},writable:!0,configurable:!0}});for(const fc of Le(Gt))"next"!==fc&&qe(sn,fc,Ne(Gt,fc));function cn(e){const t=Xe(sn);return tn(on,t,e),t}function un(e){return null!==e&&"object"==typeof e||"function"==typeof e}function ln(e){return null!==e&&"object"==typeof e}function hn(e){return void 0!==Lt(e)}function dn(e){const t=Lt(e);return"BigInt64Array"===t||"BigUint64Array"===t}function mn(e){if(null===ft)return!1;try{return vt(e),!0}catch{return!1}}function pn(e){return function(e){try{return!tt(e)&&(pt(e),!0)}catch{return!1}}(e)||mn(e)}function fn(e){return!!tt(e)&&(e[We]===ot&&Gt.next===Bt)}function vn(e){if("string"!=typeof e)return!1;const t=+e;return!(e!==t+""||!Ge(t))&&t===ut(t)}const gn=je("__Float16Array__");const Sn=1/Fe;const wn=6103515625e-14,yn=.0009765625,_n=yn*wn,xn=yn*Sn;function Tn(e){const t=+e;if(!Ge(t)||0===t)return t;const n=t>0?1:-1,r=ct(t);if(r<wn)return n*function(e){return e+Sn-Sn}(r/_n)*_n;const i=(1+xn)*r,a=i-(i-r);return a>65504||Be(a)?n*(1/0):n*a}const En=new lt(4),An=new zt(En),Rn=new Ft(En),Cn=new Ut(512),Dn=new Mt(512);for(let fc=0;fc<256;++fc){const e=fc-127;e<-24?(Cn[fc]=0,Cn[256|fc]=32768,Dn[fc]=24,Dn[256|fc]=24):e<-14?(Cn[fc]=1024>>-e-14,Cn[256|fc]=1024>>-e-14|32768,Dn[fc]=-e-1,Dn[256|fc]=-e-1):e<=15?(Cn[fc]=e+15<<10,Cn[256|fc]=e+15<<10|32768,Dn[fc]=13,Dn[256|fc]=13):e<128?(Cn[fc]=31744,Cn[256|fc]=64512,Dn[fc]=24,Dn[256|fc]=24):(Cn[fc]=31744,Cn[256|fc]=64512,Dn[fc]=13,Dn[256|fc]=13)}function In(e){An[0]=Tn(e);const t=Rn[0],n=t>>23&511;return Cn[n]+((8388607&t)>>Dn[n])}const On=new Ft(2048);for(let fc=1;fc<1024;++fc){let e=fc<<13,t=0;for(;!(8388608&e);)e<<=1,t-=8388608;e&=-8388609,t+=947912704,On[fc]=e|t}for(let fc=1024;fc<2048;++fc)On[fc]=939524096+(fc-1024<<13);const Nn=new Ft(64);for(let fc=1;fc<31;++fc)Nn[fc]=fc<<23;Nn[31]=1199570944,Nn[32]=2147483648;for(let fc=33;fc<63;++fc)Nn[fc]=2147483648+(fc-32<<23);Nn[63]=3347054592;const bn=new Ut(64);for(let fc=1;fc<64;++fc)32!==fc&&(bn[fc]=1024);function Pn(e){const t=e>>10;return Rn[0]=On[bn[t]+(1023&e)]+Nn[t],An[0]}function Ln(e){const t=+e;return Be(t)||0===t?0:ut(t)}function Mn(e){const t=Ln(e);return t<0?0:t<ze?t:ze}function Un(e,t){if(!un(e))throw jt("This is not an object");const n=e.constructor;if(void 0===n)return t;if(!un(n))throw jt(Se);return n[ke]??t}function Hn(e){if(mn(e))return!1;try{return mt(e,0,0),!1}catch{}return!0}function Fn(e,t){const n=Be(e),r=Be(t);if(n&&r)return 0;if(n)return 1;if(r||e<t)return-1;if(e>t)return 1;if(0===e&&0===t){const n=Ze(e,0),r=Ze(t,0);if(!n&&r)return-1;if(n&&!r)return 1}return 0}const zn=new Jt;function Gn(e){return en(zn,e)||!ht(e)&&function(e){if(!ln(e))return!1;const t=be(e);if(!ln(t))return!1;const n=t.constructor;if(void 0===n)return!1;if(!un(n))throw jt(Se);return Pe(n,gn)}(e)}function Bn(e){if(!Gn(e))throw jt("This is not a Float16Array object")}function Wn(e,t){const n=Gn(e),r=hn(e);if(!n&&!r)throw jt("Species constructor didn't return TypedArray object");if("number"==typeof t){let r;if(n){const t=kn(e);r=Pt(t)}else r=Pt(e);if(r<t)throw jt("Derived constructor created TypedArray object which was too small length")}if(dn(e))throw jt(_e)}function kn(e){const t=Qt(zn,e);if(void 0!==t){if(Hn(Nt(t)))throw jt(we);return t}const n=e.buffer;if(Hn(n))throw jt(we);const r=De(Xn,[n,e.byteOffset,e.length],e.constructor);return Qt(zn,r)}function Vn(e){const t=Pt(e),n=[];for(let r=0;r<t;++r)n[r]=Pn(e[r]);return n}const jn=new Xt;for(const fc of Le(wt)){if(fc===Ve)continue;const e=Ne(wt,fc);Qe(e,"get")&&"function"==typeof e.get&&Kt(jn,e.get)}const Yn=Ke({get:(e,t,n)=>vn(t)&&Qe(e,t)?Pn(Oe(e,t)):Zt(jn,$e(e,t))?Oe(e,t):Oe(e,t,n),set:(e,t,n,r)=>vn(t)&&Qe(e,t)?Me(e,t,In(n)):Me(e,t,n,r),getOwnPropertyDescriptor(e,t){if(vn(t)&&Qe(e,t)){const n=Ne(e,t);return n.value=Pn(n.value),n}return Ne(e,t)},defineProperty:(e,t,n)=>(vn(t)&&Qe(e,t)&&Qe(n,"value")&&(n.value=In(n.value)),Ie(e,t,n))});let Xn=class e{constructor(e,t,n){let r;if(Gn(e))r=De(Ut,[kn(e)],new.target);else if(un(e)&&!pn(e)){let t,n;if(hn(e)){t=e,n=Pt(e);if(Hn(Nt(e)))throw jt(we);if(dn(e))throw jt(_e);const i=new lt(2*n);r=De(Ut,[i],new.target)}else{const i=e[We];if(null!=i&&"function"!=typeof i)throw jt(xe);null!=i?fn(e)?(t=e,n=e.length):(t=[...e],n=t.length):(t=e,n=Mn(t.length)),r=De(Ut,[n],new.target)}for(let e=0;e<n;++e)r[e]=In(t[e])}else r=De(Ut,arguments,new.target);const i=new He(r,Yn);return tn(zn,i,r),i}static from(t,...n){const r=this;if(!Pe(r,gn))throw jt(ge);if(r===e){if(Gn(t)&&0===n.length){const n=kn(t),r=new Ut(Nt(n),bt(n),Pt(n));return new e(Nt(It(r)))}if(0===n.length)return new e(Nt(Ht(t,In)));const r=n[0],i=n[1];return new e(Nt(Ht(t,function(e,...t){return In(Ce(r,this,[e,...an(t)]))},i)))}let i,a;const o=t[We];if(null!=o&&"function"!=typeof o)throw jt(xe);if(null!=o)fn(t)?(i=t,a=t.length):function(e){return!!hn(e)&&e[We]===yt&&Gt.next===Bt}(t)?(i=t,a=Pt(t)):(i=[...t],a=i.length);else{if(null==t)throw jt(ye);i=Ye(t),a=Mn(i.length)}const s=new r(a);if(0===n.length)for(let e=0;e<a;++e)s[e]=i[e];else{const e=n[0],t=n[1];for(let n=0;n<a;++n)s[n]=Ce(e,t,[i[n],n])}return s}static of(...t){const n=this;if(!Pe(n,gn))throw jt(ge);const r=t.length;if(n===e){const n=new e(r),i=kn(n);for(let e=0;e<r;++e)i[e]=In(t[e]);return n}const i=new n(r);for(let e=0;e<r;++e)i[e]=t[e];return i}keys(){Bn(this);const e=kn(this);return _t(e)}values(){Bn(this);const e=kn(this);return cn(function*(){for(const t of xt(e))yield Pn(t)}())}entries(){Bn(this);const e=kn(this);return cn(function*(){for(const[t,n]of Tt(e))yield[t,Pn(n)]}())}at(e){Bn(this);const t=kn(this),n=Pt(t),r=Ln(e),i=r>=0?r:n+r;if(!(i<0||i>=n))return Pn(t[i])}with(t,n){Bn(this);const r=kn(this),i=Pt(r),a=Ln(t),o=a>=0?a:i+a,s=+n;if(o<0||o>=i)throw Yt(Ee);const c=new Ut(Nt(r),bt(r),Pt(r)),u=new e(Nt(It(c)));return kn(u)[o]=In(s),u}map(t,...n){Bn(this);const r=kn(this),i=Pt(r),a=n[0],o=Un(r,e);if(o===e){const n=new e(i),o=kn(n);for(let e=0;e<i;++e){const n=Pn(r[e]);o[e]=In(Ce(t,a,[n,e,this]))}return n}const s=new o(i);Wn(s,i);for(let e=0;e<i;++e){const n=Pn(r[e]);s[e]=Ce(t,a,[n,e,this])}return s}filter(t,...n){Bn(this);const r=kn(this),i=Pt(r),a=n[0],o=[];for(let e=0;e<i;++e){const n=Pn(r[e]);Ce(t,a,[n,e,this])&&it(o,n)}const s=new(Un(r,e))(o);return Wn(s),s}reduce(e,...t){Bn(this);const n=kn(this),r=Pt(n);if(0===r&&0===t.length)throw jt(Te);let i,a;0===t.length?(i=Pn(n[0]),a=1):(i=t[0],a=0);for(let o=a;o<r;++o)i=e(i,Pn(n[o]),o,this);return i}reduceRight(e,...t){Bn(this);const n=kn(this),r=Pt(n);if(0===r&&0===t.length)throw jt(Te);let i,a;0===t.length?(i=Pn(n[r-1]),a=r-2):(i=t[0],a=r-1);for(let o=a;o>=0;--o)i=e(i,Pn(n[o]),o,this);return i}forEach(e,...t){Bn(this);const n=kn(this),r=Pt(n),i=t[0];for(let a=0;a<r;++a)Ce(e,i,[Pn(n[a]),a,this])}find(e,...t){Bn(this);const n=kn(this),r=Pt(n),i=t[0];for(let a=0;a<r;++a){const t=Pn(n[a]);if(Ce(e,i,[t,a,this]))return t}}findIndex(e,...t){Bn(this);const n=kn(this),r=Pt(n),i=t[0];for(let a=0;a<r;++a){const t=Pn(n[a]);if(Ce(e,i,[t,a,this]))return a}return-1}findLast(e,...t){Bn(this);const n=kn(this),r=Pt(n),i=t[0];for(let a=r-1;a>=0;--a){const t=Pn(n[a]);if(Ce(e,i,[t,a,this]))return t}}findLastIndex(e,...t){Bn(this);const n=kn(this),r=Pt(n),i=t[0];for(let a=r-1;a>=0;--a){const t=Pn(n[a]);if(Ce(e,i,[t,a,this]))return a}return-1}every(e,...t){Bn(this);const n=kn(this),r=Pt(n),i=t[0];for(let a=0;a<r;++a)if(!Ce(e,i,[Pn(n[a]),a,this]))return!1;return!0}some(e,...t){Bn(this);const n=kn(this),r=Pt(n),i=t[0];for(let a=0;a<r;++a)if(Ce(e,i,[Pn(n[a]),a,this]))return!0;return!1}set(e,...t){Bn(this);const n=kn(this),r=Ln(t[0]);if(r<0)throw Yt(Ee);if(null==e)throw jt(ye);if(dn(e))throw jt(_e);if(Gn(e))return Et(kn(this),kn(e),r);if(hn(e)){if(Hn(Nt(e)))throw jt(we)}const i=Pt(n),a=Ye(e),o=Mn(a.length);if(r===1/0||o+r>i)throw Yt(Ee);for(let s=0;s<o;++s)n[s+r]=In(a[s])}reverse(){Bn(this);const e=kn(this);return At(e),this}toReversed(){Bn(this);const t=kn(this),n=new Ut(Nt(t),bt(t),Pt(t)),r=new e(Nt(It(n))),i=kn(r);return At(i),r}fill(e,...t){Bn(this);const n=kn(this);return Rt(n,In(e),...an(t)),this}copyWithin(e,t,...n){Bn(this);const r=kn(this);return Ct(r,e,t,...an(n)),this}sort(e){Bn(this);const t=kn(this),n=void 0!==e?e:Fn;return Dt(t,(e,t)=>n(Pn(e),Pn(t))),this}toSorted(t){Bn(this);const n=kn(this);if(void 0!==t&&"function"!=typeof t)throw new jt("The comparison function must be either a function or undefined");const r=void 0!==t?t:Fn,i=new Ut(Nt(n),bt(n),Pt(n)),a=new e(Nt(It(i))),o=kn(a);return Dt(o,(e,t)=>r(Pn(e),Pn(t))),a}slice(t,n){Bn(this);const r=kn(this),i=Un(r,e);if(i===e){const i=new Ut(Nt(r),bt(r),Pt(r));return new e(Nt(It(i,t,n)))}const a=Pt(r),o=Ln(t),s=void 0===n?a:Ln(n);let c,u;c=o===-1/0?0:o<0?a+o>0?a+o:0:a<o?a:o,u=s===-1/0?0:s<0?a+s>0?a+s:0:a<s?a:s;const l=u-c>0?u-c:0,h=new i(l);if(Wn(h,l),0===l)return h;if(Hn(Nt(r)))throw jt(we);let d=0;for(;c<u;)h[d]=Pn(r[c]),++c,++d;return h}subarray(t,n){Bn(this);const r=kn(this),i=Un(r,e),a=new Ut(Nt(r),bt(r),Pt(r)),o=Ot(a,t,n),s=new i(Nt(o),bt(o),Pt(o));return Wn(s),s}indexOf(e,...t){Bn(this);const n=kn(this),r=Pt(n);let i=Ln(t[0]);if(i===1/0)return-1;i<0&&(i+=r,i<0&&(i=0));for(let a=i;a<r;++a)if(Qe(n,a)&&Pn(n[a])===e)return a;return-1}lastIndexOf(e,...t){Bn(this);const n=kn(this),r=Pt(n);let i=t.length>=1?Ln(t[0]):r-1;if(i===-1/0)return-1;i>=0?i=i<r-1?i:r-1:i+=r;for(let a=i;a>=0;--a)if(Qe(n,a)&&Pn(n[a])===e)return a;return-1}includes(e,...t){Bn(this);const n=kn(this),r=Pt(n);let i=Ln(t[0]);if(i===1/0)return!1;i<0&&(i+=r,i<0&&(i=0));const a=Be(e);for(let o=i;o<r;++o){const t=Pn(n[o]);if(a&&Be(t)||t===e)return!0}return!1}join(e){Bn(this);const t=Vn(kn(this));return rt(t,e)}toLocaleString(...e){Bn(this);const t=Vn(kn(this));return at(t,...an(e))}get[Ve](){if(Gn(this))return"Float16Array"}};qe(Xn,"BYTES_PER_ELEMENT",{value:2}),qe(Xn,gn,{}),Ue(Xn,gt);const qn=Xn.prototype;function Kn(e){return e instanceof Int8Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof Int16Array||e instanceof Uint16Array||e instanceof Int32Array||e instanceof Uint32Array||e instanceof Xn||e instanceof Float32Array||e instanceof Float64Array}qe(qn,"BYTES_PER_ELEMENT",{value:2}),qe(qn,We,{value:qn.values,writable:!0,configurable:!0}),Ue(qn,wt);class Zn extends d{constructor(e,t){super(t),this.parser=e}load(e,t,n,r){const i=new pe(this.manager);i.setRequestHeader(this.requestHeader),i.setPath(this.path),i.setWithCredentials(this.withCredentials),i.load(e,n=>{try{t(this.parser(n))}catch(hi){null!=r?r(hi):console.error(hi),this.manager.itemError(e)}},n,r)}}class Jn extends d{constructor(e,t,n={},r){super(r),this.textureClass=e,this.parser=t,this.options={format:p,minFilter:m,magFilter:m,...n}}load(e,t,n,r){const i=new this.textureClass,a=new Zn(this.parser,this.manager);return a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(this.withCredentials),a.load(e,e=>{i.image.data=e instanceof Xn?new Uint16Array(e.buffer):e;const{width:n,height:r,depth:a,...o}=this.options;null!=n&&(i.image.width=n),null!=r&&(i.image.height=r),"depth"in i.image&&null!=a&&(i.image.depth=a),i.type=function(e){const t=e instanceof Int8Array?x:e instanceof Uint8Array||e instanceof Uint8ClampedArray?T:e instanceof Int16Array?E:e instanceof Uint16Array?A:e instanceof Int32Array?R:e instanceof Uint32Array?C:e instanceof Xn?D:e instanceof Float32Array||e instanceof Float64Array?I:null;return ne(null!=t),t}(e),Object.assign(i,o),i.needsUpdate=!0,null==t||t(i)},n,r),i}}const $n=h.clamp;h.euclideanModulo,h.inverseLerp;const Qn=h.lerp,er=h.degToRad;function tr(e){return(t,n)=>{t instanceof F?Object.defineProperty(t,n,{enumerable:!0,get(){var t;return null!=(null==(t=this.defines)?void 0:t[e])},set(t){var r;t!==this[n]&&(t?(this.defines??(this.defines={}),this.defines[e]="1"):null==(r=this.defines)||delete r[e],this.needsUpdate=!0)}}):Object.defineProperty(t,n,{enumerable:!0,get(){return this.defines.has(e)},set(t){t!==this[n]&&(t?this.defines.set(e,"1"):this.defines.delete(e),this.setChanged())}})}}function nr(e,{min:t=Number.MIN_SAFE_INTEGER,max:n=Number.MAX_SAFE_INTEGER}={}){return(r,i)=>{r instanceof F?Object.defineProperty(r,i,{enumerable:!0,get(){var t;const n=null==(t=this.defines)?void 0:t[e];return null!=n?parseInt(n):0},set(r){r!==this[i]&&(this.defines??(this.defines={}),this.defines[e]=$n(r,t,n).toFixed(0),this.needsUpdate=!0)}}):Object.defineProperty(r,i,{enumerable:!0,get(){const t=this.defines.get(e);return null!=t?parseInt(t):0},set(r){r!==this[i]&&(this.defines.set(e,$n(r,t,n).toFixed(0)),this.setChanged())}})}}function rr(e,{min:t=-1/0,max:n=1/0,precision:r=7}={}){return(i,a)=>{i instanceof F?Object.defineProperty(i,a,{enumerable:!0,get(){var t;const n=null==(t=this.defines)?void 0:t[e];return null!=n?parseFloat(n):0},set(i){i!==this[a]&&(this.defines??(this.defines={}),this.defines[e]=$n(i,t,n).toFixed(r),this.needsUpdate=!0)}}):Object.defineProperty(i,a,{enumerable:!0,get(){const t=this.defines.get(e);return null!=t?parseFloat(t):0},set(i){i!==this[a]&&(this.defines.set(e,$n(i,t,n).toFixed(r)),this.setChanged())}})}}function ir(e,{validate:t}={}){return(n,r)=>{n instanceof F?Object.defineProperty(n,r,{enumerable:!0,get(){var t;return(null==(t=this.defines)?void 0:t[e])??""},set(n){if(n!==this[r]){if(!1===(null==t?void 0:t(n)))return void console.error(`Expression validation failed: ${n}`);this.defines??(this.defines={}),this.defines[e]=n,this.needsUpdate=!0}}}):Object.defineProperty(n,r,{enumerable:!0,get(){return this.defines.get(e)??""},set(n){if(n!==this[r]){if(!1===(null==t?void 0:t(n)))return void console.error(`Expression validation failed: ${n}`);this.defines.set(e,n),this.setChanged()}}})}}function ar(e,...t){const n={};for(let r=0;r<t.length;r+=2){const e=t[r],i=t[r+1];for(const t of i)n[t]={enumerable:!0,get:()=>e[t],set:n=>{e[t]=n}}}return Object.defineProperties(e,n),e}function or(e,t,n){const r={};for(const i of n)r[i]={enumerable:!0,get:()=>t.uniforms[i].value,set:e=>{t.uniforms[i].value=e}};return Object.defineProperties(e,r),e}h.radToDeg,h.isPowerOfTwo,h.ceilPowerOfTwo,h.floorPowerOfTwo,h.normalize;const sr=parseInt(H.replace(/\D+/g,""));var cr=Uint8Array,ur=Uint16Array,lr=Uint32Array,hr=new cr([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),dr=new cr([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),mr=new cr([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),pr=function(e,t){for(var n=new ur(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var i=new lr(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)i[a]=a-n[r]<<5|r;return[n,i]},fr=pr(hr,2),vr=fr[0],gr=fr[1];vr[28]=258,gr[258]=28;for(var Sr=pr(dr,0)[0],wr=new ur(32768),yr=0;yr<32768;++yr){var _r=(43690&yr)>>>1|(21845&yr)<<1;_r=(61680&(_r=(52428&_r)>>>2|(13107&_r)<<2))>>>4|(3855&_r)<<4,wr[yr]=((65280&_r)>>>8|(255&_r)<<8)>>>1}var xr=function(e,t,n){for(var r=e.length,i=0,a=new ur(t);i<r;++i)++a[e[i]-1];var o,s=new ur(t);for(i=0;i<t;++i)s[i]=s[i-1]+a[i-1]<<1;o=new ur(1<<t);var c=15-t;for(i=0;i<r;++i)if(e[i])for(var u=i<<4|e[i],l=t-e[i],h=s[e[i]-1]++<<l,d=h|(1<<l)-1;h<=d;++h)o[wr[h]>>>c]=u;return o},Tr=new cr(288);for(yr=0;yr<144;++yr)Tr[yr]=8;for(yr=144;yr<256;++yr)Tr[yr]=9;for(yr=256;yr<280;++yr)Tr[yr]=7;for(yr=280;yr<288;++yr)Tr[yr]=8;var Er=new cr(32);for(yr=0;yr<32;++yr)Er[yr]=5;var Ar=xr(Tr,9),Rr=xr(Er,5),Cr=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},Dr=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},Ir=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},Or=function(e){return(e/8|0)+(7&e&&1)},Nr=function(e,t,n){var r=e.length;if(!r||n&&!n.l&&r<5)return t||new cr(0);var i=!t||n,a=!n||n.i;n||(n={}),t||(t=new cr(3*r));var o=function(e){var n=t.length;if(e>n){var r=new cr(Math.max(2*n,e));r.set(t),t=r}},s=n.f||0,c=n.p||0,u=n.b||0,l=n.l,h=n.d,d=n.m,m=n.n,p=8*r;do{if(!l){n.f=s=Dr(e,c,1);var f=Dr(e,c+1,3);if(c+=3,!f){var v=e[(C=Or(c)+4)-4]|e[C-3]<<8,g=C+v;if(g>r){if(a)throw"unexpected EOF";break}i&&o(u+v),t.set(e.subarray(C,g),u),n.b=u+=v,n.p=c=8*g;continue}if(1==f)l=Ar,h=Rr,d=9,m=5;else{if(2!=f)throw"invalid block type";var S=Dr(e,c,31)+257,w=Dr(e,c+10,15)+4,y=S+Dr(e,c+5,31)+1;c+=14;for(var _=new cr(y),x=new cr(19),T=0;T<w;++T)x[mr[T]]=Dr(e,c+3*T,7);c+=3*w;var E=Cr(x),A=(1<<E)-1,R=xr(x,E);for(T=0;T<y;){var C,D=R[Dr(e,c,A)];if(c+=15&D,(C=D>>>4)<16)_[T++]=C;else{var I=0,O=0;for(16==C?(O=3+Dr(e,c,3),c+=2,I=_[T-1]):17==C?(O=3+Dr(e,c,7),c+=3):18==C&&(O=11+Dr(e,c,127),c+=7);O--;)_[T++]=I}}var N=_.subarray(0,S),b=_.subarray(S);d=Cr(N),m=Cr(b),l=xr(N,d),h=xr(b,m)}if(c>p){if(a)throw"unexpected EOF";break}}i&&o(u+131072);for(var P=(1<<d)-1,L=(1<<m)-1,M=c;;M=c){var U=(I=l[Ir(e,c)&P])>>>4;if((c+=15&I)>p){if(a)throw"unexpected EOF";break}if(!I)throw"invalid length/literal";if(U<256)t[u++]=U;else{if(256==U){M=c,l=null;break}var H=U-254;if(U>264){var F=hr[T=U-257];H=Dr(e,c,(1<<F)-1)+vr[T],c+=F}var z=h[Ir(e,c)&L],G=z>>>4;if(!z)throw"invalid distance";c+=15&z;b=Sr[G];if(G>3){F=dr[G];b+=Ir(e,c)&(1<<F)-1,c+=F}if(c>p){if(a)throw"unexpected EOF";break}i&&o(u+131072);for(var B=u+H;u<B;u+=4)t[u]=t[u-b],t[u+1]=t[u+1-b],t[u+2]=t[u+2-b],t[u+3]=t[u+3-b];u=B}}n.l=l,n.p=M,n.b=u,l&&(s=1,n.m=d,n.d=h,n.n=m)}while(!s);return u==t.length?t:function(e,t,n){(null==n||n>e.length)&&(n=e.length);var r=new(e instanceof ur?ur:e instanceof lr?lr:cr)(n-t);return r.set(e.subarray(t,n)),r}(t,0,u)},br=new cr(0);function Pr(e,t){return Nr((function(e){if(8!=(15&e[0])||e[0]>>>4>7||(e[0]<<8|e[1])%31)throw"invalid zlib data";if(32&e[1])throw"invalid zlib data: preset dictionaries not supported"}(e),e.subarray(2,-4)),t)}var Lr=typeof TextDecoder<"u"&&new TextDecoder;try{Lr.decode(br,{stream:!0})}catch{}const Mr=sr>=152;let Ur=class extends N{constructor(e){super(e),this.type=D}parse(e){const t=Math.pow(2.7182818,2.2);const n={l:0,c:0,lc:0};function r(e,t,r,i,a){for(;r<e;)t=t<<8|W(i,a),r+=8;r-=e,n.l=t>>r&(1<<e)-1,n.c=t,n.lc=r}const i=new Array(59);function a(e,t,a,o,s,c,u){for(var l=a,h=0,d=0;s<=c;s++){if(l.value-a.value>o)return!1;r(6,h,d,e,l);var m=n.l;if(h=n.c,d=n.lc,u[s]=m,63==m){if(l.value-a.value>o)throw"Something wrong with hufUnpackEncTable";r(8,h,d,e,l);var p=n.l+6;if(h=n.c,d=n.lc,s+p>c+1)throw"Something wrong with hufUnpackEncTable";for(;p--;)u[s++]=0;s--}else if(m>=59){if(s+(p=m-59+2)>c+1)throw"Something wrong with hufUnpackEncTable";for(;p--;)u[s++]=0;s--}}!function(e){for(var t=0;t<=58;++t)i[t]=0;for(t=0;t<65537;++t)i[e[t]]+=1;var n=0;for(t=58;t>0;--t){var r=n+i[t]>>1;i[t]=n,n=r}for(t=0;t<65537;++t){var a=e[t];a>0&&(e[t]=a|i[a]++<<6)}}(u)}function o(e){return 63&e}function s(e){return e>>6}const c={c:0,lc:0};function u(e,t,n,r){e=e<<8|W(n,r),t+=8,c.c=e,c.lc=t}const l={c:0,lc:0};function h(e,t,n,r,i,a,o,s,h,d){if(e==t){r<8&&(u(n,r,i,o),n=c.c,r=c.lc);var m=n>>(r-=8);m=new Uint8Array([m])[0];if(h.value+m>d)return!1;for(var p=s[h.value-1];m-- >0;)s[h.value++]=p}else{if(!(h.value<d))return!1;s[h.value++]=e}l.c=n,l.lc=r}function d(e){return 65535&e}function m(e){var t=d(e);return t>32767?t-65536:t}const f={a:0,b:0};function v(e,t){var n=m(e),r=m(t),i=n+(1&r)+(r>>1),a=i,o=i-r;f.a=a,f.b=o}function g(e,t){var n=d(e),r=d(t),i=n-(r>>1)&65535,a=r+i-32768&65535;f.a=a,f.b=i}function w(e,t,n,r,i,a,o){for(var s,c=o<16384,u=n>i?i:n,l=1;l<=u;)l<<=1;for(s=l>>=1,l>>=1;l>=1;){for(var h,d,m,p,S=0,w=S+a*(i-s),y=a*l,_=a*s,x=r*l,T=r*s;S<=w;S+=_){for(var E=S,A=S+r*(n-s);E<=A;E+=T){var R=E+x,C=(D=E+y)+x;c?(v(e[E+t],e[D+t]),h=f.a,m=f.b,v(e[R+t],e[C+t]),d=f.a,p=f.b,v(h,d),e[E+t]=f.a,e[R+t]=f.b,v(m,p),e[D+t]=f.a,e[C+t]=f.b):(g(e[E+t],e[D+t]),h=f.a,m=f.b,g(e[R+t],e[C+t]),d=f.a,p=f.b,g(h,d),e[E+t]=f.a,e[R+t]=f.b,g(m,p),e[D+t]=f.a,e[C+t]=f.b)}if(n&l){var D=E+y;c?v(e[E+t],e[D+t]):g(e[E+t],e[D+t]),h=f.a,e[D+t]=f.b,e[E+t]=h}}if(i&l)for(E=S,A=S+r*(n-s);E<=A;E+=T){R=E+x;c?v(e[E+t],e[R+t]):g(e[E+t],e[R+t]),h=f.a,e[R+t]=f.b,e[E+t]=h}s=l,l>>=1}return S}function y(e,t,n,r,i,d){var m=n.value,p=B(t,n),f=B(t,n);n.value+=4;var v=B(t,n);if(n.value+=4,p<0||p>=65537||f<0||f>=65537)throw"Something wrong with HUF_ENCSIZE";var g=new Array(65537),S=new Array(16384);if(function(e){for(var t=0;t<16384;t++)e[t]={},e[t].len=0,e[t].lit=0,e[t].p=null}(S),a(e,0,n,r-(n.value-m),p,f,g),v>8*(r-(n.value-m)))throw"Something wrong with hufUncompress";(function(e,t,n,r){for(;t<=n;t++){var i=s(e[t]),a=o(e[t]);if(i>>a)throw"Invalid table entry";if(a>14){if((h=r[i>>a-14]).len)throw"Invalid table entry";if(h.lit++,h.p){var c=h.p;h.p=new Array(h.lit);for(var u=0;u<h.lit-1;++u)h.p[u]=c[u]}else h.p=new Array(1);h.p[h.lit-1]=t}else if(a){var l=0;for(u=1<<14-a;u>0;u--){var h;if((h=r[(i<<14-a)+l]).len||h.p)throw"Invalid table entry";h.len=a,h.lit=t,l++}}}})(g,p,f,S),function(e,t,n,r,i,a,d,m,p,f){for(var v=0,g=0,S=m,w=Math.trunc(i.value+(a+7)/8);i.value<w;)for(u(v,g,n,i),v=c.c,g=c.lc;g>=14;)if((T=t[v>>g-14&16383]).len)g-=T.len,h(T.lit,d,v,g,n,0,i,p,f,S),v=l.c,g=l.lc;else{if(!T.p)throw"hufDecode issues";var y;for(y=0;y<T.lit;y++){for(var _=o(e[T.p[y]]);g<_&&i.value<w;)u(v,g,n,i),v=c.c,g=c.lc;if(g>=_&&s(e[T.p[y]])==(v>>g-_&(1<<_)-1)){g-=_,h(T.p[y],d,v,g,n,0,i,p,f,S),v=l.c,g=l.lc;break}}if(y==T.lit)throw"hufDecode issues"}var x=8-a&7;for(v>>=x,g-=x;g>0;){var T;if(!(T=t[v<<14-g&16383]).len)throw"hufDecode issues";g-=T.len,h(T.lit,d,v,g,n,0,i,p,f,S),v=l.c,g=l.lc}}(g,S,e,0,n,v,f,d,i,{value:0})}function _(e){for(var t=1;t<e.length;t++){var n=e[t-1]+e[t]-128;e[t]=n}}function x(e,t){for(var n=0,r=Math.floor((e.length+1)/2),i=0,a=e.length-1;!(i>a||(t[i++]=e[n++],i>a));)t[i++]=e[r++]}function T(e){for(var t=e.byteLength,n=new Array,r=0,i=new DataView(e);t>0;){var a=i.getInt8(r++);if(a<0){t-=(s=-a)+1;for(var o=0;o<s;o++)n.push(i.getUint8(r++))}else{var s=a;t-=2;var c=i.getUint8(r++);for(o=0;o<s+1;o++)n.push(c)}}return n}function E(e,t,n){for(var r,i=1;i<64;)65280==(r=t[e.value])?i=64:r>>8==255?i+=255&r:(n[i]=r,i++),e.value++}function A(e,t){t[0]=X(e[0]),t[1]=X(e[1]),t[2]=X(e[5]),t[3]=X(e[6]),t[4]=X(e[14]),t[5]=X(e[15]),t[6]=X(e[27]),t[7]=X(e[28]),t[8]=X(e[2]),t[9]=X(e[4]),t[10]=X(e[7]),t[11]=X(e[13]),t[12]=X(e[16]),t[13]=X(e[26]),t[14]=X(e[29]),t[15]=X(e[42]),t[16]=X(e[3]),t[17]=X(e[8]),t[18]=X(e[12]),t[19]=X(e[17]),t[20]=X(e[25]),t[21]=X(e[30]),t[22]=X(e[41]),t[23]=X(e[43]),t[24]=X(e[9]),t[25]=X(e[11]),t[26]=X(e[18]),t[27]=X(e[24]),t[28]=X(e[31]),t[29]=X(e[40]),t[30]=X(e[44]),t[31]=X(e[53]),t[32]=X(e[10]),t[33]=X(e[19]),t[34]=X(e[23]),t[35]=X(e[32]),t[36]=X(e[39]),t[37]=X(e[45]),t[38]=X(e[52]),t[39]=X(e[54]),t[40]=X(e[20]),t[41]=X(e[22]),t[42]=X(e[33]),t[43]=X(e[38]),t[44]=X(e[46]),t[45]=X(e[51]),t[46]=X(e[55]),t[47]=X(e[60]),t[48]=X(e[21]),t[49]=X(e[34]),t[50]=X(e[37]),t[51]=X(e[47]),t[52]=X(e[50]),t[53]=X(e[56]),t[54]=X(e[59]),t[55]=X(e[61]),t[56]=X(e[35]),t[57]=X(e[36]),t[58]=X(e[48]),t[59]=X(e[49]),t[60]=X(e[57]),t[61]=X(e[58]),t[62]=X(e[62]),t[63]=X(e[63])}function R(e){const t=.5*Math.cos(.7853975),n=.5*Math.cos(3.14159/16),r=.5*Math.cos(3.14159/8),i=.5*Math.cos(3*3.14159/16),a=.5*Math.cos(.981746875),o=.5*Math.cos(3*3.14159/8),s=.5*Math.cos(1.374445625);for(var c=new Array(4),u=new Array(4),l=new Array(4),h=new Array(4),d=0;d<8;++d){var m=8*d;c[0]=r*e[m+2],c[1]=o*e[m+2],c[2]=r*e[m+6],c[3]=o*e[m+6],u[0]=n*e[m+1]+i*e[m+3]+a*e[m+5]+s*e[m+7],u[1]=i*e[m+1]-s*e[m+3]-n*e[m+5]-a*e[m+7],u[2]=a*e[m+1]-n*e[m+3]+s*e[m+5]+i*e[m+7],u[3]=s*e[m+1]-a*e[m+3]+i*e[m+5]-n*e[m+7],l[0]=t*(e[m+0]+e[m+4]),l[3]=t*(e[m+0]-e[m+4]),l[1]=c[0]+c[3],l[2]=c[1]-c[2],h[0]=l[0]+l[1],h[1]=l[3]+l[2],h[2]=l[3]-l[2],h[3]=l[0]-l[1],e[m+0]=h[0]+u[0],e[m+1]=h[1]+u[1],e[m+2]=h[2]+u[2],e[m+3]=h[3]+u[3],e[m+4]=h[3]-u[3],e[m+5]=h[2]-u[2],e[m+6]=h[1]-u[1],e[m+7]=h[0]-u[0]}for(var p=0;p<8;++p)c[0]=r*e[16+p],c[1]=o*e[16+p],c[2]=r*e[48+p],c[3]=o*e[48+p],u[0]=n*e[8+p]+i*e[24+p]+a*e[40+p]+s*e[56+p],u[1]=i*e[8+p]-s*e[24+p]-n*e[40+p]-a*e[56+p],u[2]=a*e[8+p]-n*e[24+p]+s*e[40+p]+i*e[56+p],u[3]=s*e[8+p]-a*e[24+p]+i*e[40+p]-n*e[56+p],l[0]=t*(e[p]+e[32+p]),l[3]=t*(e[p]-e[32+p]),l[1]=c[0]+c[3],l[2]=c[1]-c[2],h[0]=l[0]+l[1],h[1]=l[3]+l[2],h[2]=l[3]-l[2],h[3]=l[0]-l[1],e[0+p]=h[0]+u[0],e[8+p]=h[1]+u[1],e[16+p]=h[2]+u[2],e[24+p]=h[3]+u[3],e[32+p]=h[3]-u[3],e[40+p]=h[2]-u[2],e[48+p]=h[1]-u[1],e[56+p]=h[0]-u[0]}function C(e){for(var t=0;t<64;++t){var n=e[0][t],r=e[1][t],i=e[2][t];e[0][t]=n+1.5747*i,e[1][t]=n-.1873*r-.4682*i,e[2][t]=n+1.8556*r}}function O(e,t,n){for(var r=0;r<64;++r)t[n+r]=U.toHalfFloat(N(e[r]))}function N(e){return e<=1?Math.sign(e)*Math.pow(Math.abs(e),2.2):Math.sign(e)*Math.pow(t,Math.abs(e)-1)}function b(e){return new DataView(e.array.buffer,e.offset.value,e.size)}function P(e){var t=e.viewer.buffer.slice(e.offset.value,e.offset.value+e.size),n=new Uint8Array(T(t)),r=new Uint8Array(n.length);return _(n),x(n,r),new DataView(r.buffer)}function L(e){var t=Pr(e.array.slice(e.offset.value,e.offset.value+e.size)),n=new Uint8Array(t.length);return _(t),x(t,n),new DataView(n.buffer)}function M(e){for(var t=e.viewer,n={value:e.offset.value},r=new Uint16Array(e.width*e.scanlineBlockSize*(e.channels*e.type)),i=new Uint8Array(8192),a=0,o=new Array(e.channels),s=0;s<e.channels;s++)o[s]={},o[s].start=a,o[s].end=o[s].start,o[s].nx=e.width,o[s].ny=e.lines,o[s].size=e.type,a+=o[s].nx*o[s].ny*o[s].size;var c=q(t,n),u=q(t,n);if(u>=8192)throw"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";if(c<=u)for(s=0;s<u-c+1;s++)i[s+c]=k(t,n);var l=new Uint16Array(65536),h=function(e,t){for(var n=0,r=0;r<65536;++r)(0==r||e[r>>3]&1<<(7&r))&&(t[n++]=r);for(var i=n-1;n<65536;)t[n++]=0;return i}(i,l),d=B(t,n);y(e.array,t,n,d,r,a);for(s=0;s<e.channels;++s)for(var m=o[s],p=0;p<o[s].size;++p)w(r,m.start+p,m.nx,m.size,m.ny,m.nx*m.size,h);!function(e,t,n){for(var r=0;r<n;++r)t[r]=e[t[r]]}(l,r,a);for(var f=0,v=new Uint8Array(r.buffer.byteLength),g=0;g<e.lines;g++)for(var S=0;S<e.channels;S++){var _=(m=o[S]).nx*m.size,x=new Uint8Array(r.buffer,2*m.end,2*_);v.set(x,f),f+=2*_,m.end+=_}return new DataView(v.buffer)}function H(e){var t=Pr(e.array.slice(e.offset.value,e.offset.value+e.size));const n=e.lines*e.channels*e.width,r=1==e.type?new Uint16Array(n):new Uint32Array(n);let i=0,a=0;const o=new Array(4);for(let s=0;s<e.lines;s++)for(let n=0;n<e.channels;n++){let n=0;switch(e.type){case 1:o[0]=i,o[1]=o[0]+e.width,i=o[1]+e.width;for(let i=0;i<e.width;++i){n+=t[o[0]++]<<8|t[o[1]++],r[a]=n,a++}break;case 2:o[0]=i,o[1]=o[0]+e.width,o[2]=o[1]+e.width,i=o[2]+e.width;for(let i=0;i<e.width;++i){n+=t[o[0]++]<<24|t[o[1]++]<<16|t[o[2]++]<<8,r[a]=n,a++}}}return new DataView(r.buffer)}function F(e){var t=e.viewer,n={value:e.offset.value},r=new Uint8Array(e.width*e.lines*(e.channels*e.type*2)),i={version:V(t,n),unknownUncompressedSize:V(t,n),unknownCompressedSize:V(t,n),acCompressedSize:V(t,n),dcCompressedSize:V(t,n),rleCompressedSize:V(t,n),rleUncompressedSize:V(t,n),rleRawSize:V(t,n),totalAcUncompressedCount:V(t,n),totalDcUncompressedCount:V(t,n),acCompression:V(t,n)};if(i.version<2)throw"EXRLoader.parse: "+ee.compression+" version "+i.version+" is unsupported";for(var a=new Array,o=q(t,n)-2;o>0;){var s=z(t.buffer,n),c=k(t,n),u=c>>2&3,l=new Int8Array([(c>>4)-1])[0],h=k(t,n);a.push({name:s,index:l,type:h,compression:u}),o-=s.length+3}for(var d=ee.channels,m=new Array(e.channels),p=0;p<e.channels;++p){var f=m[p]={},v=d[p];f.name=v.name,f.compression=0,f.decoded=!1,f.type=v.pixelType,f.pLinear=v.pLinear,f.width=e.width,f.height=e.lines}for(var g={idx:new Array(3)},S=0;S<e.channels;++S)for(f=m[S],p=0;p<a.length;++p){var w=a[p];f.name==w.name&&(f.compression=w.compression,w.index>=0&&(g.idx[w.index]=S),f.offset=S)}if(i.acCompressedSize>0)switch(i.acCompression){case 0:var _=new Uint16Array(i.totalAcUncompressedCount);y(e.array,t,n,i.acCompressedSize,_,i.totalAcUncompressedCount);break;case 1:var x=Pr(e.array.slice(n.value,n.value+i.totalAcUncompressedCount));_=new Uint16Array(x.buffer);n.value+=i.totalAcUncompressedCount}if(i.dcCompressedSize>0){var D={array:e.array,offset:n,size:i.dcCompressedSize},I=new Uint16Array(L(D).buffer);n.value+=i.dcCompressedSize}if(i.rleRawSize>0){var N=T((x=Pr(e.array.slice(n.value,n.value+i.rleCompressedSize))).buffer);n.value+=i.rleCompressedSize}var b=0,P=new Array(m.length);for(p=0;p<P.length;++p)P[p]=new Array;for(var M=0;M<e.lines;++M)for(var U=0;U<m.length;++U)P[U].push(b),b+=m[U].width*e.type*2;!function(e,t,n,r,i,a){var o=new DataView(a.buffer),s=n[e.idx[0]].width,c=n[e.idx[0]].height,u=Math.floor(s/8),l=Math.ceil(s/8),h=Math.ceil(c/8),d=s-8*(l-1),m=c-8*(h-1),p={value:0},f=new Array(3),v=new Array(3),g=new Array(3),S=new Array(3),w=new Array(3);for(let E=0;E<3;++E)w[E]=t[e.idx[E]],f[E]=E<1?0:f[E-1]+l*h,v[E]=new Float32Array(64),g[E]=new Uint16Array(64),S[E]=new Uint16Array(64*l);for(let b=0;b<h;++b){var y=8;b==h-1&&(y=m);var _=8;for(let e=0;e<l;++e){e==l-1&&(_=d);for(let e=0;e<3;++e)g[e].fill(0),g[e][0]=i[f[e]++],E(p,r,g[e]),A(g[e],v[e]),R(v[e]);C(v);for(let t=0;t<3;++t)O(v[t],S[t],64*e)}let t=0;for(let r=0;r<3;++r){const i=n[e.idx[r]].type;for(let e=8*b;e<8*b+y;++e){t=w[r][e];for(let n=0;n<u;++n){const a=64*n+8*(7&e);o.setUint16(t+0*i,S[r][a+0],!0),o.setUint16(t+2*i,S[r][a+1],!0),o.setUint16(t+4*i,S[r][a+2],!0),o.setUint16(t+6*i,S[r][a+3],!0),o.setUint16(t+8*i,S[r][a+4],!0),o.setUint16(t+10*i,S[r][a+5],!0),o.setUint16(t+12*i,S[r][a+6],!0),o.setUint16(t+14*i,S[r][a+7],!0),t+=16*i}}if(u!=l)for(let e=8*b;e<8*b+y;++e){const t=w[r][e]+8*u*2*i,n=64*u+8*(7&e);for(let e=0;e<_;++e)o.setUint16(t+2*e*i,S[r][n+e],!0)}}}for(var x=new Uint16Array(s),T=(o=new DataView(a.buffer),0);T<3;++T){n[e.idx[T]].decoded=!0;var D=n[e.idx[T]].type;if(2==n[T].type)for(var I=0;I<c;++I){const e=w[T][I];for(var N=0;N<s;++N)x[N]=o.getUint16(e+2*N*D,!0);for(N=0;N<s;++N)o.setFloat32(e+2*N*D,X(x[N]),!0)}}}(g,P,m,_,I,r);for(p=0;p<m.length;++p){if(!(f=m[p]).decoded){if(2!==f.compression)throw"EXRLoader.parse: unsupported channel compression";var H=0,F=0;for(M=0;M<e.lines;++M){for(var G=P[p][H],B=0;B<f.width;++B){for(var W=0;W<2*f.type;++W)r[G++]=N[F+W*f.width*f.height];F++}H++}}}return new DataView(r.buffer)}function z(e,t){for(var n=new Uint8Array(e),r=0;0!=n[t.value+r];)r+=1;var i=(new TextDecoder).decode(n.slice(t.value,t.value+r));return t.value=t.value+r+1,i}function G(e,t){var n=e.getInt32(t.value,!0);return t.value=t.value+4,n}function B(e,t){var n=e.getUint32(t.value,!0);return t.value=t.value+4,n}function W(e,t){var n=e[t.value];return t.value=t.value+1,n}function k(e,t){var n=e.getUint8(t.value);return t.value=t.value+1,n}const V=function(e,t){let n;return n="getBigInt64"in DataView.prototype?Number(e.getBigInt64(t.value,!0)):e.getUint32(t.value+4,!0)+Number(e.getUint32(t.value,!0)<<32),t.value+=8,n};function j(e,t){var n=e.getFloat32(t.value,!0);return t.value+=4,n}function Y(e,t){return U.toHalfFloat(j(e,t))}function X(e){var t=(31744&e)>>10,n=1023&e;return(e>>15?-1:1)*(t?31===t?n?NaN:1/0:Math.pow(2,t-15)*(1+n/1024):n/1024*6103515625e-14)}function q(e,t){var n=e.getUint16(t.value,!0);return t.value+=2,n}function K(e,t){return X(q(e,t))}function Z(e,t,n,r,i){return"string"===r||"stringvector"===r||"iccProfile"===r?function(e,t,n){var r=(new TextDecoder).decode(new Uint8Array(e).slice(t.value,t.value+n));return t.value=t.value+n,r}(t,n,i):"chlist"===r?function(e,t,n,r){for(var i=n.value,a=[];n.value<i+r-1;){var o=z(t,n),s=G(e,n),c=k(e,n);n.value+=3;var u=G(e,n),l=G(e,n);a.push({name:o,pixelType:s,pLinear:c,xSampling:u,ySampling:l})}return n.value+=1,a}(e,t,n,i):"chromaticities"===r?function(e,t){return{redX:j(e,t),redY:j(e,t),greenX:j(e,t),greenY:j(e,t),blueX:j(e,t),blueY:j(e,t),whiteX:j(e,t),whiteY:j(e,t)}}(e,n):"compression"===r?function(e,t){return["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"][k(e,t)]}(e,n):"box2i"===r?function(e,t){return{xMin:B(e,t),yMin:B(e,t),xMax:B(e,t),yMax:B(e,t)}}(e,n):"lineOrder"===r?function(e,t){return["INCREASING_Y"][k(e,t)]}(e,n):"float"===r?j(e,n):"v2f"===r?function(e,t){return[j(e,t),j(e,t)]}(e,n):"v3f"===r?function(e,t){return[j(e,t),j(e,t),j(e,t)]}(e,n):"int"===r?G(e,n):"rational"===r?function(e,t){return[G(e,t),B(e,t)]}(e,n):"timecode"===r?function(e,t){return[B(e,t),B(e,t)]}(e,n):"preview"===r?(n.value+=i,"skipped"):void(n.value+=i)}const J=new DataView(e),$=new Uint8Array(e),Q={value:0},ee=function(e,t,n){const r={};if(20000630!=e.getUint32(0,!0))throw"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";r.version=e.getUint8(4);const i=e.getUint8(5);r.spec={singleTile:!!(2&i),longName:!!(4&i),deepFormat:!!(8&i),multiPart:!!(16&i)},n.value=8;for(var a=!0;a;){var o=z(t,n);if(0==o)a=!1;else{var s=z(t,n),c=Z(e,t,n,s,B(e,n));void 0===c?console.warn(`EXRLoader.parse: skipped unknown header attribute type '${s}'.`):r[o]=c}}if(-5&i)throw console.error("EXRHeader:",r),"THREE.EXRLoader: provided file is currently unsupported.";return r}(J,e,Q),te=function(e,t,n,r,i){const a={size:0,viewer:t,array:n,offset:r,width:e.dataWindow.xMax-e.dataWindow.xMin+1,height:e.dataWindow.yMax-e.dataWindow.yMin+1,channels:e.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:e.channels[0].pixelType,uncompress:null,getter:null,format:null,[Mr?"colorSpace":"encoding"]:null};switch(e.compression){case"NO_COMPRESSION":a.lines=1,a.uncompress=b;break;case"RLE_COMPRESSION":a.lines=1,a.uncompress=P;break;case"ZIPS_COMPRESSION":a.lines=1,a.uncompress=L;break;case"ZIP_COMPRESSION":a.lines=16,a.uncompress=L;break;case"PIZ_COMPRESSION":a.lines=32,a.uncompress=M;break;case"PXR24_COMPRESSION":a.lines=16,a.uncompress=H;break;case"DWAA_COMPRESSION":a.lines=32,a.uncompress=F;break;case"DWAB_COMPRESSION":a.lines=256,a.uncompress=F;break;default:throw"EXRLoader.parse: "+e.compression+" is unsupported"}if(a.scanlineBlockSize=a.lines,1==a.type)switch(i){case I:a.getter=K,a.inputSize=2;break;case D:a.getter=q,a.inputSize=2}else{if(2!=a.type)throw"EXRLoader.parse: unsupported pixelType "+a.type+" for "+e.compression+".";switch(i){case I:a.getter=j,a.inputSize=4;break;case D:a.getter=Y,a.inputSize=4}}a.blockCount=(e.dataWindow.yMax+1)/a.scanlineBlockSize;for(var o=0;o<a.blockCount;o++)V(t,r);a.outputChannels=3==a.channels?4:a.channels;const s=a.width*a.height*a.outputChannels;switch(i){case I:a.byteArray=new Float32Array(s),a.channels<a.outputChannels&&a.byteArray.fill(1,0,s);break;case D:a.byteArray=new Uint16Array(s),a.channels<a.outputChannels&&a.byteArray.fill(15360,0,s);break;default:console.error("THREE.EXRLoader: unsupported type: ",i)}return a.bytesPerLine=a.width*a.inputSize*a.channels,4==a.outputChannels?a.format=p:a.format=S,Mr?a.colorSpace="srgb-linear":a.encoding=3e3,a}(ee,J,$,Q,this.type),ne={value:0},re={R:0,G:1,B:2,A:3,Y:0};for(let p=0;p<te.height/te.scanlineBlockSize;p++){const e=B(J,Q);te.size=B(J,Q),te.lines=e+te.scanlineBlockSize>te.height?te.height-e:te.scanlineBlockSize;const t=te.size<te.lines*te.bytesPerLine?te.uncompress(te):b(te);Q.value+=te.size;for(let n=0;n<te.scanlineBlockSize;n++){const e=n+p*te.scanlineBlockSize;if(e>=te.height)break;for(let r=0;r<te.channels;r++){const i=re[ee.channels[r].name];for(let a=0;a<te.width;a++){ne.value=(n*(te.channels*te.width)+r*te.width+a)*te.inputSize;const o=(te.height-1-e)*(te.width*te.outputChannels)+a*te.outputChannels+i;te.byteArray[o]=te.getter(t,ne)}}}}return{header:ee,width:te.width,height:te.height,data:te.byteArray,format:te.format,[Mr?"colorSpace":"encoding"]:te[Mr?"colorSpace":"encoding"],type:this.type}}setDataType(e){return this.type=e,this}load(e,t,n,r){return super.load(e,function(e,n){Mr?e.colorSpace=n.colorSpace:e.encoding=n.encoding,e.minFilter=m,e.magFilter=m,e.generateMipmaps=!1,e.flipY=!1,t&&t(e,n)},n,r)}};class Hr extends d{constructor(e={},t){super(t),this.options=e}load(e,t,n,r){const{width:i,height:a,depth:o}=this.options,s=new f(null,i,a,o),c=new Ur(this.manager);return c.setRequestHeader(this.requestHeader),c.setPath(this.path),c.setWithCredentials(this.withCredentials),c.load(e,n=>{const{image:c}=n;s.image={data:c.data,width:i??c.width,height:a??c.height,depth:o??Math.sqrt(c.height)},s.type=n.type,s.format=n.format,s.colorSpace=n.colorSpace,s.needsUpdate=!0;try{null==t||t(s)}catch(Zo){null!=r?r(Zo):console.error(Zo),this.manager.itemError(e)}},n,r),s}}class Fr extends d{constructor(e={},t){super(t),this.options=e}load(e,t,n,r){const{width:i,height:a}=this.options,o=new _(null,i,a),s=new Ur(this.manager);return s.setRequestHeader(this.requestHeader),s.setPath(this.path),s.setWithCredentials(this.withCredentials),s.load(e,n=>{const{image:s}=n;o.image={data:s.data,width:i??s.width,height:a??s.height},o.type=n.type,o.format=n.format,o.colorSpace=n.colorSpace,o.needsUpdate=!0;try{null==t||t(o)}catch(ms){null!=r?r(ms):console.error(ms),this.manager.itemError(e)}},n,r),o}}const zr=1e-6,Gr=new u,Br=new u,Wr=new u,kr=new u,Vr=new u,jr=new u,Yr=new l,Xr=new w,qr=new y;let Kr=class e{constructor(e=0,t=0,n=0,r=0){this.distance=e,this.heading=t,this.pitch=n,this.roll=r}get distance(){return this._distance}set distance(e){this._distance=Math.max(e,zr)}get pitch(){return this._pitch}set pitch(e){this._pitch=$n(e,-Math.PI/2+zr,Math.PI/2-zr)}set(e,t,n,r){return this.distance=e,this.heading=t,this.pitch=n,null!=r&&(this.roll=r),this}clone(){return new e(this.distance,this.heading,this.pitch,this.roll)}copy(e){return this.distance=e.distance,this.heading=e.heading,this.pitch=e.pitch,this.roll=e.roll,this}equals(e){return e.distance===this.distance&&e.heading===this.heading&&e.pitch===this.pitch&&e.roll===this.roll}decompose(e,t,n,r,i=ue.WGS84){i.getEastNorthUpVectors(e,Gr,Br,Wr),null==r||r.copy(Wr);const a=kr.copy(Gr).multiplyScalar(Math.cos(this.heading)).add(Vr.copy(Br).multiplyScalar(Math.sin(this.heading))).multiplyScalar(Math.cos(this.pitch)).add(Vr.copy(Wr).multiplyScalar(Math.sin(this.pitch))).normalize().multiplyScalar(this.distance);if(t.copy(e).sub(a),0!==this.roll){const n=kr.copy(e).sub(t).normalize();Wr.applyQuaternion(Xr.setFromAxisAngle(n,this.roll))}n.setFromRotationMatrix(Yr.lookAt(t,e,Wr))}setFromCamera(e,t=ue.WGS84){const n=kr.setFromMatrixPosition(e.matrixWorld),r=Vr.set(0,0,.5).unproject(e).sub(n).normalize(),i=t.getIntersection(qr.set(n,r));if(null==i)return;this.distance=n.distanceTo(i),t.getEastNorthUpVectors(i,Gr,Br,Wr),this.heading=Math.atan2(Br.dot(r),Gr.dot(r)),this.pitch=Math.asin(Wr.dot(r));const a=kr.copy(e.up).applyQuaternion(e.quaternion),o=jr.copy(r).multiplyScalar(-a.dot(r)).add(a).normalize(),s=kr.copy(r).multiplyScalar(-Wr.dot(r)).add(Wr).normalize(),c=s.dot(o),u=r.dot(s.cross(o));return this.roll=Math.atan2(u,c),this}};const Zr=/^[ \t]*#include +"([\w\d./]+)"/gm;function Jr(e,t){return e.replace(Zr,(e,n)=>{const r=n.split("/").reduce((e,t)=>"string"!=typeof e&&null!=e?e[t]:void 0,t);if("string"!=typeof r)throw new Error(`Could not find include for ${n}.`);return Jr(r,t)})}let $r;function Qr(e,t,n,r=!0){if(r===function(){if(null!=$r)return $r;const e=new Uint32Array([268435456]);return $r=0===new Uint8Array(e.buffer,e.byteOffset,e.byteLength)[0],$r}())return new t(e);const i=Object.assign(new DataView(e),{getFloat16(e,t){return function(e,t,...n){return Pn(Vt(e,t,...an(n)))}(this,e,t)}}),a=new t(i.byteLength/t.BYTES_PER_ELEMENT);for(let o=0,s=0;o<a.length;++o,s+=t.BYTES_PER_ELEMENT)a[o]=i[n](s,r);return a}const ei=e=>new Uint8Array(e),ti=(e,t)=>Qr(e,Xn,"getFloat16",t);class ni extends Jn{constructor(e){super(f,ei,{format:S,minFilter:g,magFilter:g,wrapS:v,wrapT:v,wrapR:v,width:128,height:128,depth:64},e)}}const ri=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*(?:i\s*\+\+|\+\+\s*i)\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function ii(e,t,n,r){let i="";for(let a=parseInt(t);a<parseInt(n);++a)i+=r.replace(/\[\s*i\s*\]/g,"["+a+"]").replace(/UNROLLED_LOOP_INDEX/g,`${a}`);return i}function ai(e){return e.replace(ri,ii)}const oi='// Reference: https://github.com/mrdoob/three.js/blob/r171/examples/jsm/csm/CSMShader.js\n\n#ifndef SHADOW_CASCADE_COUNT\n#error "SHADOW_CASCADE_COUNT macro must be defined."\n#endif // SHADOW_CASCADE_COUNT\n\nint getCascadeIndex(\n  const mat4 viewMatrix,\n  const vec3 worldPosition,\n  const vec2 intervals[SHADOW_CASCADE_COUNT],\n  const float near,\n  const float far\n) {\n  vec4 viewPosition = viewMatrix * vec4(worldPosition, 1.0);\n  float depth = viewZToOrthographicDepth(viewPosition.z, near, far);\n  vec2 interval;\n  #pragma unroll_loop_start\n  for (int i = 0; i < 4; ++i) {\n    #if UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT\n    interval = intervals[i];\n    if (depth >= interval.x && depth < interval.y) {\n      return UNROLLED_LOOP_INDEX;\n    }\n    #endif // UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT\n  }\n  #pragma unroll_loop_end\n  return SHADOW_CASCADE_COUNT - 1;\n}\n\nint getFadedCascadeIndex(\n  const mat4 viewMatrix,\n  const vec3 worldPosition,\n  const vec2 intervals[SHADOW_CASCADE_COUNT],\n  const float near,\n  const float far,\n  const float jitter\n) {\n  vec4 viewPosition = viewMatrix * vec4(worldPosition, 1.0);\n  float depth = viewZToOrthographicDepth(viewPosition.z, near, far);\n\n  vec2 interval;\n  float intervalCenter;\n  float closestEdge;\n  float margin;\n  int nextIndex = -1;\n  int prevIndex = -1;\n  float alpha;\n\n  #pragma unroll_loop_start\n  for (int i = 0; i < 4; ++i) {\n    #if UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT\n    interval = intervals[i];\n    intervalCenter = (interval.x + interval.y) * 0.5;\n    closestEdge = depth < intervalCenter ? interval.x : interval.y;\n    margin = closestEdge * closestEdge * 0.5;\n    interval += margin * vec2(-0.5, 0.5);\n\n    #if UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT - 1\n    if (depth >= interval.x && depth < interval.y) {\n      prevIndex = nextIndex;\n      nextIndex = UNROLLED_LOOP_INDEX;\n      alpha = saturate(min(depth - interval.x, interval.y - depth) / margin);\n    }\n    #else // UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT - 1\n    // Don\'t fade out the last cascade.\n    if (depth >= interval.x) {\n      prevIndex = nextIndex;\n      nextIndex = UNROLLED_LOOP_INDEX;\n      alpha = saturate((depth - interval.x) / margin);\n    }\n    #endif // UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT - 1\n    #endif // UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT\n  }\n  #pragma unroll_loop_end\n\n  return jitter <= alpha\n    ? nextIndex\n    : prevIndex;\n}\n',si="// cSpell:words logdepthbuf\n\nfloat reverseLogDepth(const float depth, const float near, const float far) {\n  #ifdef USE_LOGDEPTHBUF\n  float d = pow(2.0, depth * log2(far + 1.0)) - 1.0;\n  float a = far / (far - near);\n  float b = far * near / (near - far);\n  return a + b / d;\n  #else // USE_LOGDEPTHBUF\n  return depth;\n  #endif // USE_LOGDEPTHBUF\n}\n\nfloat linearizeDepth(const float depth, const float near, const float far) {\n  float ndc = depth * 2.0 - 1.0;\n  return 2.0 * near * far / (far + near - ndc * (far - near));\n}\n",ci="// Reference: https://advances.realtimerendering.com/s2014/index.html#_NEXT_GENERATION_POST\n\nfloat interleavedGradientNoise(const vec2 coord) {\n  const vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n  return fract(magic.z * fract(dot(coord, magic.xy)));\n}\n",ui="#if !defined(saturate)\n#define saturate(a) clamp(a, 0.0, 1.0)\n#endif // !defined(saturate)\n\nfloat remap(const float x, const float min1, const float max1, const float min2, const float max2) {\n  return min2 + (x - min1) / (max1 - min1) * (max2 - min2);\n}\n\nvec2 remap(const vec2 x, const vec2 min1, const vec2 max1, const vec2 min2, const vec2 max2) {\n  return min2 + (x - min1) / (max1 - min1) * (max2 - min2);\n}\n\nvec3 remap(const vec3 x, const vec3 min1, const vec3 max1, const vec3 min2, const vec3 max2) {\n  return min2 + (x - min1) / (max1 - min1) * (max2 - min2);\n}\n\nvec4 remap(const vec4 x, const vec4 min1, const vec4 max1, const vec4 min2, const vec4 max2) {\n  return min2 + (x - min1) / (max1 - min1) * (max2 - min2);\n}\n\nfloat remapClamped(\n  const float x,\n  const float min1,\n  const float max1,\n  const float min2,\n  const float max2\n) {\n  return clamp(min2 + (x - min1) / (max1 - min1) * (max2 - min2), min2, max2);\n}\n\nvec2 remapClamped(\n  const vec2 x,\n  const vec2 min1,\n  const vec2 max1,\n  const vec2 min2,\n  const vec2 max2\n) {\n  return clamp(min2 + (x - min1) / (max1 - min1) * (max2 - min2), min2, max2);\n}\n\nvec3 remapClamped(\n  const vec3 x,\n  const vec3 min1,\n  const vec3 max1,\n  const vec3 min2,\n  const vec3 max2\n) {\n  return clamp(min2 + (x - min1) / (max1 - min1) * (max2 - min2), min2, max2);\n}\n\nvec4 remapClamped(\n  const vec4 x,\n  const vec4 min1,\n  const vec4 max1,\n  const vec4 min2,\n  const vec4 max2\n) {\n  return clamp(min2 + (x - min1) / (max1 - min1) * (max2 - min2), min2, max2);\n}\n\n// Implicitly remap to 0 and 1\nfloat remap(const float x, const float min1, const float max1) {\n  return (x - min1) / (max1 - min1);\n}\n\nvec2 remap(const vec2 x, const vec2 min1, const vec2 max1) {\n  return (x - min1) / (max1 - min1);\n}\n\nvec3 remap(const vec3 x, const vec3 min1, const vec3 max1) {\n  return (x - min1) / (max1 - min1);\n}\n\nvec4 remap(const vec4 x, const vec4 min1, const vec4 max1) {\n  return (x - min1) / (max1 - min1);\n}\n\nfloat remapClamped(const float x, const float min1, const float max1) {\n  return saturate((x - min1) / (max1 - min1));\n}\n\nvec2 remapClamped(const vec2 x, const vec2 min1, const vec2 max1) {\n  return saturate((x - min1) / (max1 - min1));\n}\n\nvec3 remapClamped(const vec3 x, const vec3 min1, const vec3 max1) {\n  return saturate((x - min1) / (max1 - min1));\n}\n\nvec4 remapClamped(const vec4 x, const vec4 min1, const vec4 max1) {\n  return saturate((x - min1) / (max1 - min1));\n}\n",li="// Reference: https://jcgt.org/published/0003/02/01/paper.pdf\n\nvec2 signNotZero(vec2 v) {\n  return vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);\n}\n\nvec2 packNormalToVec2(vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return v.z <= 0.0\n    ? (1.0 - abs(p.yx)) * signNotZero(p)\n    : p;\n}\n\nvec3 unpackVec2ToNormal(vec2 e) {\n  vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));\n  if (v.z < 0.0) {\n    v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);\n  }\n  return normalize(v);\n}\n",hi="float raySphereFirstIntersection(\n  const vec3 origin,\n  const vec3 direction,\n  const vec3 center,\n  const float radius\n) {\n  vec3 a = origin - center;\n  float b = 2.0 * dot(direction, a);\n  float c = dot(a, a) - radius * radius;\n  float discriminant = b * b - 4.0 * c;\n  return discriminant < 0.0\n    ? -1.0\n    : (-b - sqrt(discriminant)) * 0.5;\n}\n\nfloat raySphereFirstIntersection(const vec3 origin, const vec3 direction, const float radius) {\n  return raySphereFirstIntersection(origin, direction, vec3(0.0), radius);\n}\n\nvec4 raySphereFirstIntersection(\n  const vec3 origin,\n  const vec3 direction,\n  const vec3 center,\n  const vec4 radius\n) {\n  vec3 a = origin - center;\n  float b = 2.0 * dot(direction, a);\n  vec4 c = dot(a, a) - radius * radius;\n  vec4 discriminant = b * b - 4.0 * c;\n  vec4 mask = step(discriminant, vec4(0.0));\n  return mix((-b - sqrt(max(vec4(0.0), discriminant))) * 0.5, vec4(-1.0), mask);\n}\n\nvec4 raySphereFirstIntersection(const vec3 origin, const vec3 direction, const vec4 radius) {\n  return raySphereFirstIntersection(origin, direction, vec3(0.0), radius);\n}\n\nfloat raySphereSecondIntersection(\n  const vec3 origin,\n  const vec3 direction,\n  const vec3 center,\n  const float radius\n) {\n  vec3 a = origin - center;\n  float b = 2.0 * dot(direction, a);\n  float c = dot(a, a) - radius * radius;\n  float discriminant = b * b - 4.0 * c;\n  return discriminant < 0.0\n    ? -1.0\n    : (-b + sqrt(discriminant)) * 0.5;\n}\n\nfloat raySphereSecondIntersection(const vec3 origin, const vec3 direction, const float radius) {\n  return raySphereSecondIntersection(origin, direction, vec3(0.0), radius);\n}\n\nvec4 raySphereSecondIntersection(\n  const vec3 origin,\n  const vec3 direction,\n  const vec3 center,\n  const vec4 radius\n) {\n  vec3 a = origin - center;\n  float b = 2.0 * dot(direction, a);\n  vec4 c = dot(a, a) - radius * radius;\n  vec4 discriminant = b * b - 4.0 * c;\n  vec4 mask = step(discriminant, vec4(0.0));\n  return mix((-b + sqrt(max(vec4(0.0), discriminant))) * 0.5, vec4(-1.0), mask);\n}\n\nvec4 raySphereSecondIntersection(const vec3 origin, const vec3 direction, const vec4 radius) {\n  return raySphereSecondIntersection(origin, direction, vec3(0.0), radius);\n}\n\nvoid raySphereIntersections(\n  const vec3 origin,\n  const vec3 direction,\n  const vec3 center,\n  const float radius,\n  out float intersection1,\n  out float intersection2\n) {\n  vec3 a = origin - center;\n  float b = 2.0 * dot(direction, a);\n  float c = dot(a, a) - radius * radius;\n  float discriminant = b * b - 4.0 * c;\n  if (discriminant < 0.0) {\n    intersection1 = -1.0;\n    intersection2 = -1.0;\n    return;\n  } else {\n    float Q = sqrt(discriminant);\n    intersection1 = (-b - Q) * 0.5;\n    intersection2 = (-b + Q) * 0.5;\n  }\n}\n\nvoid raySphereIntersections(\n  const vec3 origin,\n  const vec3 direction,\n  const float radius,\n  out float intersection1,\n  out float intersection2\n) {\n  raySphereIntersections(origin, direction, vec3(0.0), radius, intersection1, intersection2);\n}\n\nvoid raySphereIntersections(\n  const vec3 origin,\n  const vec3 direction,\n  const vec3 center,\n  const vec4 radius,\n  out vec4 intersection1,\n  out vec4 intersection2\n) {\n  vec3 a = origin - center;\n  float b = 2.0 * dot(direction, a);\n  vec4 c = dot(a, a) - radius * radius;\n  vec4 discriminant = b * b - 4.0 * c;\n  vec4 mask = step(discriminant, vec4(0.0));\n  vec4 Q = sqrt(max(vec4(0.0), discriminant));\n  intersection1 = mix((-b - Q) * 0.5, vec4(-1.0), mask);\n  intersection2 = mix((-b + Q) * 0.5, vec4(-1.0), mask);\n}\n\nvoid raySphereIntersections(\n  const vec3 origin,\n  const vec3 direction,\n  const vec4 radius,\n  out vec4 intersection1,\n  out vec4 intersection2\n) {\n  raySphereIntersections(origin, direction, vec3(0.0), radius, intersection1, intersection2);\n}\n",di="vec3 screenToView(\n  const vec2 uv,\n  const float depth,\n  const float viewZ,\n  const mat4 projectionMatrix,\n  const mat4 inverseProjectionMatrix\n) {\n  vec4 clip = vec4(vec3(uv, depth) * 2.0 - 1.0, 1.0);\n  float clipW = projectionMatrix[2][3] * viewZ + projectionMatrix[3][3];\n  clip *= clipW;\n  return (inverseProjectionMatrix * clip).xyz;\n}\n",mi="// A fifth-order polynomial approximation of Turbo color map.\n// See: https://observablehq.com/@mbostock/turbo\n// prettier-ignore\nvec3 turbo(const float x) {\n  float r = 0.1357 + x * (4.5974 - x * (42.3277 - x * (130.5887 - x * (150.5666 - x * 58.1375))));\n  float g = 0.0914 + x * (2.1856 + x * (4.8052 - x * (14.0195 - x * (4.2109 + x * 2.7747))));\n  float b = 0.1067 + x * (12.5925 - x * (60.1097 - x * (109.0745 - x * (88.5066 - x * 26.8183))));\n  return vec3(r, g, b);\n}\n",pi="// Reference: https://www.gamedev.net/tutorials/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n\nvec2 vogelDisk(const int index, const int sampleCount, const float phi) {\n  const float goldenAngle = 2.39996322972865332;\n  float r = sqrt(float(index) + 0.5) / sqrt(float(sampleCount));\n  float theta = float(index) * goldenAngle + phi;\n  return r * vec2(cos(theta), sin(theta));\n}\n",fi='// Based on: https://github.com/ebruneton/precomputed_atmospheric_scattering/blob/master/atmosphere/functions.glsl\n\n/**\n * Copyright (c) 2017 Eric Bruneton\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Precomputed Atmospheric Scattering\n * Copyright (c) 2008 INRIA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nNumber ClampCosine(const Number mu) {\n  return clamp(mu, Number(-1.0), Number(1.0));\n}\n\nLength ClampDistance(const Length d) {\n  return max(d, 0.0 * m);\n}\n\nLength ClampRadius(const AtmosphereParameters atmosphere, const Length r) {\n  return clamp(r, atmosphere.bottom_radius, atmosphere.top_radius);\n}\n\nLength SafeSqrt(const Area a) {\n  return sqrt(max(a, 0.0 * m2));\n}\n\nLength DistanceToTopAtmosphereBoundary(const AtmosphereParameters atmosphere,\n    const Length r, const Number mu) {\n  assert(r <= atmosphere.top_radius);\n  assert(mu >= -1.0 && mu <= 1.0);\n  Area discriminant = r * r * (mu * mu - 1.0) +\n      atmosphere.top_radius * atmosphere.top_radius;\n  return ClampDistance(-r * mu + SafeSqrt(discriminant));\n}\n\nLength DistanceToBottomAtmosphereBoundary(const AtmosphereParameters atmosphere,\n    const Length r, const Number mu) {\n  assert(r >= atmosphere.bottom_radius);\n  assert(mu >= -1.0 && mu <= 1.0);\n  Area discriminant = r * r * (mu * mu - 1.0) +\n      atmosphere.bottom_radius * atmosphere.bottom_radius;\n  return ClampDistance(-r * mu - SafeSqrt(discriminant));\n}\n\nbool RayIntersectsGround(const AtmosphereParameters atmosphere,\n    const Length r, const Number mu) {\n  assert(r >= atmosphere.bottom_radius);\n  assert(mu >= -1.0 && mu <= 1.0);\n  return mu < 0.0 && r * r * (mu * mu - 1.0) +\n      atmosphere.bottom_radius * atmosphere.bottom_radius >= 0.0 * m2;\n}\n\nNumber GetTextureCoordFromUnitRange(const Number x, const int texture_size) {\n  return 0.5 / Number(texture_size) + x * (1.0 - 1.0 / Number(texture_size));\n}\n\nvec2 GetTransmittanceTextureUvFromRMu(const AtmosphereParameters atmosphere,\n    const Length r, const Number mu) {\n  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\n  assert(mu >= -1.0 && mu <= 1.0);\n  // Distance to top atmosphere boundary for a horizontal ray at ground level.\n  Length H = sqrt(atmosphere.top_radius * atmosphere.top_radius -\n      atmosphere.bottom_radius * atmosphere.bottom_radius);\n  // Distance to the horizon.\n  Length rho =\n      SafeSqrt(r * r - atmosphere.bottom_radius * atmosphere.bottom_radius);\n  // Distance to the top atmosphere boundary for the ray (r,mu), and its minimum\n  // and maximum values over all mu - obtained for (r,1) and (r,mu_horizon).\n  Length d = DistanceToTopAtmosphereBoundary(atmosphere, r, mu);\n  Length d_min = atmosphere.top_radius - r;\n  Length d_max = rho + H;\n  Number x_mu = (d - d_min) / (d_max - d_min);\n  Number x_r = rho / H;\n  return vec2(GetTextureCoordFromUnitRange(x_mu, TRANSMITTANCE_TEXTURE_WIDTH),\n              GetTextureCoordFromUnitRange(x_r, TRANSMITTANCE_TEXTURE_HEIGHT));\n}\n\nDimensionlessSpectrum GetTransmittanceToTopAtmosphereBoundary(\n    const AtmosphereParameters atmosphere,\n    const TransmittanceTexture transmittance_texture,\n    const Length r, const Number mu) {\n  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\n  vec2 uv = GetTransmittanceTextureUvFromRMu(atmosphere, r, mu);\n  // @shotamatsuda: Added for the precomputation stage in half-float precision.\n  #ifdef TRANSMITTANCE_PRECISION_LOG\n  // Manually interpolate the transmittance instead of the optical depth.\n  const vec2 size = vec2(TRANSMITTANCE_TEXTURE_WIDTH, TRANSMITTANCE_TEXTURE_HEIGHT);\n  const vec3 texel_size = vec3(1.0 / size, 0.0);\n  vec2 coord = (uv * size) - 0.5;\n  vec2 i = (floor(coord) + 0.5) * texel_size.xy;\n  vec2 f = fract(coord);\n  vec4 t1 = exp(-texture(transmittance_texture, i));\n  vec4 t2 = exp(-texture(transmittance_texture, i + texel_size.xz));\n  vec4 t3 = exp(-texture(transmittance_texture, i + texel_size.zy));\n  vec4 t4 = exp(-texture(transmittance_texture, i + texel_size.xy));\n  return DimensionlessSpectrum(mix(mix(t1, t2, f.x), mix(t3, t4, f.x), f.y));\n  #else // TRANSMITTANCE_PRECISION_LOG\n  return DimensionlessSpectrum(texture(transmittance_texture, uv));\n  #endif // TRANSMITTANCE_PRECISION_LOG\n}\n\nDimensionlessSpectrum GetTransmittance(\n    const AtmosphereParameters atmosphere,\n    const TransmittanceTexture transmittance_texture,\n    const Length r, const Number mu, const Length d,\n    const bool ray_r_mu_intersects_ground) {\n  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\n  assert(mu >= -1.0 && mu <= 1.0);\n  assert(d >= 0.0 * m);\n\n  Length r_d = ClampRadius(atmosphere, sqrt(d * d + 2.0 * r * mu * d + r * r));\n  Number mu_d = ClampCosine((r * mu + d) / r_d);\n\n  if (ray_r_mu_intersects_ground) {\n    return min(\n        GetTransmittanceToTopAtmosphereBoundary(\n            atmosphere, transmittance_texture, r_d, -mu_d) /\n        GetTransmittanceToTopAtmosphereBoundary(\n            atmosphere, transmittance_texture, r, -mu),\n        DimensionlessSpectrum(1.0));\n  } else {\n    return min(\n        GetTransmittanceToTopAtmosphereBoundary(\n            atmosphere, transmittance_texture, r, mu) /\n        GetTransmittanceToTopAtmosphereBoundary(\n            atmosphere, transmittance_texture, r_d, mu_d),\n        DimensionlessSpectrum(1.0));\n  }\n}\n\nDimensionlessSpectrum GetTransmittanceToSun(\n    const AtmosphereParameters atmosphere,\n    const TransmittanceTexture transmittance_texture,\n    const Length r, const Number mu_s) {\n  Number sin_theta_h = atmosphere.bottom_radius / r;\n  Number cos_theta_h = -sqrt(max(1.0 - sin_theta_h * sin_theta_h, 0.0));\n  return GetTransmittanceToTopAtmosphereBoundary(\n          atmosphere, transmittance_texture, r, mu_s) *\n      smoothstep(-sin_theta_h * atmosphere.sun_angular_radius / rad,\n                 sin_theta_h * atmosphere.sun_angular_radius / rad,\n                 mu_s - cos_theta_h);\n}\n\nInverseSolidAngle RayleighPhaseFunction(const Number nu) {\n  InverseSolidAngle k = 3.0 / (16.0 * PI * sr);\n  return k * (1.0 + nu * nu);\n}\n\nInverseSolidAngle MiePhaseFunction(const Number g, const Number nu) {\n  InverseSolidAngle k = 3.0 / (8.0 * PI * sr) * (1.0 - g * g) / (2.0 + g * g);\n  return k * (1.0 + nu * nu) / pow(1.0 + g * g - 2.0 * g * nu, 1.5);\n}\n\nvec4 GetScatteringTextureUvwzFromRMuMuSNu(const AtmosphereParameters atmosphere,\n    const Length r, const Number mu, const Number mu_s, const Number nu,\n    const bool ray_r_mu_intersects_ground) {\n  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\n  assert(mu >= -1.0 && mu <= 1.0);\n  assert(mu_s >= -1.0 && mu_s <= 1.0);\n  assert(nu >= -1.0 && nu <= 1.0);\n\n  // Distance to top atmosphere boundary for a horizontal ray at ground level.\n  Length H = sqrt(atmosphere.top_radius * atmosphere.top_radius -\n      atmosphere.bottom_radius * atmosphere.bottom_radius);\n  // Distance to the horizon.\n  Length rho =\n      SafeSqrt(r * r - atmosphere.bottom_radius * atmosphere.bottom_radius);\n  Number u_r = GetTextureCoordFromUnitRange(rho / H, SCATTERING_TEXTURE_R_SIZE);\n\n  // Discriminant of the quadratic equation for the intersections of the ray\n  // (r,mu) with the ground (see RayIntersectsGround).\n  Length r_mu = r * mu;\n  Area discriminant =\n      r_mu * r_mu - r * r + atmosphere.bottom_radius * atmosphere.bottom_radius;\n  Number u_mu;\n  if (ray_r_mu_intersects_ground) {\n    // Distance to the ground for the ray (r,mu), and its minimum and maximum\n    // values over all mu - obtained for (r,-1) and (r,mu_horizon).\n    Length d = -r_mu - SafeSqrt(discriminant);\n    Length d_min = r - atmosphere.bottom_radius;\n    Length d_max = rho;\n    u_mu = 0.5 - 0.5 * GetTextureCoordFromUnitRange(d_max == d_min ? 0.0 :\n        (d - d_min) / (d_max - d_min), SCATTERING_TEXTURE_MU_SIZE / 2);\n  } else {\n    // Distance to the top atmosphere boundary for the ray (r,mu), and its\n    // minimum and maximum values over all mu - obtained for (r,1) and\n    // (r,mu_horizon).\n    Length d = -r_mu + SafeSqrt(discriminant + H * H);\n    Length d_min = atmosphere.top_radius - r;\n    Length d_max = rho + H;\n    u_mu = 0.5 + 0.5 * GetTextureCoordFromUnitRange(\n        (d - d_min) / (d_max - d_min), SCATTERING_TEXTURE_MU_SIZE / 2);\n  }\n\n  Length d = DistanceToTopAtmosphereBoundary(\n      atmosphere, atmosphere.bottom_radius, mu_s);\n  Length d_min = atmosphere.top_radius - atmosphere.bottom_radius;\n  Length d_max = H;\n  Number a = (d - d_min) / (d_max - d_min);\n  Length D = DistanceToTopAtmosphereBoundary(\n      atmosphere, atmosphere.bottom_radius, atmosphere.mu_s_min);\n  Number A = (D - d_min) / (d_max - d_min);\n  // An ad-hoc function equal to 0 for mu_s = mu_s_min (because then d = D and\n  // thus a = A), equal to 1 for mu_s = 1 (because then d = d_min and thus\n  // a = 0), and with a large slope around mu_s = 0, to get more texture\n  // samples near the horizon.\n  Number u_mu_s = GetTextureCoordFromUnitRange(\n      max(1.0 - a / A, 0.0) / (1.0 + a), SCATTERING_TEXTURE_MU_S_SIZE);\n\n  Number u_nu = (nu + 1.0) / 2.0;\n  return vec4(u_nu, u_mu_s, u_mu, u_r);\n}\n\nvec2 GetIrradianceTextureUvFromRMuS(const AtmosphereParameters atmosphere,\n    const Length r, const Number mu_s) {\n  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\n  assert(mu_s >= -1.0 && mu_s <= 1.0);\n  Number x_r = (r - atmosphere.bottom_radius) /\n      (atmosphere.top_radius - atmosphere.bottom_radius);\n  Number x_mu_s = mu_s * 0.5 + 0.5;\n  return vec2(GetTextureCoordFromUnitRange(x_mu_s, IRRADIANCE_TEXTURE_WIDTH),\n              GetTextureCoordFromUnitRange(x_r, IRRADIANCE_TEXTURE_HEIGHT));\n}\n\nIrradianceSpectrum GetIrradiance(\n    const AtmosphereParameters atmosphere,\n    const IrradianceTexture irradiance_texture,\n    const Length r, const Number mu_s) {\n  vec2 uv = GetIrradianceTextureUvFromRMuS(atmosphere, r, mu_s);\n  return IrradianceSpectrum(texture(irradiance_texture, uv));\n}\n',vi='// Based on: https://github.com/ebruneton/precomputed_atmospheric_scattering/blob/master/atmosphere/definitions.glsl\n\n/**\n * Copyright (c) 2017 Eric Bruneton\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#define assert(x)\n\n#define Length float\n#define Wavelength float\n#define Angle float\n#define SolidAngle float\n#define Power float\n#define LuminousPower float\n\n#define Number float\n#define InverseLength float\n#define Area float\n#define Volume float\n#define NumberDensity float\n#define Irradiance float\n#define Radiance float\n#define SpectralPower float\n#define SpectralIrradiance float\n#define SpectralRadiance float\n#define SpectralRadianceDensity float\n#define ScatteringCoefficient float\n#define InverseSolidAngle float\n#define LuminousIntensity float\n#define Luminance float\n#define Illuminance float\n\n// A generic function from Wavelength to some other type.\n#define AbstractSpectrum vec3\n// A function from Wavelength to Number.\n#define DimensionlessSpectrum vec3\n// A function from Wavelength to SpectralPower.\n#define PowerSpectrum vec3\n// A function from Wavelength to SpectralIrradiance.\n#define IrradianceSpectrum vec3\n// A function from Wavelength to SpectralRadiance.\n#define RadianceSpectrum vec3\n// A function from Wavelength to SpectralRadianceDensity.\n#define RadianceDensitySpectrum vec3\n// A function from Wavelength to ScatteringCoefficient.\n#define ScatteringSpectrum vec3\n\n// A position in 3D (3 length values).\n#define Position vec3\n// A unit direction vector in 3D (3 unit-less values).\n#define Direction vec3\n// A vector of 3 luminance values.\n#define Luminance3 vec3\n// A vector of 3 illuminance values.\n#define Illuminance3 vec3\n\n#define TransmittanceTexture sampler2D\n#define AbstractScatteringTexture sampler3D\n#define ReducedScatteringTexture sampler3D\n#define ScatteringTexture sampler3D\n#define ScatteringDensityTexture sampler3D\n#define IrradianceTexture sampler2D\n\nconst Length m = 1.0;\nconst Wavelength nm = 1.0;\nconst Angle rad = 1.0;\nconst SolidAngle sr = 1.0;\nconst Power watt = 1.0;\nconst LuminousPower lm = 1.0;\n\n#if !defined(PI)\nconst float PI = 3.14159265358979323846;\n#endif // !defined(PI)\n\nconst Length km = 1000.0 * m;\nconst Area m2 = m * m;\nconst Volume m3 = m * m * m;\nconst Angle pi = PI * rad;\nconst Angle deg = pi / 180.0;\nconst Irradiance watt_per_square_meter = watt / m2;\nconst Radiance watt_per_square_meter_per_sr = watt / (m2 * sr);\nconst SpectralIrradiance watt_per_square_meter_per_nm = watt / (m2 * nm);\nconst SpectralRadiance watt_per_square_meter_per_sr_per_nm = watt / (m2 * sr * nm);\nconst SpectralRadianceDensity watt_per_cubic_meter_per_sr_per_nm = watt / (m3 * sr * nm);\nconst LuminousIntensity cd = lm / sr;\nconst LuminousIntensity kcd = 1000.0 * cd;\nconst Luminance cd_per_square_meter = cd / m2;\nconst Luminance kcd_per_square_meter = kcd / m2;\n\nstruct DensityProfileLayer {\n  Length width;\n  Number exp_term;\n  InverseLength exp_scale;\n  InverseLength linear_term;\n  Number constant_term;\n};\n\nstruct DensityProfile {\n  DensityProfileLayer layers[2];\n};\n\n// See AtmosphereParameter.ts for further details.\nstruct AtmosphereParameters {\n  IrradianceSpectrum solar_irradiance;\n  Angle sun_angular_radius;\n  Length bottom_radius;\n  Length top_radius;\n  DensityProfile rayleigh_density;\n  ScatteringSpectrum rayleigh_scattering;\n  DensityProfile mie_density;\n  ScatteringSpectrum mie_scattering;\n  ScatteringSpectrum mie_extinction;\n  Number mie_phase_function_g;\n  DensityProfile absorption_density;\n  ScatteringSpectrum absorption_extinction;\n  DimensionlessSpectrum ground_albedo;\n  Number mu_s_min;\n};\n',gi='// Based on: https://github.com/ebruneton/precomputed_atmospheric_scattering/blob/master/atmosphere/functions.glsl\n\n/**\n * Copyright (c) 2017 Eric Bruneton\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Precomputed Atmospheric Scattering\n * Copyright (c) 2008 INRIA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef COMBINED_SCATTERING_TEXTURES\nvec3 GetExtrapolatedSingleMieScattering(\n    const AtmosphereParameters atmosphere, const vec4 scattering) {\n  // Algebraically this can never be negative, but rounding errors can produce\n  // that effect for sufficiently short view rays.\n  // @shotamatsuda: Avoid division by infinitesimal values.\n  // See https://github.com/takram-design-engineering/three-geospatial/issues/47\n  if (scattering.r < 1e-5) {\n    return vec3(0.0);\n  }\n  return scattering.rgb * scattering.a / scattering.r *\n\t    (atmosphere.rayleigh_scattering.r / atmosphere.mie_scattering.r) *\n\t    (atmosphere.mie_scattering / atmosphere.rayleigh_scattering);\n}\n#endif // COMBINED_SCATTERING_TEXTURES\n\nIrradianceSpectrum GetCombinedScattering(\n    const AtmosphereParameters atmosphere,\n    const ReducedScatteringTexture scattering_texture,\n    const ReducedScatteringTexture single_mie_scattering_texture,\n    const Length r, const Number mu, const Number mu_s, const Number nu,\n    const bool ray_r_mu_intersects_ground,\n    out IrradianceSpectrum single_mie_scattering) {\n  vec4 uvwz = GetScatteringTextureUvwzFromRMuMuSNu(\n      atmosphere, r, mu, mu_s, nu, ray_r_mu_intersects_ground);\n  Number tex_coord_x = uvwz.x * Number(SCATTERING_TEXTURE_NU_SIZE - 1);\n  Number tex_x = floor(tex_coord_x);\n  Number lerp = tex_coord_x - tex_x;\n  vec3 uvw0 = vec3((tex_x + uvwz.y) / Number(SCATTERING_TEXTURE_NU_SIZE),\n      uvwz.z, uvwz.w);\n  vec3 uvw1 = vec3((tex_x + 1.0 + uvwz.y) / Number(SCATTERING_TEXTURE_NU_SIZE),\n      uvwz.z, uvwz.w);\n#ifdef COMBINED_SCATTERING_TEXTURES\n  vec4 combined_scattering =\n      texture(scattering_texture, uvw0) * (1.0 - lerp) +\n      texture(scattering_texture, uvw1) * lerp;\n  IrradianceSpectrum scattering = IrradianceSpectrum(combined_scattering);\n  single_mie_scattering =\n      GetExtrapolatedSingleMieScattering(atmosphere, combined_scattering);\n#else // COMBINED_SCATTERING_TEXTURES\n  IrradianceSpectrum scattering = IrradianceSpectrum(\n      texture(scattering_texture, uvw0) * (1.0 - lerp) +\n      texture(scattering_texture, uvw1) * lerp);\n  single_mie_scattering = IrradianceSpectrum(\n      texture(single_mie_scattering_texture, uvw0) * (1.0 - lerp) +\n      texture(single_mie_scattering_texture, uvw1) * lerp);\n#endif // COMBINED_SCATTERING_TEXTURES\n  return scattering;\n}\n\n// @shotamatsuda: Added for reading higher-order scattering texture.\n#ifdef HAS_HIGHER_ORDER_SCATTERING_TEXTURE\nIrradianceSpectrum GetScattering(\n    const AtmosphereParameters atmosphere,\n    const ReducedScatteringTexture scattering_texture,\n    const Length r, const Number mu, const Number mu_s, const Number nu,\n    const bool ray_r_mu_intersects_ground) {\n  vec4 uvwz = GetScatteringTextureUvwzFromRMuMuSNu(\n      atmosphere, r, mu, mu_s, nu, ray_r_mu_intersects_ground);\n  Number tex_coord_x = uvwz.x * Number(SCATTERING_TEXTURE_NU_SIZE - 1);\n  Number tex_x = floor(tex_coord_x);\n  Number lerp = tex_coord_x - tex_x;\n  vec3 uvw0 = vec3((tex_x + uvwz.y) / Number(SCATTERING_TEXTURE_NU_SIZE),\n      uvwz.z, uvwz.w);\n  vec3 uvw1 = vec3((tex_x + 1.0 + uvwz.y) / Number(SCATTERING_TEXTURE_NU_SIZE),\n      uvwz.z, uvwz.w);\n  IrradianceSpectrum scattering = IrradianceSpectrum(\n      texture(scattering_texture, uvw0) * (1.0 - lerp) +\n      texture(scattering_texture, uvw1) * lerp);\n  return scattering;\n}\n#endif // HAS_HIGHER_ORDER_SCATTERING_TEXTURE\n\nRadianceSpectrum GetSkyRadiance(\n    const AtmosphereParameters atmosphere,\n    const TransmittanceTexture transmittance_texture,\n    const ReducedScatteringTexture scattering_texture,\n    const ReducedScatteringTexture single_mie_scattering_texture,\n    Position camera, const Direction view_ray, const Length shadow_length,\n    const Direction sun_direction,\n    out DimensionlessSpectrum transmittance) {\n  // Compute the distance to the top atmosphere boundary along the view ray,\n  // assuming the viewer is in space (or NaN if the view ray does not intersect\n  // the atmosphere).\n  Length r = length(camera);\n  Length rmu = dot(camera, view_ray);\n  // @shotamatsuda: Use SafeSqrt instead.\n  // See: https://github.com/takram-design-engineering/three-geospatial/pull/26\n  Length distance_to_top_atmosphere_boundary = -rmu -\n      SafeSqrt(rmu * rmu - r * r +\n          atmosphere.top_radius * atmosphere.top_radius);\n  // If the viewer is in space and the view ray intersects the atmosphere, move\n  // the viewer to the top atmosphere boundary (along the view ray):\n  if (distance_to_top_atmosphere_boundary > 0.0 * m) {\n    camera = camera + view_ray * distance_to_top_atmosphere_boundary;\n    r = atmosphere.top_radius;\n    rmu += distance_to_top_atmosphere_boundary;\n  } else if (r > atmosphere.top_radius) {\n    // If the view ray does not intersect the atmosphere, simply return 0.\n    transmittance = DimensionlessSpectrum(1.0);\n    return RadianceSpectrum(0.0 * watt_per_square_meter_per_sr_per_nm);\n  }\n  // Compute the r, mu, mu_s and nu parameters needed for the texture lookups.\n  Number mu = rmu / r;\n  Number mu_s = dot(camera, sun_direction) / r;\n  Number nu = dot(view_ray, sun_direction);\n\n  // @shotamatsuda: For rendering points below the bottom atmosphere.\n  #ifdef GROUND\n  bool ray_r_mu_intersects_ground = RayIntersectsGround(atmosphere, r, mu);\n  #else // GROUND\n  bool ray_r_mu_intersects_ground = false;\n  #endif // GROUND\n\n  transmittance = ray_r_mu_intersects_ground ? DimensionlessSpectrum(0.0) :\n      GetTransmittanceToTopAtmosphereBoundary(\n          atmosphere, transmittance_texture, r, mu);\n  IrradianceSpectrum single_mie_scattering;\n  IrradianceSpectrum scattering;\n  if (shadow_length == 0.0 * m) {\n    scattering = GetCombinedScattering(\n        atmosphere, scattering_texture, single_mie_scattering_texture,\n        r, mu, mu_s, nu, ray_r_mu_intersects_ground,\n        single_mie_scattering);\n  } else {\n    // Case of light shafts (shadow_length is the total length noted l in our\n    // paper): we omit the scattering between the camera and the point at\n    // distance l, by implementing Eq. (18) of the paper (shadow_transmittance\n    // is the T(x,x_s) term, scattering is the S|x_s=x+lv term).\n    Length d = shadow_length;\n    Length r_p =\n        ClampRadius(atmosphere, sqrt(d * d + 2.0 * r * mu * d + r * r));\n    Number mu_p = (r * mu + d) / r_p;\n    Number mu_s_p = (r * mu_s + d * nu) / r_p;\n\n    scattering = GetCombinedScattering(\n        atmosphere, scattering_texture, single_mie_scattering_texture,\n        r_p, mu_p, mu_s_p, nu, ray_r_mu_intersects_ground,\n        single_mie_scattering);\n    DimensionlessSpectrum shadow_transmittance =\n        GetTransmittance(atmosphere, transmittance_texture,\n            r, mu, shadow_length, ray_r_mu_intersects_ground);\n    // @shotamatsuda: Occlude only single Rayleigh scattering by the shadow.\n#ifdef HAS_HIGHER_ORDER_SCATTERING_TEXTURE\n    IrradianceSpectrum higher_order_scattering = GetScattering(\n        atmosphere, higher_order_scattering_texture,\n        r_p, mu_p, mu_s_p, nu, ray_r_mu_intersects_ground);\n    IrradianceSpectrum single_scattering = scattering - higher_order_scattering;\n    scattering = single_scattering * shadow_transmittance + higher_order_scattering;\n#else // HAS_HIGHER_ORDER_SCATTERING_TEXTURE\n    scattering = scattering * shadow_transmittance;\n#endif // HAS_HIGHER_ORDER_SCATTERING_TEXTURE\n    single_mie_scattering = single_mie_scattering * shadow_transmittance;\n  }\n  return scattering * RayleighPhaseFunction(nu) + single_mie_scattering *\n      MiePhaseFunction(atmosphere.mie_phase_function_g, nu);\n}\n\n// @shotamatsuda: Returns the point on the ray closest to the origin.\nvec3 ClosestPointOnRay(const Position camera, const Position point) {\n  Position ray = point - camera;\n  Number t = clamp(-dot(camera, ray) / dot(ray, ray), 0.0, 1.0);\n  return camera + t * ray;\n}\n\nvec2 RaySphereIntersections(\n    const Position camera, const Direction direction, const Length radius) {\n  float b = 2.0 * dot(direction, camera);\n  float c = dot(camera, camera) - radius * radius;\n  float discriminant = b * b - 4.0 * c;\n  float Q = sqrt(discriminant);\n  return vec2(-b - Q, -b + Q) * 0.5;\n}\n\n// @shotamatsuda: Clip the view ray at the bottom atmosphere boundary.\nbool ClipAtBottomAtmosphere(\n    const AtmosphereParameters atmosphere,\n    const Direction view_ray, inout Position camera, inout Position point) {\n  const Length eps = 0.0;\n  Length bottom_radius = atmosphere.bottom_radius + eps;\n  Length r_camera = length(camera);\n  Length r_point = length(point);\n  bool camera_below = r_camera < bottom_radius;\n  bool point_below = r_point < bottom_radius;\n\n  vec2 t = RaySphereIntersections(camera, view_ray, bottom_radius);\n  Position intersection = camera + view_ray * (camera_below ? t.y : t.x);\n  camera = camera_below ? intersection : camera;\n  point = point_below ? intersection : point;\n\n  return camera_below && point_below;\n}\n\nRadianceSpectrum GetSkyRadianceToPoint(\n    const AtmosphereParameters atmosphere,\n    const TransmittanceTexture transmittance_texture,\n    const ReducedScatteringTexture scattering_texture,\n    const ReducedScatteringTexture single_mie_scattering_texture,\n    Position camera, Position point, const Length shadow_length,\n    const Direction sun_direction, out DimensionlessSpectrum transmittance) {\n  // @shotamatsuda: Avoid artifacts when the ray does not intersect the top\n  // atmosphere boundary.\n  if (length(ClosestPointOnRay(camera, point)) > atmosphere.top_radius) {\n    transmittance = vec3(1.0);\n    return vec3(0.0);\n  }\n\n  Direction view_ray = normalize(point - camera);\n  if (ClipAtBottomAtmosphere(atmosphere, view_ray, camera, point)) {\n    transmittance = vec3(1.0);\n    return vec3(0.0);\n  }\n\n  // Compute the distance to the top atmosphere boundary along the view ray,\n  // assuming the viewer is in space (or NaN if the view ray does not intersect\n  // the atmosphere).\n  Length r = length(camera);\n  Length rmu = dot(camera, view_ray);\n  // @shotamatsuda: Use SafeSqrt instead.\n  // See: https://github.com/takram-design-engineering/three-geospatial/pull/26\n  Length distance_to_top_atmosphere_boundary = -rmu -\n      SafeSqrt(rmu * rmu - r * r +\n          atmosphere.top_radius * atmosphere.top_radius);\n  // If the viewer is in space and the view ray intersects the atmosphere, move\n  // the viewer to the top atmosphere boundary (along the view ray):\n  if (distance_to_top_atmosphere_boundary > 0.0 * m) {\n    camera = camera + view_ray * distance_to_top_atmosphere_boundary;\n    r = atmosphere.top_radius;\n    rmu += distance_to_top_atmosphere_boundary;\n  }\n\n  // Compute the r, mu, mu_s and nu parameters for the first texture lookup.\n  Number mu = rmu / r;\n  Number mu_s = dot(camera, sun_direction) / r;\n  Number nu = dot(view_ray, sun_direction);\n  Length d = length(point - camera);\n  bool ray_r_mu_intersects_ground = RayIntersectsGround(atmosphere, r, mu);\n\n  // @shotamatsuda: Hack to avoid rendering artifacts near the horizon, due to\n  // finite atmosphere texture resolution and finite floating point precision.\n  // See: https://github.com/ebruneton/precomputed_atmospheric_scattering/pull/32\n  if (!ray_r_mu_intersects_ground) {\n    Number mu_horizon = -SafeSqrt(1.0 -\n        (atmosphere.bottom_radius * atmosphere.bottom_radius) / (r * r));\n    const Number eps = 0.004;\n    mu = max(mu, mu_horizon + eps);\n  }\n\n  transmittance = GetTransmittance(atmosphere, transmittance_texture,\n      r, mu, d, ray_r_mu_intersects_ground);\n\n  IrradianceSpectrum single_mie_scattering;\n  IrradianceSpectrum scattering = GetCombinedScattering(\n      atmosphere, scattering_texture, single_mie_scattering_texture,\n      r, mu, mu_s, nu, ray_r_mu_intersects_ground,\n      single_mie_scattering);\n\n  // Compute the r, mu, mu_s and nu parameters for the second texture lookup.\n  // If shadow_length is not 0 (case of light shafts), we want to ignore the\n  // scattering along the last shadow_length meters of the view ray, which we\n  // do by subtracting shadow_length from d (this way scattering_p is equal to\n  // the S|x_s=x_0-lv term in Eq. (17) of our paper).\n  d = max(d - shadow_length, 0.0 * m);\n  Length r_p = ClampRadius(atmosphere, sqrt(d * d + 2.0 * r * mu * d + r * r));\n  Number mu_p = (r * mu + d) / r_p;\n  Number mu_s_p = (r * mu_s + d * nu) / r_p;\n\n  IrradianceSpectrum single_mie_scattering_p;\n  IrradianceSpectrum scattering_p = GetCombinedScattering(\n      atmosphere, scattering_texture, single_mie_scattering_texture,\n      r_p, mu_p, mu_s_p, nu, ray_r_mu_intersects_ground,\n      single_mie_scattering_p);\n\n  // Combine the lookup results to get the scattering between camera and point.\n  DimensionlessSpectrum shadow_transmittance = transmittance;\n  if (shadow_length > 0.0 * m) {\n    // This is the T(x,x_s) term in Eq. (17) of our paper, for light shafts.\n    shadow_transmittance = GetTransmittance(atmosphere, transmittance_texture,\n        r, mu, d, ray_r_mu_intersects_ground);\n  }\n  // @shotamatsuda: Occlude only single Rayleigh scattering by the shadow.\n#ifdef HAS_HIGHER_ORDER_SCATTERING_TEXTURE\n  IrradianceSpectrum higher_order_scattering = GetScattering(\n      atmosphere, higher_order_scattering_texture,\n      r, mu, mu_s, nu, ray_r_mu_intersects_ground);\n  IrradianceSpectrum single_scattering = scattering - higher_order_scattering;\n  IrradianceSpectrum higher_order_scattering_p = GetScattering(\n      atmosphere, higher_order_scattering_texture,\n      r_p, mu_p, mu_s_p, nu, ray_r_mu_intersects_ground);\n  IrradianceSpectrum single_scattering_p =\n      scattering_p - higher_order_scattering_p;\n  scattering =\n      single_scattering - shadow_transmittance * single_scattering_p +\n      higher_order_scattering - transmittance * higher_order_scattering_p;\n#else // HAS_HIGHER_ORDER_SCATTERING_TEXTURE\n  scattering = scattering - shadow_transmittance * scattering_p;\n#endif // HAS_HIGHER_ORDER_SCATTERING_TEXTURE\n\n  single_mie_scattering =\n      single_mie_scattering - shadow_transmittance * single_mie_scattering_p;\n#ifdef COMBINED_SCATTERING_TEXTURES\n  single_mie_scattering = GetExtrapolatedSingleMieScattering(\n      atmosphere, vec4(scattering, single_mie_scattering.r));\n#endif // COMBINED_SCATTERING_TEXTURES\n\n  // Hack to avoid rendering artifacts when the sun is below the horizon.\n  single_mie_scattering = single_mie_scattering *\n      smoothstep(Number(0.0), Number(0.01), mu_s);\n\n  return scattering * RayleighPhaseFunction(nu) + single_mie_scattering *\n      MiePhaseFunction(atmosphere.mie_phase_function_g, nu);\n}\n\nIrradianceSpectrum GetSunAndSkyIrradiance(\n    const AtmosphereParameters atmosphere,\n    const TransmittanceTexture transmittance_texture,\n    const IrradianceTexture irradiance_texture,\n    const Position point, const Direction normal, const Direction sun_direction,\n    out IrradianceSpectrum sky_irradiance) {\n  Length r = length(point);\n  Number mu_s = dot(point, sun_direction) / r;\n\n  // Indirect irradiance (approximated if the surface is not horizontal).\n  sky_irradiance = GetIrradiance(atmosphere, irradiance_texture, r, mu_s) *\n      (1.0 + dot(normal, point) / r) * 0.5;\n\n  // Direct irradiance.\n  return atmosphere.solar_irradiance *\n      GetTransmittanceToSun(\n          atmosphere, transmittance_texture, r, mu_s) *\n      max(dot(normal, sun_direction), 0.0);\n}\n\n// @shotamatsuda: Added for the clouds.\nIrradianceSpectrum GetSunAndSkyScalarIrradiance(\n    const AtmosphereParameters atmosphere,\n    const TransmittanceTexture transmittance_texture,\n    const IrradianceTexture irradiance_texture,\n    const Position point, const Direction sun_direction,\n    out IrradianceSpectrum sky_irradiance) {\n  Length r = length(point);\n  Number mu_s = dot(point, sun_direction) / r;\n\n  // Indirect irradiance. Integral over sphere yields 2.\n  sky_irradiance = GetIrradiance(atmosphere, irradiance_texture, r, mu_s) *\n      2.0 * PI;\n\n  // Direct irradiance. Omit the cosine term.\n  return atmosphere.solar_irradiance *\n      GetTransmittanceToSun(atmosphere, transmittance_texture, r, mu_s);\n}\n\nLuminance3 GetSolarLuminance() {\n  return ATMOSPHERE.solar_irradiance /\n      (PI * ATMOSPHERE.sun_angular_radius * ATMOSPHERE.sun_angular_radius) *\n      SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;\n}\n\nLuminance3 GetSkyLuminance(\n    const Position camera, Direction view_ray, const Length shadow_length,\n    const Direction sun_direction, out DimensionlessSpectrum transmittance) {\n  return GetSkyRadiance(ATMOSPHERE, transmittance_texture,\n      scattering_texture, single_mie_scattering_texture,\n      camera, view_ray, shadow_length, sun_direction,\n      transmittance) * SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;\n}\n\nLuminance3 GetSkyLuminanceToPoint(\n    const Position camera, const Position point, const Length shadow_length,\n    const Direction sun_direction, out DimensionlessSpectrum transmittance) {\n  return GetSkyRadianceToPoint(ATMOSPHERE, transmittance_texture,\n      scattering_texture, single_mie_scattering_texture,\n      camera, point, shadow_length, sun_direction, transmittance) *\n      SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;\n}\n\nIlluminance3 GetSunAndSkyIlluminance(\n    const Position p, const Direction normal, const Direction sun_direction,\n    out IrradianceSpectrum sky_irradiance) {\n  IrradianceSpectrum sun_irradiance = GetSunAndSkyIrradiance(\n      ATMOSPHERE, transmittance_texture, irradiance_texture, p, normal,\n      sun_direction, sky_irradiance);\n  sky_irradiance *= SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;\n  return sun_irradiance * SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;\n}\n\n// @shotamatsuda: Added for the clouds.\nIlluminance3 GetSunAndSkyScalarIlluminance(\n    const Position p, const Direction sun_direction,\n    out IrradianceSpectrum sky_irradiance) {\n  IrradianceSpectrum sun_irradiance = GetSunAndSkyScalarIrradiance(\n      ATMOSPHERE, transmittance_texture, irradiance_texture, p,\n      sun_direction, sky_irradiance);\n  sky_irradiance *= SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;\n  return sun_irradiance * SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;\n}\n\n#define GetSolarRadiance GetSolarLuminance\n#define GetSkyRadiance GetSkyLuminance\n#define GetSkyRadianceToPoint GetSkyLuminanceToPoint\n#define GetSunAndSkyIrradiance GetSunAndSkyIlluminance\n#define GetSunAndSkyScalarIrradiance GetSunAndSkyScalarIlluminance\n',Si=256,wi=.001,yi=new u(.2126,.7152,.0722),_i=["solarIrradiance","sunAngularRadius","bottomRadius","topRadius","rayleighDensity","rayleighScattering","mieDensity","mieScattering","mieExtinction","miePhaseFunctionG","absorptionDensity","absorptionExtinction","groundAlbedo","muSMin","skyRadianceToLuminance","sunRadianceToLuminance"];class xi{constructor(e,t,n,r,i){this.width=e,this.expTerm=t,this.expScale=n,this.linearTerm=r,this.constantTerm=i}toUniform(){return new G({width:this.width,exp_term:this.expTerm,exp_scale:this.expScale,linear_term:this.linearTerm,constant_term:this.constantTerm})}}const Ti=class{constructor(e){this.solarIrradiance=new u(1.474,1.8504,1.91198),this.sunAngularRadius=.004675,this.bottomRadius=636e4,this.topRadius=642e4,this.rayleighDensity=[new xi(0,0,0,0,0),new xi(0,1,-.125,0,0)],this.rayleighScattering=new u(.005802,.013558,.0331),this.mieDensity=[new xi(0,0,0,0,0),new xi(0,1,-.833333,0,0)],this.mieScattering=new u(.003996,.003996,.003996),this.mieExtinction=new u(.00444,.00444,.00444),this.miePhaseFunctionG=.8,this.absorptionDensity=[new xi(25,0,0,1/15,-2/3),new xi(0,0,0,-1/15,8/3)],this.absorptionExtinction=new u(65e-5,.001881,85e-6),this.groundAlbedo=(new W).setScalar(.1),this.muSMin=Math.cos(er(120)),this.sunRadianceToLuminance=new u(98242.786222,69954.398112,66475.012354),this.skyRadianceToLuminance=new u(114974.916437,71305.954816,65310.548555),this.sunRadianceToRelativeLuminance=new u,this.skyRadianceToRelativeLuminance=new u,function(e,t){if(null!=t)for(const n of _i){const r=t[n];null!=r&&(e[n]instanceof u?e[n].copy(r):e[n]=r)}}(this,e);const t=yi.dot(this.sunRadianceToLuminance);this.sunRadianceToRelativeLuminance.copy(this.sunRadianceToLuminance).divideScalar(t),this.skyRadianceToRelativeLuminance.copy(this.skyRadianceToLuminance).divideScalar(t)}toUniform(){return new G({solar_irradiance:this.solarIrradiance,sun_angular_radius:this.sunAngularRadius,bottom_radius:this.bottomRadius*wi,top_radius:this.topRadius*wi,rayleigh_density:{layers:this.rayleighDensity.map(e=>e.toUniform().value)},rayleigh_scattering:this.rayleighScattering,mie_density:{layers:this.mieDensity.map(e=>e.toUniform().value)},mie_scattering:this.mieScattering,mie_extinction:this.mieExtinction,mie_phase_function_g:this.miePhaseFunctionG,absorption_density:{layers:this.absorptionDensity.map(e=>e.toUniform().value)},absorption_extinction:this.absorptionExtinction,ground_albedo:this.groundAlbedo,mu_s_min:this.muSMin})}};Ti.DEFAULT=new Ti;let Ei=Ti;const Ai=new u;function Ri(e,t,n,r){const i=n.projectOnSurface(e,Ai);return null!=i?n.getOsculatingSphereCenter(i,t,r).negate():r.setScalar(0)}const Ci="vec3 getLunarRadiance(const float moonAngularRadius) {\n  // Not a physical number but the order of 10^-6 relative to the sun may fit.\n  vec3 radiance =\n    ATMOSPHERE.solar_irradiance *\n    0.000002 /\n    (PI * moonAngularRadius * moonAngularRadius) *\n    SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;\n  return radiance;\n}\n\nfloat intersectSphere(const vec3 ray, const vec3 point, const float radius) {\n  vec3 P = -point;\n  float PoR = dot(P, ray);\n  float D = dot(P, P) - radius * radius;\n  return -PoR - sqrt(PoR * PoR - D);\n}\n\nfloat orenNayarDiffuse(const vec3 L, const vec3 V, const vec3 N) {\n  float NoL = dot(N, L);\n  float NoV = dot(N, V);\n  float s = dot(L, V) - NoL * NoV;\n  float t = mix(1.0, max(NoL, NoV), step(0.0, s));\n  return max(0.0, NoL) * (0.62406015 + 0.41284404 * s / t);\n}\n\nvec3 getSkyRadiance(\n  const vec3 cameraPosition,\n  const vec3 rayDirection,\n  const float shadowLength,\n  const vec3 sunDirection,\n  const vec3 moonDirection,\n  const float moonAngularRadius,\n  const float lunarRadianceScale\n) {\n  vec3 transmittance;\n  vec3 radiance = GetSkyRadiance(\n    cameraPosition,\n    rayDirection,\n    shadowLength,\n    sunDirection,\n    transmittance\n  );\n\n  // Rendering celestial objects without perspective doesn't make sense.\n  #ifdef PERSPECTIVE_CAMERA\n\n  #if defined(SUN) || defined(MOON)\n  vec3 ddx = dFdx(rayDirection);\n  vec3 ddy = dFdy(rayDirection);\n  float fragmentAngle = length(ddx + ddy) / length(rayDirection);\n  #endif // defined(SUN) || defined(MOON)\n\n  #ifdef SUN\n  float viewDotSun = dot(rayDirection, sunDirection);\n  if (viewDotSun > cos(ATMOSPHERE.sun_angular_radius)) {\n    float angle = acos(clamp(viewDotSun, -1.0, 1.0));\n    float antialias = smoothstep(\n      ATMOSPHERE.sun_angular_radius,\n      ATMOSPHERE.sun_angular_radius - fragmentAngle,\n      angle\n    );\n    radiance += transmittance * GetSolarRadiance() * antialias;\n  }\n  #endif // SUN\n\n  #ifdef MOON\n  float intersection = intersectSphere(rayDirection, moonDirection, moonAngularRadius);\n  if (intersection > 0.0) {\n    vec3 normal = normalize(moonDirection - rayDirection * intersection);\n    float diffuse = orenNayarDiffuse(-sunDirection, rayDirection, normal);\n    float viewDotMoon = dot(rayDirection, moonDirection);\n    float angle = acos(clamp(viewDotMoon, -1.0, 1.0));\n    float antialias = smoothstep(moonAngularRadius, moonAngularRadius - fragmentAngle, angle);\n    radiance +=\n      transmittance *\n      getLunarRadiance(moonAngularRadius) *\n      lunarRadianceScale *\n      diffuse *\n      antialias;\n  }\n  #endif // MOON\n\n  #endif // PERSPECTIVE_CAMERA\n\n  return radiance;\n}\n";var Di=Object.defineProperty,Ii=(e,t,n,r)=>{for(var i,a=void 0,o=e.length-1;o>=0;o--)(i=e[o])&&(a=i(t,n,a)||a);return a&&Di(t,n,a),a};const Oi=new u,Ni=new u,bi=new me,Pi={blendFunction:n.NORMAL,octEncodedNormal:!1,reconstructNormal:!1,ellipsoid:ue.WGS84,correctAltitude:!0,correctGeometricError:!0,sunLight:!1,skyLight:!1,transmittance:!0,inscatter:!0,albedoScale:1,sky:!1,sun:!0,moon:!0,moonAngularRadius:.0045,lunarRadianceScale:1,ground:!0};let Li=class extends e{constructor(e=new z,n,r=Ei.DEFAULT){const{blendFunction:i,normalBuffer:a=null,octEncodedNormal:o,reconstructNormal:s,irradianceTexture:c=null,scatteringTexture:h=null,transmittanceTexture:d=null,singleMieScatteringTexture:m=null,higherOrderScatteringTexture:p=null,ellipsoid:f,correctAltitude:v,correctGeometricError:g,sunDirection:S,sunIrradiance:w,sunLight:y,skyIrradiance:_,skyLight:x,transmittance:T,inscatter:E,irradianceScale:A,albedoScale:R,sky:C,sun:D,moon:I,moonDirection:O,moonAngularRadius:N,lunarRadianceScale:b,ground:P}={...Pi,...n};super("AerialPerspectiveEffect",ai(Jr('precision highp sampler2DArray;\n\n#include "core/depth"\n#include "core/math"\n#include "core/packing"\n#include "core/transform"\n#ifdef HAS_SHADOW\n#include "core/raySphereIntersection"\n#include "core/cascadedShadowMaps"\n#include "core/interleavedGradientNoise"\n#include "core/vogelDisk"\n#endif // HAS_SHADOW\n\n#include "bruneton/definitions"\n\nuniform AtmosphereParameters ATMOSPHERE;\nuniform vec3 SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;\nuniform vec3 SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;\n\nuniform sampler2D transmittance_texture;\nuniform sampler3D scattering_texture;\nuniform sampler2D irradiance_texture;\nuniform sampler3D single_mie_scattering_texture;\nuniform sampler3D higher_order_scattering_texture;\n\n#include "bruneton/common"\n#include "bruneton/runtime"\n\n#include "sky"\n\nuniform sampler2D normalBuffer;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 inverseViewMatrix;\nuniform float bottomRadius;\nuniform mat4 worldToECEFMatrix;\nuniform float geometricErrorCorrectionAmount;\nuniform vec3 sunDirection;\nuniform vec3 moonDirection;\nuniform float moonAngularRadius;\nuniform float lunarRadianceScale;\nuniform float albedoScale;\n\n#ifdef HAS_LIGHTING_MASK\nuniform sampler2D lightingMaskBuffer;\n#endif // HAS_LIGHTING_MASK\n\n// prettier-ignore\n#define LIGHTING_MASK_CHANNEL_ LIGHTING_MASK_CHANNEL\n\n#ifdef HAS_OVERLAY\nuniform sampler2D overlayBuffer;\n#endif // HAS_OVERLAY\n\n#ifdef HAS_SHADOW\nuniform sampler2DArray shadowBuffer;\nuniform vec2 shadowIntervals[SHADOW_CASCADE_COUNT];\nuniform mat4 shadowMatrices[SHADOW_CASCADE_COUNT];\nuniform mat4 inverseShadowMatrices[SHADOW_CASCADE_COUNT];\nuniform float shadowFar;\nuniform float shadowTopHeight;\nuniform float shadowRadius;\nuniform sampler3D stbnTexture;\nuniform int frame;\n#endif // HAS_SHADOW\n\n#ifdef HAS_SHADOW_LENGTH\nuniform sampler2D shadowLengthBuffer;\n#endif // HAS_SHADOW_LENGTH\n\nvarying vec3 vCameraPosition;\nvarying vec3 vRayDirection;\nvarying vec3 vGeometryAltitudeCorrection;\nvarying vec3 vEllipsoidRadiiSquared;\n\nvec3 readNormal(const vec2 uv) {\n  #ifdef OCT_ENCODED_NORMAL\n  return unpackVec2ToNormal(texture(normalBuffer, uv).xy);\n  #else // OCT_ENCODED_NORMAL\n  return 2.0 * texture(normalBuffer, uv).xyz - 1.0;\n  #endif // OCT_ENCODED_NORMAL\n}\n\nvoid correctGeometricError(inout vec3 positionECEF, inout vec3 normalECEF) {\n  // TODO: The error is pronounced at the edge of the ellipsoid due to the\n  // large difference between the sphere position and the unprojected position\n  // at the current fragment. Calculating the sphere position from the fragment\n  // UV may resolve this.\n\n  // Correct way is slerp, but this will be small-angle interpolation anyways.\n  vec3 sphereNormal = normalize(positionECEF / vEllipsoidRadiiSquared);\n  vec3 spherePosition = ATMOSPHERE.bottom_radius * sphereNormal;\n  normalECEF = mix(normalECEF, sphereNormal, geometricErrorCorrectionAmount);\n  positionECEF = mix(positionECEF, spherePosition, geometricErrorCorrectionAmount);\n}\n\n#if defined(SUN_LIGHT) || defined(SKY_LIGHT)\n\nvec3 getSunSkyIrradiance(\n  const vec3 positionECEF,\n  const vec3 normal,\n  const vec3 inputColor,\n  const float sunTransmittance\n) {\n  // Assume lambertian BRDF. If both SUN_LIGHT and SKY_LIGHT are not defined,\n  // regard the inputColor as radiance at the texel.\n  vec3 diffuse = inputColor * albedoScale * RECIPROCAL_PI;\n  vec3 skyIrradiance;\n  vec3 sunIrradiance = GetSunAndSkyIrradiance(positionECEF, normal, sunDirection, skyIrradiance);\n\n  #ifdef HAS_SHADOW\n  sunIrradiance *= sunTransmittance;\n  #endif // HAS_SHADOW\n\n  #if defined(SUN_LIGHT) && defined(SKY_LIGHT)\n  return diffuse * (sunIrradiance + skyIrradiance);\n  #elif defined(SUN_LIGHT)\n  return diffuse * sunIrradiance;\n  #elif defined(SKY_LIGHT)\n  return diffuse * skyIrradiance;\n  #endif // defined(SUN_LIGHT) && defined(SKY_LIGHT)\n}\n\n#endif // defined(SUN_LIGHT) || defined(SKY_LIGHT)\n\n#if defined(TRANSMITTANCE) || defined(INSCATTER)\n\nvoid applyTransmittanceInscatter(const vec3 positionECEF, float shadowLength, inout vec3 radiance) {\n  vec3 transmittance;\n  vec3 inscatter = GetSkyRadianceToPoint(\n    vCameraPosition,\n    positionECEF,\n    shadowLength,\n    sunDirection,\n    transmittance\n  );\n  #ifdef TRANSMITTANCE\n  radiance = radiance * transmittance;\n  #endif // TRANSMITTANCE\n  #ifdef INSCATTER\n  radiance = radiance + inscatter;\n  #endif // INSCATTER\n}\n\n#endif // defined(TRANSMITTANCE) || defined(INSCATTER)\n\n#ifdef HAS_SHADOW\n\nfloat getSTBN() {\n  ivec3 size = textureSize(stbnTexture, 0);\n  vec3 scale = 1.0 / vec3(size);\n  return texture(stbnTexture, vec3(gl_FragCoord.xy, float(frame % size.z)) * scale).r;\n}\n\nvec2 getShadowUv(const vec3 worldPosition, const int cascadeIndex) {\n  vec4 clip = shadowMatrices[cascadeIndex] * vec4(worldPosition, 1.0);\n  clip /= clip.w;\n  return clip.xy * 0.5 + 0.5;\n}\n\nfloat getDistanceToShadowTop(const vec3 positionECEF) {\n  // Distance to the top of the shadows along the sun direction, which matches\n  // the ray origin of BSM.\n  return raySphereSecondIntersection(\n    positionECEF / METER_TO_LENGTH_UNIT, // TODO: Make units consistent\n    sunDirection,\n    vec3(0.0),\n    bottomRadius + shadowTopHeight\n  );\n}\n\nfloat readShadowOpticalDepth(const vec2 uv, const float distanceToTop, const int cascadeIndex) {\n  // r: frontDepth, g: meanExtinction, b: maxOpticalDepth, a: maxOpticalDepthTail\n  vec4 shadow = texture(shadowBuffer, vec3(uv, float(cascadeIndex)));\n  // Omit adding maxOpticalDepthTail to avoid pronounced aliasing. Ground\n  // shadow will be attenuated by inscatter anyways.\n  return min(shadow.b, shadow.g * max(0.0, distanceToTop - shadow.r));\n}\n\nfloat sampleShadowOpticalDepthPCF(\n  const vec3 worldPosition,\n  const float distanceToTop,\n  const float radius,\n  const int cascadeIndex\n) {\n  vec2 uv = getShadowUv(worldPosition, cascadeIndex);\n  if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n    return 0.0;\n  }\n\n  vec2 texelSize = vec2(1.0) / vec2(textureSize(shadowBuffer, 0).xy);\n  float sum = 0.0;\n  vec2 offset;\n  #pragma unroll_loop_start\n  for (int i = 0; i < 16; ++i) {\n    #if UNROLLED_LOOP_INDEX < SHADOW_SAMPLE_COUNT\n    offset = vogelDisk(\n      UNROLLED_LOOP_INDEX,\n      SHADOW_SAMPLE_COUNT,\n      interleavedGradientNoise(gl_FragCoord.xy) * PI2\n    );\n    sum += readShadowOpticalDepth(uv + offset * radius * texelSize, distanceToTop, cascadeIndex);\n    #endif // UNROLLED_LOOP_INDEX < SHADOW_SAMPLE_COUNT\n  }\n  #pragma unroll_loop_end\n  return sum / float(SHADOW_SAMPLE_COUNT);\n}\n\nfloat sampleShadowOpticalDepth(\n  const vec3 worldPosition,\n  const vec3 positionECEF,\n  const float radius,\n  const float jitter\n) {\n  float distanceToTop = getDistanceToShadowTop(positionECEF);\n  if (distanceToTop <= 0.0) {\n    return 0.0;\n  }\n  int cascadeIndex = getFadedCascadeIndex(\n    viewMatrix,\n    worldPosition,\n    shadowIntervals,\n    cameraNear,\n    shadowFar,\n    jitter\n  );\n  return cascadeIndex >= 0\n    ? sampleShadowOpticalDepthPCF(worldPosition, distanceToTop, radius, cascadeIndex)\n    : 0.0;\n}\n\nfloat getShadowRadius(const vec3 worldPosition) {\n  vec4 clip = shadowMatrices[0] * vec4(worldPosition, 1.0);\n  clip /= clip.w;\n\n  // Offset by 1px in each direction in shadow\'s clip coordinates.\n  vec2 shadowSize = vec2(textureSize(shadowBuffer, 0));\n  vec3 offset = vec3(2.0 / shadowSize, 0.0);\n  vec4 clipX = clip + offset.xzzz;\n  vec4 clipY = clip + offset.zyzz;\n\n  // Convert back to world space.\n  vec4 worldX = inverseShadowMatrices[0] * clipX;\n  vec4 worldY = inverseShadowMatrices[0] * clipY;\n\n  // Project into the main camera\'s clip space.\n  mat4 viewProjectionMatrix = projectionMatrix * viewMatrix;\n  vec4 projected = viewProjectionMatrix * vec4(worldPosition, 1.0);\n  vec4 projectedX = viewProjectionMatrix * worldX;\n  vec4 projectedY = viewProjectionMatrix * worldY;\n  projected /= projected.w;\n  projectedX /= projectedX.w;\n  projectedY /= projectedY.w;\n\n  // Take the mean of pixel sizes.\n  vec2 center = (projected.xy * 0.5 + 0.5) * resolution;\n  vec2 offsetX = (projectedX.xy * 0.5 + 0.5) * resolution;\n  vec2 offsetY = (projectedY.xy * 0.5 + 0.5) * resolution;\n  float size = max(length(offsetX - center), length(offsetY - center));\n\n  return remapClamped(size, 10.0, 50.0, 0.0, shadowRadius);\n}\n\n#endif // HAS_SHADOW\n\nvoid mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {\n  #if defined(HAS_LIGHTING_MASK) && defined(DEBUG_SHOW_LIGHTING_MASK)\n  outputColor.rgb = vec3(texture(lightingMaskBuffer, uv).LIGHTING_MASK_CHANNEL_);\n  outputColor.a = 1.0;\n  return;\n  #endif // defined(HAS_LIGHTING_MASK) && defined(DEBUG_SHOW_LIGHTING_MASK)\n\n  float shadowLength = 0.0;\n  #ifdef HAS_SHADOW_LENGTH\n  shadowLength = texture(shadowLengthBuffer, uv).r;\n  #endif // HAS_SHADOW_LENGTH\n\n  #ifdef HAS_OVERLAY\n  vec4 overlay = texture(overlayBuffer, uv);\n  if (overlay.a == 1.0) {\n    outputColor = overlay;\n    return;\n  }\n  #endif // HAS_OVERLAY\n\n  float depth = readDepth(uv);\n  if (depth >= 1.0 - 1e-8) {\n    #ifdef SKY\n    vec3 rayDirection = normalize(vRayDirection);\n    outputColor.rgb = getSkyRadiance(\n      vCameraPosition,\n      rayDirection,\n      shadowLength,\n      sunDirection,\n      moonDirection,\n      moonAngularRadius,\n      lunarRadianceScale\n    );\n    outputColor.a = 1.0;\n    #else // SKY\n    outputColor = inputColor;\n    #endif // SKY\n\n    #ifdef HAS_OVERLAY\n    outputColor.rgb = outputColor.rgb * (1.0 - overlay.a) + overlay.rgb;\n    #endif // HAS_OVERLAY\n    return;\n  }\n  depth = reverseLogDepth(depth, cameraNear, cameraFar);\n\n  // Reconstruct position and normal in world space.\n  vec3 viewPosition = screenToView(\n    uv,\n    depth,\n    getViewZ(depth),\n    projectionMatrix,\n    inverseProjectionMatrix\n  );\n  vec3 viewNormal;\n  #ifdef RECONSTRUCT_NORMAL\n  vec3 dx = dFdx(viewPosition);\n  vec3 dy = dFdy(viewPosition);\n  viewNormal = normalize(cross(dx, dy));\n  #else // RECONSTRUCT_NORMAL\n  viewNormal = readNormal(uv);\n  #endif // RECONSTRUCT_NORMAL\n\n  vec3 worldPosition = (inverseViewMatrix * vec4(viewPosition, 1.0)).xyz;\n  vec3 worldNormal = (inverseViewMatrix * vec4(viewNormal, 0.0)).xyz;\n  vec3 positionECEF = (worldToECEFMatrix * vec4(worldPosition, 1.0)).xyz;\n  positionECEF = positionECEF * METER_TO_LENGTH_UNIT + vGeometryAltitudeCorrection;\n  vec3 normalECEF = (worldToECEFMatrix * vec4(worldNormal, 0.0)).xyz;\n\n  #ifdef CORRECT_GEOMETRIC_ERROR\n  correctGeometricError(positionECEF, normalECEF);\n  #endif // CORRECT_GEOMETRIC_ERROR\n\n  #ifdef HAS_SHADOW\n  float stbn = getSTBN();\n  float radius = getShadowRadius(worldPosition);\n  float opticalDepth = sampleShadowOpticalDepth(worldPosition, positionECEF, radius, stbn);\n  float sunTransmittance = exp(-opticalDepth);\n  #else // HAS_SHADOW\n  float sunTransmittance = 1.0;\n  #endif // HAS_SHADOW\n\n  vec3 radiance;\n  #if defined(SUN_LIGHT) || defined(SKY_LIGHT)\n  radiance = getSunSkyIrradiance(positionECEF, normalECEF, inputColor.rgb, sunTransmittance);\n  #ifdef HAS_LIGHTING_MASK\n  float lightingMask = texture(lightingMaskBuffer, uv).LIGHTING_MASK_CHANNEL_;\n  radiance = mix(inputColor.rgb, radiance, lightingMask);\n  #endif // HAS_LIGHTING_MASK\n  #else // defined(SUN_LIGHT) || defined(SKY_LIGHT)\n  radiance = inputColor.rgb;\n  #endif // defined(SUN_LIGHT) || defined(SKY_LIGHT)\n\n  #if defined(TRANSMITTANCE) || defined(INSCATTER)\n  applyTransmittanceInscatter(positionECEF, shadowLength, radiance);\n  #endif // defined(TRANSMITTANCE) || defined(INSCATTER)\n\n  outputColor = vec4(radiance, inputColor.a);\n\n  #ifdef HAS_OVERLAY\n  outputColor.rgb = outputColor.rgb * (1.0 - overlay.a) + overlay.rgb;\n  #endif // HAS_OVERLAY\n}\n',{core:{depth:si,packing:li,math:ui,transform:di,raySphereIntersection:hi,cascadedShadowMaps:oi,interleavedGradientNoise:ci,vogelDisk:pi},bruneton:{common:fi,definitions:vi,runtime:gi},sky:Ci})),{blendFunction:i,vertexShader:"uniform mat4 inverseViewMatrix;\nuniform mat4 inverseProjectionMatrix;\nuniform vec3 cameraPosition;\nuniform mat4 worldToECEFMatrix;\nuniform vec3 altitudeCorrection;\nuniform float geometricErrorCorrectionAmount;\nuniform vec3 ellipsoidRadii;\n\nvarying vec3 vCameraPosition;\nvarying vec3 vRayDirection;\nvarying vec3 vGeometryAltitudeCorrection;\nvarying vec3 vEllipsoidRadiiSquared;\n\nvoid getCameraRay(out vec3 origin, out vec3 direction) {\n  bool isPerspective = inverseProjectionMatrix[2][3] != 0.0; // 4th entry in the 3rd column\n\n  if (isPerspective) {\n    // Calculate the camera ray for a perspective camera.\n    vec4 viewPosition = inverseProjectionMatrix * vec4(position, 1.0);\n    vec4 worldDirection = inverseViewMatrix * vec4(viewPosition.xyz, 0.0);\n    origin = cameraPosition;\n    direction = worldDirection.xyz;\n  } else {\n    // Unprojected points to calculate direction.\n    vec4 nearPoint = inverseProjectionMatrix * vec4(position.xy, -1.0, 1.0);\n    vec4 farPoint = inverseProjectionMatrix * vec4(position.xy, -0.9, 1.0);\n    nearPoint /= nearPoint.w;\n    farPoint /= farPoint.w;\n\n    // Calculate world values.\n    vec4 worldDirection = inverseViewMatrix * vec4(farPoint.xyz - nearPoint.xyz, 0.0);\n    vec4 worldOrigin = inverseViewMatrix * nearPoint;\n\n    // Outputs\n    direction = worldDirection.xyz;\n    origin = worldOrigin.xyz;\n  }\n}\n\nvoid mainSupport() {\n  vec3 direction, origin;\n  getCameraRay(origin, direction);\n\n  vec3 cameraPositionECEF = (worldToECEFMatrix * vec4(origin, 1.0)).xyz;\n  vCameraPosition = (cameraPositionECEF + altitudeCorrection) * METER_TO_LENGTH_UNIT;\n  vRayDirection = (worldToECEFMatrix * vec4(direction, 0.0)).xyz;\n\n  vGeometryAltitudeCorrection = altitudeCorrection * METER_TO_LENGTH_UNIT;\n  // Gradually turn off the altitude correction on geometries as the geometric\n  // error correction takes effect, because that on the ideal sphere will be\n  // over corrected.\n  // See: https://github.com/takram-design-engineering/three-geospatial/pull/23#issuecomment-2542914656\n  #ifdef CORRECT_GEOMETRIC_ERROR\n  vGeometryAltitudeCorrection *= 1.0 - geometricErrorCorrectionAmount;\n  #endif // CORRECT_GEOMETRIC_ERROR\n\n  vec3 radii = ellipsoidRadii * METER_TO_LENGTH_UNIT;\n  vEllipsoidRadiiSquared = radii * radii;\n}\n",attributes:t.DEPTH,uniforms:new Map(Object.entries({normalBuffer:new G(a),projectionMatrix:new G(new l),viewMatrix:new G(new l),inverseProjectionMatrix:new G(new l),inverseViewMatrix:new G(new l),cameraPosition:new G(new u),bottomRadius:new G(r.bottomRadius),ellipsoidRadii:new G(new u),worldToECEFMatrix:new G(new l),altitudeCorrection:new G(new u),geometricErrorCorrectionAmount:new G(0),sunDirection:new G((null==S?void 0:S.clone())??new u),albedoScale:new G(A??R),moonDirection:new G((null==O?void 0:O.clone())??new u),moonAngularRadius:new G(N),lunarRadianceScale:new G(b),overlayBuffer:new G(null),shadowBuffer:new G(null),shadowMapSize:new G(new B),shadowIntervals:new G([]),shadowMatrices:new G([]),inverseShadowMatrices:new G([]),shadowFar:new G(0),shadowTopHeight:new G(0),shadowRadius:new G(3),stbnTexture:new G(null),frame:new G(0),shadowLengthBuffer:new G(null),lightingMaskBuffer:new G(null),ATMOSPHERE:r.toUniform(),SUN_SPECTRAL_RADIANCE_TO_LUMINANCE:new G(r.sunRadianceToRelativeLuminance),SKY_SPECTRAL_RADIANCE_TO_LUMINANCE:new G(r.skyRadianceToRelativeLuminance),irradiance_texture:new G(c),scattering_texture:new G(h),transmittance_texture:new G(d),single_mie_scattering_texture:new G(null),higher_order_scattering_texture:new G(null)})),defines:new Map([["TRANSMITTANCE_TEXTURE_WIDTH",Si.toFixed(0)],["TRANSMITTANCE_TEXTURE_HEIGHT",64..toFixed(0)],["SCATTERING_TEXTURE_R_SIZE",32..toFixed(0)],["SCATTERING_TEXTURE_MU_SIZE",128..toFixed(0)],["SCATTERING_TEXTURE_MU_S_SIZE",32..toFixed(0)],["SCATTERING_TEXTURE_NU_SIZE",8..toFixed(0)],["IRRADIANCE_TEXTURE_WIDTH",64..toFixed(0)],["IRRADIANCE_TEXTURE_HEIGHT",16..toFixed(0)],["METER_TO_LENGTH_UNIT",wi.toFixed(7)]])}),this.camera=e,this.atmosphere=r,this.overlay=null,this.shadow=null,this.shadowLength=null,this.lightingMask=null,this.combinedScatteringTextures=!1,this.hasHigherOrderScatteringTexture=!1,this.shadowSampleCount=8,this.octEncodedNormal=o,this.reconstructNormal=s,this.singleMieScatteringTexture=m,this.higherOrderScatteringTexture=p,this.ellipsoid=f,this.correctAltitude=v,this.correctGeometricError=g,this.sunLight=w??y,this.skyLight=_??x,this.transmittance=T,this.inscatter=E,this.sky=C,this.sun=D,this.moon=I,this.ground=P}get mainCamera(){return this.camera}set mainCamera(e){this.camera=e}copyCameraSettings(e){const{projectionMatrix:t,matrixWorldInverse:n,projectionMatrixInverse:r,matrixWorld:i}=e,a=this.uniforms;a.get("projectionMatrix").value.copy(t),a.get("viewMatrix").value.copy(n),a.get("inverseProjectionMatrix").value.copy(r),a.get("inverseViewMatrix").value.copy(i);const o=e.getWorldPosition(a.get("cameraPosition").value),s=a.get("worldToECEFMatrix").value,c=Oi.copy(o).applyMatrix4(s);try{const e=bi.setFromECEF(c).height,n=Ni.set(0,this.ellipsoid.maximumRadius,-Math.max(0,e)).applyMatrix4(t);a.get("geometricErrorCorrectionAmount").value=function(e){return Math.min(Math.max(e,0),1)}(function(e,t,n,r=0,i=1){return h.mapLinear(e,t,n,r,i)}(n.y,41.5,13.8,0,1))}catch{return}const u=a.get("altitudeCorrection");this.correctAltitude?Ri(c,this.atmosphere.bottomRadius,this.ellipsoid,u.value):u.value.setScalar(0)}updateOverlay(){let e=!1;const{uniforms:t,defines:n,overlay:r}=this,i=null!=r;return i!==n.has("HAS_OVERLAY")&&(i?n.set("HAS_OVERLAY","1"):(n.delete("HAS_OVERLAY"),t.get("overlayBuffer").value=null),e=!0),i&&(t.get("overlayBuffer").value=r.map),e}updateShadow(){let e=!1;const{uniforms:t,defines:n,shadow:r}=this,i=null!=r;if(i!==n.has("HAS_SHADOW")&&(i?n.set("HAS_SHADOW","1"):(n.delete("HAS_SHADOW"),t.get("shadowBuffer").value=null),e=!0),i){n.get("SHADOW_CASCADE_COUNT")!==`${r.cascadeCount}`&&(n.set("SHADOW_CASCADE_COUNT",r.cascadeCount.toFixed(0)),e=!0),t.get("shadowBuffer").value=r.map,t.get("shadowMapSize").value=r.mapSize,t.get("shadowIntervals").value=r.intervals,t.get("shadowMatrices").value=r.matrices,t.get("inverseShadowMatrices").value=r.inverseMatrices,t.get("shadowFar").value=r.far,t.get("shadowTopHeight").value=r.topHeight}return e}updateShadowLength(){let e=!1;const{uniforms:t,defines:n,shadowLength:r}=this,i=null!=r;return i!==n.has("HAS_SHADOW_LENGTH")&&(i?n.set("HAS_SHADOW_LENGTH","1"):(n.delete("HAS_SHADOW_LENGTH"),t.get("shadowLengthBuffer").value=null),e=!0),i&&(t.get("shadowLengthBuffer").value=r.map),e}updateLightingMask(){let e=!1;const{uniforms:t,defines:n,lightingMask:r}=this,i=null!=r;if(i!==n.has("HAS_LIGHTING_MASK")&&(i?n.set("HAS_LIGHTING_MASK","1"):(n.delete("HAS_LIGHTING_MASK"),t.get("lightingMaskBuffer").value=null),e=!0),i){t.get("lightingMaskBuffer").value=r.map;const i=n.get("LIGHTING_MASK_CHANNEL"),a=r.channel;a!==i&&(/^[rgba]$/.test(a)?(n.set("LIGHTING_MASK_CHANNEL",a),e=!0):console.error(`Expression validation failed: ${a}`))}return e}update(e,t,n){this.copyCameraSettings(this.camera);let r=!1;r||(r=this.updateOverlay()),r||(r=this.updateShadow()),r||(r=this.updateShadowLength()),r||(r=this.updateLightingMask()),r&&this.setChanged(),++this.uniforms.get("frame").value}get normalBuffer(){return this.uniforms.get("normalBuffer").value}set normalBuffer(e){this.uniforms.get("normalBuffer").value=e}get irradianceTexture(){return this.uniforms.get("irradiance_texture").value}set irradianceTexture(e){this.uniforms.get("irradiance_texture").value=e}get scatteringTexture(){return this.uniforms.get("scattering_texture").value}set scatteringTexture(e){this.uniforms.get("scattering_texture").value=e}get transmittanceTexture(){return this.uniforms.get("transmittance_texture").value}set transmittanceTexture(e){this.uniforms.get("transmittance_texture").value=e}get singleMieScatteringTexture(){return this.uniforms.get("single_mie_scattering_texture").value}set singleMieScatteringTexture(e){this.uniforms.get("single_mie_scattering_texture").value=e,this.combinedScatteringTextures=null==e}get higherOrderScatteringTexture(){return this.uniforms.get("higher_order_scattering_texture").value}set higherOrderScatteringTexture(e){this.uniforms.get("higher_order_scattering_texture").value=e,this.hasHigherOrderScatteringTexture=null!=e}get ellipsoid(){return this._ellipsoid}set ellipsoid(e){this._ellipsoid=e,this.uniforms.get("ellipsoidRadii").value.copy(e.radii)}get worldToECEFMatrix(){return this.uniforms.get("worldToECEFMatrix").value}get sunDirection(){return this.uniforms.get("sunDirection").value}get sunIrradiance(){return this.sunLight}set sunIrradiance(e){this.sunLight=e}get skyIrradiance(){return this.skyLight}set skyIrradiance(e){this.skyLight=e}get irradianceScale(){return this.albedoScale}set irradianceScale(e){this.albedoScale=e}get albedoScale(){return this.uniforms.get("albedoScale").value}set albedoScale(e){this.uniforms.get("albedoScale").value=e}get moonDirection(){return this.uniforms.get("moonDirection").value}get moonAngularRadius(){return this.uniforms.get("moonAngularRadius").value}set moonAngularRadius(e){this.uniforms.get("moonAngularRadius").value=e}get lunarRadianceScale(){return this.uniforms.get("lunarRadianceScale").value}set lunarRadianceScale(e){this.uniforms.get("lunarRadianceScale").value=e}get stbnTexture(){return this.uniforms.get("stbnTexture").value}set stbnTexture(e){this.uniforms.get("stbnTexture").value=e}get shadowRadius(){return this.uniforms.get("shadowRadius").value}set shadowRadius(e){this.uniforms.get("shadowRadius").value=e}};Ii([tr("OCT_ENCODED_NORMAL")],Li.prototype,"octEncodedNormal"),Ii([tr("RECONSTRUCT_NORMAL")],Li.prototype,"reconstructNormal"),Ii([tr("COMBINED_SCATTERING_TEXTURES")],Li.prototype,"combinedScatteringTextures"),Ii([tr("HAS_HIGHER_ORDER_SCATTERING_TEXTURE")],Li.prototype,"hasHigherOrderScatteringTexture"),Ii([tr("CORRECT_GEOMETRIC_ERROR")],Li.prototype,"correctGeometricError"),Ii([tr("SUN_LIGHT")],Li.prototype,"sunLight"),Ii([tr("SKY_LIGHT")],Li.prototype,"skyLight"),Ii([tr("TRANSMITTANCE")],Li.prototype,"transmittance"),Ii([tr("INSCATTER")],Li.prototype,"inscatter"),Ii([tr("SKY")],Li.prototype,"sky"),Ii([tr("SUN")],Li.prototype,"sun"),Ii([tr("MOON")],Li.prototype,"moon"),Ii([tr("GROUND")],Li.prototype,"ground"),Ii([nr("SHADOW_SAMPLE_COUNT",{min:1,max:16})],Li.prototype,"shadowSampleCount");var Mi=Object.defineProperty,Ui=(e,t,n,r)=>{for(var i,a=void 0,o=e.length-1;o>=0;o--)(i=e[o])&&(a=i(t,n,a)||a);return a&&Mi(t,n,a),a};const Hi=new u;const Fi={ellipsoid:ue.WGS84,correctAltitude:!0,renderTargetCount:1};class zi extends X{constructor(e,t=Ei.DEFAULT){const{irradianceTexture:n=null,scatteringTexture:r=null,transmittanceTexture:i=null,singleMieScatteringTexture:a=null,higherOrderScatteringTexture:o=null,ellipsoid:s,correctAltitude:c,sunDirection:h,sunAngularRadius:d,renderTargetCount:m,...p}={...Fi,...e};super({toneMapped:!1,depthWrite:!1,depthTest:!1,...p,uniforms:{cameraPosition:new G(new u),worldToECEFMatrix:new G(new l),altitudeCorrection:new G(new u),sunDirection:new G((null==h?void 0:h.clone())??new u),ATMOSPHERE:t.toUniform(),SUN_SPECTRAL_RADIANCE_TO_LUMINANCE:new G(t.sunRadianceToRelativeLuminance),SKY_SPECTRAL_RADIANCE_TO_LUMINANCE:new G(t.skyRadianceToRelativeLuminance),irradiance_texture:new G(n),scattering_texture:new G(r),transmittance_texture:new G(i),single_mie_scattering_texture:new G(null),higher_order_scattering_texture:new G(null),...p.uniforms},defines:{PI:`${Math.PI}`,TRANSMITTANCE_TEXTURE_WIDTH:Si.toFixed(0),TRANSMITTANCE_TEXTURE_HEIGHT:64..toFixed(0),SCATTERING_TEXTURE_R_SIZE:32..toFixed(0),SCATTERING_TEXTURE_MU_SIZE:128..toFixed(0),SCATTERING_TEXTURE_MU_S_SIZE:32..toFixed(0),SCATTERING_TEXTURE_NU_SIZE:8..toFixed(0),IRRADIANCE_TEXTURE_WIDTH:64..toFixed(0),IRRADIANCE_TEXTURE_HEIGHT:16..toFixed(0),METER_TO_LENGTH_UNIT:wi.toFixed(7),...p.defines}}),this.atmosphere=t,this.combinedScatteringTextures=!1,this.hasHigherOrderScatteringTexture=!1,this.singleMieScatteringTexture=a,this.higherOrderScatteringTexture=o,this.ellipsoid=s,this.correctAltitude=c,null!=d&&(this.sunAngularRadius=d),this.renderTargetCount=m}copyCameraSettings(e){const t=this.uniforms,n=e.getWorldPosition(t.cameraPosition.value),r=Hi.copy(n).applyMatrix4(t.worldToECEFMatrix.value),i=t.altitudeCorrection.value;this.correctAltitude?Ri(r,this.atmosphere.bottomRadius,this.ellipsoid,i):i.setScalar(0)}onBeforeCompile(e,t){e.fragmentShader=function(e,t){let n="",r="";for(let i=1;i<t;++i)n+=`layout(location = ${i}) out float renderTarget${i};\n`,r+=`renderTarget${i} = 0.0;\n`;return e.replace("#include <mrt_layout>",n).replace("#include <mrt_output>",r)}(e.fragmentShader,this.renderTargetCount)}onBeforeRender(e,t,n,r,i,a){this.copyCameraSettings(n)}get irradianceTexture(){return this.uniforms.irradiance_texture.value}set irradianceTexture(e){this.uniforms.irradiance_texture.value=e}get scatteringTexture(){return this.uniforms.scattering_texture.value}set scatteringTexture(e){this.uniforms.scattering_texture.value=e}get transmittanceTexture(){return this.uniforms.transmittance_texture.value}set transmittanceTexture(e){this.uniforms.transmittance_texture.value=e}get singleMieScatteringTexture(){return this.uniforms.single_mie_scattering_texture.value}set singleMieScatteringTexture(e){this.uniforms.single_mie_scattering_texture.value=e,this.combinedScatteringTextures=null==e}get higherOrderScatteringTexture(){return this.uniforms.higher_order_scattering_texture.value}set higherOrderScatteringTexture(e){this.uniforms.higher_order_scattering_texture.value=e,this.hasHigherOrderScatteringTexture=null!=e}get worldToECEFMatrix(){return this.uniforms.worldToECEFMatrix.value}get sunDirection(){return this.uniforms.sunDirection.value}get sunAngularRadius(){return this.uniforms.ATMOSPHERE.value.sun_angular_radius}set sunAngularRadius(e){this.uniforms.ATMOSPHERE.value.sun_angular_radius=e}get renderTargetCount(){return this._renderTargetCount}set renderTargetCount(e){e!==this.renderTargetCount&&(this._renderTargetCount=e,this.needsUpdate=!0)}}Ui([tr("COMBINED_SCATTERING_TEXTURES")],zi.prototype,"combinedScatteringTextures"),Ui([tr("HAS_HIGHER_ORDER_SCATTERING_TEXTURE")],zi.prototype,"hasHigherOrderScatteringTexture");
/**
    @preserve

    Astronomy library for JavaScript (browser and Node.js).
    https://github.com/cosinekitty/astronomy

    MIT License

    Copyright (c) 2019-2023 Don Cross <cosinekitty@gmail.com>

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/
/**
 * @fileoverview Astronomy calculation library for browser scripting and Node.js.
 * @author Don Cross <cosinekitty@gmail.com>
 * @license MIT
 */
const Gi=.017453292519943295,Bi=new Date("2000-01-01T12:00:00Z"),Wi=2*Math.PI,ki=180/Math.PI*3600,Vi=484813681109536e-20,ji=.0002959122082855911,Yi=2.825345909524226e-7,Xi=8.459715185680659e-8,qi=1.292024916781969e-8,Ki=1.524358900784276e-8;function Zi(e){if(!Number.isFinite(e))throw console.trace(),`Value is not a finite number: ${e}`;return e}function Ji(e){return e-Math.floor(e)}var $i;!function(e){e.Sun="Sun",e.Moon="Moon",e.Mercury="Mercury",e.Venus="Venus",e.Earth="Earth",e.Mars="Mars",e.Jupiter="Jupiter",e.Saturn="Saturn",e.Uranus="Uranus",e.Neptune="Neptune",e.Pluto="Pluto",e.SSB="SSB",e.EMB="EMB",e.Star1="Star1",e.Star2="Star2",e.Star3="Star3",e.Star4="Star4",e.Star5="Star5",e.Star6="Star6",e.Star7="Star7",e.Star8="Star8"}($i||($i={}));const Qi=[$i.Star1,$i.Star2,$i.Star3,$i.Star4,$i.Star5,$i.Star6,$i.Star7,$i.Star8],ea=[{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0}];function ta(e){const t=function(e){const t=Qi.indexOf(e);return t>=0?ea[t]:null}(e);return t&&t.dist>0?t:null}var na;!function(e){e[e.From2000=0]="From2000",e[e.Into2000=1]="Into2000"}(na||(na={}));const ra={Mercury:[[[[4.40250710144,0,0],[.40989414977,1.48302034195,26087.9031415742],[.050462942,4.47785489551,52175.8062831484],[.00855346844,1.16520322459,78263.70942472259],[.00165590362,4.11969163423,104351.61256629678],[.00034561897,.77930768443,130439.51570787099],[7583476e-11,3.71348404924,156527.41884944518]],[[26087.90313685529,0,0],[.01131199811,6.21874197797,26087.9031415742],[.00292242298,3.04449355541,52175.8062831484],[.00075775081,6.08568821653,78263.70942472259],[.00019676525,2.80965111777,104351.61256629678]]],[[[.11737528961,1.98357498767,26087.9031415742],[.02388076996,5.03738959686,52175.8062831484],[.01222839532,3.14159265359,0],[.0054325181,1.79644363964,78263.70942472259],[.0012977877,4.83232503958,104351.61256629678],[.00031866927,1.58088495658,130439.51570787099],[7963301e-11,4.60972126127,156527.41884944518]],[[.00274646065,3.95008450011,26087.9031415742],[.00099737713,3.14159265359,0]]],[[[.39528271651,0,0],[.07834131818,6.19233722598,26087.9031415742],[.00795525558,2.95989690104,52175.8062831484],[.00121281764,6.01064153797,78263.70942472259],[.00021921969,2.77820093972,104351.61256629678],[4354065e-11,5.82894543774,130439.51570787099]],[[.0021734774,4.65617158665,26087.9031415742],[.00044141826,1.42385544001,52175.8062831484]]]],Venus:[[[[3.17614666774,0,0],[.01353968419,5.59313319619,10213.285546211],[.00089891645,5.30650047764,20426.571092422],[5477194e-11,4.41630661466,7860.4193924392],[3455741e-11,2.6996444782,11790.6290886588],[2372061e-11,2.99377542079,3930.2096962196],[1317168e-11,5.18668228402,26.2983197998],[1664146e-11,4.25018630147,1577.3435424478],[1438387e-11,4.15745084182,9683.5945811164],[1200521e-11,6.15357116043,30639.856638633]],[[10213.28554621638,0,0],[.00095617813,2.4640651111,10213.285546211],[7787201e-11,.6247848222,20426.571092422]]],[[[.05923638472,.26702775812,10213.285546211],[.00040107978,1.14737178112,20426.571092422],[.00032814918,3.14159265359,0]],[[.00287821243,1.88964962838,10213.285546211]]],[[[.72334820891,0,0],[.00489824182,4.02151831717,10213.285546211],[1658058e-11,4.90206728031,20426.571092422],[1378043e-11,1.12846591367,11790.6290886588],[1632096e-11,2.84548795207,7860.4193924392],[498395e-11,2.58682193892,9683.5945811164],[221985e-11,2.01346696541,19367.1891622328],[237454e-11,2.55136053886,15720.8387848784]],[[.00034551041,.89198706276,10213.285546211]]]],Earth:[[[[1.75347045673,0,0],[.03341656453,4.66925680415,6283.0758499914],[.00034894275,4.62610242189,12566.1516999828],[3417572e-11,2.82886579754,3.523118349],[3497056e-11,2.74411783405,5753.3848848968],[3135899e-11,3.62767041756,77713.7714681205],[2676218e-11,4.41808345438,7860.4193924392],[2342691e-11,6.13516214446,3930.2096962196],[1273165e-11,2.03709657878,529.6909650946],[1324294e-11,.74246341673,11506.7697697936],[901854e-11,2.04505446477,26.2983197998],[1199167e-11,1.10962946234,1577.3435424478],[857223e-11,3.50849152283,398.1490034082],[779786e-11,1.17882681962,5223.6939198022],[99025e-10,5.23268072088,5884.9268465832],[753141e-11,2.53339052847,5507.5532386674],[505267e-11,4.58292599973,18849.2275499742],[492392e-11,4.20505711826,775.522611324],[356672e-11,2.91954114478,.0673103028],[284125e-11,1.89869240932,796.2980068164],[242879e-11,.34481445893,5486.777843175],[317087e-11,5.84901948512,11790.6290886588],[271112e-11,.31486255375,10977.078804699],[206217e-11,4.80646631478,2544.3144198834],[205478e-11,1.86953770281,5573.1428014331],[202318e-11,2.45767790232,6069.7767545534],[126225e-11,1.08295459501,20.7753954924],[155516e-11,.83306084617,213.299095438]],[[6283.0758499914,0,0],[.00206058863,2.67823455808,6283.0758499914],[4303419e-11,2.63512233481,12566.1516999828]],[[8721859e-11,1.07253635559,6283.0758499914]]],[[],[[.00227777722,3.4137662053,6283.0758499914],[3805678e-11,3.37063423795,12566.1516999828]]],[[[1.00013988784,0,0],[.01670699632,3.09846350258,6283.0758499914],[.00013956024,3.05524609456,12566.1516999828],[308372e-10,5.19846674381,77713.7714681205],[1628463e-11,1.17387558054,5753.3848848968],[1575572e-11,2.84685214877,7860.4193924392],[924799e-11,5.45292236722,11506.7697697936],[542439e-11,4.56409151453,3930.2096962196],[47211e-10,3.66100022149,5884.9268465832],[8.5831e-7,1.27079125277,161000.6857376741],[5.7056e-7,2.01374292245,83996.84731811189],[5.5736e-7,5.2415979917,71430.69561812909],[174844e-11,3.01193636733,18849.2275499742],[243181e-11,4.2734953079,11790.6290886588]],[[.00103018607,1.10748968172,6283.0758499914],[1721238e-11,1.06442300386,12566.1516999828]],[[4359385e-11,5.78455133808,6283.0758499914]]]],Mars:[[[[6.20347711581,0,0],[.18656368093,5.0503710027,3340.6124266998],[.01108216816,5.40099836344,6681.2248533996],[.00091798406,5.75478744667,10021.8372800994],[.00027744987,5.97049513147,3.523118349],[.00010610235,2.93958560338,2281.2304965106],[.00012315897,.84956094002,2810.9214616052],[8926784e-11,4.15697846427,.0172536522],[8715691e-11,6.11005153139,13362.4497067992],[6797556e-11,.36462229657,398.1490034082],[7774872e-11,3.33968761376,5621.8429232104],[3575078e-11,1.6618650571,2544.3144198834],[4161108e-11,.22814971327,2942.4634232916],[3075252e-11,.85696614132,191.4482661116],[2628117e-11,.64806124465,3337.0893083508],[2937546e-11,6.07893711402,.0673103028],[2389414e-11,5.03896442664,796.2980068164],[2579844e-11,.02996736156,3344.1355450488],[1528141e-11,1.14979301996,6151.533888305],[1798806e-11,.65634057445,529.6909650946],[1264357e-11,3.62275122593,5092.1519581158],[1286228e-11,3.06796065034,2146.1654164752],[1546404e-11,2.91579701718,1751.539531416],[1024902e-11,3.69334099279,8962.4553499102],[891566e-11,.18293837498,16703.062133499],[858759e-11,2.4009381194,2914.0142358238],[832715e-11,2.46418619474,3340.5951730476],[83272e-10,4.49495782139,3340.629680352],[712902e-11,3.66335473479,1059.3819301892],[748723e-11,3.82248614017,155.4203994342],[723861e-11,.67497311481,3738.761430108],[635548e-11,2.92182225127,8432.7643848156],[655162e-11,.48864064125,3127.3133312618],[550474e-11,3.81001042328,.9803210682],[55275e-10,4.47479317037,1748.016413067],[425966e-11,.55364317304,6283.0758499914],[415131e-11,.49662285038,213.299095438],[472167e-11,3.62547124025,1194.4470102246],[306551e-11,.38052848348,6684.7479717486],[312141e-11,.99853944405,6677.7017350506],[293198e-11,4.22131299634,20.7753954924],[302375e-11,4.48618007156,3532.0606928114],[274027e-11,.54222167059,3340.545116397],[281079e-11,5.88163521788,1349.8674096588],[231183e-11,1.28242156993,3870.3033917944],[283602e-11,5.7688543494,3149.1641605882],[236117e-11,5.75503217933,3333.498879699],[274033e-11,.13372524985,3340.6797370026],[299395e-11,2.78323740866,6254.6266625236]],[[3340.61242700512,0,0],[.01457554523,3.60433733236,3340.6124266998],[.00168414711,3.92318567804,6681.2248533996],[.00020622975,4.26108844583,10021.8372800994],[3452392e-11,4.7321039319,3.523118349],[2586332e-11,4.60670058555,13362.4497067992],[841535e-11,4.45864030426,2281.2304965106]],[[.00058152577,2.04961712429,3340.6124266998],[.00013459579,2.45738706163,6681.2248533996]]],[[[.03197134986,3.76832042431,3340.6124266998],[.00298033234,4.10616996305,6681.2248533996],[.00289104742,0,0],[.00031365539,4.4465105309,10021.8372800994],[34841e-9,4.7881254926,13362.4497067992]],[[.00217310991,6.04472194776,3340.6124266998],[.00020976948,3.14159265359,0],[.00012834709,1.60810667915,6681.2248533996]]],[[[1.53033488271,0,0],[.1418495316,3.47971283528,3340.6124266998],[.00660776362,3.81783443019,6681.2248533996],[.00046179117,4.15595316782,10021.8372800994],[8109733e-11,5.55958416318,2810.9214616052],[7485318e-11,1.77239078402,5621.8429232104],[5523191e-11,1.3643630377,2281.2304965106],[382516e-10,4.49407183687,13362.4497067992],[2306537e-11,.09081579001,2544.3144198834],[1999396e-11,5.36059617709,3337.0893083508],[2484394e-11,4.9254563992,2942.4634232916],[1960195e-11,4.74249437639,3344.1355450488],[1167119e-11,2.11260868341,5092.1519581158],[1102816e-11,5.00908403998,398.1490034082],[899066e-11,4.40791133207,529.6909650946],[992252e-11,5.83861961952,6151.533888305],[807354e-11,2.10217065501,1059.3819301892],[797915e-11,3.44839203899,796.2980068164],[740975e-11,1.49906336885,2146.1654164752]],[[.01107433345,2.03250524857,3340.6124266998],[.00103175887,2.37071847807,6681.2248533996],[128772e-9,0,0],[.0001081588,2.70888095665,10021.8372800994]],[[.00044242249,.47930604954,3340.6124266998],[8138042e-11,.86998389204,6681.2248533996]]]],Jupiter:[[[[.59954691494,0,0],[.09695898719,5.06191793158,529.6909650946],[.00573610142,1.44406205629,7.1135470008],[.00306389205,5.41734730184,1059.3819301892],[.00097178296,4.14264726552,632.7837393132],[.00072903078,3.64042916389,522.5774180938],[.00064263975,3.41145165351,103.0927742186],[.00039806064,2.29376740788,419.4846438752],[.00038857767,1.27231755835,316.3918696566],[.00027964629,1.7845459182,536.8045120954],[.0001358973,5.7748104079,1589.0728952838],[8246349e-11,3.5822792584,206.1855484372],[8768704e-11,3.63000308199,949.1756089698],[7368042e-11,5.0810119427,735.8765135318],[626315e-10,.02497628807,213.299095438],[6114062e-11,4.51319998626,1162.4747044078],[4905396e-11,1.32084470588,110.2063212194],[5305285e-11,1.30671216791,14.2270940016],[5305441e-11,4.18625634012,1052.2683831884],[4647248e-11,4.69958103684,3.9321532631],[3045023e-11,4.31676431084,426.598190876],[2609999e-11,1.56667394063,846.0828347512],[2028191e-11,1.06376530715,3.1813937377],[1764763e-11,2.14148655117,1066.49547719],[1722972e-11,3.88036268267,1265.5674786264],[1920945e-11,.97168196472,639.897286314],[1633223e-11,3.58201833555,515.463871093],[1431999e-11,4.29685556046,625.6701923124],[973272e-11,4.09764549134,95.9792272178]],[[529.69096508814,0,0],[.00489503243,4.2208293947,529.6909650946],[.00228917222,6.02646855621,7.1135470008],[.00030099479,4.54540782858,1059.3819301892],[.0002072092,5.45943156902,522.5774180938],[.00012103653,.16994816098,536.8045120954],[6067987e-11,4.42422292017,103.0927742186],[5433968e-11,3.98480737746,419.4846438752],[4237744e-11,5.89008707199,14.2270940016]],[[.00047233601,4.32148536482,7.1135470008],[.00030649436,2.929777887,529.6909650946],[.00014837605,3.14159265359,0]]],[[[.02268615702,3.55852606721,529.6909650946],[.00109971634,3.90809347197,1059.3819301892],[.00110090358,0,0],[8101428e-11,3.60509572885,522.5774180938],[6043996e-11,4.25883108339,1589.0728952838],[6437782e-11,.30627119215,536.8045120954]],[[.00078203446,1.52377859742,529.6909650946]]],[[[5.20887429326,0,0],[.25209327119,3.49108639871,529.6909650946],[.00610599976,3.84115365948,1059.3819301892],[.00282029458,2.57419881293,632.7837393132],[.00187647346,2.07590383214,522.5774180938],[.00086792905,.71001145545,419.4846438752],[.00072062974,.21465724607,536.8045120954],[.00065517248,5.9799588479,316.3918696566],[.00029134542,1.67759379655,103.0927742186],[.00030135335,2.16132003734,949.1756089698],[.00023453271,3.54023522184,735.8765135318],[.00022283743,4.19362594399,1589.0728952838],[.00023947298,.2745803748,7.1135470008],[.00013032614,2.96042965363,1162.4747044078],[970336e-10,1.90669633585,206.1855484372],[.00012749023,2.71550286592,1052.2683831884],[7057931e-11,2.18184839926,1265.5674786264],[6137703e-11,6.26418240033,846.0828347512],[2616976e-11,2.00994012876,1581.959348283]],[[.0127180152,2.64937512894,529.6909650946],[.00061661816,3.00076460387,1059.3819301892],[.00053443713,3.89717383175,522.5774180938],[.00031185171,4.88276958012,536.8045120954],[.00041390269,0,0]]]],Saturn:[[[[.87401354025,0,0],[.11107659762,3.96205090159,213.299095438],[.01414150957,4.58581516874,7.1135470008],[.00398379389,.52112032699,206.1855484372],[.00350769243,3.30329907896,426.598190876],[.00206816305,.24658372002,103.0927742186],[792713e-9,3.84007056878,220.4126424388],[.00023990355,4.66976924553,110.2063212194],[.00016573588,.43719228296,419.4846438752],[.00014906995,5.76903183869,316.3918696566],[.0001582029,.93809155235,632.7837393132],[.00014609559,1.56518472,3.9321532631],[.00013160301,4.44891291899,14.2270940016],[.00015053543,2.71669915667,639.897286314],[.00013005299,5.98119023644,11.0457002639],[.00010725067,3.12939523827,202.2533951741],[5863206e-11,.23656938524,529.6909650946],[5227757e-11,4.20783365759,3.1813937377],[6126317e-11,1.76328667907,277.0349937414],[5019687e-11,3.17787728405,433.7117378768],[459255e-10,.61977744975,199.0720014364],[4005867e-11,2.24479718502,63.7358983034],[2953796e-11,.98280366998,95.9792272178],[387367e-10,3.22283226966,138.5174968707],[2461186e-11,2.03163875071,735.8765135318],[3269484e-11,.77492638211,949.1756089698],[1758145e-11,3.2658010994,522.5774180938],[1640172e-11,5.5050445305,846.0828347512],[1391327e-11,4.02333150505,323.5054166574],[1580648e-11,4.37265307169,309.2783226558],[1123498e-11,2.83726798446,415.5524906121],[1017275e-11,3.71700135395,227.5261894396],[848642e-11,3.1915017083,209.3669421749]],[[213.2990952169,0,0],[.01297370862,1.82834923978,213.299095438],[.00564345393,2.88499717272,7.1135470008],[.00093734369,1.06311793502,426.598190876],[.00107674962,2.27769131009,206.1855484372],[.00040244455,2.04108104671,220.4126424388],[.00019941774,1.2795439047,103.0927742186],[.00010511678,2.7488034213,14.2270940016],[6416106e-11,.38238295041,639.897286314],[4848994e-11,2.43037610229,419.4846438752],[4056892e-11,2.92133209468,110.2063212194],[3768635e-11,3.6496533078,3.9321532631]],[[.0011644133,1.17988132879,7.1135470008],[.00091841837,.0732519584,213.299095438],[.00036661728,0,0],[.00015274496,4.06493179167,206.1855484372]]],[[[.04330678039,3.60284428399,213.299095438],[.00240348302,2.85238489373,426.598190876],[.00084745939,0,0],[.00030863357,3.48441504555,220.4126424388],[.00034116062,.57297307557,206.1855484372],[.0001473407,2.11846596715,639.897286314],[9916667e-11,5.79003188904,419.4846438752],[6993564e-11,4.7360468972,7.1135470008],[4807588e-11,5.43305312061,316.3918696566]],[[.00198927992,4.93901017903,213.299095438],[.00036947916,3.14159265359,0],[.00017966989,.5197943111,426.598190876]]],[[[9.55758135486,0,0],[.52921382865,2.39226219573,213.299095438],[.01873679867,5.2354960466,206.1855484372],[.01464663929,1.64763042902,426.598190876],[.00821891141,5.93520042303,316.3918696566],[.00547506923,5.0153261898,103.0927742186],[.0037168465,2.27114821115,220.4126424388],[.00361778765,3.13904301847,7.1135470008],[.00140617506,5.70406606781,632.7837393132],[.00108974848,3.29313390175,110.2063212194],[.00069006962,5.94099540992,419.4846438752],[.00061053367,.94037691801,639.897286314],[.00048913294,1.55733638681,202.2533951741],[.00034143772,.19519102597,277.0349937414],[.00032401773,5.47084567016,949.1756089698],[.00020936596,.46349251129,735.8765135318],[9796004e-11,5.20477537945,1265.5674786264],[.00011993338,5.98050967385,846.0828347512],[208393e-9,1.52102476129,433.7117378768],[.00015298404,3.0594381494,529.6909650946],[6465823e-11,.17732249942,1052.2683831884],[.00011380257,1.7310542704,522.5774180938],[3419618e-11,4.94550542171,1581.959348283]],[[.0618298134,.2584351148,213.299095438],[.00506577242,.71114625261,206.1855484372],[.00341394029,5.79635741658,426.598190876],[.00188491195,.47215589652,220.4126424388],[.00186261486,3.14159265359,0],[.00143891146,1.40744822888,7.1135470008]],[[.00436902572,4.78671677509,213.299095438]]]],Uranus:[[[[5.48129294297,0,0],[.09260408234,.89106421507,74.7815985673],[.01504247898,3.6271926092,1.4844727083],[.00365981674,1.89962179044,73.297125859],[.00272328168,3.35823706307,149.5631971346],[.00070328461,5.39254450063,63.7358983034],[.00068892678,6.09292483287,76.2660712756],[.00061998615,2.26952066061,2.9689454166],[.00061950719,2.85098872691,11.0457002639],[.0002646877,3.14152083966,71.8126531507],[.00025710476,6.11379840493,454.9093665273],[.0002107885,4.36059339067,148.0787244263],[.00017818647,1.74436930289,36.6485629295],[.00014613507,4.73732166022,3.9321532631],[.00011162509,5.8268179635,224.3447957019],[.0001099791,.48865004018,138.5174968707],[9527478e-11,2.95516862826,35.1640902212],[7545601e-11,5.236265824,109.9456887885],[4220241e-11,3.23328220918,70.8494453042],[40519e-9,2.277550173,151.0476698429],[3354596e-11,1.0654900738,4.4534181249],[2926718e-11,4.62903718891,9.5612275556],[349034e-10,5.48306144511,146.594251718],[3144069e-11,4.75199570434,77.7505439839],[2922333e-11,5.35235361027,85.8272988312],[2272788e-11,4.36600400036,70.3281804424],[2051219e-11,1.51773566586,.1118745846],[2148602e-11,.60745949945,38.1330356378],[1991643e-11,4.92437588682,277.0349937414],[1376226e-11,2.04283539351,65.2203710117],[1666902e-11,3.62744066769,380.12776796],[1284107e-11,3.11347961505,202.2533951741],[1150429e-11,.93343589092,3.1813937377],[1533221e-11,2.58594681212,52.6901980395],[1281604e-11,.54271272721,222.8603229936],[1372139e-11,4.19641530878,111.4301614968],[1221029e-11,.1990065003,108.4612160802],[946181e-11,1.19253165736,127.4717966068],[1150989e-11,4.17898916639,33.6796175129]],[[74.7815986091,0,0],[.00154332863,5.24158770553,74.7815985673],[.00024456474,1.71260334156,1.4844727083],[9258442e-11,.4282973235,11.0457002639],[8265977e-11,1.50218091379,63.7358983034],[915016e-10,1.41213765216,149.5631971346]]],[[[.01346277648,2.61877810547,74.7815985673],[623414e-9,5.08111189648,149.5631971346],[.00061601196,3.14159265359,0],[9963722e-11,1.61603805646,76.2660712756],[992616e-10,.57630380333,73.297125859]],[[.00034101978,.01321929936,74.7815985673]]],[[[19.21264847206,0,0],[.88784984413,5.60377527014,74.7815985673],[.03440836062,.32836099706,73.297125859],[.0205565386,1.7829515933,149.5631971346],[.0064932241,4.52247285911,76.2660712756],[.00602247865,3.86003823674,63.7358983034],[.00496404167,1.40139935333,454.9093665273],[.00338525369,1.58002770318,138.5174968707],[.00243509114,1.57086606044,71.8126531507],[.00190522303,1.99809394714,1.4844727083],[.00161858838,2.79137786799,148.0787244263],[.00143706183,1.38368544947,11.0457002639],[.00093192405,.17437220467,36.6485629295],[.00071424548,4.24509236074,224.3447957019],[.00089806014,3.66105364565,109.9456887885],[.00039009723,1.66971401684,70.8494453042],[.00046677296,1.39976401694,35.1640902212],[.00039025624,3.36234773834,277.0349937414],[.00036755274,3.88649278513,146.594251718],[.00030348723,.70100838798,151.0476698429],[.00029156413,3.180563367,77.7505439839],[.00022637073,.72518687029,529.6909650946],[.00011959076,1.7504339214,984.6003316219],[.00025620756,5.25656086672,380.12776796]],[[.01479896629,3.67205697578,74.7815985673]]]],Neptune:[[[[5.31188633046,0,0],[.0179847553,2.9010127389,38.1330356378],[.01019727652,.48580922867,1.4844727083],[.00124531845,4.83008090676,36.6485629295],[.00042064466,5.41054993053,2.9689454166],[.00037714584,6.09221808686,35.1640902212],[.00033784738,1.24488874087,76.2660712756],[.00016482741,7727998e-11,491.5579294568],[9198584e-11,4.93747051954,39.6175083461],[899425e-10,.27462171806,175.1660598002]],[[38.13303563957,0,0],[.00016604172,4.86323329249,1.4844727083],[.00015744045,2.27887427527,38.1330356378]]],[[[.03088622933,1.44104372644,38.1330356378],[.00027780087,5.91271884599,76.2660712756],[.00027623609,0,0],[.00015355489,2.52123799551,36.6485629295],[.00015448133,3.50877079215,39.6175083461]]],[[[30.07013205828,0,0],[.27062259632,1.32999459377,38.1330356378],[.01691764014,3.25186135653,36.6485629295],[.00807830553,5.18592878704,1.4844727083],[.0053776051,4.52113935896,35.1640902212],[.00495725141,1.5710564165,491.5579294568],[.00274571975,1.84552258866,175.1660598002],[.0001201232,1.92059384991,1021.2488945514],[.00121801746,5.79754470298,76.2660712756],[.00100896068,.3770272493,73.297125859],[.00135134092,3.37220609835,39.6175083461],[7571796e-11,1.07149207335,388.4651552382]]]]};let ia=function(e){var t,n,r,i;const a=2e3+(e-14)/365.24217;return a<-500?32*(t=(a-1820)/100)*t-20:a<500?10583.6-1014.41*(t=a/100)+33.78311*(n=t*t)-5.952053*(r=t*n)-.1798452*(i=n*n)+.022174192*(n*r)+.0090316521*(r*r):a<1600?1574.2-556.01*(t=(a-1e3)/100)+71.23472*(n=t*t)+.319781*(r=t*n)-.8503463*(i=n*n)-.005050998*(n*r)+.0083572073*(r*r):a<1700?120-.9808*(t=a-1600)-.01532*(n=t*t)+(r=t*n)/7129:a<1800?8.83+.1603*(t=a-1700)-.0059285*(n=t*t)+13336e-8*(r=t*n)-(i=n*n)/1174e3:a<1860?13.72-.332447*(t=a-1800)+.0068612*(n=t*t)+.0041116*(r=t*n)-37436e-8*(i=n*n)+121272e-10*(n*r)-1.699e-7*(r*r)+8.75e-10*(r*i):a<1900?7.62+.5737*(t=a-1860)-.251754*(n=t*t)+.01680668*(r=t*n)-.0004473624*(i=n*n)+n*r/233174:a<1920?1.494119*(t=a-1900)-2.79-.0598939*(n=t*t)+.0061966*(r=t*n)-197e-6*(i=n*n):a<1941?21.2+.84493*(t=a-1920)-.0761*(n=t*t)+.0020936*(r=t*n):a<1961?29.07+.407*(t=a-1950)-(n=t*t)/233+(r=t*n)/2547:a<1986?45.45+1.067*(t=a-1975)-(n=t*t)/260-(r=t*n)/718:a<2005?63.86+.3345*(t=a-2e3)-.060374*(n=t*t)+.0017275*(r=t*n)+651814e-9*(i=n*n)+2373599e-11*(n*r):a<2050?62.92+.32217*(t=a-2e3)+.005589*t*t:a<2150?32*(t=(a-1820)/100)*t-20-.5628*(2150-a):32*(t=(a-1820)/100)*t-20};function aa(e){return e+ia(e)/86400}let oa=class e{constructor(t){if(t instanceof e)return this.date=t.date,this.ut=t.ut,void(this.tt=t.tt);const n=864e5;if(t instanceof Date&&Number.isFinite(t.getTime()))return this.date=t,this.ut=(t.getTime()-Bi.getTime())/n,void(this.tt=aa(this.ut));if(Number.isFinite(t))return this.date=new Date(Bi.getTime()+t*n),this.ut=t,void(this.tt=aa(this.ut));throw"Argument must be a Date object, an AstroTime object, or a numeric UTC Julian date."}static FromTerrestrialTime(t){let n=new e(t);for(;;){const e=t-n.tt;if(Math.abs(e)<1e-12)return n;n=n.AddDays(e)}}toString(){return this.date.toISOString()}AddDays(t){return new e(this.ut+t)}};function sa(e){return e instanceof oa?e:new oa(e)}function ca(e){var t=e.tt/36525;return(((((-4.34e-8*t-576e-9)*t+.0020034)*t-1831e-7)*t-46.836769)*t+84381.406)/3600}var ua;function la(e){if(!ua||Math.abs(ua.tt-e.tt)>1e-6){const t=function(e){function t(e){return e%1296e3*Vi}const n=e.tt/36525,r=t(1287104.79305+129596581.0481*n),i=t(335779.526232+1739527262.8478*n),a=t(1072260.70369+1602961601.209*n),o=t(450160.398036-6962890.5431*n);let s=Math.sin(o),c=Math.cos(o),u=(-172064161-174666*n)*s+33386*c,l=(92052331+9086*n)*c+15377*s,h=2*(i-a+o);return s=Math.sin(h),c=Math.cos(h),u+=(-13170906-1675*n)*s-13696*c,l+=(5730336-3015*n)*c-4587*s,h=2*(i+o),s=Math.sin(h),c=Math.cos(h),u+=(-2276413-234*n)*s+2796*c,l+=(978459-485*n)*c+1374*s,h=2*o,s=Math.sin(h),c=Math.cos(h),u+=(2074554+207*n)*s-698*c,l+=(470*n-897492)*c-291*s,s=Math.sin(r),c=Math.cos(r),u+=(1475877-3633*n)*s+11817*c,l+=(73871-184*n)*c-1924*s,{dpsi:1e-7*u-135e-6,deps:388e-6+1e-7*l}}(e),n=ca(e),r=n+t.deps/3600;ua={tt:e.tt,dpsi:t.dpsi,deps:t.deps,ee:t.dpsi*Math.cos(n*Gi)/15,mobl:n,tobl:r}}return ua}function ha(e,t){return function(e,t){const n=e*Gi,r=Math.cos(n),i=Math.sin(n);return[t[0],t[1]*r-t[2]*i,t[1]*i+t[2]*r]}(ca(e),t)}function da(e,t){const n=e.tt/36525;let r=84381.406,i=((((-9.51e-8*n+132851e-9)*n-.00114045)*n-1.0790069)*n+5038.481507)*n,a=((((3.337e-7*n-467e-9)*n-.00772503)*n+.0512623)*n-.025754)*n+r,o=((((-56e-9*n+170663e-9)*n-.00121197)*n-2.3814292)*n+10.556403)*n;r*=Vi,i*=Vi,a*=Vi,o*=Vi;const s=Math.sin(r),c=Math.cos(r),u=Math.sin(-i),l=Math.cos(-i),h=Math.sin(-a),d=Math.cos(-a),m=Math.sin(o),p=Math.cos(o),f=p*l-u*m*d,v=p*u*c+m*d*l*c-s*m*h,g=p*u*s+m*d*l*s+c*m*h,S=-m*l-u*p*d,w=-m*u*c+p*d*l*c-s*p*h,y=-m*u*s+p*d*l*s+c*p*h,_=u*h,x=-h*l*c-s*d,T=-h*l*s+d*c;if(t===na.Into2000)return new Sa([[f,v,g],[S,w,y],[_,x,T]]);if(t===na.From2000)return new Sa([[f,S,_],[v,w,x],[g,y,T]]);throw"Invalid precess direction"}let ma;function pa(e){return function(e){if(!ma||ma.tt!==e.tt){const t=e.tt/36525;let n=15*la(e).ee;const r=function(e){let t=(.779057273264+.00273781191135448*e.ut+e.ut%1)%1*360;return t<0&&(t+=360),t}(e);let i=((n+.014506+((((-3.68e-8*t-29956e-9)*t-44e-8)*t+1.3915817)*t+4612.156534)*t)/3600+r)%360/15;i<0&&(i+=24),ma={tt:e.tt,st:i}}return ma.st}(sa(e))}let fa=class{constructor(e,t,n,r){this.x=e,this.y=t,this.z=n,this.t=r}Length(){return Math.hypot(this.x,this.y,this.z)}};class va{constructor(e,t,n,r,i,a,o){this.x=e,this.y=t,this.z=n,this.vx=r,this.vy=i,this.vz=a,this.t=o}}class ga{constructor(e,t,n){this.lat=Zi(e),this.lon=Zi(t),this.dist=Zi(n)}}class Sa{constructor(e){this.rot=e}}function wa(e){const t=sa(e),n=function(e){const t=e.tt/36525;function n(e,t){const n=[];let r;for(r=0;r<=t-e;++r)n.push(0);return{min:e,array:n}}function r(e,t,r,i){const a=[];for(let o=0;o<=t-e;++o)a.push(n(r,i));return{min:e,array:a}}function i(e,t,n){const r=e.array[t-e.min];return r.array[n-r.min]}function a(e,t,n,r){const i=e.array[t-e.min];i.array[n-i.min]=r}let o,s,c,u,l,h,d,m,p,f,v,g,S,w,y,_,x,T,E,A,R,C,D,I=r(-6,6,1,4),O=r(-6,6,1,4);function N(e,t){return i(I,e,t)}function b(e,t){return i(O,e,t)}function P(e,t,n){return a(I,e,t,n)}function L(e,t,n){return a(O,e,t,n)}function M(e,t,n,r,i){i(e*n-t*r,t*n+e*r)}function U(e){return Math.sin(Wi*e)}d=t*t,p=0,D=0,v=0,g=3422.7;var H=U(.19833+.05611*t),F=U(.27869+.04508*t),z=U(.16827-.36903*t),G=U(.34734-5.37261*t),B=U(.10498-5.37899*t),W=U(.42681-.41855*t);for(T=.84*H+.31*F+14.27*z+7.26*G+.28*B+.24*W,E=2.94*H+.31*F+14.27*z+9.34*G+1.12*B+.83*W,A=-6.4*H-1.89*W,R=.21*H+.31*F+14.27*z-88.7*G-15.3*B+.24*W-1.86*U(.14943-5.37511*t),C=T-A,m=-3332e-9*U(.59734-5.37261*t)-539e-9*U(.35498-5.37899*t)-64e-9*U(.39943-5.37511*t),S=Wi*Ji(.60643382+1336.85522467*t-313e-8*d)+T/ki,w=Wi*Ji(.37489701+1325.55240982*t+2565e-8*d)+E/ki,y=Wi*Ji(.99312619+99.99735956*t-44e-8*d)+A/ki,_=Wi*Ji(.25909118+1342.2278298*t-892e-8*d)+R/ki,x=Wi*Ji(.82736186+1236.85308708*t-397e-8*d)+C/ki,l=1;l<=4;++l){switch(l){case 1:c=w,s=4,u=1.000002208;break;case 2:c=y,s=3,u=.997504612-.002495388*t;break;case 3:c=_,s=4,u=1.000002708+139.978*m;break;case 4:c=x,s=6,u=1;break;default:throw`Internal error: I = ${l}`}for(P(0,l,1),P(1,l,Math.cos(c)*u),L(0,l,0),L(1,l,Math.sin(c)*u),h=2;h<=s;++h)M(N(h-1,l),b(h-1,l),N(1,l),b(1,l),(e,t)=>(P(h,l,e),L(h,l,t)));for(h=1;h<=s;++h)P(-h,l,N(h,l)),L(-h,l,-b(h,l))}function k(e,t,n,r){for(var i={x:1,y:0},a=[0,e,t,n,r],o=1;o<=4;++o)0!==a[o]&&M(i.x,i.y,N(a[o],o),b(a[o],o),(e,t)=>(i.x=e,i.y=t));return i}function V(e,t,n,r,i,a,o,s){var c=k(i,a,o,s);p+=e*c.y,D+=t*c.y,v+=n*c.x,g+=r*c.x}function j(e,t,n,r,i){return e*k(t,n,r,i).y}V(13.902,14.06,-.001,.2607,0,0,0,4),V(.403,-4.01,.394,.0023,0,0,0,3),V(2369.912,2373.36,.601,28.2333,0,0,0,2),V(-125.154,-112.79,-.725,-.9781,0,0,0,1),V(1.979,6.98,-.445,.0433,1,0,0,4),V(191.953,192.72,.029,3.0861,1,0,0,2),V(-8.466,-13.51,.455,-.1093,1,0,0,1),V(22639.5,22609.07,.079,186.5398,1,0,0,0),V(18.609,3.59,-.094,.0118,1,0,0,-1),V(-4586.465,-4578.13,-.077,34.3117,1,0,0,-2),V(3.215,5.44,.192,-.0386,1,0,0,-3),V(-38.428,-38.64,.001,.6008,1,0,0,-4),V(-.393,-1.43,-.092,.0086,1,0,0,-6),V(-.289,-1.59,.123,-.0053,0,1,0,4),V(-24.42,-25.1,.04,-.3,0,1,0,2),V(18.023,17.93,.007,.1494,0,1,0,1),V(-668.146,-126.98,-1.302,-.3997,0,1,0,0),V(.56,.32,-.001,-.0037,0,1,0,-1),V(-165.145,-165.06,.054,1.9178,0,1,0,-2),V(-1.877,-6.46,-.416,.0339,0,1,0,-4),V(.213,1.02,-.074,.0054,2,0,0,4),V(14.387,14.78,-.017,.2833,2,0,0,2),V(-.586,-1.2,.054,-.01,2,0,0,1),V(769.016,767.96,.107,10.1657,2,0,0,0),V(1.75,2.01,-.018,.0155,2,0,0,-1),V(-211.656,-152.53,5.679,-.3039,2,0,0,-2),V(1.225,.91,-.03,-.0088,2,0,0,-3),V(-30.773,-34.07,-.308,.3722,2,0,0,-4),V(-.57,-1.4,-.074,.0109,2,0,0,-6),V(-2.921,-11.75,.787,-.0484,1,1,0,2),V(1.267,1.52,-.022,.0164,1,1,0,1),V(-109.673,-115.18,.461,-.949,1,1,0,0),V(-205.962,-182.36,2.056,1.4437,1,1,0,-2),V(.233,.36,.012,-.0025,1,1,0,-3),V(-4.391,-9.66,-.471,.0673,1,1,0,-4),V(.283,1.53,-.111,.006,1,-1,0,4),V(14.577,31.7,-1.54,.2302,1,-1,0,2),V(147.687,138.76,.679,1.1528,1,-1,0,0),V(-1.089,.55,.021,0,1,-1,0,-1),V(28.475,23.59,-.443,-.2257,1,-1,0,-2),V(-.276,-.38,-.006,-.0036,1,-1,0,-3),V(.636,2.27,.146,-.0102,1,-1,0,-4),V(-.189,-1.68,.131,-.0028,0,2,0,2),V(-7.486,-.66,-.037,-.0086,0,2,0,0),V(-8.096,-16.35,-.74,.0918,0,2,0,-2),V(-5.741,-.04,0,-9e-4,0,0,2,2),V(.255,0,0,0,0,0,2,1),V(-411.608,-.2,0,-.0124,0,0,2,0),V(.584,.84,0,.0071,0,0,2,-1),V(-55.173,-52.14,0,-.1052,0,0,2,-2),V(.254,.25,0,-.0017,0,0,2,-3),V(.025,-1.67,0,.0031,0,0,2,-4),V(1.06,2.96,-.166,.0243,3,0,0,2),V(36.124,50.64,-1.3,.6215,3,0,0,0),V(-13.193,-16.4,.258,-.1187,3,0,0,-2),V(-1.187,-.74,.042,.0074,3,0,0,-4),V(-.293,-.31,-.002,.0046,3,0,0,-6),V(-.29,-1.45,.116,-.0051,2,1,0,2),V(-7.649,-10.56,.259,-.1038,2,1,0,0),V(-8.627,-7.59,.078,-.0192,2,1,0,-2),V(-2.74,-2.54,.022,.0324,2,1,0,-4),V(1.181,3.32,-.212,.0213,2,-1,0,2),V(9.703,11.67,-.151,.1268,2,-1,0,0),V(-.352,-.37,.001,-.0028,2,-1,0,-1),V(-2.494,-1.17,-.003,-.0017,2,-1,0,-2),V(.36,.2,-.012,-.0043,2,-1,0,-4),V(-1.167,-1.25,.008,-.0106,1,2,0,0),V(-7.412,-6.12,.117,.0484,1,2,0,-2),V(-.311,-.65,-.032,.0044,1,2,0,-4),V(.757,1.82,-.105,.0112,1,-2,0,2),V(2.58,2.32,.027,.0196,1,-2,0,0),V(2.533,2.4,-.014,-.0212,1,-2,0,-2),V(-.344,-.57,-.025,.0036,0,3,0,-2),V(-.992,-.02,0,0,1,0,2,2),V(-45.099,-.02,0,-.001,1,0,2,0),V(-.179,-9.52,0,-.0833,1,0,2,-2),V(-.301,-.33,0,.0014,1,0,2,-4),V(-6.382,-3.37,0,-.0481,1,0,-2,2),V(39.528,85.13,0,-.7136,1,0,-2,0),V(9.366,.71,0,-.0112,1,0,-2,-2),V(.202,.02,0,0,1,0,-2,-4),V(.415,.1,0,.0013,0,1,2,0),V(-2.152,-2.26,0,-.0066,0,1,2,-2),V(-1.44,-1.3,0,.0014,0,1,-2,2),V(.384,-.04,0,0,0,1,-2,-2),V(1.938,3.6,-.145,.0401,4,0,0,0),V(-.952,-1.58,.052,-.013,4,0,0,-2),V(-.551,-.94,.032,-.0097,3,1,0,0),V(-.482,-.57,.005,-.0045,3,1,0,-2),V(.681,.96,-.026,.0115,3,-1,0,0),V(-.297,-.27,.002,-9e-4,2,2,0,-2),V(.254,.21,-.003,0,2,-2,0,-2),V(-.25,-.22,.004,.0014,1,3,0,-2),V(-3.996,0,0,4e-4,2,0,2,0),V(.557,-.75,0,-.009,2,0,2,-2),V(-.459,-.38,0,-.0053,2,0,-2,2),V(-1.298,.74,0,4e-4,2,0,-2,0),V(.538,1.14,0,-.0141,2,0,-2,-2),V(.263,.02,0,0,1,1,2,0),V(.426,.07,0,-6e-4,1,1,-2,-2),V(-.304,.03,0,3e-4,1,-1,2,0),V(-.372,-.19,0,-.0027,1,-1,-2,2),V(.418,0,0,0,0,0,4,0),V(-.33,-.04,0,0,3,0,2,0),f=0,f+=j(-526.069,0,0,1,-2),f+=j(-3.352,0,0,1,-4),f+=j(44.297,1,0,1,-2),f+=j(-6,1,0,1,-4),f+=j(20.599,-1,0,1,0),f+=j(-30.598,-1,0,1,-2),f+=j(-24.649,-2,0,1,0),f+=j(-2,-2,0,1,-2),f+=j(-22.571,0,1,1,-2),f+=j(10.985,0,-1,1,-2),p+=.82*U(.7736-62.5512*t)+.31*U(.0466-125.1025*t)+.35*U(.5785-25.1042*t)+.66*U(.4591+1335.8075*t)+.64*U(.313-91.568*t)+1.14*U(.148+1331.2898*t)+.21*U(.5918+1056.5859*t)+.44*U(.5784+1322.8595*t)+.24*U(.2275-5.7374*t)+.28*U(.2965+2.6929*t)+.33*U(.3132+6.3368*t),o=_+D/ki;let Y=(1.000002708+139.978*m)*(18518.511+1.189+v)*Math.sin(o)-6.24*Math.sin(3*o)+f;return{geo_eclip_lon:Wi*Ji((S+p/ki)/Wi),geo_eclip_lat:Math.PI/648e3*Y,distance_au:4263520978299708e-20*ki/(.999953253*g)}}(t),r=n.distance_au*Math.cos(n.geo_eclip_lat),i=function(e,t,n){return function(e,t){return[e.rot[0][0]*t[0]+e.rot[1][0]*t[1]+e.rot[2][0]*t[2],e.rot[0][1]*t[0]+e.rot[1][1]*t[1]+e.rot[2][1]*t[2],e.rot[0][2]*t[0]+e.rot[1][2]*t[1]+e.rot[2][2]*t[2]]}(da(t,n),e)}(ha(t,[r*Math.cos(n.geo_eclip_lon),r*Math.sin(n.geo_eclip_lon),n.distance_au*Math.sin(n.geo_eclip_lat)]),t,na.Into2000);return new fa(i[0],i[1],i[2],t)}function ya(e,t,n){let r=1,i=0;for(let a of e){let e=0;for(let[n,r,i]of a)e+=n*Math.cos(r+t*i);let o=r*e;n&&(o%=Wi),i+=o,r*=t}return i}function _a(e,t){let n=1,r=0,i=0,a=0;for(let o of e){let e=0,s=0;for(let[n,r,i]of o){let o=r+t*i;e+=n*i*Math.sin(o),a>0&&(s+=n*Math.cos(o))}i+=a*r*s-n*e,r=n,n*=t,++a}return i}const xa=365250;function Ta(e){return new Ia(e[0]+4.4036e-7*e[1]-1.90919e-7*e[2],-4.79966e-7*e[0]+.917482137087*e[1]-.397776982902*e[2],.397776982902*e[1]+.917482137087*e[2])}function Ea(e,t,n){const r=n*Math.cos(t);return[r*Math.cos(e),r*Math.sin(e),n*Math.sin(t)]}function Aa(e,t){const n=t.tt/xa;return Ta(Ea(ya(e[0],n,!0),ya(e[1],n,!1),ya(e[2],n,!1))).ToAstroVector(t)}function Ra(e,t,n,r){const i=r/(r+ji),a=Aa(ra[n],t);e.x+=i*a.x,e.y+=i*a.y,e.z+=i*a.z}const Ca=146,Da=[[-73e4,[-26.118207232108,-14.376168177825,3.384402515299],[.0016339372163656,-.0027861699588508,-.0013585880229445]],[-700800,[41.974905202127,-.448502952929,-12.770351505989],[.00073458569351457,.0022785014891658,.00048619778602049]],[-671600,[14.706930780744,44.269110540027,9.353698474772],[-.00210001479998,.00022295915939915,.00070143443551414]],[-642400,[-29.441003929957,-6.43016153057,6.858481011305],[.00084495803960544,-.0030783914758711,-.0012106305981192]],[-613200,[39.444396946234,-6.557989760571,-13.913760296463],[.0011480029005873,.0022400006880665,.00035168075922288]],[-584e3,[20.2303809507,43.266966657189,7.382966091923],[-.0019754081700585,.00053457141292226,.00075929169129793]],[-554800,[-30.65832536462,2.093818874552,9.880531138071],[61010603013347e-18,-.0031326500935382,-.00099346125151067]],[-525600,[35.737703251673,-12.587706024764,-14.677847247563],[.0015802939375649,.0021347678412429,.00019074436384343]],[-496400,[25.466295188546,41.367478338417,5.216476873382],[-.0018054401046468,.0008328308359951,.00080260156912107]],[-467200,[-29.847174904071,10.636426313081,12.297904180106],[-.00063257063052907,-.0029969577578221,-.00074476074151596]],[-438e3,[30.774692107687,-18.236637015304,-14.945535879896],[.0020113162005465,.0019353827024189,-20937793168297e-19]],[-408800,[30.243153324028,38.656267888503,2.938501750218],[-.0016052508674468,.0011183495337525,.00083333973416824]],[-379600,[-27.288984772533,18.643162147874,14.023633623329],[-.0011856388898191,-.0027170609282181,-.00049015526126399]],[-350400,[24.519605196774,-23.245756064727,-14.626862367368],[.0024322321483154,.0016062008146048,-.00023369181613312]],[-321200,[34.505274805875,35.125338586954,.557361475637],[-.0013824391637782,.0013833397561817,.00084823598806262]],[-292e3,[-23.275363915119,25.818514298769,15.055381588598],[-.0016062295460975,-.0023395961498533,-.00024377362639479]],[-262800,[17.050384798092,-27.180376290126,-13.608963321694],[.0028175521080578,.0011358749093955,-.00049548725258825]],[-233600,[38.093671910285,30.880588383337,-1.843688067413],[-.0011317697153459,.0016128814698472,.00084177586176055]],[-204400,[-18.197852930878,31.932869934309,15.438294826279],[-.0019117272501813,-.0019146495909842,-19657304369835e-18]],[-175200,[8.528924039997,-29.618422200048,-11.805400994258],[.0031034370787005,.0005139363329243,-.00077293066202546]],[-146e3,[40.94685725864,25.904973592021,-4.256336240499],[-.00083652705194051,.0018129497136404,.0008156422827306]],[-116800,[-12.326958895325,36.881883446292,15.217158258711],[-.0021166103705038,-.001481442003599,.00017401209844705]],[-87600,[-.633258375909,-30.018759794709,-9.17193287495],[.0032016994581737,-.00025279858672148,-.0010411088271861]],[-58400,[42.936048423883,20.344685584452,-6.588027007912],[-.00050525450073192,.0019910074335507,.00077440196540269]],[-29200,[-5.975910552974,40.61180995846,14.470131723673],[-.0022184202156107,-.0010562361130164,.00033652250216211]],[0,[-9.875369580774,-27.978926224737,-5.753711824704],[.0030287533248818,-.0011276087003636,-.0012651326732361]],[29200,[43.958831986165,14.214147973292,-8.808306227163],[-.00014717608981871,.0021404187242141,.00071486567806614]],[58400,[.67813676352,43.094461639362,13.243238780721],[-.0022358226110718,-.00063233636090933,.00047664798895648]],[87600,[-18.282602096834,-23.30503958666,-1.766620508028],[.0025567245263557,-.0019902940754171,-.0013943491701082]],[116800,[43.873338744526,7.700705617215,-10.814273666425],[.00023174803055677,.0022402163127924,.00062988756452032]],[146e3,[7.392949027906,44.382678951534,11.629500214854],[-.002193281545383,-.00021751799585364,.00059556516201114]],[175200,[-24.981690229261,-16.204012851426,2.466457544298],[.001819398914958,-.0026765419531201,-.0013848283502247]],[204400,[42.530187039511,.845935508021,-12.554907527683],[.00065059779150669,.0022725657282262,.00051133743202822]],[233600,[13.999526486822,44.462363044894,9.669418486465],[-.0021079296569252,.00017533423831993,.00069128485798076]],[262800,[-29.184024803031,-7.371243995762,6.493275957928],[.00093581363109681,-.0030610357109184,-.0012364201089345]],[292e3,[39.831980671753,-6.078405766765,-13.909815358656],[.0011117769689167,.0022362097830152,.00036230548231153]],[321200,[20.294955108476,43.417190420251,7.450091985932],[-.0019742157451535,.00053102050468554,.00075938408813008]],[350400,[-30.66999230216,2.318743558955,9.973480913858],[45605107450676e-18,-.0031308219926928,-.00099066533301924]],[379600,[35.626122155983,-12.897647509224,-14.777586508444],[.0016015684949743,.0021171931182284,.00018002516202204]],[408800,[26.133186148561,41.232139187599,5.00640132622],[-.0017857704419579,.00086046232702817,.00080614690298954]],[438e3,[-29.57674022923,11.863535943587,12.631323039872],[-.00072292830060955,-.0029587820140709,-.000708242964503]],[467200,[29.910805787391,-19.159019294,-15.013363865194],[.0020871080437997,.0018848372554514,-38528655083926e-18]],[496400,[31.375957451819,38.050372720763,2.433138343754],[-.0015546055556611,.0011699815465629,.00083565439266001]],[525600,[-26.360071336928,20.662505904952,14.414696258958],[-.0013142373118349,-.0026236647854842,-.00042542017598193]],[554800,[22.599441488648,-24.508879898306,-14.484045731468],[.0025454108304806,.0014917058755191,-.00030243665086079]],[584e3,[35.877864013014,33.894226366071,-.224524636277],[-.0012941245730845,.0014560427668319,.00084762160640137]],[613200,[-21.538149762417,28.204068269761,15.321973799534],[-.001731211740901,-.0021939631314577,-.0001631691327518]],[642400,[13.971521374415,-28.339941764789,-13.083792871886],[.0029334630526035,.00091860931752944,-.00059939422488627]],[671600,[39.526942044143,28.93989736011,-2.872799527539],[-.0010068481658095,.001702113288809,.00083578230511981]],[700800,[-15.576200701394,34.399412961275,15.466033737854],[-.0020098814612884,-.0017191109825989,70414782780416e-18]],[73e4,[4.24325283709,-30.118201690825,-10.707441231349],[.0031725847067411,.0001609846120227,-.00090672150593868]]];let Ia=class e{constructor(e,t,n){this.x=e,this.y=t,this.z=n}clone(){return new e(this.x,this.y,this.z)}ToAstroVector(e){return new fa(this.x,this.y,this.z,e)}static zero(){return new e(0,0,0)}quadrature(){return this.x*this.x+this.y*this.y+this.z*this.z}add(t){return new e(this.x+t.x,this.y+t.y,this.z+t.z)}sub(t){return new e(this.x-t.x,this.y-t.y,this.z-t.z)}incr(e){this.x+=e.x,this.y+=e.y,this.z+=e.z}decr(e){this.x-=e.x,this.y-=e.y,this.z-=e.z}mul(t){return new e(t*this.x,t*this.y,t*this.z)}div(t){return new e(this.x/t,this.y/t,this.z/t)}mean(t){return new e((this.x+t.x)/2,(this.y+t.y)/2,(this.z+t.z)/2)}neg(){return new e(-this.x,-this.y,-this.z)}};class Oa{constructor(e,t,n){this.tt=e,this.r=t,this.v=n}clone(){return new Oa(this.tt,this.r,this.v)}sub(e){return new Oa(this.tt,this.r.sub(e.r),this.v.sub(e.v))}}function Na(e,t,n,r){const i=r/(r+ji),a=function(e,t){const n=t/xa,r=ya(e[0],n,!0),i=ya(e[1],n,!1),a=ya(e[2],n,!1),o=_a(e[0],n),s=_a(e[1],n),c=_a(e[2],n),u=Math.cos(r),l=Math.sin(r),h=Math.cos(i),d=Math.sin(i),m=+c*h*u-a*d*u*s-a*h*l*o,p=+c*h*l-a*d*l*s+a*h*u*o,f=+c*d+a*h*s,v=Ea(r,i,a),g=[m/xa,p/xa,f/xa],S=Ta(v),w=Ta(g);return new Oa(t,S,w)}(ra[n],t);return e.r.incr(a.r.mul(i)),e.v.incr(a.v.mul(i)),a}function ba(e,t,n){const r=n.sub(e),i=r.quadrature();return r.mul(t/(i*Math.sqrt(i)))}class Pa{constructor(e){let t=new Oa(e,new Ia(0,0,0),new Ia(0,0,0));this.Jupiter=Na(t,e,$i.Jupiter,Yi),this.Saturn=Na(t,e,$i.Saturn,Xi),this.Uranus=Na(t,e,$i.Uranus,qi),this.Neptune=Na(t,e,$i.Neptune,Ki),this.Jupiter.r.decr(t.r),this.Jupiter.v.decr(t.v),this.Saturn.r.decr(t.r),this.Saturn.v.decr(t.v),this.Uranus.r.decr(t.r),this.Uranus.v.decr(t.v),this.Neptune.r.decr(t.r),this.Neptune.v.decr(t.v),this.Sun=new Oa(e,t.r.mul(-1),t.v.mul(-1))}Acceleration(e){let t=ba(e,ji,this.Sun.r);return t.incr(ba(e,Yi,this.Jupiter.r)),t.incr(ba(e,Xi,this.Saturn.r)),t.incr(ba(e,qi,this.Uranus.r)),t.incr(ba(e,Ki,this.Neptune.r)),t}}class La{constructor(e,t,n,r){this.tt=e,this.r=t,this.v=n,this.a=r}clone(){return new La(this.tt,this.r.clone(),this.v.clone(),this.a.clone())}}let Ma=class{constructor(e,t){this.bary=e,this.grav=t}};function Ua(e,t,n,r){return new Ia(t.x+e*(n.x+e*r.x/2),t.y+e*(n.y+e*r.y/2),t.z+e*(n.z+e*r.z/2))}function Ha(e,t,n){return new Ia(t.x+e*n.x,t.y+e*n.y,t.z+e*n.z)}function Fa(e,t){const n=e-t.tt,r=new Pa(e),i=Ua(n,t.r,t.v,t.a),a=r.Acceleration(i).mean(t.a),o=Ua(n,t.r,t.v,a),s=t.v.add(a.mul(n)),c=r.Acceleration(o),u=new La(e,o,s,c);return new Ma(r,u)}const za=[];function Ga(e,t){const n=Math.floor(e);return n<0?0:n>=t?t-1:n}function Ba(e){const t=function(e){let[t,[n,r,i],[a,o,s]]=e;return new Oa(t,new Ia(n,r,i),new Ia(a,o,s))}(e),n=new Pa(t.tt),r=t.r.add(n.Sun.r),i=t.v.add(n.Sun.v),a=n.Acceleration(r),o=new La(t.tt,r,i,a);return new Ma(n,o)}function Wa(e,t,n){let r=Ba(e);const i=Math.ceil((t-r.grav.tt)/n);for(let a=0;a<i;++a)r=Fa(a+1===i?t:r.grav.tt+n,r.grav);return r}function ka(e,t){let n,r,i;const a=function(e,t){const n=Da[0][0];if(t<n||t>Da[50][0])return null;const r=Ga((t-n)/29200,50);if(!e[r]){const t=e[r]=[];t[0]=Ba(Da[r]).grav,t[200]=Ba(Da[r+1]).grav;let n,a=t[0].tt;for(n=1;n<200;++n)t[n]=Fa(a+=Ca,t[n-1]).grav;a=t[200].tt;var i=[];for(i[200]=t[200],n=199;n>0;--n)i[n]=Fa(a-=Ca,i[n+1]).grav;for(n=199;n>0;--n){const e=n/200;t[n].r=t[n].r.mul(1-e).add(i[n].r.mul(e)),t[n].v=t[n].v.mul(1-e).add(i[n].v.mul(e)),t[n].a=t[n].a.mul(1-e).add(i[n].a.mul(e))}}return e[r]}(za,e.tt);if(a){const t=Ga((e.tt-a[0].tt)/Ca,200),i=a[t],o=a[t+1],s=i.a.mean(o.a),c=Ua(e.tt-i.tt,i.r,i.v,s),u=Ha(e.tt-i.tt,i.v,s),l=Ua(e.tt-o.tt,o.r,o.v,s),h=Ha(e.tt-o.tt,o.v,s),d=(e.tt-i.tt)/Ca;n=c.mul(1-d).add(l.mul(d)),r=u.mul(1-d).add(h.mul(d))}else{let t;t=e.tt<Da[0][0]?Wa(Da[0],e.tt,-Ca):Wa(Da[50],e.tt,146),n=t.grav.r,r=t.grav.v,i=t.bary}return i||(i=new Pa(e.tt)),n=n.sub(i.Sun.r),r=r.sub(i.Sun.v),new va(n.x,n.y,n.z,r.x,r.y,r.z,e)}function Va(e,t){var n=sa(t);if(e in ra)return Aa(ra[e],n);if(e===$i.Pluto){const e=ka(n);return new fa(e.x,e.y,e.z,n)}if(e===$i.Sun)return new fa(0,0,0,n);if(e===$i.Moon){var r=Aa(ra.Earth,n),i=wa(n);return new fa(r.x+i.x,r.y+i.y,r.z+i.z,n)}if(e===$i.EMB){const e=Aa(ra.Earth,n),t=wa(n),r=82.30056;return new fa(e.x+t.x/r,e.y+t.y/r,e.z+t.z/r,n)}if(e===$i.SSB)return function(e){const t=new fa(0,0,0,e);return Ra(t,e,$i.Jupiter,Yi),Ra(t,e,$i.Saturn,Xi),Ra(t,e,$i.Uranus,qi),Ra(t,e,$i.Neptune,Ki),t}(n);const a=ta(e);if(a){return function(e,t){t=sa(t);const n=e.lat*Gi,r=e.lon*Gi,i=e.dist*Math.cos(n);return new fa(i*Math.cos(r),i*Math.sin(r),e.dist*Math.sin(n),t)}(new ga(a.dec,15*a.ra,a.dist),n)}throw`HelioVector: Unknown body "${e}"`}class ja{constructor(e,t,n,r){this.observerBody=e,this.targetBody=t,this.aberration=n,this.observerPos=r}Position(e){this.aberration&&(this.observerPos=Va(this.observerBody,e));const t=Va(this.targetBody,e);return new fa(t.x-this.observerPos.x,t.y-this.observerPos.y,t.z-this.observerPos.z,e)}}function Ya(e,t,n,r){const i=sa(e);if(ta(n)){const e=Va(n,i),r=Va(t,i);return new fa(e.x-r.x,e.y-r.y,e.z-r.z,i)}let a;a=Va(t,i);const o=new ja(t,n,r,a);return function(e,t){let n=t,r=0;for(let i=0;i<10;++i){const i=e(n),a=i.Length()/173.1446326846693;if(a>1)throw"Object is too distant for light-travel solver.";const o=t.AddDays(-a);if(r=Math.abs(o.tt-n.tt),r<1e-9)return i;n=o}throw`Light-travel time solver did not converge: dt = ${r}`}(e=>o.Position(e),i)}var Xa,qa,Ka;function Za(e){const t=da(e=sa(e),na.From2000),n=function(e,t){const n=la(e),r=n.mobl*Gi,i=n.tobl*Gi,a=n.dpsi*Vi,o=Math.cos(r),s=Math.sin(r),c=Math.cos(i),u=Math.sin(i),l=Math.cos(a),h=Math.sin(a),d=l,m=-h*o,p=-h*s,f=h*c,v=l*o*c+s*u,g=l*s*c-o*u,S=h*u,w=l*o*u-s*c,y=l*s*u+o*c;if(t===na.From2000)return new Sa([[d,f,S],[m,v,w],[p,g,y]]);if(t===na.Into2000)return new Sa([[d,m,p],[f,v,g],[S,w,y]]);throw"Invalid precess direction"}(e,na.From2000);return function(e,t){return new Sa([[t.rot[0][0]*e.rot[0][0]+t.rot[1][0]*e.rot[0][1]+t.rot[2][0]*e.rot[0][2],t.rot[0][1]*e.rot[0][0]+t.rot[1][1]*e.rot[0][1]+t.rot[2][1]*e.rot[0][2],t.rot[0][2]*e.rot[0][0]+t.rot[1][2]*e.rot[0][1]+t.rot[2][2]*e.rot[0][2]],[t.rot[0][0]*e.rot[1][0]+t.rot[1][0]*e.rot[1][1]+t.rot[2][0]*e.rot[1][2],t.rot[0][1]*e.rot[1][0]+t.rot[1][1]*e.rot[1][1]+t.rot[2][1]*e.rot[1][2],t.rot[0][2]*e.rot[1][0]+t.rot[1][2]*e.rot[1][1]+t.rot[2][2]*e.rot[1][2]],[t.rot[0][0]*e.rot[2][0]+t.rot[1][0]*e.rot[2][1]+t.rot[2][0]*e.rot[2][2],t.rot[0][1]*e.rot[2][0]+t.rot[1][1]*e.rot[2][1]+t.rot[2][1]*e.rot[2][2],t.rot[0][2]*e.rot[2][0]+t.rot[1][2]*e.rot[2][1]+t.rot[2][2]*e.rot[2][2]]])}(t,n)}!function(e){e[e.Pericenter=0]="Pericenter",e[e.Apocenter=1]="Apocenter"}(Xa||(Xa={})),function(e){e.Penumbral="penumbral",e.Partial="partial",e.Annular="annular",e.Total="total"}(qa||(qa={})),function(e){e[e.Invalid=0]="Invalid",e[e.Ascending=1]="Ascending",e[e.Descending=-1]="Descending"}(Ka||(Ka={}));const Ja=new l;function $a(e){return e instanceof oa?e:new oa(e instanceof Date?e:new Date(e))}function Qa(e,t=new l){const n=$a(e),{rot:r}=function(e,t,n){const r=Zi(n)*Gi,i=Math.cos(r),a=Math.sin(r),o=(t+1)%3,s=(t+2)%3,c=t;let u=[[0,0,0],[0,0,0],[0,0,0]];return u[o][o]=i*e.rot[o][o]-a*e.rot[o][s],u[o][s]=a*e.rot[o][o]+i*e.rot[o][s],u[o][c]=e.rot[o][c],u[s][o]=i*e.rot[s][o]-a*e.rot[s][s],u[s][s]=a*e.rot[s][o]+i*e.rot[s][s],u[s][c]=e.rot[s][c],u[c][o]=i*e.rot[c][o]-a*e.rot[c][s],u[c][s]=a*e.rot[c][o]+i*e.rot[c][s],u[c][c]=e.rot[c][c],new Sa(u)}(Za(n),2,-15*pa(n));return t.set(r[0][0],r[1][0],r[2][0],0,r[0][1],r[1][1],r[2][1],0,r[0][2],r[1][2],r[2][2],0,0,0,0,1)}function eo(e,t,n,r,i){const{x:a,y:o,z:s}=function(e,t,n){const r=sa(t);switch(e){case $i.Earth:return new fa(0,0,0,r);case $i.Moon:return wa(r);default:const t=Ya(r,$i.Earth,e,n);return t.t=r,t}}(e,t,!1);return n.set(a,o,s),n.normalize()}function to(e,t,n,r){const i=Qa(t,Ja);return eo(e,t,n),n.applyMatrix4(i)}function no(e,t=new u,n){return to($i.Sun,$a(e),t)}function ro(e,t=new u,n){return to($i.Moon,$a(e),t)}function io(e){return Math.sqrt(Math.max(e,0))}function ao(e,t,n){const{topRadius:r}=e;return function(e){return Math.max(e,0)}(-t*n+io(t**2*(n**2-1)+r**2))}function oo(e,t){return.5/t+e*(1-1/t)}const so=new u,co=new u,uo=new u,lo=new WeakMap;function ho(e,t,n){const r=4*t;return n.set(e[r],e[r+1],e[r+2])}function mo(e,t,n){const r=function(e){let t=Kn(e.image.data)?e.image.data:Kn(e.userData.imageData)?e.userData.imageData:void 0;if(e.type===D&&t instanceof Uint16Array){const e=lo.get(t.buffer);null==e?(t=new Xn(t.buffer),lo.set(t.buffer,t)):t=e}return t}(e);if(null==r)return n.setScalar(0);const{width:i,height:a}=e.image,o=$n(t.x,0,1)*(i-1),s=$n(t.y,0,1)*(a-1),c=Math.floor(o),u=Math.floor(s),l=o-c,h=s-u,d=c%i,m=(d+1)%i,p=u%a,f=(p+1)%a,v=ho(r,p*i+d,so),g=ho(r,p*i+m,co),S=v.lerp(g,l),w=ho(r,f*i+d,co),y=ho(r,f*i+m,uo),_=w.lerp(y,l);return n.copy(S.lerp(_,h))}const po=new u,fo=new u,vo=new B;function go(e,t,n,r=new W,{ellipsoid:i=ue.WGS84,correctAltitude:a=!0}={},o=Ei.DEFAULT){const s=po.copy(t);if(a){const e=i.projectOnSurface(t,fo);null!=e&&s.sub(i.getOsculatingSphereCenter(e,o.bottomRadius,fo))}const c=fo;let u=s.length(),l=s.dot(n);const{topRadius:h}=o,d=-l-Math.sqrt(l**2-u**2+h**2);if(d>0&&(u=h,l+=d),u>h)c.set(1,1,1);else{const t=l/u;if(function(e,t,n){const{bottomRadius:r}=e;return n<0&&t**2*(n**2-1)+r**2>=0}(o,u,t))c.setScalar(0);else{const n=function(e,t,n,r){const{topRadius:i,bottomRadius:a}=e,o=Math.sqrt(i**2-a**2),s=io(t**2-a**2),c=i-t,u=(ao(e,t,n)-c)/(s+o-c),l=s/o;return r.set(oo(u,Si),oo(l,64))}(o,u,t,vo);mo(e,n,c)}}const m=c.multiply(o.solarIrradiance).multiply(o.sunRadianceToRelativeLuminance);return r.setFromVector3(m)}function So(){return function(e){var t=[];if(0===e.length)return"";if("string"!=typeof e[0])throw new TypeError("Url must be a string. Received "+e[0]);if(e[0].match(/^[^/:]+:\/*$/)&&e.length>1){var n=e.shift();e[0]=n+e[0]}e[0].match(/^file:\/\/\//)?e[0]=e[0].replace(/^([^/:]+):\/*/,"$1:///"):e[0]=e[0].replace(/^([^/:]+):\/*/,"$1://");for(var r=0;r<e.length;r++){var i=e[r];if("string"!=typeof i)throw new TypeError("Url must be a string. Received "+i);""!==i&&(r>0&&(i=i.replace(/^[\/]+/,"")),i=r<e.length-1?i.replace(/[\/]+$/,""):i.replace(/[\/]+$/,"/"),t.push(i))}var a=t.join("/"),o=(a=a.replace(/\/(\?|&|#[^!])/g,"$1")).split("?");return o.shift()+(o.length>0?"?":"")+o.join("&")}("object"==typeof arguments[0]?arguments[0]:[].slice.call(arguments))}const wo={width:Si,height:64},yo={width:256,height:128,depth:32},_o={width:64,height:16};class xo extends d{constructor({format:e="exr",type:t=D,combinedScattering:n=!0,higherOrderScattering:r=!0}={},i){super(i),this.format=e,this.type=t,this.combinedScattering=n,this.higherOrderScattering=r}setType(e){return this.type=function(e){return null!=e.getContext().getExtension("OES_texture_float_linear")}(e)?I:D,this}setTypeFromRenderer(e){return this.setType(e)}load(e,t,n,r){const i={},a=({key:a,loader:o,path:s})=>(o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(this.withCredentials),o.load(So(e,s),e=>{e.type=this.type,this.type===I&&(e.image.data=new Float32Array(new Xn(e.image.data.buffer))),e.minFilter=m,e.magFilter=m,i[`${a}Texture`]=e,null!=i.irradianceTexture&&null!=i.scatteringTexture&&null!=i.transmittanceTexture&&(this.combinedScattering||null!=i.singleMieScatteringTexture)&&(!this.higherOrderScattering||null!=i.higherOrderScatteringTexture)&&(null==t||t(i))},n,r));return"exr"===this.format?{transmittanceTexture:a({key:"transmittance",loader:new Fr(wo,this.manager),path:"transmittance.exr"}),scatteringTexture:a({key:"scattering",loader:new Hr(yo,this.manager),path:"scattering.exr"}),irradianceTexture:a({key:"irradiance",loader:new Fr(_o,this.manager),path:"irradiance.exr"}),singleMieScatteringTexture:this.combinedScattering?void 0:a({key:"singleMieScattering",loader:new Hr(yo,this.manager),path:"single_mie_scattering.exr"}),higherOrderScatteringTexture:this.higherOrderScattering?a({key:"higherOrderScattering",loader:new Hr(yo,this.manager),path:"higher_order_scattering.exr"}):void 0}:{transmittanceTexture:a({key:"transmittance",loader:new Jn(_,ti,wo,this.manager),path:"transmittance.bin"}),scatteringTexture:a({key:"scattering",loader:new Jn(f,ti,yo,this.manager),path:"scattering.bin"}),irradianceTexture:a({key:"irradiance",loader:new Jn(_,ti,_o,this.manager),path:"irradiance.bin"}),singleMieScatteringTexture:this.combinedScattering?void 0:a({key:"singleMieScattering",loader:new Jn(f,ti,yo,this.manager),path:"single_mie_scattering.bin"}),higherOrderScatteringTexture:this.higherOrderScattering?a({key:"higherOrderScattering",loader:new Jn(f,ti,yo,this.manager),path:"higher_order_scattering.bin"}):void 0}}}const To=1/Math.sqrt(Math.PI),Eo=Math.sqrt(3)/(2*Math.sqrt(Math.PI)),Ao=new u,Ro=new u,Co=new B,Do=new j,Io={ellipsoid:ue.WGS84,correctAltitude:!0};class Oo extends V{constructor(e,t=Ei.DEFAULT){super(),this.atmosphere=t,this.worldToECEFMatrix=new l;const{irradianceTexture:n=null,ellipsoid:r,correctAltitude:i,sunDirection:a}={...Io,...e};this.irradianceTexture=n,this.ellipsoid=r,this.correctAltitude=i,this.sunDirection=(null==a?void 0:a.clone())??new u}update(){if(null==this.irradianceTexture)return;const e=this.worldToECEFMatrix,t=Do.setFromMatrix4(e).transpose(),n=this.getWorldPosition(Ao).applyMatrix4(e);if(this.correctAltitude){const e=this.ellipsoid.projectOnSurface(n,Ro);null!=e&&n.add(Ri(e,this.atmosphere.bottomRadius,this.ellipsoid,Ro))}const r=n.length(),i=n.dot(this.sunDirection)/r,a=function({topRadius:e,bottomRadius:t},n,r,i){const a=(n-t)/(e-t),o=.5*r+.5;return i.set(oo(o,64),oo(a,16))}(this.atmosphere,r,i,Co),o=mo(this.irradianceTexture,a,Ro);o.multiply(this.atmosphere.skyRadianceToRelativeLuminance);const s=this.ellipsoid.getSurfaceNormal(n).applyMatrix3(t),c=this.sh.coefficients;c[0].copy(o).multiplyScalar(To),c[1].copy(o).multiplyScalar(Eo*s.y),c[2].copy(o).multiplyScalar(Eo*s.z),c[3].copy(o).multiplyScalar(Eo*s.x)}}var No=Object.defineProperty,bo=(e,t,n,r)=>{for(var i,a=void 0,o=e.length-1;o>=0;o--)(i=e[o])&&(a=i(t,n,a)||a);return a&&No(t,n,a),a};const Po={...Fi,sun:!0,moon:!0,moonAngularRadius:.0045,lunarRadianceScale:1,ground:!0,groundAlbedo:new W(0)};class Lo extends zi{constructor(e){const{sun:t,moon:n,moonDirection:r,moonAngularRadius:i,lunarRadianceScale:a,ground:o,groundAlbedo:s,...c}={...Po,...e};super({name:"SkyMaterial",glslVersion:k,vertexShader:"precision highp float;\nprecision highp sampler3D;\n\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 inverseViewMatrix;\nuniform vec3 cameraPosition;\nuniform mat4 worldToECEFMatrix;\nuniform vec3 altitudeCorrection;\n\nlayout(location = 0) in vec3 position;\n\nout vec2 vUv;\nout vec3 vCameraPosition;\nout vec3 vRayDirection;\n\nvoid getCameraRay(out vec3 origin, out vec3 direction) {\n  bool isPerspective = inverseProjectionMatrix[2][3] != 0.0; // 4th entry in the 3rd column\n\n  if (isPerspective) {\n    // Calculate the camera ray for a perspective camera.\n    vec4 viewPosition = inverseProjectionMatrix * vec4(position, 1.0);\n    vec4 worldDirection = inverseViewMatrix * vec4(viewPosition.xyz, 0.0);\n    origin = cameraPosition;\n    direction = worldDirection.xyz;\n  } else {\n    // Unprojected points to calculate direction.\n    vec4 nearPoint = inverseProjectionMatrix * vec4(position.xy, -1.0, 1.0);\n    vec4 farPoint = inverseProjectionMatrix * vec4(position.xy, -0.9, 1.0);\n    nearPoint /= nearPoint.w;\n    farPoint /= farPoint.w;\n\n    // Calculate world values\n    vec4 worldDirection = inverseViewMatrix * vec4(farPoint.xyz - nearPoint.xyz, 0.0);\n    vec4 worldOrigin = inverseViewMatrix * nearPoint;\n\n    // Outputs\n    direction = worldDirection.xyz;\n    origin = worldOrigin.xyz;\n  }\n}\n\nvoid main() {\n  vUv = position.xy * 0.5 + 0.5;\n\n  vec3 direction, origin;\n  getCameraRay(origin, direction);\n\n  vec3 cameraPositionECEF = (worldToECEFMatrix * vec4(origin, 1.0)).xyz;\n  vCameraPosition = (cameraPositionECEF + altitudeCorrection) * METER_TO_LENGTH_UNIT;\n  vRayDirection = (worldToECEFMatrix * vec4(direction, 0.0)).xyz;\n\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}\n",fragmentShader:Jr('precision highp float;\nprecision highp sampler3D;\n\n#define RECIPROCAL_PI 0.3183098861837907\n\n#include "core/raySphereIntersection"\n\n#include "bruneton/definitions"\n\nuniform AtmosphereParameters ATMOSPHERE;\nuniform vec3 SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;\nuniform vec3 SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;\n\nuniform sampler2D transmittance_texture;\nuniform sampler3D scattering_texture;\nuniform sampler2D irradiance_texture;\nuniform sampler3D single_mie_scattering_texture;\nuniform sampler3D higher_order_scattering_texture;\n\n#include "bruneton/common"\n#include "bruneton/runtime"\n\n#include "sky"\n\nuniform vec3 sunDirection;\nuniform vec3 moonDirection;\nuniform float moonAngularRadius;\nuniform float lunarRadianceScale;\nuniform vec3 groundAlbedo;\n\n#ifdef HAS_SHADOW_LENGTH\nuniform sampler2D shadowLengthBuffer;\n#endif // HAS_SHADOW_LENGTH\n\nin vec2 vUv;\nin vec3 vCameraPosition;\nin vec3 vRayDirection;\n\nlayout(location = 0) out vec4 outputColor;\n\n#include <mrt_layout>\n\nvoid main() {\n  float shadowLength = 0.0;\n  #ifdef HAS_SHADOW_LENGTH\n  shadowLength = texture(shadowLengthBuffer, vUv).r;\n  #endif // HAS_SHADOW_LENGTH\n\n  vec3 cameraPosition = vCameraPosition;\n  vec3 rayDirection = normalize(vRayDirection);\n\n  #ifdef GROUND_ALBEDO\n\n  float r = length(cameraPosition);\n  float mu = dot(cameraPosition, rayDirection) / r;\n  bool intersectsGround = RayIntersectsGround(ATMOSPHERE, r, mu);\n  if (intersectsGround) {\n    float distanceToGround = raySphereFirstIntersection(\n      cameraPosition,\n      rayDirection,\n      ATMOSPHERE.bottom_radius\n    );\n    vec3 groundPosition = rayDirection * distanceToGround + cameraPosition;\n    vec3 surfaceNormal = normalize(groundPosition);\n    vec3 skyIrradiance;\n    vec3 sunIrradiance = GetSunAndSkyIrradiance(\n      cameraPosition,\n      surfaceNormal,\n      sunDirection,\n      skyIrradiance\n    );\n    vec3 transmittance;\n    vec3 inscatter = GetSkyRadianceToPoint(\n      cameraPosition,\n      ATMOSPHERE.bottom_radius * surfaceNormal,\n      shadowLength,\n      sunDirection,\n      transmittance\n    );\n    vec3 radiance = groundAlbedo * RECIPROCAL_PI * (sunIrradiance + skyIrradiance);\n    outputColor.rgb = radiance * transmittance + inscatter;\n  } else {\n    outputColor.rgb = getSkyRadiance(\n      cameraPosition,\n      rayDirection,\n      shadowLength,\n      sunDirection,\n      moonDirection,\n      moonAngularRadius,\n      lunarRadianceScale\n    );\n  }\n\n  #else // GROUND_ALBEDO\n\n  outputColor.rgb = getSkyRadiance(\n    cameraPosition,\n    rayDirection,\n    shadowLength,\n    sunDirection,\n    moonDirection,\n    moonAngularRadius,\n    lunarRadianceScale\n  );\n\n  #endif // GROUND_ALBEDO\n\n  outputColor.a = 1.0;\n\n  #include <mrt_output>\n}\n',{core:{raySphereIntersection:hi},bruneton:{common:fi,definitions:vi,runtime:gi},sky:Ci}),...c,uniforms:{inverseProjectionMatrix:new G(new l),inverseViewMatrix:new G(new l),moonDirection:new G((null==r?void 0:r.clone())??new u),moonAngularRadius:new G(i),lunarRadianceScale:new G(a),groundAlbedo:new G(s.clone()),shadowLengthBuffer:new G(null),...c.uniforms},defines:{PERSPECTIVE_CAMERA:"1"},depthTest:!0}),this.shadowLength=null,this.sun=t,this.moon=n,this.ground=o}onBeforeRender(e,t,n,r,i,a){super.onBeforeRender(e,t,n,r,i,a);const{uniforms:o,defines:s}=this;o.inverseProjectionMatrix.value.copy(n.projectionMatrixInverse),o.inverseViewMatrix.value.copy(n.matrixWorld);const c=null!=s.PERSPECTIVE_CAMERA,u=!0===n.isPerspectiveCamera;u!==c&&(u?s.PERSPECTIVE_CAMERA="1":delete s.PERSPECTIVE_CAMERA,this.needsUpdate=!0);const l=this.groundAlbedo,h=null!=s.GROUND_ALBEDO,d=0!==l.r||0!==l.g||0!==l.b;d!==h&&(d?this.defines.GROUND_ALBEDO="1":delete this.defines.GROUND_ALBEDO,this.needsUpdate=!0);const m=this.shadowLength,p=null!=m;p!==(null!=s.HAS_SHADOW_LENGTH)&&(p?s.HAS_SHADOW_LENGTH="1":(delete s.HAS_SHADOW_LENGTH,o.shadowLengthBuffer.value=null),this.needsUpdate=!0),p&&(o.shadowLengthBuffer.value=m.map)}get moonDirection(){return this.uniforms.moonDirection.value}get moonAngularRadius(){return this.uniforms.moonAngularRadius.value}set moonAngularRadius(e){this.uniforms.moonAngularRadius.value=e}get lunarRadianceScale(){return this.uniforms.lunarRadianceScale.value}set lunarRadianceScale(e){this.uniforms.lunarRadianceScale.value=e}get groundAlbedo(){return this.uniforms.groundAlbedo.value}}bo([tr("SUN")],Lo.prototype,"sun"),bo([tr("MOON")],Lo.prototype,"moon"),bo([tr("GROUND")],Lo.prototype,"ground");var Mo=Object.defineProperty,Uo=(e,t,n,r)=>{for(var i,a=void 0,o=e.length-1;o>=0;o--)(i=e[o])&&(a=i(t,n,a)||a);return a&&Mo(t,n,a),a};const Ho={...Fi,pointSize:1,intensity:1,background:!0,ground:!0};let Fo=class extends zi{constructor(e){const{pointSize:t,radianceScale:n,intensity:r,background:i,ground:a,...o}={...Ho,...e};super({name:"StarsMaterial",glslVersion:k,vertexShader:"precision highp float;\nprecision highp sampler3D;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 matrixWorld;\nuniform vec3 cameraPosition;\nuniform float cameraFar;\nuniform mat4 worldToECEFMatrix;\nuniform vec3 altitudeCorrection;\nuniform float pointSize;\nuniform vec2 magnitudeRange;\nuniform float intensity;\n\nlayout(location = 0) in vec3 position;\nlayout(location = 1) in float magnitude;\nlayout(location = 2) in vec3 color;\n\nout vec3 vCameraPosition;\nout vec3 vRayDirection;\nout vec3 vEllipsoidCenter;\nout vec3 vColor;\n\nvoid main() {\n  // Magnitude is stored between 0 to 1 within the given range.\n  float m = mix(magnitudeRange.x, magnitudeRange.y, magnitude);\n  vec3 v = pow(vec3(10.0), -vec3(magnitudeRange, m) / 2.5);\n  vColor = vec3(intensity * color);\n  vColor *= saturate((v.z - v.y) / (v.x - v.y));\n\n  #ifdef BACKGROUND\n  vec3 worldDirection = normalize(matrixWorld * vec4(position, 1.0)).xyz;\n  vec3 cameraPositionECEF = (worldToECEFMatrix * vec4(cameraPosition, 1.0)).xyz;\n  vCameraPosition = (cameraPositionECEF + altitudeCorrection) * METER_TO_LENGTH_UNIT;\n  vRayDirection = (worldToECEFMatrix * vec4(worldDirection, 0.0)).xyz;\n  gl_Position =\n    projectionMatrix * viewMatrix * vec4(cameraPosition + worldDirection * cameraFar, 1.0);\n  #else // BACKGROUND\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  #endif // BACKGROUND\n\n  gl_PointSize = pointSize;\n}\n",fragmentShader:Jr('precision highp float;\nprecision highp sampler3D;\n\n#include "bruneton/definitions"\n\nuniform AtmosphereParameters ATMOSPHERE;\nuniform vec3 SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;\nuniform vec3 SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;\n\nuniform sampler2D transmittance_texture;\nuniform sampler3D scattering_texture;\nuniform sampler2D irradiance_texture;\nuniform sampler3D single_mie_scattering_texture;\nuniform sampler3D higher_order_scattering_texture;\n\n#include "bruneton/common"\n#include "bruneton/runtime"\n\nuniform vec3 sunDirection;\n\nin vec3 vCameraPosition;\nin vec3 vRayDirection;\n\nlayout(location = 0) out vec4 outputColor;\n\n#include <mrt_layout>\n\nin vec3 vColor;\n\nvoid main() {\n  #if !defined(PERSPECTIVE_CAMERA)\n  outputColor = vec4(0.0);\n  discard; // Rendering celestial objects without perspective doesn\'t make sense.\n  #endif // !defined(PERSPECTIVE_CAMERA)\n\n  #ifdef BACKGROUND\n  vec3 rayDirection = normalize(vRayDirection);\n  float r = length(vCameraPosition);\n  float mu = dot(vCameraPosition, rayDirection) / r;\n\n  if (RayIntersectsGround(ATMOSPHERE, r, mu)) {\n    discard;\n  }\n\n  vec3 transmittance;\n  vec3 radiance = GetSkyRadiance(\n    vCameraPosition,\n    normalize(vRayDirection),\n    0.0, // Shadow length\n    sunDirection,\n    transmittance\n  );\n  radiance += transmittance * vColor;\n  outputColor = vec4(radiance, 1.0);\n  #else // BACKGROUND\n  outputColor = vec4(vColor, 1.0);\n  #endif // BACKGROUND\n\n  #include <mrt_output>\n}\n',{bruneton:{common:fi,definitions:vi,runtime:gi}}),...o,uniforms:{projectionMatrix:new G(new l),modelViewMatrix:new G(new l),viewMatrix:new G(new l),matrixWorld:new G(new l),cameraFar:new G(0),pointSize:new G(0),magnitudeRange:new G(new B(-2,8)),intensity:new G(n??r),...o.uniforms},defines:{PERSPECTIVE_CAMERA:"1"}}),this.pointSize=t,this.background=i,this.ground=a}onBeforeRender(e,t,n,r,i,a){super.onBeforeRender(e,t,n,r,i,a);const o=this.uniforms;o.projectionMatrix.value.copy(n.projectionMatrix),o.modelViewMatrix.value.copy(n.modelViewMatrix),o.viewMatrix.value.copy(n.matrixWorldInverse),o.matrixWorld.value.copy(i.matrixWorld),o.cameraFar.value=n.far,o.pointSize.value=this.pointSize*e.getPixelRatio();const s=!0===n.isPerspectiveCamera;null!=this.defines.PERSPECTIVE_CAMERA!==s&&(s?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}get magnitudeRange(){return this.uniforms.magnitudeRange.value}get radianceScale(){return this.intensity}set radianceScale(e){this.intensity=e}get intensity(){return this.uniforms.intensity.value}set intensity(e){this.uniforms.intensity.value=e}};Uo([tr("BACKGROUND")],Fo.prototype,"background"),Uo([tr("GROUND")],Fo.prototype,"ground");const zo=new u,Go=new j,Bo={ellipsoid:ue.WGS84,correctAltitude:!0,distance:1};class Wo extends Y{constructor(e,t=Ei.DEFAULT){super(),this.atmosphere=t,this.worldToECEFMatrix=new l;const{irradianceTexture:n=null,ellipsoid:r,correctAltitude:i,sunDirection:a,distance:o}={...Bo,...e};this.transmittanceTexture=n,this.ellipsoid=r,this.correctAltitude=i,this.sunDirection=(null==a?void 0:a.clone())??new u,this.distance=o}update(){const e=this.worldToECEFMatrix,t=Go.setFromMatrix4(e).transpose();if(this.position.copy(this.sunDirection).applyMatrix3(t).normalize().multiplyScalar(this.distance).add(this.target.position),null==this.transmittanceTexture)return;const n=this.target.getWorldPosition(zo).applyMatrix4(e);go(this.transmittanceTexture,n,this.sunDirection,this.color,{ellipsoid:this.ellipsoid,correctAltitude:this.correctAltitude},this.atmosphere)}}var ko=Object.defineProperty;const Vo={blendFunction:n.SRC,useTurbo:!1,near:1,far:1e3};((e,t,n)=>{for(var r,i=void 0,a=e.length-1;a>=0;a--)(r=e[a])&&(i=r(t,n,i)||i);i&&ko(t,n,i)})([tr("USE_TURBO")],class extends e{constructor(e){const{blendFunction:n,useTurbo:r,near:i,far:a}={...Vo,...e};super("DepthEffect",Jr('#include "core/depth"\n#include "core/turbo"\n\nuniform float near;\nuniform float far;\n\nvoid mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {\n  float depth = readDepth(uv);\n  depth = reverseLogDepth(depth, cameraNear, cameraFar);\n  depth = linearizeDepth(depth, near, far) / far;\n\n  #ifdef USE_TURBO\n  vec3 color = turbo(1.0 - depth);\n  #else // USE_TURBO\n  vec3 color = vec3(depth);\n  #endif // USE_TURBO\n\n  outputColor = vec4(color, inputColor.a);\n}\n',{core:{depth:si,turbo:mi}}),{blendFunction:n,attributes:t.DEPTH,uniforms:new Map(Object.entries({near:new G(i),far:new G(a)}))}),this.useTurbo=r}get near(){return this.uniforms.get("near").value}set near(e){this.uniforms.get("near").value=e}get far(){return this.uniforms.get("far").value}set far(e){this.uniforms.get("far").value=e}}.prototype,"useTurbo");const jo={blendFunction:n.NORMAL};class Yo extends e{constructor(e){const{blendFunction:t}={...jo,...e};super("DitheringEffect","#define DITHERING\n\n#include <dithering_pars_fragment>\n\nvoid mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {\n  outputColor = vec4(saturate(dithering(inputColor.rgb)), inputColor.a);\n}\n",{blendFunction:t})}}const Xo={thresholdLevel:10,thresholdRange:1};let qo=class extends K{constructor(e){const{inputBuffer:t=null,thresholdLevel:n,thresholdRange:r,...i}={...Xo,...e};super({name:"DownsampleThresholdMaterial",fragmentShader:"#include <common>\n\nuniform sampler2D inputBuffer;\n\nuniform float thresholdLevel;\nuniform float thresholdRange;\n\nin vec2 vCenterUv1;\nin vec2 vCenterUv2;\nin vec2 vCenterUv3;\nin vec2 vCenterUv4;\nin vec2 vRowUv1;\nin vec2 vRowUv2;\nin vec2 vRowUv3;\nin vec2 vRowUv4;\nin vec2 vRowUv5;\nin vec2 vRowUv6;\nin vec2 vRowUv7;\nin vec2 vRowUv8;\nin vec2 vRowUv9;\n\nfloat clampToBorder(const vec2 uv) {\n  return float(uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0);\n}\n\n// Reference: https://learnopengl.com/Guest-Articles/2022/Phys.-Based-Bloom\nvoid main() {\n  vec3 color = 0.125 * texture(inputBuffer, vec2(vRowUv5)).rgb;\n  vec4 weight =\n    0.03125 *\n    vec4(\n      clampToBorder(vRowUv1),\n      clampToBorder(vRowUv3),\n      clampToBorder(vRowUv7),\n      clampToBorder(vRowUv9)\n    );\n  color += weight.x * texture(inputBuffer, vec2(vRowUv1)).rgb;\n  color += weight.y * texture(inputBuffer, vec2(vRowUv3)).rgb;\n  color += weight.z * texture(inputBuffer, vec2(vRowUv7)).rgb;\n  color += weight.w * texture(inputBuffer, vec2(vRowUv9)).rgb;\n\n  weight =\n    0.0625 *\n    vec4(\n      clampToBorder(vRowUv2),\n      clampToBorder(vRowUv4),\n      clampToBorder(vRowUv6),\n      clampToBorder(vRowUv8)\n    );\n  color += weight.x * texture(inputBuffer, vec2(vRowUv2)).rgb;\n  color += weight.y * texture(inputBuffer, vec2(vRowUv4)).rgb;\n  color += weight.z * texture(inputBuffer, vec2(vRowUv6)).rgb;\n  color += weight.w * texture(inputBuffer, vec2(vRowUv8)).rgb;\n\n  weight =\n    0.125 *\n    vec4(\n      clampToBorder(vRowUv2),\n      clampToBorder(vRowUv4),\n      clampToBorder(vRowUv6),\n      clampToBorder(vRowUv8)\n    );\n  color += weight.x * texture(inputBuffer, vec2(vCenterUv1)).rgb;\n  color += weight.y * texture(inputBuffer, vec2(vCenterUv2)).rgb;\n  color += weight.z * texture(inputBuffer, vec2(vCenterUv3)).rgb;\n  color += weight.w * texture(inputBuffer, vec2(vCenterUv4)).rgb;\n\n  // WORKAROUND: Avoid screen flashes if the input buffer contains NaN texels.\n  // See: https://github.com/takram-design-engineering/three-geospatial/issues/7\n  if (any(isnan(color))) {\n    gl_FragColor = vec4(vec3(0.0), 1.0);\n    return;\n  }\n\n  float l = luminance(color);\n  float scale = saturate(smoothstep(thresholdLevel, thresholdLevel + thresholdRange, l));\n  gl_FragColor = vec4(color * scale, 1.0);\n}\n",vertexShader:"uniform vec2 texelSize;\n\nout vec2 vCenterUv1;\nout vec2 vCenterUv2;\nout vec2 vCenterUv3;\nout vec2 vCenterUv4;\nout vec2 vRowUv1;\nout vec2 vRowUv2;\nout vec2 vRowUv3;\nout vec2 vRowUv4;\nout vec2 vRowUv5;\nout vec2 vRowUv6;\nout vec2 vRowUv7;\nout vec2 vRowUv8;\nout vec2 vRowUv9;\n\nvoid main() {\n  vec2 uv = position.xy * 0.5 + 0.5;\n  vCenterUv1 = uv + texelSize * vec2(-1.0, 1.0);\n  vCenterUv2 = uv + texelSize * vec2(1.0, 1.0);\n  vCenterUv3 = uv + texelSize * vec2(-1.0, -1.0);\n  vCenterUv4 = uv + texelSize * vec2(1.0, -1.0);\n  vRowUv1 = uv + texelSize * vec2(-2.0, 2.0);\n  vRowUv2 = uv + texelSize * vec2(0.0, 2.0);\n  vRowUv3 = uv + texelSize * vec2(2.0, 2.0);\n  vRowUv4 = uv + texelSize * vec2(-2.0, 0.0);\n  vRowUv5 = uv + texelSize;\n  vRowUv6 = uv + texelSize * vec2(2.0, 0.0);\n  vRowUv7 = uv + texelSize * vec2(-2.0, -2.0);\n  vRowUv8 = uv + texelSize * vec2(0.0, -2.0);\n  vRowUv9 = uv + texelSize * vec2(2.0, -2.0);\n\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}\n",blending:Z,toneMapped:!1,depthWrite:!1,depthTest:!1,...i,uniforms:{inputBuffer:new G(t),texelSize:new G(new B),thresholdLevel:new G(n),thresholdRange:new G(r),...i.uniforms}})}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}get inputBuffer(){return this.uniforms.inputBuffer.value}set inputBuffer(e){this.uniforms.inputBuffer.value=e}get thresholdLevel(){return this.uniforms.thresholdLevel.value}set thresholdLevel(e){this.uniforms.thresholdLevel.value=e}get thresholdRange(){return this.uniforms.thresholdRange.value}set thresholdRange(e){this.uniforms.thresholdRange.value=e}};const Ko={ghostAmount:.001,haloAmount:.001,chromaticAberration:10};class Zo extends K{constructor(e){const{inputBuffer:t=null,ghostAmount:n,haloAmount:r,chromaticAberration:i,...a}={...Ko,...e};super({name:"LensFlareFeaturesMaterial",fragmentShader:"#include <common>\n\n#define SQRT_2 0.7071067811865476\n\nuniform sampler2D inputBuffer;\n\nuniform vec2 texelSize;\nuniform float ghostAmount;\nuniform float haloAmount;\nuniform float chromaticAberration;\n\nin vec2 vUv;\nin vec2 vAspectRatio;\n\nvec3 sampleGhost(const vec2 direction, const vec3 color, const float offset) {\n  vec2 suv = clamp(1.0 - vUv + direction * offset, 0.0, 1.0);\n  vec3 result = texture(inputBuffer, suv).rgb * color;\n\n  // Falloff at the perimeter.\n  float d = clamp(length(0.5 - suv) / (0.5 * SQRT_2), 0.0, 1.0);\n  result *= pow(1.0 - d, 3.0);\n  return result;\n}\n\nvec4 sampleGhosts(float amount) {\n  vec3 color = vec3(0.0);\n  vec2 direction = vUv - 0.5;\n  color += sampleGhost(direction, vec3(0.8, 0.8, 1.0), -5.0);\n  color += sampleGhost(direction, vec3(1.0, 0.8, 0.4), -1.5);\n  color += sampleGhost(direction, vec3(0.9, 1.0, 0.8), -0.4);\n  color += sampleGhost(direction, vec3(1.0, 0.8, 0.4), -0.2);\n  color += sampleGhost(direction, vec3(0.9, 0.7, 0.7), -0.1);\n  color += sampleGhost(direction, vec3(0.5, 1.0, 0.4), 0.7);\n  color += sampleGhost(direction, vec3(0.5, 0.5, 0.5), 1.0);\n  color += sampleGhost(direction, vec3(1.0, 1.0, 0.6), 2.5);\n  color += sampleGhost(direction, vec3(0.5, 0.8, 1.0), 10.0);\n  return vec4(color * amount, 1.0);\n}\n\n// Reference: https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html\nfloat cubicRingMask(const float x, const float radius, const float thickness) {\n  float v = min(abs(x - radius) / thickness, 1.0);\n  return 1.0 - v * v * (3.0 - 2.0 * v);\n}\n\nvec3 sampleHalo(const float radius) {\n  vec2 direction = normalize((vUv - 0.5) / vAspectRatio) * vAspectRatio;\n  vec3 offset = vec3(texelSize.x * chromaticAberration) * vec3(-1.0, 0.0, 1.0);\n  vec2 suv = fract(1.0 - vUv + direction * radius);\n  vec3 result = vec3(\n    texture(inputBuffer, suv + direction * offset.r).r,\n    texture(inputBuffer, suv + direction * offset.g).g,\n    texture(inputBuffer, suv + direction * offset.b).b\n  );\n\n  // Falloff at the center and perimeter.\n  vec2 wuv = (vUv - vec2(0.5, 0.0)) / vAspectRatio + vec2(0.5, 0.0);\n  float d = saturate(distance(wuv, vec2(0.5)));\n  result *= cubicRingMask(d, 0.45, 0.25);\n  return result;\n}\n\nvec4 sampleHalos(const float amount) {\n  vec3 color = vec3(0.0);\n  color += sampleHalo(0.3);\n  return vec4(color, 1.0) * amount;\n}\n\nvoid main() {\n  gl_FragColor += sampleGhosts(ghostAmount);\n  gl_FragColor += sampleHalos(haloAmount);\n}\n\n",vertexShader:"uniform vec2 texelSize;\n\nout vec2 vUv;\nout vec2 vAspectRatio;\n\nvoid main() {\n  vUv = position.xy * 0.5 + 0.5;\n  vAspectRatio = vec2(texelSize.x / texelSize.y, 1.0);\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}\n",blending:Z,toneMapped:!1,depthWrite:!1,depthTest:!1,uniforms:{inputBuffer:new G(t),texelSize:new G(new B),ghostAmount:new G(n),haloAmount:new G(r),chromaticAberration:new G(i),...a.uniforms}})}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}get inputBuffer(){return this.uniforms.inputBuffer.value}set inputBuffer(e){this.uniforms.inputBuffer.value=e}get ghostAmount(){return this.uniforms.ghostAmount.value}set ghostAmount(e){this.uniforms.ghostAmount.value=e}get haloAmount(){return this.uniforms.haloAmount.value}set haloAmount(e){this.uniforms.haloAmount.value=e}get chromaticAberration(){return this.uniforms.chromaticAberration.value}set chromaticAberration(e){this.uniforms.chromaticAberration.value=e}}const Jo={blendFunction:n.NORMAL,resolutionScale:.5,width:r.AUTO_SIZE,height:r.AUTO_SIZE,intensity:.005};class $o extends e{constructor(e){const{blendFunction:n,resolutionScale:c,width:u,height:l,resolutionX:h=u,resolutionY:d=l,intensity:m}={...Jo,...e};super("LensFlareEffect","uniform sampler2D bloomBuffer;\nuniform sampler2D featuresBuffer;\nuniform float intensity;\n\nvoid mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {\n  vec3 bloom = texture(bloomBuffer, uv).rgb;\n  vec3 features = texture(featuresBuffer, uv).rgb;\n  outputColor = vec4(inputColor.rgb + (bloom + features) * intensity, inputColor.a);\n}\n",{blendFunction:n,attributes:t.CONVOLUTION,uniforms:new Map(Object.entries({bloomBuffer:new G(null),featuresBuffer:new G(null),intensity:new G(1)}))}),this.onResolutionChange=()=>{this.setSize(this.resolution.baseWidth,this.resolution.baseHeight)},this.renderTarget1=new q(1,1,{depthBuffer:!1,type:D}),this.renderTarget1.texture.name="LensFlare.Target1",this.renderTarget2=new q(1,1,{depthBuffer:!1,type:D}),this.renderTarget2.texture.name="LensFlare.Target2",this.thresholdMaterial=new qo,this.thresholdPass=new i(this.thresholdMaterial),this.blurPass=new a,this.blurPass.levels=8,this.preBlurPass=new o({kernelSize:s.SMALL}),this.featuresMaterial=new Zo,this.featuresPass=new i(this.featuresMaterial),this.uniforms.get("bloomBuffer").value=this.blurPass.texture,this.uniforms.get("featuresBuffer").value=this.renderTarget1.texture,this.resolution=new r(this,h,d,c),this.resolution.addEventListener("change",this.onResolutionChange),this.intensity=m}initialize(e,t,n){this.thresholdPass.initialize(e,t,n),this.blurPass.initialize(e,t,n),this.preBlurPass.initialize(e,t,n),this.featuresPass.initialize(e,t,n)}update(e,t,n){this.thresholdPass.render(e,t,this.renderTarget1),this.blurPass.render(e,this.renderTarget1,null),this.preBlurPass.render(e,this.renderTarget1,this.renderTarget2),this.featuresPass.render(e,this.renderTarget2,this.renderTarget1)}setSize(e,t){const n=this.resolution;n.setBaseSize(e,t);const{width:r,height:i}=n;this.renderTarget1.setSize(r,i),this.renderTarget2.setSize(r,i),this.thresholdMaterial.setSize(r,i),this.blurPass.setSize(r,i),this.preBlurPass.setSize(r,i),this.featuresMaterial.setSize(r,i)}get intensity(){return this.uniforms.get("intensity").value}set intensity(e){this.uniforms.get("intensity").value=e}get thresholdLevel(){return this.thresholdMaterial.thresholdLevel}set thresholdLevel(e){this.thresholdMaterial.thresholdLevel=e}get thresholdRange(){return this.thresholdMaterial.thresholdRange}set thresholdRange(e){this.thresholdMaterial.thresholdRange=e}}var Qo=Object.defineProperty,es=(e,t,n,r)=>{for(var i,a=void 0,o=e.length-1;o>=0;o--)(i=e[o])&&(a=i(t,n,a)||a);return a&&Qo(t,n,a),a};const ts={blendFunction:n.SRC,octEncoded:!1,reconstructFromDepth:!1};let ns=class extends e{constructor(e,n){const{blendFunction:r,normalBuffer:i=null,octEncoded:a,reconstructFromDepth:o}={...ts,...n};super("NormalEffect",Jr('#include "core/depth"\n#include "core/packing"\n#include "core/transform"\n\nuniform highp sampler2D normalBuffer;\n\nuniform mat4 projectionMatrix;\nuniform mat4 inverseProjectionMatrix;\n\nvec3 reconstructNormal(const vec2 uv) {\n  float depth = readDepth(uv);\n  depth = reverseLogDepth(depth, cameraNear, cameraFar);\n  vec3 position = screenToView(\n    uv,\n    depth,\n    getViewZ(depth),\n    projectionMatrix,\n    inverseProjectionMatrix\n  );\n  vec3 dx = dFdx(position);\n  vec3 dy = dFdy(position);\n  return normalize(cross(dx, dy));\n}\n\nvec3 readNormal(const vec2 uv) {\n  #ifdef OCT_ENCODED\n  return unpackVec2ToNormal(texture(normalBuffer, uv).xy);\n  #else // OCT_ENCODED\n  return 2.0 * texture(normalBuffer, uv).xyz - 1.0;\n  #endif // OCT_ENCODED\n}\n\nvoid mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {\n  #ifdef RECONSTRUCT_FROM_DEPTH\n  vec3 normal = reconstructNormal(uv);\n  #else // RECONSTRUCT_FROM_DEPTH\n  vec3 normal = readNormal(uv);\n  #endif // RECONSTRUCT_FROM_DEPTH\n\n  outputColor = vec4(normal * 0.5 + 0.5, inputColor.a);\n}\n',{core:{depth:si,packing:li,transform:di}}),{blendFunction:r,attributes:t.DEPTH,uniforms:new Map(Object.entries({normalBuffer:new G(i),projectionMatrix:new G(new l),inverseProjectionMatrix:new G(new l)}))}),this.camera=e,null!=e&&(this.mainCamera=e),this.octEncoded=a,this.reconstructFromDepth=o}get mainCamera(){return this.camera}set mainCamera(e){this.camera=e}update(e,t,n){const r=this.uniforms,i=r.get("projectionMatrix"),a=r.get("inverseProjectionMatrix"),o=this.camera;null!=o&&(i.value.copy(o.projectionMatrix),a.value.copy(o.projectionMatrixInverse))}get normalBuffer(){return this.uniforms.get("normalBuffer").value}set normalBuffer(e){this.uniforms.get("normalBuffer").value=e}};es([tr("OCT_ENCODED")],ns.prototype,"octEncoded"),es([tr("RECONSTRUCT_FROM_DEPTH")],ns.prototype,"reconstructFromDepth");const rs=gi,is=fi,as=vi;class os{constructor(e=0,t=0,n=0,r=0){this.expTerm=e,this.exponent=t,this.linearTerm=n,this.constantTerm=r}set(e=0,t=0,n=0,r=0){return this.expTerm=e,this.exponent=t,this.linearTerm=n,this.constantTerm=r,this}clone(){return new os(this.expTerm,this.exponent,this.linearTerm,this.constantTerm)}copy(e){return this.expTerm=e.expTerm,this.exponent=e.exponent,this.linearTerm=e.linearTerm,this.constantTerm=e.constantTerm,this}}const ss=["channel","altitude","height","densityScale","shapeAmount","shapeDetailAmount","weatherExponent","shapeAlteringBias","coverageFilterWidth","shadow","densityProfile"];const cs=class e{constructor(e){this.channel="r",this.altitude=0,this.height=0,this.densityScale=.2,this.shapeAmount=1,this.shapeDetailAmount=1,this.weatherExponent=1,this.shapeAlteringBias=.35,this.coverageFilterWidth=.6,this.densityProfile=new os(0,0,.75,.25),this.shadow=!1,this.set(e)}set(e){return function(e,t){if(null!=t)for(const n of ss){const r=t[n];null!=r&&(e[n]instanceof os?e[n].copy(r):e[n]=r)}}(this,e),this}clone(){return new e(this)}copy(e){return this.channel=e.channel,this.altitude=e.altitude,this.height=e.height,this.densityScale=e.densityScale,this.shapeAmount=e.shapeAmount,this.shapeDetailAmount=e.shapeDetailAmount,this.weatherExponent=e.weatherExponent,this.shapeAlteringBias=e.shapeAlteringBias,this.coverageFilterWidth=e.coverageFilterWidth,this.densityProfile.copy(e.densityProfile),this.shadow=e.shadow,this}};cs.DEFAULT=new cs;let us=cs;const ls=Array.from({length:8},()=>({value:0,flag:0})),hs=Array.from({length:3},()=>({min:0,max:0}));function ds(e,t){return e.value!==t.value?e.value-t.value:e.flag-t.flag}const ms=class e extends Array{constructor(e){super(new us(null==e?void 0:e[0]),new us(null==e?void 0:e[1]),new us(null==e?void 0:e[2]),new us(null==e?void 0:e[3]))}set(e){return this[0].set(null==e?void 0:e[0]),this[1].set(null==e?void 0:e[1]),this[2].set(null==e?void 0:e[2]),this[3].set(null==e?void 0:e[3]),this}reset(){return this[0].copy(us.DEFAULT),this[1].copy(us.DEFAULT),this[2].copy(us.DEFAULT),this[3].copy(us.DEFAULT),this}clone(){return new e(this)}copy(e){return this[0].copy(e[0]),this[1].copy(e[1]),this[2].copy(e[2]),this[3].copy(e[3]),this}get localWeatherChannels(){return this[0].channel+this[1].channel+this[2].channel+this[3].channel}packValues(e,t){return t.set(this[0][e],this[1][e],this[2][e],this[3][e])}packSums(e,t,n){return n.set(this[0][e]+this[0][t],this[1][e]+this[1][t],this[2][e]+this[2][t],this[3][e]+this[3][t])}packDensityProfiles(e,t){return t.set(this[0].densityProfile[e],this[1].densityProfile[e],this[2].densityProfile[e],this[3].densityProfile[e])}packIntervalHeights(e,t){for(let a=0;a<4;++a){const e=this[a];let t=ls[a];t.value=e.altitude,t.flag=0,t=ls[a+4],t.value=e.altitude+e.height,t.flag=1}ls.sort(ds);let n=0,r=0;for(let a=0;a<ls.length;++a){const{value:e,flag:t}=ls[a];if(0===r&&a>0){const t=hs[n++];t.min=ls[a-1].value,t.max=e}r+=0===t?1:-1}for(;n<3;++n){const e=hs[n];e.min=0,e.max=0}let i=hs[0];e.x=i.min,t.x=i.max,i=hs[1],e.y=i.min,t.y=i.max,i=hs[2],e.z=i.min,t.z=i.max}};ms.DEFAULT=new ms([{channel:"r",altitude:750,height:650,densityScale:.2,shapeAmount:1,shapeDetailAmount:1,weatherExponent:1,shapeAlteringBias:.35,coverageFilterWidth:.6,shadow:!0},{channel:"g",altitude:1e3,height:1200,densityScale:.2,shapeAmount:1,shapeDetailAmount:1,weatherExponent:1,shapeAlteringBias:.35,coverageFilterWidth:.6,shadow:!0},{channel:"b",altitude:7500,height:500,densityScale:.003,shapeAmount:.4,shapeDetailAmount:0,weatherExponent:1,shapeAlteringBias:.35,coverageFilterWidth:.5},{channel:"a"}]);let ps=ms;function fs(e,t){if(!e)throw new Error("Invariant failed")}class vs{constructor(e,t){this.near=[new u,new u,new u,new u],this.far=[new u,new u,new u,new u],null!=e&&null!=t&&this.setFromCamera(e,t)}clone(){return(new vs).copy(this)}copy(e){for(let t=0;t<4;++t)this.near[t].copy(e.near[t]),this.far[t].copy(e.far[t]);return this}setFromCamera(e,t){const n=!0===e.isOrthographicCamera,r=e.projectionMatrixInverse;this.near[0].set(1,1,-1),this.near[1].set(1,-1,-1),this.near[2].set(-1,-1,-1),this.near[3].set(-1,1,-1);for(let i=0;i<4;++i)this.near[i].applyMatrix4(r);this.far[0].set(1,1,1),this.far[1].set(1,-1,1),this.far[2].set(-1,-1,1),this.far[3].set(-1,1,1);for(let i=0;i<4;++i){const e=this.far[i];e.applyMatrix4(r);const a=Math.abs(e.z);n?e.z*=Math.min(t/a,1):e.multiplyScalar(Math.min(t/a,1))}return this}split(e,t=[]){for(let n=0;n<e.length;++n){const r=t[n]??(t[n]=new vs);if(0===n)for(let e=0;e<4;++e)r.near[e].copy(this.near[e]);else for(let t=0;t<4;++t)r.near[t].lerpVectors(this.near[t],this.far[t],e[n-1]);if(n===e.length-1)for(let e=0;e<4;++e)r.far[e].copy(this.far[e]);else for(let t=0;t<4;++t)r.far[t].lerpVectors(this.near[t],this.far[t],e[n])}return t.length=e.length,t}applyMatrix4(e){for(let t=0;t<4;++t)this.near[t].applyMatrix4(e),this.far[t].applyMatrix4(e);return this}}const gs={uniform:(e,t,n,r,i=[])=>{for(let a=0;a<e;++a)i[a]=(t+(n-t)*(a+1)/e)/n;return i.length=e,i},logarithmic:(e,t,n,r,i=[])=>{for(let a=0;a<e;++a)i[a]=t*(n/t)**((a+1)/e)/n;return i.length=e,i},practical:(e,t,n,r=.5,i=[])=>{for(let a=0;a<e;++a){const o=(t+(n-t)*(a+1)/e)/n,s=t*(n/t)**((a+1)/e)/n;i[a]=Qn(o,s,r)}return i.length=e,i}};const Ss=new u,ws=new u,ys=new l,_s=new l,xs=new vs,Ts=new L,Es={maxFar:null,farScale:1,splitMode:"practical",splitLambda:.5,margin:0,fade:!0};class As{constructor(e){this.cascades=[],this.mapSize=new B,this.cameraFrustum=new vs,this.frusta=[],this.splits=[],this._far=0;const{cascadeCount:t,mapSize:n,maxFar:r,farScale:i,splitMode:a,splitLambda:o,margin:s,fade:c}={...Es,...e};this.cascadeCount=t,this.mapSize.copy(n),this.maxFar=r,this.farScale=i,this.splitMode=a,this.splitLambda=o,this.margin=s,this.fade=c}get cascadeCount(){return this.cascades.length}set cascadeCount(e){var t;if(e!==this.cascadeCount){for(let n=0;n<e;++n)(t=this.cascades)[n]??(t[n]={interval:new B,matrix:new l,inverseMatrix:new l,projectionMatrix:new l,inverseProjectionMatrix:new l,viewMatrix:new l,inverseViewMatrix:new l});this.cascades.length=e}}get far(){return this._far}updateIntervals(e){const t=this.cascadeCount,n=this.splits,r=this.far;(function(e,t,n,r,i,a=[]){gs[e](t,n,r,i,a)})(this.splitMode,t,e.near,r,this.splitLambda,n),this.cameraFrustum.setFromCamera(e,r),this.cameraFrustum.split(n,this.frusta);const i=this.cascades;for(let a=0;a<t;++a)i[a].interval.set(n[a-1]??0,n[a]??0)}getFrustumRadius(e,t){const n=t.near,r=t.far;let i=Math.max(r[0].distanceTo(r[2]),r[0].distanceTo(n[2]));if(this.fade){const t=e.near,n=this.far;i+=.25*(r[0].z/(n-t))**2*(n-t)}return.5*i}updateMatrices(e,t,n=1){const r=ys.lookAt(Ss.setScalar(0),ws.copy(t).multiplyScalar(-1),Q.DEFAULT_UP),i=_s.multiplyMatrices(_s.copy(r).invert(),e.matrixWorld),a=this.frusta,o=this.cascades;fs(a.length===o.length);const s=this.margin,c=this.mapSize;for(let u=0;u<a.length;++u){const l=a[u],h=o[u],d=this.getFrustumRadius(e,a[u]),m=-d,p=d,f=d,v=-d;h.projectionMatrix.makeOrthographic(m,p,f,v,-this.margin,2*d+this.margin);const{near:g,far:S}=xs.copy(l).applyMatrix4(i),w=Ts.makeEmpty();for(let e=0;e<4;e++)w.expandByPoint(g[e]),w.expandByPoint(S[e]);const y=w.getCenter(Ss);y.z=w.max.z+s;const _=(p-m)/c.width,x=(f-v)/c.height;y.x=Math.round(y.x/_)*_,y.y=Math.round(y.y/x)*x,y.applyMatrix4(r);const T=ws.copy(t).multiplyScalar(n).add(y);h.inverseViewMatrix.lookAt(y,T,Q.DEFAULT_UP).setPosition(T)}}update(e,t,n){this._far=null!=this.maxFar?Math.min(this.maxFar,e.far*this.farScale):e.far*this.farScale,this.updateIntervals(e),this.updateMatrices(e,t,n);const r=this.cascades,i=this.cascadeCount;for(let a=0;a<i;++a){const{matrix:e,inverseMatrix:t,projectionMatrix:n,inverseProjectionMatrix:i,viewMatrix:o,inverseViewMatrix:s}=r[a];i.copy(n).invert(),o.copy(s).invert(),e.copy(n).multiply(o),t.copy(s).multiply(i)}}}const Rs=[0,8,2,10,12,4,14,6,3,11,1,9,15,7,13,5],Cs=Rs.reduce((e,t,n)=>{const r=new B;for(let i=0;i<16;++i)if(Rs[i]===n){r.set((i%4+.5)/4,(Math.floor(i/4)+.5)/4);break}return[...e,r]},[]),Ds={resolutionScale:1,lightShafts:!0,shapeDetail:!0,turbulence:!0,haze:!0,clouds:{multiScatteringOctaves:8,accurateSunSkyLight:!0,accuratePhaseFunction:!1,maxIterationCount:500,minStepSize:50,maxStepSize:1e3,maxRayDistance:2e5,perspectiveStepScale:1.01,minDensity:1e-5,minExtinction:1e-5,minTransmittance:.01,maxIterationCountToGround:3,maxIterationCountToSun:2,minSecondaryStepSize:100,secondaryStepScale:2,maxShadowLengthIterationCount:500,minShadowLengthStepSize:50,maxShadowLengthRayDistance:2e5},shadow:{cascadeCount:3,mapSize:new B(512,512),maxIterationCount:50,minStepSize:100,maxStepSize:1e3,minDensity:1e-5,minExtinction:1e-5,minTransmittance:1e-4}},Is={low:{...Ds,lightShafts:!1,shapeDetail:!1,turbulence:!1,clouds:{...Ds.clouds,accurateSunSkyLight:!1,maxIterationCount:200,minStepSize:100,maxRayDistance:1e5,minDensity:1e-4,minExtinction:1e-4,minTransmittance:.1,maxIterationCountToGround:0,maxIterationCountToSun:1},shadow:{...Ds.shadow,maxIterationCount:25,minDensity:1e-4,minExtinction:1e-4,minTransmittance:.01,cascadeCount:2,mapSize:new B(256,256)}},medium:{...Ds,lightShafts:!1,turbulence:!1,clouds:{...Ds.clouds,minDensity:1e-4,minExtinction:1e-4,accurateSunSkyLight:!1,maxIterationCountToSun:2,maxIterationCountToGround:1},shadow:{...Ds.shadow,minDensity:1e-4,minExtinction:1e-4,mapSize:new B(256,256)}},high:Ds,ultra:{...Ds,clouds:{...Ds.clouds,minStepSize:10},shadow:{...Ds.shadow,mapSize:new B(1024,1024)}}},Os="float getSTBN() {\n  ivec3 size = textureSize(stbnTexture, 0);\n  vec3 scale = 1.0 / vec3(size);\n  return texture(stbnTexture, vec3(gl_FragCoord.xy, float(frame % size.z)) * scale).r;\n}\n\n// Straightforward spherical mapping\nvec2 getSphericalUv(const vec3 position) {\n  vec2 st = normalize(position.yx);\n  float phi = atan(st.x, st.y);\n  float theta = asin(normalize(position).z);\n  return vec2(phi * RECIPROCAL_PI2 + 0.5, theta * RECIPROCAL_PI + 0.5);\n}\n\nvec2 getCubeSphereUv(const vec3 position) {\n  // Cube-sphere relaxation by: http://mathproofs.blogspot.com/2005/07/mapping-cube-to-sphere.html\n  // TODO: Tile and fix seams.\n  // Possible improvements:\n  // https://iquilezles.org/articles/texturerepetition/\n  // https://gamedev.stackexchange.com/questions/184388/fragment-shader-map-dot-texture-repeatedly-over-the-sphere\n  // https://github.com/mmikk/hextile-demo\n\n  vec3 n = normalize(position);\n  vec3 f = abs(n);\n  vec3 c = n / max(f.x, max(f.y, f.z));\n  vec2 m;\n  if (all(greaterThan(f.yy, f.xz))) {\n    m = c.y > 0.0 ? vec2(-n.x, n.z) : n.xz;\n  } else if (all(greaterThan(f.xx, f.yz))) {\n    m = c.x > 0.0 ? n.yz : vec2(-n.y, n.z);\n  } else {\n    m = c.z > 0.0 ? n.xy : vec2(n.x, -n.y);\n  }\n\n  vec2 m2 = m * m;\n  float q = dot(m2.xy, vec2(-2.0, 2.0)) - 3.0;\n  float q2 = q * q;\n  vec2 uv;\n  uv.x = sqrt(1.5 + m2.x - m2.y - 0.5 * sqrt(-24.0 * m2.x + q2)) * (m.x > 0.0 ? 1.0 : -1.0);\n  uv.y = sqrt(6.0 / (3.0 - uv.x * uv.x)) * m.y;\n  return uv * 0.5 + 0.5;\n}\n\nvec2 getGlobeUv(const vec3 position) {\n  return getCubeSphereUv(position);\n}\n\nfloat getMipLevel(const vec2 uv) {\n  const float mipLevelScale = 0.1;\n  vec2 coord = uv * resolution;\n  vec2 ddx = dFdx(coord);\n  vec2 ddy = dFdy(coord);\n  float deltaMaxSqr = max(dot(ddx, ddx), dot(ddy, ddy)) * mipLevelScale;\n  return max(0.0, 0.5 * log2(max(1.0, deltaMaxSqr)));\n}\n\nbool insideLayerIntervals(const float height) {\n  bvec3 gt = greaterThan(vec3(height), minIntervalHeights);\n  bvec3 lt = lessThan(vec3(height), maxIntervalHeights);\n  return any(bvec3(gt.x && lt.x, gt.y && lt.y, gt.z && lt.z));\n}\n\nstruct WeatherSample {\n  vec4 heightFraction; // Normalized height of each layer\n  vec4 density;\n};\n\nvec4 shapeAlteringFunction(const vec4 heightFraction, const vec4 bias) {\n  // Apply a semi-circle transform to round the clouds towards the top.\n  vec4 biased = pow(heightFraction, bias);\n  vec4 x = clamp(biased * 2.0 - 1.0, -1.0, 1.0);\n  return 1.0 - x * x;\n}\n\nWeatherSample sampleWeather(const vec2 uv, const float height, const float mipLevel) {\n  WeatherSample weather;\n  weather.heightFraction = remapClamped(vec4(height), minLayerHeights, maxLayerHeights);\n\n  vec4 localWeather = pow(\n    textureLod(\n      localWeatherTexture,\n      uv * localWeatherRepeat + localWeatherOffset,\n      mipLevel\n    ).LOCAL_WEATHER_CHANNELS,\n    weatherExponents\n  );\n  #ifdef SHADOW\n  localWeather *= shadowLayerMask;\n  #endif // SHADOW\n\n  vec4 heightScale = shapeAlteringFunction(weather.heightFraction, shapeAlteringBiases);\n\n  // Modulation to control weather by coverage parameter.\n  // Reference: https://github.com/Prograda/Skybolt/blob/master/Assets/Core/Shaders/Clouds.h#L63\n  vec4 factor = 1.0 - coverage * heightScale;\n  weather.density = remapClamped(\n    mix(localWeather, vec4(1.0), coverageFilterWidths),\n    factor,\n    factor + coverageFilterWidths\n  );\n\n  return weather;\n}\n\nvec4 getLayerDensity(const vec4 heightFraction) {\n  // prettier-ignore\n  return densityProfile.expTerms * exp(densityProfile.exponents * heightFraction) +\n    densityProfile.linearTerms * heightFraction +\n    densityProfile.constantTerms;\n}\n\nstruct MediaSample {\n  float density;\n  vec4 weight;\n  float scattering;\n  float extinction;\n};\n\nMediaSample sampleMedia(\n  const WeatherSample weather,\n  const vec3 position,\n  const vec2 uv,\n  const float mipLevel,\n  const float jitter,\n  out ivec3 sampleCount\n) {\n  vec4 density = weather.density;\n\n  // TODO: Define in physical length.\n  vec3 surfaceNormal = normalize(position);\n  float localWeatherSpeed = length(localWeatherOffset);\n  vec3 evolution = -surfaceNormal * localWeatherSpeed * 2e4;\n\n  vec3 turbulence = vec3(0.0);\n  #ifdef TURBULENCE\n  vec2 turbulenceUv = uv * localWeatherRepeat * turbulenceRepeat;\n  turbulence =\n    turbulenceDisplacement *\n    (texture(turbulenceTexture, turbulenceUv).rgb * 2.0 - 1.0) *\n    dot(density, remapClamped(weather.heightFraction, vec4(0.3), vec4(0.0)));\n  #endif // TURBULENCE\n\n  vec3 shapePosition = (position + evolution + turbulence) * shapeRepeat + shapeOffset;\n  float shape = texture(shapeTexture, shapePosition).r;\n  density = remapClamped(density, vec4(1.0 - shape) * shapeAmounts, vec4(1.0));\n\n  #ifdef DEBUG_SHOW_SAMPLE_COUNT\n  ++sampleCount.y;\n  #endif // DEBUG_SHOW_SAMPLE_COUNT\n\n  #ifdef SHAPE_DETAIL\n  if (mipLevel * 0.5 + (jitter - 0.5) * 0.5 < 0.5) {\n    vec3 detailPosition = (position + turbulence) * shapeDetailRepeat + shapeDetailOffset;\n    float detail = texture(shapeDetailTexture, detailPosition).r;\n    // Fluffy at the top and whippy at the bottom.\n    vec4 modifier = mix(\n      vec4(pow(detail, 6.0)),\n      vec4(1.0 - detail),\n      remapClamped(weather.heightFraction, vec4(0.2), vec4(0.4))\n    );\n    modifier = mix(vec4(0.0), modifier, shapeDetailAmounts);\n    density = remapClamped(density * 2.0, vec4(modifier * 0.5), vec4(1.0));\n\n    #ifdef DEBUG_SHOW_SAMPLE_COUNT\n    ++sampleCount.z;\n    #endif // DEBUG_SHOW_SAMPLE_COUNT\n  }\n  #endif // SHAPE_DETAIL\n\n  // Apply the density profiles.\n  density = saturate(density * densityScales * getLayerDensity(weather.heightFraction));\n\n  MediaSample media;\n  float densitySum = density.x + density.y + density.z + density.w;\n  media.weight = density / densitySum;\n  media.scattering = densitySum * scatteringCoefficient;\n  media.extinction = densitySum * absorptionCoefficient + media.scattering;\n  return media;\n}\n\nMediaSample sampleMedia(\n  const WeatherSample weather,\n  const vec3 position,\n  const vec2 uv,\n  const float mipLevel,\n  const float jitter\n) {\n  ivec3 sampleCount;\n  return sampleMedia(weather, position, uv, mipLevel, jitter, sampleCount);\n}\n",Ns="uniform vec2 resolution;\nuniform int frame;\nuniform sampler3D stbnTexture;\n\n// Atmosphere\nuniform float bottomRadius;\nuniform mat4 worldToECEFMatrix;\nuniform mat4 ecefToWorldMatrix;\nuniform vec3 altitudeCorrection;\nuniform vec3 sunDirection;\n\n// Participating medium\nuniform float scatteringCoefficient;\nuniform float absorptionCoefficient;\n\n// Primary raymarch\nuniform float minDensity;\nuniform float minExtinction;\nuniform float minTransmittance;\n\n// Shape and weather\nuniform sampler2D localWeatherTexture;\nuniform vec2 localWeatherRepeat;\nuniform vec2 localWeatherOffset;\nuniform float coverage;\nuniform sampler3D shapeTexture;\nuniform vec3 shapeRepeat;\nuniform vec3 shapeOffset;\n\n#ifdef SHAPE_DETAIL\nuniform sampler3D shapeDetailTexture;\nuniform vec3 shapeDetailRepeat;\nuniform vec3 shapeDetailOffset;\n#endif // SHAPE_DETAIL\n\n#ifdef TURBULENCE\nuniform sampler2D turbulenceTexture;\nuniform vec2 turbulenceRepeat;\nuniform float turbulenceDisplacement;\n#endif // TURBULENCE\n\n// Haze\n#ifdef HAZE\nuniform float hazeDensityScale;\nuniform float hazeExponent;\nuniform float hazeScatteringCoefficient;\nuniform float hazeAbsorptionCoefficient;\n#endif // HAZE\n\n// Cloud layers\nuniform vec4 minLayerHeights;\nuniform vec4 maxLayerHeights;\nuniform vec3 minIntervalHeights;\nuniform vec3 maxIntervalHeights;\nuniform vec4 densityScales;\nuniform vec4 shapeAmounts;\nuniform vec4 shapeDetailAmounts;\nuniform vec4 weatherExponents;\nuniform vec4 shapeAlteringBiases;\nuniform vec4 coverageFilterWidths;\nuniform float minHeight;\nuniform float maxHeight;\nuniform float shadowTopHeight;\nuniform float shadowBottomHeight;\nuniform vec4 shadowLayerMask;\nuniform CloudDensityProfile densityProfile;\n",bs="struct GroundIrradiance {\n  vec3 sun;\n  vec3 sky;\n};\n\nstruct CloudsIrradiance {\n  vec3 minSun;\n  vec3 minSky;\n  vec3 maxSun;\n  vec3 maxSky;\n};\n\nstruct CloudDensityProfile {\n  vec4 expTerms;\n  vec4 exponents;\n  vec4 linearTerms;\n  vec4 constantTerms;\n};\n";var Ps=Object.defineProperty,Ls=(e,t,n,r)=>{for(var i,a=void 0,o=e.length-1;o>=0;o--)(i=e[o])&&(a=i(t,n,a)||a);return a&&Ps(t,n,a),a};const Ms=new u,Us=new me;class Hs extends zi{constructor({parameterUniforms:e,layerUniforms:t,atmosphereUniforms:n},r=Ei.DEFAULT){super({name:"CloudsMaterial",glslVersion:k,vertexShader:Jr('precision highp float;\nprecision highp sampler3D;\n\n#include "atmosphere/bruneton/definitions"\n\nuniform AtmosphereParameters ATMOSPHERE;\nuniform vec3 SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;\nuniform vec3 SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;\n\nuniform sampler2D transmittance_texture;\nuniform sampler3D scattering_texture;\nuniform sampler2D irradiance_texture;\nuniform sampler3D single_mie_scattering_texture;\nuniform sampler3D higher_order_scattering_texture;\n\n#include "atmosphere/bruneton/common"\n#include "atmosphere/bruneton/runtime"\n\n#include "types"\n\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 inverseViewMatrix;\nuniform vec3 cameraPosition;\nuniform mat4 worldToECEFMatrix;\nuniform vec3 altitudeCorrection;\n\n// Atmosphere\nuniform float bottomRadius;\nuniform vec3 sunDirection;\n\n// Cloud layers\nuniform float minHeight;\nuniform float maxHeight;\n\nlayout(location = 0) in vec3 position;\n\nout vec2 vUv;\nout vec3 vCameraPosition;\nout vec3 vCameraDirection; // Direction to the center of screen\nout vec3 vRayDirection; // Direction to the texel\nout vec3 vViewPosition;\n\nout GroundIrradiance vGroundIrradiance;\nout CloudsIrradiance vCloudsIrradiance;\n\nvoid sampleSunSkyIrradiance(const vec3 positionECEF) {\n  vGroundIrradiance.sun = GetSunAndSkyScalarIrradiance(\n    positionECEF * METER_TO_LENGTH_UNIT,\n    sunDirection,\n    vGroundIrradiance.sky\n  );\n\n  vec3 surfaceNormal = normalize(positionECEF);\n  vec2 radii = (bottomRadius + vec2(minHeight, maxHeight)) * METER_TO_LENGTH_UNIT;\n  vCloudsIrradiance.minSun = GetSunAndSkyScalarIrradiance(\n    surfaceNormal * radii.x,\n    sunDirection,\n    vCloudsIrradiance.minSky\n  );\n  vCloudsIrradiance.maxSun = GetSunAndSkyScalarIrradiance(\n    surfaceNormal * radii.y,\n    sunDirection,\n    vCloudsIrradiance.maxSky\n  );\n}\n\nvoid main() {\n  vUv = position.xy * 0.5 + 0.5;\n\n  vec3 viewPosition = (inverseProjectionMatrix * vec4(position, 1.0)).xyz;\n  vec3 worldDirection = (inverseViewMatrix * vec4(viewPosition.xyz, 0.0)).xyz;\n  vec3 cameraDirection = normalize((inverseViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz);\n  vCameraPosition = (worldToECEFMatrix * vec4(cameraPosition, 1.0)).xyz;\n  vCameraDirection = (worldToECEFMatrix * vec4(cameraDirection, 0.0)).xyz;\n  vRayDirection = (worldToECEFMatrix * vec4(worldDirection, 0.0)).xyz;\n  vViewPosition = viewPosition;\n\n  sampleSunSkyIrradiance(vCameraPosition + altitudeCorrection);\n\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}\n',{atmosphere:{bruneton:{common:is,definitions:as,runtime:rs}},types:bs}),fragmentShader:ai(Jr('precision highp float;\nprecision highp sampler3D;\nprecision highp sampler2DArray;\n\n#include <common>\n#include <packing>\n\n#include "core/depth"\n#include "core/math"\n#include "core/turbo"\n#include "core/generators"\n#include "core/raySphereIntersection"\n#include "core/cascadedShadowMaps"\n#include "core/interleavedGradientNoise"\n#include "core/vogelDisk"\n\n#include "atmosphere/bruneton/definitions"\n\nuniform AtmosphereParameters ATMOSPHERE;\nuniform vec3 SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;\nuniform vec3 SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;\n\nuniform sampler2D transmittance_texture;\nuniform sampler3D scattering_texture;\nuniform sampler2D irradiance_texture;\nuniform sampler3D single_mie_scattering_texture;\nuniform sampler3D higher_order_scattering_texture;\n\n#include "atmosphere/bruneton/common"\n#include "atmosphere/bruneton/runtime"\n\n#include "types"\n#include "parameters"\n#include "clouds"\n\n#if !defined(RECIPROCAL_PI4)\n#define RECIPROCAL_PI4 0.07957747154594767\n#endif // !defined(RECIPROCAL_PI4)\n\nuniform sampler2D depthBuffer;\nuniform mat4 viewMatrix;\nuniform mat4 reprojectionMatrix;\nuniform mat4 viewReprojectionMatrix;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform float cameraHeight;\nuniform vec2 temporalJitter;\nuniform vec2 targetUvScale;\nuniform float mipLevelScale;\n\n// Scattering\nconst vec2 scatterAnisotropy = vec2(SCATTER_ANISOTROPY_1, SCATTER_ANISOTROPY_2);\nconst float scatterAnisotropyMix = SCATTER_ANISOTROPY_MIX;\nuniform float skyLightScale;\nuniform float groundBounceScale;\nuniform float powderScale;\nuniform float powderExponent;\n\n// Primary raymarch\nuniform int maxIterationCount;\nuniform float minStepSize;\nuniform float maxStepSize;\nuniform float maxRayDistance;\nuniform float perspectiveStepScale;\n\n// Secondary raymarch\nuniform int maxIterationCountToSun;\nuniform int maxIterationCountToGround;\nuniform float minSecondaryStepSize;\nuniform float secondaryStepScale;\n\n// Beer shadow map\nuniform sampler2DArray shadowBuffer;\nuniform vec2 shadowTexelSize;\nuniform vec2 shadowIntervals[SHADOW_CASCADE_COUNT];\nuniform mat4 shadowMatrices[SHADOW_CASCADE_COUNT];\nuniform float shadowFar;\nuniform float maxShadowFilterRadius;\n\n// Shadow length\n#ifdef SHADOW_LENGTH\nuniform int maxShadowLengthIterationCount;\nuniform float minShadowLengthStepSize;\nuniform float maxShadowLengthRayDistance;\n#endif // SHADOW_LENGTH\n\nin vec2 vUv;\nin vec3 vCameraPosition;\nin vec3 vCameraDirection; // Direction to the center of screen\nin vec3 vRayDirection; // Direction to the texel\nin vec3 vViewPosition;\nin GroundIrradiance vGroundIrradiance;\nin CloudsIrradiance vCloudsIrradiance;\n\nlayout(location = 0) out vec4 outputColor;\nlayout(location = 1) out vec3 outputDepthVelocity;\n#ifdef SHADOW_LENGTH\nlayout(location = 2) out float outputShadowLength;\n#endif // SHADOW_LENGTH\n\nfloat readDepth(const vec2 uv) {\n  #if DEPTH_PACKING == 3201\n  return unpackRGBAToDepth(texture(depthBuffer, uv));\n  #else // DEPTH_PACKING == 3201\n  return texture(depthBuffer, uv).r;\n  #endif // DEPTH_PACKING == 3201\n}\n\nfloat getViewZ(const float depth) {\n  #ifdef PERSPECTIVE_CAMERA\n  return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n  #else // PERSPECTIVE_CAMERA\n  return orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n  #endif // PERSPECTIVE_CAMERA\n}\n\nvec3 ecefToWorld(const vec3 positionECEF) {\n  return (ecefToWorldMatrix * vec4(positionECEF - altitudeCorrection, 1.0)).xyz;\n}\n\nvec2 getShadowUv(const vec3 worldPosition, const int cascadeIndex) {\n  vec4 clip = shadowMatrices[cascadeIndex] * vec4(worldPosition, 1.0);\n  clip /= clip.w;\n  return clip.xy * 0.5 + 0.5;\n}\n\nfloat getDistanceToShadowTop(const vec3 rayPosition) {\n  // Distance to the top of the shadows along the sun direction, which matches\n  // the ray origin of BSM.\n  return raySphereSecondIntersection(\n    rayPosition,\n    sunDirection,\n    vec3(0.0),\n    bottomRadius + shadowTopHeight\n  );\n}\n\n#ifdef DEBUG_SHOW_CASCADES\n\nconst vec3 cascadeColors[4] = vec3[4](\n  vec3(1.0, 0.0, 0.0),\n  vec3(0.0, 1.0, 0.0),\n  vec3(0.0, 0.0, 1.0),\n  vec3(1.0, 1.0, 0.0)\n);\n\nvec3 getCascadeColor(const vec3 rayPosition) {\n  vec3 worldPosition = ecefToWorld(rayPosition);\n  int cascadeIndex = getCascadeIndex(\n    viewMatrix,\n    worldPosition,\n    shadowIntervals,\n    cameraNear,\n    shadowFar\n  );\n  vec2 uv = getShadowUv(worldPosition, cascadeIndex);\n  if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n    return vec3(1.0);\n  }\n  return cascadeColors[cascadeIndex];\n}\n\nvec3 getFadedCascadeColor(const vec3 rayPosition, const float jitter) {\n  vec3 worldPosition = ecefToWorld(rayPosition);\n  int cascadeIndex = getFadedCascadeIndex(\n    viewMatrix,\n    worldPosition,\n    shadowIntervals,\n    cameraNear,\n    shadowFar,\n    jitter\n  );\n  return cascadeIndex >= 0\n    ? cascadeColors[cascadeIndex]\n    : vec3(1.0);\n}\n\n#endif // DEBUG_SHOW_CASCADES\n\nfloat readShadowOpticalDepth(\n  const vec2 uv,\n  const float distanceToTop,\n  const float distanceOffset,\n  const int cascadeIndex\n) {\n  // r: frontDepth, g: meanExtinction, b: maxOpticalDepth, a: maxOpticalDepthTail\n  // Also see the discussion here: https://x.com/shotamatsuda/status/1885322308908442106\n  vec4 shadow = texture(shadowBuffer, vec3(uv, float(cascadeIndex)));\n  float distanceToFront = max(0.0, distanceToTop - distanceOffset - shadow.r);\n  return min(shadow.b + shadow.a, shadow.g * distanceToFront);\n}\n\nfloat sampleShadowOpticalDepthPCF(\n  const vec3 worldPosition,\n  const float distanceToTop,\n  const float distanceOffset,\n  const float radius,\n  const int cascadeIndex\n) {\n  vec2 uv = getShadowUv(worldPosition, cascadeIndex);\n  if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n    return 0.0;\n  }\n  if (radius < 0.1) {\n    return readShadowOpticalDepth(uv, distanceToTop, distanceOffset, cascadeIndex);\n  }\n  float sum = 0.0;\n  vec2 offset;\n  #pragma unroll_loop_start\n  for (int i = 0; i < 16; ++i) {\n    #if UNROLLED_LOOP_INDEX < SHADOW_SAMPLE_COUNT\n    offset = vogelDisk(\n      UNROLLED_LOOP_INDEX,\n      SHADOW_SAMPLE_COUNT,\n      interleavedGradientNoise(gl_FragCoord.xy + temporalJitter * resolution) * PI2\n    );\n    sum += readShadowOpticalDepth(\n      uv + offset * radius * shadowTexelSize,\n      distanceToTop,\n      distanceOffset,\n      cascadeIndex\n    );\n    #endif // UNROLLED_LOOP_INDEX < SHADOW_SAMPLE_COUNT\n  }\n  #pragma unroll_loop_end\n  return sum / float(SHADOW_SAMPLE_COUNT);\n}\n\nfloat sampleShadowOpticalDepth(\n  const vec3 rayPosition,\n  const float distanceOffset,\n  const float radius,\n  const float jitter\n) {\n  float distanceToTop = getDistanceToShadowTop(rayPosition);\n  if (distanceToTop <= 0.0) {\n    return 0.0;\n  }\n  vec3 worldPosition = ecefToWorld(rayPosition);\n  int cascadeIndex = getFadedCascadeIndex(\n    viewMatrix,\n    worldPosition,\n    shadowIntervals,\n    cameraNear,\n    shadowFar,\n    jitter\n  );\n  return cascadeIndex >= 0\n    ? sampleShadowOpticalDepthPCF(\n      worldPosition,\n      distanceToTop,\n      distanceOffset,\n      radius,\n      cascadeIndex\n    )\n    : 0.0;\n}\n\n#ifdef DEBUG_SHOW_SHADOW_MAP\nvec4 getCascadedShadowMaps(vec2 uv) {\n  vec4 coord = vec4(vUv, vUv - 0.5) * 2.0;\n  vec4 shadow = vec4(0.0);\n  if (uv.y > 0.5) {\n    if (uv.x < 0.5) {\n      shadow = texture(shadowBuffer, vec3(coord.xw, 0.0));\n    } else {\n      #if SHADOW_CASCADE_COUNT > 1\n      shadow = texture(shadowBuffer, vec3(coord.zw, 1.0));\n      #endif // SHADOW_CASCADE_COUNT > 1\n    }\n  } else {\n    if (uv.x < 0.5) {\n      #if SHADOW_CASCADE_COUNT > 2\n      shadow = texture(shadowBuffer, vec3(coord.xy, 2.0));\n      #endif // SHADOW_CASCADE_COUNT > 2\n    } else {\n      #if SHADOW_CASCADE_COUNT > 3\n      shadow = texture(shadowBuffer, vec3(coord.zy, 3.0));\n      #endif // SHADOW_CASCADE_COUNT > 3\n    }\n  }\n\n  #if !defined(DEBUG_SHOW_SHADOW_MAP_TYPE)\n  #define DEBUG_SHOW_SHADOW_MAP_TYPE 0\n  #endif // !defined(DEBUG_SHOW_SHADOW_MAP_TYPE\n\n  const float frontDepthScale = 1e-5;\n  const float meanExtinctionScale = 10.0;\n  const float maxOpticalDepthScale = 0.01;\n  vec3 color;\n  #if DEBUG_SHOW_SHADOW_MAP_TYPE == 1\n  color = vec3(shadow.r * frontDepthScale);\n  #elif DEBUG_SHOW_SHADOW_MAP_TYPE == 2\n  color = vec3(shadow.g * meanExtinctionScale);\n  #elif DEBUG_SHOW_SHADOW_MAP_TYPE == 3\n  color = vec3((shadow.b + shadow.a) * maxOpticalDepthScale);\n  #else // DEBUG_SHOW_SHADOW_MAP_TYPE\n  color =\n    (shadow.rgb + vec3(0.0, 0.0, shadow.a)) *\n    vec3(frontDepthScale, meanExtinctionScale, maxOpticalDepthScale);\n  #endif // DEBUG_SHOW_SHADOW_MAP_TYPE\n  return vec4(color, 1.0);\n}\n#endif // DEBUG_SHOW_SHADOW_MAP\n\nvec2 henyeyGreenstein(const vec2 g, const float cosTheta) {\n  vec2 g2 = g * g;\n  // prettier-ignore\n  return RECIPROCAL_PI4 *\n    ((1.0 - g2) / max(vec2(1e-7), pow(1.0 + g2 - 2.0 * g * cosTheta, vec2(1.5))));\n}\n\n#ifdef ACCURATE_PHASE_FUNCTION\n\nfloat draine(float u, float g, float a) {\n  float g2 = g * g;\n  // prettier-ignore\n  return (1.0 - g2) *\n    (1.0 + a * u * u) /\n    (4.0 * (1.0 + a * (1.0 + 2.0 * g2) / 3.0) * PI * pow(1.0 + g2 - 2.0 * g * u, 1.5));\n}\n\n// Numerically-fitted large particles (d=10) phase function It won\'t be\n// plausible without a more precise multiple scattering.\n// Reference: https://research.nvidia.com/labs/rtr/approximate-mie/\nfloat phaseFunction(const float cosTheta, const float attenuation) {\n  const float gHG = 0.988176691700256; // exp(-0.0990567/(d-1.67154))\n  const float gD = 0.5556712547839497; // exp(-2.20679/(d+3.91029) - 0.428934)\n  const float alpha = 21.995520856274638; // exp(3.62489 - 8.29288/(d+5.52825))\n  const float weight = 0.4819554318404214; // exp(-0.599085/(d-0.641583)-0.665888)\n  return mix(\n    henyeyGreenstein(vec2(gHG) * attenuation, cosTheta).x,\n    draine(cosTheta, gD * attenuation, alpha),\n    weight\n  );\n}\n\n#else // ACCURATE_PHASE_FUNCTION\n\nfloat phaseFunction(const float cosTheta, const float attenuation) {\n  const vec2 g = scatterAnisotropy;\n  const vec2 weights = vec2(1.0 - scatterAnisotropyMix, scatterAnisotropyMix);\n  // A similar approximation is described in the Frostbite\'s paper, where phase\n  // angle is attenuated instead of anisotropy.\n  return dot(henyeyGreenstein(g * attenuation, cosTheta), weights);\n}\n\n#endif // ACCURATE_PHASE_FUNCTION\n\nfloat phaseFunction(const float cosTheta) {\n  return phaseFunction(cosTheta, 1.0);\n}\n\nfloat marchOpticalDepth(\n  const vec3 rayOrigin,\n  const vec3 rayDirection,\n  const int maxIterationCount,\n  const float mipLevel,\n  const float jitter,\n  out float rayDistance\n) {\n  int iterationCount = int(\n    max(0.0, remap(mipLevel, 0.0, 1.0, float(maxIterationCount + 1), 1.0) - jitter)\n  );\n  if (iterationCount == 0) {\n    // Fudge factor to approximate the mean optical depth.\n    // TODO: Remove it.\n    return 0.5;\n  }\n  float stepSize = minSecondaryStepSize / float(iterationCount);\n  float nextDistance = stepSize * jitter;\n  float opticalDepth = 0.0;\n  for (int i = 0; i < iterationCount; ++i) {\n    rayDistance = nextDistance;\n    vec3 position = rayDistance * rayDirection + rayOrigin;\n    vec2 uv = getGlobeUv(position);\n    float height = length(position) - bottomRadius;\n    WeatherSample weather = sampleWeather(uv, height, mipLevel);\n    MediaSample media = sampleMedia(weather, position, uv, mipLevel, jitter);\n    opticalDepth += media.extinction * stepSize;\n    nextDistance += stepSize;\n    stepSize *= secondaryStepScale;\n  }\n  return opticalDepth;\n}\n\nfloat marchOpticalDepth(\n  const vec3 rayOrigin,\n  const vec3 rayDirection,\n  const int maxIterationCount,\n  const float mipLevel,\n  const float jitter\n) {\n  float rayDistance;\n  return marchOpticalDepth(\n    rayOrigin,\n    rayDirection,\n    maxIterationCount,\n    mipLevel,\n    jitter,\n    rayDistance\n  );\n}\n\nfloat approximateMultipleScattering(const float opticalDepth, const float cosTheta) {\n  // Multiple scattering approximation\n  // See: https://fpsunflower.github.io/ckulla/data/oz_volumes.pdf\n  // a: attenuation, b: contribution, c: phase attenuation\n  vec3 coeffs = vec3(1.0); // [a, b, c]\n  const vec3 attenuation = vec3(0.5, 0.5, 0.5); // Should satisfy a <= b\n  float scattering = 0.0;\n  float beerLambert;\n  #pragma unroll_loop_start\n  for (int i = 0; i < 12; ++i) {\n    #if UNROLLED_LOOP_INDEX < MULTI_SCATTERING_OCTAVES\n    beerLambert = exp(-opticalDepth * coeffs.y);\n    scattering += coeffs.x * beerLambert * phaseFunction(cosTheta, coeffs.z);\n    coeffs *= attenuation;\n    #endif // UNROLLED_LOOP_INDEX < MULTI_SCATTERING_OCTAVES\n  }\n  #pragma unroll_loop_end\n  return scattering;\n}\n\n// TODO: Construct spherical harmonics of degree 2 using 2 sample points\n// positioned near the horizon occlusion points on the sun direction plane.\nvec3 getGroundSunSkyIrradiance(\n  const vec3 position,\n  const vec3 surfaceNormal,\n  const float height,\n  out vec3 skyIrradiance\n) {\n  #ifdef ACCURATE_SUN_SKY_LIGHT\n  return GetSunAndSkyIrradiance(\n    (position - surfaceNormal * height) * METER_TO_LENGTH_UNIT,\n    surfaceNormal,\n    sunDirection,\n    skyIrradiance\n  );\n  #else // ACCURATE_SUN_SKY_LIGHT\n  skyIrradiance = vGroundIrradiance.sky;\n  return vGroundIrradiance.sun;\n  #endif // ACCURATE_SUN_SKY_LIGHT\n}\n\nvec3 getCloudsSunSkyIrradiance(const vec3 position, const float height, out vec3 skyIrradiance) {\n  #ifdef ACCURATE_SUN_SKY_LIGHT\n  return GetSunAndSkyScalarIrradiance(position * METER_TO_LENGTH_UNIT, sunDirection, skyIrradiance);\n  #else // ACCURATE_SUN_SKY_LIGHT\n  float alpha = remapClamped(height, minHeight, maxHeight);\n  skyIrradiance = mix(vCloudsIrradiance.minSky, vCloudsIrradiance.maxSky, alpha);\n  return mix(vCloudsIrradiance.minSun, vCloudsIrradiance.maxSun, alpha);\n  #endif // ACCURATE_SUN_SKY_LIGHT\n}\n\n#ifdef GROUND_BOUNCE\nvec3 approximateRadianceFromGround(\n  const vec3 position,\n  const vec3 surfaceNormal,\n  const float height,\n  const float mipLevel,\n  const float jitter\n) {\n  float opticalDepthToGround = marchOpticalDepth(\n    position,\n    -surfaceNormal,\n    maxIterationCountToGround,\n    mipLevel,\n    jitter\n  );\n  vec3 skyIrradiance;\n  vec3 sunIrradiance = getGroundSunSkyIrradiance(position, surfaceNormal, height, skyIrradiance);\n  const float groundAlbedo = 0.3;\n  vec3 groundIrradiance = skyIrradiance + (1.0 - coverage) * sunIrradiance;\n  vec3 bouncedRadiance = groundAlbedo * RECIPROCAL_PI * groundIrradiance;\n  return bouncedRadiance * exp(-opticalDepthToGround);\n}\n#endif // GROUND_BOUNCE\n\nvec4 marchClouds(\n  const vec3 rayOrigin,\n  const vec3 rayDirection,\n  const vec2 rayNearFar,\n  const float cosTheta,\n  const float jitter,\n  const float rayStartTexelsPerPixel,\n  out float frontDepth,\n  out ivec3 sampleCount\n) {\n  vec3 radianceIntegral = vec3(0.0);\n  float transmittanceIntegral = 1.0;\n  float weightedDistanceSum = 0.0;\n  float transmittanceSum = 0.0;\n\n  float maxRayDistance = rayNearFar.y - rayNearFar.x;\n  float stepSize = minStepSize + (perspectiveStepScale - 1.0) * rayNearFar.x;\n  // I don\'t understand why spatial aliasing remains unless doubling the jitter.\n  float rayDistance = stepSize * jitter * 2.0;\n\n  for (int i = 0; i < maxIterationCount; ++i) {\n    if (rayDistance > maxRayDistance) {\n      break; // Termination\n    }\n\n    vec3 position = rayDistance * rayDirection + rayOrigin;\n    float height = length(position) - bottomRadius;\n    float mipLevel = log2(max(1.0, rayStartTexelsPerPixel + rayDistance * 1e-5));\n\n    #if !defined(DEBUG_MARCH_INTERVALS)\n    if (insideLayerIntervals(height)) {\n      stepSize *= perspectiveStepScale;\n      rayDistance += mix(stepSize, maxStepSize, min(1.0, mipLevel));\n      continue;\n    }\n    #endif // !defined(DEBUG_MARCH_INTERVALS)\n\n    // Sample rough weather.\n    vec2 uv = getGlobeUv(position);\n    WeatherSample weather = sampleWeather(uv, height, mipLevel);\n\n    #ifdef DEBUG_SHOW_SAMPLE_COUNT\n    ++sampleCount.x;\n    #endif // DEBUG_SHOW_SAMPLE_COUNT\n\n    if (!any(greaterThan(weather.density, vec4(minDensity)))) {\n      // Step longer in empty space.\n      // TODO: This produces banding artifacts.\n      // Possible improvement: Binary search refinement\n      stepSize *= perspectiveStepScale;\n      rayDistance += mix(stepSize, maxStepSize, min(1.0, mipLevel));\n      continue;\n    }\n\n    // Sample detailed participating media.\n    MediaSample media = sampleMedia(weather, position, uv, mipLevel, jitter, sampleCount);\n\n    if (media.extinction > minExtinction) {\n      vec3 skyIrradiance;\n      vec3 sunIrradiance = getCloudsSunSkyIrradiance(position, height, skyIrradiance);\n      vec3 surfaceNormal = normalize(position);\n\n      // March optical depth to the sun for finer details, which BSM lacks.\n      float sunRayDistance = 0.0;\n      float opticalDepth = marchOpticalDepth(\n        position,\n        sunDirection,\n        maxIterationCountToSun,\n        mipLevel,\n        jitter,\n        sunRayDistance\n      );\n\n      if (height < shadowTopHeight) {\n        // Obtain the optical depth from BSM at the ray position.\n        opticalDepth += sampleShadowOpticalDepth(\n          position,\n          // Take account of only positions further than the marched ray\n          // distance.\n          sunRayDistance,\n          // Apply PCF only when the sun is close to the horizon.\n          maxShadowFilterRadius * remapClamped(dot(sunDirection, surfaceNormal), 0.1, 0.0),\n          jitter\n        );\n      }\n\n      vec3 radiance = sunIrradiance * approximateMultipleScattering(opticalDepth, cosTheta);\n\n      #ifdef GROUND_BOUNCE\n      // Fudge factor for the irradiance from ground.\n      if (height < shadowTopHeight && mipLevel < 0.5) {\n        vec3 groundRadiance = approximateRadianceFromGround(\n          position,\n          surfaceNormal,\n          height,\n          mipLevel,\n          jitter\n        );\n        radiance += groundRadiance * RECIPROCAL_PI4 * groundBounceScale;\n      }\n      #endif // GROUND_BOUNCE\n\n      // Crude approximation of sky gradient. Better than none in the shadows.\n      float skyGradient = dot(weather.heightFraction * 0.5 + 0.5, media.weight);\n      radiance += skyIrradiance * RECIPROCAL_PI4 * skyGradient * skyLightScale;\n\n      // Finally multiply by scattering.\n      radiance *= media.scattering;\n\n      #ifdef POWDER\n      radiance *= 1.0 - powderScale * exp(-media.extinction * powderExponent);\n      #endif // POWDER\n\n      #ifdef DEBUG_SHOW_CASCADES\n      if (height < shadowTopHeight) {\n        radiance = 1e-3 * getFadedCascadeColor(position, jitter);\n      }\n      #endif // DEBUG_SHOW_CASCADES\n\n      // Energy-conserving analytical integration of scattered light\n      // See 5.6.3 in https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\n      float transmittance = exp(-media.extinction * stepSize);\n      float clampedExtinction = max(media.extinction, 1e-7);\n      vec3 scatteringIntegral = (radiance - radiance * transmittance) / clampedExtinction;\n      radianceIntegral += transmittanceIntegral * scatteringIntegral;\n      transmittanceIntegral *= transmittance;\n\n      // Aerial perspective affecting clouds\n      // See 5.9.1 in https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\n      weightedDistanceSum += rayDistance * transmittanceIntegral;\n      transmittanceSum += transmittanceIntegral;\n    }\n\n    if (transmittanceIntegral <= minTransmittance) {\n      break; // Early termination\n    }\n\n    // Take a shorter step because we\'ve already hit the clouds.\n    stepSize *= perspectiveStepScale;\n    rayDistance += stepSize;\n  }\n\n  // The final product of 5.9.1 and we\'ll evaluate this in aerial perspective.\n  frontDepth = transmittanceSum > 0.0 ? weightedDistanceSum / transmittanceSum : -1.0;\n\n  return vec4(radianceIntegral, remapClamped(transmittanceIntegral, 1.0, minTransmittance));\n}\n\n#ifdef SHADOW_LENGTH\n\nfloat marchShadowLength(\n  const vec3 rayOrigin,\n  const vec3 rayDirection,\n  const vec2 rayNearFar,\n  const float jitter\n) {\n  float shadowLength = 0.0;\n  float maxRayDistance = rayNearFar.y - rayNearFar.x;\n  float stepSize = minShadowLengthStepSize;\n  float rayDistance = stepSize * jitter;\n  const float attenuationFactor = 1.0 - 5e-4;\n  float attenuation = 1.0;\n\n  // TODO: This march is closed, and sample resolution can be much lower.\n  // Refining the termination by binary search will make it much more efficient.\n  for (int i = 0; i < maxShadowLengthIterationCount; ++i) {\n    if (rayDistance > maxRayDistance) {\n      break; // Termination\n    }\n    vec3 position = rayDistance * rayDirection + rayOrigin;\n    float opticalDepth = sampleShadowOpticalDepth(position, 0.0, 0.0, jitter);\n    shadowLength += (1.0 - exp(-opticalDepth)) * stepSize * attenuation;\n    stepSize *= perspectiveStepScale;\n    rayDistance += stepSize;\n  }\n  return shadowLength;\n}\n\n#endif // SHADOW_LENGTH\n\n#ifdef HAZE\n\nvec4 approximateHaze(\n  const vec3 rayOrigin,\n  const vec3 rayDirection,\n  const float maxRayDistance,\n  const float cosTheta,\n  const float shadowLength\n) {\n  float modulation = remapClamped(coverage, 0.2, 0.4);\n  if (cameraHeight * modulation < 0.0) {\n    return vec4(0.0);\n  }\n  float density = modulation * hazeDensityScale * exp(-cameraHeight * hazeExponent);\n  if (density < 1e-7) {\n    return vec4(0.0); // Prevent artifact in views from space\n  }\n\n  // Blend two normals by the difference in angle so that normal near the\n  // ground becomes that of the origin, and in the sky that of the horizon.\n  vec3 normalAtOrigin = normalize(rayOrigin);\n  vec3 normalAtHorizon = (rayOrigin - dot(rayOrigin, rayDirection) * rayDirection) / bottomRadius;\n  float alpha = remapClamped(dot(normalAtOrigin, normalAtHorizon), 0.9, 1.0);\n  vec3 normal = mix(normalAtOrigin, normalAtHorizon, alpha);\n\n  // Analytical optical depth where density exponentially decreases with height.\n  // Based on: https://iquilezles.org/articles/fog/\n  float angle = max(dot(normal, rayDirection), 1e-5);\n  float exponent = angle * hazeExponent;\n  float linearTerm = density / hazeExponent / angle;\n\n  // Derive the optical depths separately for with and without shadow length.\n  float expTerm = 1.0 - exp(-maxRayDistance * exponent);\n  float shadowExpTerm = 1.0 - exp(-min(maxRayDistance, shadowLength) * exponent);\n  float opticalDepth = expTerm * linearTerm;\n  float shadowOpticalDepth = max((expTerm - shadowExpTerm) * linearTerm, 0.0);\n  float transmittance = saturate(1.0 - exp(-opticalDepth));\n  float shadowTransmittance = saturate(1.0 - exp(-shadowOpticalDepth));\n\n  vec3 skyIrradiance = vGroundIrradiance.sky;\n  vec3 sunIrradiance = vGroundIrradiance.sun;\n  vec3 inscatter = sunIrradiance * phaseFunction(cosTheta) * shadowTransmittance;\n  inscatter += skyIrradiance * RECIPROCAL_PI4 * skyLightScale * transmittance;\n  inscatter *= hazeScatteringCoefficient / (hazeAbsorptionCoefficient + hazeScatteringCoefficient);\n  return vec4(inscatter, transmittance);\n}\n\n#endif // HAZE\n\nvoid applyAerialPerspective(\n  const vec3 cameraPosition,\n  const vec3 frontPosition,\n  const float shadowLength,\n  inout vec4 color\n) {\n  vec3 transmittance;\n  vec3 inscatter = GetSkyRadianceToPoint(\n    cameraPosition * METER_TO_LENGTH_UNIT,\n    frontPosition * METER_TO_LENGTH_UNIT,\n    shadowLength * METER_TO_LENGTH_UNIT,\n    sunDirection,\n    transmittance\n  );\n  color.rgb = color.rgb * transmittance + inscatter * color.a;\n}\n\nbool rayIntersectsGround(const vec3 cameraPosition, const vec3 rayDirection) {\n  float r = length(cameraPosition);\n  float mu = dot(cameraPosition, rayDirection) / r;\n  return mu < 0.0 && r * r * (mu * mu - 1.0) + bottomRadius * bottomRadius >= 0.0;\n}\n\nstruct IntersectionResult {\n  bool ground;\n  vec4 first;\n  vec4 second;\n};\n\nIntersectionResult getIntersections(const vec3 cameraPosition, const vec3 rayDirection) {\n  IntersectionResult intersections;\n  intersections.ground = rayIntersectsGround(cameraPosition, rayDirection);\n  raySphereIntersections(\n    cameraPosition,\n    rayDirection,\n    bottomRadius + vec4(0.0, minHeight, maxHeight, shadowTopHeight),\n    intersections.first,\n    intersections.second\n  );\n  return intersections;\n}\n\nvec2 getRayNearFar(const IntersectionResult intersections) {\n  vec2 nearFar;\n  if (cameraHeight < minHeight) {\n    // View below the clouds\n    if (intersections.ground) {\n      nearFar = vec2(-1.0); // No clouds to the ground\n    } else {\n      nearFar = vec2(intersections.second.y, intersections.second.z);\n      nearFar.y = min(nearFar.y, maxRayDistance);\n    }\n  } else if (cameraHeight < maxHeight) {\n    // View inside the total cloud layer\n    if (intersections.ground) {\n      nearFar = vec2(cameraNear, intersections.first.y);\n    } else {\n      nearFar = vec2(cameraNear, intersections.second.z);\n    }\n  } else {\n    // View above the clouds\n    nearFar = vec2(intersections.first.z, intersections.second.z);\n    if (intersections.ground) {\n      // Clamp the ray at the min height.\n      nearFar.y = intersections.first.y;\n    }\n  }\n  return nearFar;\n}\n\n#ifdef SHADOW_LENGTH\nvec2 getShadowRayNearFar(const IntersectionResult intersections) {\n  vec2 nearFar;\n  if (cameraHeight < shadowTopHeight) {\n    if (intersections.ground) {\n      nearFar = vec2(cameraNear, intersections.first.x);\n    } else {\n      nearFar = vec2(cameraNear, intersections.second.w);\n    }\n  } else {\n    nearFar = vec2(intersections.first.w, intersections.second.w);\n    if (intersections.ground) {\n      // Clamp the ray at the ground.\n      nearFar.y = intersections.first.x;\n    }\n  }\n  nearFar.y = min(nearFar.y, maxShadowLengthRayDistance);\n  return nearFar;\n}\n#endif // SHADOW_LENGTH\n\n#ifdef HAZE\nvec2 getHazeRayNearFar(const IntersectionResult intersections) {\n  vec2 nearFar;\n  if (cameraHeight < maxHeight) {\n    if (intersections.ground) {\n      nearFar = vec2(cameraNear, intersections.first.x);\n    } else {\n      nearFar = vec2(cameraNear, intersections.second.z);\n    }\n  } else {\n    nearFar = vec2(cameraNear, intersections.second.z);\n    if (intersections.ground) {\n      // Clamp the ray at the ground.\n      nearFar.y = intersections.first.x;\n    }\n  }\n  return nearFar;\n}\n#endif // HAZE\n\nfloat getRayDistanceToScene(const vec3 rayDirection, out float viewZ) {\n  float depth = readDepth(vUv * targetUvScale + temporalJitter);\n  if (depth < 1.0 - 1e-7) {\n    depth = reverseLogDepth(depth, cameraNear, cameraFar);\n    viewZ = getViewZ(depth);\n    return -viewZ / dot(rayDirection, vCameraDirection);\n  }\n  viewZ = 0.0;\n  return 0.0;\n}\n\nvoid main() {\n  #ifdef DEBUG_SHOW_SHADOW_MAP\n  outputColor = getCascadedShadowMaps(vUv);\n  outputDepthVelocity = vec3(0.0);\n  #ifdef SHADOW_LENGTH\n  outputShadowLength = 0.0;\n  #endif // SHADOW_LENGTH\n  return;\n  #endif // DEBUG_SHOW_SHADOW_MAP\n\n  vec3 cameraPosition = vCameraPosition + altitudeCorrection;\n  vec3 rayDirection = normalize(vRayDirection);\n  float cosTheta = dot(sunDirection, rayDirection);\n\n  IntersectionResult intersections = getIntersections(cameraPosition, rayDirection);\n  vec2 rayNearFar = getRayNearFar(intersections);\n  #ifdef SHADOW_LENGTH\n  vec2 shadowRayNearFar = getShadowRayNearFar(intersections);\n  #endif // SHADOW_LENGTH\n  #ifdef HAZE\n  vec2 hazeRayNearFar = getHazeRayNearFar(intersections);\n  #endif // HAZE\n\n  float sceneViewZ;\n  float rayDistanceToScene = getRayDistanceToScene(rayDirection, sceneViewZ);\n  if (rayDistanceToScene > 0.0) {\n    rayNearFar.y = min(rayNearFar.y, rayDistanceToScene);\n    #ifdef SHADOW_LENGTH\n    shadowRayNearFar.y = min(shadowRayNearFar.y, rayDistanceToScene);\n    #endif // SHADOW_LENGTH\n    #ifdef HAZE\n    hazeRayNearFar.y = min(hazeRayNearFar.y, rayDistanceToScene);\n    #endif // HAZE\n  }\n\n  bool intersectsGround = any(lessThan(rayNearFar, vec2(0.0)));\n  bool intersectsScene = rayNearFar.y < rayNearFar.x;\n\n  float stbn = getSTBN();\n\n  vec4 color = vec4(0.0);\n  float frontDepth = rayNearFar.y;\n  vec3 depthVelocity = vec3(0.0);\n  float shadowLength = 0.0;\n  bool hitClouds = false;\n\n  if (!intersectsGround && !intersectsScene) {\n    vec3 rayOrigin = rayNearFar.x * rayDirection + cameraPosition;\n\n    vec2 globeUv = getGlobeUv(rayOrigin);\n    #ifdef DEBUG_SHOW_UV\n    outputColor = vec4(vec3(checker(globeUv, localWeatherRepeat + localWeatherOffset)), 1.0);\n    outputDepthVelocity = vec3(0.0);\n    #ifdef SHADOW_LENGTH\n    outputShadowLength = 0.0;\n    #endif // SHADOW_LENGTH\n    return;\n    #endif // DEBUG_SHOW_UV\n\n    float mipLevel = getMipLevel(globeUv * localWeatherRepeat) * mipLevelScale;\n    mipLevel = mix(0.0, mipLevel, min(1.0, 0.2 * cameraHeight / maxHeight));\n\n    float marchedFrontDepth;\n    ivec3 sampleCount = ivec3(0);\n    color = marchClouds(\n      rayOrigin,\n      rayDirection,\n      rayNearFar,\n      cosTheta,\n      stbn,\n      pow(2.0, mipLevel),\n      marchedFrontDepth,\n      sampleCount\n    );\n\n    #ifdef DEBUG_SHOW_SAMPLE_COUNT\n    outputColor = vec4(vec3(sampleCount) / vec3(500.0, 5.0, 5.0), 1.0);\n    outputDepthVelocity = vec3(0.0);\n    #ifdef SHADOW_LENGTH\n    outputShadowLength = 0.0;\n    #endif // SHADOW_LENGTH\n    return;\n    #endif // DEBUG_SHOW_SAMPLE_COUNT\n\n    // Front depth will be -1.0 when no samples are accumulated.\n    hitClouds = marchedFrontDepth >= 0.0;\n    if (hitClouds) {\n      frontDepth = rayNearFar.x + marchedFrontDepth;\n\n      #ifdef SHADOW_LENGTH\n      // Clamp the shadow length ray at the clouds.\n      shadowRayNearFar.y = mix(\n        shadowRayNearFar.y,\n        min(frontDepth, shadowRayNearFar.y),\n        color.a // Interpolate by the alpha for smoother edges.\n      );\n\n      // Shadow length must be computed before applying aerial perspective.\n      if (all(greaterThanEqual(shadowRayNearFar, vec2(0.0)))) {\n        shadowLength = marchShadowLength(\n          shadowRayNearFar.x * rayDirection + cameraPosition,\n          rayDirection,\n          shadowRayNearFar,\n          stbn\n        );\n      }\n      #endif // SHADOW_LENGTH\n\n      #ifdef HAZE\n      // Clamp the haze ray at the clouds.\n      hazeRayNearFar.y = mix(\n        hazeRayNearFar.y,\n        min(frontDepth, hazeRayNearFar.y),\n        color.a // Interpolate by the alpha for smoother edges.\n      );\n      #endif // HAZE\n\n      // Apply aerial perspective.\n      vec3 frontPosition = cameraPosition + frontDepth * rayDirection;\n      applyAerialPerspective(cameraPosition, frontPosition, shadowLength, color);\n\n      // Velocity for temporal resolution.\n      vec3 frontPositionWorld = ecefToWorld(frontPosition);\n      vec4 prevClip = reprojectionMatrix * vec4(frontPositionWorld, 1.0);\n      prevClip /= prevClip.w;\n      vec2 prevUv = prevClip.xy * 0.5 + 0.5;\n      vec2 velocity = vUv - prevUv;\n      depthVelocity = vec3(frontDepth, velocity);\n    }\n  }\n\n  if (!hitClouds) {\n    #ifdef SHADOW_LENGTH\n    if (all(greaterThanEqual(shadowRayNearFar, vec2(0.0)))) {\n      shadowLength = marchShadowLength(\n        shadowRayNearFar.x * rayDirection + cameraPosition,\n        rayDirection,\n        shadowRayNearFar,\n        stbn\n      );\n    }\n    #endif // SHADOW_LENGTH\n\n    // Velocity for temporal resolution. Here reproject in the view space for\n    // greatly reducing the precision errors.\n    frontDepth = sceneViewZ < 0.0 ? -sceneViewZ : cameraFar;\n    vec3 frontView = vViewPosition * frontDepth;\n    vec4 prevClip = viewReprojectionMatrix * vec4(frontView, 1.0);\n    prevClip /= prevClip.w;\n    vec2 prevUv = prevClip.xy * 0.5 + 0.5;\n    vec2 velocity = vUv - prevUv;\n    depthVelocity = vec3(frontDepth, velocity);\n  }\n\n  #ifdef DEBUG_SHOW_FRONT_DEPTH\n  outputColor = vec4(turbo(frontDepth / maxRayDistance), 1.0);\n  outputDepthVelocity = vec3(0.0);\n  #ifdef SHADOW_LENGTH\n  outputShadowLength = 0.0;\n  #endif // SHADOW_LENGTH\n  return;\n  #endif // DEBUG_SHOW_FRONT_DEPTH\n\n  #ifdef HAZE\n  vec4 haze = approximateHaze(\n    cameraNear * rayDirection + cameraPosition,\n    rayDirection,\n    hazeRayNearFar.y - hazeRayNearFar.x,\n    cosTheta,\n    shadowLength\n  );\n  color.rgb = mix(color.rgb, haze.rgb, haze.a);\n  color.a = color.a * (1.0 - haze.a) + haze.a;\n  #endif // HAZE\n\n  outputColor = color;\n  outputDepthVelocity = depthVelocity;\n  #ifdef SHADOW_LENGTH\n  outputShadowLength = shadowLength * METER_TO_LENGTH_UNIT;\n  #endif // SHADOW_LENGTH\n}\n',{core:{depth:si,math:ui,turbo:mi,generators:"float checker(const vec2 uv, const vec2 repeats) {\n  vec2 c = floor(repeats * uv);\n  float result = mod(c.x + c.y, 2.0);\n  return sign(result);\n}\n\nfloat checker(const vec2 uv, const float repeats) {\n  return checker(uv, vec2(repeats));\n}\n",raySphereIntersection:hi,cascadedShadowMaps:oi,interleavedGradientNoise:ci,vogelDisk:pi},atmosphere:{bruneton:{common:is,definitions:as,runtime:rs}},types:bs,parameters:Ns,clouds:Os})),uniforms:{...e,...t,...n,depthBuffer:new G(null),viewMatrix:new G(new l),inverseProjectionMatrix:new G(new l),inverseViewMatrix:new G(new l),reprojectionMatrix:new G(new l),viewReprojectionMatrix:new G(new l),resolution:new G(new B),cameraNear:new G(0),cameraFar:new G(0),cameraHeight:new G(0),frame:new G(0),temporalJitter:new G(new B),targetUvScale:new G(new B),mipLevelScale:new G(1),stbnTexture:new G(null),skyLightScale:new G(1),groundBounceScale:new G(1),powderScale:new G(.8),powderExponent:new G(150),maxIterationCount:new G(Ds.clouds.maxIterationCount),minStepSize:new G(Ds.clouds.minStepSize),maxStepSize:new G(Ds.clouds.maxStepSize),maxRayDistance:new G(Ds.clouds.maxRayDistance),perspectiveStepScale:new G(Ds.clouds.perspectiveStepScale),minDensity:new G(Ds.clouds.minDensity),minExtinction:new G(Ds.clouds.minExtinction),minTransmittance:new G(Ds.clouds.minTransmittance),maxIterationCountToSun:new G(Ds.clouds.maxIterationCountToSun),maxIterationCountToGround:new G(Ds.clouds.maxIterationCountToGround),minSecondaryStepSize:new G(Ds.clouds.minSecondaryStepSize),secondaryStepScale:new G(Ds.clouds.secondaryStepScale),shadowBuffer:new G(null),shadowTexelSize:new G(new B),shadowIntervals:new G(Array.from({length:4},()=>new B)),shadowMatrices:new G(Array.from({length:4},()=>new l)),shadowFar:new G(0),maxShadowFilterRadius:new G(6),shadowLayerMask:new G((new ee).setScalar(1)),maxShadowLengthIterationCount:new G(Ds.clouds.maxShadowLengthIterationCount),minShadowLengthStepSize:new G(Ds.clouds.minShadowLengthStepSize),maxShadowLengthRayDistance:new G(Ds.clouds.maxShadowLengthRayDistance),hazeDensityScale:new G(3e-5),hazeExponent:new G(.001),hazeScatteringCoefficient:new G(.9),hazeAbsorptionCoefficient:new G(.5)}},r),this.temporalUpscale=!0,this.depthPacking=0,this.localWeatherChannels="rgba",this.shapeDetail=Ds.shapeDetail,this.turbulence=Ds.turbulence,this.shadowLength=Ds.lightShafts,this.haze=Ds.haze,this.multiScatteringOctaves=Ds.clouds.multiScatteringOctaves,this.accurateSunSkyLight=Ds.clouds.accurateSunSkyLight,this.accuratePhaseFunction=Ds.clouds.accuratePhaseFunction,this.shadowCascadeCount=Ds.shadow.cascadeCount,this.shadowSampleCount=8,this.scatterAnisotropy1=.7,this.scatterAnisotropy2=-.2,this.scatterAnisotropyMix=.5}onBeforeRender(e,t,n,r,i,a){const o=null!=this.defines.USE_LOGDEPTHBUF,s=e.capabilities.logarithmicDepthBuffer;s!==o&&(s?this.defines.USE_LOGDEPTHBUF="1":delete this.defines.USE_LOGDEPTHBUF);const c=null!=this.defines.POWDER,u=this.uniforms.powderScale.value>0;u!==c&&(u?this.defines.POWDER="1":delete this.defines.POWDER,this.needsUpdate=!0);const l=null!=this.defines.GROUND_BOUNCE;(this.uniforms.groundBounceScale.value>0&&this.uniforms.maxIterationCountToGround.value>0)!==l&&(u?this.defines.GROUND_BOUNCE="1":delete this.defines.GROUND_BOUNCE,this.needsUpdate=!0)}copyCameraSettings(e){!0===e.isPerspectiveCamera?"1"!==this.defines.PERSPECTIVE_CAMERA&&(this.defines.PERSPECTIVE_CAMERA="1",this.needsUpdate=!0):null!=this.defines.PERSPECTIVE_CAMERA&&(delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0);const t=this.uniforms;t.viewMatrix.value.copy(e.matrixWorldInverse),t.inverseViewMatrix.value.copy(e.matrixWorld);const n=this.previousProjectionMatrix??e.projectionMatrix,r=this.previousViewMatrix??e.matrixWorldInverse,i=t.inverseProjectionMatrix.value,a=t.inverseViewMatrix.value,o=t.reprojectionMatrix.value,s=t.viewReprojectionMatrix.value;if(this.temporalUpscale){const c=t.frame.value%16,u=t.resolution.value,l=Cs[c],h=(l.x-.5)/u.x*4,d=(l.y-.5)/u.y*4;t.temporalJitter.value.set(h,d),t.mipLevelScale.value=.25,i.copy(e.projectionMatrix),i.elements[8]+=2*h,i.elements[9]+=2*d,i.invert(),o.copy(n),o.elements[8]+=2*h,o.elements[9]+=2*d,o.multiply(r),s.copy(o).multiply(a)}else t.temporalJitter.value.setScalar(0),t.mipLevelScale.value=1,i.copy(e.projectionMatrixInverse),o.copy(n).multiply(r),s.copy(o).multiply(a);t.cameraNear.value=e.near,t.cameraFar.value=e.far;const c=e.getWorldPosition(t.cameraPosition.value),u=Ms.copy(c).applyMatrix4(t.worldToECEFMatrix.value);try{t.cameraHeight.value=Us.setFromECEF(u).height}catch{}}copyReprojectionMatrix(e){this.previousProjectionMatrix??(this.previousProjectionMatrix=new l),this.previousViewMatrix??(this.previousViewMatrix=new l),this.previousProjectionMatrix.copy(e.projectionMatrix),this.previousViewMatrix.copy(e.matrixWorldInverse)}setSize(e,t,n,r){this.uniforms.resolution.value.set(e,t),null!=n&&null!=r?this.uniforms.targetUvScale.value.set(e/n,t/r):this.uniforms.targetUvScale.value.setScalar(1),this.previousProjectionMatrix=void 0,this.previousViewMatrix=void 0}setShadowSize(e,t){this.uniforms.shadowTexelSize.value.set(1/e,1/t)}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(e){this.uniforms.depthBuffer.value=e}get accurateSunSkyIrradiance(){return this.accurateSunSkyLight}set accurateSunSkyIrradiance(e){this.accurateSunSkyLight=e}}Ls([nr("DEPTH_PACKING")],Hs.prototype,"depthPacking"),Ls([ir("LOCAL_WEATHER_CHANNELS",{validate:e=>/^[rgba]{4}$/.test(e)})],Hs.prototype,"localWeatherChannels"),Ls([tr("SHAPE_DETAIL")],Hs.prototype,"shapeDetail"),Ls([tr("TURBULENCE")],Hs.prototype,"turbulence"),Ls([tr("SHADOW_LENGTH")],Hs.prototype,"shadowLength"),Ls([tr("HAZE")],Hs.prototype,"haze"),Ls([nr("MULTI_SCATTERING_OCTAVES",{min:1,max:12})],Hs.prototype,"multiScatteringOctaves"),Ls([tr("ACCURATE_SUN_SKY_LIGHT")],Hs.prototype,"accurateSunSkyLight"),Ls([tr("ACCURATE_PHASE_FUNCTION")],Hs.prototype,"accuratePhaseFunction"),Ls([nr("SHADOW_CASCADE_COUNT",{min:1,max:4})],Hs.prototype,"shadowCascadeCount"),Ls([nr("SHADOW_SAMPLE_COUNT",{min:1,max:16})],Hs.prototype,"shadowSampleCount"),Ls([rr("SCATTER_ANISOTROPY_1")],Hs.prototype,"scatterAnisotropy1"),Ls([rr("SCATTER_ANISOTROPY_2")],Hs.prototype,"scatterAnisotropy2"),Ls([rr("SCATTER_ANISOTROPY_MIX")],Hs.prototype,"scatterAnisotropyMix");const Fs="#ifdef VARIANCE_9_SAMPLES\n#define VARIANCE_OFFSET_COUNT 8\nconst ivec2 varianceOffsets[8] = ivec2[8](\n  ivec2(-1, -1),\n  ivec2(-1, 1),\n  ivec2(1, -1),\n  ivec2(1, 1),\n  ivec2(1, 0),\n  ivec2(0, -1),\n  ivec2(0, 1),\n  ivec2(-1, 0)\n);\n#else // VARIANCE_9_SAMPLES\n#define VARIANCE_OFFSET_COUNT 4\nconst ivec2 varianceOffsets[4] = ivec2[4](ivec2(1, 0), ivec2(0, -1), ivec2(0, 1), ivec2(-1, 0));\n#endif // VARIANCE_9_SAMPLES\n\n// Reference: https://github.com/playdeadgames/temporal\nvec4 clipAABB(const vec4 current, const vec4 history, const vec4 minColor, const vec4 maxColor) {\n  vec3 pClip = 0.5 * (maxColor.rgb + minColor.rgb);\n  vec3 eClip = 0.5 * (maxColor.rgb - minColor.rgb) + 1e-7;\n  vec4 vClip = history - vec4(pClip, current.a);\n  vec3 vUnit = vClip.xyz / eClip;\n  vec3 aUnit = abs(vUnit);\n  float maUnit = max(aUnit.x, max(aUnit.y, aUnit.z));\n  if (maUnit > 1.0) {\n    return vec4(pClip, current.a) + vClip / maUnit;\n  }\n  return history;\n}\n\n#ifdef VARIANCE_SAMPLER_ARRAY\n#define VARIANCE_SAMPLER sampler2DArray\n#define VARIANCE_SAMPLER_COORD ivec3\n#else // VARIANCE_SAMPLER_ARRAY\n#define VARIANCE_SAMPLER sampler2D\n#define VARIANCE_SAMPLER_COORD ivec2\n#endif // VARIANCE_SAMPLER_ARRAY\n\n// Variance clipping\n// Reference: https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf\nvec4 varianceClipping(\n  const VARIANCE_SAMPLER inputBuffer,\n  const VARIANCE_SAMPLER_COORD coord,\n  const vec4 current,\n  const vec4 history,\n  const float gamma\n) {\n  vec4 moment1 = current;\n  vec4 moment2 = current * current;\n  vec4 neighbor;\n  #pragma unroll_loop_start\n  for (int i = 0; i < 8; ++i) {\n    #if UNROLLED_LOOP_INDEX < VARIANCE_OFFSET_COUNT\n    neighbor = texelFetchOffset(inputBuffer, coord, 0, varianceOffsets[i]);\n    moment1 += neighbor;\n    moment2 += neighbor * neighbor;\n    #endif // UNROLLED_LOOP_INDEX < VARIANCE_OFFSET_COUNT\n  }\n  #pragma unroll_loop_end\n\n  const float N = float(VARIANCE_OFFSET_COUNT + 1);\n  vec4 mean = moment1 / N;\n  vec4 varianceGamma = sqrt(max(moment2 / N - mean * mean, 0.0)) * gamma;\n  vec4 minColor = mean - varianceGamma;\n  vec4 maxColor = mean + varianceGamma;\n  return clipAABB(clamp(mean, minColor, maxColor), history, minColor, maxColor);\n}\n\nvec4 varianceClipping(\n  const VARIANCE_SAMPLER inputBuffer,\n  const VARIANCE_SAMPLER_COORD coord,\n  const vec4 current,\n  const vec4 history\n) {\n  return varianceClipping(inputBuffer, coord, current, history, 1.0);\n}\n\nvec4 varianceClipping(\n  const sampler2D inputBuffer,\n  const vec2 coord,\n  const vec4 current,\n  const vec4 history,\n  const float gamma\n) {\n  vec4 moment1 = current;\n  vec4 moment2 = current * current;\n  vec4 neighbor;\n  #pragma unroll_loop_start\n  for (int i = 0; i < 8; ++i) {\n    #if UNROLLED_LOOP_INDEX < VARIANCE_OFFSET_COUNT\n    neighbor = textureOffset(inputBuffer, coord, varianceOffsets[i]);\n    moment1 += neighbor;\n    moment2 += neighbor * neighbor;\n    #endif // UNROLLED_LOOP_INDEX < VARIANCE_OFFSET_COUNT\n  }\n  #pragma unroll_loop_end\n\n  const float N = float(VARIANCE_OFFSET_COUNT + 1);\n  vec4 mean = moment1 / N;\n  vec4 varianceGamma = sqrt(max(moment2 / N - mean * mean, 0.0)) * gamma;\n  vec4 minColor = mean - varianceGamma;\n  vec4 maxColor = mean + varianceGamma;\n  return clipAABB(clamp(mean, minColor, maxColor), history, minColor, maxColor);\n}\n\nvec4 varianceClipping(\n  const sampler2D inputBuffer,\n  const vec2 coord,\n  const vec4 current,\n  const vec4 history\n) {\n  return varianceClipping(inputBuffer, coord, current, history, 1.0);\n}\n";var zs=Object.defineProperty,Gs=(e,t,n,r)=>{for(var i,a=void 0,o=e.length-1;o>=0;o--)(i=e[o])&&(a=i(t,n,a)||a);return a&&zs(t,n,a),a};class Bs extends X{constructor({colorBuffer:e=null,depthVelocityBuffer:t=null,shadowLengthBuffer:n=null,colorHistoryBuffer:r=null,shadowLengthHistoryBuffer:i=null}={}){super({name:"CloudsResolveMaterial",glslVersion:k,vertexShader:"precision highp float;\n\nlayout(location = 0) in vec3 position;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = position.xy * 0.5 + 0.5;\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}\n",fragmentShader:ai(Jr('precision highp float;\nprecision highp sampler2DArray;\n\n#include "core/turbo"\n#include "catmullRomSampling"\n#include "varianceClipping"\n\nuniform sampler2D colorBuffer;\nuniform sampler2D depthVelocityBuffer;\nuniform sampler2D colorHistoryBuffer;\n\n#ifdef SHADOW_LENGTH\nuniform sampler2D shadowLengthBuffer;\nuniform sampler2D shadowLengthHistoryBuffer;\n#endif // SHADOW_LENGTH\n\nuniform vec2 texelSize;\nuniform int frame;\nuniform float varianceGamma;\nuniform float temporalAlpha;\nuniform vec2 jitterOffset;\n\nin vec2 vUv;\n\nlayout(location = 0) out vec4 outputColor;\n#ifdef SHADOW_LENGTH\nlayout(location = 1) out float outputShadowLength;\n#endif // SHADOW_LENGTH\n\nconst ivec2 neighborOffsets[9] = ivec2[9](\n  ivec2(-1, -1),\n  ivec2(-1, 0),\n  ivec2(-1, 1),\n  ivec2(0, -1),\n  ivec2(0, 0),\n  ivec2(0, 1),\n  ivec2(1, -1),\n  ivec2(1, 0),\n  ivec2(1, 1)\n);\n\nconst ivec4[4] bayerIndices = ivec4[4](\n  ivec4(0, 12, 3, 15),\n  ivec4(8, 4, 11, 7),\n  ivec4(2, 14, 1, 13),\n  ivec4(10, 6, 9, 5)\n);\n\nvec4 getClosestFragment(const ivec2 coord) {\n  vec4 result = vec4(1e7, 0.0, 0.0, 0.0);\n  vec4 neighbor;\n  #pragma unroll_loop_start\n  for (int i = 0; i < 9; ++i) {\n    neighbor = texelFetchOffset(depthVelocityBuffer, coord, 0, neighborOffsets[i]);\n    if (neighbor.r < result.r) {\n      result = neighbor;\n    }\n  }\n  #pragma unroll_loop_end\n  return result;\n}\n\nvoid temporalUpscale(\n  const ivec2 coord,\n  const ivec2 lowResCoord,\n  const bool currentFrame,\n  out vec4 outputColor,\n  out float outputShadowLength\n) {\n  vec4 currentColor = texelFetch(colorBuffer, lowResCoord, 0);\n  #ifdef SHADOW_LENGTH\n  vec4 currentShadowLength = vec4(texelFetch(shadowLengthBuffer, lowResCoord, 0).rgb, 1.0);\n  #endif // SHADOW_LENGTH\n\n  if (currentFrame) {\n    // Use the texel just rendered without any accumulation.\n    outputColor = currentColor;\n    #ifdef SHADOW_LENGTH\n    outputShadowLength = currentShadowLength.r;\n    #endif // SHADOW_LENGTH\n    return;\n  }\n\n  vec4 depthVelocity = getClosestFragment(lowResCoord);\n  vec2 velocity = depthVelocity.gb;\n  vec2 prevUv = vUv - velocity;\n  if (prevUv.x < 0.0 || prevUv.x > 1.0 || prevUv.y < 0.0 || prevUv.y > 1.0) {\n    outputColor = currentColor;\n    #ifdef SHADOW_LENGTH\n    outputShadowLength = currentShadowLength.r;\n    #endif // SHADOW_LENGTH\n    return; // Rejection\n  }\n\n  // Variance clipping with a large variance gamma seems to work fine for\n  // upsampling. This increases ghosting, of course, but it\'s hard to notice on\n  // clouds.\n  // vec4 historyColor = textureCatmullRom(colorHistoryBuffer, prevUv);\n  vec4 historyColor = texture(colorHistoryBuffer, prevUv);\n  vec4 clippedColor = varianceClipping(colorBuffer, vUv, currentColor, historyColor, varianceGamma);\n  outputColor = clippedColor;\n\n  #ifdef SHADOW_LENGTH\n  // Sampling the shadow length history using scene depth doesn\'t make much\n  // sense, but it\'s too hard to derive it properly. At least this approach\n  // resolves the edges of scene objects.\n  // vec4 historyShadowLength = vec4(textureCatmullRom(shadowLengthHistoryBuffer, prevUv).rgb, 1.0);\n  vec4 historyShadowLength = vec4(texture(shadowLengthHistoryBuffer, prevUv).rgb, 1.0);\n  vec4 clippedShadowLength = varianceClipping(\n    shadowLengthBuffer,\n    vUv,\n    currentShadowLength,\n    historyShadowLength,\n    varianceGamma\n  );\n  outputShadowLength = clippedShadowLength.r;\n  #endif // SHADOW_LENGTH\n}\n\nvoid temporalAntialiasing(const ivec2 coord, out vec4 outputColor, out float outputShadowLength) {\n  vec4 currentColor = texelFetch(colorBuffer, coord, 0);\n  #ifdef SHADOW_LENGTH\n  vec4 currentShadowLength = vec4(texelFetch(shadowLengthBuffer, coord, 0).rgb, 1.0);\n  #endif // SHADOW_LENGTH\n\n  vec4 depthVelocity = getClosestFragment(coord);\n  vec2 velocity = depthVelocity.gb;\n\n  vec2 prevUv = vUv - velocity;\n  if (prevUv.x < 0.0 || prevUv.x > 1.0 || prevUv.y < 0.0 || prevUv.y > 1.0) {\n    outputColor = currentColor;\n    #ifdef SHADOW_LENGTH\n    outputShadowLength = currentShadowLength.r;\n    #endif // SHADOW_LENGTH\n    return; // Rejection\n  }\n\n  vec4 historyColor = texture(colorHistoryBuffer, prevUv);\n  vec4 clippedColor = varianceClipping(colorBuffer, coord, currentColor, historyColor);\n  outputColor = mix(clippedColor, currentColor, temporalAlpha);\n\n  #ifdef SHADOW_LENGTH\n  vec4 historyShadowLength = vec4(texture(shadowLengthHistoryBuffer, prevUv).rgb, 1.0);\n  vec4 clippedShadowLength = varianceClipping(\n    shadowLengthBuffer,\n    coord,\n    currentShadowLength,\n    historyShadowLength\n  );\n  outputShadowLength = mix(clippedShadowLength.r, currentShadowLength.r, temporalAlpha);\n  #endif // SHADOW_LENGTH\n}\n\nvoid main() {\n  ivec2 coord = ivec2(gl_FragCoord.xy);\n\n  #if !defined(SHADOW_LENGTH)\n  float outputShadowLength;\n  #endif // !defined(SHADOW_LENGTH)\n\n  #ifdef TEMPORAL_UPSCALE\n  ivec2 lowResCoord = coord / 4;\n  int bayerValue = bayerIndices[coord.x % 4][coord.y % 4];\n  bool currentFrame = bayerValue == frame % 16;\n  temporalUpscale(coord, lowResCoord, currentFrame, outputColor, outputShadowLength);\n  #else // TEMPORAL_UPSCALE\n  temporalAntialiasing(coord, outputColor, outputShadowLength);\n  #endif // TEMPORAL_UPSCALE\n\n  #if defined(SHADOW_LENGTH) && defined(DEBUG_SHOW_SHADOW_LENGTH)\n  outputColor = vec4(turbo(outputShadowLength * 0.05), 1.0);\n  #endif // defined(SHADOW_LENGTH) && defined(DEBUG_SHOW_SHADOW_LENGTH)\n\n  #ifdef DEBUG_SHOW_VELOCITY\n  outputColor.rgb = outputColor.rgb + vec3(abs(texture(depthVelocityBuffer, vUv).gb) * 10.0, 0.0);\n  #endif // DEBUG_SHOW_VELOCITY\n}\n',{core:{turbo:mi},catmullRomSampling:'// Taken from https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\n// TODO: Use 5-taps version: https://www.shadertoy.com/view/MtVGWz\n// Or even 4 taps (requires preprocessing in the input buffer):\n// https://www.shadertoy.com/view/4tyGDD\n\n/**\n * MIT License\n *\n * Copyright (c) 2019 MJP\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nvec4 textureCatmullRom(sampler2D tex, vec2 uv) {\n  vec2 texSize = vec2(textureSize(tex, 0));\n\n  // We\'re going to sample a a 4x4 grid of texels surrounding the target UV\n  // coordinate. We\'ll do this by rounding down the sample location to get the\n  // exact center of our "starting" texel. The starting texel will be at\n  // location [1, 1] in the grid, where [0, 0] is the top left corner.\n  vec2 samplePos = uv * texSize;\n  vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n  // Compute the fractional offset from our starting texel to our original\n  // sample location, which we\'ll feed into the Catmull-Rom spline function to\n  // get our filter weights.\n  vec2 f = samplePos - texPos1;\n\n  // Compute the Catmull-Rom weights using the fractional offset that we\n  // calculated earlier. These equations are pre-expanded based on our knowledge\n  // of where the texels will be located, which lets us avoid having to evaluate\n  // a piece-wise function.\n  vec2 w0 = f * (-0.5 + f * (1.0 - 0.5 * f));\n  vec2 w1 = 1.0 + f * f * (-2.5 + 1.5 * f);\n  vec2 w2 = f * (0.5 + f * (2.0 - 1.5 * f));\n  vec2 w3 = f * f * (-0.5 + 0.5 * f);\n\n  // Work out weighting factors and sampling offsets that will let us use\n  // bilinear filtering to simultaneously evaluate the middle 2 samples from the\n  // 4x4 grid.\n  vec2 w12 = w1 + w2;\n  vec2 offset12 = w2 / (w1 + w2);\n\n  // Compute the final UV coordinates we\'ll use for sampling the texture\n  vec2 texPos0 = texPos1 - 1.0;\n  vec2 texPos3 = texPos1 + 2.0;\n  vec2 texPos12 = texPos1 + offset12;\n\n  texPos0 /= texSize;\n  texPos3 /= texSize;\n  texPos12 /= texSize;\n\n  vec4 result = vec4(0.0);\n  result += texture(tex, vec2(texPos0.x, texPos0.y)) * w0.x * w0.y;\n  result += texture(tex, vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n  result += texture(tex, vec2(texPos3.x, texPos0.y)) * w3.x * w0.y;\n\n  result += texture(tex, vec2(texPos0.x, texPos12.y)) * w0.x * w12.y;\n  result += texture(tex, vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n  result += texture(tex, vec2(texPos3.x, texPos12.y)) * w3.x * w12.y;\n\n  result += texture(tex, vec2(texPos0.x, texPos3.y)) * w0.x * w3.y;\n  result += texture(tex, vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n  result += texture(tex, vec2(texPos3.x, texPos3.y)) * w3.x * w3.y;\n\n  return result;\n}\n\nvec4 textureCatmullRom(sampler2DArray tex, vec3 uv) {\n  vec2 texSize = vec2(textureSize(tex, 0));\n  vec2 samplePos = uv.xy * texSize;\n  vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n  vec2 f = samplePos - texPos1;\n  vec2 w0 = f * (-0.5 + f * (1.0 - 0.5 * f));\n  vec2 w1 = 1.0 + f * f * (-2.5 + 1.5 * f);\n  vec2 w2 = f * (0.5 + f * (2.0 - 1.5 * f));\n  vec2 w3 = f * f * (-0.5 + 0.5 * f);\n  vec2 w12 = w1 + w2;\n  vec2 offset12 = w2 / (w1 + w2);\n  vec2 texPos0 = texPos1 - 1.0;\n  vec2 texPos3 = texPos1 + 2.0;\n  vec2 texPos12 = texPos1 + offset12;\n  texPos0 /= texSize;\n  texPos3 /= texSize;\n  texPos12 /= texSize;\n  vec4 result = vec4(0.0);\n  result += texture(tex, vec3(texPos0.x, texPos0.y, uv.z)) * w0.x * w0.y;\n  result += texture(tex, vec3(texPos12.x, texPos0.y, uv.z)) * w12.x * w0.y;\n  result += texture(tex, vec3(texPos3.x, texPos0.y, uv.z)) * w3.x * w0.y;\n  result += texture(tex, vec3(texPos0.x, texPos12.y, uv.z)) * w0.x * w12.y;\n  result += texture(tex, vec3(texPos12.x, texPos12.y, uv.z)) * w12.x * w12.y;\n  result += texture(tex, vec3(texPos3.x, texPos12.y, uv.z)) * w3.x * w12.y;\n  result += texture(tex, vec3(texPos0.x, texPos3.y, uv.z)) * w0.x * w3.y;\n  result += texture(tex, vec3(texPos12.x, texPos3.y, uv.z)) * w12.x * w3.y;\n  result += texture(tex, vec3(texPos3.x, texPos3.y, uv.z)) * w3.x * w3.y;\n  return result;\n}\n',varianceClipping:Fs})),uniforms:{colorBuffer:new G(e),depthVelocityBuffer:new G(t),shadowLengthBuffer:new G(n),colorHistoryBuffer:new G(r),shadowLengthHistoryBuffer:new G(i),texelSize:new G(new B),frame:new G(0),jitterOffset:new G(new B),varianceGamma:new G(2),temporalAlpha:new G(.1)}}),this.temporalUpscale=!0,this.shadowLength=!0}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}onBeforeRender(e,t,n,r,i,a){const o=this.uniforms.frame.value%16,s=Cs[o],c=4*(s.x-.5),u=4*(s.y-.5);this.uniforms.jitterOffset.value.set(c,u)}}Gs([tr("TEMPORAL_UPSCALE")],Bs.prototype,"temporalUpscale"),Gs([tr("SHADOW_LENGTH")],Bs.prototype,"shadowLength");class Ws extends c{constructor(e,t){super(e),this._mainCamera=new z;const{shadow:n}=t;this.shadow=n}get mainCamera(){return this._mainCamera}set mainCamera(e){this._mainCamera=e}}function ks(e,{depthVelocity:t,shadowLength:n}){const r=new q(1,1,{depthBuffer:!1,type:D});let i,a;return r.texture.minFilter=m,r.texture.magFilter=m,r.texture.name=e,t&&(i=r.texture.clone(),i.isRenderTargetTexture=!0,r.depthVelocity=i,r.textures.push(i)),n&&(a=r.texture.clone(),a.isRenderTargetTexture=!0,a.format=S,r.shadowLength=a,r.textures.push(a)),Object.assign(r,{depthVelocity:i??null,shadowLength:a??null})}class Vs extends Ws{constructor({parameterUniforms:e,layerUniforms:t,atmosphereUniforms:n,...r},a){super("CloudsPass",r),this.atmosphere=a,this.width=0,this.height=0,this.currentMaterial=new Hs({parameterUniforms:e,layerUniforms:t,atmosphereUniforms:n},a),this.currentPass=new i(this.currentMaterial),this.resolveMaterial=new Bs,this.resolvePass=new i(this.resolveMaterial),this.initRenderTargets({depthVelocity:!0,shadowLength:Ds.lightShafts})}copyCameraSettings(e){this.currentMaterial.copyCameraSettings(e)}initialize(e,t,n){this.currentPass.initialize(e,t,n),this.resolvePass.initialize(e,t,n)}initRenderTargets(e){var t,n,r;null==(t=this.currentRenderTarget)||t.dispose(),null==(n=this.resolveRenderTarget)||n.dispose(),null==(r=this.historyRenderTarget)||r.dispose();const i=ks("Clouds",e),a=ks("Clouds.A",{...e,depthVelocity:!1}),o=ks("Clouds.B",{...e,depthVelocity:!1});this.currentRenderTarget=i,this.resolveRenderTarget=a,this.historyRenderTarget=o;const s=this.resolveMaterial.uniforms;s.colorBuffer.value=i.texture,s.depthVelocityBuffer.value=i.depthVelocity,s.shadowLengthBuffer.value=i.shadowLength,s.colorHistoryBuffer.value=o.texture,s.shadowLengthHistoryBuffer.value=o.shadowLength}copyShadow(){const e=this.shadow,t=this.currentMaterial.uniforms;for(let n=0;n<e.cascadeCount;++n){const r=e.cascades[n];t.shadowIntervals.value[n].copy(r.interval),t.shadowMatrices.value[n].copy(r.matrix)}t.shadowFar.value=e.far}copyReprojection(){this.currentMaterial.copyReprojectionMatrix(this.mainCamera)}swapBuffers(){const e=this.historyRenderTarget,t=this.resolveRenderTarget;this.resolveRenderTarget=e,this.historyRenderTarget=t;const n=this.resolveMaterial.uniforms;n.colorHistoryBuffer.value=t.texture,n.shadowLengthHistoryBuffer.value=t.shadowLength}update(e,t,n){this.currentMaterial.uniforms.frame.value=t,this.resolveMaterial.uniforms.frame.value=t,this.copyCameraSettings(this.mainCamera),this.copyShadow(),this.currentPass.render(e,null,this.currentRenderTarget),this.resolvePass.render(e,null,this.resolveRenderTarget),this.copyReprojection(),this.swapBuffers()}setSize(e,t){if(this.width=e,this.height=t,this.temporalUpscale){const n=Math.ceil(e/4),r=Math.ceil(t/4);this.currentRenderTarget.setSize(n,r),this.currentMaterial.setSize(4*n,4*r,e,t)}else this.currentRenderTarget.setSize(e,t),this.currentMaterial.setSize(e,t);this.resolveRenderTarget.setSize(e,t),this.resolveMaterial.setSize(e,t),this.historyRenderTarget.setSize(e,t)}setShadowSize(e,t,n){this.currentMaterial.shadowCascadeCount=n,this.currentMaterial.setShadowSize(e,t)}setDepthTexture(e,t){this.currentMaterial.depthBuffer=e,this.currentMaterial.depthPacking=t??0}get outputBuffer(){return this.historyRenderTarget.texture}get shadowBuffer(){return this.currentMaterial.uniforms.shadowBuffer.value}set shadowBuffer(e){this.currentMaterial.uniforms.shadowBuffer.value=e}get shadowLengthBuffer(){return this.historyRenderTarget.shadowLength}get temporalUpscale(){return this.currentMaterial.temporalUpscale}set temporalUpscale(e){e!==this.temporalUpscale&&(this.currentMaterial.temporalUpscale=e,this.resolveMaterial.temporalUpscale=e,this.setSize(this.width,this.height))}get lightShafts(){return this.currentMaterial.shadowLength}set lightShafts(e){e!==this.lightShafts&&(this.currentMaterial.shadowLength=e,this.resolveMaterial.shadowLength=e,this.initRenderTargets({depthVelocity:!0,shadowLength:e}),this.setSize(this.width,this.height))}}class js extends i{render(e,t,n,r,i){const a=this.fullscreenMaterial.uniforms;null!==t&&null!=(null==a?void 0:a[this.input])&&(a[this.input].value=t.texture),function(e,t){const n=e.properties.get(t.texture).__webglTexture,r=e.getContext();fs(r instanceof WebGL2RenderingContext),e.setRenderTarget(t);const i=[];if(null!=n)for(let a=0;a<t.depth;++a)r.framebufferTextureLayer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+a,n,0,a),i.push(r.COLOR_ATTACHMENT0+a);r.drawBuffers(i)}(e,n),e.render(this.scene,this.camera)}}var Ys=Object.defineProperty,Xs=(e,t,n,r)=>{for(var i,a=void 0,o=e.length-1;o>=0;o--)(i=e[o])&&(a=i(t,n,a)||a);return a&&Ys(t,n,a),a};class qs extends X{constructor({parameterUniforms:e,layerUniforms:t,atmosphereUniforms:n}){super({name:"ShadowMaterial",glslVersion:k,vertexShader:"precision highp float;\n\nlayout(location = 0) in vec3 position;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = position.xy * 0.5 + 0.5;\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}\n",fragmentShader:ai(Jr('precision highp float;\nprecision highp sampler3D;\n\n#include <common>\n\n#include "core/math"\n#include "core/raySphereIntersection"\n#include "types"\n#include "parameters"\n#include "structuredSampling"\n#include "clouds"\n\nuniform mat4 inverseShadowMatrices[CASCADE_COUNT];\nuniform mat4 reprojectionMatrices[CASCADE_COUNT];\n\n// Primary raymarch\nuniform int maxIterationCount;\nuniform float minStepSize;\nuniform float maxStepSize;\nuniform float opticalDepthTailScale;\n\nin vec2 vUv;\n\nlayout(location = 0) out vec4 outputColor[CASCADE_COUNT];\n\n// Redundant notation for prettier.\n#if CASCADE_COUNT == 1\nlayout(location = 1) out vec3 outputDepthVelocity[CASCADE_COUNT];\n#elif CASCADE_COUNT == 2\nlayout(location = 2) out vec3 outputDepthVelocity[CASCADE_COUNT];\n#elif CASCADE_COUNT == 3\nlayout(location = 3) out vec3 outputDepthVelocity[CASCADE_COUNT];\n#elif CASCADE_COUNT == 4\nlayout(location = 4) out vec3 outputDepthVelocity[CASCADE_COUNT];\n#endif // CASCADE_COUNT\n\nvec4 marchClouds(\n  const vec3 rayOrigin,\n  const vec3 rayDirection,\n  const float maxRayDistance,\n  const float jitter,\n  const float mipLevel\n) {\n  // Setup structured volume sampling (SVS).\n  // While SVS introduces spatial aliasing, it is indeed temporally stable,\n  // which is important for lower-resolution shadow maps where a flickering\n  // single pixel can be highly noticeable.\n  vec3 normal = getStructureNormal(rayDirection, jitter);\n  float rayDistance;\n  float stepSize;\n  intersectStructuredPlanes(\n    normal,\n    rayOrigin,\n    rayDirection,\n    clamp(maxRayDistance / float(maxIterationCount), minStepSize, maxStepSize),\n    rayDistance,\n    stepSize\n  );\n\n  #ifdef TEMPORAL_JITTER\n  rayDistance -= stepSize * jitter;\n  #endif // TEMPORAL_JITTER\n\n  float extinctionSum = 0.0;\n  float maxOpticalDepth = 0.0;\n  float maxOpticalDepthTail = 0.0;\n  float transmittanceIntegral = 1.0;\n  float weightedDistanceSum = 0.0;\n  float transmittanceSum = 0.0;\n\n  int sampleCount = 0;\n  for (int i = 0; i < maxIterationCount; ++i) {\n    if (rayDistance > maxRayDistance) {\n      break; // Termination\n    }\n\n    vec3 position = rayDistance * rayDirection + rayOrigin;\n    float height = length(position) - bottomRadius;\n\n    #if !defined(DEBUG_MARCH_INTERVALS)\n    if (insideLayerIntervals(height)) {\n      rayDistance += stepSize;\n      continue;\n    }\n    #endif // !defined(DEBUG_MARCH_INTERVALS)\n\n    // Sample rough weather.\n    vec2 uv = getGlobeUv(position);\n    WeatherSample weather = sampleWeather(uv, height, mipLevel);\n\n    if (any(greaterThan(weather.density, vec4(minDensity)))) {\n      // Sample detailed participating media.\n      // Note this assumes an homogeneous medium.\n      MediaSample media = sampleMedia(weather, position, uv, mipLevel, jitter);\n      if (media.extinction > minExtinction) {\n        extinctionSum += media.extinction;\n        maxOpticalDepth += media.extinction * stepSize;\n        transmittanceIntegral *= exp(-media.extinction * stepSize);\n        weightedDistanceSum += rayDistance * transmittanceIntegral;\n        transmittanceSum += transmittanceIntegral;\n        ++sampleCount;\n      }\n    }\n\n    if (transmittanceIntegral <= minTransmittance) {\n      // A large amount of optical depth accumulates in the tail, beyond the\n      // point of minimum transmittance. The expected optical depth seems to\n      // decrease exponentially with the number of samples taken before reaching\n      // the minimum transmittance.\n      // See the discussion here: https://x.com/shotamatsuda/status/1886259549931520437\n      maxOpticalDepthTail = min(\n        opticalDepthTailScale * stepSize * exp(float(1 - sampleCount)),\n        stepSize * 0.5 // Excessive optical depth only introduces aliasing.\n      );\n      break; // Early termination\n    }\n    rayDistance += stepSize;\n  }\n\n  if (sampleCount == 0) {\n    return vec4(maxRayDistance, 0.0, 0.0, 0.0);\n  }\n  float frontDepth = min(weightedDistanceSum / transmittanceSum, maxRayDistance);\n  float meanExtinction = extinctionSum / float(sampleCount);\n  return vec4(frontDepth, meanExtinction, maxOpticalDepth, maxOpticalDepthTail);\n}\n\nvoid getRayNearFar(\n  const vec3 sunPosition,\n  const vec3 rayDirection,\n  out float rayNear,\n  out float rayFar\n) {\n  vec4 firstIntersections = raySphereFirstIntersection(\n    sunPosition,\n    rayDirection,\n    vec3(0.0),\n    bottomRadius + vec4(shadowTopHeight, shadowBottomHeight, 0.0, 0.0)\n  );\n  rayNear = max(0.0, firstIntersections.x);\n  rayFar = firstIntersections.y;\n  if (rayFar < 0.0) {\n    rayFar = 1e6;\n  }\n}\n\nvoid cascade(\n  const int cascadeIndex,\n  const float mipLevel,\n  out vec4 outputColor,\n  out vec3 outputDepthVelocity\n) {\n  vec2 clip = vUv * 2.0 - 1.0;\n  vec4 point = inverseShadowMatrices[cascadeIndex] * vec4(clip.xy, -1.0, 1.0);\n  point /= point.w;\n  vec3 sunPosition = (worldToECEFMatrix * vec4(point.xyz, 1.0)).xyz + altitudeCorrection;\n\n  vec3 rayDirection = normalize(-sunDirection);\n  float rayNear;\n  float rayFar;\n  getRayNearFar(sunPosition, rayDirection, rayNear, rayFar);\n\n  vec3 rayOrigin = rayNear * rayDirection + sunPosition;\n  float stbn = getSTBN();\n  vec4 color = marchClouds(rayOrigin, rayDirection, rayFar - rayNear, stbn, mipLevel);\n  outputColor = color;\n\n  // Velocity for temporal resolution.\n  #ifdef TEMPORAL_PASS\n  vec3 frontPosition = color.x * rayDirection + rayOrigin;\n  vec3 frontPositionWorld = (ecefToWorldMatrix * vec4(frontPosition - altitudeCorrection, 1.0)).xyz;\n  vec4 prevClip = reprojectionMatrices[cascadeIndex] * vec4(frontPositionWorld, 1.0);\n  prevClip /= prevClip.w;\n  vec2 prevUv = prevClip.xy * 0.5 + 0.5;\n  vec2 velocity = (vUv - prevUv) * resolution;\n  outputDepthVelocity = vec3(color.x, velocity);\n  #else // TEMPORAL_PASS\n  outputDepthVelocity = vec3(0.0);\n  #endif // TEMPORAL_PASS\n}\n\n// TODO: Calculate from the main camera frustum perhaps?\nconst float mipLevels[4] = float[4](0.0, 0.5, 1.0, 2.0);\n\nvoid main() {\n  #pragma unroll_loop_start\n  for (int i = 0; i < 4; ++i) {\n    #if UNROLLED_LOOP_INDEX < CASCADE_COUNT\n    cascade(UNROLLED_LOOP_INDEX, mipLevels[i], outputColor[i], outputDepthVelocity[i]);\n    #endif // UNROLLED_LOOP_INDEX < CASCADE_COUNT\n  }\n  #pragma unroll_loop_end\n}\n',{core:{math:ui,raySphereIntersection:hi},types:bs,parameters:Ns,structuredSampling:"// Implements Structured Volume Sampling in fragment shader:\n// https://github.com/huwb/volsample\n// Implementation reference:\n// https://www.shadertoy.com/view/ttVfDc\n\nvoid getIcosahedralVertices(const vec3 direction, out vec3 v1, out vec3 v2, out vec3 v3) {\n  // Normalization scalers to fit dodecahedron to unit sphere.\n  const float a = 0.85065080835204; // phi / sqrt(2 + phi)\n  const float b = 0.5257311121191336; // 1 / sqrt(2 + phi)\n\n  // Derive the vertices of icosahedron where triangle intersects the direction.\n  // See: https://www.ppsloan.org/publications/AmbientDice.pdf\n  const float kT = 0.6180339887498948; // 1 / phi\n  const float kT2 = 0.38196601125010515; // 1 / phi^2\n  vec3 absD = abs(direction);\n  float selector1 = dot(absD, vec3(1.0, kT2, -kT));\n  float selector2 = dot(absD, vec3(-kT, 1.0, kT2));\n  float selector3 = dot(absD, vec3(kT2, -kT, 1.0));\n  v1 = selector1 > 0.0 ? vec3(a, b, 0.0) : vec3(-b, 0.0, a);\n  v2 = selector2 > 0.0 ? vec3(0.0, a, b) : vec3(a, -b, 0.0);\n  v3 = selector3 > 0.0 ? vec3(b, 0.0, a) : vec3(0.0, a, -b);\n  vec3 octantSign = sign(direction);\n  v1 *= octantSign;\n  v2 *= octantSign;\n  v3 *= octantSign;\n}\n\nvoid swapIfBigger(inout vec4 a, inout vec4 b) {\n  if (a.w > b.w) {\n    vec4 t = a;\n    a = b;\n    b = t;\n  }\n}\n\nvoid sortVertices(inout vec3 a, inout vec3 b, inout vec3 c) {\n  const vec3 base = vec3(0.5, 0.5, 1.0);\n  vec4 aw = vec4(a, dot(a, base));\n  vec4 bw = vec4(b, dot(b, base));\n  vec4 cw = vec4(c, dot(c, base));\n  swapIfBigger(aw, bw);\n  swapIfBigger(bw, cw);\n  swapIfBigger(aw, bw);\n  a = aw.xyz;\n  b = bw.xyz;\n  c = cw.xyz;\n}\n\nvec3 getPentagonalWeights(const vec3 direction, const vec3 v1, const vec3 v2, const vec3 v3) {\n  float d1 = dot(v1, direction);\n  float d2 = dot(v2, direction);\n  float d3 = dot(v3, direction);\n  vec3 w = exp(vec3(d1, d2, d3) * 40.0);\n  return w / (w.x + w.y + w.z);\n}\n\nvec3 getStructureNormal(\n  const vec3 direction,\n  const float jitter,\n  out vec3 a,\n  out vec3 b,\n  out vec3 c,\n  out vec3 weights\n) {\n  getIcosahedralVertices(direction, a, b, c);\n  sortVertices(a, b, c);\n  weights = getPentagonalWeights(direction, a, b, c);\n  return jitter < weights.x\n    ? a\n    : jitter < weights.x + weights.y\n      ? b\n      : c;\n}\n\nvec3 getStructureNormal(const vec3 direction, const float jitter) {\n  vec3 a, b, c, weights;\n  return getStructureNormal(direction, jitter, a, b, c, weights);\n}\n\n// Reference: https://github.com/huwb/volsample/blob/master/src/unity/Assets/Shaders/RayMarchCore.cginc\nvoid intersectStructuredPlanes(\n  const vec3 normal,\n  const vec3 rayOrigin,\n  const vec3 rayDirection,\n  const float samplePeriod,\n  out float stepOffset,\n  out float stepSize\n) {\n  float NoD = dot(rayDirection, normal);\n  stepSize = samplePeriod / abs(NoD);\n\n  // Skips leftover bit to get from rayOrigin to first strata plane.\n  stepOffset = -mod(dot(rayOrigin, normal), samplePeriod) / NoD;\n\n  // mod() gives different results depending on if the arg is negative or\n  // positive. This line makes it consistent, and ensures the first sample is in\n  // front of the viewer.\n  if (stepOffset < 0.0) {\n    stepOffset += stepSize;\n  }\n}\n",clouds:Os})),uniforms:{...e,...t,...n,inverseShadowMatrices:new G(Array.from({length:4},()=>new l)),reprojectionMatrices:new G(Array.from({length:4},()=>new l)),resolution:new G(new B),frame:new G(0),stbnTexture:new G(null),maxIterationCount:new G(Ds.shadow.maxIterationCount),minStepSize:new G(Ds.shadow.minStepSize),maxStepSize:new G(Ds.shadow.maxStepSize),minDensity:new G(Ds.shadow.minDensity),minExtinction:new G(Ds.shadow.minExtinction),minTransmittance:new G(Ds.shadow.minTransmittance),opticalDepthTailScale:new G(2)},defines:{SHADOW:"1",TEMPORAL_PASS:"1",TEMPORAL_JITTER:"1"}}),this.localWeatherChannels="rgba",this.cascadeCount=Ds.shadow.cascadeCount,this.temporalPass=!0,this.temporalJitter=!0,this.shapeDetail=Ds.shapeDetail,this.turbulence=Ds.turbulence,this.cascadeCount=Ds.shadow.cascadeCount}setSize(e,t){this.uniforms.resolution.value.set(e,t)}}Xs([ir("LOCAL_WEATHER_CHANNELS",{validate:e=>/^[rgba]{4}$/.test(e)})],qs.prototype,"localWeatherChannels"),Xs([nr("CASCADE_COUNT",{min:1,max:4})],qs.prototype,"cascadeCount"),Xs([tr("TEMPORAL_PASS")],qs.prototype,"temporalPass"),Xs([tr("TEMPORAL_JITTER")],qs.prototype,"temporalJitter"),Xs([tr("SHAPE_DETAIL")],qs.prototype,"shapeDetail"),Xs([tr("TURBULENCE")],qs.prototype,"turbulence");var Ks=Object.defineProperty;class Zs extends X{constructor({inputBuffer:e=null,historyBuffer:t=null}={}){super({name:"ShadowResolveMaterial",glslVersion:k,vertexShader:"precision highp float;\n\nlayout(location = 0) in vec3 position;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = position.xy * 0.5 + 0.5;\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}\n",fragmentShader:ai(Jr('precision highp float;\nprecision highp sampler2DArray;\n\n#define VARIANCE_9_SAMPLES 1\n#define VARIANCE_SAMPLER_ARRAY 1\n\n#include "varianceClipping"\n\nuniform sampler2DArray inputBuffer;\nuniform sampler2DArray historyBuffer;\n\nuniform vec2 texelSize;\nuniform float varianceGamma;\nuniform float temporalAlpha;\n\nin vec2 vUv;\n\nlayout(location = 0) out vec4 outputColor[CASCADE_COUNT];\n\nconst ivec2 neighborOffsets[9] = ivec2[9](\n  ivec2(-1, -1),\n  ivec2(-1, 0),\n  ivec2(-1, 1),\n  ivec2(0, -1),\n  ivec2(0, 0),\n  ivec2(0, 1),\n  ivec2(1, -1),\n  ivec2(1, 0),\n  ivec2(1, 1)\n);\n\nvec4 getClosestFragment(const ivec3 coord) {\n  vec4 result = vec4(1e7, 0.0, 0.0, 0.0);\n  vec4 neighbor;\n  #pragma unroll_loop_start\n  for (int i = 0; i < 9; ++i) {\n    neighbor = texelFetchOffset(\n      inputBuffer,\n      coord + ivec3(0, 0, CASCADE_COUNT),\n      0,\n      neighborOffsets[i]\n    );\n    if (neighbor.r < result.r) {\n      result = neighbor;\n    }\n  }\n  #pragma unroll_loop_end\n  return result;\n}\n\nvoid cascade(const int cascadeIndex, out vec4 outputColor) {\n  ivec3 coord = ivec3(gl_FragCoord.xy, cascadeIndex);\n  vec4 current = texelFetch(inputBuffer, coord, 0);\n\n  vec4 depthVelocity = getClosestFragment(coord);\n  vec2 velocity = depthVelocity.gb * texelSize;\n  vec2 prevUv = vUv - velocity;\n  if (prevUv.x < 0.0 || prevUv.x > 1.0 || prevUv.y < 0.0 || prevUv.y > 1.0) {\n    outputColor = current;\n    return; // Rejection\n  }\n\n  vec4 history = texture(historyBuffer, vec3(prevUv, float(cascadeIndex)));\n  vec4 clippedHistory = varianceClipping(inputBuffer, coord, current, history, varianceGamma);\n  outputColor = mix(clippedHistory, current, temporalAlpha);\n}\n\nvoid main() {\n  #pragma unroll_loop_start\n  for (int i = 0; i < 4; ++i) {\n    #if UNROLLED_LOOP_INDEX < CASCADE_COUNT\n    cascade(UNROLLED_LOOP_INDEX, outputColor[i]);\n    #endif // UNROLLED_LOOP_INDEX < CASCADE_COUNT\n  }\n  #pragma unroll_loop_end\n}\n',{varianceClipping:Fs})),uniforms:{inputBuffer:new G(e),historyBuffer:new G(t),texelSize:new G(new B),varianceGamma:new G(1),temporalAlpha:new G(.01)},defines:{}}),this.cascadeCount=Ds.shadow.cascadeCount}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}}function Js(e){const t=new te(1,1,1,{depthBuffer:!1});return t.texture.type=D,t.texture.minFilter=m,t.texture.magFilter=m,t.texture.name=e,t}((e,t,n)=>{for(var r,i=void 0,a=e.length-1;a>=0;a--)(r=e[a])&&(i=r(t,n,i)||i);i&&Ks(t,n,i)})([nr("CASCADE_COUNT",{min:1,max:4})],Zs.prototype,"cascadeCount");class $s extends Ws{constructor({parameterUniforms:e,layerUniforms:t,atmosphereUniforms:n,...r}){super("ShadowPass",r),this.width=0,this.height=0,this.currentMaterial=new qs({parameterUniforms:e,layerUniforms:t,atmosphereUniforms:n}),this.currentPass=new js(this.currentMaterial),this.resolveMaterial=new Zs,this.resolvePass=new js(this.resolveMaterial),this.initRenderTargets()}initialize(e,t,n){this.currentPass.initialize(e,t,n),this.resolvePass.initialize(e,t,n)}initRenderTargets(){var e,t,n;null==(e=this.currentRenderTarget)||e.dispose(),null==(t=this.resolveRenderTarget)||t.dispose(),null==(n=this.historyRenderTarget)||n.dispose();const r=Js("Shadow"),i=this.temporalPass?Js("Shadow.A"):null,a=this.temporalPass?Js("Shadow.B"):null;this.currentRenderTarget=r,this.resolveRenderTarget=i,this.historyRenderTarget=a;const o=this.resolveMaterial.uniforms;o.inputBuffer.value=r.texture,o.historyBuffer.value=(null==a?void 0:a.texture)??null}copyShadow(){const e=this.shadow,t=this.currentMaterial.uniforms;for(let n=0;n<e.cascadeCount;++n){const r=e.cascades[n];t.inverseShadowMatrices.value[n].copy(r.inverseMatrix)}}copyReprojection(){const e=this.shadow,t=this.currentMaterial.uniforms;for(let n=0;n<e.cascadeCount;++n){const r=e.cascades[n];t.reprojectionMatrices.value[n].copy(r.matrix)}}swapBuffers(){fs(null!=this.historyRenderTarget),fs(null!=this.resolveRenderTarget);const e=this.historyRenderTarget,t=this.resolveRenderTarget;this.resolveRenderTarget=e,this.historyRenderTarget=t,this.resolveMaterial.uniforms.historyBuffer.value=t.texture}update(e,t,n){this.currentMaterial.uniforms.frame.value=t,this.copyShadow(),this.currentPass.render(e,null,this.currentRenderTarget),this.temporalPass&&(fs(null!=this.resolveRenderTarget),this.resolvePass.render(e,null,this.resolveRenderTarget),this.copyReprojection(),this.swapBuffers())}setSize(e,t,n=this.shadow.cascadeCount){var r,i;this.width=e,this.height=t,this.currentMaterial.cascadeCount=n,this.resolveMaterial.cascadeCount=n,this.currentMaterial.setSize(e,t),this.resolveMaterial.setSize(e,t),this.currentRenderTarget.setSize(e,t,this.temporalPass?2*n:n),null==(r=this.resolveRenderTarget)||r.setSize(e,t,n),null==(i=this.historyRenderTarget)||i.setSize(e,t,n)}get outputBuffer(){return this.temporalPass?(fs(null!=this.historyRenderTarget),this.historyRenderTarget.texture):this.currentRenderTarget.texture}get temporalPass(){return this.currentMaterial.temporalPass}set temporalPass(e){e!==this.temporalPass&&(this.currentMaterial.temporalPass=e,this.initRenderTargets(),this.setSize(this.width,this.height))}}const Qs=[0,0,0,0];var ec=Object.defineProperty;const tc=new u,nc=new B,rc=new j,ic=["maxIterationCount","minStepSize","maxStepSize","maxRayDistance","perspectiveStepScale","minDensity","minExtinction","minTransmittance","maxIterationCountToSun","maxIterationCountToGround","minSecondaryStepSize","secondaryStepScale","maxShadowFilterRadius","maxShadowLengthIterationCount","minShadowLengthStepSize","maxShadowLengthRayDistance","hazeDensityScale","hazeExponent","hazeScatteringCoefficient","hazeAbsorptionCoefficient"],ac=["multiScatteringOctaves","accurateSunSkyLight","accuratePhaseFunction"],oc=["maxIterationCount","minStepSize","maxStepSize","minDensity","minExtinction","minTransmittance","opticalDepthTailScale"],sc=["temporalJitter"],cc=["temporalPass"],uc=["cascadeCount","mapSize","maxFar","farScale","splitMode","splitLambda"],lc={type:"change"},hc={resolutionScale:Ds.resolutionScale,width:r.AUTO_SIZE,height:r.AUTO_SIZE};class dc extends e{constructor(e=new z,n,i=Ei.DEFAULT){var a,o,s,c;super("CloudsEffect","uniform sampler2D cloudsBuffer;\n\nvoid mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {\n  #ifdef SKIP_RENDERING\n  outputColor = inputColor;\n  #else // SKIP_RENDERING\n  vec4 clouds = texture(cloudsBuffer, uv);\n  outputColor.rgb = inputColor.rgb * (1.0 - clouds.a) + clouds.rgb;\n  outputColor.a = inputColor.a * (1.0 - clouds.a) + clouds.a;\n  #endif // SKIP_RENDERING\n}\n",{attributes:t.DEPTH,uniforms:new Map([["cloudsBuffer",new G(null)]])}),this.camera=e,this.atmosphere=i,this.cloudLayers=ps.DEFAULT.clone(),this.correctAltitude=!0,this.localWeatherRepeat=(new B).setScalar(100),this.localWeatherOffset=new B,this.shapeRepeat=(new u).setScalar(3e-4),this.shapeOffset=new u,this.shapeDetailRepeat=(new u).setScalar(.006),this.shapeDetailOffset=new u,this.turbulenceRepeat=(new B).setScalar(20),this.worldToECEFMatrix=new l,this.ecefToWorldMatrix=new l,this.altitudeCorrection=new u,this.sunDirection=new u,this.localWeatherVelocity=new B,this.shapeVelocity=new u,this.shapeDetailVelocity=new u,this._atmosphereOverlay=null,this._atmosphereShadow=null,this._atmosphereShadowLength=null,this.events=new J,this.frame=0,this.shadowCascadeCount=0,this.shadowMapSize=new B,this.onResolutionChange=()=>{this.setSize(this.resolution.baseWidth,this.resolution.baseHeight)},this.skipRendering=!0;const{resolutionScale:h,width:d,height:m,resolutionX:p=d,resolutionY:f=m}={...hc,...n};this.shadowMaps=new As({cascadeCount:Ds.shadow.cascadeCount,mapSize:Ds.shadow.mapSize,splitLambda:.6}),this.parameterUniforms=function(e){return{scatteringCoefficient:new G(1),absorptionCoefficient:new G(0),coverage:new G(.3),localWeatherTexture:new G(e.localWeatherTexture),localWeatherRepeat:new G(e.localWeatherRepeat),localWeatherOffset:new G(e.localWeatherOffset),shapeTexture:new G(e.shapeTexture),shapeRepeat:new G(e.shapeRepeat),shapeOffset:new G(e.shapeOffset),shapeDetailTexture:new G(e.shapeDetailTexture),shapeDetailRepeat:new G(e.shapeDetailRepeat),shapeDetailOffset:new G(e.shapeDetailOffset),turbulenceTexture:new G(e.turbulenceTexture),turbulenceRepeat:new G(e.turbulenceRepeat),turbulenceDisplacement:new G(350)}}({localWeatherTexture:(null==(a=this.proceduralLocalWeather)?void 0:a.texture)??null,localWeatherRepeat:this.localWeatherRepeat,localWeatherOffset:this.localWeatherOffset,shapeTexture:(null==(o=this.proceduralShape)?void 0:o.texture)??null,shapeRepeat:this.shapeRepeat,shapeOffset:this.shapeOffset,shapeDetailTexture:(null==(s=this.proceduralShapeDetail)?void 0:s.texture)??null,shapeDetailRepeat:this.shapeDetailRepeat,shapeDetailOffset:this.shapeDetailOffset,turbulenceTexture:(null==(c=this.proceduralTurbulence)?void 0:c.texture)??null,turbulenceRepeat:this.turbulenceRepeat}),this.layerUniforms={minLayerHeights:new G(new ee),maxLayerHeights:new G(new ee),minIntervalHeights:new G(new u),maxIntervalHeights:new G(new u),densityScales:new G(new ee),shapeAmounts:new G(new ee),shapeDetailAmounts:new G(new ee),weatherExponents:new G(new ee),shapeAlteringBiases:new G(new ee),coverageFilterWidths:new G(new ee),minHeight:new G(0),maxHeight:new G(0),shadowTopHeight:new G(0),shadowBottomHeight:new G(0),shadowLayerMask:new G(new ee),densityProfile:new G({expTerms:new ee,exponents:new ee,linearTerms:new ee,constantTerms:new ee})},this.atmosphereUniforms=function(e,t){return{bottomRadius:new G(e.bottomRadius),topRadius:new G(e.topRadius),worldToECEFMatrix:new G(t.worldToECEFMatrix),ecefToWorldMatrix:new G(t.ecefToWorldMatrix),altitudeCorrection:new G(t.altitudeCorrection),sunDirection:new G(t.sunDirection)}}(i,{worldToECEFMatrix:this.worldToECEFMatrix,ecefToWorldMatrix:this.ecefToWorldMatrix,altitudeCorrection:this.altitudeCorrection,sunDirection:this.sunDirection});const v={shadow:this.shadowMaps,parameterUniforms:this.parameterUniforms,layerUniforms:this.layerUniforms,atmosphereUniforms:this.atmosphereUniforms};this.shadowPass=new $s(v),this.shadowPass.mainCamera=e,this.cloudsPass=new Vs(v,i),this.cloudsPass.mainCamera=e,this.clouds=ar(or({},this.cloudsPass.currentMaterial,ic),this.cloudsPass.currentMaterial,ac),this.shadow=ar(or({},this.shadowPass.currentMaterial,oc),this.shadowPass.currentMaterial,sc,this.shadowPass,cc,this.shadowMaps,uc),this.resolution=new r(this,p,f,h),this.resolution.addEventListener("change",this.onResolutionChange)}get mainCamera(){return this.camera}set mainCamera(e){this.camera=e,this.shadowPass.mainCamera=e,this.cloudsPass.mainCamera=e}initialize(e,t,n){this.shadowPass.initialize(e,t,n),this.cloudsPass.initialize(e,t,n)}updateSharedUniforms(e){!function(e,t){t.packValues("altitude",e.minLayerHeights.value),t.packSums("altitude","height",e.maxLayerHeights.value),t.packIntervalHeights(e.minIntervalHeights.value,e.maxIntervalHeights.value),t.packValues("densityScale",e.densityScales.value),t.packValues("shapeAmount",e.shapeAmounts.value),t.packValues("shapeDetailAmount",e.shapeDetailAmounts.value),t.packValues("weatherExponent",e.weatherExponents.value),t.packValues("shapeAlteringBias",e.shapeAlteringBiases.value),t.packValues("coverageFilterWidth",e.coverageFilterWidths.value);const n=e.densityProfile.value;t.packDensityProfiles("expTerm",n.expTerms),t.packDensityProfiles("exponent",n.exponents),t.packDensityProfiles("linearTerm",n.linearTerms),t.packDensityProfiles("constantTerm",n.constantTerms);let r=1/0,i=0,a=1/0,o=0;Qs.fill(0);for(let s=0;s<t.length;++s){const{altitude:e,height:n,shadow:c}=t[s],u=e+n;n>0&&(e<r&&(r=e),c&&e<a&&(a=e),u>i&&(i=u),c&&u>o&&(o=u)),Qs[s]=c?1:0}r!==1/0?(e.minHeight.value=r,e.maxHeight.value=i):(fs(0===i),e.minHeight.value=0),a!==1/0?(e.shadowBottomHeight.value=a,e.shadowTopHeight.value=o):(fs(0===o),e.shadowBottomHeight.value=0),e.shadowLayerMask.value.fromArray(Qs)}(this.layerUniforms,this.cloudLayers);const{parameterUniforms:t}=this;t.localWeatherOffset.value.add(nc.copy(this.localWeatherVelocity).multiplyScalar(e)),t.shapeOffset.value.add(tc.copy(this.shapeVelocity).multiplyScalar(e)),t.shapeDetailOffset.value.add(tc.copy(this.shapeDetailVelocity).multiplyScalar(e));const n=this.worldToECEFMatrix;this.ecefToWorldMatrix.copy(n).invert();const r=this.camera.getWorldPosition(tc).applyMatrix4(this.worldToECEFMatrix),i=this.altitudeCorrection;this.correctAltitude?Ri(r,this.atmosphere.bottomRadius,this.ellipsoid,i):i.setScalar(0);const a=this.ellipsoid.getSurfaceNormal(r,tc),o=this.sunDirection.dot(a),s=Qn(1e6,1e3,o),c=rc.setFromMatrix4(n).transpose();this.shadowMaps.update(this.camera,tc.copy(this.sunDirection).applyMatrix3(c),s)}updateWeatherTextureChannels(){const e=this.cloudLayers.localWeatherChannels;this.cloudsPass.currentMaterial.localWeatherChannels=e,this.shadowPass.currentMaterial.localWeatherChannels=e}updateAtmosphereComposition(){const{shadowMaps:e,shadowPass:t,cloudsPass:n}=this,r=t.currentMaterial.uniforms,i=n.currentMaterial.uniforms,a=this._atmosphereOverlay,o=Object.assign(this._atmosphereOverlay??{},{map:n.outputBuffer});a!==o&&(this._atmosphereOverlay=o,lc.target=this,lc.property="atmosphereOverlay",this.events.dispatchEvent(lc));const s=this._atmosphereShadow,c=Object.assign(this._atmosphereShadow??{},{map:t.outputBuffer,mapSize:e.mapSize,cascadeCount:e.cascadeCount,intervals:i.shadowIntervals.value,matrices:i.shadowMatrices.value,inverseMatrices:r.inverseShadowMatrices.value,far:e.far,topHeight:i.shadowTopHeight.value});s!==c&&(this._atmosphereShadow=c,lc.target=this,lc.property="atmosphereShadow",this.events.dispatchEvent(lc));const u=this._atmosphereShadowLength,l=null!=n.shadowLengthBuffer?Object.assign(this._atmosphereShadowLength??{},{map:n.shadowLengthBuffer}):null;u!==l&&(this._atmosphereShadowLength=l,lc.target=this,lc.property="atmosphereShadowLength",this.events.dispatchEvent(lc))}update(e,t,n=0){var r,i,a,o;const{shadowMaps:s,shadowPass:c,cloudsPass:u}=this;if(s.cascadeCount!==this.shadowCascadeCount||!s.mapSize.equals(this.shadowMapSize)){const{width:e,height:t}=s.mapSize,n=s.cascadeCount;this.shadowMapSize.set(e,t),this.shadowCascadeCount=n,c.setSize(e,t,n),u.setShadowSize(e,t,n)}null==(r=this.proceduralLocalWeather)||r.render(e,n),null==(i=this.proceduralShape)||i.render(e,n),null==(a=this.proceduralShapeDetail)||a.render(e,n),null==(o=this.proceduralTurbulence)||o.render(e,n),++this.frame,this.updateSharedUniforms(n),this.updateWeatherTextureChannels(),c.update(e,this.frame,n),u.shadowBuffer=c.outputBuffer,u.update(e,this.frame,n),this.updateAtmosphereComposition(),this.uniforms.get("cloudsBuffer").value=this.cloudsPass.outputBuffer}setSize(e,t){const{resolution:n}=this;n.setBaseSize(e,t);const{width:r,height:i}=n;this.cloudsPass.setSize(r,i)}setDepthTexture(e,t){this.shadowPass.setDepthTexture(e,t),this.cloudsPass.setDepthTexture(e,t)}set qualityPreset(e){const{clouds:t,shadow:n,...r}=Is[e];Object.assign(this,r),Object.assign(this.clouds,t),Object.assign(this.shadow,n)}get localWeatherTexture(){return this.proceduralLocalWeather??this.parameterUniforms.localWeatherTexture.value}set localWeatherTexture(e){e instanceof $||null==e?(this.proceduralLocalWeather=void 0,this.parameterUniforms.localWeatherTexture.value=e):(this.proceduralLocalWeather=e,this.parameterUniforms.localWeatherTexture.value=e.texture)}get shapeTexture(){return this.proceduralShape??this.parameterUniforms.shapeTexture.value}set shapeTexture(e){e instanceof f||null==e?(this.proceduralShape=void 0,this.parameterUniforms.shapeTexture.value=e):(this.proceduralShape=e,this.parameterUniforms.shapeTexture.value=e.texture)}get shapeDetailTexture(){return this.proceduralShapeDetail??this.parameterUniforms.shapeDetailTexture.value}set shapeDetailTexture(e){e instanceof f||null==e?(this.proceduralShapeDetail=void 0,this.parameterUniforms.shapeDetailTexture.value=e):(this.proceduralShapeDetail=e,this.parameterUniforms.shapeDetailTexture.value=e.texture)}get turbulenceTexture(){return this.proceduralTurbulence??this.parameterUniforms.turbulenceTexture.value}set turbulenceTexture(e){e instanceof $||null==e?(this.proceduralTurbulence=void 0,this.parameterUniforms.turbulenceTexture.value=e):(this.proceduralTurbulence=e,this.parameterUniforms.turbulenceTexture.value=e.texture)}get stbnTexture(){return this.cloudsPass.currentMaterial.uniforms.stbnTexture.value}set stbnTexture(e){this.cloudsPass.currentMaterial.uniforms.stbnTexture.value=e,this.shadowPass.currentMaterial.uniforms.stbnTexture.value=e}get resolutionScale(){return this.resolution.scale}set resolutionScale(e){this.resolution.scale=e}get temporalUpscale(){return this.cloudsPass.temporalUpscale}set temporalUpscale(e){this.cloudsPass.temporalUpscale=e}get lightShafts(){return this.cloudsPass.lightShafts}set lightShafts(e){this.cloudsPass.lightShafts=e}get shapeDetail(){return this.cloudsPass.currentMaterial.shapeDetail}set shapeDetail(e){this.cloudsPass.currentMaterial.shapeDetail=e,this.shadowPass.currentMaterial.shapeDetail=e}get turbulence(){return this.cloudsPass.currentMaterial.turbulence}set turbulence(e){this.cloudsPass.currentMaterial.turbulence=e,this.shadowPass.currentMaterial.turbulence=e}get haze(){return this.cloudsPass.currentMaterial.haze}set haze(e){this.cloudsPass.currentMaterial.haze=e}get scatteringCoefficient(){return this.parameterUniforms.scatteringCoefficient.value}set scatteringCoefficient(e){this.parameterUniforms.scatteringCoefficient.value=e}get absorptionCoefficient(){return this.parameterUniforms.absorptionCoefficient.value}set absorptionCoefficient(e){this.parameterUniforms.absorptionCoefficient.value=e}get coverage(){return this.parameterUniforms.coverage.value}set coverage(e){this.parameterUniforms.coverage.value=e}get turbulenceDisplacement(){return this.parameterUniforms.turbulenceDisplacement.value}set turbulenceDisplacement(e){this.parameterUniforms.turbulenceDisplacement.value=e}get scatterAnisotropy1(){return this.cloudsPass.currentMaterial.scatterAnisotropy1}set scatterAnisotropy1(e){this.cloudsPass.currentMaterial.scatterAnisotropy1=e}get scatterAnisotropy2(){return this.cloudsPass.currentMaterial.scatterAnisotropy2}set scatterAnisotropy2(e){this.cloudsPass.currentMaterial.scatterAnisotropy2=e}get scatterAnisotropyMix(){return this.cloudsPass.currentMaterial.scatterAnisotropyMix}set scatterAnisotropyMix(e){this.cloudsPass.currentMaterial.scatterAnisotropyMix=e}get skyIrradianceScale(){return this.skyLightScale}set skyIrradianceScale(e){this.skyLightScale=e}get skyLightScale(){return this.cloudsPass.currentMaterial.uniforms.skyLightScale.value}set skyLightScale(e){this.cloudsPass.currentMaterial.uniforms.skyLightScale.value=e}get groundIrradianceScale(){return this.groundBounceScale}set groundIrradianceScale(e){this.groundBounceScale=e}get groundBounceScale(){return this.cloudsPass.currentMaterial.uniforms.groundBounceScale.value}set groundBounceScale(e){this.cloudsPass.currentMaterial.uniforms.groundBounceScale.value=e}get powderScale(){return this.cloudsPass.currentMaterial.uniforms.powderScale.value}set powderScale(e){this.cloudsPass.currentMaterial.uniforms.powderScale.value=e}get powderExponent(){return this.cloudsPass.currentMaterial.uniforms.powderExponent.value}set powderExponent(e){this.cloudsPass.currentMaterial.uniforms.powderExponent.value=e}get atmosphereOverlay(){return this._atmosphereOverlay}get atmosphereShadow(){return this._atmosphereShadow}get atmosphereShadowLength(){return this._atmosphereShadowLength}get irradianceTexture(){return this.cloudsPass.currentMaterial.irradianceTexture}set irradianceTexture(e){this.cloudsPass.currentMaterial.irradianceTexture=e}get scatteringTexture(){return this.cloudsPass.currentMaterial.scatteringTexture}set scatteringTexture(e){this.cloudsPass.currentMaterial.scatteringTexture=e}get transmittanceTexture(){return this.cloudsPass.currentMaterial.transmittanceTexture}set transmittanceTexture(e){this.cloudsPass.currentMaterial.transmittanceTexture=e}get singleMieScatteringTexture(){return this.cloudsPass.currentMaterial.singleMieScatteringTexture}set singleMieScatteringTexture(e){this.cloudsPass.currentMaterial.singleMieScatteringTexture=e}get higherOrderScatteringTexture(){return this.cloudsPass.currentMaterial.higherOrderScatteringTexture}set higherOrderScatteringTexture(e){this.cloudsPass.currentMaterial.higherOrderScatteringTexture=e}get ellipsoid(){return this.cloudsPass.currentMaterial.ellipsoid}set ellipsoid(e){this.cloudsPass.currentMaterial.ellipsoid=e}get sunAngularRadius(){return this.cloudsPass.currentMaterial.sunAngularRadius}set sunAngularRadius(e){this.cloudsPass.currentMaterial.sunAngularRadius=e}}((e,t,n)=>{for(var r,i=void 0,a=e.length-1;a>=0;a--)(r=e[a])&&(i=r(t,n,i)||i);i&&ec(t,n,i)})([tr("SKIP_RENDERING")],dc.prototype,"skipRendering");const mc=128,pc=32;export{me as C,er as E,Wo as F,Kr as H,Li as L,no as N,ro as O,xo as U,ni as V,Lo as X,Oo as a,ue as b,$o as c,dc as d,Jn as e,pc as f,fe as g,Qa as h,ei as o,mc as r,Yo as u,ve as v};
