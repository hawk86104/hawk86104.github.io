import{m as n,e,a as t,o as r,f as o}from"./@tresjs.xCsT8yve1742895693222.js";import{P as i}from"./tweakpane.ivGeiIdz1742895693222.js";import{_ as c,c as a,a_ as l,l as s,aR as u,C as f,m as p,u as v,n as g}from"./three.DqHgeVY11742895693222.js";import{d,a3 as x,b as h,o as m,f as y,u as w,g as b,j as I,al as R,r as C,N as _,aj as z,ak as M}from"./@vue.C4dqouNn1742895693222.js";import"./postprocessing.vTwfsnPH1742895693222.js";import"./@vueuse.q8TRDI1e1742895693222.js";var D="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";!function(n,e){const t=O,r=A();for(;;)try{if(898174===parseInt(t(154))/1*(parseInt(t(141))/2)+-parseInt(t(186))/3*(-parseInt(t(169))/4)+parseInt(t(160))/5*(parseInt(t(140))/6)+-parseInt(t(138))/7*(-parseInt(t(151))/8)+-parseInt(t(136))/9+parseInt(t(172))/10*(parseInt(t(161))/11)+-parseInt(t(137))/12*(parseInt(t(152))/13))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function A(){const n=["length","error","110973Ikwlob","3235887FIuOiz","108972AUIZvL","326809IiQtrz","position","6hkRtQO","4dzbUBn","uniforms","waterTexture","FrontSide","exception","apply","stateObject","__proto__","causticTex","console","112tdvSTv","2171fHKmtZ","chain","271562QphzXM","table",'{}.constructor("return this")( )',"trace","return (function() ","test","994135gBoknY","99cPmSro","action","BufferGeometry","render","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","setIndex","gger","setAttribute","40oDHdeR","tiles","log","1120850egieHU","constructor","debu","value","string","prototype","counter","info","water","while (true) {}","toString","bind"];return(A=function(){return n})()}!function(){T(this,(function(){const n=O,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(165),"i"),r=F("init");e[n(159)](r+n(153))&&t[n(159)](r+"input")?F():r("0")}))()}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[O(146)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function O(n,e){const t=A();return O=function(n,e){return t[n-=136]},O(n,e)}L(void 0,(function(){const n=O,e=function(){const n=O;let e;try{e=Function(n(158)+n(156)+");")()}catch(t){e=window}return e}(),t=e[n(150)]=e[n(150)]||{},r=[n(171),"warn",n(179),n(185),n(145),n(155),n(157)];for(let o=0;o<r[n(184)];o++){const e=L[n(173)][n(177)][n(183)](L),i=r[o],c=t[i]||e;e[n(148)]=L[n(183)](L),e[n(182)]=c[n(182)][n(183)](c),t[i]=e}}))();const E=d({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=O,o=t,i=new(c[r(163)]),u=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),f=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(168)](r(139),new a(u,3)),i[r(166)](new a(f,1));const p=new l({uniforms:{light:{value:o.light},tiles:{value:o[r(170)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(144)]}),v=new s(i,p),{renderer:g,camera:d}=n(),{onAfterLoop:x}=e();return x((()=>{((n,e)=>{const t=r;p.uniforms[t(180)][t(175)]=n,p[t(142)][t(149)][t(175)]=e,g[t(175)][t(164)](v,d.value)})(o[r(143)],o.causticsTexture)})),(n,e)=>null}});function F(n){function e(n){const t=O;if(typeof n===t(176))return function(n){}.constructor(t(181))[t(146)](t(178));1!==(""+n/n)[t(184)]||n%20==0?function(){return!0}[t(173)](t(174)+t(167)).call(t(162)):function(){return!1}[t(173)]("debu"+t(167))[t(146)](t(147)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const S=k;!function(n,e){const t=k,r=W();for(;;)try{if(595116===parseInt(t(367))/1*(-parseInt(t(339))/2)+parseInt(t(360))/3+parseInt(t(330))/4*(parseInt(t(391))/5)+-parseInt(t(376))/6+parseInt(t(392))/7*(parseInt(t(378))/8)+parseInt(t(338))/9+-parseInt(t(357))/10*(parseInt(t(374))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[k(341)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){j(this,(function(){const n=k,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(359),"i"),r=N(n(342));e[n(350)](r+n(336))&&t.test(r+n(371))?N():r("0")}))()}();const P=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[k(341)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function W(){const n=["3610muQQsA","pooRef","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","1773363jqaeEl","debu",'{}.constructor("return this")( )',"https://opensource.cdn.icegl.cn","tiles","load","counter","30542DBtgSH","while (true) {}","value","__proto__","input","gger","FrontSide","19921MLcCWP","water","3330288tSDubC","pos-x.jpg","8240XgsErf","causticTex","Mesh","action","/images/skyBox/6jpg/","RawShaderMaterial","setClearColor","pos-y.jpg","causticsTexture","white","resource.cos","toString","trace","4760RmIZCS","6930lNZRCc","stateObject","light","geometry","string","setRenderTarget","length","4FTsSzL","underwater","bind","side","prototype","render","chain","uniforms","5302872xfYIoO","26msIlmg","clear","apply","init","BackSide","table","waterTexture","info","exception","neg-z.jpg","setPath","test","log","pos-z.jpg","call","console","error","constructor"];return(W=function(){return n})()}function k(n,e){const t=W();return k=function(n,e){return t[n-=325]},k(n,e)}P(void 0,(function(){const n=k;let e;try{e=Function("return (function() "+n(362)+");")()}catch(o){e=window}const t=e[n(354)]=e.console||{},r=[n(351),"warn",n(346),n(355),n(347),n(344),n(390)];for(let i=0;i<r[n(329)];i++){const e=P[n(356)][n(334)].bind(P),o=r[i],c=t[o]||e;e[n(370)]=P[n(332)](P),e.toString=c[n(389)][n(332)](c),t[o]=e}}))();const H=d({__name:S(375),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=S;let i,a;const l=r,s=l[o(326)],p=(new u)[o(349)](o(363)+o(382))[o(365)]([o(377),"neg-x.jpg",o(385),"neg-y.jpg",o(352),o(348)]),v=([i,a]=x((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),g=new(c[o(383)])({uniforms:{light:{value:l[o(325)]},tiles:{value:v},sky:{value:p},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),d=new(c[o(380)])(s,g),b=h(null),I=new f(o(387)),{renderer:R,camera:C}=n(),{onLoop:_}=e();return _((()=>{const n=o;R[n(369)][n(328)](null),R[n(369)][n(384)](I,1),R[n(369)][n(340)](),g[n(337)].water.value=l[n(345)],g[n(337)][n(379)].value=l[n(386)],g[n(333)]=c[n(373)],g.uniforms[n(331)][n(369)]=!0,R[n(369)][n(335)](d,C.value),g.side=c[n(343)],g[n(337)].underwater[n(369)]=!1,R[n(369)][n(335)](d,C[n(369)])})),(n,e)=>{const t=o;return m(),y(E,{tiles:w(v),light:n[t(325)],waterTexture:n[t(345)],causticsTexture:n[t(386)],ref_key:t(358),ref:b},null,8,[t(364),t(325),t(345),t(386)])}}});function N(n){function e(n){const t=k;if(typeof n===t(327))return function(n){}[t(356)](t(368))[t(341)](t(366));1!==(""+n/n)[t(329)]||n%20==0?function(){return!0}[t(356)](t(361)+"gger")[t(353)](t(381)):function(){return!1}[t(356)]("debu"+t(372)).apply(t(393)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=G,r=B();for(;;)try{if(568045===parseInt(t(192))/1*(parseInt(t(206))/2)+-parseInt(t(201))/3*(-parseInt(t(212))/4)+parseInt(t(202))/5+parseInt(t(237))/6+parseInt(t(207))/7*(-parseInt(t(223))/8)+parseInt(t(205))/9*(-parseInt(t(211))/10)+parseInt(t(200))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const V=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[G(220)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){V(this,(function(){const n=G,e=new RegExp(n(233)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=Q(n(198));e.test(r+"chain")&&t[n(217)](r+n(236))?Q():r("0")}))()}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[G(220)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function B(){const n=["14188TcIutQ","texture","error","debu","bind","test","stateObject","clear","apply","material","call","7989136pTbZIQ","table","action","waterTexture","render","__proto__","string","toString","warn","length","function *\\( *\\)","info","return (function() ","input","6365970jPptUx","constructor","water","prototype","3zEkCxG",'{}.constructor("return this")( )',"Mesh","OrthographicCamera","gger","trace","init","setRenderTarget","3911743TBuTxL","42JRYHcj","148390cmjOJv","value","console","972sLvJIw","139826iRJdtU","7PJMFNX","light","counter","causticsTexture","12870LEIFfS"];return(B=function(){return n})()}function G(n,e){const t=B();return G=function(n,e){return t[n-=189]},G(n,e)}Z(void 0,(function(){const n=G,e=function(){const n=G;let e;try{e=Function(n(235)+n(193)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(204)]||{},r=["log",n(231),n(234),n(214),"exception",n(224),n(197)];for(let o=0;o<r.length;o++){const e=Z[n(189)][n(191)][n(216)](Z),i=r[o],c=t[i]||e;e[n(228)]=Z.bind(Z),e.toString=c[n(230)][n(216)](c),t[i]=e}}))();const $=d({__name:"caustics",props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=G,o=t,i=new(c[r(195)])(0,1,1,0,0,2e3),a=new p(2,2,200,200),l=new v(1024,1024),s=new g({uniforms:{light:{value:o[r(208)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),u=new(c[r(194)])(a,s),d=new f("black"),{renderer:x}=n(),{onBeforeLoop:h}=e();return h((()=>{const n=r;u[n(221)].uniforms[n(190)].value=o[n(226)],x[n(203)][n(199)](l),x[n(203)].setClearColor(d,0),x[n(203)][n(219)](),x[n(203)][n(227)](u,i)})),(n,e)=>{const t=r;return m(),y(R,null,{default:b((()=>[I(H,{waterTexture:n.waterTexture,causticsTexture:w(l)[t(213)],light:n[t(208)],geometry:w(a)},null,8,[t(226),t(210),"light","geometry"])])),_:1})}}});function Q(n){function e(n){const t=G;if(typeof n===t(229))return function(n){}.constructor("while (true) {}")[t(220)](t(209));1!==(""+n/n)[t(232)]||n%20==0?function(){return!0}.constructor(t(215)+t(196))[t(222)](t(225)):function(){return!1}[t(189)]("debu"+t(196))[t(220)](t(218)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=Y,r=X();for(;;)try{if(622706===parseInt(t(553))/1*(parseInt(t(535))/2)+-parseInt(t(515))/3*(-parseInt(t(545))/4)+-parseInt(t(536))/5+parseInt(t(533))/6+-parseInt(t(543))/7+parseInt(t(542))/8*(parseInt(t(510))/9)+parseInt(t(511))/10*(-parseInt(t(564))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const J=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Y(527)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){J(this,(function(){const n=Y,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(554),"i"),r=K(n(522));e.test(r+n(500))&&t.test(r+n(501))?K():r("0")}))()}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Y(n,e){const t=X();return Y=function(n,e){return t[n-=500]},Y(n,e)}function X(){const n=["return (function() ","RawShaderMaterial","gger","center","1887512mFTfgG","420105wzfyNE","lightFrontGeometry","4xuBAWB","call","material","WebGLRenderTarget","clientY","uniforms","Vector2","table","151dNcEoy","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","clientX","warn","FloatType","domElement","needsUpdate","setFromCamera","length","position","prototype","1191531CXdlOc","point","chain","input","toString","debu","height","exception","Mesh",'{}.constructor("return this")( )',"left","removeEventListener","9umnZsB","10rEVgNy","texture","autoClear","bind","125991imSAoP","stateObject","radius","string","error","PlaneGeometry","action","init","constructor","strength","addEventListener","trace","apply","width","OrthographicCamera","value","console","light","1010418PfAypg","getY","12074yiNCGg","2834420oozgHL","render"];return(X=function(){return n})()}U(void 0,(function(){const n=Y;let e;try{e=Function(n(538)+n(507)+");")()}catch(o){e=window}const t=e[n(531)]=e[n(531)]||{},r=["log",n(556),"info",n(519),n(505),n(552),n(526)];for(let i=0;i<r[n(561)];i++){const e=U[n(523)][n(563)][n(514)](U),o=r[i],c=t[o]||e;e.__proto__=U[n(514)](U),e.toString=c[n(502)].bind(c),t[o]=e}}))();const q=d({__name:"waterSimulation",props:{light:{}},setup(t,{expose:r}){const o=Y,i=new(c[o(529)])(0,1,1,0,0,2e3),a=new(c[o(520)])(2,2),l=new(c[o(548)])(256,256,{type:c[o(557)]}),u=new v(256,256,{type:c[o(557)]}),f=new(c[o(539)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),p=new(c[o(539)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),g=new(c[o(539)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),d=new s(a,f),x=new(c[o(506)])(a,p),h=new(c[o(506)])(a,g);let b=l;const I=(n,e)=>{const t=o,r=b,c=b===l?u:l;e[t(547)][t(550)][t(512)][t(530)]=r[t(512)],n.setRenderTarget(c),n[t(537)](e,i),b=c},{renderer:R,camera:C,raycaster:_}=n();R[o(530)][o(513)]=!1;const{onBeforeLoop:z}=e();z((()=>{const n=o;var e,t;t=R[n(530)],I(t,h),e=R[n(530)],I(e,x)}));const M=(n,e,t,r)=>{const i=o;d[i(547)][i(550)][i(541)].value=[n,e],d[i(547)][i(550)][i(517)][i(530)]=t,d[i(547)][i(550)][i(524)][i(530)]=r,I(R[i(530)],d)},T=new(c[o(551)]),A=new(c[o(520)])(2,2),L=A.attributes[o(562)];for(let n=0;n<L.count;n++){const e=-L[o(534)](n);L.setY(n,0),L.setZ(n,e)}L[o(559)]=!0;const O=new(c[o(506)])(A),E={handleEvent:n=>{const e=o,t=R[e(530)].domElement.getBoundingClientRect(),r=t[e(528)],i=t[e(504)];T.x=2*(n[e(555)]-t[e(508)])/r-1,T.y=2*-(n[e(549)]-t.top)/i+1,_[e(530)][e(560)](T,C[e(530)]);const c=_.value.intersectObject(O);for(let o of c)M(o[e(565)].x,o[e(565)].z,.03,.04)}};return r({addDrop:M,mouseEvent:n=>{const e=o;n?R.value[e(558)][e(525)]("mousemove",E):R[e(530)].domElement[e(509)]("mousemove",E)}}),(n,e)=>{const t=o;return m(),y($,{lightFrontGeometry:w(a),waterTexture:w(b).texture,light:n[t(532)]},null,8,[t(544),"waterTexture",t(532)])}}});function K(n){function e(n){const t=Y;if(typeof n===t(518))return function(n){}[t(523)]("while (true) {}")[t(527)]("counter");1!==(""+n/n)[t(561)]||n%20==0?function(){return!0}[t(523)](t(503)+t(540))[t(546)](t(521)):function(){return!1}.constructor(t(503)+"gger")[t(527)](t(516)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const nn=rn;!function(n,e){const t=rn,r=on();for(;;)try{if(707517===parseInt(t(325))/1*(-parseInt(t(316))/2)+-parseInt(t(334))/3*(-parseInt(t(333))/4)+parseInt(t(348))/5+-parseInt(t(326))/6+parseInt(t(353))/7+-parseInt(t(349))/8+parseInt(t(342))/9*(parseInt(t(336))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[rn(328)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){en(this,(function(){const n=rn,e=new RegExp(n(358)),t=new RegExp(n(319),"i"),r=an(n(317));e[n(312)](r+n(318))&&t[n(312)](r+n(332))?an():r("0")}))()}();const tn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function rn(n,e){const t=on();return rn=function(n,e){return t[n-=312]},rn(n,e)}function on(){const n=["stateObject","trace","prototype","72173NWszgP","634704ahGiGx","随机增加波纹","apply","console","info","click","input","258116lGNDGF","39mNRsDf","change","4210cNurAJ","debu","while (true) {}","__proto__","addButton","counter","12681DtwfCq","toString","realWater","addBinding","random","TresPerspectiveCamera","1644680YofmuQ","10729936uEAszJ","action","return (function() ","value","8817319KojjGf","gger","log",'{}.constructor("return this")( )',"call","function *\\( *\\)","warn","test","exception","length","constructor","24nigiEc","init","chain","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","点击按钮","addDrop"];return(on=function(){return n})()}tn(void 0,(function(){const n=rn,e=function(){const n=rn;let e;try{e=Function(n(351)+n(356)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(329)]||{},r=[n(355),n(359),n(330),"error",n(313),"table",n(323)];for(let o=0;o<r[n(314)];o++){const e=tn[n(315)][n(324)].bind(tn),i=r[o],c=t[i]||e;e[n(339)]=tn.bind(tn),e[n(343)]=c.toString.bind(c),t[i]=e}}))();const cn=d({__name:nn(344),setup(n){const e=nn,t=C({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:"manual"}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=h(null),l=new i;l[e(340)]({label:e(320),title:e(327)}).on(e(331),(()=>{const n=e;for(var t=0;t<10;t++)a.value[n(321)](2*Math.random()-1,2*Math[n(346)]()-1,.03,1&t?.02:-.02)}));const s=h(!1);return l[e(345)](s,e(352),{label:"鼠标波纹"}).on(e(335),(n=>{const t=e;a[t(352)].mouseEvent(n[t(352)])})),(n,i)=>{const l=e;return m(),y(w(o),z(M(t)),{default:b((()=>[i[0]||(i[0]=_(l(347),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),I(w(r)),I(q,{light:c,ref_key:"waterSimulationRef",ref:a},null,512)])),_:1},16)}}});function an(n){function e(n){const t=rn;if("string"==typeof n)return function(n){}[t(315)](t(338))[t(328)](t(341));1!==(""+n/n)[t(314)]||n%20==0?function(){return!0}.constructor(t(337)+t(354))[t(357)](t(350)):function(){return!1}[t(315)]("debu"+t(354)).apply(t(322)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{cn as default};
