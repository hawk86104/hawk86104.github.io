import{m as n,e,a as t,o as r,f as o}from"./@tresjs.G4idgyWs1738919103432.js";import{P as i}from"./tweakpane.yDiyAAkA1738919103432.js";import{B as c,c as a,_ as l,aW as s,aM as u,y as f,r as p,V as v}from"./three.CYhYNU4g1738919103432.js";import{d as g,a3 as d,b as x,o as h,f as m,u as y,g as w,j as b,al as I,r as R,N as C,aj as _,ak as z}from"./@vue.NRI7TcgI1738919103432.js";import"./@vueuse.DL3Lluw_1738919103432.js";var M="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";!function(n,e){const t=L,r=A();for(;;)try{if(203815===-parseInt(t(282))/1+-parseInt(t(288))/2+parseInt(t(289))/3*(-parseInt(t(283))/4)+-parseInt(t(291))/5*(parseInt(t(263))/6)+-parseInt(t(261))/7*(parseInt(t(280))/8)+-parseInt(t(279))/9*(-parseInt(t(257))/10)+parseInt(t(272))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const D=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){D(this,(function(){const n=L,e=new RegExp(n(269)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=F("init");e[n(296)](r+"chain")&&t[n(296)](r+n(253))?F():r("0")}))()}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[L(268)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function A(){const n=["2550891zHkbBp","FrontSide","72tOhcIA","tiles","gger","exception","counter","apply","function *\\( *\\)","toString","warn","9217857npCbSZ","debu","table",'{}.constructor("return this")( )',"uniforms","position","bind","9XSEiSG","8bKUsVg","Mesh","284887tvptkK","3308TtPSkA","value","while (true) {}","causticTex","string","37790NbmziA","618wDVJlU","waterTexture","15620wfPPYI","trace","length","prototype","causticsTexture","test","constructor","action","return (function() ","input","BufferAttribute","render","call","2418730RmliDH","setIndex","info","stateObject"];return(A=function(){return n})()}function L(n,e){const t=A();return(L=function(n,e){return t[n-=251]})(n,e)}T(void 0,(function(){const n=L,e=function(){const n=L;let e;try{e=Function(n(252)+n(275)+");")()}catch(t){e=window}return e}(),t=e.console=e.console||{},r=["log",n(271),n(259),"error",n(266),n(274),n(292)];for(let o=0;o<r[n(293)];o++){const e=T.constructor[n(294)][n(278)](T),i=r[o],c=t[i]||e;e.__proto__=T[n(278)](T),e[n(270)]=c[n(270)][n(278)](c),t[i]=e}}))();const O=g({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=L,o=t,i=new c,u=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),f=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i.setAttribute(r(277),new a(u,3)),i[r(258)](new(l[r(254)])(f,1));const p=new s({uniforms:{light:{value:o.light},tiles:{value:o[r(264)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:l[r(262)]}),v=new(l[r(281)])(i,p),{renderer:g,camera:d}=n(),{onAfterLoop:x}=e();return x((()=>{const n=r;((n,e)=>{const t=r;p.uniforms.water[t(284)]=n,p[t(276)][t(286)][t(284)]=e,g[t(284)][t(255)](v,d[t(284)])})(o[n(290)],o[n(295)])})),(n,e)=>null}});function F(n){function e(n){const t=L;if(typeof n===t(287))return function(n){}[t(297)](t(285))[t(268)](t(267));1!==(""+n/n)[t(293)]||n%20==0?function(){return!0}[t(297)](t(273)+"gger")[t(256)](t(251)):function(){return!1}.constructor(t(273)+t(265))[t(268)](t(260)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const S=P;!function(n,e){const t=P,r=W();for(;;)try{if(917419===parseInt(t(286))/1*(parseInt(t(302))/2)+parseInt(t(321))/3*(-parseInt(t(313))/4)+parseInt(t(314))/5+-parseInt(t(299))/6+parseInt(t(317))/7*(parseInt(t(293))/8)+parseInt(t(296))/9*(-parseInt(t(273))/10)+parseInt(t(288))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const E=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(274)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){E(this,(function(){const n=P,e=new RegExp(n(295)),t=new RegExp(n(329),"i"),r=V(n(292));e[n(309)](r+n(308))&&t[n(309)](r+n(301))?V():r("0")}))()}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(274)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function P(n,e){const t=W();return(P=function(n,e){return t[n-=269]})(n,e)}function W(){const n=["Color","geometry","setPath","BackSide","3454680dILipz","apply","setRenderTarget","constructor","light",'{}.constructor("return this")( )',"bind","RawShaderMaterial","setClearColor","gger","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","counter","side","7589YroDDn","table","25412057vbTfoK","waterTexture","causticTex","neg-y.jpg","init","3011776EVbqBT","prototype","function *\\( *\\)","36LshLLG","render","string","1345998OmszEV","pooRef","input","52GoQijX","length","toString","return (function() ","causticsTexture","warn","chain","test","while (true) {}","value","neg-x.jpg","788HAKSem","3068070dPTqiv","debu","log","14nuwzrd","underwater","white","uniforms","20565XrgYKZ","exception","water","Mesh","call","pos-z.jpg","console","action","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","stateObject","neg-z.jpg"];return(W=function(){return n})()}j(void 0,(function(){const n=P,e=function(){const n=P;let e;try{e=Function(n(305)+n(278)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(327)]||{},r=[n(316),n(307),"info","error",n(322),n(287),"trace"];for(let o=0;o<r.length;o++){const e=j[n(276)][n(294)][n(279)](j),i=r[o],c=t[i]||e;e.__proto__=j.bind(j),e[n(304)]=c.toString[n(279)](c),t[i]=e}}))();const H=g({__name:S(323),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=S;let i,c;const a=r,s=a[o(270)],p=(new u)[o(271)](o(283)).load(["pos-x.jpg",o(312),"pos-y.jpg",o(291),o(326),o(331)]),v=([i,c]=d((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,c(),i),g=new(l[o(280)])({uniforms:{light:{value:a[o(277)]},tiles:{value:v},sky:{value:p},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),w=new(l[o(324)])(s,g),b=x(null),I=new(l[o(269)])(o(319)),{renderer:R,camera:C}=n(),{onLoop:_}=e();return _((()=>{const n=o;R[n(311)][n(275)](null),R[n(311)][n(281)](I,1),R.value.clear(),g[n(320)][n(323)].value=a[n(289)],g[n(320)][n(290)][n(311)]=a[n(306)],g[n(285)]=f,g[n(320)][n(318)][n(311)]=!0,R[n(311)][n(297)](w,C[n(311)]),g[n(285)]=l[n(272)],g.uniforms[n(318)][n(311)]=!1,R.value.render(w,C[n(311)])})),(n,e)=>{const t=o;return h(),m(O,{tiles:y(v),light:n[t(277)],waterTexture:n[t(289)],causticsTexture:n.causticsTexture,ref_key:t(300),ref:b},null,8,["tiles",t(277),"waterTexture",t(306)])}}});function V(n){function e(n){const t=P;if(typeof n===t(298))return function(n){}.constructor(t(310))[t(274)](t(284));1!==(""+n/n)[t(303)]||n%20==0?function(){return!0}[t(276)](t(315)+t(282))[t(325)](t(328)):function(){return!1}[t(276)]("debu"+t(282)).apply(t(330)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function k(){const n=["exception","2475720EKxYqH","Color","geometry","180166PrzwEB","light","gger","info","constructor","448542XSyWTo","OrthographicCamera","init","uniforms","material","return (function() ","5gwIsFd","water","toString","9peZKYl","stateObject","length","call","black","PlaneGeometry","apply","counter","prototype","ShaderMaterial","442118tAYNFJ","function *\\( *\\)","value","3rNAOBD","debu","console","setRenderTarget","string","Mesh","log","WebGLRenderTarget","texture","147497PDYDrc","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","table","22360PZSATj","bind","waterTexture","__proto__","305120zlFIYQ","test","clear","warn","action",'{}.constructor("return this")( )',"render","chain"];return(k=function(){return n})()}!function(n,e){const t=B,r=k();for(;;)try{if(117245===parseInt(t(488))/1+-parseInt(t(476))/2*(parseInt(t(479))/3)+parseInt(t(491))/4+parseInt(t(518))/5*(-parseInt(t(512))/6)+-parseInt(t(507))/7+parseInt(t(495))/8+-parseInt(t(521))/9*(-parseInt(t(504))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[B(527)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Z(this,(function(){const n=B,e=new RegExp(n(477)),t=new RegExp(n(489),"i"),r=G(n(514));e[n(496)](r+n(502))&&t[n(496)](r+"input")?G():r("0")}))()}();const N=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[B(527)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function B(n,e){const t=k();return(B=function(n,e){return t[n-=473]})(n,e)}N(void 0,(function(){const n=B;let e;try{e=Function(n(517)+n(500)+");")()}catch(o){e=window}const t=e[n(481)]=e[n(481)]||{},r=[n(485),n(498),n(510),"error",n(503),n(490),"trace"];for(let i=0;i<r.length;i++){const e=N[n(511)][n(474)][n(492)](N),o=r[i],c=t[o]||e;e[n(494)]=N[n(492)](N),e[n(520)]=c[n(520)].bind(c),t[o]=e}}))();const Y=g({__name:"caustics",props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=B,o=t,i=new(l[r(513)])(0,1,1,0,0,2e3),c=new(l[r(526)])(2,2,200,200),a=new(l[r(486)])(1024,1024),s=new(l[r(475)])({uniforms:{light:{value:o.light},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),u=new(l[r(484)])(c,s),f=new(l[r(505)])(r(525)),{renderer:p}=n(),{onBeforeLoop:v}=e();return v((()=>{const n=r;u[n(516)][n(515)][n(519)][n(478)]=o.waterTexture,p[n(478)][n(482)](a),p.value.setClearColor(f,0),p[n(478)][n(497)](),p[n(478)][n(501)](u,i)})),(n,e)=>{const t=r;return h(),m(I,null,{default:w((()=>[b(H,{waterTexture:n[t(493)],causticsTexture:y(a)[t(487)],light:n[t(508)],geometry:y(c)},null,8,[t(493),"causticsTexture",t(508),t(506)])])),_:1})}}});function G(n){function e(n){const t=B;if(typeof n===t(483))return function(n){}[t(511)]("while (true) {}")[t(527)](t(473));1!==(""+n/n)[t(523)]||n%20==0?function(){return!0}[t(511)](t(480)+t(509))[t(524)](t(499)):function(){return!1}[t(511)](t(480)+"gger")[t(527)](t(522)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=q,r=X();for(;;)try{if(275120===parseInt(t(167))/1*(parseInt(t(123))/2)+-parseInt(t(155))/3+parseInt(t(154))/4+parseInt(t(153))/5*(-parseInt(t(175))/6)+parseInt(t(124))/7+parseInt(t(140))/8*(-parseInt(t(180))/9)+parseInt(t(112))/10*(parseInt(t(178))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const $=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(118)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){$(this,(function(){const n=q,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(115),"i"),r=J(n(146));e[n(141)](r+n(150))&&t.test(r+n(152))?J():r("0")}))()}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(118)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function X(){const n=["strength","domElement","intersectObject","toString","string","39632dIbImR","test","table","error","stateObject","call","init","getY","length","console","chain","info","input","715495RzsPsi","12160ItwDHV","434511RTlTyO","bind","RawShaderMaterial","attributes","uniforms","counter","count","material","texture","mousemove","light","clientY","63813XKHcYa","Mesh","setRenderTarget","return (function() ","render","radius","__proto__","while (true) {}","12uGylgl","warn","debu","11LeaIIX","PlaneGeometry","432QXCmGk","position","height","needsUpdate","OrthographicCamera","action","value","WebGLRenderTarget","3621070outOPS","getBoundingClientRect","FloatType","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","trace","removeEventListener","apply","constructor","waterTexture","lightFrontGeometry","prototype","2fmsdjP","3604909DczwoO","gger","setFromCamera","autoClear",'{}.constructor("return this")( )',"addEventListener","log","setZ","clientX","point","left"];return(X=function(){return n})()}function q(n,e){const t=X();return(q=function(n,e){return t[n-=110]})(n,e)}K(void 0,(function(){const n=q;let e;try{e=Function(n(170)+n(128)+");")()}catch(o){e=window}const t=e[n(149)]=e[n(149)]||{},r=[n(130),n(176),n(151),n(143),"exception",n(142),n(116)];for(let i=0;i<r[n(148)];i++){const e=K[n(119)][n(122)][n(156)](K),o=r[i],c=t[o]||e;e[n(173)]=K[n(156)](K),e[n(138)]=c[n(138)][n(156)](c),t[o]=e}}))();const U=g({__name:"waterSimulation",props:{light:{}},setup(t,{expose:r}){const o=q,i=new(l[o(184)])(0,1,1,0,0,2e3),c=new(l[o(179)])(2,2),a=new(l[o(111)])(256,256,{type:l[o(114)]}),s=new(l[o(111)])(256,256,{type:l[o(114)]}),u=new(l[o(157)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),f=new(l[o(157)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),g=new(l[o(157)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),d=new(l[o(168)])(c,u),x=new p(c,f),w=new(l[o(168)])(c,g);let b=a;const I=(n,e)=>{const t=o,r=b,c=b===a?s:a;e[t(162)][t(159)].texture[t(110)]=r.texture,n[t(169)](c),n[t(171)](e,i),b=c},{renderer:R,camera:C,raycaster:_}=n();R[o(110)][o(127)]=!1;const{onBeforeLoop:z}=e();z((()=>{const n=o;var e,t;t=R.value,I(t,w),e=R[n(110)],I(e,x)}));const D=(n,e,t,r)=>{const i=o;d[i(162)][i(159)].center[i(110)]=[n,e],d.material.uniforms[i(172)][i(110)]=t,d[i(162)][i(159)][i(135)][i(110)]=r,I(R[i(110)],d)},T=new v,A=new(l[o(179)])(2,2),L=A[o(158)][o(181)];for(let n=0;n<L[o(161)];n++){const e=-L[o(147)](n);L.setY(n,0),L[o(131)](n,e)}L[o(183)]=!0;const O=new(l[o(168)])(A),F={handleEvent:n=>{const e=o,t=R[e(110)][e(136)][e(113)](),r=t.width,i=t[e(182)];T.x=2*(n[e(132)]-t[e(134)])/r-1,T.y=2*-(n[e(166)]-t.top)/i+1,_.value[e(126)](T,C[e(110)]);const c=_[e(110)][e(137)](O);for(let o of c)D(o[e(133)].x,o[e(133)].z,.03,.04)}};return r({addDrop:D,mouseEvent:n=>{const e=o;n?R[e(110)].domElement[e(129)](e(164),F):R[e(110)][e(136)][e(117)](e(164),F)}}),(n,e)=>{const t=o;return h(),m(Y,{lightFrontGeometry:y(c),waterTexture:y(b)[t(163)],light:n.light},null,8,[t(121),t(120),t(165)])}}});function J(n){function e(n){const t=q;if(typeof n===t(139))return function(n){}.constructor(t(174))[t(118)](t(160));1!==(""+n/n)[t(148)]||n%20==0?function(){return!0}[t(119)](t(177)+t(125))[t(145)](t(185)):function(){return!1}.constructor(t(177)+t(125))[t(118)](t(144)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const Q=tn;!function(n,e){const t=tn,r=cn();for(;;)try{if(316401===-parseInt(t(374))/1+parseInt(t(360))/2*(-parseInt(t(348))/3)+-parseInt(t(337))/4+parseInt(t(362))/5*(-parseInt(t(382))/6)+parseInt(t(343))/7+-parseInt(t(368))/8+parseInt(t(384))/9*(parseInt(t(375))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(370)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){nn(this,(function(){const n=tn,e=new RegExp(n(364)),t=new RegExp(n(366),"i"),r=on(n(359));e[n(381)](r+n(361))&&t[n(381)](r+n(350))?on():r("0")}))()}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(370)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function tn(n,e){const t=cn();return(tn=function(n,e){return t[n-=337]})(n,e)}en(void 0,(function(){const n=tn,e=function(){const n=tn;let e;try{e=Function(n(373)+n(379)+");")()}catch(t){e=window}return e}(),t=e[n(363)]=e[n(363)]||{},r=[n(342),"warn",n(380),n(372),"exception",n(367),"trace"];for(let o=0;o<r[n(365)];o++){const e=en[n(377)][n(341)][n(339)](en),i=r[o],c=t[i]||e;e.__proto__=en.bind(en),e[n(346)]=c.toString[n(339)](c),t[i]=e}}))();const rn=g({__name:Q(383),setup(n){const e=Q,t=R({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(340)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=x(null),l=new i;l[e(386)]({label:e(385),title:e(378)}).on(e(351),(()=>{const n=e;for(var t=0;t<10;t++)a.value[n(376)](2*Math[n(349)]()-1,2*Math[n(349)]()-1,.03,1&t?.02:-.02)}));const s=x(!1);return l[e(369)](s,e(338),{label:"鼠标波纹"}).on(e(354),(n=>{const t=e;a[t(338)][t(344)](n[t(338)])})),(n,i)=>{const l=e;return h(),m(y(o),_(z(t)),{default:w((()=>[i[0]||(i[0]=C(l(347),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),b(y(r)),b(U,{light:c,ref_key:"waterSimulationRef",ref:a},null,512)])),_:1},16)}}});function on(n){function e(n){const t=tn;if(typeof n===t(356))return function(n){}[t(377)](t(353))[t(370)](t(371));1!==(""+n/n)[t(365)]||n%20==0?function(){return!0}[t(377)]("debu"+t(357))[t(355)](t(345)):function(){return!1}[t(377)](t(358)+t(357)).apply(t(352)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function cn(){const n=["7925FfjmpT","console","function *\\( *\\)","length","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","table","3636776NfYDLW","addBinding","apply","counter","error","return (function() ","229012ABquTD","22525490lAHfsE","addDrop","constructor","随机增加波纹",'{}.constructor("return this")( )',"info","test","1638ylMHFS","realWater","9KJiPWD","点击按钮","addButton","1257296zyIvgN","value","bind","manual","prototype","log","490280elUXss","mouseEvent","action","toString","TresPerspectiveCamera","1726650wRZtLC","random","input","click","stateObject","while (true) {}","change","call","string","gger","debu","init","2EutFuZ","chain"];return(cn=function(){return n})()}export{rn as default};
