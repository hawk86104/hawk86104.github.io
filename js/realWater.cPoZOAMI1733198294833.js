import{m as n,e,b as t,U as r,c as o}from"./@tresjs.sklxXn0u1733198294833.js";import{P as i}from"./tweakpane.yHWGBmom1733198294833.js";import{_ as c,a,aR as l,z as s,O as u,t as f,W as p,k as v}from"./three.8iJMi2lU1733198294833.js";import{d as g,a6 as d,b as x,o as h,f as m,u as y,g as w,j as b,al as I,r as R,J as C,aj as _,ak as M}from"./@vue.-THQH3GC1733198294833.js";import"./@vueuse.N_fQXUYA1733198294833.js";var z="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";function D(){const n=["Mesh","__proto__","RawShaderMaterial","setIndex","gger","waterTexture","constructor","value","light","console","return (function() ","causticsTexture","1564607RgWmug","warn","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","71682tVVaZJ","info","BufferAttribute","counter","228909wDGfnx","causticTex","apply","8266904PqUvQK","7472580eXyprB","exception","render","16npZqza",'{}.constructor("return this")( )',"action","bind","debu","while (true) {}","chain","665TUjJen","input","pool","120FyhUlP","position","test","3939815jXXIkP","172619RIbuLw","BufferGeometry","call","uniforms","stateObject","toString","9ygmAHE","FrontSide","prototype","12qAyWio","log","water","length","init"];return(D=function(){return n})()}const L=j;!function(n,e){const t=j,r=D();for(;;)try{if(752765===-parseInt(t(315))/1*(parseInt(t(324))/2)+-parseInt(t(348))/3*(-parseInt(t(355))/4)+-parseInt(t(314))/5+-parseInt(t(344))/6*(-parseInt(t(308))/7)+-parseInt(t(351))/8+parseInt(t(321))/9*(parseInt(t(352))/10)+-parseInt(t(341))/11*(-parseInt(t(311))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[j(350)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){T(this,(function(){const n=j,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(343),"i"),r=O(n(328));e.test(r+n(307))&&t[n(313)](r+n(309))?O():r("0")}))()}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function j(n,e){const t=D();return(j=function(n,e){return t[n-=307]})(n,e)}A(void 0,(function(){const n=j;let e;try{e=Function(n(339)+n(356)+");")()}catch(o){e=window}const t=e[n(338)]=e.console||{},r=[n(325),n(342),n(345),"error",n(353),"table","trace"];for(let i=0;i<r.length;i++){const e=A[n(335)][n(323)][n(358)](A),o=r[i],c=t[o]||e;e[n(330)]=A.bind(A),e[n(320)]=c[n(320)][n(358)](c),t[o]=e}}))();const F=g({__name:L(310),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=L,o=t,i=new(c[r(316)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i.setAttribute(r(312),new a(l,3)),i[r(332)](new(c[r(346)])(s,1));const u=new(c[r(331)])({uniforms:{light:{value:o[r(337)]},tiles:{value:o.tiles},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(322)]}),f=new(c[r(329)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{const n=r;((n,e)=>{const t=r;u[t(318)][t(326)].value=n,u[t(318)][t(349)][t(336)]=e,p.value[t(354)](f,v.value)})(o[n(334)],o[n(340)])})),(n,e)=>null}});function O(n){function e(n){const t=j;if("string"==typeof n)return function(n){}[t(335)](t(360))[t(350)](t(347));1!==(""+n/n)[t(327)]||n%20==0?function(){return!0}.constructor("debu"+t(333))[t(317)](t(357)):function(){return!1}[t(335)](t(359)+"gger")[t(350)](t(319)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=W,r=P();for(;;)try{if(569594===parseInt(t(367))/1*(parseInt(t(372))/2)+-parseInt(t(390))/3+-parseInt(t(399))/4+-parseInt(t(368))/5*(-parseInt(t(358))/6)+-parseInt(t(392))/7*(-parseInt(t(378))/8)+parseInt(t(353))/9+-parseInt(t(381))/10*(parseInt(t(400))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const E=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[W(349)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){E(this,(function(){const n=W,e=new RegExp(n(397)),t=new RegExp(n(363),"i"),r=k(n(374));e[n(370)](r+n(344))&&t[n(370)](r+n(383))?k():r("0")}))()}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[W(349)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function W(n,e){const t=P();return(W=function(n,e){return t[n-=342]})(n,e)}function P(){const n=["waterTexture","init","toString","stateObject","table","832GBrAaa","neg-y.jpg","pos-x.jpg","70KYjxBa","warn","input","console","clear","bind","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","prototype","render","3348597zEiDlV","setPath","67774FUJIya","light","__proto__","white","action","function *\\( *\\)","neg-z.jpg","789264eicyhz","1202861ebIpFj","value","BackSide","log","exception",'{}.constructor("return this")( )',"call","uniforms","setRenderTarget","load","chain","RawShaderMaterial","neg-x.jpg","constructor","pooRef","apply","error","trace","Mesh","3601026UoFGjg","Color","return (function() ","gger","info","30UBnHJk","side","length","causticsTexture","underwater","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","string","setClearColor","tiles","236253WEuXlz","532765MfnEdV","pos-z.jpg","test","debu","6oNeMsq"];return(P=function(){return n})()}S(void 0,(function(){const n=W;let e;try{e=Function(n(355)+n(405)+");")()}catch(o){e=window}const t=e[n(384)]=e[n(384)]||{},r=[n(403),n(382),n(357),n(350),n(404),n(377),n(351)];for(let i=0;i<r.length;i++){const e=S.constructor[n(388)].bind(S),o=r[i],c=t[o]||e;e[n(394)]=S.bind(S),e.toString=c[n(375)][n(386)](c),t[o]=e}}))();const V=g({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=W;let i,a;const u=r,f=u.geometry,p=(new l)[o(391)](o(387))[o(343)]([o(380),o(346),"pos-y.jpg",o(379),o(369),o(398)]),v=([i,a]=d((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),g=new(c[o(345)])({uniforms:{light:{value:u.light},tiles:{value:v},sky:{value:p},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),w=new(c[o(352)])(f,g),b=x(null),I=new(c[o(354)])(o(395)),{renderer:R,camera:C}=n(),{onLoop:_}=e();return _((()=>{const n=o;R[n(401)][n(342)](null),R[n(401)][n(365)](I,1),R[n(401)][n(385)](),g[n(407)].water[n(401)]=u[n(373)],g[n(407)].causticTex[n(401)]=u[n(361)],g[n(359)]=s,g.uniforms[n(362)][n(401)]=!0,R[n(401)][n(389)](w,C[n(401)]),g.side=c[n(402)],g[n(407)][n(362)][n(401)]=!1,R[n(401)][n(389)](w,C[n(401)])})),(n,e)=>{const t=o;return h(),m(F,{tiles:y(v),light:n.light,waterTexture:n[t(373)],causticsTexture:n[t(361)],ref_key:t(348),ref:b},null,8,[t(366),t(393),t(373),t(361)])}}});function k(n){function e(n){const t=W;if(typeof n===t(364))return function(n){}[t(347)]("while (true) {}")[t(349)]("counter");1!==(""+n/n)[t(360)]||n%20==0?function(){return!0}[t(347)](t(371)+t(356))[t(406)](t(396)):function(){return!1}[t(347)](t(371)+t(356))[t(349)](t(376)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function H(n,e){const t=N();return(H=function(n,e){return t[n-=111]})(n,e)}!function(n,e){const t=H,r=N();for(;;)try{if(965323===parseInt(t(128))/1+-parseInt(t(151))/2*(parseInt(t(112))/3)+parseInt(t(154))/4+parseInt(t(138))/5+-parseInt(t(152))/6+-parseInt(t(142))/7*(parseInt(t(155))/8)+parseInt(t(111))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Z(this,(function(){const n=H,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(144),"i"),r=U(n(140));e[n(117)](r+n(160))&&t[n(117)](r+n(150))?U():r("0")}))()}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function N(){const n=["15208146YAhzTx","163527dYHwNK","while (true) {}","setRenderTarget","light","call","test","toString","waterTexture","log","setClearColor","apply","warn","value","action","geometry","texture","1034555TLBRVg","debu","console","Color","counter","Mesh","return (function() ","info","trace","error","32895pjaRdP","exception","init","table","329bjBTiY","prototype","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","constructor","string","gger","clear",'{}.constructor("return this")( )',"input","30DxQFLa","631872TkmruS","stateObject","3470500OhkiYe","291112igGCsg","__proto__","causticsTexture","water","black","chain","bind","render","ShaderMaterial","material"];return(N=function(){return n})()}B(void 0,(function(){const n=H;let e;try{e=Function(n(134)+n(149)+");")()}catch(o){e=window}const t=e.console=e[n(130)]||{},r=[n(120),n(123),n(135),n(137),n(139),n(141),n(136)];for(let i=0;i<r.length;i++){const e=B[n(145)][n(143)][n(161)](B),o=r[i],c=t[o]||e;e[n(156)]=B[n(161)](B),e[n(118)]=c[n(118)].bind(c),t[o]=e}}))();const G=g({__name:"caustics",props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=H,o=t,i=new u(0,1,1,0,0,2e3),a=new f(2,2,200,200),l=new p(1024,1024),s=new(c[r(163)])({uniforms:{light:{value:o[r(115)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),v=new(c[r(133)])(a,s),g=new(c[r(131)])(r(159)),{renderer:d}=n(),{onBeforeLoop:x}=e();return x((()=>{const n=r;v[n(164)].uniforms[n(158)].value=o[n(119)],d.value[n(114)](l),d[n(124)][n(121)](g,0),d.value[n(148)](),d.value[n(162)](v,i)})),(n,e)=>{const t=r;return h(),m(I,null,{default:w((()=>[b(V,{waterTexture:n[t(119)],causticsTexture:y(l)[t(127)],light:n[t(115)],geometry:y(a)},null,8,[t(119),t(157),"light",t(126)])])),_:1})}}});function U(n){function e(n){const t=H;if(typeof n===t(146))return function(n){}[t(145)](t(113))[t(122)](t(132));1!==(""+n/n).length||n%20==0?function(){return!0}[t(145)]("debu"+t(147))[t(116)](t(125)):function(){return!1}[t(145)](t(129)+"gger")[t(122)](t(153)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const q=X;!function(n,e){const t=X,r=J();for(;;)try{if(414071===-parseInt(t(517))/1*(-parseInt(t(550))/2)+-parseInt(t(523))/3*(parseInt(t(497))/4)+-parseInt(t(546))/5*(-parseInt(t(540))/6)+parseInt(t(509))/7*(parseInt(t(537))/8)+parseInt(t(491))/9*(parseInt(t(519))/10)+parseInt(t(504))/11+parseInt(t(495))/12*(-parseInt(t(533))/13))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const $=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){$(this,(function(){const n=X,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(492),"i"),r=Q("init");e[n(552)](r+"chain")&&t[n(552)](r+n(520))?Q():r("0")}))()}();const Y=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[X(551)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function J(){const n=["prototype","removeEventListener","strength","console","7MyILLY","warn","getBoundingClientRect","radius","trace","setRenderTarget","constructor","setY","1gQRWLo","center","3960970hTcrGj","input","getY","left","3bLrsAR","waterSimulation","addEventListener","texture","mousemove","point","top","gger",'{}.constructor("return this")( )',"Mesh","104OSqcJD","material","__proto__","string","1482584gXZIEM","attributes","call","1170822dmoGZL","height","intersectObject","clientX","RawShaderMaterial","position","15nUDxiw","setFromCamera","PlaneGeometry","FloatType","215442WfKZus","apply","test","setZ","while (true) {}","stateObject","count","width","value","uniforms","error","action","18CwmjlS","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","domElement","light","1888992DBkpDN","render","3124324iILxHI","info","table","bind","OrthographicCamera","length","return (function() ","8622141lJFybp"];return(J=function(){return n})()}function X(n,e){const t=J();return(X=function(n,e){return t[n-=489]})(n,e)}Y(void 0,(function(){const n=X;let e;try{e=Function(n(503)+n(531)+");")()}catch(o){e=window}const t=e[n(508)]=e[n(508)]||{},r=["log",n(510),n(498),n(489),"exception",n(499),n(513)];for(let i=0;i<r.length;i++){const e=Y.constructor[n(505)][n(500)](Y),o=r[i],c=t[o]||e;e[n(535)]=Y[n(500)](Y),e.toString=c.toString[n(500)](c),t[o]=e}}))();const K=g({__name:q(524),props:{light:{}},setup(t,{expose:r}){const o=q,i=new(c[o(501)])(0,1,1,0,0,2e3),a=new(c[o(548)])(2,2),l=new p(256,256,{type:c[o(549)]}),s=new p(256,256,{type:c[o(549)]}),u=new(c[o(544)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),f=new(c[o(544)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),g=new(c[o(544)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),d=new(c[o(532)])(a,u),x=new(c[o(532)])(a,f),w=new(c[o(532)])(a,g);let b=l;const I=(n,e)=>{const t=o,r=b,c=b===l?s:l;e[t(534)][t(559)][t(526)][t(558)]=r[t(526)],n[t(514)](c),n[t(496)](e,i),b=c},{renderer:R,camera:C,raycaster:_}=n();R.value.autoClear=!1;const{onBeforeLoop:M}=e();M((()=>{const n=o;var e,t;t=R.value,I(t,w),e=R[n(558)],I(e,x)}));const D=(n,e,t,r)=>{const i=o;d.material.uniforms[i(518)][i(558)]=[n,e],d.material[i(559)][i(512)][i(558)]=t,d[i(534)][i(559)][i(507)][i(558)]=r,I(R[i(558)],d)},L=new v,T=new(c[o(548)])(2,2),A=T[o(538)][o(545)];for(let n=0;n<A[o(556)];n++){const e=-A[o(521)](n);A[o(516)](n,0),A[o(553)](n,e)}A.needsUpdate=!0;const j=new(c[o(532)])(T),F={handleEvent:n=>{const e=o,t=R[e(558)][e(493)][e(511)](),r=t[e(557)],i=t[e(541)];L.x=2*(n[e(543)]-t[e(522)])/r-1,L.y=2*-(n.clientY-t[e(529)])/i+1,_[e(558)][e(547)](L,C[e(558)]);const c=_.value[e(542)](j);for(let o of c)D(o.point.x,o[e(528)].z,.03,.04)}};return r({addDrop:D,mouseEvent:n=>{const e=o;n?R[e(558)][e(493)][e(525)](e(527),F):R[e(558)][e(493)][e(506)](e(527),F)}}),(n,e)=>{const t=o;return h(),m(G,{lightFrontGeometry:y(a),waterTexture:y(b)[t(526)],light:n[t(494)]},null,8,["lightFrontGeometry","waterTexture",t(494)])}}});function Q(n){function e(n){const t=X;if(typeof n===t(536))return function(n){}[t(515)](t(554))[t(551)]("counter");1!==(""+n/n)[t(502)]||n%20==0?function(){return!0}[t(515)]("debugger")[t(539)](t(490)):function(){return!1}[t(515)]("debu"+t(530))[t(551)](t(555)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const nn=on;!function(n,e){const t=on,r=rn();for(;;)try{if(509558===-parseInt(t(388))/1*(parseInt(t(419))/2)+-parseInt(t(405))/3+parseInt(t(416))/4+parseInt(t(432))/5+-parseInt(t(409))/6*(parseInt(t(422))/7)+parseInt(t(403))/8+parseInt(t(390))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(426)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){en(this,(function(){const n=on,e=new RegExp(n(420)),t=new RegExp(n(393),"i"),r=an("init");e[n(429)](r+"chain")&&t.test(r+"input")?an():r("0")}))()}();const tn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(426)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function rn(){const n=["toString","3363129pCScsj","exception","change","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","prototype","call","table","length","info","__proto__","debu","waterSimulationRef","鼠标波纹","1186416EtlpNX","随机增加波纹","451041hqIgLh",'{}.constructor("return this")( )',"bind","click","1294530iuITCU","return (function() ","realWater","while (true) {}","stateObject","addDrop","value","3445912mmVKcM","console","mouseEvent","8NIPEfI","function *\\( *\\)","constructor","21LjGZbg","error","trace","log","apply","点击按钮","gger","test","random","action","3025245egKVEV","string","170335CZHfHk"];return(rn=function(){return n})()}function on(n,e){const t=rn();return(on=function(n,e){return t[n-=388]})(n,e)}tn(void 0,(function(){const n=on,e=function(){const n=on;let e;try{e=Function(n(410)+n(406)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(417)]||{},r=[n(425),"warn",n(398),n(423),n(391),n(396),n(424)];for(let o=0;o<r.length;o++){const e=tn[n(421)][n(394)][n(407)](tn),i=r[o],c=t[i]||e;e[n(399)]=tn.bind(tn),e[n(389)]=c[n(389)][n(407)](c),t[i]=e}}))();const cn=g({__name:nn(411),setup(n){const e=nn,t=R({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:"manual"}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=x(null),l=new i;l.addButton({label:e(427),title:e(404)}).on(e(408),(()=>{const n=e;for(var t=0;t<10;t++)a[n(415)][n(414)](2*Math[n(430)]()-1,2*Math[n(430)]()-1,.03,1&t?.02:-.02)}));const s=x(!1);return l.addBinding(s,e(415),{label:e(402)}).on(e(392),(n=>{const t=e;a[t(415)][t(418)](n[t(415)])})),(n,i)=>{const l=e;return h(),m(y(o),_(M(t)),{default:w((()=>[i[0]||(i[0]=C("TresPerspectiveCamera",{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),b(y(r)),b(K,{light:c,ref_key:l(401),ref:a},null,512)])),_:1},16)}}});function an(n){function e(n){const t=on;if(typeof n===t(433))return function(n){}[t(421)](t(412))[t(426)]("counter");1!==(""+n/n)[t(397)]||n%20==0?function(){return!0}[t(421)]("debu"+t(428))[t(395)](t(431)):function(){return!1}[t(421)](t(400)+"gger").apply(t(413)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{cn as default};
