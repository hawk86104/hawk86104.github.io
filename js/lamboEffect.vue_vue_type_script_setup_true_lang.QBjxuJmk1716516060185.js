import{bK as T,c4 as v,at as D,bL as E,b3 as b,ar as U,aI as x,cA as g,d5 as S,a1 as _,ak as L,a6 as P,a9 as z,aH as M}from"./vendor.wPpJEadL1716516060185.js";import{S as N,R as I,E as F}from"./EffectComposer.teaJw5pG1716516060185.js";import{O as C}from"./OutputPass.UskVqCgT1716516060185.js";import{U as H}from"./UnrealBloomPass.Y7fo6ipB1716516060185.js";const R={name:"LUTShader",defines:{USE_3DTEXTURE:1},uniforms:{lut3d:{value:null},lut:{value:null},lutSize:{value:0},tDiffuse:{value:null},intensity:{value:1}},vertexShader:"\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}\n\n	",fragmentShader:"\n\n		uniform float lutSize;\n		#if USE_3DTEXTURE\n		precision highp sampler3D;\n		uniform sampler3D lut3d;\n		#else\n		uniform sampler2D lut;\n\n		vec3 lutLookup( sampler2D tex, float size, vec3 rgb ) {\n\n			float sliceHeight = 1.0 / size;\n			float yPixelHeight = 1.0 / ( size * size );\n\n			// Get the slices on either side of the sample\n			float slice = rgb.b * size;\n			float interp = fract( slice );\n			float slice0 = slice - interp;\n			float centeredInterp = interp - 0.5;\n\n			float slice1 = slice0 + sign( centeredInterp );\n\n			// Pull y sample in by half a pixel in each direction to avoid color\n			// bleeding from adjacent slices.\n			float greenOffset = clamp( rgb.g * sliceHeight, yPixelHeight * 0.5, sliceHeight - yPixelHeight * 0.5 );\n\n			vec2 uv0 = vec2(\n				rgb.r,\n				slice0 * sliceHeight + greenOffset\n			);\n			vec2 uv1 = vec2(\n				rgb.r,\n				slice1 * sliceHeight + greenOffset\n			);\n\n			vec3 sample0 = texture2D( tex, uv0 ).rgb;\n			vec3 sample1 = texture2D( tex, uv1 ).rgb;\n\n			return mix( sample0, sample1, abs( centeredInterp ) );\n\n		}\n		#endif\n\n		varying vec2 vUv;\n		uniform float intensity;\n		uniform sampler2D tDiffuse;\n		void main() {\n\n			vec4 val = texture2D( tDiffuse, vUv );\n			vec4 lutVal;\n\n			// pull the sample in by half a pixel so the sample begins\n			// at the center of the edge pixels.\n			float pixelWidth = 1.0 / lutSize;\n			float halfPixelWidth = 0.5 / lutSize;\n			vec3 uvw = vec3( halfPixelWidth ) + val.rgb * ( 1.0 - pixelWidth );\n\n			#if USE_3DTEXTURE\n\n			lutVal = vec4( texture( lut3d, uvw ).rgb, val.a );\n\n			#else\n\n			lutVal = vec4( lutLookup( lut, lutSize, uvw ), val.a );\n\n			#endif\n\n			gl_FragColor = vec4( mix( val, lutVal, intensity ) );\n\n		}\n\n	"};class O extends N{set lut(e){const a=this.material;if(e!==this.lut&&(a.uniforms.lut3d.value=null,a.uniforms.lut.value=null,e)){const c=e.isData3DTexture?1:0;c!==a.defines.USE_3DTEXTURE&&(a.defines.USE_3DTEXTURE=c,a.needsUpdate=!0),a.uniforms.lutSize.value=e.image.width,e.isData3DTexture?a.uniforms.lut3d.value=e:a.uniforms.lut.value=e}}get lut(){return this.material.uniforms.lut.value||this.material.uniforms.lut3d.value}set intensity(e){this.material.uniforms.intensity.value=e}get intensity(){return this.material.uniforms.intensity.value}constructor(e={}){super(R),this.lut=e.lut||null,this.intensity="intensity"in e?e.intensity:1}}class V extends T{constructor(e){super(e),this.type=v}setType(e){if(e!==v&&e!==D)throw new Error("LUTCubeLoader: Unsupported type");return this.type=e,this}load(e,a,c,n){const u=new E(this.manager);u.setPath(this.path),u.setResponseType("text"),u.load(e,l=>{try{a(this.parse(l))}catch(t){n?n(t):console.error(t),this.manager.itemError(e)}},c,n)}parse(e){const a=/TITLE +"([^"]*)"/,c=/LUT_3D_SIZE +(\d+)/,n=/DOMAIN_MIN +([\d.]+) +([\d.]+) +([\d.]+)/,u=/DOMAIN_MAX +([\d.]+) +([\d.]+) +([\d.]+)/,l=/^([\d.e+-]+) +([\d.e+-]+) +([\d.e+-]+) *$/gm;let t=a.exec(e);const y=t!==null?t[1]:null;if(t=c.exec(e),t===null)throw new Error("LUTCubeLoader: Missing LUT_3D_SIZE information");const r=Number(t[1]),d=r**3*4,o=this.type===v?new Uint8Array(d):new Float32Array(d),m=new b(0,0,0),f=new b(1,1,1);if(t=n.exec(e),t!==null&&m.set(Number(t[1]),Number(t[2]),Number(t[3])),t=u.exec(e),t!==null&&f.set(Number(t[1]),Number(t[2]),Number(t[3])),m.x>f.x||m.y>f.y||m.z>f.z)throw new Error("LUTCubeLoader: Invalid input domain");const p=this.type===v?255:1;let h=0;for(;(t=l.exec(e))!==null;)o[h++]=Number(t[1])*p,o[h++]=Number(t[2])*p,o[h++]=Number(t[3])*p,o[h++]=p;const i=new U;i.image.data=o,i.image.width=r,i.image.height=r*r,i.type=this.type,i.magFilter=x,i.minFilter=x,i.wrapS=g,i.wrapT=g,i.generateMipmaps=!1,i.needsUpdate=!0;const s=new S;return s.image.data=o,s.image.width=r,s.image.height=r,s.image.depth=r,s.type=this.type,s.magFilter=x,s.minFilter=x,s.wrapS=g,s.wrapT=g,s.wrapR=g,s.generateMipmaps=!1,s.needsUpdate=!0,{title:y,size:r,domainMin:m,domainMax:f,texture:i,texture3D:s}}}const k=_({__name:"lamboEffect",setup(w){const{camera:e,renderer:a,scene:c,sizes:n}=L(),u={threshold:.666,strength:.366,radius:.33};let l=null,t=null;const y=(d,o,m,f,p)=>{const h=new I(d,o),i=new H(new M(f,p),u.strength,u.radius,u.threshold);l=new F(m),l.addPass(h),l.addPass(i),l.addPass(new C),t=new O({intensity:1}),l.addPass(t)};new V().load("https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/model/industry4/F-6800-STD.cube",function(d){t.lut=d.texture3D}),P(()=>{n.width.value&&y(c.value,e.value,a.value,n.width.value,n.height.value)});const{onLoop:r}=z();return r(()=>{l&&l.render()}),(d,o)=>null}});export{k as _};
