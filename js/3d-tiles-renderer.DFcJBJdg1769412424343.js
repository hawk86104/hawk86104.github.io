const e="[0-9A-Za-z-]+",t=`(?:\\+(${e}(?:\\.${e})*))`,s="0|[1-9]\\d*",i="[0-9]+",r="\\d*[a-zA-Z-][a-zA-Z0-9-]*",n=`(?:${i}|${r})`,o=`(?:${s}|${r})`,a=`(?:-(${o}(?:\\.${o})*))`,l=`${s}|x|X|\\*`,c=`[v=\\s]*(${l})(?:\\.(${l})(?:\\.(${l})(?:${a})?${t}?)?)?`,h=`^\\s*(${c})\\s+-\\s+(${c})\\s*$`,u="((?:<|>)?=?)",d=`(\\s*)${u}\\s*(${`[v=\\s]*${`(${i})\\.(${i})\\.(${i})`}${`(?:-?(${n}(?:\\.${n})*))`}?${t}?`}|${c})`,p="(?:~>?)",m=`(\\s*)${p}\\s+`,f="(?:\\^)",g=`(\\s*)${f}\\s+`,y=`^${f}${c}$`,_=`^${p}${c}$`,x=`^${u}\\s*${c}$`,T=`^${u}\\s*(${`v?${`(${s})\\.(${s})\\.(${s})`}${a}?${t}?`})$|^$`;function b(e){return new RegExp(e)}function w(e){return!e||"x"===e.toLowerCase()||"*"===e}function v(...e){return t=>e.reduce((e,t)=>t(e),t)}function M(e){return e.match(b(T))}function P(e,t,s,i){const r=`${e}.${t}.${s}`;return i?`${r}-${i}`:r}function S(e){return e.replace(b(h),(e,t,s,i,r,n,o,a,l,c,h,u)=>`${t=w(s)?"":w(i)?`>=${s}.0.0`:w(r)?`>=${s}.${i}.0`:`>=${t}`} ${a=w(l)?"":w(c)?`<${+l+1}.0.0-0`:w(h)?`<${l}.${+c+1}.0-0`:u?`<=${l}.${c}.${h}-${u}`:`<=${a}`}`.trim())}function E(e){return e.replace(b(d),"$1$2$3")}function R(e){return e.replace(b(m),"$1~")}function C(e){return e.replace(b(g),"$1^")}function A(e){return e.trim().split(/\s+/).map(e=>e.replace(b(y),(e,t,s,i,r)=>w(t)?"":w(s)?`>=${t}.0.0 <${+t+1}.0.0-0`:w(i)?"0"===t?`>=${t}.${s}.0 <${t}.${+s+1}.0-0`:`>=${t}.${s}.0 <${+t+1}.0.0-0`:r?"0"===t?"0"===s?`>=${t}.${s}.${i}-${r} <${t}.${s}.${+i+1}-0`:`>=${t}.${s}.${i}-${r} <${t}.${+s+1}.0-0`:`>=${t}.${s}.${i}-${r} <${+t+1}.0.0-0`:"0"===t?"0"===s?`>=${t}.${s}.${i} <${t}.${s}.${+i+1}-0`:`>=${t}.${s}.${i} <${t}.${+s+1}.0-0`:`>=${t}.${s}.${i} <${+t+1}.0.0-0`)).join(" ")}function L(e){return e.trim().split(/\s+/).map(e=>e.replace(b(_),(e,t,s,i,r)=>w(t)?"":w(s)?`>=${t}.0.0 <${+t+1}.0.0-0`:w(i)?`>=${t}.${s}.0 <${t}.${+s+1}.0-0`:r?`>=${t}.${s}.${i}-${r} <${t}.${+s+1}.0-0`:`>=${t}.${s}.${i} <${t}.${+s+1}.0-0`)).join(" ")}function I(e){return e.split(/\s+/).map(e=>e.trim().replace(b(x),(e,t,s,i,r,n)=>{const o=w(s),a=o||w(i),l=a||w(r);return"="===t&&l&&(t=""),n="",o?">"===t||"<"===t?"<0.0.0-0":"*":t&&l?(a&&(i=0),r=0,">"===t?(t=">=",a?(s=+s+1,i=0,r=0):(i=+i+1,r=0)):"<="===t&&(t="<",a?s=+s+1:i=+i+1),"<"===t&&(n="-0"),`${t+s}.${i}.${r}${n}`):a?`>=${s}.0.0${n} <${+s+1}.0.0-0`:l?`>=${s}.${i}.0${n} <${s}.${+i+1}.0-0`:e})).join(" ")}function D(e){return e.trim().replace(b("(<|>)?=?\\s*\\*"),"")}function F(e,t){return(e=+e||e)>(t=+t||t)?1:e===t?0:-1}function O(e,t){return F(e.major,t.major)||F(e.minor,t.minor)||F(e.patch,t.patch)||function(e,t){const{preRelease:s}=e,{preRelease:i}=t;if(void 0===s&&i)return 1;if(s&&void 0===i)return-1;if(void 0===s&&void 0===i)return 0;for(let r=0,n=s.length;r<=n;r++){const e=s[r],t=i[r];if(e!==t)return void 0===e&&void 0===t?0:e?t?F(e,t):-1:1}return 0}(e,t)}function U(e,t){return e.version===t.version}function k(e,t){switch(e.operator){case"":case"=":return U(e,t);case">":return O(e,t)<0;case">=":return U(e,t)||O(e,t)<0;case"<":return O(e,t)>0;case"<=":return U(e,t)||O(e,t)>0;case void 0:return!0;default:return!1}}function N(e,t){if(!e)return!1;const s=function(e){return v(S,E,R,C)(e.trim()).split(/\s+/).join(" ")}(t),i=s.split(" ").map(e=>function(e){return v(A,L,I,D)(e)}(e)).join(" "),r=i.split(/\s+/).map(e=>e.trim().replace(b("^\\s*>=\\s*0.0.0\\s*$"),"")),n=M(e);if(!n)return!1;const[,o,,a,l,c,h]=n,u={version:P(a,l,c,h),major:a,minor:l,patch:c,preRelease:null==h?void 0:h.split(".")};for(const d of r){const e=M(d);if(!e)return!1;const[,t,,s,i,r,n]=e;if(!k({operator:t,version:P(s,i,r,n),major:s,minor:i,patch:r,preRelease:null==n?void 0:n.split(".")},u))return!1}return!0}const z={},B={vue:{get:()=>()=>$(new URL("__federation_shared_vue.CoqbYoK91769412424343.js",import.meta.url).href),import:!0},three:{get:()=>()=>$(new URL("__federation_shared_three.CWRR_KE21769412424343.js",import.meta.url).href),import:!0}},V=Object.create(null);async function H(e,t="default"){return V[e]?new Promise(t=>t(V[e])):await async function(e,t){let s=null;if(globalThis?.__federation_shared__?.[t]?.[e]){const i=globalThis.__federation_shared__[t][e],r=B[e]?.requiredVersion;if(!!r){const t=Object.keys(i).find(e=>N(e,r));if(t){const e=i[t];s=await(await e.get())()}else console.log(`provider support ${e}(${t}) is not satisfied requiredVersion(\${moduleMap[name].requiredVersion})`)}else{const e=i[Object.keys(i)[0]];s=await(await e.get())()}}if(s)return j(s,e)}(e,t)||async function(e){if(B[e]?.import){return j(await(await B[e].get())(),e)}console.error("consumer config import=false,so cant use callback shared module")}(e)}async function $(e){return z[e]??=import(e),z[e]}function j(e,t){return"function"==typeof e.default?(Object.keys(e).forEach(t=>{"default"!==t&&(e.default[t]=e[t])}),V[t]=e.default,e.default):(e.default&&(e=Object.assign({},e.default,e)),V[t]=e,e)}const{BufferAttribute:G,BufferGeometry:W,Float32BufferAttribute:q,InstancedBufferAttribute:K,InterleavedBuffer:X,InterleavedBufferAttribute:Z,TriangleFanDrawMode:Y,TriangleStripDrawMode:Q,TrianglesDrawMode:J,Vector3:ee}=await H("three");function te(e,t=!1){const s=null!==e[0].index,i=new Set(Object.keys(e[0].attributes)),r=new Set(Object.keys(e[0].morphAttributes)),n={},o={},a=e[0].morphTargetsRelative,l=new W;let c=0;for(let h=0;h<e.length;++h){const u=e[h];let d=0;if(s!==(null!==u.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in u.attributes){if(!i.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===n[e]&&(n[e]=[]),n[e].push(u.attributes[e]),d++}if(d!==i.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". Make sure all geometries have the same number of attributes."),null;if(a!==u.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in u.morphAttributes){if(!r.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===o[e]&&(o[e]=[]),o[e].push(u.morphAttributes[e])}if(t){let e;if(s)e=u.index.count;else{if(void 0===u.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". The geometry must have either an index or a position attribute"),null;e=u.attributes.position.count}l.addGroup(c,e,h),c+=e}}if(s){let t=0;const s=[];for(let i=0;i<e.length;++i){const r=e[i].index;for(let e=0;e<r.count;++e)s.push(r.getX(e)+t);t+=e[i].attributes.position.count}l.setIndex(s)}for(const h in n){const e=se(n[h]);if(!e)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+h+" attribute."),null;l.setAttribute(h,e)}for(const h in o){const e=o[h][0].length;if(0===e)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[h]=[];for(let t=0;t<e;++t){const e=[];for(let i=0;i<o[h].length;++i)e.push(o[h][i][t]);const s=se(e);if(!s)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+h+" morphAttribute."),null;l.morphAttributes[h].push(s)}}return l}function se(e){let t,s,i,r=-1,n=0;for(let c=0;c<e.length;++c){const o=e[c];if(void 0===t&&(t=o.array.constructor),t!==o.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===s&&(s=o.itemSize),s!==o.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===i&&(i=o.normalized),i!==o.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(-1===r&&(r=o.gpuType),r!==o.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;n+=o.count*s}const o=new t(n),a=new G(o,s,i);let l=0;for(let c=0;c<e.length;++c){const t=e[c];if(t.isInterleavedBufferAttribute){const e=l/s;for(let i=0,r=t.count;i<r;i++)for(let n=0;n<s;n++){const s=t.getComponent(i,n);a.setComponent(i+e,n,s)}}else o.set(t.array,l);l+=t.count*s}return void 0!==r&&(a.gpuType=r),a}function ie(e,t=1e-4){t=Math.max(t,Number.EPSILON);const s={},i=e.getIndex(),r=e.getAttribute("position"),n=i?i.count:r.count;let o=0;const a=Object.keys(e.attributes),l={},c={},h=[],u=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"];for(let _=0,x=a.length;_<x;_++){const t=a[_],s=e.attributes[t];l[t]=new s.constructor(new s.array.constructor(s.count*s.itemSize),s.itemSize,s.normalized);const i=e.morphAttributes[t];i&&(c[t]||(c[t]=[]),i.forEach((e,s)=>{const i=new e.array.constructor(e.count*e.itemSize);c[t][s]=new e.constructor(i,e.itemSize,e.normalized)}))}const p=.5*t,m=Math.log10(1/t),f=Math.pow(10,m),g=p*f;for(let _=0;_<n;_++){const t=i?i.getX(_):_;let r="";for(let s=0,i=a.length;s<i;s++){const i=a[s],n=e.getAttribute(i),o=n.itemSize;for(let e=0;e<o;e++)r+=~~(n[u[e]](t)*f+g)+","}if(r in s)h.push(s[r]);else{for(let s=0,i=a.length;s<i;s++){const i=a[s],r=e.getAttribute(i),n=e.morphAttributes[i],h=r.itemSize,p=l[i],m=c[i];for(let e=0;e<h;e++){const s=u[e],i=d[e];if(p[i](o,r[s](t)),n)for(let e=0,r=n.length;e<r;e++)m[e][i](o,n[e][s](t))}}s[r]=o,h.push(o),o++}}const y=e.clone();for(const _ in e.attributes){const e=l[_];if(y.setAttribute(_,new e.constructor(e.array.slice(0,o*e.itemSize),e.itemSize,e.normalized)),_ in c)for(let t=0;t<c[_].length;t++){const e=c[_][t];y.morphAttributes[_][t]=new e.constructor(e.array.slice(0,o*e.itemSize),e.itemSize,e.normalized)}}return y.setIndex(h),y}function re(e,t){if(t===J)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===Y||t===Q){let s=e.getIndex();if(null===s){const t=[],i=e.getAttribute("position");if(void 0===i)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<i.count;e++)t.push(e);e.setIndex(t),s=e.getIndex()}const i=s.count-2,r=[];if(t===Y)for(let e=1;e<=i;e++)r.push(s.getX(0)),r.push(s.getX(e)),r.push(s.getX(e+1));else for(let e=0;e<i;e++)e%2==0?(r.push(s.getX(e)),r.push(s.getX(e+1)),r.push(s.getX(e+2))):(r.push(s.getX(e+2)),r.push(s.getX(e+1)),r.push(s.getX(e)));r.length/3!==i&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const n=e.clone();return n.setIndex(r),n.clearGroups(),n}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}function ne(e,t=Math.PI/3){const s=Math.cos(t),i=100*(1+1e-10),r=[new ee,new ee,new ee],n=new ee,o=new ee,a=new ee,l=new ee;function c(e){return`${~~(e.x*i)},${~~(e.y*i)},${~~(e.z*i)}`}const h=e.index?e.toNonIndexed():e,u=h.attributes.position,d={};for(let f=0,g=u.count/3;f<g;f++){const e=3*f,t=r[0].fromBufferAttribute(u,e+0),s=r[1].fromBufferAttribute(u,e+1),i=r[2].fromBufferAttribute(u,e+2);n.subVectors(i,s),o.subVectors(t,s);const a=(new ee).crossVectors(n,o).normalize();for(let n=0;n<3;n++){const e=c(r[n]);e in d||(d[e]=[]),d[e].push(a)}}const p=new Float32Array(3*u.count),m=new G(p,3,!1);for(let f=0,g=u.count/3;f<g;f++){const e=3*f,t=r[0].fromBufferAttribute(u,e+0),i=r[1].fromBufferAttribute(u,e+1),h=r[2].fromBufferAttribute(u,e+2);n.subVectors(h,i),o.subVectors(t,i),a.crossVectors(n,o).normalize();for(let n=0;n<3;n++){const t=d[c(r[n])];l.set(0,0,0);for(let e=0,i=t.length;e<i;e++){const i=t[e];a.dot(i)>s&&l.add(i)}l.normalize(),m.setXYZ(e+n,l.x,l.y,l.z)}}return h.setAttribute("normal",m),h}const{AnimationClip:oe,Bone:ae,Box3:le,BufferAttribute:ce,BufferGeometry:he,ClampToEdgeWrapping:ue,Color:de,ColorManagement:pe,DirectionalLight:me,DoubleSide:fe,FileLoader:ge,FrontSide:ye,Group:_e,ImageBitmapLoader:xe,InstancedMesh:Te,InterleavedBuffer:be,InterleavedBufferAttribute:we,Interpolant:ve,InterpolateDiscrete:Me,InterpolateLinear:Pe,Line:Se,LineBasicMaterial:Ee,LineLoop:Re,LineSegments:Ce,LinearFilter:Ae,LinearMipmapLinearFilter:Le,LinearMipmapNearestFilter:Ie,LinearSRGBColorSpace:De,Loader:Fe,LoaderUtils:Oe,Material:Ue,MathUtils:ke,Matrix4:Ne,Mesh:ze,MeshBasicMaterial:Be,MeshPhysicalMaterial:Ve,MeshStandardMaterial:He,MirroredRepeatWrapping:$e,NearestFilter:je,NearestMipmapLinearFilter:Ge,NearestMipmapNearestFilter:We,NumberKeyframeTrack:qe,Object3D:Ke,OrthographicCamera:Xe,PerspectiveCamera:Ze,PointLight:Ye,Points:Qe,PointsMaterial:Je,PropertyBinding:et,Quaternion:tt,QuaternionKeyframeTrack:st,RepeatWrapping:it,Skeleton:rt,SkinnedMesh:nt,Sphere:ot,SpotLight:at,Texture:lt,TextureLoader:ct,TriangleFanDrawMode:ht,TriangleStripDrawMode:ut,Vector2:dt,Vector3:pt,VectorKeyframeTrack:mt,SRGBColorSpace:ft,InstancedBufferAttribute:gt}=await H("three");class yt extends Fe{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(e){return new vt(e)}),this.register(function(e){return new Mt(e)}),this.register(function(e){return new Dt(e)}),this.register(function(e){return new Ft(e)}),this.register(function(e){return new Ot(e)}),this.register(function(e){return new St(e)}),this.register(function(e){return new Et(e)}),this.register(function(e){return new Rt(e)}),this.register(function(e){return new Ct(e)}),this.register(function(e){return new wt(e)}),this.register(function(e){return new At(e)}),this.register(function(e){return new Pt(e)}),this.register(function(e){return new It(e)}),this.register(function(e){return new Lt(e)}),this.register(function(e){return new Tt(e)}),this.register(function(e){return new Ut(e)}),this.register(function(e){return new kt(e)})}load(e,t,s,i){const r=this;let n;if(""!==this.resourcePath)n=this.resourcePath;else if(""!==this.path){const t=Oe.extractUrlBase(e);n=Oe.resolveURL(t,this.path)}else n=Oe.extractUrlBase(e);this.manager.itemStart(e);const o=function(t){i?i(t):console.error(t),r.manager.itemError(e),r.manager.itemEnd(e)},a=new ge(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(s){try{r.parse(s,n,function(s){t(s),r.manager.itemEnd(e)},o)}catch(i){o(i)}},s,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,i){let r;const n={},o={},a=new TextDecoder;if("string"==typeof e)r=JSON.parse(e);else if(e instanceof ArrayBuffer){if(a.decode(new Uint8Array(e,0,4))===Nt){try{n[xt.KHR_BINARY_GLTF]=new Vt(e)}catch(c){return void(i&&i(c))}r=JSON.parse(n[xt.KHR_BINARY_GLTF].content)}else r=JSON.parse(a.decode(e))}else r=e;if(void 0===r.asset||r.asset.version[0]<2)return void(i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const l=new ps(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const e=this.pluginCallbacks[h](l);e.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),o[e.name]=e,n[e.name]=!0}if(r.extensionsUsed)for(let h=0;h<r.extensionsUsed.length;++h){const e=r.extensionsUsed[h],t=r.extensionsRequired||[];switch(e){case xt.KHR_MATERIALS_UNLIT:n[e]=new bt;break;case xt.KHR_DRACO_MESH_COMPRESSION:n[e]=new Ht(r,this.dracoLoader);break;case xt.KHR_TEXTURE_TRANSFORM:n[e]=new $t;break;case xt.KHR_MESH_QUANTIZATION:n[e]=new jt;break;default:t.indexOf(e)>=0&&void 0===o[e]&&console.warn('THREE.GLTFLoader: Unknown extension "'+e+'".')}}l.setExtensions(n),l.setPlugins(o),l.parse(s,i)}parseAsync(e,t){const s=this;return new Promise(function(i,r){s.parse(e,t,i,r)})}}function _t(){let e={};return{get:function(t){return e[t]},add:function(t,s){e[t]=s},remove:function(t){delete e[t]},removeAll:function(){e={}}}}const xt={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Tt{constructor(e){this.parser=e,this.name=xt.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,i=t.length;s<i;s++){const i=t[s];i.extensions&&i.extensions[this.name]&&void 0!==i.extensions[this.name].light&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let i=t.cache.get(s);if(i)return i;const r=t.json,n=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let o;const a=new de(16777215);void 0!==n.color&&a.setRGB(n.color[0],n.color[1],n.color[2],De);const l=void 0!==n.range?n.range:0;switch(n.type){case"directional":o=new me(a),o.target.position.set(0,0,-1),o.add(o.target);break;case"point":o=new Ye(a),o.distance=l;break;case"spot":o=new at(a),o.distance=l,n.spot=n.spot||{},n.spot.innerConeAngle=void 0!==n.spot.innerConeAngle?n.spot.innerConeAngle:0,n.spot.outerConeAngle=void 0!==n.spot.outerConeAngle?n.spot.outerConeAngle:Math.PI/4,o.angle=n.spot.outerConeAngle,o.penumbra=1-n.spot.innerConeAngle/n.spot.outerConeAngle,o.target.position.set(0,0,-1),o.add(o.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+n.type)}return o.position.set(0,0,0),as(o,n),void 0!==n.intensity&&(o.intensity=n.intensity),o.name=t.createUniqueName(n.name||"light_"+e),i=Promise.resolve(o),t.cache.add(s,i),i}getDependency(e,t){if("light"===e)return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,i=s.json.nodes[e],r=(i.extensions&&i.extensions[this.name]||{}).light;return void 0===r?null:this._loadLight(r).then(function(e){return s._getNodeRef(t.cache,r,e)})}}class bt{constructor(){this.name=xt.KHR_MATERIALS_UNLIT}getMaterialType(){return Be}extendParams(e,t,s){const i=[];e.color=new de(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const t=r.baseColorFactor;e.color.setRGB(t[0],t[1],t[2],De),e.opacity=t[3]}void 0!==r.baseColorTexture&&i.push(s.assignTexture(e,"map",r.baseColorTexture,ft))}return Promise.all(i)}}class wt{constructor(e){this.parser=e,this.name=xt.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=s.extensions[this.name].emissiveStrength;return void 0!==i&&(t.emissiveIntensity=i),Promise.resolve()}}class vt{constructor(e){this.parser=e,this.name=xt.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?Ve:null}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],n=i.extensions[this.name];if(void 0!==n.clearcoatFactor&&(t.clearcoat=n.clearcoatFactor),void 0!==n.clearcoatTexture&&r.push(s.assignTexture(t,"clearcoatMap",n.clearcoatTexture)),void 0!==n.clearcoatRoughnessFactor&&(t.clearcoatRoughness=n.clearcoatRoughnessFactor),void 0!==n.clearcoatRoughnessTexture&&r.push(s.assignTexture(t,"clearcoatRoughnessMap",n.clearcoatRoughnessTexture)),void 0!==n.clearcoatNormalTexture&&(r.push(s.assignTexture(t,"clearcoatNormalMap",n.clearcoatNormalTexture)),void 0!==n.clearcoatNormalTexture.scale)){const e=n.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new dt(e,e)}return Promise.all(r)}}class Mt{constructor(e){this.parser=e,this.name=xt.KHR_MATERIALS_DISPERSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?Ve:null}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=s.extensions[this.name];return t.dispersion=void 0!==i.dispersion?i.dispersion:0,Promise.resolve()}}class Pt{constructor(e){this.parser=e,this.name=xt.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?Ve:null}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],n=i.extensions[this.name];return void 0!==n.iridescenceFactor&&(t.iridescence=n.iridescenceFactor),void 0!==n.iridescenceTexture&&r.push(s.assignTexture(t,"iridescenceMap",n.iridescenceTexture)),void 0!==n.iridescenceIor&&(t.iridescenceIOR=n.iridescenceIor),void 0===t.iridescenceThicknessRange&&(t.iridescenceThicknessRange=[100,400]),void 0!==n.iridescenceThicknessMinimum&&(t.iridescenceThicknessRange[0]=n.iridescenceThicknessMinimum),void 0!==n.iridescenceThicknessMaximum&&(t.iridescenceThicknessRange[1]=n.iridescenceThicknessMaximum),void 0!==n.iridescenceThicknessTexture&&r.push(s.assignTexture(t,"iridescenceThicknessMap",n.iridescenceThicknessTexture)),Promise.all(r)}}class St{constructor(e){this.parser=e,this.name=xt.KHR_MATERIALS_SHEEN}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?Ve:null}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new de(0,0,0),t.sheenRoughness=0,t.sheen=1;const n=i.extensions[this.name];if(void 0!==n.sheenColorFactor){const e=n.sheenColorFactor;t.sheenColor.setRGB(e[0],e[1],e[2],De)}return void 0!==n.sheenRoughnessFactor&&(t.sheenRoughness=n.sheenRoughnessFactor),void 0!==n.sheenColorTexture&&r.push(s.assignTexture(t,"sheenColorMap",n.sheenColorTexture,ft)),void 0!==n.sheenRoughnessTexture&&r.push(s.assignTexture(t,"sheenRoughnessMap",n.sheenRoughnessTexture)),Promise.all(r)}}class Et{constructor(e){this.parser=e,this.name=xt.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?Ve:null}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],n=i.extensions[this.name];return void 0!==n.transmissionFactor&&(t.transmission=n.transmissionFactor),void 0!==n.transmissionTexture&&r.push(s.assignTexture(t,"transmissionMap",n.transmissionTexture)),Promise.all(r)}}class Rt{constructor(e){this.parser=e,this.name=xt.KHR_MATERIALS_VOLUME}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?Ve:null}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],n=i.extensions[this.name];t.thickness=void 0!==n.thicknessFactor?n.thicknessFactor:0,void 0!==n.thicknessTexture&&r.push(s.assignTexture(t,"thicknessMap",n.thicknessTexture)),t.attenuationDistance=n.attenuationDistance||1/0;const o=n.attenuationColor||[1,1,1];return t.attenuationColor=(new de).setRGB(o[0],o[1],o[2],De),Promise.all(r)}}class Ct{constructor(e){this.parser=e,this.name=xt.KHR_MATERIALS_IOR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?Ve:null}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=s.extensions[this.name];return t.ior=void 0!==i.ior?i.ior:1.5,Promise.resolve()}}class At{constructor(e){this.parser=e,this.name=xt.KHR_MATERIALS_SPECULAR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?Ve:null}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],n=i.extensions[this.name];t.specularIntensity=void 0!==n.specularFactor?n.specularFactor:1,void 0!==n.specularTexture&&r.push(s.assignTexture(t,"specularIntensityMap",n.specularTexture));const o=n.specularColorFactor||[1,1,1];return t.specularColor=(new de).setRGB(o[0],o[1],o[2],De),void 0!==n.specularColorTexture&&r.push(s.assignTexture(t,"specularColorMap",n.specularColorTexture,ft)),Promise.all(r)}}class Lt{constructor(e){this.parser=e,this.name=xt.EXT_MATERIALS_BUMP}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?Ve:null}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],n=i.extensions[this.name];return t.bumpScale=void 0!==n.bumpFactor?n.bumpFactor:1,void 0!==n.bumpTexture&&r.push(s.assignTexture(t,"bumpMap",n.bumpTexture)),Promise.all(r)}}class It{constructor(e){this.parser=e,this.name=xt.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?Ve:null}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],n=i.extensions[this.name];return void 0!==n.anisotropyStrength&&(t.anisotropy=n.anisotropyStrength),void 0!==n.anisotropyRotation&&(t.anisotropyRotation=n.anisotropyRotation),void 0!==n.anisotropyTexture&&r.push(s.assignTexture(t,"anisotropyMap",n.anisotropyTexture)),Promise.all(r)}}class Dt{constructor(e){this.parser=e,this.name=xt.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,i=s.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const r=i.extensions[this.name],n=t.options.ktx2Loader;if(!n){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,n)}}class Ft{constructor(e){this.parser=e,this.name=xt.EXT_TEXTURE_WEBP}loadTexture(e){const t=this.name,s=this.parser,i=s.json,r=i.textures[e];if(!r.extensions||!r.extensions[t])return null;const n=r.extensions[t],o=i.images[n.source];let a=s.textureLoader;if(o.uri){const e=s.options.manager.getHandler(o.uri);null!==e&&(a=e)}return s.loadTextureImage(e,n.source,a)}}class Ot{constructor(e){this.parser=e,this.name=xt.EXT_TEXTURE_AVIF}loadTexture(e){const t=this.name,s=this.parser,i=s.json,r=i.textures[e];if(!r.extensions||!r.extensions[t])return null;const n=r.extensions[t],o=i.images[n.source];let a=s.textureLoader;if(o.uri){const e=s.options.manager.getHandler(o.uri);null!==e&&(a=e)}return s.loadTextureImage(e,n.source,a)}}class Ut{constructor(e){this.name=xt.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const e=s.extensions[this.name],i=this.parser.getDependency("buffer",e.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then(function(t){const s=e.byteOffset||0,i=e.byteLength||0,n=e.count,o=e.byteStride,a=new Uint8Array(t,s,i);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(n,o,a,e.mode,e.filter).then(function(e){return e.buffer}):r.ready.then(function(){const t=new ArrayBuffer(n*o);return r.decodeGltfBuffer(new Uint8Array(t),n,o,a,e.mode,e.filter),t})})}return null}}class kt{constructor(e){this.name=xt.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||void 0===s.mesh)return null;const i=t.meshes[s.mesh];for(const a of i.primitives)if(a.mode!==Kt.TRIANGLES&&a.mode!==Kt.TRIANGLE_STRIP&&a.mode!==Kt.TRIANGLE_FAN&&void 0!==a.mode)return null;const r=s.extensions[this.name].attributes,n=[],o={};for(const a in r)n.push(this.parser.getDependency("accessor",r[a]).then(e=>(o[a]=e,o[a])));return n.length<1?null:(n.push(this.parser.createNodeMesh(e)),Promise.all(n).then(e=>{const t=e.pop(),s=t.isGroup?t.children:[t],i=e[0].count,r=[];for(const n of s){const e=new Ne,t=new pt,s=new tt,a=new pt(1,1,1),l=new Te(n.geometry,n.material,i);for(let r=0;r<i;r++)o.TRANSLATION&&t.fromBufferAttribute(o.TRANSLATION,r),o.ROTATION&&s.fromBufferAttribute(o.ROTATION,r),o.SCALE&&a.fromBufferAttribute(o.SCALE,r),l.setMatrixAt(r,e.compose(t,s,a));for(const i in o)if("_COLOR_0"===i){const e=o[i];l.instanceColor=new gt(e.array,e.itemSize,e.normalized)}else"TRANSLATION"!==i&&"ROTATION"!==i&&"SCALE"!==i&&n.geometry.setAttribute(i,o[i]);Ke.prototype.copy.call(l,n),this.parser.assignFinalMaterial(l),r.push(l)}return t.isGroup?(t.clear(),t.add(...r),t):r[0]}))}}const Nt="glTF",zt=1313821514,Bt=5130562;class Vt{constructor(e){this.name=xt.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,12),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Nt)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-12,r=new DataView(e,12);let n=0;for(;n<i;){const t=r.getUint32(n,!0);n+=4;const i=r.getUint32(n,!0);if(n+=4,i===zt){const i=new Uint8Array(e,12+n,t);this.content=s.decode(i)}else if(i===Bt){const s=12+n;this.body=e.slice(s,s+t)}n+=t}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Ht{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=xt.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,i=this.dracoLoader,r=e.extensions[this.name].bufferView,n=e.extensions[this.name].attributes,o={},a={},l={};for(const c in n){const e=Jt[c]||c.toLowerCase();o[e]=n[c]}for(const c in e.attributes){const t=Jt[c]||c.toLowerCase();if(void 0!==n[c]){const i=s.accessors[e.attributes[c]],r=Xt[i.componentType];l[t]=r.name,a[t]=!0===i.normalized}}return t.getDependency("bufferView",r).then(function(e){return new Promise(function(t,s){i.decodeDracoFile(e,function(e){for(const t in e.attributes){const s=e.attributes[t],i=a[t];void 0!==i&&(s.normalized=i)}t(e)},o,l,De,s)})})}}class $t{constructor(){this.name=xt.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return void 0!==t.texCoord&&t.texCoord!==e.channel||void 0!==t.offset||void 0!==t.rotation||void 0!==t.scale?(e=e.clone(),void 0!==t.texCoord&&(e.channel=t.texCoord),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),e.needsUpdate=!0,e):e}}class jt{constructor(){this.name=xt.KHR_MESH_QUANTIZATION}}class Gt extends ve{constructor(e,t,s,i){super(e,t,s,i)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,i=this.valueSize,r=e*i*3+i;for(let n=0;n!==i;n++)t[n]=s[r+n];return t}interpolate_(e,t,s,i){const r=this.resultBuffer,n=this.sampleValues,o=this.valueSize,a=2*o,l=3*o,c=i-t,h=(s-t)/c,u=h*h,d=u*h,p=e*l,m=p-l,f=-2*d+3*u,g=d-u,y=1-f,_=g-u+h;for(let x=0;x!==o;x++){const e=n[m+x+o],t=n[m+x+a]*c,s=n[p+x+o],i=n[p+x]*c;r[x]=y*e+_*t+f*s+g*i}return r}}const Wt=new tt;class qt extends Gt{interpolate_(e,t,s,i){const r=super.interpolate_(e,t,s,i);return Wt.fromArray(r).normalize().toArray(r),r}}const Kt={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},Xt={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Zt={9728:je,9729:Ae,9984:We,9985:Ie,9986:Ge,9987:Le},Yt={33071:ue,33648:$e,10497:it},Qt={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Jt={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},es={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},ts={CUBICSPLINE:void 0,LINEAR:Pe,STEP:Me},ss="OPAQUE",is="MASK",rs="BLEND";function ns(e){return void 0===e.DefaultMaterial&&(e.DefaultMaterial=new He({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:ye})),e.DefaultMaterial}function os(e,t,s){for(const i in s.extensions)void 0===e[i]&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[i]=s.extensions[i])}function as(e,t){void 0!==t.extras&&("object"==typeof t.extras?Object.assign(e.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function ls(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(let s=0,i=t.weights.length;s<i;s++)e.morphTargetInfluences[s]=t.weights[s];if(t.extras&&Array.isArray(t.extras.targetNames)){const s=t.extras.targetNames;if(e.morphTargetInfluences.length===s.length){e.morphTargetDictionary={};for(let t=0,i=s.length;t<i;t++)e.morphTargetDictionary[s[t]]=t}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function cs(e){let t;const s=e.extensions&&e.extensions[xt.KHR_DRACO_MESH_COMPRESSION];if(t=s?"draco:"+s.bufferView+":"+s.indices+":"+hs(s.attributes):e.indices+":"+hs(e.attributes)+":"+e.mode,void 0!==e.targets)for(let i=0,r=e.targets.length;i<r;i++)t+=":"+hs(e.targets[i]);return t}function hs(e){let t="";const s=Object.keys(e).sort();for(let i=0,r=s.length;i<r;i++)t+=s[i]+":"+e[s[i]]+";";return t}function us(e){switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}const ds=new Ne;class ps{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new _t,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,i=-1,r=!1,n=-1;if("undefined"!=typeof navigator){const e=navigator.userAgent;s=!0===/^((?!chrome|android).)*safari/i.test(e);const t=e.match(/Version\/(\d+)/);i=s&&t?parseInt(t[1],10):-1,r=e.indexOf("Firefox")>-1,n=r?e.match(/Firefox\/([0-9]+)\./)[1]:-1}"undefined"==typeof createImageBitmap||s&&i<17||r&&n<98?this.textureLoader=new ct(this.options.manager):this.textureLoader=new xe(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new ge(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,i=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(e){return e._markDefs&&e._markDefs()}),Promise.all(this._invokeAll(function(e){return e.beforeRoot&&e.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(t){const n={scene:t[0][i.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:i.asset,parser:s,userData:{}};return os(r,n,i),as(n,i),Promise.all(s._invokeAll(function(e){return e.afterRoot&&e.afterRoot(n)})).then(function(){for(const e of n.scenes)e.updateMatrixWorld();e(n)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let i=0,r=t.length;i<r;i++){const s=t[i].joints;for(let t=0,i=s.length;t<i;t++)e[s[t]].isBone=!0}for(let i=0,r=e.length;i<r;i++){const t=e[i];void 0!==t.mesh&&(this._addNodeRef(this.meshCache,t.mesh),void 0!==t.skin&&(s[t.mesh].isSkinnedMesh=!0)),void 0!==t.camera&&this._addNodeRef(this.cameraCache,t.camera)}}_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const i=s.clone(),r=(e,t)=>{const s=this.associations.get(e);null!=s&&this.associations.set(t,s);for(const[i,n]of e.children.entries())r(n,t.children[i])};return r(s,i),i.name+="_instance_"+e.uses[t]++,i}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const i=e(t[s]);if(i)return i}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let i=0;i<t.length;i++){const r=e(t[i]);r&&s.push(r)}return s}getDependency(e,t){const s=e+":"+t;let i=this.cache.get(s);if(!i){switch(e){case"scene":i=this.loadScene(t);break;case"node":i=this._invokeOne(function(e){return e.loadNode&&e.loadNode(t)});break;case"mesh":i=this._invokeOne(function(e){return e.loadMesh&&e.loadMesh(t)});break;case"accessor":i=this.loadAccessor(t);break;case"bufferView":i=this._invokeOne(function(e){return e.loadBufferView&&e.loadBufferView(t)});break;case"buffer":i=this.loadBuffer(t);break;case"material":i=this._invokeOne(function(e){return e.loadMaterial&&e.loadMaterial(t)});break;case"texture":i=this._invokeOne(function(e){return e.loadTexture&&e.loadTexture(t)});break;case"skin":i=this.loadSkin(t);break;case"animation":i=this._invokeOne(function(e){return e.loadAnimation&&e.loadAnimation(t)});break;case"camera":i=this.loadCamera(t);break;default:if(i=this._invokeOne(function(s){return s!=this&&s.getDependency&&s.getDependency(e,t)}),!i)throw new Error("Unknown type: "+e)}this.cache.add(s,i)}return i}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,i=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(i.map(function(t,i){return s.getDependency(e,i)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[xt.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(e,r){s.load(Oe.resolveURL(t.uri,i.path),e,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(e){const s=t.byteLength||0,i=t.byteOffset||0;return e.slice(i,i+s)})}loadAccessor(e){const t=this,s=this.json,i=this.json.accessors[e];if(void 0===i.bufferView&&void 0===i.sparse){const e=Qt[i.type],t=Xt[i.componentType],s=!0===i.normalized,r=new t(i.count*e);return Promise.resolve(new ce(r,e,s))}const r=[];return void 0!==i.bufferView?r.push(this.getDependency("bufferView",i.bufferView)):r.push(null),void 0!==i.sparse&&(r.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(r).then(function(e){const r=e[0],n=Qt[i.type],o=Xt[i.componentType],a=o.BYTES_PER_ELEMENT,l=a*n,c=i.byteOffset||0,h=void 0!==i.bufferView?s.bufferViews[i.bufferView].byteStride:void 0,u=!0===i.normalized;let d,p;if(h&&h!==l){const e=Math.floor(c/h),s="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+e+":"+i.count;let l=t.cache.get(s);l||(d=new o(r,e*h,i.count*h/a),l=new be(d,h/a),t.cache.add(s,l)),p=new we(l,n,c%h/a,u)}else d=null===r?new o(i.count*n):new o(r,c,i.count*n),p=new ce(d,n,u);if(void 0!==i.sparse){const t=Qt.SCALAR,s=Xt[i.sparse.indices.componentType],a=i.sparse.indices.byteOffset||0,l=i.sparse.values.byteOffset||0,c=new s(e[1],a,i.sparse.count*t),h=new o(e[2],l,i.sparse.count*n);null!==r&&(p=new ce(p.array.slice(),p.itemSize,p.normalized)),p.normalized=!1;for(let e=0,i=c.length;e<i;e++){const t=c[e];if(p.setX(t,h[e*n]),n>=2&&p.setY(t,h[e*n+1]),n>=3&&p.setZ(t,h[e*n+2]),n>=4&&p.setW(t,h[e*n+3]),n>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}p.normalized=u}return p})}loadTexture(e){const t=this.json,s=this.options,i=t.textures[e].source,r=t.images[i];let n=this.textureLoader;if(r.uri){const e=s.manager.getHandler(r.uri);null!==e&&(n=e)}return this.loadTextureImage(e,i,n)}loadTextureImage(e,t,s){const i=this,r=this.json,n=r.textures[e],o=r.images[t],a=(o.uri||o.bufferView)+":"+n.sampler;if(this.textureCache[a])return this.textureCache[a];const l=this.loadImageSource(t,s).then(function(t){t.flipY=!1,t.name=n.name||o.name||"",""===t.name&&"string"==typeof o.uri&&!1===o.uri.startsWith("data:image/")&&(t.name=o.uri);const s=(r.samplers||{})[n.sampler]||{};return t.magFilter=Zt[s.magFilter]||Ae,t.minFilter=Zt[s.minFilter]||Le,t.wrapS=Yt[s.wrapS]||it,t.wrapT=Yt[s.wrapT]||it,t.generateMipmaps=!t.isCompressedTexture&&t.minFilter!==je&&t.minFilter!==Ae,i.associations.set(t,{textures:e}),t}).catch(function(){return null});return this.textureCache[a]=l,l}loadImageSource(e,t){const s=this,i=this.json,r=this.options;if(void 0!==this.sourceCache[e])return this.sourceCache[e].then(e=>e.clone());const n=i.images[e],o=self.URL||self.webkitURL;let a=n.uri||"",l=!1;if(void 0!==n.bufferView)a=s.getDependency("bufferView",n.bufferView).then(function(e){l=!0;const t=new Blob([e],{type:n.mimeType});return a=o.createObjectURL(t),a});else if(void 0===n.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const c=Promise.resolve(a).then(function(e){return new Promise(function(s,i){let n=s;!0===t.isImageBitmapLoader&&(n=function(e){const t=new lt(e);t.needsUpdate=!0,s(t)}),t.load(Oe.resolveURL(e,r.path),n,void 0,i)})}).then(function(e){var t;return!0===l&&o.revokeObjectURL(a),as(e,n),e.userData.mimeType=n.mimeType||((t=n.uri).search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/)?"image/jpeg":t.search(/\.webp($|\?)/i)>0||0===t.search(/^data\:image\/webp/)?"image/webp":t.search(/\.ktx2($|\?)/i)>0||0===t.search(/^data\:image\/ktx2/)?"image/ktx2":"image/png"),e}).catch(function(e){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),e});return this.sourceCache[e]=c,c}assignTexture(e,t,s,i){const r=this;return this.getDependency("texture",s.index).then(function(n){if(!n)return null;if(void 0!==s.texCoord&&s.texCoord>0&&((n=n.clone()).channel=s.texCoord),r.extensions[xt.KHR_TEXTURE_TRANSFORM]){const e=void 0!==s.extensions?s.extensions[xt.KHR_TEXTURE_TRANSFORM]:void 0;if(e){const t=r.associations.get(n);n=r.extensions[xt.KHR_TEXTURE_TRANSFORM].extendTexture(n,e),r.associations.set(n,t)}}return void 0!==i&&(n.colorSpace=i),e[t]=n,n})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const i=void 0===t.attributes.tangent,r=void 0!==t.attributes.color,n=void 0===t.attributes.normal;if(e.isPoints){const e="PointsMaterial:"+s.uuid;let t=this.cache.get(e);t||(t=new Je,Ue.prototype.copy.call(t,s),t.color.copy(s.color),t.map=s.map,t.sizeAttenuation=!1,this.cache.add(e,t)),s=t}else if(e.isLine){const e="LineBasicMaterial:"+s.uuid;let t=this.cache.get(e);t||(t=new Ee,Ue.prototype.copy.call(t,s),t.color.copy(s.color),t.map=s.map,this.cache.add(e,t)),s=t}if(i||r||n){let e="ClonedMaterial:"+s.uuid+":";i&&(e+="derivative-tangents:"),r&&(e+="vertex-colors:"),n&&(e+="flat-shading:");let t=this.cache.get(e);t||(t=s.clone(),r&&(t.vertexColors=!0),n&&(t.flatShading=!0),i&&(t.normalScale&&(t.normalScale.y*=-1),t.clearcoatNormalScale&&(t.clearcoatNormalScale.y*=-1)),this.cache.add(e,t),this.associations.set(t,this.associations.get(s))),s=t}e.material=s}getMaterialType(){return He}loadMaterial(e){const t=this,s=this.json,i=this.extensions,r=s.materials[e];let n;const o={},a=[];if((r.extensions||{})[xt.KHR_MATERIALS_UNLIT]){const e=i[xt.KHR_MATERIALS_UNLIT];n=e.getMaterialType(),a.push(e.extendParams(o,r,t))}else{const s=r.pbrMetallicRoughness||{};if(o.color=new de(1,1,1),o.opacity=1,Array.isArray(s.baseColorFactor)){const e=s.baseColorFactor;o.color.setRGB(e[0],e[1],e[2],De),o.opacity=e[3]}void 0!==s.baseColorTexture&&a.push(t.assignTexture(o,"map",s.baseColorTexture,ft)),o.metalness=void 0!==s.metallicFactor?s.metallicFactor:1,o.roughness=void 0!==s.roughnessFactor?s.roughnessFactor:1,void 0!==s.metallicRoughnessTexture&&(a.push(t.assignTexture(o,"metalnessMap",s.metallicRoughnessTexture)),a.push(t.assignTexture(o,"roughnessMap",s.metallicRoughnessTexture))),n=this._invokeOne(function(t){return t.getMaterialType&&t.getMaterialType(e)}),a.push(Promise.all(this._invokeAll(function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,o)})))}!0===r.doubleSided&&(o.side=fe);const l=r.alphaMode||ss;if(l===rs?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,l===is&&(o.alphaTest=void 0!==r.alphaCutoff?r.alphaCutoff:.5)),void 0!==r.normalTexture&&n!==Be&&(a.push(t.assignTexture(o,"normalMap",r.normalTexture)),o.normalScale=new dt(1,1),void 0!==r.normalTexture.scale)){const e=r.normalTexture.scale;o.normalScale.set(e,e)}if(void 0!==r.occlusionTexture&&n!==Be&&(a.push(t.assignTexture(o,"aoMap",r.occlusionTexture)),void 0!==r.occlusionTexture.strength&&(o.aoMapIntensity=r.occlusionTexture.strength)),void 0!==r.emissiveFactor&&n!==Be){const e=r.emissiveFactor;o.emissive=(new de).setRGB(e[0],e[1],e[2],De)}return void 0!==r.emissiveTexture&&n!==Be&&a.push(t.assignTexture(o,"emissiveMap",r.emissiveTexture,ft)),Promise.all(a).then(function(){const s=new n(o);return r.name&&(s.name=r.name),as(s,r),t.associations.set(s,{materials:e}),r.extensions&&os(i,s,r),s})}createUniqueName(e){const t=et.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,i=this.primitiveCache;function r(e){return s[xt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then(function(s){return ms(s,e,t)})}const n=[];for(let o=0,a=e.length;o<a;o++){const s=e[o],a=cs(s),l=i[a];if(l)n.push(l.promise);else{let e;e=s.extensions&&s.extensions[xt.KHR_DRACO_MESH_COMPRESSION]?r(s):ms(new he,s,t),i[a]={primitive:s,promise:e},n.push(e)}}return Promise.all(n)}loadMesh(e){const t=this,s=this.json,i=this.extensions,r=s.meshes[e],n=r.primitives,o=[];for(let a=0,l=n.length;a<l;a++){const e=void 0===n[a].material?ns(this.cache):this.getDependency("material",n[a].material);o.push(e)}return o.push(t.loadGeometries(n)),Promise.all(o).then(function(s){const o=s.slice(0,s.length-1),a=s[s.length-1],l=[];for(let h=0,u=a.length;h<u;h++){const s=a[h],c=n[h];let u;const d=o[h];if(c.mode===Kt.TRIANGLES||c.mode===Kt.TRIANGLE_STRIP||c.mode===Kt.TRIANGLE_FAN||void 0===c.mode)u=!0===r.isSkinnedMesh?new nt(s,d):new ze(s,d),!0===u.isSkinnedMesh&&u.normalizeSkinWeights(),c.mode===Kt.TRIANGLE_STRIP?u.geometry=re(u.geometry,ut):c.mode===Kt.TRIANGLE_FAN&&(u.geometry=re(u.geometry,ht));else if(c.mode===Kt.LINES)u=new Ce(s,d);else if(c.mode===Kt.LINE_STRIP)u=new Se(s,d);else if(c.mode===Kt.LINE_LOOP)u=new Re(s,d);else{if(c.mode!==Kt.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+c.mode);u=new Qe(s,d)}Object.keys(u.geometry.morphAttributes).length>0&&ls(u,r),u.name=t.createUniqueName(r.name||"mesh_"+e),as(u,r),c.extensions&&os(i,u,c),t.assignFinalMaterial(u),l.push(u)}for(let i=0,r=l.length;i<r;i++)t.associations.set(l[i],{meshes:e,primitives:i});if(1===l.length)return r.extensions&&os(i,l[0],r),l[0];const c=new _e;r.extensions&&os(i,c,r),t.associations.set(c,{meshes:e});for(let e=0,t=l.length;e<t;e++)c.add(l[e]);return c})}loadCamera(e){let t;const s=this.json.cameras[e],i=s[s.type];if(i)return"perspective"===s.type?t=new Ze(ke.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):"orthographic"===s.type&&(t=new Xe(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),as(t,s),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const t=this.json.skins[e],s=[];for(let i=0,r=t.joints.length;i<r;i++)s.push(this._loadNodeShallow(t.joints[i]));return void 0!==t.inverseBindMatrices?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(e){const s=e.pop(),i=e,r=[],n=[];for(let o=0,a=i.length;o<a;o++){const e=i[o];if(e){r.push(e);const t=new Ne;null!==s&&t.fromArray(s.array,16*o),n.push(t)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[o])}return new rt(r,n)})}loadAnimation(e){const t=this.json,s=this,i=t.animations[e],r=i.name?i.name:"animation_"+e,n=[],o=[],a=[],l=[],c=[];for(let h=0,u=i.channels.length;h<u;h++){const e=i.channels[h],t=i.samplers[e.sampler],s=e.target,r=s.node,u=void 0!==i.parameters?i.parameters[t.input]:t.input,d=void 0!==i.parameters?i.parameters[t.output]:t.output;void 0!==s.node&&(n.push(this.getDependency("node",r)),o.push(this.getDependency("accessor",u)),a.push(this.getDependency("accessor",d)),l.push(t),c.push(s))}return Promise.all([Promise.all(n),Promise.all(o),Promise.all(a),Promise.all(l),Promise.all(c)]).then(function(e){const t=e[0],n=e[1],o=e[2],a=e[3],l=e[4],c=[];for(let i=0,r=t.length;i<r;i++){const e=t[i],r=n[i],h=o[i],u=a[i],d=l[i];if(void 0===e)continue;e.updateMatrix&&e.updateMatrix();const p=s._createAnimationTracks(e,r,h,u,d);if(p)for(let t=0;t<p.length;t++)c.push(p[t])}const h=new oe(r,void 0,c);return as(h,i),h})}createNodeMesh(e){const t=this.json,s=this,i=t.nodes[e];return void 0===i.mesh?null:s.getDependency("mesh",i.mesh).then(function(e){const t=s._getNodeRef(s.meshCache,i.mesh,e);return void 0!==i.weights&&t.traverse(function(e){if(e.isMesh)for(let t=0,s=i.weights.length;t<s;t++)e.morphTargetInfluences[t]=i.weights[t]}),t})}loadNode(e){const t=this,s=this.json.nodes[e],i=t._loadNodeShallow(e),r=[],n=s.children||[];for(let a=0,l=n.length;a<l;a++)r.push(t.getDependency("node",n[a]));const o=void 0===s.skin?Promise.resolve(null):t.getDependency("skin",s.skin);return Promise.all([i,Promise.all(r),o]).then(function(e){const t=e[0],s=e[1],i=e[2];null!==i&&t.traverse(function(e){e.isSkinnedMesh&&e.bind(i,ds)});for(let r=0,n=s.length;r<n;r++)t.add(s[r]);return t})}_loadNodeShallow(e){const t=this.json,s=this.extensions,i=this;if(void 0!==this.nodeCache[e])return this.nodeCache[e];const r=t.nodes[e],n=r.name?i.createUniqueName(r.name):"",o=[],a=i._invokeOne(function(t){return t.createNodeMesh&&t.createNodeMesh(e)});return a&&o.push(a),void 0!==r.camera&&o.push(i.getDependency("camera",r.camera).then(function(e){return i._getNodeRef(i.cameraCache,r.camera,e)})),i._invokeAll(function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)}).forEach(function(e){o.push(e)}),this.nodeCache[e]=Promise.all(o).then(function(t){let o;if(o=!0===r.isBone?new ae:t.length>1?new _e:1===t.length?t[0]:new Ke,o!==t[0])for(let e=0,s=t.length;e<s;e++)o.add(t[e]);if(r.name&&(o.userData.name=r.name,o.name=n),as(o,r),r.extensions&&os(s,o,r),void 0!==r.matrix){const e=new Ne;e.fromArray(r.matrix),o.applyMatrix4(e)}else void 0!==r.translation&&o.position.fromArray(r.translation),void 0!==r.rotation&&o.quaternion.fromArray(r.rotation),void 0!==r.scale&&o.scale.fromArray(r.scale);if(i.associations.has(o)){if(void 0!==r.mesh&&i.meshCache.refs[r.mesh]>1){const e=i.associations.get(o);i.associations.set(o,{...e})}}else i.associations.set(o,{});return i.associations.get(o).nodes=e,o}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],i=this,r=new _e;s.name&&(r.name=i.createUniqueName(s.name)),as(r,s),s.extensions&&os(t,r,s);const n=s.nodes||[],o=[];for(let a=0,l=n.length;a<l;a++)o.push(i.getDependency("node",n[a]));return Promise.all(o).then(function(e){for(let t=0,s=e.length;t<s;t++)r.add(e[t]);return i.associations=(e=>{const t=new Map;for(const[s,r]of i.associations)(s instanceof Ue||s instanceof lt)&&t.set(s,r);return e.traverse(e=>{const s=i.associations.get(e);null!=s&&t.set(e,s)}),t})(r),r})}_createAnimationTracks(e,t,s,i,r){const n=[],o=e.name?e.name:e.uuid,a=[];let l;switch(es[r.path]===es.weights?e.traverse(function(e){e.morphTargetInfluences&&a.push(e.name?e.name:e.uuid)}):a.push(o),es[r.path]){case es.weights:l=qe;break;case es.rotation:l=st;break;case es.translation:case es.scale:l=mt;break;default:if(1===s.itemSize)l=qe;else l=mt}const c=void 0!==i.interpolation?ts[i.interpolation]:Pe,h=this._getArrayFromAccessor(s);for(let u=0,d=a.length;u<d;u++){const e=new l(a[u]+"."+es[r.path],t.array,h,c);"CUBICSPLINE"===i.interpolation&&this._createCubicSplineTrackInterpolant(e),n.push(e)}return n}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const e=us(t.constructor),s=new Float32Array(t.length);for(let i=0,r=t.length;i<r;i++)s[i]=t[i]*e;t=s}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(e){return new(this instanceof st?qt:Gt)(this.times,this.values,this.getValueSize()/3,e)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function ms(e,t,s){const i=t.attributes,r=[];function n(t,i){return s.getDependency("accessor",t).then(function(t){e.setAttribute(i,t)})}for(const o in i){const t=Jt[o]||o.toLowerCase();t in e.attributes||r.push(n(i[o],t))}if(void 0!==t.indices&&!e.index){const i=s.getDependency("accessor",t.indices).then(function(t){e.setIndex(t)});r.push(i)}return pe.workingColorSpace!==De&&"COLOR_0"in i&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${pe.workingColorSpace}" not supported.`),as(e,t),function(e,t,s){const i=t.attributes,r=new le;if(void 0===i.POSITION)return;{const e=s.json.accessors[i.POSITION],t=e.min,n=e.max;if(void 0===t||void 0===n)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(r.set(new pt(t[0],t[1],t[2]),new pt(n[0],n[1],n[2])),e.normalized){const t=us(Xt[e.componentType]);r.min.multiplyScalar(t),r.max.multiplyScalar(t)}}const n=t.targets;if(void 0!==n){const e=new pt,t=new pt;for(let i=0,r=n.length;i<r;i++){const r=n[i];if(void 0!==r.POSITION){const i=s.json.accessors[r.POSITION],n=i.min,o=i.max;if(void 0!==n&&void 0!==o){if(t.setX(Math.max(Math.abs(n[0]),Math.abs(o[0]))),t.setY(Math.max(Math.abs(n[1]),Math.abs(o[1]))),t.setZ(Math.max(Math.abs(n[2]),Math.abs(o[2]))),i.normalized){const e=us(Xt[i.componentType]);t.multiplyScalar(e)}e.max(t)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}r.expandByVector(e)}e.boundingBox=r;const o=new ot;r.getCenter(o.center),o.radius=r.min.distanceTo(r.max)/2,e.boundingSphere=o}(e,t,s),Promise.all(r).then(function(){return void 0!==t.targets?function(e,t,s){let i=!1,r=!1,n=!1;for(let c=0,h=t.length;c<h;c++){const e=t[c];if(void 0!==e.POSITION&&(i=!0),void 0!==e.NORMAL&&(r=!0),void 0!==e.COLOR_0&&(n=!0),i&&r&&n)break}if(!i&&!r&&!n)return Promise.resolve(e);const o=[],a=[],l=[];for(let c=0,h=t.length;c<h;c++){const h=t[c];if(i){const t=void 0!==h.POSITION?s.getDependency("accessor",h.POSITION):e.attributes.position;o.push(t)}if(r){const t=void 0!==h.NORMAL?s.getDependency("accessor",h.NORMAL):e.attributes.normal;a.push(t)}if(n){const t=void 0!==h.COLOR_0?s.getDependency("accessor",h.COLOR_0):e.attributes.color;l.push(t)}}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(t){const s=t[0],o=t[1],a=t[2];return i&&(e.morphAttributes.position=s),r&&(e.morphAttributes.normal=o),n&&(e.morphAttributes.color=a),e.morphTargetsRelative=!0,e})}(e,t.targets,s):e})}class fs{get unloadPriorityCallback(){return this._unloadPriorityCallback}set unloadPriorityCallback(e){1===e.length?(console.warn('LRUCache: "unloadPriorityCallback" function has been changed to take two arguments.'),this._unloadPriorityCallback=(t,s)=>{const i=e(t),r=e(s);return i<r?-1:i>r?1:0}):this._unloadPriorityCallback=e}constructor(){this.minSize=6e3,this.maxSize=8e3,this.minBytesSize=322122547.2,this.maxBytesSize=429496729.6,this.unloadPercent=.05,this.autoMarkUnused=!0,this.itemSet=new Map,this.itemList=[],this.usedSet=new Set,this.callbacks=new Map,this.unloadingHandle=-1,this.cachedBytes=0,this.bytesMap=new Map,this.loadedSet=new Set,this._unloadPriorityCallback=null;const e=this.itemSet;this.defaultPriorityCallback=t=>e.get(t)}isFull(){return this.itemSet.size>=this.maxSize||this.cachedBytes>=this.maxBytesSize}getMemoryUsage(e){return this.bytesMap.get(e)||0}setMemoryUsage(e,t){const{bytesMap:s,itemSet:i}=this;i.has(e)&&(this.cachedBytes-=s.get(e)||0,s.set(e,t),this.cachedBytes+=t)}add(e,t){const s=this.itemSet;if(s.has(e)||this.isFull())return!1;const i=this.usedSet,r=this.itemList,n=this.callbacks;return r.push(e),i.add(e),s.set(e,Date.now()),n.set(e,t),!0}has(e){return this.itemSet.has(e)}remove(e){const t=this.usedSet,s=this.itemSet,i=this.itemList,r=this.bytesMap,n=this.callbacks,o=this.loadedSet;if(s.has(e)){this.cachedBytes-=r.get(e)||0,r.delete(e),n.get(e)(e);const a=i.indexOf(e);return i.splice(a,1),t.delete(e),s.delete(e),n.delete(e),o.delete(e),!0}return!1}setLoaded(e,t){const{itemSet:s,loadedSet:i}=this;s.has(e)&&(!0===t?i.add(e):i.delete(e))}markUsed(e){const t=this.itemSet,s=this.usedSet;t.has(e)&&!s.has(e)&&(t.set(e,Date.now()),s.add(e))}markUnused(e){this.usedSet.delete(e)}markAllUnused(){this.usedSet.clear()}unloadUnusedContent(){const{unloadPercent:e,minSize:t,maxSize:s,itemList:i,itemSet:r,usedSet:n,loadedSet:o,callbacks:a,bytesMap:l,minBytesSize:c,maxBytesSize:h}=this,u=i.length-n.size,d=i.length-o.size,p=Math.max(Math.min(i.length-t,u),0),m=this.cachedBytes-c,f=this.unloadPriorityCallback||this.defaultPriorityCallback;let g=!1;const y=p>0&&u>0||d&&i.length>s;if(u&&this.cachedBytes>c||d&&this.cachedBytes>h||y){i.sort((e,t)=>{const s=n.has(e);if(s===n.has(t)){const s=o.has(e);return s===o.has(t)?-f(e,t):s?1:-1}return s?1:-1});const d=Math.max(t*e,p*e),y=Math.ceil(Math.min(d,u,p)),_=Math.max(e*m,e*c),x=Math.min(_,m);let T=0,b=0;for(;this.cachedBytes-b>h||i.length-T>s;){const e=i[T],t=l.get(e)||0;if(n.has(e)&&o.has(e)||this.cachedBytes-b-t<h&&i.length-T<=s)break;b+=t,T++}for(;b<x||T<y;){const e=i[T],t=l.get(e)||0;if(n.has(e)||this.cachedBytes-b-t<c&&T>=y)break;b+=t,T++}i.splice(0,T).forEach(e=>{this.cachedBytes-=l.get(e)||0,a.get(e)(e),l.delete(e),r.delete(e),a.delete(e),o.delete(e),n.delete(e)}),g=T<p||b<m&&T<u,g=g&&T>0}g&&(this.unloadingHandle=requestAnimationFrame(()=>this.scheduleUnload()))}scheduleUnload(){cancelAnimationFrame(this.unloadingHandle),this.scheduled||(this.scheduled=!0,queueMicrotask(()=>{this.scheduled=!1,this.unloadUnusedContent()}))}}let gs=class{get running(){return 0!==this.items.length||0!==this.currJobs}constructor(){this.maxJobs=6,this.items=[],this.callbacks=new Map,this.currJobs=0,this.scheduled=!1,this.autoUpdate=!0,this.priorityCallback=null,this.schedulingCallback=e=>{requestAnimationFrame(e)},this._runjobs=()=>{this.scheduled=!1,this.tryRunJobs()}}sort(){const e=this.priorityCallback,t=this.items;null!==e&&t.sort(e)}has(e){return this.callbacks.has(e)}add(e,t){const s={callback:t,reject:null,resolve:null,promise:null};return s.promise=new Promise((t,i)=>{const r=this.items,n=this.callbacks;s.resolve=t,s.reject=i,r.unshift(e),n.set(e,s),this.autoUpdate&&this.scheduleJobRun()}),s.promise}remove(e){const t=this.items,s=this.callbacks,i=t.indexOf(e);if(-1!==i){const r=s.get(e);r.promise.catch(()=>{}),r.reject(new Error("PriorityQueue: Item removed.")),t.splice(i,1),s.delete(e)}}removeByFilter(e){const{items:t}=this;for(let s=0;s<t.length;s++){const i=t[s];e(i)&&this.remove(i)}}tryRunJobs(){this.sort();const e=this.items,t=this.callbacks,s=this.maxJobs;let i=0;const r=()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()};for(;s>this.currJobs&&e.length>0&&i<s;){this.currJobs++,i++;const s=e.pop(),{callback:n,resolve:o,reject:a}=t.get(s);let l;t.delete(s);try{l=n(s)}catch(Js){a(Js),r()}l instanceof Promise?l.then(o).catch(a).finally(r):(o(l),r())}}scheduleJobRun(){this.scheduled||(this.schedulingCallback(this._runjobs),this.scheduled=!0)}};const ys=-1,_s=6378137;function xs(e,t=null,s=null){const i=[];for(i.push(e),i.push(null),i.push(0);i.length>0;){const e=i.pop(),r=i.pop(),n=i.pop();if(t&&t(n,r,e))return void(s&&s(n,r,e));const o=n.children;if(o)for(let t=o.length-1;t>=0;t--)i.push(o[t]),i.push(n),i.push(e+1);s&&s(n,r,e)}}function Ts(e){if(null===e||e.byteLength<4)return"";let t;if(t=e instanceof DataView?e:new DataView(e),"{"===String.fromCharCode(t.getUint8(0)))return null;let s="";for(let i=0;i<4;i++)s+=String.fromCharCode(t.getUint8(i));return s}const bs=new TextDecoder;function ws(e){return bs.decode(e)}function vs(e){return e.replace(/[\\/][^\\/]+$/,"")+"/"}let Ms=class{constructor(){this.fetchOptions={},this.workingPath=""}load(...e){return console.warn('Loader: "load" function has been deprecated in favor of "loadAsync".'),this.loadAsync(...e)}loadAsync(e){return fetch(e,this.fetchOptions).then(t=>{if(!t.ok)throw new Error(`Failed to load file "${e}" with status ${t.status} : ${t.statusText}`);return t.arrayBuffer()}).then(t=>(""===this.workingPath&&(this.workingPath=vs(e)),this.parse(t)))}resolveExternalURL(e){return new URL(e,this.workingPath).href}parse(e){throw new Error("LoaderBase: Parse not implemented.")}};function Ps(e){if(!e)return null;let t=e.length;const s=e.indexOf("?"),i=e.indexOf("#");-1!==s&&(t=Math.min(t,s)),-1!==i&&(t=Math.min(t,i));const r=e.lastIndexOf(".",t),n=e.lastIndexOf("/",t),o=e.indexOf("://");return-1!==o&&o+2===n||-1===r||r<n?null:e.substring(r+1,t)||null}const Ss={inView:!1,error:1/0,distanceFromCamera:1/0};function Es(e){return 3===e||e===ys}function Rs(e,t){return e.__lastFrameVisited===t&&e.__used}function Cs(e){return e.__childrenProcessed===e.children.length}function As(e,t){e.__lastFrameVisited!==t.frameCount&&(e.__lastFrameVisited=t.frameCount,e.__used=!1,e.__inFrustum=!1,e.__isLeaf=!1,e.__visible=!1,e.__active=!1,e.__error=1/0,e.__distanceFromCamera=1/0,e.__allChildrenLoaded=!1,t.calculateTileViewError(e,Ss),e.__inFrustum=Ss.inView,e.__error=Ss.error,e.__distanceFromCamera=Ss.distanceFromCamera)}function Ls(e,t){if(t.ensureChildrenArePreprocessed(e),As(e,t),Ds(e,t),e.__hasUnrenderableContent&&Cs(e)){const s=e.children;for(let e=0,i=s.length;e<i;e++)Ls(s[e],t)}}function Is(e,t){if(t.ensureChildrenArePreprocessed(e),Rs(e,t.frameCount)&&(e.__hasContent&&t.queueTileForDownload(e),Cs(e))){const s=e.children;for(let e=0,i=s.length;e<i;e++)Is(s[e],t)}}function Ds(e,t){e.__used||(e.__used=!0,t.markTileUsed(e),t.stats.used++,!0===e.__inFrustum&&t.stats.inFrustum++)}function Fs(e,t){if(t.ensureChildrenArePreprocessed(e),As(e,t),!e.__inFrustum)return;if(!function(e,t){return!(e.__error<=t.errorTarget&&!e.__hasUnrenderableContent||t.maxDepth>0&&e.__depth+1>=t.maxDepth||!Cs(e))}(e,t))return void Ds(e,t);let s=!1,i=!1;const r=e.children;for(let n=0,o=r.length;n<o;n++){const e=r[n];Fs(e,t),s=s||Rs(e,t.frameCount),i=i||e.__inFrustum}if(Ds(e,t),s&&"REPLACE"===e.refine&&(e.__depth,1))for(let n=0,o=r.length;n<o;n++){Ls(r[n],t)}}function Os(e,t){const s=t.frameCount;if(!Rs(e,s))return;const i=e.children;let r=!1;for(let n=0,o=i.length;n<o;n++){const e=i[n];r=r||Rs(e,s)}if(r){let r=!0;for(let e=0,n=i.length;e<n;e++){const n=i[e];if(Os(n,t),Rs(n,s)){const e=n.__allChildrenLoaded||!n.__hasContent||n.__hasRenderableContent&&Es(n.__loadingState)||n.__hasUnrenderableContent&&n.__loadingState===ys;r=r&&e}}e.__allChildrenLoaded=r}else e.__isLeaf=!0}function Us(e,t){const s=t.stats;if(!Rs(e,t.frameCount))return;if(e.__isLeaf)return void(3===e.__loadingState?(e.__inFrustum&&(e.__visible=!0,s.visible++),e.__active=!0,s.active++):e.__hasContent&&t.queueTileForDownload(e));const i=e.children,r=e.__hasContent,n=Es(e.__loadingState)&&r,o=(t.errorTarget+1)*t.errorThreshold,a=e.__error<=o,l="ADD"===e.refine,c=e.__allChildrenLoaded||0===e.__depth&&!1;if(r&&(a||l)&&t.queueTileForDownload(e),(a&&n&&!c||n&&l)&&(e.__inFrustum&&(e.__visible=!0,s.visible++),e.__active=!0,s.active++),l||!a||c)for(let h=0,u=i.length;h<u;h++)Us(i[h],t);else for(let h=0,u=i.length;h<u;h++){const e=i[h];Rs(e,t.frameCount)&&Is(e,t)}}function ks(e,t){const s=Rs(e,t.frameCount);if(s||e.__usedLastFrame){let i=!1,r=!1;s?(i=e.__active,r=t.displayActiveTiles&&e.__active||e.__visible):As(e,t),e.__hasRenderableContent&&3===e.__loadingState&&(e.__wasSetActive!==i&&t.invokeOnePlugin(t=>t.setTileActive&&t.setTileActive(e,i)),e.__wasSetVisible!==r&&t.invokeOnePlugin(t=>t.setTileVisible&&t.setTileVisible(e,r))),e.__wasSetActive=i,e.__wasSetVisible=r,e.__usedLastFrame=s;const n=e.children;for(let e=0,s=n.length;e<s;e++){ks(n[e],t)}}}const Ns=Symbol("PLUGIN_REGISTERED"),zs=(e,t)=>{const s=e.priority||0,i=t.priority||0;return s!==i?s>i?1:-1:e.__used!==t.__used?e.__used?1:-1:e.__error!==t.__error?e.__error>t.__error?1:-1:e.__distanceFromCamera!==t.__distanceFromCamera?e.__distanceFromCamera>t.__distanceFromCamera?-1:1:e.__depthFromRenderedParent!==t.__depthFromRenderedParent?e.__depthFromRenderedParent>t.__depthFromRenderedParent?-1:1:0},Bs=(e,t)=>{const s=e.priority||0,i=t.priority||0;return s!==i?s>i?1:-1:e.__lastFrameVisited!==t.__lastFrameVisited?e.__lastFrameVisited>t.__lastFrameVisited?-1:1:e.__depthFromRenderedParent!==t.__depthFromRenderedParent?e.__depthFromRenderedParent>t.__depthFromRenderedParent?1:-1:e.__loadingState!==t.__loadingState?e.__loadingState>t.__loadingState?-1:1:e.__hasUnrenderableContent!==t.__hasUnrenderableContent?e.__hasUnrenderableContent?-1:1:e.__error!==t.__error?e.__error>t.__error?-1:1:0};let Vs=class{get root(){const e=this.rootTileSet;return e?e.root:null}get loadProgress(){const{stats:e,isLoading:t}=this,s=e.downloading+e.parsing,i=e.inCacheSinceLoad+(t?1:0);return 0===i?1:1-s/i}get errorThreshold(){return this._errorThreshold}set errorThreshold(e){console.warn('TilesRenderer: The "errorThreshold" option has been deprecated.'),this._errorThreshold=e}constructor(e=null){this.rootLoadingState=0,this.rootTileSet=null,this.rootURL=e,this.fetchOptions={},this.plugins=[],this.queuedTiles=[],this.cachedSinceLoadComplete=new Set,this.isLoading=!1;const t=new fs;t.unloadPriorityCallback=Bs;const s=new gs;s.maxJobs=25,s.priorityCallback=zs;const i=new gs;i.maxJobs=5,i.priorityCallback=zs;const r=new gs;r.maxJobs=25,this.processedTiles=new WeakSet,this.visibleTiles=new Set,this.activeTiles=new Set,this.usedSet=new Set,this.lruCache=t,this.downloadQueue=s,this.parseQueue=i,this.processNodeQueue=r,this.stats={inCacheSinceLoad:0,inCache:0,parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0,this._dispatchNeedsUpdateEvent=function(e){let t=null;return()=>{null===t&&(t=requestAnimationFrame(()=>{t=null,e()}))}}(()=>{this.dispatchEvent({type:"needs-update"})}),this.errorTarget=16,this._errorThreshold=1/0,this.displayActiveTiles=!1,this.maxDepth=1/0}registerPlugin(e){if(!0===e[Ns])throw new Error("TilesRendererBase: A plugin can only be registered to a single tile set");const t=this.plugins,s=e.priority||0;let i=t.length;for(let r=0;r<t.length;r++)if((t[r].priority||0)>s){i=r;break}t.splice(i,0,e),e[Ns]=!0,e.init&&e.init(this)}unregisterPlugin(e){const t=this.plugins;if("string"==typeof e&&(e=this.getPluginByName(name)),t.includes(e)){const s=t.indexOf(e);return t.splice(s,1),e.dispose&&e.dispose(),!0}return!1}getPluginByName(e){return this.plugins.find(t=>t.name===e)||null}traverse(e,t,s=!0){this.root&&xs(this.root,(t,...i)=>(s&&this.ensureChildrenArePreprocessed(t,!0),!!e&&e(t,...i)),t)}queueTileForDownload(e){0!==e.__loadingState||this.lruCache.isFull()||this.queuedTiles.push(e)}markTileUsed(e){this.usedSet.add(e),this.lruCache.markUsed(e)}update(){const{lruCache:e,usedSet:t,stats:s,root:i,downloadQueue:r,parseQueue:n,processNodeQueue:o}=this;if(0===this.rootLoadingState&&(this.rootLoadingState=1,this.invokeOnePlugin(e=>e.loadRootTileSet&&e.loadRootTileSet()).then(e=>{let t=this.rootURL;null!==t&&this.invokeAllPlugins(e=>t=e.preprocessURL?e.preprocessURL(t,null):t),this.rootLoadingState=3,this.rootTileSet=e,this.dispatchEvent({type:"needs-update"}),this.dispatchEvent({type:"load-content"}),this.dispatchEvent({type:"load-tile-set",tileSet:e,url:t})}).catch(e=>{this.rootLoadingState=ys,console.error(e),this.rootTileSet=null,this.dispatchEvent({type:"load-error",tile:null,error:e,url:this.rootURL})})),!i)return;s.inFrustum=0,s.used=0,s.active=0,s.visible=0,this.frameCount++,t.forEach(t=>e.markUnused(t)),t.clear(),Fs(i,this),Os(i,this),Us(i,this),ks(i,this);const a=this.queuedTiles;a.sort(e.unloadPriorityCallback);for(let l=0,c=a.length;l<c&&!e.isFull();l++)this.requestTileContents(a[l]);a.length=0,e.scheduleUnload(),!1===(r.running||n.running||o.running)&&!0===this.isLoading&&(this.cachedSinceLoadComplete.clear(),s.inCacheSinceLoad=0,this.dispatchEvent({type:"tiles-load-end"}),this.isLoading=!1)}resetFailedTiles(){this.rootLoadingState===ys&&(this.rootLoadingState=0);const e=this.stats;0!==e.failed&&(this.traverse(e=>{e.__loadingState===ys&&(e.__loadingState=0)},null,!1),e.failed=0)}dispose(){[...this.plugins].forEach(e=>{this.unregisterPlugin(e)});const e=this.lruCache,t=[];this.traverse(e=>(t.push(e),!1),null,!1);for(let s=0,i=t.length;s<i;s++)e.remove(t[s]);this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0}calculateBytesUsed(e,t){return 0}dispatchEvent(e){}fetchData(e,t){return fetch(e,t)}parseTile(e,t,s){return null}disposeTile(e){e.__visible&&(this.invokeOnePlugin(t=>t.setTileVisible&&t.setTileVisible(e,!1)),e.__visible=!1),e.__active&&(this.invokeOnePlugin(t=>t.setTileActive&&t.setTileActive(e,!1)),e.__active=!1)}preprocessNode(e,t,s=null){var i;if(this.processedTiles.add(e),e.content&&(!("uri"in e.content)&&"url"in e.content&&(e.content.uri=e.content.url,delete e.content.url),e.content.boundingVolume&&!("box"in e.content.boundingVolume||"sphere"in e.content.boundingVolume||"region"in e.content.boundingVolume)&&delete e.content.boundingVolume),e.parent=s,e.children=e.children||[],null!=(i=e.content)&&i.uri){const t=Ps(e.content.uri);e.__hasContent=!0,e.__hasUnrenderableContent=!(!t||!/json$/.test(t)),e.__hasRenderableContent=!e.__hasUnrenderableContent}else e.__hasContent=!1,e.__hasUnrenderableContent=!1,e.__hasRenderableContent=!1;e.__childrenProcessed=0,s&&s.__childrenProcessed++,e.__distanceFromCamera=1/0,e.__error=1/0,e.__inFrustum=!1,e.__isLeaf=!1,e.__usedLastFrame=!1,e.__used=!1,e.__wasSetVisible=!1,e.__visible=!1,e.__allChildrenLoaded=!1,e.__wasSetActive=!1,e.__active=!1,e.__loadingState=0,null===s?(e.__depth=0,e.__depthFromRenderedParent=e.__hasRenderableContent?1:0,e.refine=e.refine||"REPLACE"):(e.__depth=s.__depth+1,e.__depthFromRenderedParent=s.__depthFromRenderedParent+(e.__hasRenderableContent?1:0),e.refine=e.refine||s.refine),e.__basePath=t,e.__lastFrameVisited=-1,this.invokeAllPlugins(i=>{i!==this&&i.preprocessNode&&i.preprocessNode(e,t,s)})}setTileActive(e,t){t?this.activeTiles.add(e):this.activeTiles.delete(e)}setTileVisible(e,t){t?this.visibleTiles.add(e):this.visibleTiles.delete(e)}calculateTileViewError(e,t){}ensureChildrenArePreprocessed(e,t=!1){const s=e.children;for(let i=0,r=s.length;i<r;i++){const r=s[i];if("__depth"in r)break;t?(this.processNodeQueue.remove(r),this.preprocessNode(r,e.__basePath,e)):this.processNodeQueue.has(r)||this.processNodeQueue.add(r,t=>{this.preprocessNode(t,e.__basePath,e),this._dispatchNeedsUpdateEvent()})}}getBytesUsed(e){let t=0;return this.invokeAllPlugins(s=>{s.calculateBytesUsed&&(t+=s.calculateBytesUsed(e,e.cached.scene)||0)}),t}recalculateBytesUsed(e=null){const{lruCache:t,processedTiles:s}=this;null===e?t.itemSet.forEach(e=>{s.has(e)&&t.setMemoryUsage(e,this.getBytesUsed(e))}):t.setMemoryUsage(e,this.getBytesUsed(e))}preprocessTileSet(e,t,s=null){const i=e.asset.version,[r,n]=i.split(".").map(e=>parseInt(e));console.assert(r<=1,"TilesRenderer: asset.version is expected to be a 1.x or a compatible version."),1===r&&n>0&&console.warn("TilesRenderer: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.");let o=t.replace(/\/[^/]*$/,"");o=new URL(o,window.location.href).toString(),this.preprocessNode(e.root,o,s)}loadRootTileSet(){let e=this.rootURL;return this.invokeAllPlugins(t=>e=t.preprocessURL?t.preprocessURL(e,null):e),this.invokeOnePlugin(t=>t.fetchData&&t.fetchData(e,this.fetchOptions)).then(t=>{if(t instanceof Response){if(t.ok)return t.json();throw new Error(`TilesRenderer: Failed to load tileset "${e}" with status ${t.status} : ${t.statusText}`)}return t}).then(t=>(this.preprocessTileSet(t,e),t))}requestTileContents(e){if(0!==e.__loadingState)return;let t=!1,s=null,i=new URL(e.content.uri,e.__basePath+"/").toString();this.invokeAllPlugins(t=>i=t.preprocessURL?t.preprocessURL(i,e):i);const r=this.stats,n=this.lruCache,o=this.downloadQueue,a=this.parseQueue,l=Ps(i),c=new AbortController,h=c.signal;return n.add(e,s=>{c.abort(),t?(s.children.length=0,s.__childrenProcessed=0):this.invokeAllPlugins(e=>{e.disposeTile&&e.disposeTile(s)}),r.inCache--,this.cachedSinceLoadComplete.has(e)&&(this.cachedSinceLoadComplete.delete(e),r.inCacheSinceLoad--),1===s.__loadingState?r.downloading--:2===s.__loadingState&&r.parsing--,s.__loadingState=0,a.remove(s),o.remove(s)})?(this.isLoading||(this.isLoading=!0,this.dispatchEvent({type:"tiles-load-start"})),n.setMemoryUsage(e,this.getBytesUsed(e)),this.cachedSinceLoadComplete.add(e),r.inCacheSinceLoad++,r.inCache++,r.downloading++,e.__loadingState=1,o.add(e,t=>{if(h.aborted)return Promise.resolve();const s=this.invokeOnePlugin(e=>e.fetchData&&e.fetchData(i,{...this.fetchOptions,signal:h}));return this.dispatchEvent({type:"tile-download-start",tile:e}),s}).then(e=>{if(!h.aborted){if(e instanceof Response){if(e.ok)return"json"===l?e.json():e.arrayBuffer();throw new Error(`Failed to load model with error code ${e.status}`)}return e}}).then(n=>{if(!h.aborted)return r.downloading--,r.parsing++,e.__loadingState=2,a.add(e,r=>h.aborted?Promise.resolve():"json"===l&&n.root?(this.preprocessTileSet(n,i,e),e.children.push(n.root),s=n,t=!0,Promise.resolve()):this.invokeOnePlugin(e=>e.parseTile&&e.parseTile(n,r,l,i,h)))}).then(()=>{if(h.aborted)return;r.parsing--,e.__loadingState=3,n.setLoaded(e,!0);const o=this.getBytesUsed(e);0===n.getMemoryUsage(e)&&o>0&&n.isFull()?n.remove(e):(n.setMemoryUsage(e,o),this.dispatchEvent({type:"needs-update"}),this.dispatchEvent({type:"load-content"}),t&&this.dispatchEvent({type:"load-tile-set",tileSet:s,url:i}),e.cached.scene&&this.dispatchEvent({type:"load-model",scene:e.cached.scene,tile:e}))}).catch(t=>{h.aborted||("AbortError"!==t.name?(a.remove(e),o.remove(e),2===e.__loadingState?r.parsing--:1===e.__loadingState&&r.downloading--,r.failed++,console.error(`TilesRenderer : Failed to load tile at url "${e.content.uri}".`),console.error(t),e.__loadingState=ys,n.setLoaded(e,!0),this.dispatchEvent({type:"load-error",tile:e,error:t,url:i})):n.remove(e))})):void 0}getAttributions(e=[]){return this.invokeAllPlugins(t=>t!==this&&t.getAttributions&&t.getAttributions(e)),e}invokeOnePlugin(e){const t=[...this.plugins,this];for(let s=0;s<t.length;s++){const i=e(t[s]);if(i)return i}return null}invokeAllPlugins(e){const t=[...this.plugins,this],s=[];for(let i=0;i<t.length;i++){const r=e(t[i]);r&&s.push(r)}return 0===s.length?null:Promise.all(s)}};function Hs(e,t,s,i,r,n){let o,a;switch(i){case"SCALAR":o=1;break;case"VEC2":o=2;break;case"VEC3":o=3;break;case"VEC4":o=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${n}".`)}const l=s*o;switch(r){case"BYTE":a=new Int8Array(e,t,l);break;case"UNSIGNED_BYTE":a=new Uint8Array(e,t,l);break;case"SHORT":a=new Int16Array(e,t,l);break;case"UNSIGNED_SHORT":a=new Uint16Array(e,t,l);break;case"INT":a=new Int32Array(e,t,l);break;case"UNSIGNED_INT":a=new Uint32Array(e,t,l);break;case"FLOAT":a=new Float32Array(e,t,l);break;case"DOUBLE":a=new Float64Array(e,t,l);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${n}".`)}return a}class $s{constructor(e,t,s,i){this.buffer=e,this.binOffset=t+s,this.binLength=i;let r=null;if(0!==s){const i=new Uint8Array(e,t,s);r=JSON.parse(ws(i))}else r={};this.header=r}getKeys(){return Object.keys(this.header).filter(e=>"extensions"!==e)}getData(e,t,s=null,i=null){const r=this.header;if(!(e in r))return null;const n=r[e];if(n instanceof Object){if(Array.isArray(n))return n;{const{buffer:r,binOffset:o,binLength:a}=this,l=n.byteOffset||0,c=n.type||i,h=n.componentType||s;if("type"in n&&i&&n.type!==i)throw new Error("FeatureTable: Specified type does not match expected type.");const u=o+l,d=Hs(r,u,t,c,h,e);if(u+d.byteLength>o+a)throw new Error("FeatureTable: Feature data read outside binary body length.");return d}}return n}getBuffer(e,t){const{buffer:s,binOffset:i}=this;return s.slice(i+e,i+e+t)}}let js=class{constructor(e){this.batchTable=e;const t=e.header.extensions["3DTILES_batch_table_hierarchy"];this.classes=t.classes;for(const i of this.classes){const e=i.instances;for(const t in e)i.instances[t]=this._parseProperty(e[t],i.length,t)}if(this.instancesLength=t.instancesLength,this.classIds=this._parseProperty(t.classIds,this.instancesLength,"classIds"),t.parentCounts?this.parentCounts=this._parseProperty(t.parentCounts,this.instancesLength,"parentCounts"):this.parentCounts=new Array(this.instancesLength).fill(1),t.parentIds){const e=this.parentCounts.reduce((e,t)=>e+t,0);this.parentIds=this._parseProperty(t.parentIds,e,"parentIds")}else this.parentIds=null;this.instancesIds=[];const s={};for(const i of this.classIds)s[i]=s[i]??0,this.instancesIds.push(s[i]),s[i]++}_parseProperty(e,t,s){if(Array.isArray(e))return e;{const{buffer:i,binOffset:r}=this.batchTable;return Hs(i,r+e.byteOffset,t,"SCALAR",e.componentType||"UNSIGNED_SHORT",s)}}getDataFromId(e,t={}){const s=this.parentCounts[e];if(this.parentIds&&s>0){let i=0;for(let t=0;t<e;t++)i+=this.parentCounts[t];for(let r=0;r<s;r++){const s=this.parentIds[i+r];s!==e&&this.getDataFromId(s,t)}}const i=this.classIds[e],r=this.classes[i].instances,n=this.classes[i].name,o=this.instancesIds[e];for(const a in r)t[n]=t[n]||{},t[n][a]=r[a][o];return t}},Gs=class extends $s{get batchSize(){return console.warn("BatchTable.batchSize has been deprecated and replaced with BatchTable.count."),this.count}constructor(e,t,s,i,r){super(e,s,i,r),this.count=t,this.extensions={};const n=this.header.extensions;n&&n["3DTILES_batch_table_hierarchy"]&&(this.extensions["3DTILES_batch_table_hierarchy"]=new js(this))}getData(e,t=null,s=null){return console.warn("BatchTable: BatchTable.getData is deprecated. Use BatchTable.getDataFromId to get allproperties for an id or BatchTable.getPropertyArray for getting an array of value for a property."),super.getData(e,this.count,t,s)}getDataFromId(e,t={}){if(e<0||e>=this.count)throw new Error(`BatchTable: id value "${e}" out of bounds for "${this.count}" features number.`);for(const s of this.getKeys())t[s]=super.getData(s,this.count)[e];for(const s in this.extensions){const i=this.extensions[s];i.getDataFromId instanceof Function&&(t[s]=t[s]||{},i.getDataFromId(e,t[s]))}return t}getPropertyArray(e){return super.getData(e,this.count)}},Ws=class extends Ms{parse(e){const t=new DataView(e),s=Ts(t);console.assert("b3dm"===s);const i=t.getUint32(4,!0);console.assert(1===i);const r=t.getUint32(8,!0);console.assert(r===e.byteLength);const n=t.getUint32(12,!0),o=t.getUint32(16,!0),a=t.getUint32(20,!0),l=t.getUint32(24,!0),c=e.slice(28,28+n+o),h=new $s(c,0,n,o),u=28+n+o,d=e.slice(u,u+a+l),p=new Gs(d,h.getData("BATCH_LENGTH"),0,a,l),m=u+a+l;return{version:i,featureTable:h,batchTable:p,glbBytes:new Uint8Array(e,m,r-m)}}},qs=class extends Ms{parse(e){const t=new DataView(e),s=Ts(t);console.assert("i3dm"===s);const i=t.getUint32(4,!0);console.assert(1===i);const r=t.getUint32(8,!0);console.assert(r===e.byteLength);const n=t.getUint32(12,!0),o=t.getUint32(16,!0),a=t.getUint32(20,!0),l=t.getUint32(24,!0),c=t.getUint32(28,!0),h=e.slice(32,32+n+o),u=new $s(h,0,n,o),d=32+n+o,p=e.slice(d,d+a+l),m=new Gs(p,u.getData("INSTANCES_LENGTH"),0,a,l),f=d+a+l,g=new Uint8Array(e,f,r-f);let y=null,_=null,x=null;if(c)y=g,_=Promise.resolve();else{const e=this.resolveExternalURL(ws(g));x=vs(e),_=fetch(e,this.fetchOptions).then(t=>{if(!t.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${e}" with status ${t.status} : ${t.statusText}`);return t.arrayBuffer()}).then(e=>{y=new Uint8Array(e)})}return _.then(()=>({version:i,featureTable:u,batchTable:m,glbBytes:y,gltfWorkingPath:x}))}},Ks=class extends Ms{parse(e){const t=new DataView(e),s=Ts(t);console.assert("pnts"===s);const i=t.getUint32(4,!0);console.assert(1===i);const r=t.getUint32(8,!0);console.assert(r===e.byteLength);const n=t.getUint32(12,!0),o=t.getUint32(16,!0),a=t.getUint32(20,!0),l=t.getUint32(24,!0),c=e.slice(28,28+n+o),h=new $s(c,0,n,o),u=28+n+o,d=e.slice(u,u+a+l),p=new Gs(d,h.getData("BATCH_LENGTH")||h.getData("POINTS_LENGTH"),0,a,l);return Promise.resolve({version:i,featureTable:h,batchTable:p})}},Xs=class extends Ms{parse(e){const t=new DataView(e),s=Ts(t);console.assert("cmpt"===s,'CMPTLoader: The magic bytes equal "cmpt".');const i=t.getUint32(4,!0);console.assert(1===i,'CMPTLoader: The version listed in the header is "1".');const r=t.getUint32(8,!0);console.assert(r===e.byteLength,"CMPTLoader: The contents buffer length listed in the header matches the file.");const n=t.getUint32(12,!0),o=[];let a=16;for(let l=0;l<n;l++){const t=new DataView(e,a,12),s=Ts(t),i=t.getUint32(4,!0),r=t.getUint32(8,!0),n=new Uint8Array(e,a,r);o.push({type:s,buffer:n,version:i}),a+=r}return{version:i,tiles:o}}};const Zs=await H("three"),{MathUtils:Ys,Spherical:Qs,Vector3:Js,Matrix4:ei,Sphere:ti,Ray:si,Euler:ii,Box3:ri,Plane:ni}=await H("three");new Qs,new Js;const oi=new Qs,ai=new Js,li=new Js,ci=new Js,hi=new ei,ui=new ei,di=new ei,pi=new ti,mi=new ii,fi=new Js,gi=new Js,yi=new Js,_i=new Js,xi=new si;let Ti=class{constructor(e=1,t=1,s=1){this.name="",this.radius=new Js(e,t,s)}intersectRay(e,t){return hi.makeScale(...this.radius).invert(),pi.center.set(0,0,0),pi.radius=1,xi.copy(e).applyMatrix4(hi),xi.intersectSphere(pi,t)?(hi.makeScale(...this.radius),t.applyMatrix4(hi),t):null}getEastNorthUpFrame(e,t,s,i){return s.isMatrix4&&(i=s,s=0,console.warn('Ellipsoid: The signature for "getEastNorthUpFrame" has changed.')),this.getEastNorthUpAxes(e,t,fi,gi,yi),this.getCartographicToPosition(e,t,s,_i),i.makeBasis(fi,gi,yi).setPosition(_i)}getOrientedEastNorthUpFrame(e,t,s,i,r,n,o){return this.getObjectFrame(e,t,s,i,r,n,o,0)}getObjectFrame(e,t,s,i,r,n,o,a=2){return this.getEastNorthUpFrame(e,t,s,hi),mi.set(r,n,-i,"ZXY"),o.makeRotationFromEuler(mi).premultiply(hi),1===a?(mi.set(Math.PI/2,0,0,"XYZ"),ui.makeRotationFromEuler(mi),o.multiply(ui)):2===a&&(mi.set(-Math.PI/2,0,Math.PI,"XYZ"),ui.makeRotationFromEuler(mi),o.multiply(ui)),o}getCartographicFromObjectFrame(e,t,s=2){return 1===s?(mi.set(-Math.PI/2,0,0,"XYZ"),ui.makeRotationFromEuler(mi).premultiply(e)):2===s?(mi.set(-Math.PI/2,0,Math.PI,"XYZ"),ui.makeRotationFromEuler(mi).premultiply(e)):ui.copy(e),_i.setFromMatrixPosition(ui),this.getPositionToCartographic(_i,t),this.getEastNorthUpFrame(t.lat,t.lon,0,hi).invert(),ui.premultiply(hi),mi.setFromRotationMatrix(ui,"ZXY"),t.azimuth=-mi.z,t.elevation=mi.x,t.roll=mi.y,t}getEastNorthUpAxes(e,t,s,i,r,n=_i){this.getCartographicToPosition(e,t,0,n),this.getCartographicToNormal(e,t,r),s.set(-n.y,n.x,0).normalize(),i.crossVectors(r,s).normalize()}getAzElRollFromRotationMatrix(e,t,s,i,r=0){return console.warn('Ellipsoid: "getAzElRollFromRotationMatrix" is deprecated. Use "getCartographicFromObjectFrame", instead.'),this.getCartographicToPosition(e,t,0,_i),di.copy(s).setPosition(_i),this.getCartographicFromObjectFrame(di,i,r),delete i.height,delete i.lat,delete i.lon,i}getRotationMatrixFromAzElRoll(e,t,s,i,r,n,o=0){return console.warn('Ellipsoid: "getRotationMatrixFromAzElRoll" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(e,t,0,s,i,r,n,o),n.setPosition(0,0,0),n}getFrame(e,t,s,i,r,n,o,a=0){return console.warn('Ellipsoid: "getFrame" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(e,t,n,s,i,r,o,a)}getCartographicToPosition(e,t,s,i){this.getCartographicToNormal(e,t,ai);const r=this.radius;li.copy(ai),li.x*=r.x**2,li.y*=r.y**2,li.z*=r.z**2;const n=Math.sqrt(ai.dot(li));return li.divideScalar(n),i.copy(li).addScaledVector(ai,s)}getPositionToCartographic(e,t){this.getPositionToSurfacePoint(e,li),this.getPositionToNormal(e,ai);const s=ci.subVectors(e,li);return t.lon=Math.atan2(ai.y,ai.x),t.lat=Math.asin(ai.z),t.height=Math.sign(s.dot(e))*s.length(),t}getCartographicToNormal(e,t,s){return oi.set(1,-e+Math.PI/2,t),s.setFromSpherical(oi).normalize(),function(e){const{x:t,y:s,z:i}=e;e.x=i,e.y=t,e.z=s}(s),s}getPositionToNormal(e,t){const s=this.radius;return t.copy(e),t.x/=s.x**2,t.y/=s.y**2,t.z/=s.z**2,t.normalize(),t}getPositionToSurfacePoint(e,t){const s=this.radius,i=1/s.x**2,r=1/s.y**2,n=1/s.z**2,o=e.x*e.x*i,a=e.y*e.y*r,l=e.z*e.z*n,c=o+a+l,h=Math.sqrt(1/c),u=li.copy(e).multiplyScalar(h);if(c<.1)return isFinite(h)?t.copy(u):null;const d=ci.set(u.x*i*2,u.y*r*2,u.z*n*2);let p,m,f,g,y,_,x,T,b,w,v,M=(1-h)*e.length()/(.5*d.length()),P=0;do{M-=P,f=1/(1+M*i),g=1/(1+M*r),y=1/(1+M*n),_=f*f,x=g*g,T=y*y,b=_*f,w=x*g,v=T*y,p=o*_+a*x+l*T-1,m=o*b*i+a*w*r+l*v*n;P=p/(-2*m)}while(Math.abs(p)>1e-12);return t.set(e.x*f,e.y*g,e.z*y)}calculateHorizonDistance(e,t){const s=this.calculateEffectiveRadius(e);return Math.sqrt(2*s*t+t**2)}calculateEffectiveRadius(e){const t=this.radius.x,s=1-this.radius.z**2/t**2,i=e*Ys.DEG2RAD,r=Math.sin(i)**2;return t/Math.sqrt(1-s*r)}getPositionElevation(e){this.getPositionToSurfacePoint(e,li);const t=ci.subVectors(e,li);return Math.sign(t.dot(e))*t.length()}closestPointToRayEstimate(e,t){return this.intersectRay(e,t)?t:(hi.makeScale(...this.radius).invert(),xi.copy(e).applyMatrix4(hi),li.set(0,0,0),xi.closestPointToPoint(li,t).normalize(),hi.makeScale(...this.radius),t.applyMatrix4(hi))}copy(e){return this.radius.copy(e.radius),this}clone(){return(new this.constructor).copy(this)}};const bi=new Js,wi=new Js,vi=new Js,Mi=new si;let Pi=class{constructor(e=new ri,t=new ei){this.box=e.clone(),this.transform=t.clone(),this.inverseTransform=new ei,this.points=new Array(8).fill().map(()=>new Js),this.planes=new Array(6).fill().map(()=>new ni)}copy(e){return this.box.copy(e.box),this.transform.copy(e.transform),this.update(),this}clone(){return(new this.constructor).copy(this)}clampPoint(e,t){return t.copy(e).applyMatrix4(this.inverseTransform).clamp(this.box.min,this.box.max).applyMatrix4(this.transform)}distanceToPoint(e){return this.clampPoint(e,vi).distanceTo(e)}containsPoint(e){return vi.copy(e).applyMatrix4(this.inverseTransform),this.box.containsPoint(vi)}intersectsRay(e){return Mi.copy(e).applyMatrix4(this.inverseTransform),Mi.intersectsBox(this.box)}intersectRay(e,t){return Mi.copy(e).applyMatrix4(this.inverseTransform),Mi.intersectBox(this.box,t)?(t.applyMatrix4(this.transform),t):null}update(){const{points:e,inverseTransform:t,transform:s,box:i}=this;t.copy(s).invert();const{min:r,max:n}=i;let o=0;for(let a=-1;a<=1;a+=2)for(let t=-1;t<=1;t+=2)for(let i=-1;i<=1;i+=2)e[o].set(a<0?r.x:n.x,t<0?r.y:n.y,i<0?r.z:n.z).applyMatrix4(s),o++;this.updatePlanes()}updatePlanes(){bi.copy(this.box.min).applyMatrix4(this.transform),wi.copy(this.box.max).applyMatrix4(this.transform),vi.set(0,0,1).transformDirection(this.transform),this.planes[0].setFromNormalAndCoplanarPoint(vi,bi),this.planes[1].setFromNormalAndCoplanarPoint(vi,wi).negate(),vi.set(0,1,0).transformDirection(this.transform),this.planes[2].setFromNormalAndCoplanarPoint(vi,bi),this.planes[3].setFromNormalAndCoplanarPoint(vi,wi).negate(),vi.set(1,0,0).transformDirection(this.transform),this.planes[4].setFromNormalAndCoplanarPoint(vi,bi),this.planes[5].setFromNormalAndCoplanarPoint(vi,wi).negate()}intersectsSphere(e){return this.clampPoint(e.center,vi),vi.distanceToSquared(e.center)<=e.radius*e.radius}intersectsFrustum(e){return this._intersectsPlaneShape(e.planes,e.points)}intersectsOBB(e){return this._intersectsPlaneShape(e.planes,e.points)}_intersectsPlaneShape(e,t){const s=this.points,i=this.planes;for(let r=0;r<6;r++){const t=e[r];let i=-1/0;for(let e=0;e<8;e++){const r=s[e],n=t.distanceToPoint(r);i=i<n?n:i}if(i<0)return!1}for(let r=0;r<6;r++){const e=i[r];let s=-1/0;for(let i=0;i<8;i++){const r=t[i],n=e.distanceToPoint(r);s=s<n?n:s}if(s<0)return!1}return!0}};const Si=Math.PI,Ei=Si/2,Ri=new Js,Ci=new Js,Ai=new Js,Li=new ei;let Ii=0;const Di=[];function Fi(e=!1){return e?(Di[Ii]||(Di[Ii]=new Js),Ii++,Di[Ii-1]):new Js}function Oi(){Ii=0}let Ui=class extends Ti{constructor(e,t,s,i=-Ei,r=Ei,n=0,o=2*Si,a=0,l=0){super(e,t,s),this.latStart=i,this.latEnd=r,this.lonStart=n,this.lonEnd=o,this.heightStart=a,this.heightEnd=l}_getPoints(e=!1){const{latStart:t,latEnd:s,lonStart:i,lonEnd:r,heightStart:n,heightEnd:o}=this,a=Ys.mapLinear(.5,0,1,t,s),l=Ys.mapLinear(.5,0,1,i,r),c=Math.floor(i/Ei)*Ei,h=[[-Si/2,0],[Si/2,0],[0,c],[0,c+Si/2],[0,c+Si],[0,c+3*Si/2],[t,r],[s,r],[t,i],[s,i],[0,i],[0,r],[a,l],[t,l],[s,l],[a,i],[a,r]],u=[],d=h.length;for(let p=0;p<=1;p++){const a=Ys.mapLinear(p,0,1,n,o);for(let n=0,o=d;n<o;n++){const[o,l]=h[n];if(o>=t&&o<=s&&l>=i&&l<=r){const t=Fi(e);u.push(t),this.getCartographicToPosition(o,l,a,t)}}}return u}getBoundingBox(e,t){Oi();const{latStart:s,latEnd:i,lonStart:r,lonEnd:n}=this;if(i-s<Si/2){const e=Ys.mapLinear(.5,0,1,s,i),o=Ys.mapLinear(.5,0,1,r,n);this.getCartographicToNormal(e,o,Ai),Ci.set(0,0,1),Ri.crossVectors(Ci,Ai),Ci.crossVectors(Ri,Ai),t.makeBasis(Ri,Ci,Ai)}else Ri.set(1,0,0),Ci.set(0,1,0),Ai.set(0,0,1),t.makeBasis(Ri,Ci,Ai);Li.copy(t).invert();const o=this._getPoints(!0);for(let a=0,l=o.length;a<l;a++)o[a].applyMatrix4(Li);e.makeEmpty(),e.setFromPoints(o)}getBoundingSphere(e,t){Oi();const s=this._getPoints(!0);e.makeEmpty(),e.setFromPoints(s,t)}};function ki(e){const{TextureUtils:t}=Zs;if(!t||!e)return 0;const{format:s,type:i,image:r}=e,{width:n,height:o}=r;let a=t.getByteLength(n,o,s,i);return a*=e.generateMipmaps?4/3:1,a}const{DefaultLoadingManager:Ni,Matrix4:zi,Vector3:Bi,Vector2:Vi,MathUtils:Hi,PointsMaterial:$i,BufferGeometry:ji,BufferAttribute:Gi,Color:Wi,Points:qi,InstancedMesh:Ki,Quaternion:Xi,Group:Zi,Ray:Yi,Sphere:Qi,Frustum:Ji,Matrix3:er,LoadingManager:tr,EventDispatcher:sr,Euler:ir,Mesh:rr,PlaneGeometry:nr,ShaderMaterial:or,Plane:ar,Raycaster:lr,Clock:cr,PerspectiveCamera:hr,OrthographicCamera:ur}=await H("three");class dr extends Ws{constructor(e=Ni){super(),this.manager=e,this.adjustmentTransform=new zi}parse(e){const t=super.parse(e),s=t.glbBytes.slice().buffer;return new Promise((e,i)=>{const r=this.manager,n=this.fetchOptions,o=r.getHandler("path.gltf")||new yt(r);"include"===n.credentials&&"cors"===n.mode&&o.setCrossOrigin("use-credentials"),"credentials"in n&&o.setWithCredentials("include"===n.credentials),n.headers&&o.setRequestHeader(n.headers);let a=this.workingPath;!/[\\/]$/.test(a)&&a.length&&(a+="/");const l=this.adjustmentTransform;o.parse(s,a,s=>{const{batchTable:i,featureTable:r}=t,{scene:n}=s,o=r.getData("RTC_CENTER",1,"FLOAT","VEC3");o&&(n.position.x+=o[0],n.position.y+=o[1],n.position.z+=o[2]),s.scene.updateMatrix(),s.scene.matrix.multiply(l),s.scene.matrix.decompose(s.scene.position,s.scene.quaternion,s.scene.scale),s.batchTable=i,s.featureTable=r,n.batchTable=i,n.featureTable=r,e(s)},i)})}}function pr(e){const t=e>>11,s=e>>5&63,i=31&e;return[Math.round(t/31*255),Math.round(s/63*255),Math.round(i/31*255)]}const mr=new Vi;function fr(e,t,s=new Bi){mr.set(e,t).divideScalar(256).multiplyScalar(2).subScalar(1),s.set(mr.x,mr.y,1-Math.abs(mr.x)-Math.abs(mr.y));const i=Hi.clamp(-s.z,0,1);return s.x>=0?s.setX(s.x-i):s.setX(s.x+i),s.y>=0?s.setY(s.y-i):s.setY(s.y+i),s.normalize(),s}const gr={RGB:"color",POSITION:"position"};class yr extends Ks{constructor(e=Ni){super(),this.manager=e}parse(e){return super.parse(e).then(async e=>{const{featureTable:t,batchTable:s}=e,i=new $i,r=t.header.extensions,n=new Bi;let o;if(r&&r["3DTILES_draco_point_compression"]){const{byteOffset:e,byteLength:s,properties:n}=r["3DTILES_draco_point_compression"],a=this.manager.getHandler("draco.drc");if(null==a)throw new Error("PNTSLoader: dracoLoader not available.");const l={};for(const t in n)if(t in gr&&t in n){l[gr[t]]=n[t]}const c={attributeIDs:l,attributeTypes:{position:"Float32Array",color:"Uint8Array"},useUniqueIDs:!0},h=t.getBuffer(e,s);o=await a.decodeGeometry(h,c),o.attributes.color&&(i.vertexColors=!0)}else{const e=t.getData("POINTS_LENGTH"),s=t.getData("POSITION",e,"FLOAT","VEC3"),r=t.getData("NORMAL",e,"FLOAT","VEC3"),a=t.getData("NORMAL",e,"UNSIGNED_BYTE","VEC2"),l=t.getData("RGB",e,"UNSIGNED_BYTE","VEC3"),c=t.getData("RGBA",e,"UNSIGNED_BYTE","VEC4"),h=t.getData("RGB565",e,"UNSIGNED_SHORT","SCALAR"),u=t.getData("CONSTANT_RGBA",e,"UNSIGNED_BYTE","VEC4"),d=t.getData("POSITION_QUANTIZED",e,"UNSIGNED_SHORT","VEC3"),p=t.getData("QUANTIZED_VOLUME_SCALE",e,"FLOAT","VEC3"),m=t.getData("QUANTIZED_VOLUME_OFFSET",e,"FLOAT","VEC3");if(o=new ji,d){const t=new Float32Array(3*e);for(let s=0;s<e;s++)for(let e=0;e<3;e++){const i=3*s+e;t[i]=d[i]/65535*p[e]}n.x=m[0],n.y=m[1],n.z=m[2],o.setAttribute("position",new Gi(t,3,!1))}else o.setAttribute("position",new Gi(s,3,!1));if(null!==r)o.setAttribute("normal",new Gi(r,3,!1));else if(null!==a){const t=new Float32Array(3*e),s=new Bi;for(let i=0;i<e;i++){const e=fr(a[2*i],a[2*i+1],s);t[3*i]=e.x,t[3*i+1]=e.y,t[3*i+2]=e.z}o.setAttribute("normal",new Gi(t,3,!1))}if(null!==c)o.setAttribute("color",new Gi(c,4,!0)),i.vertexColors=!0,i.transparent=!0,i.depthWrite=!1;else if(null!==l)o.setAttribute("color",new Gi(l,3,!0)),i.vertexColors=!0;else if(null!==h){const t=new Uint8Array(3*e);for(let s=0;s<e;s++){const e=pr(h[s]);for(let i=0;i<3;i++){t[3*s+i]=e[i]}}o.setAttribute("color",new Gi(t,3,!0)),i.vertexColors=!0}else if(null!==u){const e=new Wi(u[0],u[1],u[2]);i.color=e;const t=u[3]/255;t<1&&(i.opacity=t,i.transparent=!0,i.depthWrite=!1)}}const a=new qi(o,i);a.position.copy(n),e.scene=a,e.scene.featureTable=t,e.scene.batchTable=s;const l=t.getData("RTC_CENTER",1,"FLOAT","VEC3");return l&&(e.scene.position.x+=l[0],e.scene.position.y+=l[1],e.scene.position.z+=l[2]),e})}}const _r=new Ti(_s,_s,6356752.314245179);_r.name="WGS84 Earth";const xr=new Bi,Tr=new Bi,br=new Bi,wr=new Bi,vr=new Xi,Mr=new Bi,Pr=new zi,Sr=new zi,Er=new Bi,Rr=new zi,Cr=new Xi,Ar={};class Lr extends qs{constructor(e=Ni){super(),this.manager=e,this.adjustmentTransform=new zi,this.ellipsoid=_r.clone()}resolveExternalURL(e){return this.manager.resolveURL(super.resolveExternalURL(e))}parse(e){return super.parse(e).then(e=>{const{featureTable:t,batchTable:s}=e,i=e.glbBytes.slice().buffer;return new Promise((r,n)=>{const o=this.fetchOptions,a=this.manager,l=a.getHandler("path.gltf")||new yt(a);"include"===o.credentials&&"cors"===o.mode&&l.setCrossOrigin("use-credentials"),"credentials"in o&&l.setWithCredentials("include"===o.credentials),o.headers&&l.setRequestHeader(o.headers);let c=e.gltfWorkingPath??this.workingPath;/[\\/]$/.test(c)||(c+="/");const h=this.adjustmentTransform;l.parse(i,c,e=>{const i=t.getData("INSTANCES_LENGTH"),n=t.getData("POSITION",i,"FLOAT","VEC3"),o=t.getData("NORMAL_UP",i,"FLOAT","VEC3"),a=t.getData("NORMAL_RIGHT",i,"FLOAT","VEC3"),l=t.getData("SCALE_NON_UNIFORM",i,"FLOAT","VEC3"),c=t.getData("SCALE",i,"FLOAT","SCALAR"),u=t.getData("RTC_CENTER",1,"FLOAT","VEC3"),d=t.getData("EAST_NORTH_UP");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach(e=>{e in t.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${e}" detected.`)});const p=new Bi;for(let t=0;t<i;t++)p.x+=n[3*t+0]/i,p.y+=n[3*t+1]/i,p.z+=n[3*t+2]/i;const m=[],f=[];e.scene.updateMatrixWorld(),e.scene.traverse(e=>{if(e.isMesh){f.push(e);const{geometry:t,material:s}=e,r=new Ki(t,s,i);r.position.copy(p),u&&(r.position.x+=u[0],r.position.y+=u[1],r.position.z+=u[2]),m.push(r)}});for(let t=0;t<i;t++){wr.set(n[3*t+0]-p.x,n[3*t+1]-p.y,n[3*t+2]-p.z),vr.identity(),o&&(Tr.set(o[3*t+0],o[3*t+1],o[3*t+2]),br.set(a[3*t+0],a[3*t+1],a[3*t+2]),xr.crossVectors(br,Tr).normalize(),Pr.makeBasis(br,Tr,xr),vr.setFromRotationMatrix(Pr)),Mr.set(1,1,1),l&&Mr.set(l[3*t+0],l[3*t+1],l[3*t+2]),c&&Mr.multiplyScalar(c[t]);for(let e=0,s=m.length;e<s;e++){const s=m[e];Cr.copy(vr),d&&(s.updateMatrixWorld(),Er.copy(wr).applyMatrix4(s.matrixWorld),this.ellipsoid.getPositionToCartographic(Er,Ar),this.ellipsoid.getEastNorthUpFrame(Ar.lat,Ar.lon,Rr),Cr.setFromRotationMatrix(Rr)),Pr.compose(wr,Cr,Mr).multiply(h);const i=f[e];Sr.multiplyMatrices(Pr,i.matrixWorld),s.setMatrixAt(t,Sr)}}e.scene.clear(),e.scene.add(...m),e.batchTable=s,e.featureTable=t,e.scene.batchTable=s,e.scene.featureTable=t,r(e)},n)})})}}class Ir extends Xs{constructor(e=Ni){super(),this.manager=e,this.adjustmentTransform=new zi,this.ellipsoid=_r.clone()}parse(e){const t=super.parse(e),{manager:s,ellipsoid:i,adjustmentTransform:r}=this,n=[];for(const o in t.tiles){const{type:e,buffer:a}=t.tiles[o];switch(e){case"b3dm":{const e=a.slice(),t=new dr(s);t.workingPath=this.workingPath,t.fetchOptions=this.fetchOptions,t.adjustmentTransform.copy(r);const i=t.parse(e.buffer);n.push(i);break}case"pnts":{const e=a.slice(),t=new yr(s);t.workingPath=this.workingPath,t.fetchOptions=this.fetchOptions;const i=t.parse(e.buffer);n.push(i);break}case"i3dm":{const e=a.slice(),t=new Lr(s);t.workingPath=this.workingPath,t.fetchOptions=this.fetchOptions,t.ellipsoid.copy(i),t.adjustmentTransform.copy(r);const o=t.parse(e.buffer);n.push(o);break}}}return Promise.all(n).then(e=>{const t=new Zi;return e.forEach(e=>{t.add(e.scene)}),{tiles:e,scene:t}})}}const Dr=new zi;class Fr extends Zi{constructor(e){super(),this.isTilesGroup=!0,this.name="TilesRenderer.TilesGroup",this.tilesRenderer=e,this.matrixWorldInverse=new zi}raycast(e,t){return!this.tilesRenderer.optimizeRaycast||(this.tilesRenderer.raycast(e,t),!1)}updateMatrixWorld(e){if(this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldNeedsUpdate||e){null===this.parent?Dr.copy(this.matrix):Dr.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1;const e=Dr.elements,t=this.matrixWorld.elements;let s=!1;for(let i=0;i<16;i++){const r=e[i],n=t[i];if(Math.abs(r-n)>Number.EPSILON){s=!0;break}}if(s){this.matrixWorld.copy(Dr),this.matrixWorldInverse.copy(Dr).invert();const e=this.children;for(let t=0,s=e.length;t<s;t++)e[t].updateMatrixWorld()}}}updateWorldMatrix(e,t){this.parent&&e&&this.parent.updateWorldMatrix(e,!1),this.updateMatrixWorld(!0)}}const Or=new Yi,Ur=new Bi,kr=[];function Nr(e,t){return e.distance-t.distance}function zr(e,t,s,i){const{scene:r}=e.cached;s.invokeOnePlugin(s=>s.raycastTile&&s.raycastTile(e,r,t,i))||t.intersectObject(r,!0,i)}function Br(e){return"__used"in e}function Vr(e,t,s,i=null){const{group:r,activeTiles:n}=e;null===i&&(i=Or).copy(s.ray).applyMatrix4(r.matrixWorldInverse);const o=[],a=t.children;for(let h=0,u=a.length;h<u;h++){const e=a[h];Br(e)&&e.__used&&(null!==e.cached.boundingVolume.intersectRay(i,Ur)&&(Ur.applyMatrix4(r.matrixWorld),o.push({distance:Ur.distanceToSquared(s.ray.origin),tile:e})))}o.sort(Nr);let l=null,c=1/0;if(n.has(t)){const i=function(e,t,s){zr(e,t,s,kr),kr.sort(Nr);const i=kr[0]||null;return kr.length=0,i}(t,s,e);i&&(l=i,c=i.distance*i.distance)}for(let h=0,u=o.length;h<u;h++){const t=o[h],r=t.distance,n=t.tile;if(r>c)break;const a=Vr(e,n,s,i);if(a){const e=a.distance*a.distance;e<c&&(l=a,c=e)}}return l}function Hr(e,t,s,i,r=null){if(!Br(t))return;const{group:n,activeTiles:o}=e,{boundingVolume:a}=t.cached;if(null===r&&(r=Or).copy(s.ray).applyMatrix4(n.matrixWorldInverse),!t.__used||!a.intersectsRay(r))return;o.has(t)&&zr(t,s,e,i);const l=t.children;for(let c=0,h=l.length;c<h;c++)Hr(e,l[c],s,i,r)}const $r=new Bi,jr=new Bi,Gr=new Bi,Wr=new Bi,qr=new Bi;class Kr{constructor(){this.sphere=null,this.obb=null,this.region=null,this.regionObb=null}intersectsRay(e){const t=this.sphere,s=this.obb||this.regionObb;return!(t&&!e.intersectsSphere(t)||s&&!s.intersectsRay(e))}intersectRay(e,t=null){const s=this.sphere,i=this.obb||this.regionObb;let r=-1/0,n=-1/0;s&&e.intersectSphere(s,Wr)&&(r=s.containsPoint(e.origin)?0:e.origin.distanceToSquared(Wr)),i&&i.intersectRay(e,qr)&&(n=i.containsPoint(e.origin)?0:e.origin.distanceToSquared(qr));const o=Math.max(r,n);return o===-1/0?null:(e.at(Math.sqrt(o),t),t)}distanceToPoint(e){const t=this.sphere,s=this.obb||this.regionObb;let i=-1/0,r=-1/0;return t&&(i=Math.max(t.distanceToPoint(e),0)),s&&(r=s.distanceToPoint(e)),i>r?i:r}intersectsFrustum(e){const t=this.obb||this.regionObb,s=this.sphere;return!(s&&!e.intersectsSphere(s)||t&&!t.intersectsFrustum(e))&&!(!s&&!t)}intersectsSphere(e){const t=this.obb||this.regionObb,s=this.sphere;return!(s&&!s.intersectsSphere(e)||t&&!t.intersectsSphere(e))&&!(!s&&!t)}intersectsOBB(e){const t=this.obb||this.regionObb,s=this.sphere;return!(s&&!e.intersectsSphere(s)||t&&!t.intersectsOBB(e))&&!(!s&&!t)}getOBB(e,t){const s=this.obb||this.regionObb;s?(e.copy(s.box),t.copy(s.transform)):(this.getAABB(e),t.identity())}getAABB(e){if(this.sphere)this.sphere.getBoundingBox(e);else{const t=this.obb||this.regionObb;e.copy(t.box).applyMatrix4(t.transform)}}getSphere(e){if(this.sphere)e.copy(this.sphere);else if(this.region)this.region.getBoundingSphere(e);else{const t=this.obb||this.regionObb;t.box.getBoundingSphere(e),e.applyMatrix4(t.transform)}}setObbData(e,t){const s=new Pi;$r.set(e[3],e[4],e[5]),jr.set(e[6],e[7],e[8]),Gr.set(e[9],e[10],e[11]);const i=$r.length(),r=jr.length(),n=Gr.length();$r.normalize(),jr.normalize(),Gr.normalize(),0===i&&$r.crossVectors(jr,Gr),0===r&&jr.crossVectors($r,Gr),0===n&&Gr.crossVectors($r,jr),s.transform.set($r.x,jr.x,Gr.x,e[0],$r.y,jr.y,Gr.y,e[1],$r.z,jr.z,Gr.z,e[2],0,0,0,1).premultiply(t),s.box.min.set(-i,-r,-n),s.box.max.set(i,r,n),s.update(),this.obb=s}setSphereData(e,t,s,i,r){const n=new Qi;n.center.set(e,t,s),n.radius=i,n.applyMatrix4(r),this.sphere=n}setRegionData(e,t,s,i,r,n,o){const a=new Ui(...e.radius,s,r,t,i,n,o),l=new Pi;a.getBoundingBox(l.box,l.transform),l.update(),this.region=a,this.regionObb=l}}const Xr=new er;class Zr extends Ji{constructor(){super(),this.points=Array(8).fill().map(()=>new Bi)}setFromProjectionMatrix(e,t){return super.setFromProjectionMatrix(e,t),this.calculateFrustumPoints(),this}calculateFrustumPoints(){const{planes:e,points:t}=this;[[e[0],e[3],e[4]],[e[1],e[3],e[4]],[e[0],e[2],e[4]],[e[1],e[2],e[4]],[e[0],e[3],e[5]],[e[1],e[3],e[5]],[e[0],e[2],e[5]],[e[1],e[2],e[5]]].forEach((e,s)=>{!function(e,t,s,i){const r=Xr.set(e.normal.x,e.normal.y,e.normal.z,t.normal.x,t.normal.y,t.normal.z,s.normal.x,s.normal.y,s.normal.z);i.set(-e.constant,-t.constant,-s.constant),i.applyMatrix3(r.invert())}(e[0],e[1],e[2],t[s])})}}const Yr=new zi,Qr=new ir,Jr=Symbol("INITIAL_FRUSTUM_CULLED"),en=new zi,tn=new Bi,sn=new Vi,rn={inView:!1,error:1/0},nn=new Bi(1,0,0),on=new Bi(0,1,0);function an(e,t){e.traverse(e=>{e.frustumCulled=e[Jr]&&t})}class ln extends Vs{get autoDisableRendererCulling(){return this._autoDisableRendererCulling}set autoDisableRendererCulling(e){this._autoDisableRendererCulling!==e&&(super._autoDisableRendererCulling=e,this.forEachLoadedModel(t=>{an(t,!e)}))}get optimizeRaycast(){return this._optimizeRaycast}set optimizeRaycast(e){console.warn('TilesRenderer: The "optimizeRaycast" option has been deprecated.'),this._optimizeRaycast=e}constructor(...e){super(...e),this.group=new Fr(this),this.ellipsoid=_r.clone(),this.cameras=[],this.cameraMap=new Map,this.cameraInfo=[],this._optimizeRaycast=!0,this._upRotationMatrix=new zi,this._bytesUsed=new WeakMap,this._autoDisableRendererCulling=!0;const t=new tr;t.setURLModifier(e=>this.preprocessURL?this.preprocessURL(e):e),this.manager=t,this._listeners={}}addEventListener(...e){sr.prototype.addEventListener.call(this,...e)}hasEventListener(...e){sr.prototype.hasEventListener.call(this,...e)}removeEventListener(...e){sr.prototype.removeEventListener.call(this,...e)}dispatchEvent(...e){sr.prototype.dispatchEvent.call(this,...e)}getBoundingBox(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return!!t&&(t.getAABB(e),!0)}getOrientedBoundingBox(e,t){if(!this.root)return!1;const s=this.root.cached.boundingVolume;return!!s&&(s.getOBB(e,t),!0)}getBoundingSphere(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return!!t&&(t.getSphere(e),!0)}forEachLoadedModel(e){this.traverse(t=>{const s=t.cached&&t.cached.scene;s&&e(s,t)},null,!1)}raycast(e,t){if(this.root)if(e.firstHitOnly){const s=Vr(this,this.root,e);s&&t.push(s)}else Hr(this,this.root,e,t)}hasCamera(e){return this.cameraMap.has(e)}setCamera(e){const t=this.cameras,s=this.cameraMap;return!s.has(e)&&(s.set(e,new Vi),t.push(e),this.dispatchEvent({type:"add-camera",camera:e}),!0)}setResolution(e,t,s){const i=this.cameraMap;if(!i.has(e))return!1;const r=t.isVector2?t.x:t,n=t.isVector2?t.y:s,o=i.get(e);return(o.width!==r||o.height!==n)&&(o.set(r,n),this.dispatchEvent({type:"camera-resolution-change"})),!0}setResolutionFromRenderer(e,t){return t.getSize(sn),this.setResolution(e,sn.x,sn.y)}deleteCamera(e){const t=this.cameras,s=this.cameraMap;if(s.has(e)){const i=t.indexOf(e);return t.splice(i,1),s.delete(e),this.dispatchEvent({type:"delete-camera",camera:e}),!0}return!1}loadRootTileSet(...e){return super.loadRootTileSet(...e).then(e=>{const{asset:t,extensions:s={}}=e;switch((t&&t.gltfUpAxis||"y").toLowerCase()){case"x":this._upRotationMatrix.makeRotationAxis(on,-Math.PI/2);break;case"y":this._upRotationMatrix.makeRotationAxis(nn,Math.PI/2)}if("3DTILES_ellipsoid"in s){const e=s["3DTILES_ellipsoid"],{ellipsoid:t}=this;t.name=e.body,e.radii?t.radius.set(...e.radii):t.radius.set(1,1,1)}return e})}update(){let e=null;if(this.invokeAllPlugins(t=>{if(t.doTilesNeedUpdate){const s=t.doTilesNeedUpdate();e=null===e?s:!(!e&&!s)}}),!1===e)return this.dispatchEvent({type:"update-before"}),void this.dispatchEvent({type:"update-after"});this.dispatchEvent({type:"update-before"});const t=this.group,s=this.cameras,i=this.cameraMap,r=this.cameraInfo;for(;r.length>s.length;)r.pop();for(;r.length<s.length;)r.push({frustum:new Zr,isOrthographic:!1,sseDenominator:-1,position:new Bi,invScale:-1,pixelSize:0});tn.setFromMatrixScale(t.matrixWorldInverse),Math.abs(Math.max(tn.x-tn.y,tn.x-tn.z))>1e-6&&console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.");for(let n=0,o=r.length;n<o;n++){const e=s[n],o=r[n],a=o.frustum,l=o.position,c=i.get(e);(0===c.width||0===c.height)&&console.warn("TilesRenderer: resolution for camera error calculation is not set.");const h=e.projectionMatrix.elements;if(o.isOrthographic=1===h[15],o.isOrthographic){const e=2/h[0],t=2/h[5];o.pixelSize=Math.max(t/c.height,e/c.width)}else o.sseDenominator=2/h[5]/c.height;en.copy(t.matrixWorld),en.premultiply(e.matrixWorldInverse),en.premultiply(e.projectionMatrix),a.setFromProjectionMatrix(en),l.set(0,0,0),l.applyMatrix4(e.matrixWorld),l.applyMatrix4(t.matrixWorldInverse)}if(super.update(),this.dispatchEvent({type:"update-after"}),0===s.length&&this.root){let e=!1;this.invokeAllPlugins(t=>e=e||!(t===this||!t.calculateTileViewError)),!1===e&&console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles.")}}preprocessNode(e,t,s=null){super.preprocessNode(e,t,s);const i=new zi;if(e.transform){const t=e.transform;for(let e=0;e<16;e++)i.elements[e]=t[e]}s&&i.premultiply(s.cached.transform);const r=(new zi).copy(i).invert(),n=new Kr;"sphere"in e.boundingVolume&&n.setSphereData(...e.boundingVolume.sphere,i),"box"in e.boundingVolume&&n.setObbData(e.boundingVolume.box,i),"region"in e.boundingVolume&&n.setRegionData(this.ellipsoid,...e.boundingVolume.region),e.cached={transform:i,transformInverse:r,active:!1,boundingVolume:n,metadata:null,scene:null,geometry:null,materials:null,textures:null}}async parseTile(e,t,s,i,r){const n=t.cached,o=vs(i),a=this.fetchOptions,l=this.manager;let c=null;const h=n.transform,u=this._upRotationMatrix,d=(Ts(e)||s).toLowerCase();switch(d){case"b3dm":{const t=new dr(l);t.workingPath=o,t.fetchOptions=a,t.adjustmentTransform.copy(u),c=t.parse(e);break}case"pnts":{const t=new yr(l);t.workingPath=o,t.fetchOptions=a,c=t.parse(e);break}case"i3dm":{const t=new Lr(l);t.workingPath=o,t.fetchOptions=a,t.adjustmentTransform.copy(u),t.ellipsoid.copy(this.ellipsoid),c=t.parse(e);break}case"cmpt":{const t=new Ir(l);t.workingPath=o,t.fetchOptions=a,t.adjustmentTransform.copy(u),t.ellipsoid.copy(this.ellipsoid),c=t.parse(e).then(e=>e.scene);break}case"gltf":case"glb":{const t=l.getHandler("path.gltf")||l.getHandler("path.glb")||new yt(l);t.setWithCredentials("include"===a.credentials),t.setRequestHeader(a.headers||{}),"include"===a.credentials&&"cors"===a.mode&&t.setCrossOrigin("use-credentials");let s=t.resourcePath||t.path||o;!/[\\/]$/.test(s)&&s.length&&(s+="/"),c=t.parseAsync(e,s).then(e=>{e.scene=e.scene||new Zi;const{scene:t}=e;return t.updateMatrix(),t.matrix.multiply(u).decompose(t.position,t.quaternion,t.scale),e});break}default:c=this.invokeOnePlugin(n=>n.parseToMesh&&n.parseToMesh(e,t,s,i,r))}const p=await c;if(null===p)throw new Error(`TilesRenderer: Content type "${d}" not supported.`);let m,f;p.isObject3D?(m=p,f=null):(m=p.scene,f=p),m.updateMatrix(),m.matrix.premultiply(h),m.matrix.decompose(m.position,m.quaternion,m.scale),await this.invokeAllPlugins(e=>e.processTileModel&&e.processTileModel(m,t)),m.traverse(e=>{e[Jr]=e.frustumCulled}),an(m,!this.autoDisableRendererCulling);const g=[],y=[],_=[];if(m.traverse(e=>{if(e.geometry&&y.push(e.geometry),e.material){const t=e.material;g.push(e.material);for(const e in t){const s=t[e];s&&s.isTexture&&_.push(s)}}}),r.aborted)for(let x=0,T=_.length;x<T;x++){const e=_[x];e.image instanceof ImageBitmap&&e.image.close(),e.dispose()}else n.materials=g,n.geometry=y,n.textures=_,n.scene=m,n.metadata=f}disposeTile(e){super.disposeTile(e);const t=e.cached;if(t.scene){const s=t.materials,i=t.geometry,r=t.textures,n=t.scene.parent;t.scene.traverse(e=>{e.userData.meshFeatures&&e.userData.meshFeatures.dispose(),e.userData.structuralMetadata&&e.userData.structuralMetadata.dispose()});for(let e=0,t=i.length;e<t;e++)i[e].dispose();for(let e=0,t=s.length;e<t;e++)s[e].dispose();for(let e=0,t=r.length;e<t;e++){const t=r[e];t.image instanceof ImageBitmap&&t.image.close(),t.dispose()}n&&n.remove(t.scene),this.dispatchEvent({type:"dispose-model",scene:t.scene,tile:e}),t.scene=null,t.materials=null,t.textures=null,t.geometry=null,t.metadata=null}}setTileVisible(e,t){const s=e.cached.scene,i=this.group;t?s&&(i.add(s),s.updateMatrixWorld(!0)):s&&i.remove(s),super.setTileVisible(e,t),this.dispatchEvent({type:"tile-visibility-change",scene:s,tile:e,visible:t})}calculateBytesUsed(e,t){const s=this._bytesUsed;return!s.has(e)&&t&&s.set(e,function(e){const t=new Set;let s=0;return e.traverse(e=>{if(e.geometry&&!t.has(e.geometry)&&(s+=function(e){let t=0;for(const i in e.attributes){const s=e.getAttribute(i);t+=s.count*s.itemSize*s.array.BYTES_PER_ELEMENT}const s=e.getIndex();return t+=s?s.count*s.itemSize*s.array.BYTES_PER_ELEMENT:0,t}(e.geometry),t.add(e.geometry)),e.material){const i=e.material;for(const e in i){const r=i[e];r&&r.isTexture&&!t.has(r)&&(s+=ki(r),t.add(r))}}}),s}(t)),s.get(e)??null}calculateTileViewError(e,t){const s=e.cached,i=this.cameras,r=this.cameraInfo,n=s.boundingVolume;let o=!1,a=-1/0,l=1/0,c=-1/0,h=1/0;for(let u=0,d=i.length;u<d;u++){const t=r[u];let s,i;if(t.isOrthographic){const r=t.pixelSize;s=e.geometricError/r,i=1/0}else{const r=t.sseDenominator;i=n.distanceToPoint(t.position),s=0===i?1/0:e.geometricError/(i*r)}const d=r[u].frustum;n.intersectsFrustum(d)&&(o=!0,a=Math.max(a,s),l=Math.min(l,i)),c=Math.max(c,s),h=Math.min(h,i)}this.invokeAllPlugins(t=>{t!==this&&t.calculateTileViewError&&(t.calculateTileViewError(e,rn),rn.inView&&(o=!0,a=Math.max(a,rn.error)),c=Math.max(c,rn.error))}),o?(t.inView=!0,t.error=a,t.distanceFromCamera=l):(t.inView=!1,t.error=c,t.distanceFromCamera=h)}setLatLonToYUp(e,t){console.warn("TilesRenderer: setLatLonToYUp is deprecated. Use the ReorientationPlugin, instead.");const{ellipsoid:s,group:i}=this;Qr.set(Math.PI/2,Math.PI/2,0),Yr.makeRotationFromEuler(Qr),s.getEastNorthUpFrame(e,t,0,i.matrix).multiply(Yr).invert().decompose(i.position,i.quaternion,i.scale),i.updateMatrixWorld(!0)}dispose(){super.dispose(),this.group.removeFromParent()}}class cn extends rr{constructor(){super(new nr(0,0),new hn),this.renderOrder=1/0}onBeforeRender(e){const t=this.material.uniforms;e.getSize(t.resolution.value)}updateMatrixWorld(){this.matrixWorld.makeTranslation(this.position)}dispose(){this.geometry.dispose(),this.material.dispose()}}class hn extends or{constructor(){super({depthWrite:!1,depthTest:!1,transparent:!0,uniforms:{resolution:{value:new Vi},size:{value:15},thickness:{value:2},opacity:{value:1}},vertexShader:"\n\n\t\t\t\tuniform float pixelRatio;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\t\t\t\t\tvec2 offset = uv * 2.0 - vec2( 1.0 );\n\t\t\t\t\toffset.y *= aspect;\n\n\t\t\t\t\tvec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tscreenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;\n\n\t\t\t\t\tgl_Position = screenPoint;\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat ht = 0.5 * thickness;\n\t\t\t\t\tfloat planeDim = size + thickness;\n\t\t\t\t\tfloat offset = ( planeDim - ht - 2.0 ) / planeDim;\n\t\t\t\t\tfloat texelThickness = ht / planeDim;\n\n\t\t\t\t\tvec2 vec = vUv * 2.0 - vec2( 1.0 );\n\t\t\t\t\tfloat dist = abs( length( vec ) - offset );\n\t\t\t\t\tfloat fw = fwidth( dist ) * 0.5;\n\t\t\t\t\tfloat a = smoothstep( texelThickness - fw, texelThickness + fw, dist );\n\n\t\t\t\t\tgl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );\n\n\t\t\t\t}\n\t\t\t"})}}const un=new Vi,dn=new Vi;class pn{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new Vi,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new Vi,this.hoverSet=!1}updateFrame(){const{previousPositions:e,pointerPositions:t}=this;for(const s in t)e[s].copy(t[s])}setHoverEvent(e){("mouse"===e.pointerType||"wheel"===e.type)&&(this.getAdjustedPointer(e,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(e){return null!==this.pointerType?(this.getCenterPoint(e),e):this.hoverSet?(e.copy(this.hoverPosition),e):null}getAdjustedPointer(e,t){const s=(this.domElement?this.domElement:e.target).getBoundingClientRect(),i=e.clientX-s.left,r=e.clientY-s.top;t.set(i,r)}addPointer(e){const t=e.pointerId,s=new Vi;this.getAdjustedPointer(e,s),this.pointerOrder.push(t),this.pointerPositions[t]=s,this.previousPositions[t]=s.clone(),this.startPositions[t]=s.clone(),1===this.getPointerCount()&&(this.pointerType=e.pointerType,this.buttons=e.buttons)}updatePointer(e){const t=e.pointerId;return t in this.pointerPositions&&(this.getAdjustedPointer(e,this.pointerPositions[t]),!0)}deletePointer(e){const t=e.pointerId,s=this.pointerOrder;s.splice(s.indexOf(t),1),delete this.pointerPositions[t],delete this.previousPositions[t],delete this.startPositions[t],0===this.getPointerCount.length&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(e,t=this.pointerPositions){const s=this.pointerOrder;if(1===this.getPointerCount()||"mouse"===this.getPointerType()){const i=s[0];return e.copy(t[i]),e}if(2===this.getPointerCount()){const s=this.pointerOrder[0],i=this.pointerOrder[1],r=t[s],n=t[i];return e.addVectors(r,n).multiplyScalar(.5),e}return null}getPreviousCenterPoint(e){return this.getCenterPoint(e,this.previousPositions)}getStartCenterPoint(e){return this.getCenterPoint(e,this.startPositions)}getMoveDistance(){return this.getCenterPoint(un),this.getPreviousCenterPoint(dn),un.sub(dn).length()}getTouchPointerDistance(e=this.pointerPositions){if(this.getPointerCount()<=1||"mouse"===this.getPointerType())return 0;const{pointerOrder:t}=this,s=t[0],i=t[1],r=e[s],n=e[i];return r.distanceTo(n)}getPreviousTouchPointerDistance(){return this.getTouchPointerDistance(this.previousPositions)}getStartTouchPointerDistance(){return this.getTouchPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return"touch"===this.getPointerType()}getPointerButtons(){return this.buttons}isLeftClicked(){return!!(1&this.buttons)}isRightClicked(){return!!(2&this.buttons)}}const mn=new zi;function fn(e,t,s){return s.makeTranslation(-e.x,-e.y,-e.z),mn.makeRotationFromQuaternion(t),s.premultiply(mn),mn.makeTranslation(e.x,e.y,e.z),s.premultiply(mn),s}function gn(e,t,s,i){i.x=(e-s.offsetLeft)/s.clientWidth*2-1,i.y=-(t-s.offsetTop)/s.clientHeight*2+1,i.isVector3&&(i.z=0)}function yn(e,t,s){const i=e instanceof Yi?e:e.ray,{origin:r,direction:n}=i;r.set(t.x,t.y,-1).unproject(s),n.set(t.x,t.y,1).unproject(s).sub(r),e.isRay||(e.near=0,e.far=n.length(),e.camera=s),n.normalize()}new Bi;const _n=.05,xn=.025,Tn=new zi,bn=new zi,wn=new Bi,vn=new Bi,Mn=new Bi,Pn=new Bi,Sn=new Bi,En=new Bi,Rn=new Bi,Cn=new Bi,An=new Xi,Ln=new ar,In=new Bi,Dn=new Bi,Fn=new Bi,On=new Xi,Un=new Yi,kn=new Vi,Nn=new Vi,zn=new Vi,Bn=new Vi,Vn=new Vi,Hn=new Vi,$n={type:"change"},jn={type:"start"},Gn={type:"end"};class Wn extends sr{get enabled(){return this._enabled}set enabled(e){e!==this.enabled&&(this._enabled=e,this.resetState(),this.pointerTracker.reset(),this.enabled||(this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0)))}constructor(e=null,t=null,s=null,i=null){super(),this.isEnvironmentControls=!0,this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.enableDamping=!1,this.dampingFactor=.15,this.fallbackPlane=new ar(new Bi(0,1,0),0),this.useFallbackPlane=!0,this.scaleZoomOrientationAtEdges=!1,this.autoAdjustCameraRotation=!0,this.state=0,this.pointerTracker=new pn,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new Bi,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new Bi,this.zoomPoint=new Bi,this.zoomDelta=0,this.rotationInertiaPivot=new Bi,this.rotationInertia=new Vi,this.dragInertia=new Bi,this.inertiaTargetDistance=1/0,this.inertiaStableFrames=0,this.pivotMesh=new cn,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new lr,this.raycaster.firstHitOnly=!0,this.up=new Bi(0,1,0),this.clock=new cr,this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=0,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,s&&this.attach(s),t&&this.setCamera(t),e&&this.setScene(e),i&&this.setTilesRenderer(i)}setScene(e){this.scene=e}setCamera(e){this.camera=e,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.raycaster.camera=e,this.resetState()}setTilesRenderer(e){console.warn('EnvironmentControls: "setTilesRenderer" has been deprecated. Use "setScene" and "setEllipsoid", instead.'),this.tilesRenderer=e,null!==this.tilesRenderer&&this.setScene(this.tilesRenderer.group)}attach(e){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=e,this.pointerTracker.domElement=e,e.style.touchAction="none";const t=e=>{this.enabled&&e.preventDefault()},s=e=>{if(!this.enabled)return;e.preventDefault();const{camera:t,raycaster:s,domElement:i,up:r,pivotMesh:n,pointerTracker:o,scene:a,pivotPoint:l,enabled:c}=this;if(o.addPointer(e),this.needsUpdate=!0,o.isPointerTouch())if(n.visible=!1,0===o.getPointerCount())i.setPointerCapture(e.pointerId);else if(o.getPointerCount()>2)return void this.resetState();o.getCenterPoint(Nn),gn(Nn.x,Nn.y,i,Nn),yn(s,Nn,t);const h=Math.abs(s.ray.direction.dot(r));if(h<_n||h<xn)return;const u=this._raycast(s);u&&(2===o.getPointerCount()||o.isRightClicked()||o.isLeftClicked()&&e.shiftKey?(this.setState(o.isPointerTouch()?4:2),l.copy(u.point),n.position.copy(u.point),n.visible=!o.isPointerTouch()&&c,n.updateMatrixWorld(),a.add(n)):o.isLeftClicked()&&(this.setState(1),l.copy(u.point),n.position.copy(u.point),n.updateMatrixWorld(),a.add(n)))};let i=!1;const r=e=>{const{pointerTracker:t}=this;if(!this.enabled)return;e.preventDefault();const{pivotMesh:s,enabled:r}=this;this.zoomDirectionSet=!1,this.zoomPointSet=!1,0!==this.state&&(this.needsUpdate=!0),t.setHoverEvent(e),t.updatePointer(e)&&(t.isPointerTouch()&&2===t.getPointerCount()&&(i||(i=!0,queueMicrotask(()=>{i=!1,t.getCenterPoint(Vn);const e=t.getStartTouchPointerDistance(),n=t.getTouchPointerDistance(),o=n-e;if(0===this.state||4===this.state){t.getCenterPoint(Vn),t.getStartCenterPoint(Hn);const e=2*window.devicePixelRatio,s=Vn.distanceTo(Hn);(Math.abs(o)>e||s>e)&&(Math.abs(o)>s?(this.setState(3),this.zoomDirectionSet=!1):this.setState(2))}if(3===this.state){const e=t.getPreviousTouchPointerDistance();this.zoomDelta+=n-e,s.visible=!1}else 2===this.state&&(s.visible=r)}))),this.dispatchEvent($n))},n=t=>{const{pointerTracker:s}=this;!this.enabled||0===s.getPointerCount()||(s.deletePointer(t),"touch"===s.getPointerType()&&0===s.getPointerCount()&&e.releasePointerCapture(t.pointerId),this.resetState(),this.needsUpdate=!0)},o=e=>{if(!this.enabled)return;e.preventDefault();const{pointerTracker:t}=this;let s;switch(t.setHoverEvent(e),t.updatePointer(e),this.dispatchEvent(jn),e.deltaMode){case 2:s=800*e.deltaY;break;case 1:s=40*e.deltaY;break;case 0:s=e.deltaY}const i=Math.sign(s),r=Math.abs(s);this.zoomDelta-=.25*i*r,this.needsUpdate=!0,this._lastUsedState=3,this.dispatchEvent(Gn)},a=e=>{this.enabled&&this.resetState()};e.addEventListener("contextmenu",t),e.addEventListener("pointerdown",s),e.addEventListener("wheel",o,{passive:!1});const l=e.getRootNode();l.addEventListener("pointermove",r),l.addEventListener("pointerup",n),l.addEventListener("pointerleave",a),this._detachCallback=()=>{e.removeEventListener("contextmenu",t),e.removeEventListener("pointerdown",s),e.removeEventListener("wheel",o),l.removeEventListener("pointermove",r),l.removeEventListener("pointerup",n),l.removeEventListener("pointerleave",a)}}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}getUpDirection(e,t){t.copy(this.up)}getCameraUpDirection(e){this.getUpDirection(this.camera.position,e)}getPivotPoint(e){let t=null;3===this._lastUsedState?this._zoomPointWasSet&&(t=e.copy(this.zoomPoint)):(2===this._lastUsedState||1===this._lastUsedState)&&(t=e.copy(this.pivotPoint));const{camera:s,raycaster:i}=this;null!==t&&(vn.copy(t).project(s),(vn.x<-1||vn.x>1||vn.y<-1||vn.y>1)&&(t=null)),yn(i,{x:0,y:0},s);const r=this._raycast(i);return r&&(null===t||r.distance<t.distanceTo(i.ray.origin))&&(t=e.copy(r.point)),t}resetState(){0!==this.state&&this.dispatchEvent(Gn),this.state=0,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=this.enabled,this.actionHeightOffset=0,this.pointerTracker.reset()}setState(e=this.state,t=!0){this.state!==e&&(0===this.state&&t&&this.dispatchEvent(jn),this.pivotMesh.visible=this.enabled,this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0),this.inertiaStableFrames=0,this.state=e,0!==e&&4!==e&&(this._lastUsedState=e))}update(e=Math.min(this.clock.getDelta(),.064)){if(!this.enabled||!this.camera||0===e)return;const{camera:t,cameraRadius:s,pivotPoint:i,up:r,state:n,adjustHeight:o,autoAdjustCameraRotation:a}=this;t.updateMatrixWorld(),this.getCameraUpDirection(In),this._upInitialized||(this._upInitialized=!0,this.up.copy(In)),this.zoomPointSet=!1;const l=this._inertiaNeedsUpdate(),c=this.needsUpdate||l;if(this.needsUpdate||l){const s=this.zoomDelta;this._updateZoom(),this._updatePosition(e),this._updateRotation(e),1===n||2===n?(Sn.set(0,0,-1).transformDirection(t.matrixWorld),this.inertiaTargetDistance=vn.copy(i).sub(t.position).dot(Sn)):0===n&&this._updateInertia(e),(0!==n||0!==s||l)&&this.dispatchEvent($n),this.needsUpdate=!1}const h=t.isOrthographicCamera?null:o&&this._getPointBelowCamera()||null;if(this.getCameraUpDirection(In),this._setFrame(In),(1===this.state||2===this.state)&&0!==this.actionHeightOffset){const{actionHeightOffset:e}=this;t.position.addScaledVector(r,-e),i.addScaledVector(r,-e),h&&(h.distance-=e)}if(this.actionHeightOffset=0,h){const e=h.distance;if(e<s){const n=s-e;t.position.addScaledVector(r,n),i.addScaledVector(r,n),this.actionHeightOffset=n}}this.pointerTracker.updateFrame(),c&&a&&(this.getCameraUpDirection(In),this._alignCameraUp(In,1),this.getCameraUpDirection(In),this._clampRotation(In))}adjustCamera(e){const{adjustHeight:t,cameraRadius:s}=this;if(e.isPerspectiveCamera){this.getUpDirection(e.position,In);const i=t&&this._getPointBelowCamera(e.position,In)||null;if(i){const t=i.distance;t<s&&e.position.addScaledVector(In,s-t)}}}dispose(){this.detach()}_updateInertia(e){const{rotationInertia:t,pivotPoint:s,dragInertia:i,enableDamping:r,dampingFactor:n,camera:o,cameraRadius:a,minDistance:l,inertiaTargetDistance:c}=this;if(!this.enableDamping||this.inertiaStableFrames>1)return i.set(0,0,0),void t.set(0,0,0);const h=Math.pow(2,-e/n),u=Math.max(o.near,a,l,c),d=25e-5;if(t.lengthSq()>0){yn(Un,vn.set(0,0,-1),o),Un.applyMatrix4(o.matrixWorldInverse),Un.direction.normalize(),Un.recast(-Un.direction.dot(Un.origin)).at(u/Un.direction.z,vn),vn.applyMatrix4(o.matrixWorld),yn(Un,wn.set(d,d,-1),o),Un.applyMatrix4(o.matrixWorldInverse),Un.direction.normalize(),Un.recast(-Un.direction.dot(Un.origin)).at(u/Un.direction.z,wn),wn.applyMatrix4(o.matrixWorld),vn.sub(s).normalize(),wn.sub(s).normalize();const i=vn.angleTo(wn)/e;t.multiplyScalar(h),(t.lengthSq()<i**2||!r)&&t.set(0,0)}if(i.lengthSq()>0){yn(Un,vn.set(0,0,-1),o),Un.applyMatrix4(o.matrixWorldInverse),Un.direction.normalize(),Un.recast(-Un.direction.dot(Un.origin)).at(u/Un.direction.z,vn),vn.applyMatrix4(o.matrixWorld),yn(Un,wn.set(d,d,-1),o),Un.applyMatrix4(o.matrixWorldInverse),Un.direction.normalize(),Un.recast(-Un.direction.dot(Un.origin)).at(u/Un.direction.z,wn),wn.applyMatrix4(o.matrixWorld);const t=vn.distanceTo(wn)/e;i.multiplyScalar(h),(i.lengthSq()<t**2||!r)&&i.set(0,0,0)}t.lengthSq()>0&&this._applyRotation(t.x*e,t.y*e,s),i.lengthSq()>0&&(o.position.addScaledVector(i,e),o.updateMatrixWorld())}_inertiaNeedsUpdate(){const{rotationInertia:e,dragInertia:t}=this;return 0!==e.lengthSq()||0!==t.lengthSq()}_updateZoom(){const{zoomPoint:e,zoomDirection:t,camera:s,minDistance:i,maxDistance:r,pointerTracker:n,domElement:o,minZoom:a,maxZoom:l,zoomSpeed:c,state:h}=this;let u=this.zoomDelta;if(this.zoomDelta=0,n.getLatestPoint(Nn)&&(0!==u||3===h))if(this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),s.isOrthographicCamera){this._updateZoomDirection();const e=this.zoomPointSet||this._updateZoomPoint();Dn.unproject(s);const t=Math.pow(.95,Math.abs(.05*u));let i=u>0?1/Math.abs(t):t;i*=c,i>1?l<s.zoom*i&&(i=1):a>s.zoom*i&&(i=1),s.zoom*=i,s.updateProjectionMatrix(),e&&(gn(Nn.x,Nn.y,o,Fn),Fn.unproject(s),s.position.sub(Fn).add(Dn),s.updateMatrixWorld())}else{this._updateZoomDirection();const n=vn.copy(t);if(this.zoomPointSet||this._updateZoomPoint()){const n=e.distanceTo(s.position);if(u<0){const e=Math.min(0,n-r);u=u*n*c*.0025,u=Math.max(u,e)}else{const e=Math.max(0,n-i);u=u*Math.max(n-i,0)*c*.0025,u=Math.min(u,e)}s.position.addScaledVector(t,u),s.updateMatrixWorld()}else{const e=this._getPointBelowCamera();if(e){const t=e.distance;n.set(0,0,-1).transformDirection(s.matrixWorld),s.position.addScaledVector(n,u*t*.01),s.updateMatrixWorld()}}}}_updateZoomDirection(){if(this.zoomDirectionSet)return;const{domElement:e,raycaster:t,camera:s,zoomDirection:i,pointerTracker:r}=this;r.getLatestPoint(Nn),gn(Nn.x,Nn.y,e,Dn),yn(t,Dn,s),i.copy(t.ray.direction).normalize(),this.zoomDirectionSet=!0}_updateZoomPoint(){const{camera:e,zoomDirectionSet:t,zoomDirection:s,raycaster:i,zoomPoint:r,pointerTracker:n,domElement:o}=this;if(this._zoomPointWasSet=!1,!t)return!1;e.isOrthographicCamera&&n.getLatestPoint(kn)?(gn(kn.x,kn.y,o,kn),yn(i,kn,e)):(i.ray.origin.copy(e.position),i.ray.direction.copy(s),i.near=0,i.far=1/0);const a=this._raycast(i);return!!a&&(r.copy(a.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0)}_getPointBelowCamera(e=this.camera.position,t=this.up){const{raycaster:s}=this;s.ray.direction.copy(t).multiplyScalar(-1),s.ray.origin.copy(e).addScaledVector(t,1e5),s.near=0,s.far=1/0;const i=this._raycast(s);return i&&(i.distance-=1e5),i}_updatePosition(e){const{raycaster:t,camera:s,pivotPoint:i,up:r,pointerTracker:n,domElement:o,state:a,dragInertia:l}=this;if(1===a){if(n.getCenterPoint(Nn),gn(Nn.x,Nn.y,o,Nn),Ln.setFromNormalAndCoplanarPoint(r,i),yn(t,Nn,s),Math.abs(t.ray.direction.dot(r))<_n){const e=Math.acos(_n);Cn.crossVectors(t.ray.direction,r).normalize(),t.ray.direction.copy(r).applyAxisAngle(Cn,e).multiplyScalar(-1)}if(this.getUpDirection(i,In),Math.abs(t.ray.direction.dot(In))<xn){const e=Math.acos(xn);Cn.crossVectors(t.ray.direction,In).normalize(),t.ray.direction.copy(In).applyAxisAngle(Cn,e).multiplyScalar(-1)}t.ray.intersectPlane(Ln,vn)&&(wn.subVectors(i,vn),s.position.add(wn),s.updateMatrixWorld(),wn.multiplyScalar(1/e),n.getMoveDistance()/e<2*window.devicePixelRatio?this.inertiaStableFrames++:(l.copy(wn),this.inertiaStableFrames=0))}}_updateRotation(e){const{pivotPoint:t,pointerTracker:s,domElement:i,state:r,rotationInertia:n}=this;2===r&&(s.getCenterPoint(Nn),s.getPreviousCenterPoint(zn),Bn.subVectors(Nn,zn).multiplyScalar(2*Math.PI/i.clientHeight),this._applyRotation(Bn.x,Bn.y,t),Bn.multiplyScalar(1/e),s.getMoveDistance()/e<2*window.devicePixelRatio?this.inertiaStableFrames++:(n.copy(Bn),this.inertiaStableFrames=0))}_applyRotation(e,t,s){if(0===e&&0===t)return;const{camera:i,minAltitude:r,maxAltitude:n,rotationSpeed:o}=this,a=-e*o;let l,c=t*o;Sn.set(0,0,1).transformDirection(i.matrixWorld),En.set(1,0,0).transformDirection(i.matrixWorld),this.getUpDirection(s,In),In.dot(Sn)>1-1e-10?l=0:(vn.crossVectors(In,Sn).normalize(),l=Math.sign(vn.dot(En))*In.angleTo(Sn)),c>0?(c=Math.min(l-r,c),c=Math.max(0,c)):(c=Math.max(l-n,c),c=Math.min(0,c)),An.setFromAxisAngle(In,a),fn(s,An,Tn),i.matrixWorld.premultiply(Tn),En.set(1,0,0).transformDirection(i.matrixWorld),An.setFromAxisAngle(En,-c),fn(s,An,Tn),i.matrixWorld.premultiply(Tn),i.matrixWorld.decompose(i.position,i.quaternion,vn)}_setFrame(e){const{up:t,camera:s,zoomPoint:i,zoomDirectionSet:r,zoomPointSet:n,scaleZoomOrientationAtEdges:o}=this;if(r&&(n||this._updateZoomPoint())){if(An.setFromUnitVectors(t,e),o){this.getUpDirection(i,vn);let e=Math.max(vn.dot(t)-.6,0)/.4;e=Hi.mapLinear(e,0,.5,0,1),e=Math.min(e,1),s.isOrthographicCamera&&(e*=.1),An.slerp(On,1-e)}fn(i,An,Tn),s.updateMatrixWorld(),s.matrixWorld.premultiply(Tn),s.matrixWorld.decompose(s.position,s.quaternion,vn),this.zoomDirectionSet=!1,this._updateZoomDirection()}t.copy(e),s.updateMatrixWorld()}_raycast(e){const{scene:t,useFallbackPlane:s,fallbackPlane:i}=this,r=e.intersectObject(t)[0]||null;if(r)return r;if(s){const t=i;if(e.ray.intersectPlane(t,vn))return{point:vn.clone(),distance:e.ray.origin.distanceTo(vn)}}return null}_alignCameraUp(e,t=1){const{camera:s,state:i,pivotPoint:r,zoomPoint:n,zoomPointSet:o}=this;s.updateMatrixWorld(),Sn.set(0,0,-1).transformDirection(s.matrixWorld),En.set(-1,0,0).transformDirection(s.matrixWorld);let a=Hi.mapLinear(1-Math.abs(Sn.dot(e)),0,.2,0,1);a=Hi.clamp(a,0,1),t*=a,Rn.crossVectors(e,Sn),Rn.lerp(En,1-t).normalize(),An.setFromUnitVectors(En,Rn),s.quaternion.premultiply(An);let l=null;1===i||2===i?l=Mn.copy(r):o&&(l=Mn.copy(n)),l&&(bn.copy(s.matrixWorld).invert(),vn.copy(l).applyMatrix4(bn),s.updateMatrixWorld(),vn.applyMatrix4(s.matrixWorld),Pn.subVectors(l,vn),s.position.add(Pn)),s.updateMatrixWorld()}_clampRotation(e){const{camera:t,minAltitude:s,maxAltitude:i,state:r,pivotPoint:n,zoomPoint:o,zoomPointSet:a}=this;let l,c;if(t.updateMatrixWorld(),Sn.set(0,0,1).transformDirection(t.matrixWorld),En.set(1,0,0).transformDirection(t.matrixWorld),e.dot(Sn)>1-1e-10?l=0:(vn.crossVectors(e,Sn),l=Math.sign(vn.dot(En))*e.angleTo(Sn)),l>i)c=i;else{if(!(l<s))return;c=s}Sn.copy(e),An.setFromAxisAngle(En,c),Sn.applyQuaternion(An).normalize(),vn.crossVectors(Sn,En).normalize(),Tn.makeBasis(En,vn,Sn),t.quaternion.setFromRotationMatrix(Tn);let h=null;1===r||2===r?h=Mn.copy(n):a&&(h=Mn.copy(o)),h&&(bn.copy(t.matrixWorld).invert(),vn.copy(h).applyMatrix4(bn),t.updateMatrixWorld(),vn.applyMatrix4(t.matrixWorld),Pn.subVectors(h,vn),t.position.add(Pn)),t.updateMatrixWorld()}}const qn=new zi,Kn=new zi,Xn=new Bi,Zn=new Bi,Yn=new Bi,Qn=new Bi,Jn=new Bi,eo=new Bi,to=new Xi,so=new Bi,io=new Bi,ro=new Yi,no=new Ti,oo=new Vi,ao={};class lo extends Wn{get tilesGroup(){return console.warn('GlobeControls: "tilesGroup" has been deprecated. Use "ellipsoidGroup", instead.'),this.ellipsoidFrame}get ellipsoidFrame(){return this.ellipsoidGroup.matrixWorld}get ellipsoidFrameInverse(){const{ellipsoidGroup:e,ellipsoidFrame:t,_ellipsoidFrameInverse:s}=this;return e.matrixWorldInverse?e.matrixWorldInverse:s.copy(t).invert()}constructor(e=null,t=null,s=null,i=null){super(e,t,s),this.isGlobeControls=!0,this._dragMode=0,this._rotationMode=0,this.maxZoom=.01,this.nearMargin=.25,this.farMargin=0,this.useFallbackPlane=!1,this.autoAdjustCameraRotation=!1,this.globeInertia=new Xi,this.globeInertiaFactor=0,this.ellipsoid=_r.clone(),this.ellipsoidGroup=new Zi,this._ellipsoidFrameInverse=new zi,null!==i&&this.setTilesRenderer(i)}setTilesRenderer(e){super.setTilesRenderer(e),null!==e&&this.setEllipsoid(e.ellipsoid,e.group)}setEllipsoid(e,t){this.ellipsoid=e||_r.clone(),this.ellipsoidGroup=t||new Zi}getPivotPoint(e){const{camera:t,ellipsoidFrame:s,ellipsoidFrameInverse:i,ellipsoid:r}=this;return Qn.set(0,0,-1).transformDirection(t.matrixWorld),ro.origin.copy(t.position),ro.direction.copy(Qn),ro.applyMatrix4(i),r.closestPointToRayEstimate(ro,Zn).applyMatrix4(s),(null===super.getPivotPoint(e)||Xn.subVectors(e,ro.origin).dot(ro.direction)>Xn.subVectors(Zn,ro.origin).dot(ro.direction))&&e.copy(Zn),e}getVectorToCenter(e){const{ellipsoidFrame:t,camera:s}=this;return e.setFromMatrixPosition(t).sub(s.position)}getDistanceToCenter(){return this.getVectorToCenter(Zn).length()}getUpDirection(e,t){const{ellipsoidFrame:s,ellipsoidFrameInverse:i,ellipsoid:r}=this;Zn.copy(e).applyMatrix4(i),r.getPositionToNormal(Zn,t),t.transformDirection(s)}getCameraUpDirection(e){const{ellipsoidFrame:t,ellipsoidFrameInverse:s,ellipsoid:i,camera:r}=this;r.isOrthographicCamera?(this._getVirtualOrthoCameraPosition(Zn),Zn.applyMatrix4(s),i.getPositionToNormal(Zn,e),e.transformDirection(t)):this.getUpDirection(r.position,e)}update(e=Math.min(this.clock.getDelta(),.064)){if(!this.enabled||!this.camera||0===e)return;const{camera:t,pivotMesh:s}=this;this._isNearControls()?this.scaleZoomOrientationAtEdges=this.zoomDelta<0:(0!==this.state&&1!==this._dragMode&&1!==this._rotationMode&&(s.visible=!1),this.scaleZoomOrientationAtEdges=!1);const i=this.needsUpdate||this._inertiaNeedsUpdate();super.update(e),this.adjustCamera(t),i&&this._isNearControls()&&(this.getCameraUpDirection(eo),this._alignCameraUp(eo,1),this.getCameraUpDirection(eo),this._clampRotation(eo))}adjustCamera(e){super.adjustCamera(e);const{ellipsoidFrame:t,ellipsoidFrameInverse:s,ellipsoid:i,nearMargin:r,farMargin:n}=this,o=Math.max(...i.radius);if(e.isPerspectiveCamera){const a=Zn.setFromMatrixPosition(t).sub(e.position).length(),l=r*o,c=Hi.clamp((a-o)/l,0,1),h=Hi.lerp(1,1e3,c);e.near=Math.max(h,a-o-l),Xn.copy(e.position).applyMatrix4(s),i.getPositionToCartographic(Xn,ao);const u=Math.max(i.getPositionElevation(Xn),2550),d=i.calculateHorizonDistance(ao.lat,u);e.far=d+.1+o*n,e.updateProjectionMatrix()}else{this._getVirtualOrthoCameraPosition(e.position,e),e.updateMatrixWorld(),qn.copy(e.matrixWorld).invert(),Zn.setFromMatrixPosition(t).applyMatrix4(qn);const s=-Zn.z;e.near=s-o*(1+r),e.far=s+.1+o*n,e.position.addScaledVector(Qn,e.near),e.far-=e.near,e.near=0,e.updateProjectionMatrix(),e.updateMatrixWorld()}}setState(...e){super.setState(...e),this._dragMode=0,this._rotationMode=0}_updateInertia(e){super._updateInertia(e);const{globeInertia:t,enableDamping:s,dampingFactor:i,camera:r,cameraRadius:n,minDistance:o,inertiaTargetDistance:a,ellipsoidFrame:l}=this;if(!this.enableDamping||this.inertiaStableFrames>1)return this.globeInertiaFactor=0,void this.globeInertia.identity();const c=Math.pow(2,-e/i),h=Math.max(r.near,n,o,a),u=25e-5;if(Yn.setFromMatrixPosition(l),0!==this.globeInertiaFactor){yn(ro,Zn.set(0,0,-1),r),ro.applyMatrix4(r.matrixWorldInverse),ro.direction.normalize(),ro.recast(-ro.direction.dot(ro.origin)).at(h/ro.direction.z,Zn),Zn.applyMatrix4(r.matrixWorld),yn(ro,Xn.set(u,u,-1),r),ro.applyMatrix4(r.matrixWorldInverse),ro.direction.normalize(),ro.recast(-ro.direction.dot(ro.origin)).at(h/ro.direction.z,Xn),Xn.applyMatrix4(r.matrixWorld),Zn.sub(Yn).normalize(),Xn.sub(Yn).normalize(),this.globeInertiaFactor*=c;const i=Zn.angleTo(Xn)/e;(2*Math.acos(t.w)*this.globeInertiaFactor<i||!s)&&(this.globeInertiaFactor=0,t.identity())}0!==this.globeInertiaFactor&&(1===t.w&&(0!==t.x||0!==t.y||0!==t.z)&&(t.w=Math.min(t.w,1-1e-9)),Yn.setFromMatrixPosition(l),to.identity().slerp(t,this.globeInertiaFactor*e),fn(Yn,to,Kn),r.matrixWorld.premultiply(Kn),r.matrixWorld.decompose(r.position,r.quaternion,Zn))}_inertiaNeedsUpdate(){return super._inertiaNeedsUpdate()||0!==this.globeInertiaFactor}_updatePosition(e){if(1===this.state){0===this._dragMode&&(this._dragMode=this._isNearControls()?1:-1);const{raycaster:t,camera:s,pivotPoint:i,pointerTracker:r,domElement:n,ellipsoidFrame:o,ellipsoidFrameInverse:a}=this,l=Xn,c=Jn;r.getCenterPoint(oo),gn(oo.x,oo.y,n,oo),yn(t,oo,s),t.ray.applyMatrix4(a);const h=Zn.copy(i).applyMatrix4(a).length();if(no.radius.setScalar(h),!no.intersectRay(t.ray,Zn))return this.resetState(),void this._updateInertia(e);Zn.applyMatrix4(o),Yn.setFromMatrixPosition(o),l.subVectors(i,Yn).normalize(),c.subVectors(Zn,Yn).normalize(),to.setFromUnitVectors(c,l),fn(Yn,to,Kn),s.matrixWorld.premultiply(Kn),s.matrixWorld.decompose(s.position,s.quaternion,Zn),r.getMoveDistance()/e<2*window.devicePixelRatio?this.inertiaStableFrames++:(this.globeInertia.copy(to),this.globeInertiaFactor=1/e,this.inertiaStableFrames=0)}}_updateRotation(...e){1===this._rotationMode||this._isNearControls()?(this._rotationMode=1,super._updateRotation(...e)):(this.pivotMesh.visible=!1,this._rotationMode=-1)}_updateZoom(){const{zoomDelta:e,ellipsoid:t,zoomSpeed:s,zoomPoint:i,camera:r,maxZoom:n,state:o}=this;if(3!==o&&0===e)return;this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),this.globeInertia.identity(),this.globeInertiaFactor=0;const a=Hi.clamp(Hi.mapLinear(Math.abs(e),0,20,0,1),0,1);if(this._isNearControls()||e>0){if(this._updateZoomDirection(),e<0&&(this.zoomPointSet||this._updateZoomPoint())){Qn.set(0,0,-1).transformDirection(r.matrixWorld).normalize(),io.copy(this.up).multiplyScalar(-1),this.getUpDirection(i,so);const e=Hi.clamp(Hi.mapLinear(-so.dot(io),1,.95,0,1),0,1),t=1-Qn.dot(io),s=r.isOrthographicCamera?.05:1,n=Hi.clamp(3*a,0,1),o=Math.min(e*t*s*n,.1);io.lerpVectors(Qn,io,o).normalize(),to.setFromUnitVectors(Qn,io),fn(i,to,Kn),r.matrixWorld.premultiply(Kn),r.matrixWorld.decompose(r.position,r.quaternion,io),this.zoomDirection.subVectors(i,r.position).normalize()}super._updateZoom()}else if(r.isPerspectiveCamera){const i=this._getPerspectiveTransitionDistance(),r=this._getMaxPerspectiveDistance(),n=Hi.mapLinear(this.getDistanceToCenter(),i,r,0,1);this._tiltTowardsCenter(Hi.lerp(0,.4,n*a)),this._alignCameraUpToNorth(Hi.lerp(0,.2,n*a));const o=e*(this.getDistanceToCenter()-t.radius.x)*s*.0025,l=Math.max(o,Math.min(this.getDistanceToCenter()-r,0));this.getVectorToCenter(Zn).normalize(),this.camera.position.addScaledVector(Zn,l),this.camera.updateMatrixWorld(),this.zoomDelta=0}else{const e=this._getOrthographicTransitionZoom(),t=this._getMinOrthographicZoom(),i=Hi.mapLinear(r.zoom,e,t,0,1);this._tiltTowardsCenter(Hi.lerp(0,.4,i*a)),this._alignCameraUpToNorth(Hi.lerp(0,.2,i*a));const o=this.zoomDelta,l=Math.pow(.95,Math.abs(.05*o)),c=o>0?1/Math.abs(l):l,h=t/r.zoom,u=Math.max(c*s,Math.min(h,1));r.zoom=Math.min(n,r.zoom*u),r.updateProjectionMatrix(),this.zoomDelta=0,this.zoomDirectionSet=!1}}_alignCameraUpToNorth(e){const{ellipsoidFrame:t}=this;eo.set(0,0,1).transformDirection(t),this._alignCameraUp(eo,e)}_tiltTowardsCenter(e){const{camera:t,ellipsoidFrame:s}=this;Qn.set(0,0,-1).transformDirection(t.matrixWorld).normalize(),Zn.setFromMatrixPosition(s).sub(t.position).normalize(),Zn.lerp(Qn,1-e).normalize(),to.setFromUnitVectors(Qn,Zn),t.quaternion.premultiply(to),t.updateMatrixWorld()}_getPerspectiveTransitionDistance(){const{camera:e,ellipsoid:t}=this;if(!e.isPerspectiveCamera)throw new Error;const s=Math.max(...t.radius),i=2*Math.atan(Math.tan(Hi.DEG2RAD*e.fov*.5)*e.aspect),r=s/Math.tan(Hi.DEG2RAD*e.fov*.5),n=s/Math.tan(.5*i);return Math.max(r,n)}_getMaxPerspectiveDistance(){const{camera:e,ellipsoid:t}=this;if(!e.isPerspectiveCamera)throw new Error;const s=Math.max(...t.radius),i=2*Math.atan(Math.tan(Hi.DEG2RAD*e.fov*.5)*e.aspect),r=s/Math.tan(Hi.DEG2RAD*e.fov*.5),n=s/Math.tan(.5*i);return 2*Math.max(r,n)}_getOrthographicTransitionZoom(){const{camera:e,ellipsoid:t}=this;if(!e.isOrthographicCamera)throw new Error;const s=e.top-e.bottom,i=e.right-e.left;return 2*Math.max(s,i)/(2*Math.max(...t.radius))}_getMinOrthographicZoom(){const{camera:e,ellipsoid:t}=this;if(!e.isOrthographicCamera)throw new Error;const s=e.top-e.bottom,i=e.right-e.left;return.7*Math.min(s,i)/(2*Math.max(...t.radius))}_getVirtualOrthoCameraPosition(e,t=this.camera){const{ellipsoidFrame:s,ellipsoidFrameInverse:i,ellipsoid:r}=this;if(!t.isOrthographicCamera)throw new Error;ro.origin.copy(t.position),ro.direction.set(0,0,-1).transformDirection(t.matrixWorld),ro.applyMatrix4(i),r.closestPointToRayEstimate(ro,Xn).applyMatrix4(s);const n=t.top-t.bottom,o=t.right-t.left,a=Math.max(n,o)/t.zoom;Qn.set(0,0,-1).transformDirection(t.matrixWorld);const l=Xn.sub(t.position).dot(Qn);e.copy(t.position).addScaledVector(Qn,l-4*a)}_isNearControls(){const{camera:e}=this;return e.isPerspectiveCamera?this.getDistanceToCenter()<this._getPerspectiveTransitionDistance():e.zoom>this._getOrthographicTransitionZoom()}_raycast(e){const t=super._raycast(e);if(null===t){const{ellipsoid:t,ellipsoidFrame:s,ellipsoidFrameInverse:i}=this;ro.copy(e.ray).applyMatrix4(i);const r=t.intersectRay(ro,Zn);return null!==r?(r.applyMatrix4(s),{point:r.clone(),distance:r.distanceTo(e.ray.origin)}):null}return t}}const co=new Bi,ho=new Bi,uo=new ur,po=new Bi,mo=new Bi,fo=new Bi,go=new Xi,yo=new Xi;class _o extends sr{get animating(){return 0!==this._alpha&&1!==this._alpha}get alpha(){return 0===this._target?1-this._alpha:this._alpha}get camera(){return 0===this._alpha?this.perspectiveCamera:1===this._alpha?this.orthographicCamera:this.transitionCamera}get mode(){return 0===this._target?"perspective":"orthographic"}set mode(e){if(e===this.mode)return;const t=this.camera;"perspective"===e?(this._target=0,this._alpha=0):(this._target=1,this._alpha=1),this.dispatchEvent({type:"camera-change",camera:this.camera,prevCamera:t})}constructor(e=new hr,t=new ur){super(),this.perspectiveCamera=e,this.orthographicCamera=t,this.transitionCamera=new hr,this.orthographicPositionalZoom=!0,this.orthographicOffset=50,this.fixedPoint=new Bi,this.duration=200,this.autoSync=!0,this.easeFunction=e=>e,this._target=0,this._alpha=0,this._clock=new cr}toggle(){this._target=1===this._target?0:1,this._clock.getDelta(),this.dispatchEvent({type:"toggle"})}update(e=Math.min(this._clock.getDelta(),.064)){this.autoSync&&this.syncCameras();const{perspectiveCamera:t,orthographicCamera:s,transitionCamera:i,camera:r}=this,n=1e3*e;if(this._alpha!==this._target){const e=Math.sign(this._target-this._alpha)*n/this.duration;this._alpha=Hi.clamp(this._alpha+e,0,1),this.dispatchEvent({type:"change",alpha:this.alpha})}const o=r;let a=null;0===this._alpha?a=t:1===this._alpha?a=s:(a=i,this._updateTransitionCamera()),o!==a&&(a===i&&this.dispatchEvent({type:"transition-start"}),this.dispatchEvent({type:"camera-change",camera:a,prevCamera:o}),o===i&&this.dispatchEvent({type:"transition-end"}))}syncCameras(){const e=this._getFromCamera(),{perspectiveCamera:t,orthographicCamera:s,transitionCamera:i,fixedPoint:r}=this;if(co.set(0,0,-1).transformDirection(e.matrixWorld).normalize(),e.isPerspectiveCamera){if(this.orthographicPositionalZoom)s.position.copy(t.position).addScaledVector(co,-this.orthographicOffset),s.rotation.copy(t.rotation),s.updateMatrixWorld();else{const e=ho.subVectors(r,s.position).dot(co),i=ho.subVectors(r,t.position).dot(co);ho.copy(t.position).addScaledVector(co,i),s.rotation.copy(t.rotation),s.position.copy(ho).addScaledVector(co,-e),s.updateMatrixWorld()}const e=Math.abs(ho.subVectors(t.position,r).dot(co)),i=2*Math.tan(Hi.DEG2RAD*t.fov*.5)*e,n=s.top-s.bottom;s.zoom=n/i,s.updateProjectionMatrix()}else{const e=Math.abs(ho.subVectors(s.position,r).dot(co)),i=(s.top-s.bottom)/s.zoom*.5/Math.tan(Hi.DEG2RAD*t.fov*.5);t.rotation.copy(s.rotation),t.position.copy(s.position).addScaledVector(co,e).addScaledVector(co,-i),t.updateMatrixWorld(),this.orthographicPositionalZoom&&(s.position.copy(t.position).addScaledVector(co,-this.orthographicOffset),s.updateMatrixWorld())}i.position.copy(t.position),i.rotation.copy(t.rotation)}_getTransitionDirection(){return Math.sign(this._target-this._alpha)}_getToCamera(){const e=this._getTransitionDirection();return 0===e?0===this._target?this.perspectiveCamera:this.orthographicCamera:e>0?this.orthographicCamera:this.perspectiveCamera}_getFromCamera(){const e=this._getTransitionDirection();return 0===e?0===this._target?this.perspectiveCamera:this.orthographicCamera:e>0?this.perspectiveCamera:this.orthographicCamera}_updateTransitionCamera(){const{perspectiveCamera:e,orthographicCamera:t,transitionCamera:s,fixedPoint:i}=this,r=this.easeFunction(this._alpha);co.set(0,0,-1).transformDirection(t.matrixWorld).normalize(),uo.copy(t),uo.position.addScaledVector(co,t.near),t.far-=t.near,t.near=0,co.set(0,0,-1).transformDirection(e.matrixWorld).normalize();const n=Math.abs(ho.subVectors(e.position,i).dot(co)),o=2*Math.tan(Hi.DEG2RAD*e.fov*.5)*n,a=yo.slerpQuaternions(e.quaternion,uo.quaternion,r),l=Hi.lerp(e.fov,1,r),c=.5*o/Math.tan(Hi.DEG2RAD*l*.5),h=fo.copy(uo.position).sub(i).applyQuaternion(go.copy(uo.quaternion).invert()),u=mo.copy(e.position).sub(i).applyQuaternion(go.copy(e.quaternion).invert()),d=po.lerpVectors(u,h,r);d.z-=Math.abs(d.z)-c;const p=-(u.z-d.z),m=-(h.z-d.z),f=Hi.lerp(p+e.near,m+uo.near,r),g=Hi.lerp(p+e.far,m+uo.far,r),y=Math.max(g,0)-Math.max(f,0);s.aspect=e.aspect,s.fov=l,s.near=Math.max(f,1e-5*y),s.far=g,s.position.copy(d).applyQuaternion(a).add(i),s.quaternion.copy(a),s.updateProjectionMatrix(),s.updateMatrixWorld()}}export{ln as Ai,fs as E,lo as Fi,yt as GLTFLoader,_o as Wi,xs as h,H as importShared,te as mergeGeometries,ie as mergeVertices,ne as toCreasedNormals,Ms as y,Ti as zt};
