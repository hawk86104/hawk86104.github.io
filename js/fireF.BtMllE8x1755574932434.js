import{b as t}from"./pagesShow.vue_vue_type_script_setup_true_lang.6jWwf-A61755574932434.js";import{bd as e,g as i,S as s,V as a,l as n,t as r,a as o,n as l,b7 as c,cJ as h,am as u,bL as m,C as p,$ as d,aC as f,M as S,B as g,c as y,bg as w,b9 as v,aE as P,T as x}from"./three.QlBabAUP1755574932434.js";import{m as I,e as A}from"./@tresjs.D3Ezko2-1755574932434.js";import{d as T,b as z,a2 as F,e as E,o as b,f as O,j as C}from"./@vue.BzMISRrV1755574932434.js";import"./three-custom-shader-material.EFGJY8zp1755574932434.js";import"./buildingsCustomShaderMaterial.DyBo--wu1755574932434.js";import"./postprocessing.DBDjiblp1755574932434.js";import"./@vueuse.BcmlNMCY1755574932434.js";class R{static Time=new R("Time");static Sequence=new R("Sequence");constructor(t){this.name=t}}class V{constructor(){this.init()}init(){this.progressType=R.Time,this.lifetime=1,this.age=0,this.sequenceElement=new r,this.position=new a,this.velocity=new a,this.acceleration=new a,this.normal=new a,this.rotation=0,this.rotationalSpeed=0,this.size=new o,this.color=new p,this.alpha=1,this.initialSize=new o,this.initialColor=new p,this.initialAlpha=1}setAll(t,e,i,s,a,n,r,o,l,c,h,u,m,p,d,f){this.progressType=t,this.lifetime=e,this.age=i,this.sequenceElement.copy(s),this.position.copy(a),this.velocity.copy(n),this.acceleration.copy(r),this.normal.copy(o),this.rotation=l,this.rotationalSpeed=c,this.size=h,this.color.copy(u),this.alpha=m,this.initialSize.copy(p),this.initialColor.copy(d),this.initialAlpha=f}copyTo(t){t.setAll(this.progressType,this.lifetime,this.age,this.sequenceElement,this.position,this.velocity,this.acceleration,this.normal,this.rotation,this.rotationalSpeed,this.size,this.color,this.alpha,this.initialSize,this.initialColor,this.initialAlpha)}copy(t){this.setAll(t.progressType,t.lifetime,t.age,t.sequenceElement,t.position,t.velocity,t.acceleration,t.normal,t.rotation,t.rotationalSpeed,t.size,t.color,t.alpha,t.initialSize,t.initialColor,t.initialAlpha)}}class q{constructor(){this.particleCount=0,this.activeParticleCount=0,this.particleStates=[]}init(t){this.setParticleCount(t)}setParticleCount(t){this.particleCount!=t&&(this.dispose(),this.allocate(t)),this.particleCount=t}setActiveParticleCount(t){this.activeParticleCount=t}allocate(t){this.particleStates=[],this.particleCount=t;for(let e=0;e<t;e++)this.particleStates[e]=new V}dispose(){}getParticleCount(){return this.particleCount}flushParticleStateToBuffers(){}copyState(t,e){if(t>=this.particleCount)throw new Error('ParticleStateArray::copyState() -> "srcIndex" is out of range.');if(e>=this.particleCount)throw new Error('ParticleStateArray::copyState() -> "destIndex" is out of range.');const i=this.particleStates[t],s=this.particleStates[e];i.copyTo(s)}setState(t,e){if(t>=this.particleCount)throw new Error('ParticleStateArray::setState() -> "index" is out of range.');return this.particleStates[t].copy(e)}getState(t){if(t>=this.particleCount)throw new Error('ParticleStateArray::getState() -> "index" is out of range.');return this.particleStates[t]}computeBoundingBox=function(){const t=new a;return function(e=new i,s=null){const a=e.min,n=e.max;for(let i=0;i<this.activeParticleCount;i++){const e=this.getState(i);let r=e.position;s&&(t.copy(r),t.applyMatrix4(s),r=t);const o=Math.max(e.size.x,e.size.y),l=r.x-o,c=r.x+o,h=r.y-o,u=r.y+o,m=r.z-o,p=r.z+o;(0==i||r.x<a.x)&&(a.x=l),(0==i||r.x>n.x)&&(n.x=c),(0==i||r.y<a.y)&&(a.y=h),(0==i||r.y>n.y)&&(n.y=u),(0==i||r.z<a.z)&&(a.z=m),(0==i||r.z>n.z)&&(n.z=p)}return e}}();computeBoundingSphere=function(){const t=new a,e=new a,i=new a;return function(a=new s,n=null){let r=0;for(let s=0;s<this.activeParticleCount;s++){const a=this.getState(s);let o=a.position;n&&(i.copy(o),i.applyMatrix4(n),o=i);const l=Math.max(a.size.x,a.size.y);if(0==s)t.copy(o),r=l;else{e.copy(o).sub(t);const i=e.length()+l;if(i>r){const s=(i-r)/2;e.normalize().multiplyScalar(s),t.add(e),r+=s}}}return a.center.copy(t),a.radius=r,a}}()}class N{constructor(t,e,i=0){this.start=t,this.length=e,this.id=i}}class U{constructor(){this.sequences={},this.ids=[]}addSequence(t,e,i){if(this.hasID(i))throw new Error("ParticleSequenceGroup::addParticleSequence -> Tried to add sequence with duplicate ID.");const s=new N(t,e,i);return this.sequences[i]=s,this.ids.push(i),s}getSequence(t){if(!this.hasID(t))throw new Error("ParticleSequenceGroup::getSequence -> Invalid ID.");return this.sequences[t]}getSequenceIDs(){return this.ids}hasID(t){return!!this.sequences[t]}}class M{constructor(){}initializeState(t){t.initialColor.set(1,1,1),t.initialSize.set(1,1),t.initialAlpha=1,t.progressType=R.Time,t.lifetime=0,t.age=0,t.sequenceElement.set(0,0,0,0),t.position.set(0,0,0),t.velocity.set(0,0,0),t.acceleration.set(0,0,0),t.normal.set(0,0,1),t.rotation=0,t.rotationalSpeed=0,t.size.copy(t.initialSize),t.color.copy(t.initialColor),t.alpha=1}}class X extends M{constructor(){super()}initializeState(t){super.initializeState(t)}}class B{constructor(){}updateState(){}}class J extends B{constructor(){super(),this.timeScaledVelocity=new a,this.timeScaledAcceleration=new a,this.stateAcceleration=new a,this.stateVelocity=new a}updateState(t,e){return super.updateState(t,e),this.stateAcceleration.copy(t.acceleration),this.timeScaledAcceleration.copy(this.stateAcceleration),this.timeScaledAcceleration.multiplyScalar(e),t.velocity.add(this.timeScaledAcceleration),this.stateVelocity.copy(t.velocity),this.timeScaledVelocity.copy(this.stateVelocity),this.timeScaledVelocity.multiplyScalar(e),t.position.add(this.timeScaledVelocity),t.age=t.age+e,t.rotation=t.rotation+e*t.rotationalSpeed,!0}}class j{static clamp(t,e,i){return Math.min(Math.max(t,e),i)}static currentTime(){return performance.now()/1e3}}class W{constructor(){this.components=[]}addComponent(t){this.components.push(t)}update(t,e){for(const i of this.components)i.update(t,e)}getComponent(t){if(t>=this.components.length)throw new Error('ComponentContainer::getComponent() -> "index" is out of range.');return this.components[t]}}class D{static NotStarted=new D("NotStarted");static Running=new D("Running");static Paused=new D("Paused");static Done=new D("Done");constructor(t){this.name=t}}class Y{constructor(t,e){this.owner=t,this.owner.visible=!1,this.visible=!0,this.particleSystemRenderer=e,this.initialized=!1,this.maximumActiveParticles=0,this.activeParticleCount=0,this.simulateInWorldSpace=!0,this.emitterInitialized=!1,this.particleEmitter=null,this.componentContainer=new W,this.particleStateInitializers=[],this.particleStateOperators=[],this.particleStates=null,this.systemState=D.NotStarted,this.particleSequences=new U,this.onUpdateCallback=null,this.transformInitialDirectionInWorldSpace=!0,this.boundingBox=new i,this.boundingSphere=new s}init(t){if(this.initialized)throw new Error("ParticleSystem::init() -> trying to intialize more than once.");this.maximumActiveParticles=t,this.particleSystemRenderer?(this.particleSystemRenderer.setOwner(this.owner),this.particleSystemRenderer.init(this.maximumActiveParticles,this.simulateInWorldSpace),this.particleSystemRenderer.setSimulateInWorldSpace(this.simulateInWorldSpace),this.particleStates=this.particleSystemRenderer.getParticleStateArray()):(this.particleStates=new q,this.particleStates.init(this.maximumActiveParticles)),this.addParticleStateInitializer(new X),this.addParticleStateOperator(new J),this.initialized=!0}getVisible(){return this.visible}setVisibile(t){return this.visible=t}onUpdate(t){this.onUpdateCallback=t}update(t,e){if(this.systemState==D.Running){if(this.owner.updateWorldMatrix(!0),t=null==t||null==t?j.currentTime():t,e=null==e||null==e?t-this.lastUpdateTime:e,this.emitterInitialized&&this.systemState==D.Running){const t=this.particleEmitter.update(e);t>0&&this.activateParticles(t),this.advanceActiveParticles(e),this.onUpdateCallback&&this.onUpdateCallback(this.activeParticleCount),this.updateBounds()}this.componentContainer.update(t,e),this.lastUpdateTime=t}}render(t,e){if(this.getVisible()&&this.particleSystemRenderer){const i=t.autoClear;t.autoClear=!1,this.owner.visible=!0,this.owner.matrixWorldNeedsUpdate=!0,this.particleSystemRenderer.render(this.owner,t,e),this.owner.visible=!1,t.autoClear=i}}start(){this.systemState!=D.NotStarted&&this.systemState!=D.Paused||(this.systemState=D.Running,this.startTime=j.currentTime(),this.lastUpdateTime=this.startTime)}pause(){this.systemState==D.Running&&(this.systemState=D.Paused)}stop(){}getSystemState(){return this.systemState}setEmitter(t){return this.particleEmitter=t,this.particleEmitter.maximumActiveParticles=this.maximumActiveParticles,this.emitterInitialized=!0,this.particleEmitter}addComponent(t){this.componentContainer.addComponent(t)}getComponent(t){return this.componentContainer.getComponent(t)}addParticleStateInitializer(t){return this.particleStateInitializers.push(t),t}getParticleStateInitializerCount(){return this.particleStateInitializers.length}getParticleStateInitializer(t){if(t>=this.particleStateInitializers.length)throw new Error('ParticleSystem::getParticleStateInitializer() -> "index" is out of range.');return this.particleStateInitializers[t]}addParticleStateOperator(t){return this.particleStateOperators.push(t),t}getParticleStateOperatorCount(){return this.particleStateOperators.length}getParticleStateOperator(t){if(t>=this.particleStateOperators.length)throw new Error('ParticleSystem::getParticleStateOperator() -> "index" is out of range.');return this.particleStateOperators[t]}getMaximumActiveParticles(){return this.maximumActiveParticles}getActiveParticleCount(){return this.activeParticleCount}getParticleState(t){if(t>=this.activeParticleCount)throw new Error('ParticleSystem::getParticleState() -> "index" is out of range.');return this.particleStates.getState(t)}getParticleStates(){return this.particleStates}getParticleSystemRenderer(){return this.particleSystemRenderer}getSimulateInWorldSpace(){return this.simulateInWorldSpace}setSimulateInWorldSpace(t){this.simulateInWorldSpace=t,this.particleSystemRenderer&&this.particleSystemRenderer.setSimulateInWorldSpace(this.simulateInWorldSpace)}setTransformInitialDirectionInWorldSpace(t){this.transformInitialDirectionInWorldSpace=t}addParticleSequence(t,e,i=0){this.particleSequences.addSequence(t,e,i)}getParticleSequences(){return this.particleSequences}getEmitter(){return this.particleEmitter}updateBounds=function(){const t=new S;return function(){let e=null;this.transformInitialDirectionInWorldSpace&&(e=t,e.copy(this.owner.matrixWorld).invert()),this.particleSystemRenderer.calculatingBoundingSphereFromBox()?(this.particleStates.computeBoundingBox(this.boundingBox,e),this.particleSystemRenderer.setBoundingBox(this.boundingBox)):(this.particleStates.computeBoundingSphere(this.boundingSphere,e),this.particleSystemRenderer.setBoundingSphere(this.boundingSphere))}}();activateParticles(t){if(this.systemState==D.Running){const e=j.clamp(this.activeParticleCount+t,0,this.maximumActiveParticles);for(let t=this.activeParticleCount;t<e;t++)this.activateParticle(t);this.activeParticleCount=e,this.particleStates.setActiveParticleCount(this.activeParticleCount)}}activateParticle(t){if(this.systemState==D.Running){const e=this.particleStates.getState(t);e.age=0;for(let t=0;t<this.particleStateInitializers.length;t++){this.particleStateInitializers[t].initializeState(e)}if(this.simulateInWorldSpace){e.position.applyMatrix4(this.owner.matrixWorld);const t=e.velocity.length();if(this.transformInitialDirectionInWorldSpace){e.velocity.transformDirection(this.owner.matrixWorld).multiplyScalar(t);const i=e.acceleration.length();e.acceleration.transformDirection(this.owner.matrixWorld).multiplyScalar(i)}}this.particleStates.flushParticleStateToBuffers(t)}}advanceActiveParticles(t){if(this.systemState==D.Running){let e=0;for(;e<this.activeParticleCount;){this.advanceActiveParticle(e,t)?e++:(e<this.activeParticleCount-1&&this.copyParticleInArray(this.activeParticleCount-1,e),this.activeParticleCount--)}this.particleStates.setActiveParticleCount(this.activeParticleCount)}}advanceActiveParticle(t,e){if(this.systemState==D.Running){const i=this.particleStates.getState(t);for(let t=0;t<this.particleStateOperators.length;t++){const s=this.particleStateOperators[t].updateState(i,e),a=i.lifetime;if(!s||0!=a&&i.age>=a)return!1}return this.particleStates.flushParticleStateToBuffers(t),!0}return!1}copyParticleInArray(t,e){this.particleStates.copyState(t,e),this.particleStates.flushParticleStateToBuffers(e)}static fromJSON(t,e,i){const s=(t,e,i)=>{e(t);for(const a in t)if(t.hasOwnProperty(a)){const i=t[a];"object"==typeof i&&s(i,e)}};s(t,(t=>{t.type&&(t.type=e.parseTypeString(t.type))}));const a=t.maxParticleCount,n=t.simulateInWorldSpace,r=t.renderer,o=r.type.fromJSON(r.params),l=new d,c=new Y(l,o,i);c.init(a),c.setSimulateInWorldSpace(n);const h=t.emitter,u=h.type.fromJSON(h.params);if(c.setEmitter(u),t.sequences)for(const m of t.sequences)c.addParticleSequence(m.start,m.length,m.id);if(t.initializers)for(const m of t.initializers)c.addParticleStateInitializer(m.type.fromJSON(c,m.params));if(t.operators)for(const m of t.operators){const t=c.addParticleStateOperator(m.type.fromJSON(c,m.params));m.elements&&t.addElementsFromParameters(m.elements)}return[c,l]}toJSON(t){const e=this.getParticleSystemRenderer(),i=this.getEmitter(),s=this.getParticleSequences(),a=s.getSequenceIDs().map((t=>{const e=s.getSequence(t);return{id:t,start:e.start,length:e.length}})),n=[],r=this.getParticleStateInitializerCount();for(let c=0;c<r;c++){const e=this.getParticleStateInitializer(c);e.constructor!==X&&n.push({type:t.getTypePath(e.constructor),params:e.toJSON(t)})}const o=[],l=this.getParticleStateOperatorCount();for(let c=0;c<l;c++){const e=this.getParticleStateOperator(c);if(e.constructor!==J){const i=e.toJSON(t),s=i.params||i,a=i.params?i.elements:null,n={type:t.getTypePath(e.constructor),params:s};a&&(n.elements=a),o.push(n)}}return{maxParticleCount:this.getMaximumActiveParticles(),simulateInWorldSpace:this.getSimulateInWorldSpace(),renderer:{type:t.getTypePath(e.constructor),params:e.toJSON()},emitter:{type:t.getTypePath(i.constructor),params:i.toJSON()},sequences:a,initializers:n,operators:o}}}class _{constructor(){this.particleSystems=[],this.startupTime=performance.now()/1e3,this.lastUpdateTime=this.startupTime,this.componentContainer=new W}update(){const t=j.currentTime(),e=t-this.lastUpdateTime;for(const i of this.particleSystems)i.update(t,e);this.componentContainer.update(t,e),this.lastUpdateTime=t}render(t,e){for(const i of this.particleSystems)i.render(t,e)}addParticleSystem(t){this.particleSystems.push(t)}addComponent(t){this.componentContainer.addComponent(t)}getComponent(t){return this.componentContainer.getComponent(t)}}class Z{constructor(){this.initialized=!1,this.particleCount=0,this.owner=null,this.simulateInWorldSpace=!1}setSimulateInWorldSpace(t){this.simulateInWorldSpace=t}getParticleStateArray(){}setOwner(t){this.owner=t}init(t){if(this.particleCount=t,!this.initialized)return this.initialized=!0,!0;throw new Error("Renderer::init() -> trying to intialize more than once.")}render(){}}class G extends q{constructor(){super(),this.geometry=null,this.progressTypes=null,this.lifetimes=null,this.ages=null,this.sequenceElements=null,this.positions=null,this.velocities=null,this.accelerations=null,this.normals=null,this.rotations=null,this.rotationalSpeeds=null,this.sizes=null,this.colors=null,this.initialSizes=null,this.initialColors=null,this.instanced=!1,this.verticesPerParticle=6}init(t,e=!1){this.instanced=e,this.instanced?this.verticesPerParticle=1:this.verticesPerParticle=6,super.init(t),this.allocate(t)}setParticleCount(t){super.setParticleCount(t)}setActiveParticleCount(t){super.setActiveParticleCount(t),t>0?this.instanced?this.geometry.instanceCount=t:this.geometry.setDrawRange(0,this.verticesPerParticle*t):this.instanced?this.geometry.instanceCount=0:this.geometry.setDrawRange(0,0)}flushParticleStateToBuffers(t){if(t>=this.particleCount)throw new Error('ParticleStateAttributeArray::flushParticleStateToBuffers() -> "index" is out of range.');const e=this.getState(t),i=t*this.verticesPerParticle;for(let s=0;s<this.verticesPerParticle;s++)this.lifetimes.setX(i+s,e.lifetime),this.lifetimes.needsUpdate=!0,this.ages.setX(i+s,e.age),this.ages.needsUpdate=!0,this.sequenceElements.setXYZW(i+s,e.sequenceElement.x,e.sequenceElement.y,e.sequenceElement.z,e.sequenceElement.w),this.sequenceElements.needsUpdate=!0,this.positions.setXYZ(i+s,e.position.x,e.position.y,e.position.z),this.positions.needsUpdate=!0,this.velocities.setXYZ(i+s,e.velocity.x,e.velocity.y,e.velocity.z),this.velocities.needsUpdate=!0,this.accelerations.setXYZ(i+s,e.acceleration.x,e.acceleration.y,e.acceleration.z),this.accelerations.needsUpdate=!0,this.normals.setXYZ(i+s,e.normal.x,e.normal.y,e.normal.z),this.normals.needsUpdate=!0,this.rotations.setX(i+s,e.rotation),this.rotations.needsUpdate=!0,this.rotationalSpeeds.setX(i+s,e.rotationalSpeed),this.rotationalSpeeds.needsUpdate=!0,this.sizes.setXY(i+s,e.size.x,e.size.y),this.sizes.needsUpdate=!0,this.colors.setXYZ(i+s,e.color.r,e.color.g,e.color.b),this.colors.needsUpdate=!0,this.alphas.setX(i+s,e.alpha),this.alphas.needsUpdate=!0,this.initialSizes.setXY(i+s,e.initialSize.x,e.initialSize.y),this.initialSizes.needsUpdate=!0,this.initialAlphas.setX(i+s,e.initialAlpha),this.initialAlphas.needsUpdate=!0}copyState(t,e){super.copyState(t,e),this.flushParticleStateToBuffers(e)}setState(t,e){if(t>=this.particleCount)throw new Error('ParticleStateAttributeArray::setState() -> "index" is out of range.');super.setState(t,e),this.flushParticleStateToBuffers(t)}getPositions(){return this.positions}getSizes(){return this.sizes}getRotations(){return this.rotations}getSequenceElements(){return this.sequenceElements}getColors(){return this.colors}getGeometry(){return this.geometry}allocate(t){super.allocate(t);const e=(t,e)=>this.instanced?new P(t,e):new y(t,e),i=this.verticesPerParticle*this.particleCount;if(this.instanced){const t=new g,e=new Float32Array(18);this.basePositions=new y(e,3),t.setAttribute("position",this.basePositions),this.basePositions.needsUpdate=!0,this.basePositions.setXYZ(0,-1,1,0),this.basePositions.setXYZ(1,-1,-1,0),this.basePositions.setXYZ(2,1,1,0),this.basePositions.setXYZ(3,-1,-1,0),this.basePositions.setXYZ(4,1,-1,0),this.basePositions.setXYZ(5,1,1,0);const i=new Float32Array(12);this.baseUVs=new y(i,2),t.setAttribute("baseUV",this.baseUVs),this.baseUVs.needsUpdate=!0,this.baseUVs.setXY(0,0,1),this.baseUVs.setXY(1,0,0),this.baseUVs.setXY(2,1,1),this.baseUVs.setXY(3,0,0),this.baseUVs.setXY(4,1,0),this.baseUVs.setXY(5,1,1);const s=new Float32Array(6);this.customIndexes=new y(s,1),t.setAttribute("customIndex",this.customIndexes),this.customIndexes.needsUpdate=!0,this.customIndexes.setX(0,0),this.customIndexes.setX(1,1),this.customIndexes.setX(2,3),this.customIndexes.setX(3,1),this.customIndexes.setX(4,2),this.customIndexes.setX(5,3),this.geometry=(new w).copy(t),this.geometry.instanceCount=0}else{this.geometry=new g;const t=new Float32Array(i);this.customIndexes=new y(t,1),this.geometry.setAttribute("customIndex",this.customIndexes),this.customIndexes.needsUpdate=!0;for(let e=0;e<this.particleCount;e++){const t=e*this.verticesPerParticle;this.customIndexes.setX(t,0),this.customIndexes.setX(t+1,1),this.customIndexes.setX(t+2,3),this.customIndexes.setX(t+3,1),this.customIndexes.setX(t+4,2),this.customIndexes.setX(t+5,3)}}const s=new Float32Array(i),a=new Float32Array(i),n=new Float32Array(4*i),r=new Float32Array(3*i),o=new Float32Array(3*i),l=new Float32Array(3*i),c=new Float32Array(3*i),h=new Float32Array(i),u=new Float32Array(i),m=new Float32Array(2*i),p=new Float32Array(3*i),d=new Float32Array(i),f=new Float32Array(2*i),S=new Float32Array(3*i),x=new Float32Array(i);this.positions=e(r,3),this.positions.setUsage(v),this.geometry.setAttribute("particlePosition",this.positions),this.lifetimes=e(s,1),this.lifetimes.setUsage(v),this.geometry.setAttribute("lifetime",this.lifetimes),this.ages=e(a,1),this.ages.setUsage(v),this.geometry.setAttribute("age",this.ages),this.sequenceElements=e(n,4),this.sequenceElements.setUsage(v),this.geometry.setAttribute("sequenceElement",this.sequenceElements),this.velocities=e(o,3),this.velocities.setUsage(v),this.geometry.setAttribute("velocity",this.velocities),this.accelerations=e(l,3),this.accelerations.setUsage(v),this.geometry.setAttribute("acceleration",this.accelerations),this.normals=e(c,3),this.normals.setUsage(v),this.geometry.setAttribute("normal",this.normals),this.rotations=e(h,1),this.rotations.setUsage(v),this.geometry.setAttribute("rotation",this.rotations),this.rotationalSpeeds=e(u,1),this.rotationalSpeeds.setUsage(v),this.geometry.setAttribute("rotationalSpeed",this.rotationalSpeeds),this.sizes=e(m,2),this.sizes.setUsage(v),this.geometry.setAttribute("size",this.sizes),this.colors=e(p,3),this.colors.setUsage(v),this.geometry.setAttribute("color",this.colors),this.alphas=e(d,1),this.alphas.setUsage(v),this.geometry.setAttribute("alpha",this.alphas),this.initialSizes=e(f,2),this.initialSizes.setUsage(v),this.geometry.setAttribute("initialSize",this.initialSizes),this.initialColors=e(S,3),this.initialColors.setUsage(v),this.geometry.setAttribute("initialColor",this.initialColors),this.initialAlphas=e(x,1),this.initialAlphas.setUsage(v),this.geometry.setAttribute("initialAlpha",this.initialAlphas)}dispose(){super.dispose(),this.geometry&&(this.geometry.dispose(),this.geometry=null)}}class k{constructor(t,e,i,s,a){this.length=t,this.x=e,this.y=i,this.width=s,this.height=a}}class L{constructor(t,e){this.texture=t,this.texturePath=e,this.frameSets=[]}getTexture(){return this.texture}getTexturePath(){return this.texturePath}getFrameSetCount(){return this.frameSets.length}addFrameSet(t,e,i,s,a){this.frameSets.push(new k(t,e,i,s,a))}getFrameSet(t){if(t>=this.frameSets.length)throw new Error('Atlas::getFrameSet -> "index" is out of range.');return this.frameSets[t]}}class H extends Z{constructor(t,a,n=!1,r=e,o=!0,l){super(),this.instanced=t,this.particleStateArray=null,this.material=null,this.mesh=null,this.atlas=a,this.interpolateAtlasFrames=n,this.blending=r,this.boundingBox=new i,this.boundingSphere=new s,this.calculateBoundingSphereFromBox=o,this.renderOrder=l}setOwner(t){super.setOwner(t)}getParticleStateArray(){return this.particleStateArray}setSimulateInWorldSpace(t){super.setSimulateInWorldSpace(t),this.material&&(this.material.uniforms.simulateInWorldSpace.value=t?1:0,this.material.uniformsNeedUpdate=!0)}calculatingBoundingSphereFromBox(){return this.calculateBoundingSphereFromBox}setBoundingBox(t){this.boundingBox.copy(t),this.mesh&&this.updateMeshBounds()}setBoundingSphere(t){this.boundingSphere.copy(t),this.mesh&&this.updateMeshBounds()}render(t,e,i){e.render(t,i)}updateMeshBounds=function(){const t=new a;return function(){const e=this.particleStateArray.getGeometry();if(this.calculateBoundingSphereFromBox){e.boundingBox||(e.boundingBox=new i),e.boundingBox.copy(this.boundingBox),e.boundingSphere||(e.boundingSphere=new s),t.x=(this.boundingBox.min.x+this.boundingBox.max.x)/2,t.y=(this.boundingBox.min.y+this.boundingBox.max.y)/2,t.z=(this.boundingBox.min.z+this.boundingBox.max.z)/2;const a=this.boundingBox.max.x-t.x,n=this.boundingBox.max.y-t.y,r=this.boundingBox.max.z-t.z,o=Math.max(Math.max(a,n),r);e.boundingSphere.center.copy(t),e.boundingSphere.radius=Math.sqrt(2*o*o)}else e.boundingSphere||(e.boundingSphere=new s),e.boundingSphere.copy(this.boundingSphere)}}();init(t){super.init(t)&&(this.particleStateArray=new G,this.particleStateArray.init(t,this.instanced),this.material=this.createMaterial(null,null,null,!0,!1),this.material.blending=this.blending,this.mesh=new n(this.particleStateArray.getGeometry(),this.material),this.mesh.frustumCulled=!0,void 0!==this.renderOrder&&(this.mesh.renderOrder=this.renderOrder),this.updateMeshBounds(),this.owner.add(this.mesh))}dispose(){this.particleStateArray.dispose()}createMaterial(t,i,s,a,n){const u=[...Array(16).keys()].map((t=>new r));if(this.atlas)for(let e=0;e<this.atlas.getFrameSetCount();e++){const t=this.atlas.getFrameSet(e);u[e]=new r(t.x,t.y,t.width,t.height)}const m=this.atlas?this.atlas.getTexture():null,p=this.interpolateAtlasFrames,d=this.simulateInWorldSpace,f=this.instanced?1:0,S={atlasFrameSet:{type:"v4v",value:u},atlasTexture:{type:"t",value:m},interpolateAtlasFrames:{value:p},uvOffset:{type:"v2",value:new o},simulateInWorldSpace:{value:d},instanced:{value:f}};return s=s||{},Object.assign(s,S),t=t||H.Shader.getVertexShader(n),i=i||H.Shader.getFragmentShader(a,n),new l({uniforms:s,vertexShader:t,fragmentShader:i,transparent:!0,alphaTest:1,blending:e,blendDstAlpha:h,blendSrcAlpha:c,depthTest:!0,depthWrite:!1})}static Shader={get VertexVars(){return["const int MAX_ATLAS_FRAME_SETS = 16; \n","uniform vec4 atlasFrameSet[MAX_ATLAS_FRAME_SETS]; \n","uniform int interpolateAtlasFrames; \n","uniform int simulateInWorldSpace; \n","uniform int instanced; \n","attribute vec2 baseUV;\n","attribute float customIndex;\n","attribute vec4 particlePosition;\n","attribute float rotation;\n","attribute vec2 size;\n","attribute vec4 sequenceElement;\n","attribute vec3 color;\n","attribute float alpha;\n","varying vec2 vUV1;\n","varying vec2 vUV2;\n","varying vec3 vFragColor;\n","varying float vFragAlpha;\n","varying float vSequenceElementT; \n"].join("\n")},get FragmentVars(){return["uniform int interpolateAtlasFrames; \n","uniform sampler2D atlasTexture;\n","uniform vec2 uvOffset;\n","varying vec2 vUV1;\n","varying vec2 vUV2;\n","varying vec3 vFragColor;\n","varying float vFragAlpha;\n","varying float vSequenceElementT;\n"].join("\n")},getVertexShader(t){let e=["#include <common>",this.VertexVars].join("\n");return t&&(e+="  \n #include <logdepthbuf_pars_vertex> \n"),e+=["void getUV(in int sequenceElement, in int sequenceNumber, in vec4 atlasFrames, out vec2 uv) { \n","   float atlasFrameWidth = atlasFrames.z; \n","   float atlasFrameHeight = atlasFrames.w; \n","   float atlasFrameX = atlasFrames.x; \n","   float atlasFrameY = atlasFrames.y; \n","   int firstRowSections = int((1.0 - atlasFrameX) / atlasFrameWidth); \n","   int maxRowSections = int(1.0 / atlasFrameWidth); \n","   float firstRowX = atlasFrameX + atlasFrameWidth * float(sequenceElement); \n","   float firstRowY = 1.0 - (atlasFrameY + atlasFrameHeight); \n","   int nRowSequenceElement = sequenceElement - firstRowSections; \n","   float SNOverHS = float(nRowSequenceElement) / float(maxRowSections);\n","   int nRowYTile = int(SNOverHS);\n","   int nRowXTile = int((SNOverHS - float(nRowYTile)) * float(maxRowSections));\n","   float nRowX = float(nRowXTile) * atlasFrameWidth;\n","   float nRowY = 1.0 - ((float(nRowYTile) + 1.0) * (atlasFrameHeight) + atlasFrameY + atlasFrameHeight);\n","   float nRow = step(float(firstRowSections), float(sequenceElement)); \n","   uv.x = nRow * nRowX + (1.0 - nRow) * firstRowX; \n","   uv.y = nRow * nRowY + (1.0 - nRow) * firstRowY; \n","} \n","void main()\n","{\n","   const vec2 right = vec2(1.0, 0.0);\n","   const vec2 up = vec2(0.0, 1.0);\n","   const vec2 left = vec2(-1.0, 0.0);\n","   const vec2 down = vec2(0.0, -1.0);\n","   const vec2 uRight = vec2(1.0, 1.0);\n","   const vec2 uLeft = vec2(-1.0, 1.0);\n","   const vec2 dLeft = vec2(-1.0, -1.0);\n","   const vec2 dRight = vec2(1.0, -1.0);\n","   vec4 viewPosition; \n","   if (simulateInWorldSpace == 1) { \n","       viewPosition = viewMatrix * particlePosition;\n","   } else { \n","       viewPosition = viewMatrix * modelMatrix * particlePosition;\n","   } \n","   float sequenceElementF = sequenceElement.x;\n","   int sequenceNumber = int(sequenceElement.y);\n","   int sequenceStart = int(sequenceElement.z);\n","   int sequenceLength = int(sequenceElement.w);\n","   vec4 atlasFrames = atlasFrameSet[sequenceNumber]; \n","   vec2 uv1; \n","   vec2 uv2; \n","   vSequenceElementT = sequenceElementF - float(int(sequenceElementF)); \n","   int firstSequenceElement = int(sequenceElementF); \n","   int secondSequenceElement = clamp(firstSequenceElement + 1, sequenceStart, sequenceStart + sequenceLength - 1); \n","   getUV(firstSequenceElement, sequenceNumber, atlasFrames, uv1); \n","   if (interpolateAtlasFrames == 1 && firstSequenceElement != secondSequenceElement) { \n ","       getUV(secondSequenceElement, sequenceNumber, atlasFrames, uv2); \n","   } \n","   float atlasFrameWidth = atlasFrames.z; \n","   float atlasFrameHeight = atlasFrames.w; \n","   float rotMag = rotation; \n","   mat2 rotMat = mat2(cos(rotMag), -sin(rotMag), sin(rotMag), cos(rotMag)) * mat2(size.x, 0.0, 0.0, size.y);\n","   float rightSide; \n","   float upperSide; \n","   if (instanced != 1) { \n","       rightSide = step(2.0, customIndex); \n","       vec2 upperSideStep = step(vec2(customIndex, 3.0), vec2(0.0, customIndex));\n","       upperSide = upperSideStep.x + upperSideStep.y;\n","   }  else { \n","       rightSide = baseUV.x; \n","       upperSide = baseUV.y; \n","   } \n","   float uvXOffset = atlasFrameWidth * rightSide; \n","   float uvYOffset = atlasFrameHeight * upperSide; \n","   vec2 rotVec; \n","   if (instanced != 1) { \n","       vec4 rotVecStep = step(vec4(customIndex, customIndex, 3.0, 2.0), vec4(0.0, 1.0, customIndex, customIndex)); \n","       float uLeftV = rotVecStep.x; \n","       float dLeftV = rotVecStep.y - rotVecStep.x; \n","       float uRightV = rotVecStep.z; \n","       float dRightV = rotVecStep.w - rotVecStep.z; \n","       rotVec = uLeft * uLeftV + dLeft * dLeftV + dRight * dRightV + uRight * uRightV; \n","   }  else { \n","       rotVec = position.xy; \n ","   } \n","   gl_Position = projectionMatrix * (vec4(rotMat * rotVec, 0.0, 0.0) + viewPosition);\n","   vUV1 = vec2(uv1.x + uvXOffset, uv1.y + uvYOffset);\n","   vUV2 = vec2(uv2.x + uvXOffset, uv2.y + uvYOffset);\n","   vFragColor = color; \n","   vFragAlpha = alpha; \n"].join("\n"),t&&(e+="   \n  #include <logdepthbuf_vertex> \n"),e+="} \n",e},getFragmentShader(t,e){let i=`#include <common> \n${this.FragmentVars}\n`;return e&&(i+="  \n #include <logdepthbuf_pars_fragment> \n"),i+="void main() { \n",e&&(i+="    \n  #include <logdepthbuf_fragment> \n"),i+=t?["   vec4 color1 = texture(atlasTexture, vUV1 + uvOffset) * vec4(vFragColor, 1.0);\n","   vec4 color2 = color1; \n","   if (interpolateAtlasFrames == 1) color2 = texture(atlasTexture, vUV2 + uvOffset) * vec4(vFragColor, 1.0);\n","   gl_FragColor = mix(color1, color2, vSequenceElementT);\n","   gl_FragColor.a *= vFragAlpha; \n"].join("\n"):["   vec4 color1 = texture2D(atlasTexture, vUV1 + uvOffset) * vec4(vFragColor, 1.0);\n","   vec4 color2 = color1; \n","   if (interpolateAtlasFrames == 1) color2 = texture(atlasTexture, vUV2 + uvOffset) * vec4(vFragColor, 1.0);\n","   gl_FragColor = mix(color1, color2, vSequenceElementT);\n","   gl_FragColor.a *= vFragAlpha; \n"].join("\n"),i+="}\n",i}};static fromJSON(t){const i=t.atlas,s=(new u).load(i.texturePath),a=new L(s,i.texturePath),n=i.framesets;for(const e of n)a.addFrameSet(e.length,e.x,e.y,e.width,e.height);const r=new H(t.instanced,a,i.interpolateFrames);return"Additive"==t.blending?r.blending=m:r.blending=e,r}toJSON(t){t=t||(t=>{if(t.texturePath)return t.texturePath;const e=t.getTexture().source;if(e){const t=e.data;if(t){const e=t.baseURI,i=t.currentSrc;return i.indexOf(e)>=0?i.substr(e.length,i.length-e.length):i}}});const e=[];for(let s=0;s<this.atlas.getFrameSetCount();s++){const t=this.atlas.getFrameSet(s);e.push(t)}let i="Normal";this.material.blending===m&&(i="Additive");return{instanced:this.instanced,blending:i,atlas:{interpolateFrames:this.interpolateAtlasFrames,texturePath:t(this.atlas),framesets:e}}}}class ${constructor(){this.emissionRelativeStartTime=0,this.emissionDuration=0,this.emitCount=0,this.age=0,this.timeActive=0,this.activeCount=0,this.maximumActiveParticles=0}update(t){return this.internalUpdate(t),0}internalUpdate(t){return this.age+=t,this.timeActive=Math.max(this.age-this.emissionRelativeStartTime,0),this.age>=this.emissionRelativeStartTime&&(0==this.emissionDuration||this.timeActive<=emissionDuration)}updateEmitCount(t){this.emitCount+=t}}class K extends ${constructor(){super(),this.emissionMinimum=0,this.emissionMaximum=0}}class Q extends K{constructor(t=0){super(),this.emissionRate=t}update(t){if(this.internalUpdate(t)){const t=this.emissionRate*this.timeActive-this.emitCount;if(t>=1){const e=Math.floor(t);return this.updateEmitCount(e),e}}return 0}static fromJSON(t){const e=new Q;return e.emissionRate=t.emissionRate||0,e}toJSON(){return{emissionRate:this.emissionRate}}}class tt{static Default=new tt("Default");static Vector2=new tt("Vector2");static Vector3=new tt("Vector3");static Vector4=new tt("Vector4");static Color=new tt("Color");constructor(t){this.name=t}static getTypeID(t){let e=tt.Default;return t===o?e=tt.Vector2:t===a?e=tt.Vector3:t===r?e=tt.Vector4:t===p&&(e=tt.Color),e}static loadJSONParameter(t,e){switch(e){case o:return(new o).fromArray(t);case a:return(new a).fromArray(t);case r:return(new r).fromArray(t);case p:return(new p).fromArray(t)}return t}}class et{constructor(t){this.outType=t,this.outTypeID=tt.getTypeID(t)}}class it extends et{constructor(t,e,i,s,a,n){super(t),this.range=e,this.offset=i,this.uniformRange=s,this.uniformOffset=a,this.normalize=n}generate(t){const e=Math.random()*this.uniformRange;switch(this.outTypeID){case tt.Default:t=Math.random()*this.range+this.offset,this.normalize&&(t=t<0?-1:1);break;case tt.Vector2:t.set(this.generateForElement(e,"x"),this.generateForElement(e,"y"));break;case tt.Vector3:t.set(this.generateForElement(e,"x"),this.generateForElement(e,"y"),this.generateForElement(e,"z"));break;case tt.Vector4:t.set(this.generateForElement(e,"x"),this.generateForElement(e,"y"),this.generateForElement(e,"z"),this.generateForElement(e,"w"))}return this.normalize&&t.normalize(),t}generateForElement(t,e){return t+Math.random()*this.range[e]+this.offset[e]+this.uniformOffset}clone(){return new it(this.outType,this.range,this.offset,this.uniformRange,this.uniformOffset,this.normalize)}static getParameterJSON(t){return t instanceof o||t instanceof a||t instanceof r||t instanceof p?t.toArray():t}static fromJSON(t){return new it(t.type,tt.loadJSONParameter(t.range,t.type),tt.loadJSONParameter(t.offset,t.type),t.uniformRange||0,t.uniformOffset||0,t.normalize)}toJSON(t){const e={range:it.getParameterJSON(this.range),offset:it.getParameterJSON(this.offset),uniformRange:this.uniformRange,uniformOffset:this.uniformOffset},i=t.getTypePath(this.range.constructor);return null!=i&&(e.type=i),{type:t.getTypePath(it),params:e}}}class st extends M{constructor(t,e,i,s,a){super(),this.range=t,this.offset=e,this.uniformRange=i,this.uniformOffset=s,this.normalize=a,this.generator=new it(0,this.range,this.offset,this.uniformRange,this.uniformOffset,this.normalize)}initializeState(t){t.lifetime=this.generator.generate()}static fromJSON(t,e){return new st(e.range,e.offset,e.uniformRange,e.uniformOffset,e.normalize)}toJSON(){return{range:this.range,offset:this.offset,uniformRange:this.uniformRange,uniformOffset:this.uniformOffset,normalize:this.normalize}}}class at extends M{constructor(t){super(),this.generator=t.clone()}initializeState(t){t.rotation=this.generator.generate(t.rotation)}static fromJSON(t,e){const i=e.generator.type.fromJSON(e.generator.params);return new at(i)}toJSON(t){return{generator:this.generator.toJSON(t)}}}class nt extends M{constructor(t,e,i,s,a){super(),this.range=t,this.offset=e,this.uniformRange=i,this.uniformOffset=s,this.normalize=a,this.generator=new it(0,this.range,this.offset,this.uniformRange,this.uniformOffset,this.normalize)}initializeState(t){t.rotationalSpeed=this.generator.generate()}static fromJSON(t,e){return new nt(e.range,e.offset,e.uniformRange,e.uniformOffset,e.normalize)}toJSON(){return{range:this.range,offset:this.offset,uniformRange:this.uniformRange,uniformOffset:this.uniformOffset,normalize:this.normalize}}}class rt extends M{constructor(t,e){super(),this.randomGenerator=new it(a,t,e,0,0,!1)}initializeState(t){this.randomGenerator.generate(t.position)}static fromJSON(t,e){return new rt((new a).fromArray(e.range),(new a).fromArray(e.offset))}toJSON(){return{range:this.randomGenerator.range.toArray(),offset:this.randomGenerator.offset.toArray()}}}class ot extends M{constructor(t){super(),this.generator=t.clone()}initializeState(t){this.generator.generate(t.size),t.initialSize.copy(t.size)}static fromJSON(t,e){const i=e.generator.type.fromJSON(e.generator.params);return new ot(i)}toJSON(t){return{generator:this.generator.toJSON(t)}}}class lt extends M{constructor(t,e,i,s,n=!0){super(),this.directionGenerator=new it(a,t,e,0,0,!0),this.speedGenerator=new it(0,i,s,0,0,!1),this.normalizeDirection=n}initializeState(t){this.directionGenerator.generate(t.velocity),this.normalizeDirection&&t.velocity.normalize(),t.velocity.multiplyScalar(this.speedGenerator.generate())}static fromJSON(t,e){return new lt((new a).fromArray(e.range),(new a).fromArray(e.offset),e.speedRange,e.speedOffset)}toJSON(){return{range:this.directionGenerator.range.toArray(),offset:this.directionGenerator.offset.toArray(),speedRange:this.speedGenerator.range,speedOffset:this.speedGenerator.offset}}}class ct extends M{constructor(t,e=!1){super(),this.setParticleSequences(t),this.reverse=e}setParticleSequences(t){this.particleSequences=t}initializeState(t){const e=this.particleSequences.getSequenceIDs(),i=e.length*Math.random(),s=e[Math.floor(i)],a=this.particleSequences.getSequence(s),n=t.sequenceElement;this.reverse?n.x=a.length-1:n.x=a.start,n.y=a.id,n.z=a.start,n.w=a.length,t.progressType=R.Sequence}static fromJSON(t,e){return new ct(t.getParticleSequences(),e.reverse)}toJSON(){return{reverse:this.reverse}}}class ht extends B{constructor(t,e,i=!1,s=!1){super(),this.particleSequences=t,this.speed=e,this.loop=i,this.reverse=s}updateState(t,e){const i=t.sequenceElement,s=this.particleSequences.getSequence(i.y),a=e/this.speed;if(this.reverse){if(i.x-=a,i.x<s.start&&(i.x=s.start+s.length,!this.loop))return!1}else if(i.x+=a,i.x>=s.start+s.length&&(i.x=s.start,!this.loop))return!1;return!0}static fromJSON(t,e){return new ht(t.getParticleSequences(),e.speed,e.loop,e.reverse)}toJSON(){return{speed:this.speed,loop:this.loop,reverse:this.reverse}}}class ut{constructor(t,e){this.elements=[],this.tValues=[],this.elementTypeID=tt.getTypeID(t),this.interpolator=e||this.getInterpolatorForTypeID(this.elementTypeID)}*[Symbol.iterator](){let t=0;for(;t<this.getElementCount();)yield{element:this.elements[t],tValue:this.tValues[t]},t++}getElementCount(){return this.elements.length}getElement(t){if(t>=this.getElementCount())throw new Error('ContinuousArray::getElement() -> "index" is out of bounds.');return this.elements[t]}getTValue(t){if(t>=this.getElementCount())throw new Error('ContinuousArray::getTValue() -> "index" is out of bounds.');return this.tValues[t]}addElement(t,e){this.elements.push(t),this.tValues.push(e)}getInterpolatedElement(t,e){return this.interpolator(t,this.elements,this.tValues,e)}getInterpolatorForTypeID=function(){const t={lowerIndex:0,upperIndex:0,localT:0},e=new o,i=new a,s=new r,n=new p,l=e=>(i,s,a,n)=>{ut.getInterpolationValuesForTValue(a,i,t),e.copy(s[t.upperIndex]).multiplyScalar(t.localT),n.copy(s[t.lowerIndex]).multiplyScalar(1-t.localT).add(e)};return function(a){switch(a){case tt.Default:return(e,i,s)=>(ut.getInterpolationValuesForTValue(s,e,t),(1-t.localT)*i[t.lowerIndex]+t.localT*i[t.upperIndex]);case tt.Vector2:return l(e);case tt.Vector3:return l(i);case tt.Vector4:return l(s);case tt.Color:return l(n)}}}();static getInterpolationValuesForTValue(t,e,i){const s=t.length;if(0===s)return i.lowerIndex=-1,i.upperIndex=-1,void(i.localT=-1);let a=0,n=-1,r=0;for(let c=0;c<s&&(a=t[c],!(a>e));c++)n++,r++;i.lowerIndex=j.clamp(n,0,s-1),i.upperIndex=j.clamp(r,0,s-1);const o=t[n],l=t[r];i.localT=(e-o)/(l-o)}}class mt extends B{constructor(t,e=!1){super(),this.relativeToInitialValue=e,this.interpolationElements=new ut(t)}addElement(t,e){this.interpolationElements.addElement(t,e)}addElements(t){for(const e of t)this.interpolationElements.addElement(e[0],e[1])}addElementsFromElementClassAndParameters(t,e){for(const i of e){const[...e]=i[0];this.interpolationElements.addElement(new t(...e),i[1])}}getInterpolatedValue(t,e){let i=0;switch(t.progressType){case R.Time:i=0!=t.lifetime?t.age/t.lifetime:t.age;break;case R.Sequence:i=t.sequenceElement.x/t.sequenceElement.w}return this.interpolationElements.getInterpolatedElement(i,e)}}class pt extends mt{constructor(t=!1){super(0,t)}addElementsFromParameters(t){super.addElements(t)}updateState(t){return this.relativeToInitialValue?t.alpha=t.initialAlpha*this.getInterpolatedValue(t,t.alpha):t.alpha=this.getInterpolatedValue(t,t.alpha),!0}static fromJSON(t,e){return new pt(e.relativeToInitialValue)}toJSON(){return{params:{relativeToInitialValue:this.relativeToInitialValue},elements:[...this.interpolationElements].map((t=>[t.element,t.tValue]))}}}class dt extends mt{constructor(t=!1){super(o,t)}addElementsFromParameters(t){super.addElementsFromElementClassAndParameters(o,t)}updateState=function(){const t=new o;return function(e){return this.getInterpolatedValue(e,t),this.relativeToInitialValue?e.size.set(e.initialSize.x*t.x,e.initialSize.y*t.y):e.size.copy(t),!0}}();static fromJSON(t,e){return new dt(e.relativeToInitialValue)}toJSON(){return{params:{relativeToInitialValue:this.relativeToInitialValue},elements:[...this.interpolationElements].map((t=>[t.element.toArray(),t.tValue]))}}}class ft extends mt{constructor(t=!1){super(p,t)}addElementsFromParameters(t){super.addElementsFromElementClassAndParameters(p,t)}updateState=function(){const t=new p;return function(e){return this.getInterpolatedValue(e,t),this.relativeToInitialValue?e.color.setRGB(e.initialColor.r*t.r,e.initialColor.g*t.g,e.initialColor.b*t.b):e.color.copy(t),!0}}();static fromJSON(t,e){return new ft(e.relativeToInitialValue)}toJSON(){return{params:{relativeToInitialValue:this.relativeToInitialValue},elements:[...this.interpolationElements].map((t=>[t.element.toArray(),t.tValue]))}}}class St extends B{constructor(t){super(),this.generator=t.clone()}addElementsFromParameters(t){super.addElementsFromElementClassAndParameters(THREE.Vector3,t)}updateState(t){return this.generator.generate(t.acceleration),!0}static fromJSON(t,e){const i=e.generator.type.fromJSON(e.generator.params);return new St(i)}toJSON(t){return{generator:this.generator.toJSON(t)}}}class gt extends et{constructor(t,e,i,s,n,r,o,l,c,h,u,m){super(a),this.rangeTheta=t,this.offsetTheta=e,this.rangePhi=i,this.offsetPhi=s,this.rangeRadius=n,this.offsetRadius=r,this.scaleX=o,this.scaleY=l,this.scaleZ=c,this.offsetX=h,this.offsetY=u,this.offsetZ=m,this.tempUp=(new a).set(0,1,0)}generate(t){this.tempUp.set(0,1,0);const e=Math.random()*this.rangeTheta+this.offsetTheta,i=Math.random()*this.rangePhi+this.offsetPhi,s=Math.cos(e),a=Math.sin(e),n=Math.cos(i),r=Math.sin(i);t.set(s,0,-a),t.multiplyScalar(n),this.tempUp.multiplyScalar(r),t.add(this.tempUp),t.normalize();const o=Math.random()*this.rangeRadius+this.offsetRadius;t.multiplyScalar(o),t.x*=this.scaleX,t.y*=this.scaleY,t.z*=this.scaleZ,t.x+=this.offsetX,t.y+=this.offsetY,t.z+=this.offsetZ}clone(){return new gt(this.rangeTheta,this.offsetTheta,this.rangePhi,this.offsetPhi,this.rangeRadius,this.offsetRadius,this.scaleX,this.scaleY,this.scaleZ,this.offsetX,this.offsetY,this.offsetZ)}static fromJSON(t){return new gt(t.rangeTheta,t.offsetTheta,t.rangePhi,t.offsetPhi,t.rangeRadius,t.offsetRadius,t.scaleX,t.scaleY,t.scaleZ,t.offsetX,t.offsetY,t.offsetZ)}toJSON(t){return{type:t.getTypePath(gt),params:{rangeTheta:this.rangeTheta,offsetTheta:this.offsetTheta,rangePhi:this.rangePhi,offsetPhi:this.offsetPhi,rangeRadius:this.rangeRadius,offsetRadius:this.offsetRadius,scaleX:this.scaleX,scaleY:this.scaleY,scaleZ:this.scaleZ,offsetX:this.offsetX,offsetY:this.offsetY,offsetZ:this.offsetZ}}}}class yt{constructor(){}}class wt extends yt{constructor(t,e,i,s,n,r,o=void 0){super(),this.owner=null,this.light=null,this.lastUpdateTime=performance.now()/1e3,this.lastIntensityFlickerTime=this.lastUpdateTime,this.lastPositionFlickerTime=this.lastUpdateTime,this.lastIntensityAdjuster=1,this.nextIntensityAdjuster=1,this.lastPositionAdjuster=new a,this.positionAdjuster=new a,this.intensity=1,this.intensityFlux=2,this.parent=t,this.init(t,e,i,s,n,r,o)}init(t,e,i,s,a,n,r=void 0){this.owner=new d,t.add(this.owner),s=s||new p,a=a||0,null!=n&&null!=n||(n=2);const o=!!r;return this.light=new f(16777215,2,0,1),this.light.color.copy(s),this.light.distance=a,this.light.decay=n,this.light.castShadow=o,o&&(this.light.shadow.mapSize.width=r.mapSize||512,this.light.shadow.mapSize.height=r.mapSize||512,this.light.shadow.camera.near=r.cameraNear||.5,this.light.shadow.camera.far=r.cameraFar||500,this.light.shadow.bias=r.bias||1e-4,this.light.shadow.radius=r.edgeRadius||1),this.owner.add(this.light),this.intensity=e,this.intensityFlux=i,this.light}dispose(){this.parent.remove(this.owner)}getLight(){return this.light}setIntensity(t){this.intensity=t}update(t){const e=t-this.lastIntensityFlickerTime,i=1/8,s=this.intensityFlux;if(e>i){this.lastIntensityFlickerTime=t;let e=1+2*(Math.random()-.5)*s*i;const a=e-this.lastIntensityAdjuster;e=this.lastIntensityAdjuster+a,this.lastIntensityAdjuster=this.nextIntensityAdjuster,this.nextIntensityAdjuster=j.clamp(e,.25,1.5)}else{const t=e/i,s=(1-t)*this.lastIntensityAdjuster+t*this.nextIntensityAdjuster;this.light.intensity=s*this.intensity}if(t-this.lastPositionFlickerTime>.0625){this.lastPositionFlickerTime=t;const e=t-this.lastUpdateTime;this.positionAdjuster.set(Math.random()-.5,Math.random()-.5,Math.random()-.5),this.positionAdjuster.multiplyScalar(e),this.positionAdjuster.add(this.lastPositionAdjuster),this.positionAdjuster.multiplyScalar(.5),this.owner.position.copy(this.positionAdjuster),this.lastPositionAdjuster.copy(this.positionAdjuster),this.lastUpdateTime=t}}}class vt{constructor(){this.jsonTypes={default:{}},this.jsonTypeNames={},this.typeIDGen=0}addType(t,e){this.addTypeToNamespace("default",t,e)}addTypeToNamespace(t,e,i){if(!this.jsonTypes[t])throw new Error("JSONTypeStore::addTypeToNamespace() -> namespace does not exist");if(this.jsonTypes[t][e])throw new Error("JSONTypeStore::addTypeToNamespace() -> typeName already exists");this.checkAndAddTypeName(i,e,t)&&(this.jsonTypes[t][e]=i)}addNamespace(t,e){if(this.jsonTypes[t])throw new Error("JSONTypeStore::addNamespace() -> namespace already exists");this.jsonTypes[t]=e;for(const i in e)if(!e.hasOwnProperty||e.hasOwnProperty(i)){const s=e[i];this.checkAndAddTypeName(s,i,t)}}checkAndAddTypeName(t,e,i){if("function"==typeof t){const s=this.typeIDGen++;t.___photonsTypeID=s,this.jsonTypeNames[s]={namespace:i,typeName:e}}}getType(t,e){if(!this.jsonTypes[t])throw new Error("JSONTypeStore::getType() -> namespace does not exist");if(!this.jsonTypes[t][e])throw new Error("JSONTypeStore::getType() -> typeName does not exist");return this.jsonTypes[t][e]}getTypeNames(t){return this.jsonTypeNames[t.___photonsTypeID]}getTypePath(t){const e=this.getTypeNames(t);if(e)return`${e.namespace}.${e.typeName}`}parseNamespaceAndTypename(t){const e=t.split("."),i=e[0];e.splice(0,1);return{namespace:i,typeName:e.join(".")}}parseTypeString(t){const{namespace:e,typeName:i}=this.parseNamespaceAndTypename(t);return this.getType(e,i)}}const Pt=Object.freeze(Object.defineProperty({__proto__:null,AccelerationOperator:St,AnimatedSpriteRenderer:H,Atlas:L,BaseParticleStateInitializer:X,BaseParticleStateOperator:J,BoxPositionInitializer:rt,ColorInterpolatorOperator:ft,ConstantParticleEmitter:Q,FlickerLight:wt,JSONTypeStore:vt,LifetimeInitializer:st,Manager:_,OpacityInterpolatorOperator:pt,ParticleStateArray:q,ParticleSystem:Y,ParticleSystemState:D,RandomGenerator:it,RandomVelocityInitializer:lt,Renderer:Z,RotationInitializer:at,RotationalSpeedInitializer:nt,SequenceInitializer:ct,SequenceOperator:ht,SizeInitializer:ot,SizeInterpolatorOperator:dt,SphereRandomGenerator:gt},Symbol.toStringTag,{value:"Module"})),xt=T({__name:"fireF",props:{position:{default:[0,0,0]},scale:{default:1}},setup(t){const e=t,i=new _,s=new vt;s.addNamespace("THREE",x),s.addNamespace("Photons",Pt);const{renderer:n,camera:r,scene:l}=I(),c=new a(...e.position);i.addParticleSystem(((t,e)=>{const i=new d;i.position.copy(e);const s="./plugins/digitalCity/image/fireF/ember.png",r=(new u).load(s),l=new L(r,s);l.addFrameSet(1,0,0,1,1);const c=new H(!0,l,!0,m),h=new Y(i,c,n.value);h.init(150),h.setEmitter(new Q(6));const p=new it(o,new o(0,0),new o(.15*t,.15*t),0,0,!1);h.addParticleStateInitializer(new st(3,1,0,0,!1)),h.addParticleStateInitializer(new ot(p)),h.addParticleStateInitializer(new rt(new a(.05*t,0,.05*t),new a(-.025*t,0,-.025*t))),h.addParticleStateInitializer(new lt(new a(.4*t,.5*t,.4*t),new a(-.2*t,.8*t,-.2*t),.6*t,.8*t,!1));h.addParticleStateOperator(new pt).addElements([[0,0],[.7,.25],[.9,.75],[0,1]]);h.addParticleStateOperator(new ft(!0)).addElementsFromParameters([[[1,.7,0],0],[[1,.6,0],.5],[[1,.4,0],1]]);const f=new gt(2*Math.PI,0,Math.PI,-Math.PI/2,20,-8,t,t,t,0,0,0);return h.addParticleStateOperator(new St(f)),h.setSimulateInWorldSpace(!0),h.start(),h})(e.scale,c)),i.addParticleSystem(((t,e)=>{const i=new d;i.position.copy(e);const s="./plugins/digitalCity/image/fireF/base_flame.png",r=(new u).load(s),l=new L(r,s);l.addFrameSet(18,0,0,.125,.25);const c=new H(!0,l,!0),h=new Y(i,c,n.value);h.init(50),h.setEmitter(new Q(10)),h.addParticleSequence(0,18);const m=h.getParticleSequences();h.addParticleStateInitializer(new st(0,0,0,0,!1)),h.addParticleStateInitializer(new at(new it(0,Math.PI/2,-Math.PI/2,0,0,!1))),h.addParticleStateInitializer(new nt(1,-1,0,0,!1)),h.addParticleStateInitializer(new ot(new it(o,new o(.25*t,.25*t),new o(.5*t,.5*t),0,0,!1))),h.addParticleStateInitializer(new rt(new a(.05*t,0,.05*t),new a(-.025*t,0,-.025*t))),h.addParticleStateInitializer(new lt(new a(.05*t,.4*t,.05*t),new a(-.025*t,.8*t,-.025*t),.35*t,.5*t,!1)),h.addParticleStateInitializer(new ct(m)),h.addParticleStateOperator(new ht(m,.07,!1));h.addParticleStateOperator(new pt).addElements([[0,0],[.3,.25],[.3,.5],[0,1]]);h.addParticleStateOperator(new dt(!0)).addElementsFromParameters([[[.6,.6],0],[[1,1],.4],[[1,1],1]]);return h.addParticleStateOperator(new ft(!0)).addElementsFromParameters([[[1,1,1],0],[[1.5,1.5,1.5],.5],[[1,1,1],1]]),h.addParticleStateOperator(new St(new it(a,new a(0,0,0),new a(0,1.5*t,0),0,0,!1))),h.setSimulateInWorldSpace(!0),h.start(),h})(e.scale,c)),i.addParticleSystem(((t,e)=>{const i=new d;i.position.copy(e);const s="./plugins/digitalCity/image/fireF/bright_flame.png",r=(new u).load(s),l=new L(r,s);l.addFrameSet(16,0,0,212/1024,.25);const c=new H(!0,l,!0),h=new Y(i,c,n.value);h.init(20),h.setEmitter(new Q(5)),h.addParticleSequence(0,16);const m=h.getParticleSequences();h.addParticleStateInitializer(new st(0,0,0,0,!1)),h.addParticleStateInitializer(new at(new it(0,Math.PI,-Math.PI/2,0,0,!1))),h.addParticleStateInitializer(new nt(Math.PI/2,-Math.PI/4,0,0,!1)),h.addParticleStateInitializer(new ot(new it(o,new o(0,0),new o(0,0),.2*t,.65*t,!1))),h.addParticleStateInitializer(new rt(new a(.1*t,0,.1*t),new a(-.05*t,0,-.05*t))),h.addParticleStateInitializer(new lt(new a(.02*t,.4*t,.02*t),new a(-.01*t,.4*t,-.01*t),.1*t,.2*t,!1)),h.addParticleStateInitializer(new ct(m)),h.addParticleStateOperator(new ht(m,.1,!1));h.addParticleStateOperator(new pt).addElements([[0,0],[.6,.2],[.5,.75],[0,1]]);h.addParticleStateOperator(new dt(!0)).addElementsFromParameters([[[.3,.3],0],[[1,1],.4],[[1,1],.55],[[.65,.65],.75],[[.1,.1],1]]);return h.addParticleStateOperator(new ft(!0)).addElementsFromParameters([[[1,1,1],0],[[2,2,2],.3],[[2,2,2],.4],[[.9,.6,.3],.65],[[.75,0,0],1]]),h.addParticleStateOperator(new St(new it(a,new a(0,0,0),new a(0,1.5*t,0),0,0,!1))),h.setSimulateInWorldSpace(!0),h.start(),h})(e.scale,c)),i.addComponent(((t,e=10)=>{const i=new d;l.value.add(i),i.position.copy(t);return new wt(i,e,2,(new p).setRGB(1,.8,.4),0,1,{mapSize:1024,cameraNear:.1,cameraFar:5e3,bias:9e-6,edgeRadius:3})})(c,100));const{onBeforeLoop:h}=A();return h((()=>{i.update(),i.render(n.value,r.value)})),(t,e)=>null}}),It=T({__name:"fireF",setup(e){const i=z();return F((()=>{i.value&&(i.value.$refs.tcRef?i.value.$refs.tcRef.context.camera.value.position.set(580,360,500):i.value.$refs.perspectiveCameraRef&&i.value.$refs.perspectiveCameraRef.position.set(580,360,500))})),(e,s)=>(b(),E(t,{ref_key:"pagesShowRef",ref:i},{ability:O((()=>[C(xt,{position:[0,20,10],scale:40})])),_:1},512))}});export{It as default};
