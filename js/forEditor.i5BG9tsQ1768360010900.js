import{importShared as t}from"./3d-tiles-renderer.CvhCoabY1768360010900.js";const{BackSide:n,BoxGeometry:e,Mesh:o,ShaderMaterial:i,UniformsUtils:a,Vector3:c}=await t("three");class r extends o{constructor(){const t=r.SkyShader,o=new i({name:t.name,uniforms:a.clone(t.uniforms),vertexShader:t.vertexShader,fragmentShader:t.fragmentShader,side:n,depthWrite:!1});super(new e(1,1,1),o),this.isSky=!0}}r.SkyShader={name:"SkyShader",uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new c},up:{value:new c(0,1,0)}},vertexShader:"\n\t\tuniform vec3 sunPosition;\n\t\tuniform float rayleigh;\n\t\tuniform float turbidity;\n\t\tuniform float mieCoefficient;\n\t\tuniform vec3 up;\n\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\t// constants for atmospheric scattering\n\t\tconst float e = 2.71828182845904523536028747135266249775724709369995957;\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\t// wavelength of used primaries, according to preetham\n\t\tconst vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n\t\t// this pre-calculation replaces older TotalRayleigh(vec3 lambda) function:\n\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n\t\tconst vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n\t\t// mie stuff\n\t\t// K coefficient for the primaries\n\t\tconst float v = 4.0;\n\t\tconst vec3 K = vec3( 0.686, 0.678, 0.666 );\n\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n\t\tconst vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n\t\t// earth shadow hack\n\t\t// cutoffAngle = pi / 1.95;\n\t\tconst float cutoffAngle = 1.6110731556870734;\n\t\tconst float steepness = 1.5;\n\t\tconst float EE = 1000.0;\n\n\t\tfloat sunIntensity( float zenithAngleCos ) {\n\t\t\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n\t\t\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n\t\t}\n\n\t\tvec3 totalMie( float T ) {\n\t\t\tfloat c = ( 0.2 * T ) * 10E-18;\n\t\t\treturn 0.434 * c * MieConst;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvWorldPosition = worldPosition.xyz;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n\t\t\tvSunDirection = normalize( sunPosition );\n\n\t\t\tvSunE = sunIntensity( dot( vSunDirection, up ) );\n\n\t\t\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n\t\t\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n\t\t\t// extinction (absorption + out scattering)\n\t\t\t// rayleigh coefficients\n\t\t\tvBetaR = totalRayleigh * rayleighCoefficient;\n\n\t\t\t// mie coefficients\n\t\t\tvBetaM = totalMie( turbidity ) * mieCoefficient;\n\n\t\t}",fragmentShader:"\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\tuniform float mieDirectionalG;\n\t\tuniform vec3 up;\n\n\t\t// constants for atmospheric scattering\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\tconst float n = 1.0003; // refractive index of air\n\t\tconst float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n\t\t// optical length at zenith for molecules\n\t\tconst float rayleighZenithLength = 8.4E3;\n\t\tconst float mieZenithLength = 1.25E3;\n\t\t// 66 arc seconds -> degrees, and the cosine of that\n\t\tconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n\t\t// 3.0 / ( 16.0 * pi )\n\t\tconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n\t\t// 1.0 / ( 4.0 * pi )\n\t\tconst float ONE_OVER_FOURPI = 0.07957747154594767;\n\n\t\tfloat rayleighPhase( float cosTheta ) {\n\t\t\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n\t\t}\n\n\t\tfloat hgPhase( float cosTheta, float g ) {\n\t\t\tfloat g2 = pow( g, 2.0 );\n\t\t\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n\t\t\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec3 direction = normalize( vWorldPosition - cameraPosition );\n\n\t\t\t// optical length\n\t\t\t// cutoff angle at 90 to avoid singularity in next formula.\n\t\t\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n\t\t\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n\t\t\tfloat sR = rayleighZenithLength * inverse;\n\t\t\tfloat sM = mieZenithLength * inverse;\n\n\t\t\t// combined extinction factor\n\t\t\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n\t\t\t// in scattering\n\t\t\tfloat cosTheta = dot( direction, vSunDirection );\n\n\t\t\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n\t\t\tvec3 betaRTheta = vBetaR * rPhase;\n\n\t\t\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );\n\t\t\tvec3 betaMTheta = vBetaM * mPhase;\n\n\t\t\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n\t\t\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n\t\t\t// nightsky\n\t\t\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]\n\t\t\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]\n\t\t\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n\t\t\tvec3 L0 = vec3( 0.1 ) * Fex;\n\n\t\t\t// composition + solar disc\n\t\t\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n\t\t\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n\t\t\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n\t\t\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n\t\t\tgl_FragColor = vec4( retColor, 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}"};const{AnimationClip:l,AnimationMixer:s,Matrix4:u,Quaternion:f,QuaternionKeyframeTrack:v,SkeletonHelper:d,Vector3:h,VectorKeyframeTrack:p}=await t("three");function g(t){const n=new Map,e=new Map,o=t.clone();return m(t,o,function(t,o){n.set(o,t),e.set(t,o)}),o.traverse(function(t){if(!t.isSkinnedMesh)return;const o=t,i=n.get(t),a=i.skeleton.bones;o.skeleton=i.skeleton.clone(),o.bindMatrix.copy(i.bindMatrix),o.skeleton.bones=a.map(function(t){return e.get(t)}),o.bind(o.skeleton,o.bindMatrix)}),o}function m(t,n,e){e(t,n);for(let o=0;o<t.children.length;o++)m(t.children[o],n.children[o],e)}const{ref:y,shallowReactive:b}=await t("vue"),w=await t("three");function x(t){return function(t){const n=(new w.Box3).setFromObject(t),e=new w.Vector3;n.getCenter(e);const o=new w.Vector3;n.getSize(o);const i=n.min.y,a=new w.Group;return a.name="centeredGroup",t.position.sub(e),t.position.y=-i,a.add(t),a}(function(t){let n=null;return function(t){let n=!1;return t.traverse(t=>{t.isSkinnedMesh&&(n=!0)}),n}(t)?(n=g(t),n.updateMatrixWorld(!0)):n=t.clone(),n}(t))}function E(t,n){if(!t||!n?.length)return;const e=n.filter(t=>t.enabled);if(!e.length)return;const o=e.find(t=>"click"===t.eventType),i=e.find(t=>"doubleclick"===t.eventType);let a=null;const c=(t,n)=>{const{currentObject:e,point:o,object:i,distance:a}=n;t.function(n,e,o,i,a)};(o||i)&&(o&&(t.addEventListener("click",t=>{a&&clearTimeout(a),i?a=setTimeout(()=>c(o,t),250):c(o,t)}),console.log(`✅ 已绑定 click uuid=${t.uuid}`)),i&&(t.addEventListener("dblclick",t=>{a&&(clearTimeout(a),a=null),c(i,t)}),console.log(`✅ 已绑定 dblclick uuid=${t.uuid}`)));for(const r of e)["click","doubleclick"].includes(r.eventType)||(t.addEventListener(r.eventType,t=>c(r,t)),console.log(`✅ 已绑定 ${r.eventType} uuid=${t.uuid}`))}function T(t){const n={},e={click:null,doubleclick:null,contextmenu:null,pointerenter:null,pointerleave:null};for(const i of t)i.enabled&&"function"==typeof i.function&&(e[i.eventType]=t=>{const{currentObject:n,point:e,object:o,distance:a}=t;i.function(t,n,e,o,a)},console.log(`✅ 已绑定 ${i.eventType} `));let o=null;(e.click||e.doubleclick)&&(n.click=t=>{o&&clearTimeout(o),e.doubleclick?o=setTimeout(()=>{e.click?.(t)},250):e.click?.(t)},e.doubleclick&&(n.dblclick=t=>{o&&(clearTimeout(o),o=null),e.doubleclick?.(t)}));for(const i of["contextmenu","pointerenter","pointerleave"])e[i]&&(n[i]=e[i]);return n}function k(){window.globalTvtFun&&window.globalTvtFun?.gerstnerWater_updateMeshList&&window.globalTvtFun?.gerstnerWater_updateMeshList(!0)}export{r as Sky,T as extendMakeEvent,E as meshAddEvent,k as onReadySenceOnce,x as standardizationMeshCopy};
