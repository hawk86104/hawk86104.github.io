import{P as e}from"./tweakpane.CqZAnw7f1763541780170.js";import{i as o}from"./Resource.Cw8OnALu1763541780170.js";import"./@fesjs.DD9azIsJ1763541780170.js";/* empty css                                                                             */import{l as n}from"./yangyangLoading.BcCqvO4X1763541780170.js";import"./three-mesh-ui.module.D3gU0ixQ1763541780170.js";import"./global.NituJV0f1763541780170.js";/* empty css                                                              */import"./shapeConfigurator.vue_vue_type_style_index_1_scoped_abbf0cc1_lang.D34gkB8O1763541780170.js";import{b as l}from"./pagesShow.vue_vue_type_script_setup_true_lang.D_7dF83l1763541780170.js";import{_ as a}from"./@tresjs.MD0a_GHJ1763541780170.js";import{d as r,w as t,G as i,o as s,a9 as f,aa as u,a as c,I as d,h as p,u as m,r as v,e as h,b as g,H as w,m as y,F as C}from"./@vue.D9fSGD371763541780170.js";import{k as O,a6 as T,d as _}from"./three.F31Lz30M1763541780170.js";import"./vue-router.Bt0PFAN11763541780170.js";import"./lodash-es.DWe8oqPO1763541780170.js";import"./pinia.CbQiAydb1763541780170.js";import"./@qlin.y-0Z8WnK1763541780170.js";import"./@babel.BPq7uOAK1763541780170.js";import"./@floating-ui.Bhq4ibgf1763541780170.js";import"./@juggle.Vc7cP4_P1763541780170.js";import"./utils.C6G49BqD1763541780170.js";import"./color.CKhTNrTY1763541780170.js";import"./color-string.Cyg2_hFL1763541780170.js";import"./color-name.gyPnsvCn1763541780170.js";import"./lodash.BdjyYiRW1763541780170.js";import"./@amap.fjyZdsU91763541780170.js";import"./object-hash.Bg6hZt921763541780170.js";import"./jszip.DlMTIJ0v1763541780170.js";import"./three-custom-shader-material.CEYdA4hW1763541780170.js";import"./buildingsCustomShaderMaterial.DyBo--wu1763541780170.js";import"./postprocessing.CQ_CcmSv1763541780170.js";import"./@vueuse.C5rlNtd31763541780170.js";const b=r({__name:"meshSpiralMaterial",props:{frontColor:{default:"#320564"},backColor:{default:"#ec22ff"},intensity:{default:1.5},powerOffset:{default:4},noiseCutOff:{default:.32},colorBoth:{type:Boolean,default:!1}},setup(e){const n=e,l=o.getItem("noiseVoronoi.png"),r={uniforms:{uTime:{value:0},uFrontColor:{value:new O(n.frontColor)},uBackColor:{value:new O(n.backColor).multiplyScalar(n.intensity)},uNoise:{value:l},uPowerOffset:{value:n.powerOffset},uNoiseCutOff:{value:n.noiseCutOff},uColorBoth:{value:n.colorBoth}},vertexShader:"out vec2 vUv;\n\nvoid main()\n{\n    \n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    vUv = uv;\n    \n}",fragmentShader:"uniform float uTime;\nuniform vec3 uFrontColor;\nuniform vec3 uBackColor;\nuniform sampler2D uNoise;\nuniform float uPowerOffset;\nuniform float uNoiseCutOff;\nuniform bool uColorBoth;\n\nin vec2 vUv;\n\nvoid clip( float clipValue, float alphaThreshold, int type )\n{\n    \n    switch( type )\n    {\n        case 0: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n\n        case 1: \n            if( clipValue > alphaThreshold ) discard;\n        break;\n\n        case 2: \n            if( clipValue <= alphaThreshold ) discard;\n        break;\n\n        case 3: \n            if( clipValue >= alphaThreshold ) discard;\n        break;\n\n        case 4: \n            if( clipValue == alphaThreshold ) discard;\n        break;\n\n        default: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n    }\n}\nvec2 tileOffset( vec2 uv , vec2 tiling, vec2 offset )\n{\n    return  uv * tiling + offset;\n}\n\nvoid main()\n{\n    vec2 uv = vUv;\n\n    vec2 timeOffset = vec2( uTime * 0.6, 0.0 );\n\n    \n\n    \n    vec3 noiseVoronoi = texture( uNoise, uv ).rgb;\n\n    float uvCutOff = uv.y;\n\n    uvCutOff = smoothstep( 0.02, 1.0, uvCutOff + 0.2  );\n\n    \n    float noiseCutOff = pow( noiseVoronoi.r, uPowerOffset );\n\n    \n\n    \n    vec3 colorFront = uFrontColor;\n    colorFront *= noiseCutOff;\n\n    vec3 colorBack = uBackColor;\n    colorBack *= noiseCutOff;\n\n    \n    vec3 colorFinal = colorFront;\n\n    if( uColorBoth )\n    {\n        colorFinal = ( ( gl_FrontFacing ) ? colorFront : colorBack );\n    }\n\n    \n    clip( noiseCutOff, uNoiseCutOff, 0 );\n\n    gl_FragColor = vec4( colorFinal, noiseCutOff * uvCutOff );\n    \n\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n\n}",transparent:!0,side:T,depthWrite:!0,depthTest:!0},{onBeforeRender:c}=a();return c(({delta:e})=>{r.uniforms.uTime.value+=e}),t(()=>[n.frontColor,n.backColor],([e,o])=>{r.uniforms.uFrontColor.value.setStyle(e),r.uniforms.uBackColor.value.setStyle(o).multiplyScalar(n.intensity)}),(e,o)=>(s(),i("TresShaderMaterial",f(u(r)),null,16))}}),S=["geometry"],j=r({__name:"highlightMiddle",props:{frontColor:{default:"#111111"},backColor:{default:"#ff810c"}},setup(e){const n=c(null),{nodes:l}=o.getItem("spiral-middle.glb"),{onBeforeRender:r}=a();return r(({delta:e,elapsed:o})=>{if(n.value){const l=3.4*o,a=.2*Math.sin(l)+.8;n.value.rotation.y+=6*e,n.value.scale.set(a,a,a)}}),(e,o)=>(s(),i("TresGroup",null,[d("TresMesh",{ref_key:"meshRef",ref:n,geometry:m(l).Cylinder.geometry,renderOrder:999991},[p(b,{frontColor:e.frontColor,backColor:e.backColor,intensity:2.7,powerOffset:12,colorBoth:""},null,8,["frontColor","backColor"])],8,S)]))}});const x=r({__name:"meshTornadoMaterial",props:{colorBase:{default:"#ff821c"},colorIntensity:{default:12},twirlAmount:{default:8},radialShearAmount:{default:new _(5,5)},twirlOffset:{default:new _(0,.5)},radialOffset:{default:new _(0,.5)},twirlCenter:{default:new _(.5,-.5)},radialCenter:{default:new _(.5,.5)},noisePower:{default:1},alphaThreshold:{default:.17},showEdge:{type:Boolean,default:!1}},setup(e){const o=e,n={uniforms:{uTime:{value:0},uColor:{value:new O(o.colorBase).multiplyScalar(o.colorIntensity)},uTwirl:{value:o.twirlAmount},uRadialShear:{value:o.radialShearAmount},uTwirlOffset:{value:o.twirlOffset},uRadialOffset:{value:o.radialOffset},uTwirlCenter:{value:o.twirlCenter},uRadialCenter:{value:o.radialCenter},uNoisePower:{value:o.noisePower},uAlphaThreshold:{value:o.alphaThreshold},uEdge:{value:o.showEdge}},vertexShader:"out vec2 vUv;\n\nvoid main()\n{\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    vUv = uv;\n}",fragmentShader:"uniform float uTime;\nuniform vec3 uColor;\nuniform float uTwirl;\nuniform vec2 uRadialShear;\nuniform vec2 uTwirlOffset;\nuniform vec2 uRadialOffset;\nuniform vec2 uTwirlCenter;\nuniform vec2 uRadialCenter;\nuniform float uNoisePower;\nuniform float uAlphaThreshold;\nuniform bool uEdge;\n\nin vec2 vUv;\n\nvoid clip( float clipValue, float alphaThreshold, int type )\n{\n    \n    switch( type )\n    {\n        case 0: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n\n        case 1: \n            if( clipValue > alphaThreshold ) discard;\n        break;\n\n        case 2: \n            if( clipValue <= alphaThreshold ) discard;\n        break;\n\n        case 3: \n            if( clipValue >= alphaThreshold ) discard;\n        break;\n\n        case 4: \n            if( clipValue == alphaThreshold ) discard;\n        break;\n\n        default: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n    }\n}\nvec2 twirl(vec2 uv, vec2 center, float strength, vec2 offset)\n{\n    vec2 delta = uv - center;\n    float angle = strength * length(delta);\n    float x = cos(angle) * delta.x - sin(angle) * delta.y;\n    float y = sin(angle) * delta.x + cos(angle) * delta.y;\n    return vec2(x + center.x + offset.x, y + center.y + offset.y);\n}\nvec2 radialShear( vec2 uv, vec2 center, float strength, vec2 offset )\n{\n    vec2 delta = uv - center;\n    float delta2 = dot( delta.xy, delta.xy );\n\n    float deltaOffset = delta2 * strength;\n\n    return uv + vec2( delta.y, -delta.x) * deltaOffset + offset;\n}\n\nvec2 radialShear( vec2 uv, vec2 center, vec2 strength, vec2 offset )\n{\n    vec2 delta = uv - center;\n    vec2 delta2 =  vec2( dot( delta.xy, delta.xy ) );\n\n    vec2 deltaOffset = delta2 * strength;\n\n    return uv + vec2( delta.y, -delta.x) * deltaOffset + offset;\n}\nfloat randomSimple(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat interpolate( float a, float b, float t )\n{\n    return ( 1.0 - t ) * a + ( t * b );\n}\n\nfloat valueNoise( vec2 uv )\n{\n    vec2 i = floor( uv );\n    vec2 f = fract( uv );\n    f = f * f * ( 3.0 - 2.0 * f );\n\n    uv = abs( fract( uv ) - 0.5 );\n    vec2 c0 = i + vec2(0.0, 0.0);\n    vec2 c1 = i + vec2(1.0, 0.0);\n    vec2 c2 = i + vec2(0.0, 1.0);\n    vec2 c3 = i + vec2(1.0, 1.0);\n    float r0 = randomSimple(c0);\n    float r1 = randomSimple(c1);\n    float r2 = randomSimple(c2);\n    float r3 = randomSimple(c3);\n\n    float bottomOfGrid = interpolate(r0, r1, f.x);\n    float topOfGrid = interpolate(r2, r3, f.x);\n    float t = interpolate(bottomOfGrid, topOfGrid, f.y);\n    return t;\n}\n\nfloat noiseSimple( vec2 UV, float Scale )\n{\n    float t = 0.0;\n\n    float freq = pow(2.0, float(0));\n    float amp = pow(0.5, float(3-0));\n    t += valueNoise(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    freq = pow(2.0, float(1));\n    amp = pow(0.5, float(3-1));\n    t += valueNoise(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    freq = pow(2.0, float(2));\n    amp = pow(0.5, float(3-2));\n    t += valueNoise(vec2(UV.x * Scale / freq, UV.y * Scale / freq ) ) * amp;\n\n    return t;\n}\nfloat remap( float value, float min1, float max1, float min2, float max2 ) \n{\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main()\n{\n\n    vec2 uv = vUv;\n    float time = uTime;\n\n    vec2 twirlOffset = vec2( time * uTwirlOffset.x, time * uTwirlOffset.y );\n    vec2 radialOffset = vec2( time * uRadialOffset.x, time * uRadialOffset.y );\n\n    float uvCutOff = uv.y;\n    uvCutOff = smoothstep( 0.2, 1.0, uvCutOff + 0.2 );\n\n    vec2 uvRadial = radialShear( uv, uRadialCenter, uRadialShear, radialOffset );\n    vec2 uvTwirl = twirl( uv, uTwirlCenter, uTwirl, twirlOffset );\n\n    float noiseRadial = noiseSimple( uvRadial, 20.0 );\n    float noiseTwirl = noiseSimple( uvTwirl, 20.0 );\n\n    float noise = noiseRadial * noiseTwirl;\n\n    noise = pow( noise, uNoisePower );\n\n    float dissolve = remap( noise, 0.0, 1.0, 1.0, 0.0 );\n\n    vec3 colorFinal = uColor;\n    colorFinal *= noise;\n\n    clip( noise, uAlphaThreshold, 0 );\n\n    vec4 color = vec4( colorFinal, dissolve );\n\n    if( uEdge )\n    {\n        color.a *= uvCutOff;\n    }\n\n    gl_FragColor = color;\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n\n}",transparent:!0,side:T,depthWrite:!0,depthTest:!0},{onBeforeRender:l}=a();return l(({delta:e})=>{n.uniforms.uTime.value+=e}),t(()=>o.colorBase,e=>{n.uniforms.uColor.value.setStyle(e).multiplyScalar(o.colorIntensity)}),(e,o)=>(s(),i("TresShaderMaterial",f(u(n)),null,16))}}),k=["geometry"],B=r({__name:"tornadoOutter",props:{color:{default:"#ff5400"}},setup(e){const{nodes:n}=o.getItem("tornado.glb");return(e,o)=>(s(),i("TresMesh",{geometry:m(n).tornado.geometry},[p(x,{colorBase:e.color,colorIntensity:2,twirlAmount:6,radialShearAmount:new _(.9,.9),twirlCenter:new _(.5,-.52),twirlOffset:new _(-.5,-.25),radialOffset:new _(-.5,.5),alphaThreshold:.18,showEdge:!1},null,8,["colorBase","radialShearAmount","twirlCenter","twirlOffset","radialOffset"])],8,k))}}),V=["geometry"],F=r({__name:"tornado",props:{color:{default:"#ff5400"}},setup(e){const{nodes:n}=o.getItem("tornado.glb");return(e,o)=>(s(),i("TresMesh",{geometry:m(n).tornado.geometry},[p(x,{colorBase:e.color,colorIntensity:13,twirlAmount:8,radialShearAmount:new _(.7,.7),twirlCenter:new _(.5,-.52),twirlOffset:new _(-1,-.5),radialOffset:new _(-1,.5),alphaThreshold:.23,showEdge:!1},null,8,["colorBase","radialShearAmount","twirlCenter","twirlOffset","radialOffset"])],8,V))}}),R=["geometry"],A=r({__name:"tornadoInner",props:{color:{default:"#ff5400"}},setup(e){const{nodes:n}=o.getItem("tornado.glb");return(e,o)=>(s(),i("TresMesh",{geometry:m(n).tornado.geometry},[p(x,{colorBase:e.color,colorIntensity:8,radialShearAmount:new _(.7,.7),alphaThreshold:.17,showEdge:!0},null,8,["colorBase","radialShearAmount"])],8,R))}}),M=r({__name:"experience",props:{color0:{default:"#111111"},color1:{default:"#ff810c"},color2:{default:"#3a3a3a"},color3:{default:"#ff821c"},color4:{default:"#ff5400"}},setup:e=>(e,o)=>(s(),i("TresGroup",null,[p(j,{scale:[1.1,4.6,1.1],position:[0,-2,0],frontColor:e.color0,backColor:e.color1},null,8,["frontColor","backColor"]),p(B,{scale:[.6,.4,.6],position:[0,-2.5,0],renderOrder:999992,color:e.color2},null,8,["color"]),p(F,{scale:[.44,.4,.44],position:[0,-2.5,0],renderOrder:999993,color:e.color3},null,8,["color"]),p(A,{scale:.4,position:[0,-2.5,0],renderOrder:999994,color:e.color4},null,8,["color"])]))}),N=r({__name:"stylizedTornado",setup(a){o.loadResources([{functionName:"GLTFLoader",url:"./plugins/digitalCity/model/spiral-middle.glb"},{functionName:"GLTFLoader",url:"./plugins/digitalCity/model/tornado.glb"},{functionName:"TextureLoader",url:"./plugins/digitalCity/image/noise/noiseVoronoi.png"}]);const r=new e({title:"龙卷风参数",expanded:!0}),t=v({color0:"#111111",color1:"#ff810c",color2:"#3a3a3a",color3:"#ff821c",color4:"#ff1800"});return r.addBinding(t,"color0",{label:"颜色0"}),r.addBinding(t,"color1",{label:"颜色1"}),r.addBinding(t,"color2",{label:"颜色2"}),r.addBinding(t,"color3",{label:"颜色3"}),r.addBinding(t,"color4",{label:"颜色4"}),(e,a)=>(s(),i(C,null,[p(m(n),{useResourceManager:""}),p(l,{showAxesHelper:!1},{ability:h(()=>[m(o).hasAllFinished.value?(s(),g(M,y({key:0,position:[10,280,0],scale:100},t),null,16)):w("",!0)]),_:1})],64))}});export{N as default};
