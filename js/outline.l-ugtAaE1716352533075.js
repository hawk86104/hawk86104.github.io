var A=Object.defineProperty;var P=Object.getOwnPropertySymbols;var D=Object.prototype.hasOwnProperty,F=Object.prototype.propertyIsEnumerable;var y=(o,e,t)=>e in o?A(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,_=(o,e)=>{for(var t in e||(e={}))D.call(e,t)&&y(o,t,e[t]);if(P)for(var t of P(e))F.call(e,t)&&y(o,t,e[t]);return o};import{az as u,aH as C,b5 as q,b6 as K,b7 as U,b8 as H,aw as W,b9 as Y,a1 as T,ak as J,a7 as Q,a6 as X,o as I,c as Z,L as v,a2 as h,ba as ee,aq as ne,x as te,E as se,a8 as oe,bb as ae,a as g,aa as N,ab as S,ac as ie,Y as i}from"./vendor.0WmFTx_01716352533075.js";import{s as re}from"./shaderMaterial.5tokN2pq1716352533075.js";import{t as ce}from"./BufferGeometryUtils.JjmGIV241716352533075.js";const le=re({screenspace:!1,color:new u("black"),opacity:1,thickness:.05,size:new C},"\n   #include <common>\n   #include <morphtarget_pars_vertex>\n   #include <skinning_pars_vertex>\n   uniform float thickness;\n   uniform float screenspace;\n   uniform vec2 size;\n   void main() {\n     #if defined (USE_SKINNING)\n	   #include <beginnormal_vertex>\n       #include <morphnormal_vertex>\n       #include <skinbase_vertex>\n       #include <skinnormal_vertex>\n       #include <defaultnormal_vertex>\n     #endif\n     #include <begin_vertex>\n	   #include <morphtarget_vertex>\n	   #include <skinning_vertex>\n     #include <project_vertex>\n     vec4 tNormal = vec4(normal, 0.0);\n     vec4 tPosition = vec4(transformed, 1.0);\n     #ifdef USE_INSTANCING\n       tNormal = instanceMatrix * tNormal;\n       tPosition = instanceMatrix * tPosition;\n     #endif\n     if (screenspace == 0.0) {\n       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;\n       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); \n     } else {\n       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;\n       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;\n       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;\n       clipPosition.xy += offset;\n       gl_Position = clipPosition;\n     }\n   }","\n   uniform vec3 color;\n   uniform float opacity;\n   void main(){\n     gl_FragColor = vec4(color, opacity);\n     #include <tonemapping_fragment>\n     #include <".concat(parseInt(Y.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment",">\n   }"));function de({color:o=new u("black"),opacity:e=1,transparent:t=!1,screenspace:a=!1,toneMapped:d=!0,polygonOffset:f=!1,polygonOffsetFactor:x=0,renderOrder:B=0,thickness:O=.05,angle:j=Math.PI,gl:m}){const c=new q;let r={color:o,opacity:e,transparent:t,screenspace:a,toneMapped:d,polygonOffset:f,polygonOffsetFactor:x,renderOrder:B,thickness:O,angle:j};function M(l){const n=c.parent;if(c.clear(),n&&n.geometry){let s;const p=new le({side:K});n.skeleton?(s=new U,s.material=p,s.bind(n.skeleton,n.bindMatrix),c.add(s)):n.isInstancedMesh?(s=new H(n.geometry,p,n.count),s.instanceMatrix=n.instanceMatrix,c.add(s)):(s=new W,s.material=p,c.add(s)),s.geometry=l?ce(n.geometry,l):n.geometry}}function w(l){r=_(_({},r),l);const n=c.children[0];if(n){const{transparent:s,thickness:p,color:E,opacity:V,screenspace:G,toneMapped:L,polygonOffset:R,polygonOffsetFactor:$,renderOrder:k}=r,b=new C;!m&&r.screenspace&&console.warn('Outlines: "screenspace" requires a WebGLRenderer instance to calculate the outline size'),m&&m.getSize(b),Object.assign(n.material,{transparent:s,thickness:p,color:E,opacity:V,size:b,screenspace:G,toneMapped:L,polygonOffset:R,polygonOffsetFactor:$}),k!==void 0&&(n.renderOrder=k)}}return{group:c,updateProps(l){var n;const s=(n=l.angle)!==null&&n!==void 0?n:r.angle;s!==r.angle&&M(s),w(l)},generate(){M(r.angle),w(r)}}}const pe=["object"],z=T({__name:"outlineCom",props:{color:{default:"#ffffff"},thickness:{default:.1},screenspace:{type:Boolean,default:!1}},setup(o){const e=o,{renderer:t}=J(),a=de({color:new u(e.color),thickness:e.thickness,screenspace:e.screenspace,gl:t.value});return Q(()=>{a.generate()}),X(()=>{a.updateProps({color:new u(e.color),thickness:e.thickness,screenspace:e.screenspace})}),(d,f)=>(I(),Z("primitive",{object:v(a).group},null,8,pe))}}),ue=i("TresPerspectiveCamera",{position:[10,10,10],fov:45,near:1,far:1e3},null,-1),fe=i("TresAmbientLight",{intensity:.5},null,-1),me=i("TresDirectionalLight",{position:[15,15,15],intensity:1},null,-1),_e={position:[0,.9,0],name:"torus"},he=i("TresTorusKnotGeometry",{args:[1,.35,100,32]},null,-1),ge=i("TresMeshStandardMaterial",{color:"#ff33ff",roughness:.3,metalness:.5},null,-1),ve={position:[-2.5,.5,2.5],"receive-shadow":"","cast-shadow":"",name:"cube"},xe=i("TresCylinderGeometry",{args:[1.5,1.5,2]},null,-1),Me=i("TresMeshStandardMaterial",{color:3407871,roughness:0,metalness:0},null,-1),ye=T({__name:"outline",setup(o){const e=h({alpha:!0,toneMapping:ee,windowSize:!0,clearColor:0}),t=h({enableDamping:!0,autoRotate:!1}),a=h({color:"#ff00ae",thickness:.1,screenspace:!1}),d=new ne;return d.addBinding(a,"color",{label:"颜色"}),d.addBinding(a,"thickness",{label:"thickness",min:0,max:2,step:.01}),d.addBinding(a,"screenspace",{label:"space"}),(f,x)=>(I(),te(v(ae),oe(e,{"window-size":""}),{default:se(()=>[ue,g(v(ie),N(S(t)),null,16),fe,me,i("TresMesh",_e,[he,ge,g(z,N(S(a)),null,16)]),i("TresMesh",ve,[xe,Me,g(z)])]),_:1},16))}});export{ye as default};
