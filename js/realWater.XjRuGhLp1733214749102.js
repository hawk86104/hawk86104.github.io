import{m as n,e,b as t,U as r,c as o}from"./@tresjs.lftldzUe1733214749102.js";import{P as i}from"./tweakpane.yHWGBmom1733214749102.js";import{_ as c,s as a,m as l,t as s,aA as u}from"./three.aWgA1gea1733214749102.js";import{d as f,a6 as p,b as v,o as g,f as d,u as x,g as h,j as m,al as y,r as w,J as b,aj as R,ak as C}from"./@vue.-THQH3GC1733214749102.js";import"./@vueuse.xtU2GBMi1733214749102.js";var I="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const _=D;!function(n,e){const t=D,r=A();for(;;)try{if(351098===-parseInt(t(451))/1+parseInt(t(476))/2+parseInt(t(466))/3*(parseInt(t(463))/4)+parseInt(t(447))/5+-parseInt(t(483))/6+-parseInt(t(469))/7+-parseInt(t(452))/8)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const M=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){M(this,(function(){const n=D,e=new RegExp(n(485)),t=new RegExp(n(462),"i"),r=L(n(479));e[n(453)](r+n(478))&&t[n(453)](r+n(470))?L():r("0")}))()}();const z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function D(n,e){const t=A();return(D=function(n,e){return t[n-=447]})(n,e)}z(void 0,(function(){const n=D;let e;try{e=Function(n(455)+n(495)+");")()}catch(o){e=window}const t=e[n(474)]=e[n(474)]||{},r=[n(480),n(497),"info",n(458),n(457),"table",n(465)];for(let i=0;i<r[n(471)];i++){const e=z[n(490)].prototype[n(449)](z),o=r[i],c=t[o]||e;e[n(460)]=z.bind(z),e[n(475)]=c.toString[n(449)](c),t[o]=e}}))();const T=f({__name:_(477),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=_,o=t,i=new(c[r(484)]),a=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),l=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(456)](r(492),new(c[r(464)])(a,3)),i[r(459)](new(c[r(464)])(l,1));const s=new(c[r(454)])({uniforms:{light:{value:o.light},tiles:{value:o[r(487)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(486)]}),u=new(c[r(482)])(i,s),{renderer:f,camera:p}=n(),{onAfterLoop:v}=e();return v((()=>{((n,e)=>{const t=r;s[t(461)][t(489)][t(488)]=n,s[t(461)][t(491)].value=e,f[t(488)][t(473)](u,p[t(488)])})(o[r(481)],o.causticsTexture)})),(n,e)=>null}});function L(n){function e(n){const t=D;if(typeof n===t(450))return function(n){}[t(490)](t(468))[t(493)]("counter");1!==(""+n/n)[t(471)]||n%20==0?function(){return!0}[t(490)](t(467)+t(494))[t(496)](t(472)):function(){return!1}[t(490)](t(467)+t(494))[t(493)](t(448)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function A(){const n=["setIndex","__proto__","uniforms","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","4XjLfwz","BufferAttribute","trace","1771137cgzJVL","debu","while (true) {}","4213622YHqEQl","input","length","action","render","console","toString","317158XvysVS","pool","chain","init","log","waterTexture","Mesh","132636PlLfkR","BufferGeometry","function *\\( *\\)","FrontSide","tiles","value","water","constructor","causticTex","position","apply","gger",'{}.constructor("return this")( )',"call","warn","2356385COCGZk","stateObject","bind","string","42845ecpMex","1617920AVKdyp","test","RawShaderMaterial","return (function() ","setAttribute","exception","error"];return(A=function(){return n})()}function O(){const n=["log","waterTexture","pos-y.jpg","value","light","return (function() ","210570hcgmEp","toString","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","1070290LazAst","side","uniforms","86696EmctiB","clear",'{}.constructor("return this")( )',"input","14hApesh","Color","CubeTextureLoader","render","RawShaderMaterial","white","while (true) {}","gger","pooRef","underwater","water","22mwIzvR","BackSide","790278KrtbuG","1421996wEHmkn","action","6qkiJsP","warn","89265fkGsRv","setPath","constructor","bind","string","apply","console","trace","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","setRenderTarget","geometry","tiles","exception","neg-y.jpg","causticTex","length","220284cfwjol","3uDYSGi","counter","function *\\( *\\)","chain","stateObject","error","causticsTexture","FrontSide","debu","neg-z.jpg"];return(O=function(){return n})()}const F=E;!function(n,e){const t=E,r=O();for(;;)try{if(252697===-parseInt(t(340))/1+parseInt(t(335))/2+parseInt(t(296))/3*(-parseInt(t(336))/4)+-parseInt(t(312))/5*(-parseInt(t(338))/6)+parseInt(t(322))/7*(parseInt(t(318))/8)+parseInt(t(295))/9+-parseInt(t(315))/10*(-parseInt(t(333))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[E(345)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){S(this,(function(){const n=E,e=new RegExp(n(298)),t=new RegExp(n(314),"i"),r=P("init");e.test(r+n(299))&&t.test(r+n(321))?P():r("0")}))()}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[E(345)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function E(n,e){const t=O();return(E=function(n,e){return t[n-=288]})(n,e)}j(void 0,(function(){const n=E;let e;try{e=Function(n(311)+n(320)+");")()}catch(o){e=window}const t=e[n(346)]=e[n(346)]||{},r=[n(306),n(339),"info",n(301),n(291),"table",n(347)];for(let i=0;i<r.length;i++){const e=j[n(342)].prototype.bind(j),o=r[i],c=t[o]||e;e.__proto__=j[n(343)](j),e[n(313)]=c[n(313)].bind(c),t[o]=e}}))();const W=f({__name:F(332),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=F;let i,l;const s=r,u=s[o(289)],f=(new(c[o(324)]))[o(341)](o(348)).load(["pos-x.jpg","neg-x.jpg",o(308),o(292),"pos-z.jpg",o(305)]),h=([i,l]=p((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,l(),i),m=new(c[o(326)])({uniforms:{light:{value:s[o(310)]},tiles:{value:h},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new a(u,m),w=v(null),b=new(c[o(323)])(o(327)),{renderer:R,camera:C}=n(),{onLoop:I}=e();return I((()=>{const n=o;R[n(309)][n(288)](null),R.value.setClearColor(b,1),R.value[n(319)](),m[n(317)].water[n(309)]=s[n(307)],m[n(317)][n(293)][n(309)]=s[n(302)],m[n(316)]=c[n(303)],m[n(317)][n(331)][n(309)]=!0,R.value[n(325)](y,C[n(309)]),m.side=c[n(334)],m[n(317)][n(331)][n(309)]=!1,R[n(309)].render(y,C[n(309)])})),(n,e)=>{const t=o;return g(),d(T,{tiles:x(h),light:n[t(310)],waterTexture:n[t(307)],causticsTexture:n[t(302)],ref_key:t(330),ref:w},null,8,[t(290),"light","waterTexture",t(302)])}}});function P(n){function e(n){const t=E;if(typeof n===t(344))return function(n){}[t(342)](t(328)).apply(t(297));1!==(""+n/n)[t(294)]||n%20==0?function(){return!0}[t(342)](t(304)+t(329)).call(t(337)):function(){return!1}[t(342)](t(304)+t(329))[t(345)](t(300)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const k=V;!function(n,e){const t=V,r=N();for(;;)try{if(508874===parseInt(t(428))/1*(-parseInt(t(440))/2)+parseInt(t(443))/3+-parseInt(t(416))/4*(-parseInt(t(399))/5)+-parseInt(t(420))/6*(parseInt(t(417))/7)+-parseInt(t(424))/8+parseInt(t(435))/9+parseInt(t(410))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const H=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[V(442)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function V(n,e){const t=N();return(V=function(n,e){return t[n-=398]})(n,e)}!function(){H(this,(function(){const n=V,e=new RegExp(n(433)),t=new RegExp(n(405),"i"),r=B(n(429));e[n(437)](r+n(423))&&t.test(r+n(403))?B():r("0")}))()}();const G=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[V(442)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function N(){const n=["string","3916359JnYFzv","constructor","test","debu","water","2698dcHMaa","action","apply","1963233sujwlk","__proto__",'{}.constructor("return this")( )',"OrthographicCamera","light","call","4435cuFQJH","while (true) {}","texture","causticsTexture","input","black","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","waterTexture","exception","return (function() ","prototype","7272640CcZETo","stateObject","WebGLRenderTarget","bind","counter","clear","732MgLzHq","494564RfGiol","PlaneGeometry","log","6BUTSco","Color","console","chain","5725424PXlmRh","caustics","length","value","507DbGrpc","init","gger","trace","warn","function *\\( *\\)"];return(N=function(){return n})()}G(void 0,(function(){const n=V,e=function(){const n=V;let e;try{e=Function(n(408)+n(445)+");")()}catch(t){e=window}return e}(),t=e[n(422)]=e[n(422)]||{},r=[n(419),n(432),"info","error",n(407),"table",n(431)];for(let o=0;o<r[n(426)];o++){const e=G.constructor[n(409)][n(413)](G),i=r[o],c=t[i]||e;e[n(444)]=G[n(413)](G),e.toString=c.toString.bind(c),t[i]=e}}))();const Z=f({__name:k(425),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=k,o=t,i=new(c[r(446)])(0,1,1,0,0,2e3),s=new(c[r(418)])(2,2,200,200),u=new(c[r(412)])(1024,1024),f=new l({uniforms:{light:{value:o[r(447)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new a(s,f),v=new(c[r(421)])(r(404)),{renderer:w}=n(),{onBeforeLoop:b}=e();return b((()=>{const n=r;p.material.uniforms[n(439)][n(427)]=o.waterTexture,w.value.setRenderTarget(u),w[n(427)].setClearColor(v,0),w[n(427)][n(415)](),w[n(427)].render(p,i)})),(n,e)=>{const t=r;return g(),d(y,null,{default:h((()=>[m(W,{waterTexture:n.waterTexture,causticsTexture:x(u)[t(401)],light:n.light,geometry:x(s)},null,8,[t(406),t(402),t(447),"geometry"])])),_:1})}}});function B(n){function e(n){const t=V;if(typeof n===t(434))return function(n){}[t(436)](t(400))[t(442)](t(414));1!==(""+n/n)[t(426)]||n%20==0?function(){return!0}[t(436)](t(438)+t(430))[t(398)](t(441)):function(){return!1}[t(436)]("debu"+t(430))[t(442)](t(411)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const Y=q;!function(n,e){const t=q,r=J();for(;;)try{if(787734===-parseInt(t(179))/1*(-parseInt(t(230))/2)+-parseInt(t(231))/3*(parseInt(t(222))/4)+parseInt(t(188))/5+parseInt(t(246))/6+-parseInt(t(189))/7+-parseInt(t(207))/8+parseInt(t(198))/9*(parseInt(t(218))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const $=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(215)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){$(this,(function(){const n=q,e=new RegExp(n(191)),t=new RegExp(n(203),"i"),r=K(n(186));e[n(211)](r+n(242))&&t[n(211)](r+"input")?K():r("0")}))()}();const X=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function q(n,e){const t=J();return(q=function(n,e){return t[n-=178]})(n,e)}X(void 0,(function(){const n=q;let e;try{e=Function(n(194)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e.console=e.console||{},r=[n(192),n(195),n(244),n(228),n(210),"table",n(213)];for(let i=0;i<r[n(220)];i++){const e=X[n(225)].prototype.bind(X),o=r[i],c=t[o]||e;e[n(233)]=X[n(212)](X),e[n(184)]=c.toString[n(212)](c),t[o]=e}}))();const U=f({__name:Y(229),props:{light:{}},setup(t,{expose:r}){const o=Y,i=new(c[o(187)])(0,1,1,0,0,2e3),l=new s(2,2),f=new(c[o(201)])(256,256,{type:c[o(238)]}),p=new(c[o(201)])(256,256,{type:c[o(238)]}),v=new u({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:I,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),h=new(c[o(224)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:I,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),m=new(c[o(224)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:I,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),y=new(c[o(182)])(l,v),w=new(c[o(182)])(l,h),b=new a(l,m);let R=f;const C=(n,e)=>{const t=o,r=R,c=R===f?p:f;e[t(185)][t(196)][t(240)][t(202)]=r[t(240)],n[t(217)](c),n[t(234)](e,i),R=c},{renderer:_,camera:M,raycaster:z}=n();_[o(202)][o(227)]=!1;const{onBeforeLoop:D}=e();D((()=>{const n=o;var e,t;t=_[n(202)],C(t,b),e=_[n(202)],C(e,w)}));const T=(n,e,t,r)=>{const i=o;y[i(185)].uniforms[i(208)][i(202)]=[n,e],y.material[i(196)][i(199)].value=t,y.material[i(196)][i(223)].value=r,C(_.value,y)},L=new(c[o(247)]),A=new(c[o(241)])(2,2),O=A[o(236)].position;for(let n=0;n<O[o(214)];n++){const e=-O.getY(n);O[o(221)](n,0),O[o(178)](n,e)}O[o(183)]=!0;const F=new(c[o(182)])(A),S={handleEvent:n=>{const e=o,t=_[e(202)][e(204)][e(181)](),r=t[e(205)],i=t[e(226)];L.x=2*(n.clientX-t.left)/r-1,L.y=2*-(n[e(209)]-t[e(232)])/i+1,z[e(202)].setFromCamera(L,M[e(202)]);const c=z[e(202)].intersectObject(F);for(let o of c)T(o[e(237)].x,o[e(237)].z,.03,.04)}};return r({addDrop:T,mouseEvent:n=>{const e=o;n?_[e(202)][e(204)][e(180)](e(219),S):_[e(202)].domElement[e(239)]("mousemove",S)}}),(n,e)=>{const t=o;return g(),d(Z,{lightFrontGeometry:x(l),waterTexture:x(R)[t(240)],light:n[t(243)]},null,8,["lightFrontGeometry",t(245),"light"])}}});function J(){const n=["init","OrthographicCamera","3955580MyjDpM","2634667UMGcgJ","stateObject","function *\\( *\\)","log","gger","return (function() ","warn","uniforms","while (true) {}","9ysFlnR","radius","debu","WebGLRenderTarget","value","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","domElement","width","string","7640352KmWTlL","center","clientY","exception","test","bind","trace","count","apply","counter","setRenderTarget","15173260WkDaUi","mousemove","length","setY","44HhlXHi","strength","RawShaderMaterial","constructor","height","autoClear","error","waterSimulation","28506NVyfiz","384630bzYfhy","top","__proto__","render","call","attributes","point","FloatType","removeEventListener","texture","PlaneGeometry","chain","light","info","waterTexture","2451636xXXkWl","Vector2","setZ","57XcTOfc","addEventListener","getBoundingClientRect","Mesh","needsUpdate","toString","material"];return(J=function(){return n})()}function K(n){function e(n){const t=q;if(typeof n===t(206))return function(n){}[t(225)](t(197)).apply(t(216));1!==(""+n/n)[t(220)]||n%20==0?function(){return!0}[t(225)](t(200)+t(193))[t(235)]("action"):function(){return!1}.constructor(t(200)+t(193))[t(215)](t(190)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=tn,r=en();for(;;)try{if(890093===parseInt(t(361))/1*(-parseInt(t(374))/2)+-parseInt(t(354))/3+parseInt(t(375))/4*(parseInt(t(365))/5)+parseInt(t(388))/6+-parseInt(t(383))/7+-parseInt(t(373))/8*(-parseInt(t(349))/9)+parseInt(t(385))/10*(parseInt(t(377))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(384)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Q(this,(function(){const n=tn,e=new RegExp(n(355)),t=new RegExp(n(364),"i"),r=on("init");e[n(387)](r+n(371))&&t[n(387)](r+n(360))?on():r("0")}))()}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(384)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function en(){const n=["274618LZWNyW","48rCQpCk","stateObject","429IIdaIC","gger","call","鼠标波纹","prototype","click","8570072jmcrMv","apply","453980DYtUdO","addDrop","test","761598yYXuMd","action","随机增加波纹","addBinding","toString","addButton","mouseEvent","while (true) {}","random","263799pCaiwQ","info","console","debu","length","4853253oRxPGT","function *\\( *\\)","table","bind","waterSimulationRef","value","input","2OvNRpv","trace","error","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","329295uBNcYl","string","warn","log","__proto__","constructor","chain","manual","360CTkhKt"];return(en=function(){return n})()}function tn(n,e){const t=en();return(tn=function(n,e){return t[n-=341]})(n,e)}nn(void 0,(function(){const n=tn;let e;try{e=Function('return (function() {}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(351)]=e[n(351)]||{},r=[n(368),n(367),n(350),n(363),"exception",n(356),n(362)];for(let i=0;i<r[n(353)];i++){const e=nn[n(370)][n(381)][n(357)](nn),o=r[i],c=t[o]||e;e[n(369)]=nn[n(357)](nn),e.toString=c[n(344)].bind(c),t[o]=e}}))();const rn=f({__name:"realWater",setup(n){const e=tn,t=w({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(372)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=v(null),l=new i;l[e(345)]({label:"点击按钮",title:e(342)}).on(e(382),(()=>{const n=e;for(var t=0;t<10;t++)a[n(359)][n(386)](2*Math[n(348)]()-1,2*Math.random()-1,.03,1&t?.02:-.02)}));const s=v(!1);return l[e(343)](s,"value",{label:e(380)}).on("change",(n=>{const t=e;a[t(359)][t(346)](n[t(359)])})),(n,i)=>{const l=e;return g(),d(x(o),R(C(t)),{default:h((()=>[i[0]||(i[0]=b("TresPerspectiveCamera",{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),m(x(r)),m(U,{light:c,ref_key:l(358),ref:a},null,512)])),_:1},16)}}});function on(n){function e(n){const t=tn;if(typeof n===t(366))return function(n){}[t(370)](t(347))[t(384)]("counter");1!==(""+n/n)[t(353)]||n%20==0?function(){return!0}[t(370)](t(352)+"gger")[t(379)](t(341)):function(){return!1}[t(370)](t(352)+t(378)).apply(t(376)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{rn as default};
