import{o as e}from"./index.Crdf3MNx1763540743861.js";import{F as t,_ as a}from"./@tresjs.BCHtwiaC1763540743861.js";import{s as o}from"./snoise.B6agkY-m1763540743861.js";import{d as n,a8 as r,w as i,H as s,o as u,u as l,J as c}from"./@vue.Co_gxueH1763540743861.js";import{j as v,l as d,b8 as p,k as f,V as m}from"./three.rXKzP9fQ1763540743861.js";const g=["geometry"],A=["blending"],w=n({__name:"particlesPoints",props:{geo:{default:new v},uEdge:{default:6},uFreq:{default:.41},uAmp:{default:20},uProgress:{default:-2},uColor:{default:"#4d9bff"},uPointSize:{default:200},particleData:{default:{particleSpeedFactor:.02,velocityFactor:{x:2.5,y:2},waveAmplitude:0}}},async setup(n){let v,w;const y=n,P=y.geo.clone(),b=([v,w]=r(()=>e("./plugins/industry4/image/particle.png")),v=await v,w(),v);let h,x,D,F,M,z,S=P.attributes.position.count;!function(e){S=e.attributes.position.count,h=new Float32Array(S),x=new Float32Array(e.getAttribute("position").array),D=new Float32Array(e.getAttribute("position").array),F=new Float32Array(3*S),M=new Float32Array(S),z=new Float32Array(S);for(let t=0;t<S;t++){let e=3*t+0,a=3*t+1,o=3*t+2;h[t]=5.5*Math.random()+1.5,F[e]=.5*Math.random()+.5,F[a]=.5*Math.random()+.5,F[o]=.1*Math.random(),M[t]=.001,z[t]=Math.random()*Math.PI*2}e.setAttribute("aOffset",new f(h,1)),e.setAttribute("aCurrentPos",new f(D,3)),e.setAttribute("aVelocity",new f(F,3)),e.setAttribute("aDist",new f(M,1)),e.setAttribute("aAngle",new f(z,1))}(P);const{renderer:C}=t(),j={uTexture:{value:b},uPixelDensity:{value:C.getPixelRatio()},uProgress:{value:y.uProgress},uEdge:{value:y.uEdge},uAmp:{value:y.uAmp},uFreq:{value:y.uFreq},uBaseSize:{value:y.uPointSize},uColor:{value:new d(y.uColor)}},E=`\n    ${o}\n    uniform float uPixelDensity;\n    uniform float uBaseSize;\n    uniform float uFreq;\n    uniform float uAmp;\n    uniform float uEdge;\n    uniform float uProgress;\n\n    varying float vNoise;\n    varying float vAngle;\n\n    attribute vec3 aCurrentPos;\n    attribute float aDist;\n    attribute float aAngle;\n\n    void main() {\n        vec3 pos = position;\n\n        float noise = snoise(pos * uFreq) * uAmp;\n        vNoise =noise;\n\n        vAngle = aAngle;\n\n        if( vNoise > uProgress-2.0 && vNoise < uProgress + uEdge+2.0){\n            pos = aCurrentPos;\n        }\n\n        vec4 modelPosition = modelMatrix * vec4(pos, 1.0);\n        vec4 viewPosition = viewMatrix * modelPosition;\n        vec4 projectedPosition = projectionMatrix * viewPosition;\n        gl_Position = projectedPosition;\n\n        float size = uBaseSize * uPixelDensity;\n        size = size  / (aDist + 1.0);\n        gl_PointSize = size / -viewPosition.z;\n}\n`;function _(e){let t=F[3*e+0],a=F[3*e+1],o=F[3*e+2];t*=y.particleData.velocityFactor.x,a*=y.particleData.velocityFactor.y;let{xwave:n,ywave:r}=function(e){const t=D[3*e+0],a=D[3*e+1];let o=Math.sin(2*a)*(.8+y.particleData.waveAmplitude),n=Math.sin(2*t)*(.6+y.particleData.waveAmplitude),r=Math.sin(5*a)*(.2+y.particleData.waveAmplitude),i=Math.sin(1*t)*(.9+y.particleData.waveAmplitude),s=Math.sin(8*a)*(.8+y.particleData.waveAmplitude),u=Math.sin(5*t)*(.6+y.particleData.waveAmplitude);return{xwave:o+r+s+Math.sin(3*a)*(.8+y.particleData.waveAmplitude),ywave:n+i+u+Math.sin(7*t)*(.6+y.particleData.waveAmplitude)}}(e);return t+=n,a+=r,t*=Math.abs(y.particleData.particleSpeedFactor),a*=Math.abs(y.particleData.particleSpeedFactor),o*=Math.abs(y.particleData.particleSpeedFactor),{vx:t,vy:a,vz:o}}const{onBeforeRender:q}=a();return q(()=>{!function(){for(let e=0;e<S;e++){let t=3*e+0,a=3*e+1,o=3*e+2,{vx:n,vy:r,vz:i}=_(e);D[t]+=n,D[a]+=r,D[o]+=i;const s=new m(x[t],x[a],x[o]),u=new m(D[t],D[a],D[o]),l=s.distanceTo(u);M[e]=l,z[e]+=.01,l>h[e]&&(D[t]=x[t],D[a]=x[a],D[o]=x[o])}P.setAttribute("aOffset",new f(h,1)),P.setAttribute("aCurrentPos",new f(D,3)),P.setAttribute("aVelocity",new f(F,3)),P.setAttribute("aDist",new f(M,1)),P.setAttribute("aAngle",new f(z,1))}()}),i(()=>[y.uColor,y.uEdge,y.uFreq,y.uAmp,y.uProgress,y.uPointSize],([e,t,a,o,n,r])=>{j.uColor.value.setStyle(e),j.uEdge.value=t,j.uFreq.value=a,j.uAmp.value=o,j.uProgress.value=n,j.uBaseSize.value=r}),(e,t)=>(u(),s("TresPoints",{geometry:l(P)},[c("TresShaderMaterial",{transparent:"",blending:p,uniforms:j,vertexShader:E,fragmentShader:"\n    uniform vec3 uColor;\n    uniform float uEdge;\n    uniform float uProgress;\n    uniform sampler2D uTexture;\n\n    varying float vNoise;\n    varying float vAngle;\n\n    void main(){\n        if( vNoise < uProgress ) discard;\n        if( vNoise > uProgress + uEdge) discard;\n\n        vec2 coord = gl_PointCoord;\n        coord = coord - 0.5; // get the coordinate from 0-1 ot -0.5 to 0.5\n        coord = coord * mat2(cos(vAngle),sin(vAngle) , -sin(vAngle), cos(vAngle)); // apply the rotation transformaion\n        coord = coord +  0.5; // reset the coordinate to 0-1  \n\n        vec4 texture = texture2D(uTexture,coord);\n\n        gl_FragColor = vec4(vec3(uColor.xyz * texture.xyz),1.0);\n    }\n"},null,8,A)],8,g))}});export{w as _};
