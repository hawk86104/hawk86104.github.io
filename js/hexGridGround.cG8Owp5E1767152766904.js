import{importShared as e}from"./3d-tiles-renderer.CPyPbRB51767152766904.js";import{useTexture as i,useLoop as a,customShaderMaterial_default as n,OrbitControls_default as t}from"./index.BGo9PN8R1767152766904.js";import{Pane as o}from"./tweakpane.BbuIEN141767152766904.js";import{_sfc_main as r}from"./reflectorDUDV.vue_vue_type_script_setup_true_lang.Ds57Dagg1767152766904.js";const{defineComponent:s}=await e("vue"),{unref:d,openBlock:l,createBlock:v}=await e("vue"),{watch:u}=await e("vue"),c=await e("three"),m=s({__name:"hexGridMaterial",props:{baseMaterial:{default:c.MeshBasicMaterial},speed:{default:1},gridWeight:{default:.03},raisedBottom:{default:.05},waveFrequency:{default:.2},wavePow:{default:4},division:{default:32},divisionScaleX:{default:1},direction:{default:4},isReversed:{default:!1},hasMaskTexture:{default:!1},maskTexture:{default:""}},setup(e){const t=e,o={gridWeight:{value:t.gridWeight},raisedBottom:{value:t.raisedBottom},waveFrequency:{value:t.waveFrequency},wavePow:{value:t.wavePow},direction:{value:t.direction},isReversed:{value:t.isReversed},hasMaskTexture:{value:t.hasMaskTexture},maskTexture:{value:null},division:{value:t.division},divisionScaleX:{value:t.divisionScaleX},time:{value:0}};if(t.maskTexture){const{state:e}=i(t.maskTexture);o.maskTexture=e}u(()=>[t.gridWeight,t.raisedBottom,t.waveFrequency,t.wavePow,t.division,t.divisionScaleX,t.direction,t.isReversed,t.hasMaskTexture],([e,i,a,n,t,r,s,d,l])=>{o.gridWeight.value=e,o.raisedBottom.value=i,o.waveFrequency.value=a,o.wavePow.value=n,o.division.value=t,o.divisionScaleX.value=r,o.direction.value=s,o.isReversed.value=d,o.hasMaskTexture.value=l});const{onBeforeRender:r}=a();return r(({delta:e})=>{o.time.value+=e*t.speed}),(i,a)=>(l(),v(d(n),{baseMaterial:e.baseMaterial,vertexShader:"\nvarying vec2 uvPosition;\nvoid main() {\n    uvPosition = uv;\n}\n",side:c.DoubleSide,transparent:"",fragmentShader:d("varying vec2 uvPosition;\n\nuniform float time;\n\nuniform float raisedBottom;\nuniform float waveFrequency;\nuniform float wavePow;\nuniform int direction;\n\nuniform float division;\nuniform float divisionScaleX;\n\nuniform bool hasMaskTexture;\nuniform sampler2D maskTexture;\n\nuniform bool isReversed;\n\nuniform float gridWeight;\n\nfloat hexDist(vec2 p) {\n  p = abs(p);\n  float d = dot(p, normalize(vec2(1.0, 1.73)));\n  return max(d, p.x);\n}\nvec4 hexCoords(vec2 uv) {\n  vec2 r = vec2(1.0, 1.73);\n  vec2 h = r * 0.5;\n  vec2 a = mod(uv, r) - h;\n  vec2 b = mod(uv - h, r) - h;\n\n  vec2 gv = length(a) < length(b) ? a : b;\n  vec2 id = uv - gv;\n\n  float x = atan(gv.x, gv.y);\n  float y = 0.5 - hexDist(gv);\n\n  return vec4(x, y, id);\n}\n\nvoid main() {\n  vec2 uv = uvPosition * vec2(division * divisionScaleX, division);\n  vec4 hc = hexCoords(uv);\n  vec2 id = hc.zw;\n  float distance = id.y;\n  if (direction == 3) {\n    distance = id.x;\n  } else if (direction == 5) {\n    distance = length(id.xy);\n  } else if (direction == 6) {\n    vec2 center = vec2(0.5 * division * divisionScaleX, 0.5 * division);\n    distance = length(uv - center);\n  }\n  float wavy =\n      pow(sin((distance * waveFrequency - time)), wavePow) + raisedBottom;\n\n  float diffuseColorA = csm_DiffuseColor.a;\n  diffuseColorA *= wavy;\n\n  float mask = 1.0;\n  if (hasMaskTexture) {\n    vec2 uVm = id / vec2(division * divisionScaleX, division);\n    mask = texture2D(maskTexture, uVm).g;\n  }\n\n  float w = gridWeight + (1.0 - mask);\n  w = clamp(w, 0.0, 1.0);\n\n  float margin = clamp(w * 0.33, 0.00, 0.02);\n  float stepMax = w + margin;\n\n  float gridLine = smoothstep(w, stepMax, hc.y);\n  gridLine = isReversed ? 1.0 - gridLine : gridLine;\n  diffuseColorA *= gridLine;\n\n  \n  \n  csm_DiffuseColor.rgb *= diffuseColorA;\n\nfloat brightness = length(csm_DiffuseColor.rgb);\n\nfloat alphaBlend = smoothstep(0.0, 1.0, brightness);\n\ncsm_DiffuseColor.a *= alphaBlend;\n\ncsm_FragColor = vec4(csm_DiffuseColor.rgb, csm_DiffuseColor.a);\n}"),uniforms:o},null,8,["baseMaterial","side","fragmentShader"]))}}),{defineComponent:f}=await e("vue"),{createElementVNode:g,unref:p,mergeProps:h,createVNode:w,openBlock:x,createElementBlock:B}=await e("vue"),b=["rotation"],k=await e("three"),M=f({__name:"hexGridMesh",setup(e){const i=k.MeshBasicMaterial;return(e,a)=>(x(),B("TresMesh",{rotation:[-Math.PI/2,0,0]},[a[0]||(a[0]=g("TresPlaneGeometry",{args:[1,1]},null,-1)),w(m,h({baseMaterial:p(i)},e.$attrs,{maskTexture:"./plugins/floor/image/logoBlack.png"}),null,16,["baseMaterial"])],8,b))}}),{defineComponent:y}=await e("vue"),{createElementVNode:_,unref:C,createVNode:T,mergeProps:P,resolveComponent:D,withCtx:S,openBlock:R,createBlock:X}=await e("vue"),{reactive:F}=await e("vue"),q=y({__name:"hexGridGround",setup(e){const i=F({reflectivity:.8,showGridHelper:!1,scale:1}),a=F({color:"#de62f2",speed:1.9,gridWeight:.223,raisedBottom:.66,waveFrequency:.066,wavePow:19,division:46,divisionScaleX:1,isReversed:!1,direction:4,hasMaskTexture:!0}),n=new o({title:"hexGridGround",expanded:!0});return n.addBinding(a,"hasMaskTexture",{label:"图片纹理"}),n.addBinding(a,"color",{label:"颜色"}),n.addBinding(a,"speed",{label:"速度",min:-5,max:5,step:.1}),n.addBinding(a,"gridWeight",{label:"网格宽度",min:.001,max:.5,step:.001}),n.addBinding(a,"raisedBottom",{label:"渐变宽度",min:.001,max:1,step:.001}),n.addBinding(a,"waveFrequency",{label:"分段",min:.001,max:1,step:.001}),n.addBinding(a,"wavePow",{label:"渐变强度",min:1,max:30,step:.1}),n.addBinding(a,"division",{label:"网格整体缩放",min:.1,max:50,step:.1}),n.addBinding(a,"divisionScaleX",{label:"网格横向缩放",min:.1,max:10,step:.1}),n.addBinding(a,"isReversed",{label:"颜色取反"}),n.addBinding(a,"direction",{label:"方向类别",min:3,max:6,step:1}),(e,n)=>{const o=D("TresCanvas");return R(),X(o,{clearColor:"#666666","window-size":""},{default:S(()=>[n[0]||(n[0]=_("TresPerspectiveCamera",{position:[3,3,0],fov:45,near:.1,far:1e4},null,-1)),T(C(t),{enableDamping:"",autoRotate:""}),T(M,P(a,{scale:9}),null,16),T(r,P({position:[0,-.06,0]},i),null,16)]),_:1})}}});export{q as default};
