import{a0 as t,bO as n,_ as e,C as o}from"./three.RUAk_tvU1742436572432.js";import{e as r}from"./@tresjs.Uh9iM8du1742436572432.js";import{g as i}from"./utils.xj2ovq-o1742436572432.js";import{d as s,b as a,a2 as c,w as u,o as l,H as f,N as p,u as v,aj as m,ak as d}from"./@vue.deO5D3Lf1742436572432.js";const y=x;!function(t,n){const e=x,o=I();for(;;)try{if(192403===parseInt(e(183))/1*(-parseInt(e(161))/2)+-parseInt(e(187))/3+-parseInt(e(160))/4*(-parseInt(e(179))/5)+parseInt(e(166))/6*(parseInt(e(136))/7)+-parseInt(e(188))/8*(-parseInt(e(152))/9)+parseInt(e(191))/10*(-parseInt(e(151))/11)+parseInt(e(173))/12)break;o.push(o.shift())}catch(r){o.push(o.shift())}}();const h=function(){let t=!0;return function(n,e){const o=t?function(){if(e){const t=e[x(172)](n,arguments);return e=null,t}}:function(){};return t=!1,o}}();!function(){h(this,(function(){const t=x,n=new RegExp("function *\\( *\\)"),e=new RegExp(t(189),"i"),o=C(t(144));n.test(o+t(137))&&e.test(o+"input")?C():o("0")}))()}();const g=function(){let t=!0;return function(n,e){const o=t?function(){if(e){const t=e[x(172)](n,arguments);return e=null,t}}:function(){};return t=!1,o}}();function x(t,n){const e=I();return(x=function(t,n){return e[t-=133]})(t,n)}g(void 0,(function(){const t=x;let n;try{n=Function(t(133)+t(157)+");")()}catch(r){n=window}const e=n[t(147)]=n[t(147)]||{},o=[t(153),"warn",t(174),"error","exception",t(184),"trace"];for(let i=0;i<o.length;i++){const n=g.constructor[t(149)][t(185)](g),r=o[i],s=e[r]||n;n[t(176)]=g[t(185)](g),n[t(155)]=s[t(155)].bind(s),e[r]=n}}))();const w=[y(141),"uv"],_=s({__name:"rippleMesh",props:{positionSrc:{default:[{x:0,y:0},{x:10,y:10}]},color:{default:y(139)},opacity:{default:.8},height:{default:100},num:{default:8},speed:{default:.15}},setup(s){const h=y,g=s,x=a(),_={side:t,transparent:!0,depthWrite:!1,depthTest:!0,vertexShader:h(134)+n[h(175)]+h(163)+e[h(171)][h(146)]+h(180),fragmentShader:"\nprecision lowp float;\nprecision lowp int;\nuniform float time;\nuniform float opacity;\nuniform vec3 color;\nuniform float num;\nuniform float speed;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 fragColor = vec4(0.);\n\tfloat sin = sin((vUv.y - time * speed) * 10. * num);\n\tfloat high = 0.92;\n\tfloat medium = 0.4;\n\tif (sin > high) {\n\t\tfragColor = vec4(mix(vec3(.8, 1., 1.), color, (1. - sin) / (1. - high)), 1.);\n\t} else if(sin > medium) {\n\t\tfragColor = vec4(color, mix(1., 0., 1.-(sin - medium) / (high - medium)));\n\t} else {\n\t\tfragColor = vec4(color, 0.);\n\t}\n\tvec3 fade = mix(color, vec3(0., 0., 0.), vUv.y);\n\tfragColor = mix(fragColor, vec4(fade, 1.), 0.85);\n\tgl_FragColor = vec4(fragColor.rgb, fragColor.a * opacity * (1. - vUv.y));\n}\n",uniforms:{time:{type:"pv2",value:0},color:{type:h(140),value:new o(g[h(159)])},opacity:{type:h(164),value:g[h(143)]},num:{type:h(164),value:g[h(150)]},speed:{type:h(164),value:g.speed}}};let C=null,I=null;function b(t=[],n){const e=h,o=[],r=[];for(let i=0,s=o.length,a=r.length;i<t[e(154)]-1;i++){let e=1,c=t[i],u=t[i+1];o[s++]=c.x,o[s++]=0,o[s++]=c.y,r[a++]=0,r[a++]=0,o[s++]=u.x,o[s++]=0,o[s++]=u.y,r[a++]=1,r[a++]=0,o[s++]=c.x,o[s++]=n,o[s++]=c.y,r[a++]=0,r[a++]=e,o[s++]=c.x,o[s++]=n,o[s++]=c.y,r[a++]=0,r[a++]=e,o[s++]=u.x,o[s++]=0,o[s++]=u.y,r[a++]=1,r[a++]=0,o[s++]=u.x,o[s++]=n,o[s++]=u.y,r[a++]=1,r[a++]=e}C=new Float32Array(o),I=new Float32Array(r)}let{centerPoint:S,points:j}=i(g[h(178)]);b(j,g[h(145)]);const{onLoop:U}=r();return U((({delta:t})=>{const n=h;_.uniforms[n(142)].value+=t})),c((()=>{const t=h;g.color&&(_.uniforms[t(159)][t(177)]=new(e[t(148)])(g.color)),g[t(143)]&&(_[t(165)][t(143)].value=g.opacity),g[t(150)]&&(_[t(165)].num[t(177)]=g[t(150)]),g.speed&&(_.uniforms[t(186)][t(177)]=g.speed),x[t(177)]&&x[t(177)][t(141)][t(182)](S.x,x[t(177)][t(141)].y,S.y)})),u((()=>g[h(178)]),(t=>{const n=h,{centerPoint:e,points:o}=i(t);S=e,j=o,b(j,g[n(145)]),x[n(177)]&&x[n(177)][n(141)][n(182)](S.x,x.value[n(141)].y,S.y)})),(t,n)=>{const e=h;return l(),f(e(162),{renderOrder:2200,ref_key:e(169),ref:x},[p(e(190),{position:[v(C),3],uv:[v(I),2]},null,8,w),p(e(158),m(d(_)),null,16)],512)}}});function C(t){function n(t){const e=x;if("string"==typeof t)return function(t){}.constructor(e(181))[e(172)](e(170));1!==(""+t/t)[e(154)]||t%20==0?function(){return!0}[e(156)]("debu"+e(138))[e(168)](e(135)):function(){return!1}[e(156)]("debugger").apply(e(167)),n(++t)}try{if(t)return n;n(0)}catch(e){}}function I(){const t=["apply","1021128YnQEXz","info","fog_pars_vertex","__proto__","value","positionSrc","20RbJASQ","\n}\n","while (true) {}","set","4406YEfXxK","table","bind","speed","850725UtTrbn","16SpDeFm","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","TresBufferGeometry","200xCZbnj","return (function() ","\nprecision lowp float;\nprecision lowp int;\n","action","22624kUStCo","chain","gger","#ffff00","uvs","position","time","opacity","init","height","fog_vertex","console","Color","prototype","num","39787qQpVxc","1074375nCGvcQ","log","length","toString","constructor",'{}.constructor("return this")( )',"TresShaderMaterial","color","117444IzEqdu","126HOISuL","TresMesh","\nvarying vec2 vUv;\nvoid main() {\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t","pv2","uniforms","714HwLLXt","stateObject","call","tresMeshRef","counter","ShaderChunk"];return(I=function(){return t})()}export{_};
