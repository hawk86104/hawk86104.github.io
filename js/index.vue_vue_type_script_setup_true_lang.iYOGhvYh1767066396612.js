import{i as e}from"./3d-tiles-renderer.CbgZh8zU1767066396612.js";import{F as t,v as r,_ as a}from"./@tresjs.B1f7s3pS1767066396612.js";import{f as n}from"./utils.CNife3_q1767066396612.js";import{a1 as i}from"./three.BD1hRFgo1767066396612.js";const{NoBlending:o,ShaderMaterial:l,Uniform:s,Vector2:u,REVISION:h}=await e("three"),p=(()=>Number.parseInt(h.replace(/\D+/g,"")))();class d extends l{constructor(e=new u){super({uniforms:{inputBuffer:new s(null),depthBuffer:new s(null),resolution:new s(new u),texelSize:new s(new u),halfTexelSize:new s(new u),kernel:new s(0),scale:new s(1),cameraNear:new s(0),cameraFar:new s(1),depthEdge0:new s(0),depthEdge1:new s(1),depthScale:new s(0),depthBias:new s(.25)},fragmentShader:`#include <common>\n        #include <dithering_pars_fragment>      \n        uniform sampler2D inputBuffer;\n        uniform sampler2D depthBuffer;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float depthEdge0;\n        uniform float depthEdge1;\n        uniform float depthScale;\n        uniform float depthBias;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          float depthFactor = 0.0;\n          \n          #ifdef USE_DEPTH\n            vec4 depth = texture2D(depthBuffer, vUv);\n            depthFactor = smoothstep(\n              1.0 - depthEdge1, 1.0 - depthEdge0,\n              1.0 - (depth.r * depth.a) + depthBias\n            );\n            depthFactor = clamp(depthScale * depthFactor + 0.25, 0.0, 1.0);\n          #endif\n\n          gl_FragColor = 0.25 * (\n            texture2D(inputBuffer, mix(vUv0, vUv, depthFactor))\n            + texture2D(inputBuffer, mix(vUv1, vUv, depthFactor))\n            + texture2D(inputBuffer, mix(vUv2, vUv, depthFactor))\n            + texture2D(inputBuffer, mix(vUv3, vUv, depthFactor))\n          );\n          \n          #include <dithering_fragment>\n          #include <tonemapping_fragment>\n          #include <${p>=154?"colorspace_fragment":"encodings_fragment"}>\n        }`,vertexShader:"uniform vec2 texelSize;\n        uniform vec2 halfTexelSize;\n        uniform float kernel;\n        uniform float scale;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          vec2 uv = position.xy * 0.5 + 0.5;\n          vUv = uv;\n\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0);\n        }",blending:o,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}const{BufferAttribute:v,BufferGeometry:c,Camera:f,HalfFloatType:m,LinearFilter:x,Mesh:g,Scene:M,Vector2:S,WebGLRenderTarget:_}=await e("three");class w{constructor({resolution:e,width:t=500,height:r=500,depthEdge0:a=0,depthEdge1:n=1,depthScale:i=0,depthBias:o=.25}){this.renderToScreen=!1,this.renderTargetA=new _(e,e,{minFilter:x,magFilter:x,stencilBuffer:!1,depthBuffer:!1,type:m}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new d,this.convolutionMaterial.setTexelSize(1/t,1/r),this.convolutionMaterial.setResolution(new S(t,r)),this.scene=new M,this.camera=new f,this.convolutionMaterial.uniforms.depthEdge0.value=a,this.convolutionMaterial.uniforms.depthEdge1.value=n,this.convolutionMaterial.uniforms.depthScale.value=i,this.convolutionMaterial.uniforms.depthBias.value=o,this.convolutionMaterial.defines.USE_DEPTH=i>0;const l=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),s=new Float32Array([0,0,2,0,0,2]),u=new c;u.setAttribute("position",new v(l,3)),u.setAttribute("uv",new v(s,2)),this.screen=new g(u,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,r){const a=this.scene,n=this.camera,i=this.renderTargetA,o=this.renderTargetB,l=this.convolutionMaterial,s=l.uniforms;s.depthBuffer.value=t.depthTexture;const u=l.kernel;let h,p,d,v=t;for(p=0,d=u.length-1;p<d;++p)h=1&p?o:i,s.kernel.value=u[p],s.inputBuffer.value=v.texture,e.setRenderTarget(h),e.render(a,n),v=h;s.kernel.value=u[p],s.inputBuffer.value=v.texture,e.setRenderTarget(this.renderToScreen?null:r),e.render(a,n)}dispose(){this.screen.material.dispose(),this.screen.geometry.dispose(),this.renderTargetA.dispose(),this.renderTargetB.dispose(),this.convolutionMaterial.dispose()}}const{MeshStandardMaterial:D}=await e("three");class y extends D{constructor(e={}){super(e),this._tDepth={value:null},this._distortionMap={value:null},this._tSharp={value:null},this._tBlur={value:null},this._textureMatrix={value:null},this._mix={value:.5},this._sharpMix={value:0},this._blurMixSmooth={value:0},this._blurMixRough={value:0},this._sharpDepthEdgeMin={value:.9},this._sharpDepthEdgeMax={value:1},this._sharpDepthScale={value:0},this._sharpDepthBias={value:0},this._distortion={value:1},this.setValues(e)}onBeforeCompile(e){e.defines?.USE_UV||(e.defines.USE_UV="");for(const t of Object.keys(e.defines))e.defines[t.toUpperCase()]=e.defines[t];e.uniforms.tSharp=this._tSharp,e.uniforms.tDepth=this._tDepth,e.uniforms.tBlur=this._tBlur,e.uniforms.distortionMap=this._distortionMap,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mixMain=this._mix,e.uniforms.sharpMix=this._sharpMix,e.uniforms.sharpDepthScale=this._sharpDepthScale,e.uniforms.sharpDepthEdgeMin=this._sharpDepthEdgeMin,e.uniforms.sharpDepthEdgeMax=this._sharpDepthEdgeMax,e.uniforms.sharpDepthBias=this._sharpDepthBias,e.uniforms.blurMixSmooth=this._blurMixSmooth,e.uniforms.blurMixRough=this._blurMixRough,e.uniforms.distortion=this._distortion,e.vertexShader=`\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;\n      ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace("#include <project_vertex>","#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );"),e.fragmentShader=`\n        uniform sampler2D tSharp;\n        uniform sampler2D tBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float mixMain;\n        uniform float sharpMix;\n        uniform float blurMixSmooth;\n        uniform float blurMixRough;\n        uniform float sharpDepthScale;\n        uniform float sharpDepthBias;\n        uniform float sharpDepthEdgeMin;\n        uniform float sharpDepthEdgeMax;\n        varying vec4 my_vUv;\n        ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>","#include <emissivemap_fragment>\n\n      vec4 new_vUv = my_vUv;\n\n      #ifdef USE_DISTORTION\n        float distortionFactor = (texture(distortionMap, vUv).r - 0.5) * distortion;\n        new_vUv.x += distortionFactor;\n        new_vUv.y += distortionFactor;\n      #endif\n\n      #ifdef USE_NORMALMAP\n\n        vec4 normalColor = texture(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        vec2 normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n\n        vec4 sharp = texture(tSharp, normal_uv);\n\n        #ifdef USE_BLUR\n          vec4 blur = texture(tBlur, normal_uv);\n        #endif\n\n        #ifdef USE_DEPTH\n          vec4 depth = texture(tDepth, normal_uv);\n        #endif\n\n      #else\n\n        vec4 sharp = textureProj(tSharp, new_vUv);\n\n        #ifdef USE_BLUR\n          vec4 blur = textureProj(tBlur, new_vUv);\n        #endif\n\n        #ifdef USE_DEPTH\n          vec4 depth = textureProj(tDepth, new_vUv);\n        #endif\n\n      #endif\n\n      #ifdef USE_DEPTH\n        float depthFactor = smoothstep(\n          1.0 - sharpDepthEdgeMax, 1.0 - sharpDepthEdgeMin,\n          1.0 - (depth.r * depth.a) + sharpDepthBias\n        );\n        depthFactor = clamp(sharpDepthScale * depthFactor, 0.0, 1.0);\n\n        sharp *= depthFactor;\n      #endif\n\n      sharp *= (1.0 - roughnessFactor);\n      "),e.fragmentShader=e.fragmentShader.replace("#include <opaque_fragment>","\n\n      #ifdef USE_BLUR\n        outgoingLight += mixMain * (\n          vec3(sharp) * sharpMix\n          + vec3(blur) * (blurMixSmooth * (1.0 - roughnessFactor) + blurMixRough * roughnessFactor)\n        );\n      #else\n        outgoingLight += mixMain * vec3(sharp) * sharpMix;\n      #endif\n\n      #include <opaque_fragment>\n      ")}get tSharp(){return this._tSharp.value}set tSharp(e){this._tSharp.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tBlur(){return this._tBlur.value}set tBlur(e){this._tBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get sharpMix(){return this._sharpMix.value}set sharpMix(e){this._sharpMix.value=e}get blurMixSmooth(){return this._blurMixSmooth.value}set blurMixSmooth(e){this._blurMixSmooth.value=e}get blurMixRough(){return this._blurMixRough.value}set blurMixRough(e){this._blurMixRough.value=e}get mix(){return this._mix.value}set mix(e){this._mix.value=e}get sharpDepthScale(){return this._sharpDepthScale.value}set sharpDepthScale(e){this._sharpDepthScale.value=e}get sharpDepthBias(){return this._sharpDepthBias.value}set sharpDepthBias(e){this._sharpDepthBias.value=e}get sharpDepthEdgeMin(){return this._sharpDepthEdgeMin.value}set sharpDepthEdgeMin(e){this._sharpDepthEdgeMin.value=e}get sharpDepthEdgeMax(){return this._sharpDepthEdgeMax.value}set sharpDepthEdgeMax(e){this._sharpDepthEdgeMax.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}}const{defineComponent:U}=await e("vue"),{unref:b,mergeProps:E,openBlock:B,createElementBlock:T}=await e("vue"),P=["texture-matrix","t-sharp","t-depth","t-blur","defines-USE_BLUR","defines-USE_DEPTH","defines-USE_DISTORTION"],{Color:R,DepthTexture:F,Euler:z,HalfFloatType:C,LinearFilter:W,Matrix4:A,PerspectiveCamera:k,Plane:j,TangentSpaceNormalMap:L,Vector2:I,Vector3:V,Vector4:N,WebGLRenderer:O,WebGLRenderTarget:H}=await e("three"),{computed:q,onBeforeUnmount:$,shallowRef:G,toValue:J,watch:K}=await e("vue"),Q=U({__name:"index",props:{resolution:{default:256},mix:{default:1},sharpMix:{default:1},sharpDepthScale:{default:1},sharpDepthBias:{default:0},sharpDepthEdgeMin:{default:0},sharpDepthEdgeMax:{default:.2},blurMixSmooth:{default:1},blurMixRough:{default:1},blurDepthScale:{default:1},blurDepthBias:{default:0},blurDepthEdgeMin:{default:0},blurDepthEdgeMax:{default:.2},blurSize:{default:()=>[0,0]},distortionMap:{},distortion:{default:0},reflectorOffset:{default:0},color:{default:()=>new R(3355443)},roughness:{default:1},metalness:{default:0},map:{},lightMap:{},lightMapIntensity:{default:1},aoMap:{},aoMapIntensity:{default:1},emissive:{default:()=>new R(0)},emissiveIntensity:{default:1},emissiveMap:{},bumpMap:{},bumpScale:{default:1},normalMap:{},normalMapType:{default:L},normalScale:{default:()=>new I(1,1)},displacementMap:{},displacementScale:{default:1},displacementBias:{default:0},roughnessMap:{default:null},metalnessMap:{},alphaMap:{},envMap:{},envMapRotation:{default:()=>new z},envMapIntensity:{default:1},wireframe:{type:Boolean,default:!1},wireframeLinewidth:{default:1},wireframeLinecap:{default:"round"},wireframeLinejoin:{default:"round"},flatShading:{type:Boolean,default:!1},fog:{type:Boolean,default:!0}},setup(e,{expose:o}){const l=e,{extend:s,invalidate:u}=t();s({MeshReflectionMaterial:y});const h=q(()=>500-(Array.isArray(l.blurSize)?l.blurSize[0]:l.blurSize)),p=q(()=>500-(Array.isArray(l.blurSize)?l.blurSize[1]:l.blurSize)),d=q(()=>h.value>0||p.value>0),v=q(()=>l.sharpDepthScale>0||l.blurDepthScale>0),c=q(()=>!!l.distortionMap),f=q(()=>!!l.roughnessMap),m=G();let x;const g={reflectorPlane:new j,normal:new V,reflectorWorldPosition:new V,cameraWorldPosition:new V,rotationMatrix:new A,lookAtPosition:new V(0,0,-1),clipPlane:new N,view:new V,target:new V,q:new N,virtualCamera:new k,textureMatrix:new A},M=new H(l.resolution,l.resolution,{minFilter:W,magFilter:W,type:C,depthBuffer:!0,depthTexture:new F(l.resolution,l.resolution)}),S=new H(l.resolution,l.resolution,{minFilter:W,magFilter:W,type:C});K(()=>[l.resolution],()=>{M.setSize(l.resolution,l.resolution),S.setSize(l.resolution,l.resolution)}),K(()=>[l.resolution,h.value,p.value,l.blurDepthEdgeMin,l.blurDepthEdgeMax,l.blurDepthScale,l.blurDepthBias],()=>{x?.dispose(),x=new w({resolution:l.resolution,width:h.value,height:p.value,depthEdge0:l.blurDepthEdgeMin,depthEdge1:l.blurDepthEdgeMax,depthScale:l.blurDepthScale,depthBias:l.blurDepthBias})},{immediate:!0}),K(()=>[d.value],()=>{r("MeshReflectionMaterial: Setting blurMixRough or blurMixSmooth to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),K(v,()=>{r("MeshReflectionMaterial: Setting depthScale to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),K(c,()=>{r("MeshReflectionMaterial: Toggling distortionMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),K(f,()=>{r("MeshReflectionMaterial: Toggling roughnessMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),K(()=>[l.normalMap],()=>{r("MeshReflectionMaterial: Toggling normalMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),$(()=>{M.dispose(),S.dispose(),x.dispose()});const{onBeforeRender:_}=a();return _(({renderer:e,scene:t,camera:r})=>{const a=m.value?.__tres?.parent;if(a)if(e instanceof i)console.warn("MeshReflectionMaterial: WebGPURenderer is not supported yet");else if(e instanceof O){u();const i=e.xr.enabled,o=e.shadowMap.autoUpdate;if(g.reflectorWorldPosition.setFromMatrixPosition(a.matrixWorld),g.cameraWorldPosition.setFromMatrixPosition(r.value?.matrixWorld),g.rotationMatrix.extractRotation(a.matrixWorld),g.normal.set(0,0,1),g.normal.applyMatrix4(g.rotationMatrix),g.reflectorWorldPosition.addScaledVector(g.normal,l.reflectorOffset),g.view.subVectors(g.reflectorWorldPosition,g.cameraWorldPosition),g.view.dot(g.normal)>0)return;a.visible=!1,g.view.reflect(g.normal).negate(),g.view.add(g.reflectorWorldPosition),g.rotationMatrix.extractRotation(r.value?.matrixWorld),g.lookAtPosition.set(0,0,-1),g.lookAtPosition.applyMatrix4(g.rotationMatrix),g.lookAtPosition.add(g.cameraWorldPosition),g.target.subVectors(g.reflectorWorldPosition,g.lookAtPosition),g.target.reflect(g.normal).negate(),g.target.add(g.reflectorWorldPosition),g.virtualCamera.position.copy(g.view),g.virtualCamera.up.set(0,1,0),g.virtualCamera.up.applyMatrix4(g.rotationMatrix),g.virtualCamera.up.reflect(g.normal),g.virtualCamera.lookAt(g.target),g.virtualCamera.far=r.value.far,g.virtualCamera.updateMatrixWorld(),g.virtualCamera.far=r.value.far,g.virtualCamera.projectionMatrix.copy(r.value.projectionMatrix),g.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),g.textureMatrix.multiply(g.virtualCamera.projectionMatrix),g.textureMatrix.multiply(g.virtualCamera.matrixWorldInverse),g.textureMatrix.multiply(a.matrixWorld),g.reflectorPlane.setFromNormalAndCoplanarPoint(g.normal,g.reflectorWorldPosition),g.reflectorPlane.applyMatrix4(g.virtualCamera.matrixWorldInverse),g.clipPlane.set(g.reflectorPlane.normal.x,g.reflectorPlane.normal.y,g.reflectorPlane.normal.z,g.reflectorPlane.constant);const s=g.virtualCamera.projectionMatrix;g.q.x=(Math.sign(g.clipPlane.x)+s.elements[8])/s.elements[0],g.q.y=(Math.sign(g.clipPlane.y)+s.elements[9])/s.elements[5],g.q.z=-1,g.q.w=(1+s.elements[10])/s.elements[14],g.clipPlane.multiplyScalar(2/g.clipPlane.dot(g.q)),s.elements[2]=g.clipPlane.x,s.elements[6]=g.clipPlane.y,s.elements[10]=g.clipPlane.z+1,s.elements[14]=g.clipPlane.w,e.shadowMap.autoUpdate=!1,e.setRenderTarget(M),e.autoClear||e.clear(),n(J(t)),e.render(J(t),g.virtualCamera),e instanceof O&&x.render(e,M,S),n(J(t),!1),e.xr.enabled=i,e.shadowMap.autoUpdate=o,a.visible=!0,e.setRenderTarget(null),u()}}),o({instance:m}),(e,t)=>(B(),T("TresMeshReflectionMaterial",E({key:`key${d.value?"0":"1"}${v.value?"0":"1"}${c.value?"0":"1"}${f.value?"0":"1"}`,ref_key:"materialRef",ref:m},l,{"texture-matrix":g.textureMatrix,"t-sharp":b(M)?.texture,"t-depth":b(M)?.depthTexture,"t-blur":b(S)?.texture,"defines-USE_BLUR":d.value?"":void 0,"defines-USE_DEPTH":v.value?"":void 0,"defines-USE_DISTORTION":c.value?"":void 0}),null,16,P))}});export{Q as _};
