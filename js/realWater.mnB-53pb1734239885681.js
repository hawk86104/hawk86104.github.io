import{m as n,e,b as t,U as r,c as o}from"./@tresjs.qWeugQU61734239885681.js";import{P as i}from"./tweakpane.yHWGBmom1734239885681.js";import{B as c,a,_ as l,s,aA as u,C as f,t as p,W as v}from"./three.NPKhDGTA1734239885681.js";import{d as g,a6 as d,b as x,o as h,f as m,u as y,g as w,j as b,al as I,r as C,J as R,aj as _,ak as M}from"./@vue.-THQH3GC1734239885681.js";import"./@vueuse.GyFlY0FM1734239885681.js";var z="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const D=T;!function(n,e){const t=T,r=E();for(;;)try{if(145839===-parseInt(t(308))/1+parseInt(t(295))/2*(parseInt(t(323))/3)+parseInt(t(297))/4*(parseInt(t(315))/5)+parseInt(t(290))/6*(-parseInt(t(312))/7)+-parseInt(t(325))/8*(parseInt(t(286))/9)+parseInt(t(318))/10+parseInt(t(293))/11*(-parseInt(t(296))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[T(330)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){A(this,(function(){const n=T,e=new RegExp(n(303)),t=new RegExp(n(320),"i"),r=F("init");e[n(328)](r+n(285))&&t[n(328)](r+n(309))?F():r("0")}))()}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[T(330)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function T(n,e){const t=E();return(T=function(n,e){return t[n-=280]})(n,e)}L(void 0,(function(){const n=T;let e;try{e=Function(n(310)+n(283)+");")()}catch(o){e=window}const t=e[n(314)]=e[n(314)]||{},r=[n(291),n(298),n(329),n(327),n(317),n(288),"trace"];for(let i=0;i<r.length;i++){const e=L[n(313)].prototype.bind(L),o=r[i],c=t[o]||e;e[n(284)]=L.bind(L),e[n(299)]=c[n(299)][n(321)](c),t[o]=e}}))();const O=g({__name:D(280),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=D,o=t,i=new c,u=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),f=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(300)]("position",new a(u,3)),i[r(281)](new(l[r(304)])(f,1));const p=new(l[r(326)])({uniforms:{light:{value:o[r(322)]},tiles:{value:o.tiles},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:l[r(307)]}),v=new s(i,p),{renderer:g,camera:d}=n(),{onAfterLoop:x}=e();return x((()=>{const n=r;((n,e)=>{const t=r;p[t(302)].water[t(306)]=n,p[t(302)][t(319)][t(306)]=e,g[t(306)][t(324)](v,d.value)})(o[n(294)],o[n(305)])})),(n,e)=>null}});function F(n){function e(n){const t=T;if(typeof n===t(316))return function(n){}[t(313)](t(282))[t(330)]("counter");1!==(""+n/n)[t(289)]||n%20==0?function(){return!0}.constructor(t(292)+t(331))[t(287)](t(311)):function(){return!1}[t(313)]("debu"+t(331))[t(330)](t(301)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function E(){const n=["value","FrontSide","77566HUFJeL","input","return (function() ","action","178773VPTCRN","constructor","console","955WXvnlx","string","exception","2896910RVWpwx","causticTex","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","bind","light","458478nVOeZD","render","400qKGSEC","RawShaderMaterial","error","test","info","apply","gger","pool","setIndex","while (true) {}",'{}.constructor("return this")( )',"__proto__","chain","27396XQRnZz","call","table","length","24lHPbtp","log","debu","11hbGKnL","waterTexture","2GLqVAe","2228916smDiym","4628MssEcQ","warn","toString","setAttribute","stateObject","uniforms","function *\\( *\\)","BufferAttribute","causticsTexture"];return(E=function(){return n})()}function S(n,e){const t=V();return(S=function(n,e){return t[n-=138]})(n,e)}const j=S;!function(n,e){const t=S,r=V();for(;;)try{if(721305===-parseInt(t(168))/1+-parseInt(t(171))/2*(-parseInt(t(141))/3)+-parseInt(t(138))/4*(parseInt(t(139))/5)+-parseInt(t(174))/6+parseInt(t(192))/7+parseInt(t(195))/8*(parseInt(t(161))/9)+parseInt(t(160))/10*(parseInt(t(162))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[S(146)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){W(this,(function(){const n=S,e=new RegExp(n(201)),t=new RegExp(n(169),"i"),r=k(n(159));e[n(173)](r+"chain")&&t[n(173)](r+n(177))?k():r("0")}))()}();const P=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[S(146)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function V(){const n=["setRenderTarget","trace","console","causticTex","stateObject","info","8863631iumohI","render","toString","18064vuJkbP","water","load","neg-x.jpg","call","neg-z.jpg","function *\\( *\\)","__proto__","log","4WPpbyM","6576610UThvvN","pos-z.jpg","7041bvEtWr","action","while (true) {}","pos-x.jpg","side","apply","value","counter","BackSide","setPath","neg-y.jpg","CubeTextureLoader","length","prototype","bind","uniforms","underwater","string","init","5162930vOtMOQ","2502QxJTPY","44mitBEg","pos-y.jpg","gger","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/",'{}.constructor("return this")( )',"waterTexture","1255648nWeyhl","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","error","346jywBri","exception","test","6437310FNVlRD","geometry","Mesh","input","FrontSide","tiles","pooRef","constructor","white","causticsTexture","debu","light"];return(V=function(){return n})()}P(void 0,(function(){const n=S;let e;try{e=Function("return (function() "+n(166)+");")()}catch(o){e=window}const t=e[n(188)]=e[n(188)]||{},r=[n(203),"warn",n(191),n(170),n(172),"table",n(187)];for(let i=0;i<r[n(153)];i++){const e=P.constructor[n(154)][n(155)](P),o=r[i],c=t[o]||e;e[n(202)]=P.bind(P),e[n(194)]=c.toString[n(155)](c),t[o]=e}}))();const H=g({__name:j(196),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=j;let i,c;const a=r,s=a[o(175)],p=(new(l[o(152)]))[o(150)](o(165))[o(197)]([o(144),o(198),o(163),o(151),o(140),o(200)]),v=([i,c]=d((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,c(),i),g=new u({uniforms:{light:{value:a[o(185)]},tiles:{value:v},sky:{value:p},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),w=new(l[o(176)])(s,g),b=x(null),I=new f(o(182)),{renderer:C,camera:R}=n(),{onLoop:_}=e();return _((()=>{const n=o;C[n(147)][n(186)](null),C[n(147)].setClearColor(I,1),C[n(147)].clear(),g[n(156)].water[n(147)]=a[n(167)],g[n(156)][n(189)][n(147)]=a[n(183)],g[n(145)]=l[n(178)],g[n(156)][n(157)][n(147)]=!0,C[n(147)][n(193)](w,R[n(147)]),g.side=l[n(149)],g[n(156)].underwater[n(147)]=!1,C[n(147)][n(193)](w,R[n(147)])})),(n,e)=>{const t=o;return h(),m(O,{tiles:y(v),light:n.light,waterTexture:n.waterTexture,causticsTexture:n[t(183)],ref_key:t(180),ref:b},null,8,[t(179),"light",t(167),t(183)])}}});function k(n){function e(n){const t=S;if(typeof n===t(158))return function(n){}.constructor(t(143))[t(146)](t(148));1!==(""+n/n)[t(153)]||n%20==0?function(){return!0}[t(181)](t(184)+"gger")[t(199)](t(142)):function(){return!1}[t(181)](t(184)+t(164))[t(146)](t(190)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const Z=J;!function(n,e){const t=J,r=N();for(;;)try{if(607275===parseInt(t(458))/1+-parseInt(t(469))/2*(parseInt(t(472))/3)+parseInt(t(462))/4*(parseInt(t(493))/5)+-parseInt(t(485))/6+parseInt(t(498))/7+-parseInt(t(446))/8*(-parseInt(t(474))/9)+-parseInt(t(473))/10*(parseInt(t(444))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function N(){const n=["exception","479922MSAvlU","uniforms","call","table","black","toString","waterTexture","ShaderMaterial","3761610hhLnrB","function *\\( *\\)","OrthographicCamera","causticsTexture","error","1065589YvohIY","setRenderTarget","console","trace","663190Udtyml","light","3408phmUcU","water","counter","__proto__","length","init","caustics","warn","action","log","Mesh","info","135761MZColX","prototype","input","texture","4BoJVAf","chain","gger","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)",'{}.constructor("return this")( )',"value","apply","31498NrtsZx","return (function() ","test","60IiSyDk","140RVRfzQ","17028qEcQmI","clear","geometry","stateObject","bind","constructor","string","material","while (true) {}","debu"];return(N=function(){return n})()}!function(){B(this,(function(){const n=J,e=new RegExp(n(494)),t=new RegExp(n(465),"i"),r=$(n(451));e[n(471)](r+n(463))&&t[n(471)](r+n(460))?$():r("0")}))()}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[J(468)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function J(n,e){const t=N();return(J=function(n,e){return t[n-=444]})(n,e)}U(void 0,(function(){const n=J,e=function(){const n=J;let e;try{e=Function(n(470)+n(466)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(500)]||{},r=[n(455),n(453),n(457),n(497),n(484),n(488),n(501)];for(let o=0;o<r[n(450)];o++){const e=U[n(479)][n(459)][n(478)](U),i=r[o],c=t[i]||e;e[n(449)]=U[n(478)](U),e[n(490)]=c[n(490)].bind(c),t[i]=e}}))();const Q=g({__name:Z(452),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=Z,o=t,i=new(l[r(495)])(0,1,1,0,0,2e3),c=new p(2,2,200,200),a=new v(1024,1024),s=new(l[r(492)])({uniforms:{light:{value:o.light},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),u=new(l[r(456)])(c,s),g=new f(r(489)),{renderer:d}=n(),{onBeforeLoop:x}=e();return x((()=>{const n=r;u[n(481)][n(486)][n(447)][n(467)]=o[n(491)],d[n(467)][n(499)](a),d.value.setClearColor(g,0),d[n(467)][n(475)](),d[n(467)].render(u,i)})),(n,e)=>{const t=r;return h(),m(I,null,{default:w((()=>[b(H,{waterTexture:n[t(491)],causticsTexture:y(a)[t(461)],light:n[t(445)],geometry:y(c)},null,8,[t(491),t(496),t(445),t(476)])])),_:1})}}});function $(n){function e(n){const t=J;if(typeof n===t(480))return function(n){}[t(479)](t(482)).apply(t(448));1!==(""+n/n).length||n%20==0?function(){return!0}[t(479)](t(483)+t(464))[t(487)](t(454)):function(){return!1}[t(479)](t(483)+t(464))[t(468)](t(477)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const G=K;!function(n,e){const t=K,r=Y();for(;;)try{if(211580===-parseInt(t(219))/1*(parseInt(t(252))/2)+-parseInt(t(233))/3+parseInt(t(246))/4*(-parseInt(t(210))/5)+parseInt(t(238))/6+-parseInt(t(193))/7*(-parseInt(t(235))/8)+-parseInt(t(189))/9+parseInt(t(218))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const X=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Y(){const n=["gger","trace","Mesh","113660DXOYXL","waterTexture","debu","mousemove","input","position","init","lightFrontGeometry","12474510HjJZtB","1AXojhF","removeEventListener","left","counter","test","point","OrthographicCamera","center","Vector2","addEventListener","count","PlaneGeometry","height","uniforms","1035522zJDWZh","attributes","56LunEvC","domElement","waterSimulation","113622HHsvIC","toString","getBoundingClientRect","return (function() ","setFromCamera","render","texture","needsUpdate","48wYeqwY","RawShaderMaterial","radius",'{}.constructor("return this")( )',"strength","apply","775204PpjasQ","exception","clientX","WebGLRenderTarget","action","bind","FloatType","1496655uhCXeF","autoClear","top","material","117047VLgGHI","value","chain","log","clientY","light","while (true) {}","length","stateObject","prototype","constructor","console","warn","table"];return(Y=function(){return n})()}!function(){X(this,(function(){const n=K,e=new RegExp("function *\\( *\\)"),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=en(n(216));e[n(223)](r+n(195))&&t.test(r+n(214))?en():r("0")}))()}();const q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[K(251)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function K(n,e){const t=Y();return(K=function(n,e){return t[n-=184]})(n,e)}q(void 0,(function(){const n=K,e=function(){const n=K;let e;try{e=Function(n(241)+n(249)+");")()}catch(t){e=window}return e}(),t=e[n(204)]=e[n(204)]||{},r=[n(196),n(205),"info","error",n(253),n(206),n(208)];for(let o=0;o<r[n(200)];o++){const e=q[n(203)][n(202)][n(187)](q),i=r[o],c=t[i]||e;e.__proto__=q[n(187)](q),e.toString=c[n(239)][n(187)](c),t[i]=e}}))();const nn=g({__name:G(237),props:{light:{}},setup(t,{expose:r}){const o=G,i=new(l[o(225)])(0,1,1,0,0,2e3),c=new p(2,2),a=new(l[o(185)])(256,256,{type:l[o(188)]}),s=new(l[o(185)])(256,256,{type:l[o(188)]}),f=new(l[o(247)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),v=new u({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),g=new(l[o(247)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),d=new(l[o(209)])(c,f),x=new(l[o(209)])(c,v),w=new(l[o(209)])(c,g);let b=a;const I=(n,e)=>{const t=o,r=b,c=b===a?s:a;e[t(192)][t(232)].texture[t(194)]=r[t(244)],n.setRenderTarget(c),n[t(243)](e,i),b=c},{renderer:C,camera:R,raycaster:_}=n();C[o(194)][o(190)]=!1;const{onBeforeLoop:M}=e();M((()=>{const n=o;var e,t;t=C[n(194)],I(t,w),e=C[n(194)],I(e,x)}));const D=(n,e,t,r)=>{const i=o;d.material[i(232)][i(226)][i(194)]=[n,e],d.material.uniforms[i(248)][i(194)]=t,d[i(192)][i(232)][i(250)][i(194)]=r,I(C[i(194)],d)},A=new(l[o(227)]),L=new(l[o(230)])(2,2),T=L[o(234)][o(215)];for(let n=0;n<T[o(229)];n++){const e=-T.getY(n);T.setY(n,0),T.setZ(n,e)}T[o(245)]=!0;const O=new(l[o(209)])(L),F={handleEvent:n=>{const e=o,t=C.value.domElement[e(240)](),r=t.width,i=t[e(231)];A.x=2*(n[e(184)]-t[e(221)])/r-1,A.y=2*-(n[e(197)]-t[e(191)])/i+1,_.value[e(242)](A,R[e(194)]);const c=_[e(194)].intersectObject(O);for(let o of c)D(o[e(224)].x,o[e(224)].z,.03,.04)}};return r({addDrop:D,mouseEvent:n=>{const e=o;n?C.value.domElement[e(228)](e(213),F):C[e(194)][e(236)][e(220)](e(213),F)}}),(n,e)=>{const t=o;return h(),m(Q,{lightFrontGeometry:y(c),waterTexture:y(b)[t(244)],light:n[t(198)]},null,8,[t(217),t(211),t(198)])}}});function en(n){function e(n){const t=K;if("string"==typeof n)return function(n){}[t(203)](t(199))[t(251)](t(222));1!==(""+n/n)[t(200)]||n%20==0?function(){return!0}.constructor(t(212)+t(207)).call(t(186)):function(){return!1}[t(203)]("debu"+t(207))[t(251)](t(201)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const tn=cn;!function(n,e){const t=cn,r=an();for(;;)try{if(460480===-parseInt(t(501))/1*(-parseInt(t(509))/2)+-parseInt(t(494))/3+parseInt(t(481))/4*(parseInt(t(519))/5)+-parseInt(t(522))/6*(-parseInt(t(499))/7)+parseInt(t(528))/8+-parseInt(t(498))/9*(parseInt(t(496))/10)+-parseInt(t(523))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[cn(497)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){rn(this,(function(){const n=cn,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(485),"i"),r=sn(n(513));e[n(503)](r+n(525))&&t[n(503)](r+n(515))?sn():r("0")}))()}();const on=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[cn(497)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function cn(n,e){const t=an();return(cn=function(n,e){return t[n-=481]})(n,e)}function an(){const n=["chain","鼠标波纹","gger","4649800spAfzJ","668rIlrXW","counter","log","click","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","while (true) {}","change","realWater","mouseEvent","prototype","点击按钮","debu","table","1382220BDUBfg","constructor","950sgJZkk","apply","55314afgtAc","9604CCZPZQ","TresPerspectiveCamera","851606zbBkUQ","info","test","error","bind","action","exception","random","2JclFHc","manual","warn","toString","init","console","input","waterSimulationRef","__proto__","value","26155bFcQyN","return (function() ","length","24AZOaVE","8874866fwaLUV","addDrop"];return(an=function(){return n})()}on(void 0,(function(){const n=cn,e=function(){const n=cn;let e;try{e=Function(n(520)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(514)]=e.console||{},r=[n(483),n(511),n(502),n(504),n(507),n(493),"trace"];for(let o=0;o<r[n(521)];o++){const e=on[n(495)][n(490)][n(505)](on),i=r[o],c=t[i]||e;e[n(517)]=on[n(505)](on),e.toString=c[n(512)].bind(c),t[i]=e}}))();const ln=g({__name:tn(488),setup(n){const e=tn,t=C({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(510)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=x(null),l=new i;l.addButton({label:e(491),title:"随机增加波纹"}).on(e(484),(()=>{const n=e;for(var t=0;t<10;t++)a[n(518)][n(524)](2*Math[n(508)]()-1,2*Math[n(508)]()-1,.03,1&t?.02:-.02)}));const s=x(!1);return l.addBinding(s,e(518),{label:e(526)}).on(e(487),(n=>{const t=e;a[t(518)][t(489)](n[t(518)])})),(n,i)=>{const l=e;return h(),m(y(o),_(M(t)),{default:w((()=>[i[0]||(i[0]=R(l(500),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),b(y(r)),b(nn,{light:c,ref_key:l(516),ref:a},null,512)])),_:1},16)}}});function sn(n){function e(n){const t=cn;if("string"==typeof n)return function(n){}[t(495)](t(486))[t(497)](t(482));1!==(""+n/n).length||n%20==0?function(){return!0}[t(495)](t(492)+t(527)).call(t(506)):function(){return!1}[t(495)](t(492)+t(527))[t(497)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{ln as default};
