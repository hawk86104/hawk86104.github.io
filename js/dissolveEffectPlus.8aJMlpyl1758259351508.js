import{h as e,m as t,e as n,b as a,a as o}from"./@tresjs.CywMBpUh1758259351508.js";import"./lamina.7xwNePoj1758259351508.js";import{_ as r}from"./skyBoxDmesh.vue_vue_type_script_setup_true_lang.zI7k7VbZ1758259351508.js";import{P as s}from"./tweakpane.C0HtAJSg1758259351508.js";import{d as i,w as l,e as u,o as c,u as d,aa as v,G as p,I as m,j as g,m as x,a5 as f,f as y,a2 as w,r as P,h,a7 as A,a8 as b}from"./@vue.pEDXJ_3Z1758259351508.js";import{aE as z,C,a3 as D,B as _,bV as F,c as E,V as M,cO as j,cr as S,cs as q,a as B,ct as k,Y as T}from"./three.CtgP63ME1758259351508.js";import"./postprocessing.DJgHFhS91758259351508.js";import"./@vueuse.C5HLo59K1758259351508.js";import"./glsl-tokenizer.BMVmBPoE1758259351508.js";import"./@amap.CGUF9xH41758259351508.js";import"./glsl-token-descope.4V2_7q6C1758259351508.js";import"./glsl-token-depth.Duvdnvlt1758259351508.js";import"./glsl-token-scope.BdCfdvWe1758259351508.js";import"./glsl-token-properties.DKXemF9b1758259351508.js";import"./glsl-token-assignments.Ctx_yUgS1758259351508.js";import"./glsl-token-string.BBIN0iOh1758259351508.js";import"./glsl-token-functions.7xgp6R6C1758259351508.js";var N="vec4 permute(vec4 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    \n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    \n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    \n    i = mod(i, 289.0);\n    vec4 p = permute(permute(permute(\n                    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    \n    \n    float n_ = 1.0 / 7.0; \n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); \n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_); \n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    \n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    \n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\n                dot(p2, x2), dot(p3, x3)));\n}";const K=i({__name:"material",props:{baseMaterial:{default:new z},uEdgeColor:{default:"#4d9bff"},uEdge:{default:6},uFreq:{default:.41},uAmp:{default:20},uProgress:{default:-2}},setup(t){const n=t,a={uEdgeColor:{value:new C(n.uEdgeColor)},uFreq:{value:n.uFreq},uAmp:{value:n.uAmp},uProgress:{value:n.uProgress},uEdge:{value:n.uEdge}},o=`\n  varying vec3 vPos;\n\n  uniform float uFreq;\n  uniform float uAmp;\n  uniform float uProgress;\n  uniform float uEdge;\n  uniform vec3 uEdgeColor;\n\n  ${N}\n\n\tvoid main() {\n\t\tfloat noise = snoise(vPos * uFreq) * uAmp; // calculate snoise in fragment shader for smooth dissolve edges\n\n    if(noise < uProgress) discard; // discard any fragment where noise is lower than progress\n\n    float edgeWidth = uProgress + uEdge;\n\n    if(noise > uProgress && noise < edgeWidth){\n        csm_DiffuseColor = vec4(vec3(uEdgeColor),noise); // colors the edge\n    }else{\n\t\t\t\tcsm_DiffuseColor = vec4(csm_DiffuseColor.xyz,1.0);\n\t\t}\n\t}\n`;return l((()=>[n.uEdgeColor,n.uEdge,n.uFreq,n.uAmp,n.uProgress]),(([e,t,n,o,r])=>{a.uEdgeColor.value.setStyle(e),a.uEdge.value=t,a.uFreq.value=n,a.uAmp.value=o,a.uProgress.value=r})),(n,r)=>(c(),u(d(e),{baseMaterial:t.baseMaterial,vertexShader:"\n\tvarying vec3 vPos;\n\tvoid main() {\n\t\tvPos = position;\n\t}\n",side:D,fragmentShader:o,uniforms:a},null,8,["baseMaterial","side"]))}}),$=["geometry"],I=["blending"],V=i({__name:"particlesPoints",props:{geo:{default:new _},uEdge:{default:6},uFreq:{default:.41},uAmp:{default:20},uProgress:{default:-2},uColor:{default:"#4d9bff"},uPointSize:{default:200},particleData:{default:{particleSpeedFactor:.02,velocityFactor:{x:2.5,y:2},waveAmplitude:0}}},async setup(e){let o,r;const s=e,i=s.geo.clone(),u=([o,r]=v((()=>a(["./plugins/industry4/image/particle.png"]))),o=await o,r(),o);let g,x,f,y,w,P,h=i.attributes.position.count;!function(e){h=e.attributes.position.count,g=new Float32Array(h),x=new Float32Array(e.getAttribute("position").array),f=new Float32Array(e.getAttribute("position").array),y=new Float32Array(3*h),w=new Float32Array(h),P=new Float32Array(h);for(let t=0;t<h;t++){let e=3*t+0,n=3*t+1,a=3*t+2;g[t]=5.5*Math.random()+1.5,y[e]=.5*Math.random()+.5,y[n]=.5*Math.random()+.5,y[a]=.1*Math.random(),w[t]=.001,P[t]=Math.random()*Math.PI*2}e.setAttribute("aOffset",new E(g,1)),e.setAttribute("aCurrentPos",new E(f,3)),e.setAttribute("aVelocity",new E(y,3)),e.setAttribute("aDist",new E(w,1)),e.setAttribute("aAngle",new E(P,1))}(i);const{renderer:A}=t(),b={uTexture:{value:u},uPixelDensity:{value:A.value.getPixelRatio()},uProgress:{value:s.uProgress},uEdge:{value:s.uEdge},uAmp:{value:s.uAmp},uFreq:{value:s.uFreq},uBaseSize:{value:s.uPointSize},uColor:{value:new C(s.uColor)}},z=`\n    ${N}\n    uniform float uPixelDensity;\n    uniform float uBaseSize;\n    uniform float uFreq;\n    uniform float uAmp;\n    uniform float uEdge;\n    uniform float uProgress;\n\n    varying float vNoise;\n    varying float vAngle;\n\n    attribute vec3 aCurrentPos;\n    attribute float aDist;\n    attribute float aAngle;\n\n    void main() {\n        vec3 pos = position;\n\n        float noise = snoise(pos * uFreq) * uAmp;\n        vNoise =noise;\n\n        vAngle = aAngle;\n\n        if( vNoise > uProgress-2.0 && vNoise < uProgress + uEdge+2.0){\n            pos = aCurrentPos;\n        }\n\n        vec4 modelPosition = modelMatrix * vec4(pos, 1.0);\n        vec4 viewPosition = viewMatrix * modelPosition;\n        vec4 projectedPosition = projectionMatrix * viewPosition;\n        gl_Position = projectedPosition;\n\n        float size = uBaseSize * uPixelDensity;\n        size = size  / (aDist + 1.0);\n        gl_PointSize = size / -viewPosition.z;\n}\n`;function D(e){let t=y[3*e+0],n=y[3*e+1],a=y[3*e+2];t*=s.particleData.velocityFactor.x,n*=s.particleData.velocityFactor.y;let{xwave:o,ywave:r}=function(e){const t=f[3*e+0],n=f[3*e+1];let a=Math.sin(2*n)*(.8+s.particleData.waveAmplitude),o=Math.sin(2*t)*(.6+s.particleData.waveAmplitude),r=Math.sin(5*n)*(.2+s.particleData.waveAmplitude),i=Math.sin(1*t)*(.9+s.particleData.waveAmplitude),l=Math.sin(8*n)*(.8+s.particleData.waveAmplitude),u=Math.sin(5*t)*(.6+s.particleData.waveAmplitude);return{xwave:a+r+l+Math.sin(3*n)*(.8+s.particleData.waveAmplitude),ywave:o+i+u+Math.sin(7*t)*(.6+s.particleData.waveAmplitude)}}(e);return t+=o,n+=r,t*=Math.abs(s.particleData.particleSpeedFactor),n*=Math.abs(s.particleData.particleSpeedFactor),a*=Math.abs(s.particleData.particleSpeedFactor),{vx:t,vy:n,vz:a}}const{onLoop:_}=n();return _((()=>{!function(){for(let e=0;e<h;e++){let t=3*e+0,n=3*e+1,a=3*e+2,{vx:o,vy:r,vz:s}=D(e);f[t]+=o,f[n]+=r,f[a]+=s;const i=new M(x[t],x[n],x[a]),l=new M(f[t],f[n],f[a]),u=i.distanceTo(l);w[e]=u,P[e]+=.01,u>g[e]&&(f[t]=x[t],f[n]=x[n],f[a]=x[a])}i.setAttribute("aOffset",new E(g,1)),i.setAttribute("aCurrentPos",new E(f,3)),i.setAttribute("aVelocity",new E(y,3)),i.setAttribute("aDist",new E(w,1)),i.setAttribute("aAngle",new E(P,1))}()})),l((()=>[s.uColor,s.uEdge,s.uFreq,s.uAmp,s.uProgress,s.uPointSize]),(([e,t,n,a,o,r])=>{b.uColor.value.setStyle(e),b.uEdge.value=t,b.uFreq.value=n,b.uAmp.value=a,b.uProgress.value=o,b.uBaseSize.value=r})),(e,t)=>(c(),p("TresPoints",{geometry:d(i)},[m("TresShaderMaterial",{transparent:"",blending:F,uniforms:b,vertexShader:z,fragmentShader:"\n    uniform vec3 uColor;\n    uniform float uEdge;\n    uniform float uProgress;\n    uniform sampler2D uTexture;\n\n    varying float vNoise;\n    varying float vAngle;\n\n    void main(){\n        if( vNoise < uProgress ) discard;\n        if( vNoise > uProgress + uEdge) discard;\n\n        vec2 coord = gl_PointCoord;\n        coord = coord - 0.5; // get the coordinate from 0-1 ot -0.5 to 0.5\n        coord = coord * mat2(cos(vAngle),sin(vAngle) , -sin(vAngle), cos(vAngle)); // apply the rotation transformaion\n        coord = coord +  0.5; // reset the coordinate to 0-1  \n\n        vec4 texture = texture2D(uTexture,coord);\n\n        gl_FragColor = vec4(vec3(uColor.xyz * texture.xyz),1.0);\n    }\n"},null,8,I)],8,$))}}),O=["geometry"],G=i({__name:"torusKnot",setup(e){const t=new j(3,1,64,8,2,3);return(e,n)=>(c(),p("TresGroup",null,[m("TresMesh",{geometry:d(t)},[g(K,x({color:"#636363",metalness:2,roughness:0},e.$attrs),null,16)],8,O),(c(),u(f,null,{default:y((()=>[g(V,x({geo:d(t)},e.$attrs,{uColor:e.$attrs.uEdgeColor}),null,16,["geo","uColor"])])),_:1}))]))}}),L=i({__name:"bloomPass",setup(e){const{camera:a,renderer:o,scene:r,sizes:s}=t(),i=0,l=.216,u=.2;let c=null;w((()=>{s.width.value&&((e,t,n,a,o)=>{const r=new S(e,t),s=new q(new B(a,o),l,u,i);c=new k(n),c.addPass(r),c.addPass(s)})(r.value,a.value,o.value,s.width.value,s.height.value)}));const{onLoop:d}=n();return d((()=>{c&&c.render()})),(e,t)=>null}}),W=i({__name:"dissolveEffectPlus",setup(e){const t={clearColor:"#201919",windowSize:!0,toneMapping:T,toneMappingExposure:.8,renderMode:"manual"},n=P({uEdgeColor:"#ff784d",uEdge:6,uFreq:.41,uAmp:20,uProgress:-4.9,uPointSize:576,particleData:{particleSpeedFactor:.02,velocityFactor:{x:2.5,y:2},waveAmplitude:0}}),a=P({torusKnotColor:"#7a8c87"}),i=new s({title:"参数",expanded:!0});return i.addBinding(a,"torusKnotColor",{label:"torusKnotColor"}),i.addBinding(n,"uEdgeColor",{label:"边缘颜色"}),i.addBinding(n,"uEdge",{label:"边缘宽度",min:0,max:9,step:.01}),i.addBinding(n,"uFreq",{label:"密度",min:.002,max:2,step:.002}),i.addBinding(n,"uAmp",{label:"幅度",min:3,max:22,step:.01}),i.addBinding(n,"uProgress",{label:"进度",min:-25,max:20,step:.1}),i.addBinding(n,"uPointSize",{label:"粒子大小",min:10,max:800,step:5}),i.addBinding(n.particleData,"particleSpeedFactor",{label:"粒子速度",min:1e-4,max:.1,step:1e-4}),i.addBinding(n.particleData,"velocityFactor",{picker:"inline",label:"粒子飘逸方向",expanded:!0,x:{min:-10,max:10,step:.01},y:{min:-10,max:10,step:.01}}),i.addBinding(n.particleData,"waveAmplitude",{label:"粒子扰动幅度",min:0,max:5,step:.01}),(e,s)=>{const i=h("TresCanvas");return c(),u(i,A(b(t)),{default:y((()=>[s[0]||(s[0]=m("TresPerspectiveCamera",{position:[15,15,15],fov:45,near:.1,far:1e4,"look-at":[0,0,0]},null,-1)),g(d(o),{enableDamping:""}),g(G,x(n,{color:a.torusKnotColor}),null,16,["color"]),(c(),u(f,null,{default:y((()=>[g(d(r),{texture:"https://opensource.cdn.icegl.cn/images/skyBox/workshop_blur.jpg"},null,8,["texture"])])),_:1})),g(L)])),_:1},16)}}});export{W as default};
