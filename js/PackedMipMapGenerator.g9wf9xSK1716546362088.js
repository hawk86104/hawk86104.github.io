var V=Object.defineProperty;var g=Object.getOwnPropertySymbols;var I=Object.prototype.hasOwnProperty,C=Object.prototype.propertyIsEnumerable;var d=(t,e,a)=>e in t?V(t,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[e]=a,h=(t,e)=>{for(var a in e||(e={}))I.call(e,a)&&d(t,a,e[a]);if(g)for(var a of g(e))C.call(e,a)&&d(t,a,e[a]);return t};import{aG as N,bw as O,aw as H,aH as z,bj as G,az as F,ax as v,aB as R,aC as y,aT as _}from"./vendor.LnRgd2r_1716546362088.js";var X=Object.defineProperty,Y=(t,e,a)=>e in t?X(t,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[e]=a,P=(t,e,a)=>(Y(t,typeof e!="symbol"?e+"":e,a),a);class M{constructor(e){P(this,"camera",new N(-1,1,1,-1,0,1)),P(this,"geometry",new O(2,2)),P(this,"mesh"),this.mesh=new H(this.geometry,e)}get material(){return this.mesh.material}set material(e){this.mesh.material=e}dispose(){this.mesh.geometry.dispose()}render(e){e.render(this.mesh,this.camera)}}const W={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","	vUv = uv;","	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","	vec4 texel = texture2D( tDiffuse, vUv );","	gl_FragColor = opacity * texel;","}"].join("\n")},Q='\n\n	// Without original size argument for power of two targets\n	vec4 packedTexture2DLOD( sampler2D tex, vec2 uv, int level ) {\n\n		// the fraction of the uv space used by the target mip\n		float targetSubview = 1.0 / pow( 2.0, float( level ) );\n		float widthRatio = 2.0 / 3.0;\n		vec2 scaledDimensions = vec2( targetSubview * widthRatio, targetSubview );\n\n		// all levels > 0 are on the right third of the texture\n		// y is offset from the bottom\n		vec2 offset = vec2(\n			level > 0 ? widthRatio : 0.0,\n			level > 0 ? targetSubview : 0.0\n		);\n\n		vec2 samplePoint = mix( offset, offset + scaledDimensions, uv );\n		return texture2D( tex, samplePoint );\n\n	}\n\n	vec4 packedTexture2DLOD( sampler2D tex, vec2 uv, float level ) {\n\n		float ratio = mod( level, 1.0 );\n		int minLevel = int( floor( level ) );\n		int maxLevel = int( ceil( level ) );\n\n		vec4 minValue = packedTexture2DLOD( tex, uv, minLevel );\n		vec4 maxValue = packedTexture2DLOD( tex, uv, maxLevel );\n\n		return mix( minValue, maxValue, ratio );\n\n	}\n\n	// With original size argument\n	vec4 packedTexture2DLOD( sampler2D tex, vec2 uv, int level, vec2 originalPixelSize ) {\n\n		float floatLevel = float( level );\n		vec2 atlasSize;\n		atlasSize.x = floor( originalPixelSize.x * 1.5 );\n		atlasSize.y = originalPixelSize.y;\n\n		// we stop making mip maps when one dimension == 1\n		float maxLevel = min( floor( log2( originalPixelSize.x ) ), floor( log2( originalPixelSize.y ) ) );\n		floatLevel = min( floatLevel, maxLevel );\n\n		// use inverse pow of 2 to simulate right bit shift operator\n		vec2 currentPixelDimensions = floor( originalPixelSize / pow( 2.0, floatLevel ) );\n		vec2 pixelOffset = vec2(\n			floatLevel > 0.0 ? originalPixelSize.x : 0.0,\n			floatLevel > 0.0 ? currentPixelDimensions.y : 0.0\n		);\n\n		// "minPixel / atlasSize" samples the top left piece of the first pixel\n		// "maxPixel / atlasSize" samples the bottom right piece of the last pixel\n		vec2 minPixel = pixelOffset;\n		vec2 maxPixel = pixelOffset + currentPixelDimensions;\n		vec2 samplePoint = mix( minPixel, maxPixel, uv );\n		samplePoint /= atlasSize;\n\n		vec2 halfPixelSize = 1.0 / ( 2.0 * atlasSize );\n		samplePoint = min( samplePoint, maxPixel / atlasSize - halfPixelSize );\n		samplePoint = max( samplePoint, minPixel / atlasSize + halfPixelSize );\n\n		return texture2D( tex, samplePoint );\n\n	}\n\n	vec4 packedTexture2DLOD( sampler2D tex, vec2 uv, float level, vec2 originalPixelSize ) {\n\n		float ratio = mod( level, 1.0 );\n		int minLevel = int( floor( level ) );\n		int maxLevel = int( ceil( level ) );\n\n		vec4 minValue = packedTexture2DLOD( tex, uv, minLevel, originalPixelSize );\n		vec4 maxValue = packedTexture2DLOD( tex, uv, maxLevel, originalPixelSize );\n\n		return mix( minValue, maxValue, ratio );\n\n	}\n\n';function f(t){const e=h({},t);return"defines"in t&&(e.defines=h({},t.defines)),"uniforms"in t&&(e.uniforms=G.clone(t.uniforms)),e}const k={defines:{X_IS_EVEN:1,Y_IS_EVEN:1},uniforms:{map:{value:null},originalMapSize:{value:new z},parentMapSize:{value:new z},parentLevel:{value:0}},vertexShader:"\n		varying vec2 vUv;\n		void main() {\n\n			#include <begin_vertex>\n			#include <project_vertex>\n			vUv = uv;\n\n		}\n	",fragmentShader:"\n		varying vec2 vUv;\n		uniform sampler2D map;\n		uniform int parentLevel;\n		uniform vec2 parentMapSize;\n		uniform vec2 originalMapSize;\n\n		".concat(Q,"\n\n		#if X_IS_EVEN && Y_IS_EVEN\n\n		#define SAMPLES 4\n		#define WIDTH 2\n		#define HEIGHT 2\n\n		#elif X_IS_EVEN\n\n		#define SAMPLES 6\n		#define WIDTH 2\n		#define HEIGHT 3\n\n		#elif Y_IS_EVEN\n\n		#define SAMPLES 6\n		#define WIDTH 3\n		#define HEIGHT 2\n\n		#else\n\n		#define SAMPLES 9\n		#define WIDTH 3\n		#define HEIGHT 3\n\n		#endif\n\n		vec4 sampleAt( vec2 uv ) {\n\n			return packedTexture2DLOD( map, uv, parentLevel, originalMapSize );\n\n		}\n\n		void main() {\n\n			vec2 childMapSize = parentMapSize / 2.0;\n			// vec2 childPixelSize = 1.0 / childMapSize;\n			// vec2 halfChildPixelSize = childPixelSize / 2.0;\n			vec2 childPixelPos = floor( vUv * childMapSize );\n\n			vec2 parentPixelSize = 1.0 / parentMapSize;\n			vec2 halfParentPixelSize = parentPixelSize / 2.0;\n			vec2 parentPixelPos = childPixelPos * 2.0;\n\n			vec2 baseUv = ( parentPixelPos / parentMapSize ) + halfParentPixelSize;\n\n			vec4 samples[ SAMPLES ];\n			float weights[ SAMPLES ];\n\n			#if X_IS_EVEN && Y_IS_EVEN\n\n			samples[ 0 ] = sampleAt( baseUv );\n			samples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );\n			samples[ 2 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );\n			samples[ 3 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );\n\n			weights[ 0 ] = 0.25;\n			weights[ 1 ] = 0.25;\n			weights[ 2 ] = 0.25;\n			weights[ 3 ] = 0.25;\n\n			#elif X_IS_EVEN\n\n			float wx0 = 0.5;\n			float wx1 = 0.5;\n\n			float yden = 2.0 * parentMapSize.y + 1.0;\n			float wy0 = ( parentMapSize.y - parentPixelPos.y ) / yden;\n			float wy1 = ( parentMapSize.y ) / yden;\n			float wy2 = ( parentPixelPos.y + 1.0 ) / yden;\n\n			samples[ 0 ] = sampleAt( baseUv );\n			samples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );\n\n			samples[ 2 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );\n			samples[ 3 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );\n\n			samples[ 4 ] = sampleAt( baseUv + vec2( 0.0, 2.0 * parentPixelSize.y ) );\n			samples[ 5 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 2.0 * parentPixelSize.y ) );\n\n			weights[ 0 ] = wx0 * wy0;\n			weights[ 1 ] = wx1 * wy0;\n\n			weights[ 2 ] = wx0 * wy1;\n			weights[ 3 ] = wx1 * wy1;\n\n			weights[ 4 ] = wx0 * wy2;\n			weights[ 5 ] = wx1 * wy2;\n\n			#elif Y_IS_EVEN\n\n			float xden = 2.0 * parentMapSize.x + 1.0;\n			float wx0 = ( parentMapSize.x - parentPixelPos.x ) / xden;\n			float wx1 = ( parentMapSize.x ) / xden;\n			float wx2 = ( parentPixelPos.x + 1.0 ) / xden;\n\n			float wy0 = 0.5;\n			float wy1 = 0.5;\n\n			samples[ 0 ] = sampleAt( baseUv );\n			samples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );\n			samples[ 2 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 0.0 ) );\n\n			samples[ 3 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );\n			samples[ 4 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );\n			samples[ 5 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, parentPixelSize.y ) );\n\n			weights[ 0 ] = wx0 * wy0;\n			weights[ 1 ] = wx1 * wy0;\n			weights[ 2 ] = wx2 * wy0;\n\n			weights[ 3 ] = wx0 * wy1;\n			weights[ 4 ] = wx1 * wy1;\n			weights[ 5 ] = wx2 * wy1;\n\n			#else\n\n			float xden = 2.0 * parentMapSize.x + 1.0;\n			float wx0 = ( parentMapSize.x - parentPixelPos.x ) / xden;\n			float wx1 = ( parentMapSize.x ) / xden;\n			float wx2 = ( parentPixelPos.x + 1.0 ) / xden;\n\n			float yden = 2.0 * parentMapSize.y + 1.0;\n			float wy0 = ( parentMapSize.y - parentPixelPos.y ) / yden;\n			float wy1 = ( parentMapSize.y ) / yden;\n			float wy2 = ( parentPixelPos.y + 1.0 ) / yden;\n\n			samples[ 0 ] = sampleAt( baseUv );\n			samples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );\n			samples[ 2 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 0.0 ) );\n\n			samples[ 3 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );\n			samples[ 4 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );\n			samples[ 5 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, parentPixelSize.y ) );\n\n			samples[ 6 ] = sampleAt( baseUv + vec2( 0.0, 2.0 * parentPixelSize.y ) );\n			samples[ 7 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 2.0 * parentPixelSize.y ) );\n			samples[ 8 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 2.0 * parentPixelSize.y ) );\n\n			weights[ 0 ] = wx0 * wy0;\n			weights[ 1 ] = wx1 * wy0;\n			weights[ 2 ] = wx2 * wy0;\n\n			weights[ 3 ] = wx0 * wy1;\n			weights[ 4 ] = wx1 * wy1;\n			weights[ 5 ] = wx2 * wy1;\n\n			weights[ 6 ] = wx0 * wy2;\n			weights[ 7 ] = wx1 * wy2;\n			weights[ 8 ] = wx2 * wy2;\n\n			#endif\n\n			<mipmap_logic>\n\n		}\n	")},E=new F;class J{constructor(e){e||(e="\n\n				#pragma unroll_loop\n				for ( int i = 0; i < SAMPLES; i ++ ) {\n\n					gl_FragColor += samples[ i ] * weights[ i ];\n\n				}\n\n			");const a=f(k);a.fragmentShader=a.fragmentShader.replace(/<mipmap_logic>/g,e);const i=new Array(4);i[0]=new v(f(a)),i[0].defines.X_IS_EVEN=0,i[0].defines.Y_IS_EVEN=0,i[1]=new v(f(a)),i[1].defines.X_IS_EVEN=1,i[1].defines.Y_IS_EVEN=0,i[2]=new v(f(a)),i[2].defines.X_IS_EVEN=0,i[2].defines.Y_IS_EVEN=1,i[3]=new v(f(a)),i[3].defines.X_IS_EVEN=1,i[3].defines.Y_IS_EVEN=1;const m=new R;m.texture.minFilter=y,m.texture.magFilter=y,this._swapTarget=m,this._copyQuad=new M(new v(W)),this._mipQuad=new M(null),this._mipMaterials=i}update(e,a,i,m=!1){e.isWebGLRenderTarget&&(e=e.texture);const b=i.autoClear,A=i.getClearAlpha(),D=i.getRenderTarget();i.getClearColor(E);const c=this._copyQuad,w=this._mipQuad,l=this._swapTarget,L=this._mipMaterials;let s,o;m?(s=_.floorPowerOfTwo(e.image.width),o=_.floorPowerOfTwo(e.image.height)):(s=Math.floor(e.image.width),o=Math.floor(e.image.height));const S=Math.floor(s*1.5),x=Math.floor(o);a.setSize(S,x),l.texture.type!==a.texture.type?(l.dispose(),l.copy(a),l.texture.image=h({},l.texture.image)):l.setSize(S,x),i.autoClear=!1,i.setClearColor(0),i.setClearAlpha(),c.material.uniforms.tDiffuse.value=e,c.camera.setViewOffset(s,o,0,0,S,x),i.setRenderTarget(a),i.clear(),c.render(i),i.setRenderTarget(l),i.clear(),c.render(i);let r=s,n=o,u=0;for(;r>1&&n>1;){const U=(r%2===0?1:0)|(n%2===0?2:0),p=L[U];p.uniforms.map.value=l.texture,p.uniforms.parentLevel.value=u,p.uniforms.parentMapSize.value.set(r,n),p.uniforms.originalMapSize.value.set(s,o),w.material=p,r=Math.floor(r/2),n=Math.floor(n/2);const T=x-2*n;i.setRenderTarget(a),w.camera.setViewOffset(r,n,-s,-T,S,x),w.render(i),i.setRenderTarget(l),p.uniforms.map.value=a.texture,w.render(i),u++}return i.setRenderTarget(D),i.setClearAlpha(A),i.setClearColor(E),i.autoClear=b,u+1}dispose(){this._swapTarget.dispose(),this._mipQuad.dispose(),this._copyQuad.dispose(),this._mipMaterials.forEach(e=>e.dispose())}}export{J as P};
