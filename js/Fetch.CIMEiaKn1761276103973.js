class t{constructor(){this._controller=new AbortController,this.listeners=new Set}static{this.pendings=new Map}fetch(e,s={}){t.pendings.has(e)||(t.pendings.set(e,this),fetch(e,{...s,signal:this._controller.signal}).then(t=>{this.listeners.forEach(e=>e.resolve(t.clone()))}).catch(t=>{this.listeners.forEach(e=>e.reject(t))}).finally(()=>{t.pendings.delete(e)}))}abort(){this._controller.abort()}}class e{constructor(t,e){this.url=t,this.init=e,this.promise=new Promise((t,e)=>{this.resolve=t,this.reject=e})}ready(){let e=t.pendings.get(this.url);return e||(e=new t,e.fetch(this.url,this.init)),e.listeners.add(this),this.promise}abort(){this.reject("User abort.");const e=t.pendings.get(this.url);e&&(e.listeners.delete(this),0===e.listeners.size&&e.abort())}}export{e as F};
