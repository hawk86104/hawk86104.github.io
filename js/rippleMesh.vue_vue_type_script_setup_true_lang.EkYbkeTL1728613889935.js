import{_ as n,C as t}from"./three.-yu4716U1728613889935.js";import{U as e}from"./@tresjs.BSMy0VpY1728613889935.js";import{g as o}from"./utils.JrYkpB5x1728613889935.js";import{d as r,b as i,a3 as s,o as a,E as c,L as u,u as l,aj as f,ak as p}from"./@vue.JNsx1iN61728613889935.js";const v=d;!function(n,t){const e=d,o=y();for(;;)try{if(337018===parseInt(e(173))/1*(parseInt(e(170))/2)+parseInt(e(126))/3*(-parseInt(e(132))/4)+-parseInt(e(142))/5+-parseInt(e(180))/6+parseInt(e(169))/7*(parseInt(e(174))/8)+parseInt(e(155))/9*(-parseInt(e(141))/10)+-parseInt(e(166))/11*(-parseInt(e(160))/12))break;o.push(o.shift())}catch(r){o.push(o.shift())}}();const m=function(){let n=!0;return function(t,e){const o=n?function(){if(e){const n=e[d(147)](t,arguments);return e=null,n}}:function(){};return n=!1,o}}();function d(n,t){const e=y();return(d=function(n,t){return e[n-=124]})(n,t)}!function(){m(this,(function(){const n=d,t=new RegExp("function *\\( *\\)"),e=new RegExp(n(144),"i"),o=w(n(140));t.test(o+n(146))&&e[n(154)](o+n(172))?w():o("0")}))()}();const h=function(){let n=!0;return function(t,e){const o=n?function(){if(e){const n=e[d(147)](t,arguments);return e=null,n}}:function(){};return n=!1,o}}();function y(){const n=["Color","gger","stateObject","toString","44UDyNuK","speed","pv2","568778BSpJbo","110dkcMEP","TresShaderMaterial","input","7370iIWQTl","56HHdmEj","log","uniforms","opacity","ShaderChunk","value","2262864cMGCAE","DoubleSide","fog_vertex","rippleMesh","uvs","9heizxx","bind","height","__proto__","trace","console","444392ENRRld","TresMesh","fog_pars_vertex","info","while (true) {}","constructor","\n}\n","table","init","10sBaFNg","2465125bDjUOP","counter","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","time","chain","apply","call","position","tresMeshRef","length","action","return (function() ","test","2056707inYJTo","color","num","#ffff00","warn","2384628YQRewQ","debu"];return(y=function(){return n})()}h(void 0,(function(){const n=d;let t;try{t=Function(n(153)+'{}.constructor("return this")( ));')()}catch(r){t=window}const e=t[n(131)]=t[n(131)]||{},o=[n(175),n(159),n(135),"error","exception",n(139),n(130)];for(let i=0;i<o[n(151)];i++){const t=h[n(137)].prototype[n(127)](h),r=o[i],s=e[r]||t;t[n(129)]=h.bind(h),t[n(165)]=s[n(165)][n(127)](s),e[r]=t}}))();const g=[v(149),"uv"],x=r({__name:v(124),props:{positionSrc:{default:[{x:0,y:0},{x:10,y:10}]},color:{default:v(158)},opacity:{default:.8},height:{default:100},num:{default:8},speed:{default:.15}},setup(r){const m=v,d=r,h=i(),y={side:n[m(181)],transparent:!0,depthWrite:!1,depthTest:!0,vertexShader:"\nprecision lowp float;\nprecision lowp int;\n"+n[m(178)][m(134)]+"\nvarying vec2 vUv;\nvoid main() {\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    "+n[m(178)][m(182)]+m(138),fragmentShader:"\n  precision lowp float;\n  precision lowp int;\n  uniform float time;\n  uniform float opacity;\n  uniform vec3 color;\n  uniform float num;\n  uniform float speed;\n  varying vec2 vUv;\n  void main() {\n    vec4 fragColor = vec4(0.);\n    float sin = sin((vUv.y - time * speed) * 10. * num);\n    float high = 0.92;\n    float medium = 0.4;\n    if (sin > high) {\n      fragColor = vec4(mix(vec3(.8, 1., 1.), color, (1. - sin) / (1. - high)), 1.);\n    } else if(sin > medium) {\n      fragColor = vec4(color, mix(1., 0., 1.-(sin - medium) / (high - medium)));\n    } else {\n      fragColor = vec4(color, 0.);\n    }\n    vec3 fade = mix(color, vec3(0., 0., 0.), vUv.y);\n    fragColor = mix(fragColor, vec4(fade, 1.), 0.85);\n    gl_FragColor = vec4(fragColor.rgb, fragColor.a * opacity * (1. - vUv.y));\n  }\n\t",uniforms:{time:{type:m(168),value:0},color:{type:m(125),value:new(n[m(162)])(d[m(156)])},opacity:{type:m(168),value:d.opacity},num:{type:m(168),value:d[m(157)]},speed:{type:m(168),value:d.speed}}};let x=null,w=null;const{centerPoint:_,points:C}=o(d.positionSrc);!function(n=[],t){const e=[],o=[];for(let r=0,i=e.length,s=o.length;r<n.length-1;r++){let a=1,c=n[r],u=n[r+1];e[i++]=c.x,e[i++]=0,e[i++]=c.y,o[s++]=0,o[s++]=0,e[i++]=u.x,e[i++]=0,e[i++]=u.y,o[s++]=1,o[s++]=0,e[i++]=c.x,e[i++]=t,e[i++]=c.y,o[s++]=0,o[s++]=a,e[i++]=c.x,e[i++]=t,e[i++]=c.y,o[s++]=0,o[s++]=a,e[i++]=u.x,e[i++]=0,e[i++]=u.y,o[s++]=1,o[s++]=0,e[i++]=u.x,e[i++]=t,e[i++]=u.y,o[s++]=1,o[s++]=a}x=new Float32Array(e),w=new Float32Array(o)}(C,d[m(128)]);const{onLoop:I}=e();return I((({delta:n})=>{const t=m;y[t(176)][t(145)][t(179)]+=n})),s((()=>{const n=m;d[n(156)]&&(y[n(176)][n(156)].value=new t(d.color)),d.opacity&&(y[n(176)].opacity[n(179)]=d[n(177)]),d.num&&(y[n(176)].num[n(179)]=d[n(157)]),d[n(167)]&&(y[n(176)].speed[n(179)]=d[n(167)]),h[n(179)]&&h[n(179)][n(149)].set(_.x,h[n(179)][n(149)].y,_.y)})),(n,t)=>{const e=m;return a(),c(e(133),{renderOrder:2200,ref_key:e(150),ref:h},[u("TresBufferGeometry",{position:[l(x),3],uv:[l(w),2]},null,8,g),u(e(171),f(p(y)),null,16)],512)}}});function w(n){function t(n){const e=d;if("string"==typeof n)return function(n){}[e(137)](e(136))[e(147)](e(143));1!==(""+n/n)[e(151)]||n%20==0?function(){return!0}[e(137)](e(161)+e(163))[e(148)](e(152)):function(){return!1}[e(137)](e(161)+e(163))[e(147)](e(164)),t(++n)}try{if(n)return t;t(0)}catch(e){}}export{x as _};
