import{b as t,ax as e,B as o,c as r}from"./three.2wx8FU0g1743660816268.js";
/**
 * @description Loop Subdivision Surface
 * @about       Smooth subdivision surface modifier for use with three.js BufferGeometry.
 * @author      Stephens Nunnally <@stevinz>
 * @license     MIT - Copyright (c) 2022 Stephens Nunnally
 * @source      https://github.com/stevinz/three-subdivide
 */
const i=new t,n=new t,s=new t,u=new t,a=new t,c=new t,f=new t,d=new t,l=new t,p=new t,m=new t,b=[new t,new t,new t],h=[new t,new t,new t],v=new e;class g{static modify(t,e=1,o={}){if(arguments.length>3&&console.warn("LoopSubdivision.modify() now uses a parameter object. See readme for more info!"),"object"!=typeof o&&(o={}),void 0===o.split&&(o.split=!0),void 0===o.uvSmooth&&(o.uvSmooth=!1),void 0===o.preserveEdges&&(o.preserveEdges=!1),void 0===o.flatOnly&&(o.flatOnly=!1),void 0===o.maxTriangles&&(o.maxTriangles=1/0),void 0===o.weight&&(o.weight=1),!isNaN(o.weight)&&isFinite(o.weight)||(o.weight=1),o.weight=Math.max(0,Math.min(1,o.weight)),!z(t))return t;let r=t.clone();if(o.split){const t=g.edgeSplit(r);r.dispose(),r=t}for(let i=0;i<e;i++){if(r.attributes.position.count/3<o.maxTriangles){let t;t=o.flatOnly?g.flat(r,o):g.smooth(r,o),r.groups.forEach((e=>{t.addGroup(4*e.start,4*e.count,e.materialIndex)})),r.dispose(),r=t}}return r}static edgeSplit(t){if(!z(t))return t;const e=null!==t.index?t.toNonIndexed():t.clone(),i=new o,a=$(e),l=e.attributes.position.count,p=e.getAttribute("position"),m=e.getAttribute("normal"),b={},h=[],g={},w=[];for(let o=0;o<l;o+=3){c.fromBufferAttribute(p,o+0),f.fromBufferAttribute(p,o+1),d.fromBufferAttribute(p,o+2),u.fromBufferAttribute(m,o);const t=A(c),e=A(f),r=A(d),i=v.set(c,f,d).getArea();if(w.push(!S(i,0)),!w[o/3]){h.push([]);continue}B(u,c,f,d);const n=A(u),s=[`${t}_${e}_${n}`,`${e}_${t}_${n}`,`${e}_${r}_${n}`,`${r}_${e}_${n}`,`${r}_${t}_${n}`,`${t}_${r}_${n}`],a=o/3;for(let o=0;o<s.length;o++)b[s[o]]||(b[s[o]]=[]),b[s[o]].push(a),g[s[o]]||(0!==o&&1!==o||(g[s[o]]=c.distanceTo(f)),2!==o&&3!==o||(g[s[o]]=f.distanceTo(d)),4!==o&&5!==o||(g[s[o]]=d.distanceTo(c)));h.push([s[0],s[2],s[4]])}a.forEach((t=>{const o=e.getAttribute(t);if(!o)return;const n=E(o,t);i.setAttribute(t,new r(n,o.itemSize))}));const y=e.morphAttributes;for(const o in y){const t=[],e=y[o];for(let i=0,n=e.length;i<n;i++){if(e[i].count!==l)continue;const n=E(e[i],o,!0);t.push(new r(n,e[i].itemSize))}i.morphAttributes[o]=t}return i.morphTargetsRelative=e.morphTargetsRelative,e.dispose(),i;function E(t,o,r=!1){const u=l*t.itemSize*4,a=new t.array.constructor(u),p="position"===o&&!r&&e.groups.length>0;let m,v,S=0,y=0,A=t.itemSize;for(let z=0;z<l;z+=3){if(!w[z/3]){y+=3;continue}c.fromBufferAttribute(t,z+0),f.fromBufferAttribute(t,z+1),d.fromBufferAttribute(t,z+2);const o=z/3,r=h[o][0],u=h[o][1],l=h[o][2],B=b[r].length,$=b[u].length,E=b[l].length,T=3*S/A/3;if(0===B+$+E-3)x(a,S,A,c,f,d),S+=3*A;else{const t=g[r],e=g[u],o=g[l];(t>e||$<=1)&&(t>o||E<=1)&&B>1?(n.copy(c).add(f).divideScalar(2),E>1?(s.copy(d).add(c).divideScalar(2),x(a,S,A,c,n,s),S+=3*A,x(a,S,A,n,d,s),S+=3*A):(x(a,S,A,c,n,d),S+=3*A),$>1?(s.copy(f).add(d).divideScalar(2),x(a,S,A,n,f,s),S+=3*A,x(a,S,A,s,d,n),S+=3*A):(x(a,S,A,f,d,n),S+=3*A)):(e>o||E<=1)&&$>1?(n.copy(f).add(d).divideScalar(2),B>1?(s.copy(c).add(f).divideScalar(2),x(a,S,A,n,s,f),S+=3*A,x(a,S,A,s,n,c),S+=3*A):(x(a,S,A,f,n,c),S+=3*A),E>1?(s.copy(d).add(c).divideScalar(2),x(a,S,A,n,d,s),S+=3*A,x(a,S,A,s,c,n),S+=3*A):(x(a,S,A,d,c,n),S+=3*A)):E>1?(n.copy(d).add(c).divideScalar(2),$>1?(s.copy(f).add(d).divideScalar(2),x(a,S,A,d,n,s),S+=3*A,x(a,S,A,n,f,s),S+=3*A):(x(a,S,A,d,n,f),S+=3*A),B>1?(s.copy(c).add(f).divideScalar(2),x(a,S,A,c,s,n),S+=3*A,x(a,S,A,s,f,n),S+=3*A):(x(a,S,A,c,f,n),S+=3*A)):(x(a,S,A,c,f,d),S+=3*A)}p&&e.groups.forEach((t=>{t.start===z-y&&(void 0!==m&&void 0!==v&&i.addGroup(m,T-m,v),m=T,v=t.materialIndex)})),y=0}const B=3*S/A,$=new t.array.constructor(B);for(let e=0;e<B;e++)$[e]=a[e];return p&&void 0!==m&&void 0!==v&&i.addGroup(m,3*S/A/3-m,v),$}}static flat(t,e={}){if(!z(t))return t;const r=null!==t.index?t.toNonIndexed():t.clone(),i=new o,n=$(r),s=r.attributes.position.count;n.forEach((t=>{const o=r.getAttribute(t);o&&i.setAttribute(t,g.flatAttribute(o,s,e))}));const u=r.morphAttributes;for(const o in u){const t=[],r=u[o];for(let o=0,i=r.length;o<i;o++)r[o].count===s&&t.push(g.flatAttribute(r[o],s,e));i.morphAttributes[o]=t}return i.morphTargetsRelative=r.morphTargetsRelative,r.dispose(),i}static flatAttribute(t,e,o={}){const i=e*t.itemSize*4,n=new t.array.constructor(i);let s=0,u=t.itemSize;for(let r=0;r<e;r+=3)c.fromBufferAttribute(t,r+0),f.fromBufferAttribute(t,r+1),d.fromBufferAttribute(t,r+2),l.copy(c).add(f).divideScalar(2),p.copy(f).add(d).divideScalar(2),m.copy(d).add(c).divideScalar(2),x(n,s,u,c,l,m),s+=3*u,x(n,s,u,f,p,l),s+=3*u,x(n,s,u,d,m,p),s+=3*u,x(n,s,u,l,p,m),s+=3*u;return new r(n,t.itemSize)}static smooth(t,e={}){if("object"!=typeof e&&(e={}),void 0===e.uvSmooth&&(e.uvSmooth=!1),void 0===e.preserveEdges&&(e.preserveEdges=!1),!z(t))return t;const n=null!==t.index?t.toNonIndexed():t.clone(),s=g.flat(n,e),u=new o,c=$(n),f=n.attributes.position.count,d=n.getAttribute("position"),v=s.getAttribute("position"),w={},S={},y={},B={};function E(t,e,o){S[t]||(S[t]={}),S[t][e]||(S[t][e]=[]),S[t][e].push(o)}function T(t,e){y[t]||(y[t]=[]),y[t].push(e)}function _(t,e){B[t]||(B[t]=new Set),B[t].add(e)}for(let o=0;o<f;o+=3){const t=A(h[0].fromBufferAttribute(d,o+0)),e=A(h[1].fromBufferAttribute(d,o+1)),r=A(h[2].fromBufferAttribute(d,o+2));E(t,e,o+1),E(t,r,o+2),E(e,t,o+0),E(e,r,o+2),E(r,t,o+0),E(r,e,o+1),l.copy(h[0]).add(h[1]).divideScalar(2),p.copy(h[1]).add(h[2]).divideScalar(2),m.copy(h[2]).add(h[0]).divideScalar(2);const i=A(l),n=A(p),s=A(m);T(i,o+2),T(n,o+0),T(s,o+1),_(t,i),_(t,s),_(e,i),_(e,n),_(r,n),_(r,s)}for(let o=0;o<s.attributes.position.count;o++){const t=A(a.fromBufferAttribute(v,o));w[t]||(w[t]=[]),w[t].push(o)}c.forEach((t=>{const e=n.getAttribute(t),o=s.getAttribute(t);if(void 0===e||void 0===o)return;const i=j(t,e,o);u.setAttribute(t,new r(i,o.itemSize))}));const G=n.morphAttributes;for(const o in G){const t=[],i=G[o];for(let n=0,s=i.length;n<s;n++){if(i[n].count!==f)continue;const s=i[n],u=g.flatAttribute(i[n],i[n].count,e),a=j(o,s,u);t.push(new r(a,u.itemSize))}u.morphAttributes[o]=t}return u.morphTargetsRelative=n.morphTargetsRelative,s.dispose(),n.dispose(),u;function j(t,o,r){const n=s.attributes.position.count*r.itemSize,u=new o.array.constructor(n);let c=0;for(let p=0;p<s.attributes.position.count;p+=3){for(let n=0;n<3;n++)if("uv"!==t||e.uvSmooth)if("normal"===t){b[n].fromBufferAttribute(v,p+n);const t=A(b[n]),e=w[t],o=Object.keys(e).length,s=.75/o,u=1-s*o;h[n].fromBufferAttribute(r,p+n),h[n].multiplyScalar(u),e.forEach((t=>{i.fromBufferAttribute(r,t),i.multiplyScalar(s),h[n].add(i)}))}else{h[n].fromBufferAttribute(r,p+n),b[n].fromBufferAttribute(v,p+n);const t=A(b[n]),s=S[t],u=y[t];if(s){if(e.preserveEdges){const e=B[t];let o=!0;for(const t of e)y[t].length%2!=0&&(o=!1);if(!o)continue}const r=Object.keys(s).length,u=1/r*(5/8-Math.pow(3/8+1/4*Math.cos(2*Math.PI/r),2)),c=(f=1/r/r,d=u,(1-(l=e.weight))*f+l*d),p=1-c*r;h[n].multiplyScalar(p);for(let t in s){const e=s[t];i.set(0,0,0);for(let t=0;t<e.length;t++)i.add(a.fromBufferAttribute(o,e[t]));i.divideScalar(e.length),i.multiplyScalar(c),h[n].add(i)}}else if(u&&2===u.length){const t=u.length,e=.125,r=1-e*t;h[n].multiplyScalar(r),u.forEach((t=>{i.fromBufferAttribute(o,t),i.multiplyScalar(e),h[n].add(i)}))}}else h[n].fromBufferAttribute(r,p+n);x(u,c,r.itemSize,h[0],h[1],h[2]),c+=3*r.itemSize}var f,d,l;return u}}}const w=Math.pow(10,2);function S(t,e,o=1e-5){return t<e+o&&t>e-o}function y(t,e=w){let o=(r=t*e)+(r>0?.5:-.5)<<0;var r;return 0==o&&(o=0),`${o}`}function A(t,e=w){return`${y(t.x,e)},${y(t.y,e)},${y(t.z,e)}`}function B(t,e,o,r){a.subVectors(e,o),t.subVectors(o,r),t.cross(a).normalize()}function $(t){const e=Object.keys(t.attributes);return Array.from(new Set(["position","normal","uv"].concat(e)))}function x(t,e,o,r,i,n){o>=1&&(t[e+0+0*o]=r.x,t[e+0+1*o]=i.x,t[e+0+2*o]=n.x),o>=2&&(t[e+1+0*o]=r.y,t[e+1+1*o]=i.y,t[e+1+2*o]=n.y),o>=3&&(t[e+2+0*o]=r.z,t[e+2+1*o]=i.z,t[e+2+2*o]=n.z),o>=4&&(t[e+3+0*o]=r.w,t[e+3+1*o]=i.w,t[e+3+2*o]=n.w)}function z(t){return void 0===t?(console.warn("LoopSubdivision: Geometry provided is undefined"),!1):t.isBufferGeometry?void 0===t.attributes.position?(console.warn("LoopSubdivision: Geometry provided missing required 'position' attribute"),!1):(void 0===t.attributes.normal&&t.computeVertexNormals(),!0):(console.warn("LoopSubdivision: Geometry provided is not 'BufferGeometry' type"),!1)}export{g as L};
