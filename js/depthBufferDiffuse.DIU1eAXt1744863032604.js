import"./index.CLfAe2tm1744863032604.js";import"./index.BGSZsJXM1744863032604.js";import{P as e}from"./tweakpane.C0HtAJSg1744863032604.js";import{b as r}from"./pagesShow.vue_vue_type_script_setup_true_lang.IwwYCecN1744863032604.js";import{_ as o}from"./default.vue_vue_type_script_setup_true_lang.BfXifJKI1744863032604.js";import{m as t,e as i}from"./@tresjs.DDZ0vesk1744863032604.js";import"./index.TmMel0Tm1744863032604.js";import{u as a}from"./index.CoMom7Dz1744863032604.js";import{d as n,a6 as s,w as l,H as u,o as m,J as f,ak as d,al as p,r as v,v as h,a3 as c,j,u as g,f as C,m as _,F as b}from"./@vue.DK6ok9LJ1744863032604.js";import{C as x,a as D,ab as w,cv as y}from"./three.B0XaFSnH1744863032604.js";import"./utils.CppDyFGn1744863032604.js";import"./@fesjs.1a7Lul6Z1744863032604.js";import"./vue-router.CdrpVSr11744863032604.js";import"./lodash-es.BOsRjQhS1744863032604.js";import"./@qlin.q6OWdsQV1744863032604.js";import"./pinia.vfLI9vPt1744863032604.js";import"./@babel.BPq7uOAK1744863032604.js";import"./@floating-ui.BFjFSAYt1744863032604.js";import"./@juggle.CcBCnTIR1744863032604.js";import"./three-mesh-ui.module.skm2U1Jq1744863032604.js";import"./SPE.DqZmuCUH1744863032604.js";import"./utils.D42y0R0G1744863032604.js";import"./three-mesh-bvh.CQMVAHAP1744863032604.js";import"./HeightCorrection.Bq98L9tL1744863032604.js";import"./three-custom-shader-material.Cs7iC7LJ1744863032604.js";import"./buildingsCustomShaderMaterial.DyBo--wu1744863032604.js";import"./postprocessing.DMK_Mhe01744863032604.js";import"./@vueuse.aRlY5CPe1744863032604.js";import"./object-hash.BnegGKfT1744863032604.js";import"./@amap.CGUF9xH41744863032604.js";import"./jszip.H-wAjEeh1744863032604.js";const z={renderOrder:2200},N=["args"],P=n({__name:"depthBufferDiffuse",props:{radius:{default:100},shieldColor:{default:"#ffff00"},rimColor:{default:"#ffffff"},threshold:{default:.005}},setup(e){const r=e,{sizes:o,camera:n}=t(),v=o.aspectRatio.value,h=o.width.value,c=o.height.value,j=a({height:h*v,width:c*v,depth:!0,isLoop:!0}),g={blending:y,transparent:!0,depthWrite:!1,depthTest:!0,side:w,vertexShader:"\n\tvarying vec2 vUv;\n\tvarying vec3 vNormal;\n\tvarying vec3 vPosition;\n\tvoid main() {\n\t\tvUv = uv;\n\t\tvec4 worldPos = modelMatrix * vec4(position, 1.0);\n\t\tvec4 modelNormal = modelMatrix * vec4(normal, 0.0);\n\t\tvec4 mvPosition = viewMatrix * worldPos;\n\t\tgl_Position = projectionMatrix * mvPosition;\n\t\tvNormal = modelNormal.xyz;\n\t\tvPosition = worldPos.xyz;\n\t}\n  ",fragmentShader:"\nuniform sampler2D uDepthTexture; \nuniform vec2 uResolution;\nuniform float uNear;\nuniform float uFar;\nuniform float uThreshold;\nuniform vec3 uShieldColor;\nuniform vec3 uRimColor;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\n#include <packing>\n\nfloat LinearizeDepth(float depth) {\n\tfloat zNdc = 2.0 * depth - 1.0;\n\tfloat zEye = (2.0 * uFar * uNear) / ((uFar + uNear) - zNdc * (uFar - uNear));\n\tfloat linearDepth = (zEye - uNear) / (uFar - uNear);\n\treturn linearDepth;\n}\n\nvoid main() {\n\n  vec3 normal = normalize(vNormal);\n  if(gl_FrontFacing) {\n    normal *= -1.0;\n  }\n\n  vec3 viewDirection = normalize(cameraPosition - vPosition);\n  float fresnel = 1. + dot(normal, viewDirection);\n  fresnel = pow(fresnel, 4.0);\n\n  vec2 worldCoords = gl_FragCoord.xy/uResolution;\n\n  float sceneDepth = LinearizeDepth(texture2D(uDepthTexture, worldCoords).r);\n  float bubbleDepth = LinearizeDepth(gl_FragCoord.z);\n\n  float difference = abs( sceneDepth - bubbleDepth);\n  float normalizedDistance = clamp(difference / uThreshold, 0.0, 1.0);\n  vec4 intersection = mix(vec4(1.0), vec4(0.0), normalizedDistance) ;\n  intersection.rgb *= uRimColor;\n  vec4 color = vec4(uShieldColor, 0.3);\n  gl_FragColor = color + intersection + vec4(uRimColor, 1.0) * fresnel ;\n}\n  ",uniforms:{uDepthTexture:{value:s(j?.value?.depthTexture)},uResolution:{value:new D(h,c)},uNear:{value:1},uFar:{value:1e4},uThreshold:{value:.005},uShieldColor:{value:new x(r.shieldColor)},uRimColor:{value:new x(r.rimColor)}}},{onLoop:C}=i();return C((()=>{})),l((()=>[r.rimColor,r.shieldColor,r.threshold]),(([e,r,o])=>{g.uniforms.uRimColor.value.setStyle(e),g.uniforms.uShieldColor.value.setStyle(r),g.uniforms.uThreshold.value=o})),(e,o)=>(m(),u("TresMesh",z,[f("TresSphereGeometry",{args:[r.radius,64,64]},null,8,N),f("TresShaderMaterial",d(p(g)),null,16)]))}}),R=n({__name:"depthBufferDiffuse",setup(t){const i=v({shieldColor:"#ffff00",rimColor:"#ffffff",threshold:.005,radius:100}),a=new e;a.addBinding(i,"shieldColor",{label:"圈颜色"}),a.addBinding(i,"rimColor",{label:"条颜色"}),a.addBinding(i,"threshold",{label:"线条参数",min:1e-5,max:.01,step:1e-5}),a.addBinding(i,"radius",{label:"大小",min:10,max:200,step:1});const n=h(null);return c((()=>{n.value&&(n.value.$refs.tcRef?n.value.$refs.tcRef.context.camera.value.position.set(-135,250,320):n.value.$refs.perspectiveCameraRef&&n.value.$refs.perspectiveCameraRef.position.set(-135,250,320))})),(e,t)=>(m(),u(b,null,[j(g(o)),j(r,{ref_key:"pagesShowRef",ref:n},{ability:C((()=>[j(g(P),_({position:[0,30,0]},i),null,16)])),_:1},512)],64))}});export{R as default};
