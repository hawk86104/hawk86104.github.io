import{importShared as e}from"./3d-tiles-renderer.CPyPbRB51767152766904.js";import{useLoop as t,useTres as n,_export_sfc as o,OrbitControls_default as a}from"./index.BGo9PN8R1767152766904.js";import{EffectComposer as r,RenderPass as l,ShaderPass as i}from"./RenderPass.coonXiPa1767152766904.js";import{UnrealBloomPass as s}from"./UnrealBloomPass.BAfZwd9i1767152766904.js";var c="float N21(vec2 st){\n\treturn fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat smoothNoise(vec2 ip){\n\tvec2 lv=fract(ip);\n\tvec2 id=floor(ip);\n\t\n\tlv=lv*lv*(3.-2.*lv);\n\t\n\tfloat bl=N21(id);\n\tfloat br=N21(id+vec2(1,0));\n\tfloat b=mix(bl,br,lv.x);\n\t\n\tfloat tl=N21(id+vec2(0,1));\n\tfloat tr=N21(id+vec2(1,1));\n\tfloat t=mix(tl,tr,lv.x);\n\t\n\treturn clamp(mix(b,t,lv.y)*.5+.5,0.,1.);\n}\nfloat smoothNoise2(vec2 p){\n\tp.y+=time;\n\tp/=4.;\n\t\n\tfloat n=smoothNoise(p)*1.5;\n\tn+=smoothNoise(p*2.01)*.25;\n\tn+=smoothNoise(p*4.02)*.125;\n\tn+=smoothNoise(p*8.03)*.0625;\n\tn/=(1.5+.25+.125+.0625);\n\treturn clamp(n,0.,1.);\n}";const{defineComponent:u}=await e("vue"),{unref:v,createElementVNode:m,Fragment:f,openBlock:d,createElementBlock:g}=await e("vue"),p=["geometry","material"],h=["material"],b=["rotateX"],x=await e("three"),w=100,y=u({__name:"lucesPlane",props:{globalUniforms:{}},setup(e){const n=e,o=[],a=[],r=new x.SphereGeometry(1,36,18),l=(new x.InstancedBufferGeometry).copy(r);l.instanceCount=w;const i=[];for(let t=0;t<w;t++){let e=x.MathUtils.randFloatSpread(49),t=x.MathUtils.randFloatSpread(49),n=x.MathUtils.randFloat(.0625,.125),r=x.MathUtils.randFloat(1,3);i.push(e,t,n),a.push(new x.Vector4(e,t,r,x.MathUtils.randFloat(1,2))),o.push(new x.Vector4(e,t,n,r))}l.setAttribute("instData",new x.InstancedBufferAttribute(new Float32Array(i),3));const s=new x.MeshBasicMaterial({color:16720418,onBeforeCompile:e=>{e.uniforms.noiseTex=n.globalUniforms.noise,e.vertexShader=`\n      uniform sampler2D noiseTex;\n      attribute vec4 instData;\n      ${e.vertexShader}\n    `.replace("#include <begin_vertex>","#include <begin_vertex>\n      transformed = position * instData.z;\n      \n      transformed.x += instData.x;\n      transformed.z += instData.y;\n      vec2 nUv = (vec2(instData.x, -instData.y) - vec2(-25.)) / 50.;\n      float h = texture2D(noiseTex, nUv).g;\n      h = (h - 0.5) * 4.;\n      transformed.y += h;\n      ")}}),c={luces:{value:o}},u=new x.MeshLambertMaterial({color:2363940,onBeforeCompile:e=>{e.uniforms.luces=c.luces,e.uniforms.globalBloom=n.globalUniforms.globalBloom,e.uniforms.noiseTex=n.globalUniforms.noise,e.vertexShader=`\n      uniform float time;\n      uniform sampler2D noiseTex;\n      varying vec3 vPos;\n      varying float intensity;\n      \n      //// https://discourse.threejs.org/t/calculating-vertex-normals-after-displacement-in-the-vertex-shader/16989/8 ///\n      \n      // the function which defines the displacement\n      float displace(vec2 vUv) {\n        return (texture2D(noiseTex, vUv).g - 0.5) * 4.;\n      }\n\n      vec3 getNormal(vec2 vUv){\n        vec3 displacedPosition = position + normal * displace(vUv);\n\n        float texelSize = 1.0 / 512.0; // temporarily hardcoding texture resolution\n        float offset = 0.1;\n\n        vec3 neighbour1 = position + vec3(1., 0., 0.) * offset;\n        vec3 neighbour2 = position + vec3(0., 0., 1.) * offset;\n        vec2 neighbour1uv = vUv + vec2(-texelSize, 0);\n        vec2 neighbour2uv = vUv  + vec2(0, -texelSize);\n        vec3 displacedNeighbour1 = neighbour1 + normal * displace(neighbour1uv);\n        vec3 displacedNeighbour2 = neighbour2 + normal * displace(neighbour2uv);\n\n        // https://i.ya-webdesign.com/images/vector-normals-tangent-16.png\n        vec3 displacedTangent = displacedNeighbour1 - displacedPosition;\n        vec3 displacedBitangent = displacedNeighbour2 - displacedPosition;\n\n        // https://upload.wikimedia.org/wikipedia/commons/d/d2/Right_hand_rule_cross_product.svg\n        vec3 displacedNormal = normalize(cross(displacedBitangent, displacedTangent));\n        return displacedNormal;\n      }\n      \n      ${e.vertexShader}\n    `.replace("#include <begin_vertex>","#include <begin_vertex>\n\n        float h = texture2D(noiseTex, uv).g;\n        intensity = h;\n        h = (h - 0.5) * 4.;\n        transformed.y = h;\n        vPos = transformed;\n        transformedNormal = normalMatrix * getNormal(uv);\n      "),e.fragmentShader=`\n      uniform vec4 luces[100];\n      uniform sampler2D noiseTex;\n      uniform float globalBloom;\n      varying vec3 vPos;\n      varying float intensity;\n\n      ${e.fragmentShader}\n    `.replace("#include <fog_fragment>","\n        vec3 col = vec3(1, 0, 0)*0.75;\n        float intensity = 0.;\n        for(int i = 0;i < 100; i++){\n          vec4 lux = luces[i];\n          vec2 luxUv = (vec2(lux.x, -lux.y) - vec2(-25.)) / 50.;\n          float h = texture2D(noiseTex, luxUv).g;\n          h = (h - 0.5) * 4.;\n          vec3 lightPos = vec3(lux.x, h, lux.y);\n          float currIntensity = smoothstep(lux.z + lux.w, lux.z, distance(vPos, lightPos));\n          intensity += pow(currIntensity, 16.);\n        }\n        intensity = clamp(intensity, 0., 1.);\n        col = mix(col * 0.5, col, intensity);\n        col = mix(gl_FragColor.rgb, col, intensity);\n        col += vec3(1) * intensity * 0.01;\n        gl_FragColor = vec4( col, opacity );\n        #include <fog_fragment>\n      ").replace("#include <dithering_fragment>","#include <dithering_fragment>\n        if (globalBloom > 0.5) {\n          gl_FragColor = vec4(0);\n        }\n      ")}}),{onBeforeRender:y}=t();return y(({elapsed:e})=>{for(let t=0;t<w;t++){const n=a[t];let r=(n.y+e+25)%50-25;o[t].y=r,o[t].w=(Math.sin(e*n.w*(t%3+1))*Math.cos(e*n.w*(t%5+1))*.25+.25)*n.z+.75*n.z,l.attributes.instData.setY(t,r)}l.attributes.instData.needsUpdate=!0}),(e,t)=>(d(),g(f,null,[m("TresMesh",{geometry:v(l),material:v(s)},null,8,p),m("TresMesh",{material:v(u)},[m("TresPlaneGeometry",{args:[50,50,500,500],rotateX:.5*-Math.PI},null,8,b)],8,h)],64))}}),{defineComponent:U}=await e("vue"),{unref:T,createElementVNode:B,openBlock:_,createElementBlock:S}=await e("vue"),M=["material"],D=await e("three"),N=U({__name:"portal",props:{globalUniforms:{}},setup(e){const t=e,n=new D.MeshBasicMaterial({color:16737843,transparent:!0,onBeforeCompile:e=>{e.uniforms.time=t.globalUniforms.time,e.uniforms.globalBloom=t.globalUniforms.globalBloom,e.fragmentShader=`\n      #define S(a, b, t) smoothstep(a, b, t)\n      uniform float time;\n      uniform float globalBloom;\n      \n      ${c}\n      \n      float getTri(vec2 uv, float shift){\n        uv = uv * 2.-1.;\n        float a = atan(uv.x + shift,uv.y) + 3.1415926;\n        float r = 3.1415926 * 2./3.;\n        return cos(floor(.5+a/r)*r-a)*length(uv);\n      }\n      \n      float doubleTri(vec2 uv, float still, float width){\n        vec2 baseUv = uv;\n        vec2 e2 = fwidth(baseUv * 20.);\n        float e = min(e2.x, e2.y) * width;\n        float baseTri = getTri(baseUv, cos(baseUv.y * 31. + time) * sin(baseUv.y * 27. + time * 4.) * 0.025 * still);\n        float td = abs(fract(baseTri * 20.) - 0.5);\n        float tri = S(e, 0., td) - S(0., e, td);\n        tri *= step(0.4, baseTri) -  step(0.5, baseTri);\n        return tri;\n      }\n      \n      ${e.fragmentShader}\n    `.replace("vec4 diffuseColor = vec4( diffuse, opacity );","\n        float tri = doubleTri(vUv, 0.0, 16.);\n        float triWave = doubleTri(vUv, 1.0, 8.);\n        float fullTri = max(tri, triWave);\n        \n        if (fullTri < 0.5) discard;\n        \n        vec3 col = mix(diffuse, vec3(0.75), fullTri);\n        \n        float blinking = smoothNoise(vec2(time, time * 5.));\n        blinking = blinking * 0.9 + 0.1;\n        \n        vec4 diffuseColor = vec4(col * blinking, fullTri);\n      ").replace("#include <dithering_fragment>","#include <dithering_fragment>\n        if (globalBloom > 0.5) {\n          gl_FragColor = vec4(gl_FragColor.rgb * 0.375, fullTri);\n        }\n      ")}});return n.defines={USE_UV:""},(e,t)=>(_(),S("TresMesh",{material:T(n),position:[0,3.75,-12]},[...t[0]||(t[0]=[B("TresPlaneGeometry",{args:[5,5]},null,-1)])],8,M))}}),{defineComponent:C}=await e("vue"),{unref:P,openBlock:k,createElementBlock:E}=await e("vue"),F=["material","geometry"],z=await e("three"),G=C({__name:"drops",props:{globalUniforms:{}},setup(e){const t=e,n=[],o=[];for(let l=0;l<2e4;l++){const e=z.MathUtils.randFloatSpread(35),t=z.MathUtils.randFloat(-5,10),a=z.MathUtils.randFloatSpread(35),r=z.MathUtils.randFloat(.25,.5);n.push(e,t,a,e,t,a),o.push(0,r,1,r)}const a=new z.BufferGeometry;a.setAttribute("position",new z.Float32BufferAttribute(n,3)),a.setAttribute("gEnds",new z.Float32BufferAttribute(o,2));const r=new z.LineBasicMaterial({color:8930440,transparent:!0,onBeforeCompile:e=>{e.uniforms.time=t.globalUniforms.time,e.uniforms.noiseTex=t.globalUniforms.noise,e.uniforms.globalBloom=t.globalUniforms.globalBloom,e.vertexShader=`\n      uniform float time;\n      uniform sampler2D noiseTex;\n      attribute vec2 gEnds;\n      varying float vGEnds;\n      varying float vH;\n\n      ${e.vertexShader}\n    `.replace("#include <begin_vertex>","#include <begin_vertex>\n        \n      vec3 pos = position;\n      \n      vec2 nUv = (vec2(pos.x, -pos.z) - vec2(-25.)) / 50.;\n      float h = texture2D(noiseTex, nUv).g;\n      h = (h - 0.5) * 4.;\n      \n      pos.y = -mod(10. - (pos.y - time * 5.), 15.) + 10.;\n      h = pos.y - h;\n      pos.y += gEnds.x * gEnds.y;\n      transformed = pos;\n      vGEnds = gEnds.x;\n      vH = smoothstep(3., 0., h);\n      "),e.fragmentShader=`\n      uniform float time;\n      uniform float globalBloom;\n      varying float vGEnds;\n      varying float vH;\n      ${c}\n      ${e.fragmentShader}\n    `.replace("vec4 diffuseColor = vec4( diffuse, opacity );","\n      float op = 1. - vGEnds;\n      op = pow(op, 3.);\n      float h = (pow(vH, 3.) * 0.5 + 0.5);\n      vec3 col = diffuse * h; // lighter close to the surface\n      col *= 1. + smoothstep(0.99, 1., h); // sparkle at the surface\n      if (globalBloom > 0.5) {\n        //col *= 0.5;\n      }\n      vec4 diffuseColor = vec4( col, op );\n      \n      ")}});return(e,t)=>(k(),E("TresLineSegments",{material:P(r),geometry:P(a)},null,8,F))}}),{defineComponent:V}=await e("vue"),{createVNode:A,Fragment:R,openBlock:$,createElementBlock:j}=await e("vue"),I=await e("three"),{watch:L}=await e("vue"),H=V({__name:"fboRender",setup(e){const o={time:{value:0},globalBloom:{value:0},noise:{value:null}},a=new I.WebGLRenderTarget(512,512),u=new I.Scene,v=new I.Camera,m=new I.PlaneGeometry(2,2),f=new I.MeshBasicMaterial({onBeforeCompile:e=>{e.uniforms.time=o.time,e.fragmentShader=`\n      uniform float time;\n      ${c}\n      ${e.fragmentShader}\n    `.replace("vec4 diffuseColor = vec4( diffuse, opacity );","\n        vec3 col = vec3(0);\n        float h = clamp(smoothNoise2(vUv * 50.), 0., 1.);\n        col = vec3(h);\n        vec4 diffuseColor = vec4( col, opacity );\n      ")}});f.defines={USE_UV:""};const d=new I.Mesh(m,f);u.add(d),o.noise.value=a.texture;const{camera:g,renderer:p,scene:h,sizes:b,controls:x}=n();L(()=>x.value,e=>{e?.target.set(0,2,0),h.value.background||(h.value.background=new I.Color(6706534))});const w=new r(p),U=new r(p),T=new l(h.value,g.value),B=new s(new I.Vector2(b.width.value,b.height.value),1.2,.5,0);w.renderToScreen=!1,w.addPass(T),w.addPass(B);const _=new i(new I.ShaderMaterial({uniforms:{baseTexture:{value:null},bloomTexture:{value:w.renderTarget2.texture}},vertexShader:"\n\t\t\t\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t\t\t\tvUv = uv;\n\t\t\t\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\t\t\t\t}",fragmentShader:"\n\t\t\t\t\t\t\t\tuniform sampler2D baseTexture;\n\t\t\t\t\t\t\t\tuniform sampler2D bloomTexture;\n\t\t\t\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t\t\t\tgl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );\n\t\t\t\t\t\t\t\t}",defines:{}}),"baseTexture");_.needsSwap=!0,U.addPass(T),U.addPass(_),h.value.fog=new I.Fog(6706534,1,25);const{onBeforeRender:S}=t();return S(({elapsed:e})=>{o.time.value=e,p&&(p.setRenderTarget(a),p.render(u,v),p.setRenderTarget(null),o.globalBloom.value=1.2,h.value.fog.color.set(0),h.value.fog.near=15,h.value.background?.set(0),w.render(),o.globalBloom.value=0,h.value.fog.color.set(6706534),h.value.fog.near=10,h.value.background?.set(6706534),U.render())}),(e,t)=>($(),j(R,null,[A(y,{globalUniforms:o}),A(N,{globalUniforms:o}),A(G,{globalUniforms:o})],64))}}),W={},{createElementVNode:X,createTextVNode:Y,openBlock:q,createElementBlock:J}=await e("vue"),K={class:"text"};const O=o(W,[["render",function(e,t){return q(),J("div",K,[...t[0]||(t[0]=[X("span",{class:"retro noselect"},[X("span",{style:{color:"#eae"}},"光"),Y("噪声")],-1)])])}],["__scopeId","data-v-3881bd43"]]),{defineComponent:Q}=await e("vue"),{createVNode:Z,createElementVNode:ee,unref:te,normalizeProps:ne,guardReactiveProps:oe,resolveComponent:ae,withCtx:re,Fragment:le,openBlock:ie,createElementBlock:se}=await e("vue"),ce=await e("three"),ue=Q({__name:"lightNoise",setup(e){const t={windowSize:!0,antialias:!0,renderMode:"manual"},n={enableDamping:!0,minDistance:5,maxDistance:10,minPolarAngle:60*ce.MathUtils.DEG2RAD,maxPolarAngle:90*ce.MathUtils.DEG2RAD,makeDefault:!0};return(e,o)=>{const r=ae("TresCanvas");return ie(),se(le,null,[Z(O),Z(r,ne(oe(t)),{default:re(()=>[o[0]||(o[0]=ee("TresPerspectiveCamera",{position:[0,3,5],fov:45,near:.1,far:1e3},null,-1)),Z(te(a),ne(oe(n)),null,16),o[1]||(o[1]=ee("TresAmbientLight",{intensity:.5},null,-1)),o[2]||(o[2]=ee("TresDirectionalLight",{position:[0,3,-12],intensity:1},null,-1)),Z(H)]),_:1},16)],64)}}});export{ue as default};
