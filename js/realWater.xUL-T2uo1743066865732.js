import{m as n,e,a as t,o as r,f as o}from"./@tresjs.NxYvETXi1743066865732.js";import{P as i}from"./tweakpane.ivGeiIdz1743066865732.js";import{_ as c,a2 as a,C as l,O as s,n as u,m as f,u as p,X as v,a_ as g,V as d,l as x}from"./three.qSkR4_5R1743066865732.js";import{d as h,a3 as m,b as y,o as w,f as b,u as C,g as R,j as I,al as _,r as z,N as M,aj as D,ak as L}from"./@vue.L-brCdZe1743066865732.js";import"./postprocessing.ncQBP5me1743066865732.js";import"./@vueuse.2gpu5LGS1743066865732.js";var T="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const A=j;!function(n,e){const t=j,r=F();for(;;)try{if(280225===-parseInt(t(412))/1+parseInt(t(422))/2+parseInt(t(377))/3+-parseInt(t(375))/4+-parseInt(t(378))/5+parseInt(t(410))/6*(parseInt(t(397))/7)+-parseInt(t(417))/8*(parseInt(t(396))/9))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const O=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[j(413)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function F(){const n=["waterTexture","uniforms","2190282HwnGDV","Mesh","261187KJgyTN","apply","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","debu","causticsTexture","1359616zlgrrP","table","trace","length","light","738596fMFLlY","exception","BufferAttribute","__proto__","797104OtPuZs","BufferGeometry","1629387NvCmaY","134650NgELrl","water","warn","toString","function *\\( *\\)","stateObject","console","causticTex","tiles","info","return (function() ","setIndex","init","chain","bind","pool","string","counter","27iVruuv","7AIzdvn","constructor","while (true) {}","position","value","log","test","call",'{}.constructor("return this")( )',"RawShaderMaterial","gger"];return(F=function(){return n})()}!function(){O(this,(function(){const n=j,e=new RegExp(n(382)),t=new RegExp(n(414),"i"),r=W(n(390));e[n(403)](r+n(391))&&t[n(403)](r+"input")?W():r("0")}))()}();const E=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function j(n,e){const t=F();return j=function(n,e){return t[n-=372]},j(n,e)}E(void 0,(function(){const n=j,e=function(){const n=j;let e;try{e=Function(n(388)+n(405)+");")()}catch(t){e=window}return e}(),t=e[n(384)]=e[n(384)]||{},r=[n(402),n(380),n(387),"error",n(372),n(418),n(419)];for(let o=0;o<r[n(420)];o++){const e=E.constructor.prototype[n(392)](E),i=r[o],c=t[i]||e;e[n(374)]=E[n(392)](E),e[n(381)]=c[n(381)][n(392)](c),t[i]=e}}))();const S=h({__name:A(393),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=A,o=t,i=new(c[r(376)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i.setAttribute(r(400),new(c[r(373)])(l,3)),i[r(389)](new(c[r(373)])(s,1));const u=new(c[r(406)])({uniforms:{light:{value:o[r(421)]},tiles:{value:o[r(386)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:a}),f=new(c[r(411)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{const n=r;((n,e)=>{const t=r;u[t(409)][t(379)][t(401)]=n,u[t(409)][t(385)][t(401)]=e,p.value.render(f,v[t(401)])})(o[n(408)],o[n(416)])})),(n,e)=>null}});function W(n){function e(n){const t=j;if(typeof n===t(394))return function(n){}[t(398)](t(399))[t(413)](t(395));1!==(""+n/n)[t(420)]||n%20==0?function(){return!0}.constructor(t(415)+t(407))[t(404)]("action"):function(){return!1}[t(398)](t(415)+t(407))[t(413)](t(383)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const P=k;!function(n,e){const t=k,r=N();for(;;)try{if(297895===parseInt(t(396))/1+-parseInt(t(394))/2+parseInt(t(403))/3*(parseInt(t(366))/4)+-parseInt(t(399))/5+-parseInt(t(373))/6+parseInt(t(402))/7+-parseInt(t(377))/8*(-parseInt(t(409))/9))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const V=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[k(372)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){V(this,(function(){const n=k,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(359),"i"),r=Z(n(398));e[n(365)](r+n(390))&&t[n(365)](r+n(387))?Z():r("0")}))()}();const H=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[k(372)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function k(n,e){const t=N();return k=function(n,e){return t[n-=353]},k(n,e)}function N(){const n=["exception","clear","pos-y.jpg","70914HlntIK","water","23825htCzzJ","setPath","init","50645BnAoJw","pos-z.jpg","tiles","1711948SLokRY","3lYXrhs","string","setRenderTarget","pooRef","toString","info","9SnGrYg","light","causticsTexture","waterTexture","underwater","action","side","console","setClearColor","log","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","geometry","warn","neg-y.jpg","gger","debu","test","1906204wtOoXL","pos-x.jpg","table","https://opensource.cdn.icegl.cn","while (true) {}","bind","apply","3179100RHEplS","counter","CubeTextureLoader","Mesh","1027128isXbNC","length","error","value","RawShaderMaterial","BackSide","white","call","constructor","uniforms","input","resource.cos","stateObject","chain"];return(N=function(){return n})()}H(void 0,(function(){const n=k,e=function(){let n;try{n=Function('return (function() {}.constructor("return this")( ));')()}catch(e){n=window}return n}(),t=e[n(356)]=e[n(356)]||{},r=[n(358),n(361),n(408),n(379),n(391),n(368),"trace"];for(let o=0;o<r[n(378)];o++){const e=H.constructor.prototype[n(371)](H),i=r[o],c=t[i]||e;e.__proto__=H[n(371)](H),e[n(407)]=c[n(407)][n(371)](c),t[i]=e}}))();const G=h({__name:P(395),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=P;let i,s;const u=r,f=u[o(360)],p=(new(c[o(375)]))[o(397)](o(369)+"/images/skyBox/6jpg/").load([o(367),"neg-x.jpg",o(393),o(362),o(400),"neg-z.jpg"]),v=([i,s]=m((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,s(),i),g=new(c[o(381)])({uniforms:{light:{value:u[o(410)]},tiles:{value:v},sky:{value:p},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),d=new(c[o(376)])(f,g),x=y(null),h=new l(o(383)),{renderer:R,camera:I}=n(),{onLoop:_}=e();return _((()=>{const n=o;R[n(380)][n(405)](null),R[n(380)][n(357)](h,1),R.value[n(392)](),g[n(386)][n(395)][n(380)]=u.waterTexture,g[n(386)].causticTex[n(380)]=u[n(411)],g[n(355)]=a,g[n(386)][n(353)][n(380)]=!0,R[n(380)].render(d,I[n(380)]),g[n(355)]=c[n(382)],g.uniforms[n(353)].value=!1,R[n(380)].render(d,I[n(380)])})),(n,e)=>{const t=o;return w(),b(S,{tiles:C(v),light:n.light,waterTexture:n[t(412)],causticsTexture:n[t(411)],ref_key:t(406),ref:x},null,8,[t(401),"light",t(412),t(411)])}}});function Z(n){function e(n){const t=k;if(typeof n===t(404))return function(n){}[t(385)](t(370)).apply(t(374));1!==(""+n/n)[t(378)]||n%20==0?function(){return!0}[t(385)](t(364)+t(363))[t(384)](t(354)):function(){return!1}[t(385)](t(364)+t(363))[t(372)](t(389)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const Y=q;!function(n,e){const t=q,r=$();for(;;)try{if(754724===-parseInt(t(448))/1*(-parseInt(t(429))/2)+-parseInt(t(422))/3*(-parseInt(t(415))/4)+parseInt(t(403))/5+-parseInt(t(450))/6*(-parseInt(t(445))/7)+parseInt(t(447))/8+parseInt(t(440))/9*(-parseInt(t(437))/10)+-parseInt(t(430))/11*(parseInt(t(427))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(439)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){B(this,(function(){const n=q,e=new RegExp(n(438)),t=new RegExp(n(406),"i"),r=K(n(418));e.test(r+n(402))&&t[n(417)](r+n(404))?K():r("0")}))()}();const X=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function $(){const n=["return (function() ","chain","7413710lzRNur","input","Color","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","value","warn","prototype","render","material","caustics","constructor","trace","5121464mWCQQX","Mesh","test","init","clear","light","debu","3wqxGzG","while (true) {}","__proto__","stateObject","water","11124wDUpmH","exception","4HxkTbJ","44968HExtps","WebGLRenderTarget","setClearColor","info","PlaneGeometry","texture","length","70pFnvcV","function *\\( *\\)","apply","860346ANZwlb","waterTexture","causticsTexture","geometry","call","812TVfVKP","log","7686944DmQloV","695441OLxiJX","counter","5100mecFoj","bind","uniforms","gger","console","toString"];return($=function(){return n})()}X(void 0,(function(){const n=q;let e;try{e=Function(n(401)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(454)]=e[n(454)]||{},r=[n(446),n(408),n(433),"error",n(428),"table",n(414)];for(let i=0;i<r.length;i++){const e=X.constructor[n(409)][n(451)](X),o=r[i],c=t[o]||e;e[n(424)]=X[n(451)](X),e[n(455)]=c[n(455)][n(451)](c),t[o]=e}}))();const J=h({__name:Y(412),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=Y,o=t,i=new s(0,1,1,0,0,2e3),a=new(c[r(434)])(2,2,200,200),l=new(c[r(431)])(1024,1024),f=new u({uniforms:{light:{value:o[r(420)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new(c[r(416)])(a,f),v=new(c[r(405)])("black"),{renderer:g}=n(),{onBeforeLoop:d}=e();return d((()=>{const n=r;p[n(411)][n(452)][n(426)][n(407)]=o[n(441)],g.value.setRenderTarget(l),g.value[n(432)](v,0),g[n(407)][n(419)](),g[n(407)][n(410)](p,i)})),(n,e)=>{const t=r;return w(),b(_,null,{default:R((()=>[I(G,{waterTexture:n[t(441)],causticsTexture:C(l)[t(435)],light:n[t(420)],geometry:C(a)},null,8,[t(441),t(442),t(420),t(443)])])),_:1})}}});function q(n,e){const t=$();return q=function(n,e){return t[n-=401]},q(n,e)}function K(n){function e(n){const t=q;if("string"==typeof n)return function(n){}[t(413)](t(423)).apply(t(449));1!==(""+n/n)[t(436)]||n%20==0?function(){return!0}[t(413)](t(421)+t(453))[t(444)]("action"):function(){return!1}.constructor("debu"+t(453))[t(439)](t(425)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const Q=en;!function(n,e){const t=en,r=tn();for(;;)try{if(793183===parseInt(t(342))/1+parseInt(t(322))/2*(-parseInt(t(320))/3)+-parseInt(t(296))/4+parseInt(t(347))/5*(parseInt(t(301))/6)+-parseInt(t(315))/7+parseInt(t(338))/8*(-parseInt(t(281))/9)+parseInt(t(309))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){U(this,(function(){const n=en,e=new RegExp(n(307)),t=new RegExp(n(292),"i"),r=on("init");e[n(305)](r+"chain")&&t[n(305)](r+"input")?on():r("0")}))()}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[en(325)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function en(n,e){const t=tn();return en=function(n,e){return t[n-=277]},en(n,e)}function tn(){const n=["bind","material","3ZxWsuj","attributes","1532444HDfLVY","exception","waterSimulation","apply","info","OrthographicCamera","__proto__","position","top","trace","getY","autoClear","mousemove","while (true) {}","intersectObject","setZ","4072WCOdYo","left","width","clientY","68223YFckuQ","length","removeEventListener","uniforms","error","4233260MxKsgC","point","render","PlaneGeometry","log","2898dMxphx","height","clientX",'{}.constructor("return this")( )',"call","setY","debu","domElement","addEventListener","waterTexture","RawShaderMaterial","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","value","center","light","1087588hVbXDv","table","string","FloatType","strength","6iOVqMA","texture","count","constructor","test","radius","function *\\( *\\)","action","21782430uaMfcH","toString","WebGLRenderTarget","gger","console","lightFrontGeometry","7685426DcdHqe","Mesh","return (function() "];return(tn=function(){return n})()}nn(void 0,(function(){const n=en;let e;try{e=Function(n(317)+n(284)+");")()}catch(o){e=window}const t=e[n(313)]=e[n(313)]||{},r=[n(280),"warn",n(326),n(346),n(323),n(297),n(331)];for(let i=0;i<r[n(343)];i++){const e=nn[n(304)].prototype.bind(nn),o=r[i],c=t[o]||e;e[n(328)]=nn[n(318)](nn),e.toString=c[n(310)][n(318)](c),t[o]=e}}))();const rn=h({__name:Q(324),props:{light:{}},setup(t,{expose:r}){const o=Q,i=new(c[o(327)])(0,1,1,0,0,2e3),a=new f(2,2),l=new(c[o(311)])(256,256,{type:c[o(299)]}),s=new p(256,256,{type:v}),u=new(c[o(291)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:T,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),h=new g({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:T,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),m=new(c[o(291)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:T,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),y=new(c[o(316)])(a,u),R=new(c[o(316)])(a,h),I=new(c[o(316)])(a,m);let _=l;const z=(n,e)=>{const t=o,r=_,c=_===l?s:l;e[t(319)][t(345)][t(302)][t(293)]=r[t(302)],n.setRenderTarget(c),n[t(278)](e,i),_=c},{renderer:M,camera:D,raycaster:L}=n();M.value[o(333)]=!1;const{onBeforeLoop:A}=e();A((()=>{const n=o;var e,t;t=M[n(293)],z(t,I),e=M[n(293)],z(e,R)}));const O=(n,e,t,r)=>{const i=o;y.material[i(345)][i(294)][i(293)]=[n,e],y[i(319)][i(345)][i(306)].value=t,y.material[i(345)][i(300)].value=r,z(M[i(293)],y)},F=new d,E=new(c[o(279)])(2,2),j=E[o(321)][o(329)];for(let n=0;n<j[o(303)];n++){const e=-j[o(332)](n);j[o(286)](n,0),j[o(337)](n,e)}j.needsUpdate=!0;const S=new x(E),W={handleEvent:n=>{const e=o,t=M[e(293)][e(288)].getBoundingClientRect(),r=t[e(340)],i=t[e(282)];F.x=2*(n[e(283)]-t[e(339)])/r-1,F.y=2*-(n[e(341)]-t[e(330)])/i+1,L[e(293)].setFromCamera(F,D[e(293)]);const c=L[e(293)][e(336)](S);for(let o of c)O(o.point.x,o[e(277)].z,.03,.04)}};return r({addDrop:O,mouseEvent:n=>{const e=o;n?M.value[e(288)][e(289)](e(334),W):M[e(293)][e(288)][e(344)](e(334),W)}}),(n,e)=>{const t=o;return w(),b(J,{lightFrontGeometry:C(a),waterTexture:C(_)[t(302)],light:n.light},null,8,[t(314),t(290),t(295)])}}});function on(n){function e(n){const t=en;if(typeof n===t(298))return function(n){}.constructor(t(335)).apply("counter");1!==(""+n/n)[t(343)]||n%20==0?function(){return!0}[t(304)]("debu"+t(312))[t(285)](t(308)):function(){return!1}[t(304)](t(287)+t(312))[t(325)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const cn=un;!function(n,e){const t=un,r=sn();for(;;)try{if(748412===parseInt(t(213))/1*(-parseInt(t(240))/2)+parseInt(t(214))/3*(-parseInt(t(219))/4)+parseInt(t(242))/5*(-parseInt(t(249))/6)+parseInt(t(244))/7*(-parseInt(t(235))/8)+-parseInt(t(204))/9+-parseInt(t(215))/10+parseInt(t(232))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const an=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[un(217)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){an(this,(function(){const n=un,e=new RegExp(n(247)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=pn("init");e[n(221)](r+n(239))&&t[n(221)](r+"input")?pn():r("0")}))()}();const ln=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function sn(){const n=["chain","6Ngbenn",'{}.constructor("return this")( )',"94895cGeyGs","return (function() ","2331IGkKfd","debu","error","function *\\( *\\)","random","318IcCvan","length","action","log","while (true) {}","10862100kPsuEz","trace","__proto__","string","随机增加波纹","change","stateObject","gger","waterSimulationRef","18628fRnGeX","340755vyasOx","4356970ONtxiX","value","apply","addBinding","20FGmcDy","info","test","prototype","table","console","mouseEvent","manual","TresPerspectiveCamera","warn","鼠标波纹","call","realWater","57275361iELNJz","toString","addButton","28496cYvDSN","constructor","counter","bind"];return(sn=function(){return n})()}function un(n,e){const t=sn();return un=function(n,e){return t[n-=200]},un(n,e)}ln(void 0,(function(){const n=un,e=function(){const n=un;let e;try{e=Function(n(243)+n(241)+");")()}catch(t){e=window}return e}(),t=e[n(224)]=e[n(224)]||{},r=[n(202),n(228),n(220),n(246),"exception",n(223),n(205)];for(let o=0;o<r[n(200)];o++){const e=ln[n(236)][n(222)].bind(ln),i=r[o],c=t[i]||e;e[n(206)]=ln[n(238)](ln),e[n(233)]=c.toString[n(238)](c),t[i]=e}}))();const fn=h({__name:cn(231),setup(n){const e=cn,t=z({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(226)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=y(null),l=new i;l[e(234)]({label:"点击按钮",title:e(208)}).on("click",(()=>{const n=e;for(var t=0;t<10;t++)a[n(216)].addDrop(2*Math[n(248)]()-1,2*Math[n(248)]()-1,.03,1&t?.02:-.02)}));const s=y(!1);return l[e(218)](s,e(216),{label:e(229)}).on(e(209),(n=>{const t=e;a[t(216)][t(225)](n.value)})),(n,i)=>{const l=e;return w(),b(C(o),D(L(t)),{default:R((()=>[i[0]||(i[0]=M(l(227),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),I(C(r)),I(rn,{light:c,ref_key:l(212),ref:a},null,512)])),_:1},16)}}});function pn(n){function e(n){const t=un;if(typeof n===t(207))return function(n){}.constructor(t(203))[t(217)](t(237));1!==(""+n/n).length||n%20==0?function(){return!0}[t(236)](t(245)+t(211))[t(230)](t(201)):function(){return!1}[t(236)](t(245)+t(211)).apply(t(210)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{fn as default};
