import{m as n,e,a as t,o as r,f as o}from"./@tresjs.oW7bfow21742297875262.js";import{P as i}from"./tweakpane.yDiyAAkA1742297875262.js";import{_ as c,c as a,C as l,W as s,O as u,s as f,o as p,aW as v,r as g}from"./three.N4lg2KsY1742297875262.js";import{d as x,a3 as d,b as h,o as m,f as y,u as w,g as b,j as C,al as R,r as I,N as _,aj as M,ak as z}from"./@vue.NRI7TcgI1742297875262.js";import"./postprocessing.9PKUyDJ51742297875262.js";import"./@vueuse.Y8_DCJgq1742297875262.js";var D="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";!function(n,e){const t=A,r=F();for(;;)try{if(971765===-parseInt(t(402))/1*(parseInt(t(424))/2)+parseInt(t(400))/3*(-parseInt(t(414))/4)+parseInt(t(423))/5*(-parseInt(t(427))/6)+-parseInt(t(399))/7*(parseInt(t(425))/8)+parseInt(t(403))/9+-parseInt(t(416))/10+parseInt(t(434))/11*(parseInt(t(429))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[A(415)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function A(n,e){const t=F();return(A=function(n,e){return t[n-=390]})(n,e)}!function(){T(this,(function(){const n=A,e=new RegExp("function *\\( *\\)"),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=j(n(419));e[n(395)](r+n(432))&&t[n(395)](r+n(397))?j():r("0")}))()}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[A(415)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function F(){const n=["debu","waterTexture","RawShaderMaterial","water","tiles","gger","exception","setAttribute","error","test","position","input","warn","6510511iBiGjr","12jJlPoD","value","3867WfueMX","7773363qkpvsq","stateObject","log","bind","length","render","uniforms","console","causticsTexture","return (function() ","prototype","184020dNWuJu","apply","13964430jWAPnJ","info","BufferGeometry","init","causticTex","setIndex","toString","5AAbxGs","892iVvXvV","8OFarnF","Mesh","8254242SgzTeP","while (true) {}","12KydMPX","light","constructor","chain","FrontSide","62908813iByfYT","counter"];return(F=function(){return n})()}L(void 0,(function(){const n=A;let e;try{e=Function(n(412)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(410)]=e[n(410)]||{},r=[n(405),n(398),n(417),n(394),n(392),"table","trace"];for(let i=0;i<r[n(407)];i++){const e=L[n(431)][n(413)].bind(L),o=r[i],c=t[o]||e;e.__proto__=L[n(406)](L),e[n(422)]=c[n(422)][n(406)](c),t[o]=e}}))();const O=x({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=A,o=t,i=new(c[r(418)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(393)](r(396),new a(l,3)),i[r(421)](new a(s,1));const u=new(c[r(438)])({uniforms:{light:{value:o[r(430)]},tiles:{value:o[r(390)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(433)]}),f=new(c[r(426)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{const n=r;((n,e)=>{const t=r;u[t(409)][t(439)][t(401)]=n,u[t(409)][t(420)][t(401)]=e,p[t(401)][t(408)](f,v[t(401)])})(o[n(437)],o[n(411)])})),(n,e)=>null}});function j(n){function e(n){const t=A;if("string"==typeof n)return function(n){}[t(431)](t(428))[t(415)](t(435));1!==(""+n/n)[t(407)]||n%20==0?function(){return!0}[t(431)](t(436)+t(391)).call("action"):function(){return!1}[t(431)](t(436)+"gger").apply(t(404)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const S=P;!function(n,e){const t=P,r=V();for(;;)try{if(531390===parseInt(t(337))/1*(parseInt(t(382))/2)+-parseInt(t(384))/3+parseInt(t(323))/4+-parseInt(t(353))/5*(-parseInt(t(379))/6)+-parseInt(t(356))/7*(-parseInt(t(340))/8)+-parseInt(t(338))/9*(-parseInt(t(346))/10)+-parseInt(t(341))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(365)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){W(this,(function(){const n=P,e=new RegExp(n(360)),t=new RegExp(n(330),"i"),r=k(n(332));e.test(r+n(339))&&t[n(342)](r+n(350))?k():r("0")}))()}();const E=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(365)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function P(n,e){const t=V();return(P=function(n,e){return t[n-=322]})(n,e)}function V(){const n=["RawShaderMaterial","toString","stateObject","clear","table","action","load","console","924522yjSlyY","while (true) {}","light","120JwyLYn","gger","1817445FTfQoH","error","trace","uniforms","neg-x.jpg","warn","render","1791268axJrzm","/images/skyBox/6jpg/","neg-z.jpg","bind","underwater","side","Mesh","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","BackSide","init","CubeTextureLoader","pos-z.jpg","exception","waterTexture","13469wIHukl","747RqnFGt","chain","32tNYobI","22463760besBSR","test","setPath","return (function() ","debu","122350pgUMRf","causticTex","causticsTexture","setClearColor","input","water","value","25CMZWcO","prototype","resource.cos","240569jffAHR","tiles","constructor","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com","function *\\( *\\)","__proto__","pos-y.jpg","FrontSide","call","apply","neg-y.jpg","info","counter","length","geometry"];return(V=function(){return n})()}E(void 0,(function(){const n=P,e=function(){const n=P;let e;try{e=Function(n(344)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(378)]=e[n(378)]||{},r=["log",n(389),n(367),n(385),n(335),n(375),n(386)];for(let o=0;o<r[n(369)];o++){const e=E[n(358)][n(354)][n(326)](E),i=r[o],c=t[i]||e;e[n(361)]=E.bind(E),e[n(372)]=c[n(372)][n(326)](c),t[i]=e}}))();const N=x({__name:S(351),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=S;let i,a;const s=r,u=s[o(370)],f=(new(c[o(333)]))[o(343)](o(359)+o(324))[o(377)](["pos-x.jpg",o(388),o(362),o(366),o(334),o(325)]),p=([i,a]=d((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),v=new(c[o(371)])({uniforms:{light:{value:s[o(381)]},tiles:{value:p},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),g=new(c[o(329)])(u,v),x=h(null),b=new l("white"),{renderer:C,camera:R}=n(),{onLoop:I}=e();return I((()=>{const n=o;C[n(352)].setRenderTarget(null),C[n(352)][n(349)](b,1),C[n(352)][n(374)](),v.uniforms[n(351)].value=s.waterTexture,v[n(387)][n(347)][n(352)]=s[n(348)],v[n(328)]=c[n(363)],v.uniforms[n(327)][n(352)]=!0,C.value[n(322)](g,R[n(352)]),v[n(328)]=c[n(331)],v[n(387)][n(327)].value=!1,C.value[n(322)](g,R[n(352)])})),(n,e)=>{const t=o;return m(),y(O,{tiles:w(p),light:n[t(381)],waterTexture:n[t(336)],causticsTexture:n[t(348)],ref_key:"pooRef",ref:x},null,8,[t(357),t(381),"waterTexture",t(348)])}}});function k(n){function e(n){const t=P;if("string"==typeof n)return function(n){}.constructor(t(380)).apply(t(368));1!==(""+n/n).length||n%20==0?function(){return!0}[t(358)](t(345)+t(383))[t(364)](t(376)):function(){return!1}[t(358)]("debu"+t(383))[t(365)](t(373)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function H(){const n=["warn","info","OrthographicCamera",'{}.constructor("return this")( )',"test","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","render","action","137706DVdyNC","Mesh","128430QGXtzO","waterTexture","causticsTexture","caustics","water","string","uniforms","value","toString","__proto__","Color","bind","5YohbGX","call","setClearColor","function *\\( *\\)","black","stateObject","return (function() ","length","clear","material","constructor","console","log","PlaneGeometry","940236NsctJa","error","279KnnCMN","geometry","exception","init","764712iDwDJF","207260wfjfWE","gger","counter","28PAPxXr","ShaderMaterial","922088fQPHDs","134916GNbntN","debu","apply","light"];return(H=function(){return n})()}const G=J;!function(n,e){const t=J,r=H();for(;;)try{if(239252===-parseInt(t(143))/1+-parseInt(t(171))/2+-parseInt(t(145))/3+-parseInt(t(177))/4+-parseInt(t(157))/5*(parseInt(t(131))/6)+parseInt(t(181))/7*(parseInt(t(130))/8)+parseInt(t(173))/9*(parseInt(t(178))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[J(133)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Z(this,(function(){const n=J,e=new RegExp(n(160)),t=new RegExp(n(140),"i"),r=$(n(176));e.test(r+"chain")&&t[n(139)](r+"input")?$():r("0")}))()}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[J(133)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function J(n,e){const t=H();return(J=function(n,e){return t[n-=130]})(n,e)}B(void 0,(function(){const n=J,e=function(){const n=J;let e;try{e=Function(n(163)+n(138)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(168)]||{},r=[n(169),n(135),n(136),n(172),n(175),"table","trace"];for(let o=0;o<r[n(164)];o++){const e=B.constructor.prototype[n(156)](B),i=r[o],c=t[i]||e;e[n(154)]=B[n(156)](B),e[n(153)]=c[n(153)][n(156)](c),t[i]=e}}))();const Y=x({__name:G(148),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=G,o=t,i=new(c[r(137)])(0,1,1,0,0,2e3),a=new(c[r(170)])(2,2,200,200),l=new s(1024,1024),u=new(c[r(182)])({uniforms:{light:{value:o.light},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),f=new(c[r(144)])(a,u),p=new(c[r(155)])(r(161)),{renderer:v}=n(),{onBeforeLoop:g}=e();return g((()=>{const n=r;f[n(166)][n(151)][n(149)][n(152)]=o[n(146)],v[n(152)].setRenderTarget(l),v.value[n(159)](p,0),v.value[n(165)](),v[n(152)][n(141)](f,i)})),(n,e)=>{const t=r;return m(),y(R,null,{default:b((()=>[C(N,{waterTexture:n.waterTexture,causticsTexture:w(l).texture,light:n.light,geometry:w(a)},null,8,[t(146),t(147),t(134),t(174)])])),_:1})}}});function $(n){function e(n){const t=J;if(typeof n===t(150))return function(n){}[t(167)]("while (true) {}")[t(133)](t(180));1!==(""+n/n)[t(164)]||n%20==0?function(){return!0}[t(167)]("debu"+t(179))[t(158)](t(142)):function(){return!1}[t(167)](t(132)+t(179))[t(133)](t(162)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const q=K;!function(n,e){const t=K,r=U();for(;;)try{if(559561===parseInt(t(464))/1+parseInt(t(477))/2*(parseInt(t(506))/3)+-parseInt(t(475))/4+parseInt(t(508))/5+-parseInt(t(482))/6*(-parseInt(t(459))/7)+-parseInt(t(481))/8*(-parseInt(t(507))/9)+-parseInt(t(483))/10*(parseInt(t(511))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const X=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[K(510)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function U(){const n=["addEventListener","330633hMOFyJ","stateObject","exception","setY","toString","attributes","warn","waterSimulation","getY","console","length","1356476tnxlZD","log","956gMnWJc","gger","string","height","136CFxWen","76452MeCJiw","2760420xYeUpe","lightFrontGeometry","domElement",'{}.constructor("return this")( )',"chain","FloatType","trace","bind","left","removeEventListener","clientX","needsUpdate","WebGLRenderTarget","width","init","center","RawShaderMaterial","while (true) {}","material","render","action","test","Mesh","3639UqJyTt","350613FmVerN","748520GfnpyZ","value","apply","77rxduFE","call","waterTexture","Vector2","uniforms","setFromCamera","PlaneGeometry","table","info","setRenderTarget","radius","error","clientY","setZ","input","point","counter","609VQRmTN","constructor","texture","debu"];return(U=function(){return n})()}!function(){X(this,(function(){const n=K,e=new RegExp("function *\\( *\\)"),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=en(n(497));e[n(504)](r+n(487))&&t.test(r+n(456))?en():r("0")}))()}();const Q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function K(n,e){const t=U();return(K=function(n,e){return t[n-=445]})(n,e)}Q(void 0,(function(){const n=K,e=function(){const n=K;let e;try{e=Function("return (function() "+n(486)+");")()}catch(t){e=window}return e}(),t=e[n(473)]=e[n(473)]||{},r=[n(476),n(470),n(450),n(453),n(466),n(449),n(489)];for(let o=0;o<r.length;o++){const e=Q.constructor.prototype[n(490)](Q),i=r[o],c=t[i]||e;e.__proto__=Q[n(490)](Q),e.toString=c[n(468)][n(490)](c),t[i]=e}}))();const nn=x({__name:q(471),props:{light:{}},setup(t,{expose:r}){const o=q,i=new u(0,1,1,0,0,2e3),a=new f(2,2),l=new(c[o(495)])(256,256,{type:c[o(488)]}),s=new(c[o(495)])(256,256,{type:p}),x=new(c[o(499)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),d=new(c[o(499)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),h=new v({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),b=new(c[o(505)])(a,x),C=new g(a,d),R=new(c[o(505)])(a,h);let I=l;const _=(n,e)=>{const t=o,r=I,c=I===l?s:l;e[t(501)][t(446)][t(461)][t(509)]=r.texture,n[t(451)](c),n[t(502)](e,i),I=c},{renderer:M,camera:z,raycaster:T}=n();M[o(509)].autoClear=!1;const{onBeforeLoop:A}=e();A((()=>{const n=o;var e,t;t=M[n(509)],_(t,R),e=M[n(509)],_(e,C)}));const L=(n,e,t,r)=>{const i=o;b[i(501)][i(446)][i(498)][i(509)]=[n,e],b[i(501)][i(446)][i(452)].value=t,b[i(501)][i(446)].strength.value=r,_(M[i(509)],b)},F=new(c[o(445)]),O=new(c[o(448)])(2,2),j=O[o(469)].position;for(let n=0;n<j.count;n++){const e=-j[o(472)](n);j[o(467)](n,0),j[o(455)](n,e)}j[o(494)]=!0;const S=new(c[o(505)])(O),W={handleEvent:n=>{const e=o,t=M[e(509)][e(485)].getBoundingClientRect(),r=t[e(496)],i=t[e(480)];F.x=2*(n[e(493)]-t[e(491)])/r-1,F.y=2*-(n[e(454)]-t.top)/i+1,T.value[e(447)](F,z[e(509)]);const c=T[e(509)].intersectObject(S);for(let o of c)L(o[e(457)].x,o[e(457)].z,.03,.04)}};return r({addDrop:L,mouseEvent:n=>{const e=o;n?M.value[e(485)][e(463)]("mousemove",W):M[e(509)][e(485)][e(492)]("mousemove",W)}}),(n,e)=>{const t=o;return m(),y(Y,{lightFrontGeometry:w(a),waterTexture:w(I).texture,light:n.light},null,8,[t(484),t(513),"light"])}}});function en(n){function e(n){const t=K;if(typeof n===t(479))return function(n){}[t(460)](t(500))[t(510)](t(458));1!==(""+n/n)[t(474)]||n%20==0?function(){return!0}.constructor(t(462)+t(478))[t(512)](t(503)):function(){return!1}[t(460)](t(462)+t(478))[t(510)](t(465)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const tn=rn;function rn(n,e){const t=an();return(rn=function(n,e){return t[n-=257]})(n,e)}!function(n,e){const t=rn,r=an();for(;;)try{if(578508===-parseInt(t(279))/1+parseInt(t(271))/2*(-parseInt(t(295))/3)+parseInt(t(265))/4*(parseInt(t(281))/5)+-parseInt(t(288))/6+-parseInt(t(298))/7*(-parseInt(t(259))/8)+parseInt(t(262))/9*(parseInt(t(277))/10)+parseInt(t(270))/11*(-parseInt(t(275))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const on=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[rn(300)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){on(this,(function(){const n=rn,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(280),"i"),r=sn(n(294));e[n(285)](r+n(257))&&t[n(285)](r+n(296))?sn():r("0")}))()}();const cn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[rn(300)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function an(){const n=["init","9uGVMMc","input","change","2709shvURX","随机增加波纹","apply","action",'{}.constructor("return this")( )',"chain","mouseEvent","17112DPSfjt","counter","addButton","2403PQnkJz","value","waterSimulationRef","3782316LyuUTW","manual","stateObject","log","debu","6246537DqCmUV","429370CXNYBM","__proto__","realWater","length","12pYSEeu","console","19970Vpsmou","gger","457353mxBfAx","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","5xLYHff","while (true) {}","info","table","test","click","trace","352728qvVPyb","toString","bind","TresPerspectiveCamera","constructor","return (function() "];return(an=function(){return n})()}cn(void 0,(function(){const n=rn;let e;try{e=Function(n(293)+n(302)+");")()}catch(o){e=window}const t=e.console=e[n(276)]||{},r=[n(268),"warn",n(283),"error","exception",n(284),n(287)];for(let i=0;i<r[n(274)];i++){const e=cn[n(292)].prototype[n(290)](cn),o=r[i],c=t[o]||e;e[n(272)]=cn[n(290)](cn),e.toString=c[n(289)][n(290)](c),t[o]=e}}))();const ln=x({__name:tn(273),setup(n){const e=tn,t=I({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(266)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=h(null),l=new i;l[e(261)]({label:"点击按钮",title:e(299)}).on(e(286),(()=>{const n=e;for(var t=0;t<10;t++)a[n(263)].addDrop(2*Math.random()-1,2*Math.random()-1,.03,1&t?.02:-.02)}));const s=h(!1);return l.addBinding(s,e(263),{label:"鼠标波纹"}).on(e(297),(n=>{const t=e;a[t(263)][t(258)](n[t(263)])})),(n,i)=>{const l=e;return m(),y(w(o),M(z(t)),{default:b((()=>[i[0]||(i[0]=_(l(291),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),C(w(r)),C(nn,{light:c,ref_key:l(264),ref:a},null,512)])),_:1},16)}}});function sn(n){function e(n){const t=rn;if("string"==typeof n)return function(n){}[t(292)](t(282))[t(300)](t(260));1!==(""+n/n).length||n%20==0?function(){return!0}[t(292)](t(269)+t(278)).call(t(301)):function(){return!1}.constructor("debu"+t(278))[t(300)](t(267)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{ln as default};
