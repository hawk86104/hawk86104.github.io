import{a6 as n,bR as t,C as o}from"./three.VTQVqxMx1725416517797.js";import{$ as e}from"./@tresjs.5lh7VmqZ1725416517797.js";import{g as r}from"./utils.CfHZ88O81725416517797.js";import{d as i,b as s,a2 as a,o as c,E as u,L as l,u as f,aj as p,ak as v}from"./@vue._6MD2XyK1725416517797.js";const m=w;!function(n,t){const o=w,e=g();for(;;)try{if(382550===parseInt(o(376))/1+parseInt(o(350))/2*(parseInt(o(384))/3)+parseInt(o(336))/4*(parseInt(o(397))/5)+parseInt(o(344))/6*(-parseInt(o(338))/7)+-parseInt(o(377))/8*(parseInt(o(388))/9)+parseInt(o(374))/10*(parseInt(o(371))/11)+parseInt(o(343))/12*(-parseInt(o(386))/13))break;e.push(e.shift())}catch(r){e.push(e.shift())}}();const d=function(){let n=!0;return function(t,o){const e=n?function(){if(o){const n=o[w(339)](t,arguments);return o=null,n}}:function(){};return n=!1,e}}();!function(){d(this,(function(){const n=w,t=new RegExp(n(366)),o=new RegExp(n(359),"i"),e=I(n(389));t[n(369)](e+"chain")&&o[n(369)](e+n(379))?I():e("0")}))()}();const y=function(){let n=!0;return function(t,o){const e=n?function(){if(o){const n=o.apply(t,arguments);return o=null,n}}:function(){};return n=!1,e}}();y(void 0,(function(){const n=w;let t;try{t=Function(n(375)+n(363)+");")()}catch(r){t=window}const o=t[n(390)]=t[n(390)]||{},e=[n(385),n(347),n(349),n(353),n(393),n(365),n(381)];for(let i=0;i<e[n(395)];i++){const t=y[n(346)][n(345)].bind(y),r=e[i],s=o[r]||t;t[n(354)]=y.bind(y),t.toString=s[n(380)].bind(s),o[r]=t}}))();const h=[m(373),"uv"];function g(){const n=["pv2","2585165raBlJE","color","position","30VXZyjH","return (function() ","684787FwbJoq","668144cJpvAn","action","input","toString","trace","DoubleSide","debu","557709nrazuJ","log","44720jNBdYB","#ffff00","9lAciFG","init","console","speed","ShaderChunk","exception","uniforms","length","value","30ELBCNE","\nprecision lowp float;\nprecision lowp int;\n","374084eJGqpI","opacity","168LghIIF","apply","num","\n}\n","TresShaderMaterial","5196qUUjjs","91794HUUPbS","prototype","constructor","warn","fog_vertex","info","4WBDCRu","\nvarying vec2 vUv;\nvoid main() {\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    ","TresMesh","error","__proto__","stateObject","set","gger","fog_pars_vertex","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","string","Color","counter",'{}.constructor("return this")( )',"height","table","function *\\( *\\)","uvs","\n  precision lowp float;\n  precision lowp int;\n  uniform float time;\n  uniform float opacity;\n  uniform vec3 color;\n  uniform float num;\n  uniform float speed;\n  varying vec2 vUv;\n  void main() {\n    vec4 fragColor = vec4(0.);\n    float sin = sin((vUv.y - time * speed) * 10. * num);\n    float high = 0.92;\n    float medium = 0.4;\n    if (sin > high) {\n      fragColor = vec4(mix(vec3(.8, 1., 1.), color, (1. - sin) / (1. - high)), 1.);\n    } else if(sin > medium) {\n      fragColor = vec4(color, mix(1., 0., 1.-(sin - medium) / (high - medium)));\n    } else {\n      fragColor = vec4(color, 0.);\n    }\n    vec3 fade = mix(color, vec3(0., 0., 0.), vUv.y);\n    fragColor = mix(fragColor, vec4(fade, 1.), 0.85);\n    gl_FragColor = vec4(fragColor.rgb, fragColor.a * opacity * (1. - vUv.y));\n  }\n\t","test"];return(g=function(){return n})()}const x=i({__name:"rippleMesh",props:{positionSrc:{default:[{x:0,y:0},{x:10,y:10}]},color:{default:m(387)},opacity:{default:.8},height:{default:100},num:{default:8},speed:{default:.15}},setup(i){const d=m,y=i,g=s(),x={side:n[d(382)],transparent:!0,depthWrite:!1,depthTest:!0,vertexShader:d(335)+t[d(358)]+d(351)+n[d(392)][d(348)]+d(341),fragmentShader:d(368),uniforms:{time:{type:d(370),value:0},color:{type:d(367),value:new o(y[d(372)])},opacity:{type:d(370),value:y[d(337)]},num:{type:d(370),value:y[d(340)]},speed:{type:"pv2",value:y[d(391)]}}};let w=null,I=null;const{centerPoint:_,points:b}=r(y.positionSrc);!function(n=[],t){const o=d,e=[],r=[];for(let i=0,s=e[o(395)],a=r.length;i<n[o(395)]-1;i++){let o=1,c=n[i],u=n[i+1];e[s++]=c.x,e[s++]=0,e[s++]=c.y,r[a++]=0,r[a++]=0,e[s++]=u.x,e[s++]=0,e[s++]=u.y,r[a++]=1,r[a++]=0,e[s++]=c.x,e[s++]=t,e[s++]=c.y,r[a++]=0,r[a++]=o,e[s++]=c.x,e[s++]=t,e[s++]=c.y,r[a++]=0,r[a++]=o,e[s++]=u.x,e[s++]=0,e[s++]=u.y,r[a++]=1,r[a++]=0,e[s++]=u.x,e[s++]=t,e[s++]=u.y,r[a++]=1,r[a++]=o}w=new Float32Array(e),I=new Float32Array(r)}(b,y[d(364)]);const{onLoop:C}=e();return C((({delta:n})=>{const t=d;x.uniforms.time[t(396)]+=n})),a((()=>{const t=d;y[t(372)]&&(x[t(394)].color[t(396)]=new(n[t(361)])(y[t(372)])),y[t(337)]&&(x[t(394)][t(337)][t(396)]=y.opacity),y[t(340)]&&(x[t(394)][t(340)][t(396)]=y.num),y[t(391)]&&(x.uniforms[t(391)].value=y[t(391)]),g.value&&g[t(396)][t(373)][t(356)](_.x,g.value[t(373)].y,_.y)})),(n,t)=>{const o=d;return c(),u(o(352),{renderOrder:2200,ref_key:"tresMeshRef",ref:g},[l("TresBufferGeometry",{position:[f(w),3],uv:[f(I),2]},null,8,h),l(o(342),p(v(x)),null,16)],512)}}});function w(n,t){const o=g();return(w=function(n,t){return o[n-=335]})(n,t)}function I(n){function t(n){const o=w;if(typeof n===o(360))return function(n){}[o(346)]("while (true) {}")[o(339)](o(362));1!==(""+n/n)[o(395)]||n%20==0?function(){return!0}[o(346)](o(383)+o(357)).call(o(378)):function(){return!1}[o(346)]("debu"+o(357)).apply(o(355)),t(++n)}try{if(n)return t;t(0)}catch(o){}}export{x as _};
