import{importShared as e}from"./3d-tiles-renderer.COLnOnaF1767661981680.js";import{LineGeometry as o,Line2 as t}from"./Line2.CYLGnuRy1767661981680.js";import{LineMaterial as n}from"./LineSegments2.CvvRfaG51767661981680.js";import{resetUV as r}from"./utils.JK7L2jsz1767661981680.js";const{defineComponent:i}=await e("vue"),{unref:a,createElementVNode:l,openBlock:c,createElementBlock:v}=await e("vue"),s=["object","rotation-x"],m=["object","rotation-x"],p=await e("three"),{watchEffect:d}=await e("vue"),f=i({__name:"regionGlow",props:{positionSrc:{default:[[0,0],[1,1]]},color:{default:"#ffff00"}},setup(e){const i=e,f=new p.Shape;i.positionSrc.forEach((e,o)=>{0===o?f.moveTo(e[0],e[1]):f.lineTo(e[0],e[1])});const u=new p.ShaderMaterial({vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    varying vec2 vUv;\n\t\tuniform vec3 color;\n    void main() {\n\t\t\t// 计算距离四条边的最小距离\n        float distance = max(max(vUv.x, -vUv.x), max(vUv.y, -vUv.y));\n\n        // 将距离映射到透明度（从边缘到中心逐渐变透明）\n        float alpha = smoothstep(0.1, 0.9, distance*1.1);\n\n        // 设置最终颜色和透明度\n        gl_FragColor = vec4(color, alpha);\n    }\n  ",transparent:!0,side:p.DoubleSide,depthWrite:!1,depthTest:!0,uniforms:{color:{type:"uvs",value:new p.Color(i.color)}}});let w=new p.ShapeGeometry(f);r(w,!0);const h=new p.Mesh(w,u),x=f.getPoints(),g=new o;g.setPositions(x.flatMap(e=>[e.x,e.y,0]));var j=new n({color:new p.Color(i.color),linewidth:2});const S=new t(g,j);return d(()=>{u.uniforms.color.value=new p.Color(i.color),j.color=new p.Color(i.color)}),(e,o)=>(c(),v("TresGroup",null,[l("primitive",{object:a(h),renderOrder:9999,"rotation-x":Math.PI/2},null,8,s),l("primitive",{object:a(S),renderOrder:9999,"rotation-x":Math.PI/2},null,8,m)]))}});export{f as _sfc_main};
