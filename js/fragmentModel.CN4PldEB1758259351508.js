import{e as o,k as a,b as e,a as n}from"./@tresjs.CywMBpUh1758259351508.js";import{V as t,c as r,C as s,l as i,cq as l,Y as c}from"./three.CtgP63ME1758259351508.js";import{P as m}from"./tweakpane.C0HtAJSg1758259351508.js";import{d as u,aa as v,r as p,b as d,w as g,G as x,o as f,I as y,a7 as b,a8 as w,u as C,h as P,e as h,f as z,j as _,a5 as M}from"./@vue.pEDXJ_3Z1758259351508.js";import"./postprocessing.DJgHFhS91758259351508.js";import"./@vueuse.C5HLo59K1758259351508.js";const A=["geometry"],D=u({__name:"fragmentModelCom",async setup(n){let c,u;const P=o=>{const a=[];return o.traverse((o=>{o instanceof i&&(o.geometry.deleteAttribute("uv"),o.geometry.deleteAttribute("tangent"),a.push(o.geometry))})),l(a)},h=P(([c,u]=v((()=>a("https://opensource.cdn.icegl.cn/model/eCommerce/guanYu.glb",{draco:!0,decoderPath:"./draco/"}))),c=await c,u(),c).scene.children[0]);h.rotateX(Math.PI/2),h.translate(0,-.9,0);const z=h.clone().toNonIndexed(),_=P(([c,u]=v((()=>a("https://opensource.cdn.icegl.cn/model/industry4/modelDraco.glb",{draco:!0,decoderPath:"./draco/"}))),c=await c,u(),c).scene.children[0]);_.rotateX(-Math.PI/2),_.rotateY(Math.PI/3);const M=_.clone().toNonIndexed(),D=z.attributes.position.array,N=z.attributes.position.count,j=M.attributes.position.array,V=M.attributes.normal.array,I=M.attributes.position.count,R=new Float32Array(N),F=new Float32Array(3*(N+2)),S=new Float32Array(3*(N+2)),T=new Float32Array(3*(N+2));for(let o=0;o<N;o+=3){const a=1*Math.random(),e=o%I;R[o]=a,R[o+1]=a,R[o+2]=a;const n=3*o,r=D[n],s=D[n+1],i=D[n+2],l=D[n+3],c=D[n+4],m=D[n+5],u=D[n+6],v=D[n+7],p=D[n+8],d=new t(r+l+u,s+c+v,i+m+p).divideScalar(3);F.set([d.x,d.y,d.z],3*o),F.set([d.x,d.y,d.z],3*(o+1)),F.set([d.x,d.y,d.z],3*(o+2));const g=(o,a,e)=>{const n=3*e;for(let t=0;t<3;t++){const r=n+3*t;a.set([o[r],o[r+1],o[r+2]],3*(e+t))}};g(j,S,e),g(V,T,e)}z.setAttribute("aRandom",new r(R,1)),z.setAttribute("aCenter",new r(F,3)),z.setAttribute("toPosition",new r(S,3)),z.setAttribute("toNormal",new r(T,3)),console.log(z.attributes);const B=([c,u]=v((()=>e(["./plugins/visualArts/image/fragment512px.png"]))),c=await c,u(),c),U={uniforms:{u_progress:{value:-.1},matcap1:{value:B},m1Color:{type:"v3",value:new s("#ffc0fa")},matcap2:{value:B},m2Color:{type:"v3",value:new s("#bcd4ff")}},vertexShader:"varying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\n\nattribute vec3 aCenter;\nattribute vec3 toPosition;\nattribute vec3 toNormal;\nattribute float aRandom;\n\nuniform float u_progress;\n\n#include <common>\n\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n      oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,\n      oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,\n      oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n      oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s,\n      oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\nvoid main() {\n  vUv = uv;\n\n  float progress = u_progress;\n  float sinProgress = sin(progress * PI);\n\n  vec3 pos = mix(position, toPosition, progress);\n  vec3 nor = mix(normal, toNormal, progress);\n\n  vNormal = normalMatrix * normalize(nor);\n\n  float prog = ((pos.y + 1.) / 2.) * 1.1;\n\n  float locprog = clamp((sinProgress - 0.9 * prog) / 0.2, 0., 1.);\n\n  vec3 transform = pos - aCenter;\n\n  transform += 3. * aRandom * nor * locprog;\n\n  transform *= (1.0 - locprog);\n\n  transform += aCenter;\n\n  mat4 rotation = rotation3d(vec3(0., 1., 0.), aRandom * (locprog)*PI * 3.);\n\n  transform = (rotation * vec4(transform, 1.)).xyz;\n\n  vec4 modelViewPosition = modelViewMatrix * vec4(transform, 1.0);\n\n  gl_Position = projectionMatrix * modelViewPosition;\n\n  vViewPosition = -modelViewPosition.xyz;\n}",fragmentShader:"varying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vViewPosition;\nuniform sampler2D matcap;\nuniform sampler2D matcap2;\nuniform float u_progress;\nuniform vec3 m1Color;\nuniform vec3 m2Color;\n\nvoid main() {\n  vec3 viewDir = normalize(vViewPosition);\n  vec3 x = normalize(vec3(viewDir.z, 0.0, -viewDir.x));\n  vec3 y = cross(viewDir, x);\n  vec2 uv = vec2(dot(x, vNormal), dot(y, vNormal)) * 0.495 + 0.5;\n\n  float progress = abs(sin(u_progress));\n\n  vec3 matcapColor = texture2D(matcap, uv).rgb;\n  matcapColor = mix(matcapColor, m1Color, 0.5);\n  vec3 matcap2Color = texture2D(matcap2, uv).rgb;\n  matcap2Color = mix(matcap2Color, m2Color, 0.5);\n\n  vec3 color = vec3(matcapColor);\n  color = mix(color, matcap2Color, progress);\n\n  gl_FragColor = vec4(color, 1.0);\n}"},Y=p({c1:"#ffc0fa",c2:"#bcd4ff"}),k=d(.5),L=new m({title:"参数"});return L.addBinding(U.uniforms.u_progress,"value",{label:"变化量",min:-.1,max:1,step:.001}).disabled=!0,L.addBinding(Y,"c1",{label:"颜色1st"}),L.addBinding(Y,"c2",{label:"颜色2rd"}),L.addBinding(k,"value",{label:"速度",min:.001,max:1,step:.001}),g(Y,(o=>{U.uniforms.m1Color.value.set(o.c1),U.uniforms.m2Color.value.set(o.c2)}),{deep:!0}),o().onLoop((({elapsed:o})=>{U.uniforms.u_progress.value=(Math.sin(o*k.value)+1)/2,L.refresh()})),(o,a)=>(f(),x("TresMesh",{geometry:C(z)},[y("TresShaderMaterial",b(w(U)),null,16)],8,A))}}),N=u({__name:"fragmentModel",setup(o){const a=p({enableDamping:!0,enableZoom:!0,autoRotate:!0,enablePan:!0,enableRotate:!0}),e={clearColor:"#000000",windowSize:!0,toneMapping:c,toneMappingExposure:.8};return(o,t)=>{const r=P("TresCanvas");return f(),h(r,b(w(e)),{default:z((()=>[t[0]||(t[0]=y("TresPerspectiveCamera",{position:[0,2,8],fov:45,near:.1,far:1e3},null,-1)),_(C(n),b(w(a)),null,16),t[1]||(t[1]=y("TresAmbientLight",{intensity:2},null,-1)),(f(),h(M,null,{default:z((()=>[_(D)])),_:1}))])),_:1},16)}}});export{N as default};
