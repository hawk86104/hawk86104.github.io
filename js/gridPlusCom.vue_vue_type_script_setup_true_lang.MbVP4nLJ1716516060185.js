var b=Object.defineProperty;var d=Object.getOwnPropertySymbols;var j=Object.prototype.hasOwnProperty,D=Object.prototype.propertyIsEnumerable;var m=(n,o,e)=>o in n?b(n,o,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[o]=e,r=(n,o)=>{for(var e in o||(o={}))j.call(o,e)&&m(n,e,o[e]);if(d)for(var e of d(o))D.call(o,e)&&m(n,e,o[e]);return n};import{az as l,b3 as a,bz as M,aw as F,b2 as B,b6 as V,b9 as E,a1 as I,a6 as N,o as W,c as A,L}from"./vendor.wPpJEadL1716516060185.js";import{s as O}from"./shaderMaterial.pdh9-Njp1716516060185.js";const R=O({cellSize:.5,sectionSize:1,fadeDistance:100,fadeStrength:1,cellThickness:.5,sectionThickness:1,cellColor:new l,sectionColor:new l,infiniteGrid:!1,followCamera:!1,worldCamProjPosition:new a,worldPlanePosition:new a},"\n      varying vec3 localPosition;\n      varying vec4 worldPosition;\n  \n      uniform vec3 worldCamProjPosition;\n      uniform vec3 worldPlanePosition;\n      uniform float fadeDistance;\n      uniform bool infiniteGrid;\n      uniform bool followCamera;\n  \n      void main() {\n        localPosition = position.xzy;\n        if (infiniteGrid) localPosition *= 1.0 + fadeDistance;\n        \n        worldPosition = modelMatrix * vec4(localPosition, 1.0);\n        if (followCamera) {\n          worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);\n          localPosition = (inverse(modelMatrix) * worldPosition).xyz;\n        }\n  \n        gl_Position = projectionMatrix * viewMatrix * worldPosition;\n      }\n    ","\n      varying vec3 localPosition;\n      varying vec4 worldPosition;\n  \n      uniform vec3 worldCamProjPosition;\n      uniform float cellSize;\n      uniform float sectionSize;\n      uniform vec3 cellColor;\n      uniform vec3 sectionColor;\n      uniform float fadeDistance;\n      uniform float fadeStrength;\n      uniform float cellThickness;\n      uniform float sectionThickness;\n  \n      float getGrid(float size, float thickness) {\n        vec2 r = localPosition.xz / size;\n        vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n        float line = min(grid.x, grid.y) + 1.0 - thickness;\n        return 1.0 - min(line, 1.0);\n      }\n  \n      void main() {\n        float g1 = getGrid(cellSize, cellThickness);\n        float g2 = getGrid(sectionSize, sectionThickness);\n  \n        float dist = distance(worldCamProjPosition, worldPosition.xyz);\n        float d = 1.0 - min(dist / fadeDistance, 1.0);\n        vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));\n  \n        gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));\n        gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\n        if (gl_FragColor.a <= 0.0) discard;\n  \n        #include <tonemapping_fragment>\n        #include <".concat(parseInt(E.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment",">\n      }\n    ")),$=({args:n=[1,1],cellColor:o=new l("#000000"),sectionColor:e=new l("#2080ff"),cellSize:i=.5,sectionSize:s=1,followCamera:u=!1,infiniteGrid:g=!1,fadeDistance:w=100,fadeStrength:P=1,cellThickness:C=.5,sectionThickness:h=1,side:p=V}={})=>{const z={cellSize:i,sectionSize:s,cellColor:o,sectionColor:e,cellThickness:C,sectionThickness:h},S={fadeDistance:w,fadeStrength:P,infiniteGrid:g,followCamera:u},v=new R(r(r({transparent:!0,side:p},z),S)),k=new M(n[0],n[1]),t=new F(k,v);t.frustumCulled=!1;const c=new B,x=new a(0,1,0),_=new a(0,0,0);return{mesh:t,update:T=>{if(!t.parent)return;c.setFromNormalAndCoplanarPoint(x,_).applyMatrix4(t.matrixWorld);const f=t.material,y=f.uniforms.worldCamProjPosition,G=f.uniforms.worldPlanePosition;c.projectPoint(T.position,y.value),G.value.set(0,0,0).applyMatrix4(t.matrixWorld)}}},q=["object"],U=I({__name:"gridPlusCom",props:{args:{default:[10,10]},cellColor:{default:"#6f6f6f"},cellSize:{default:.6},cellThickness:{default:1},sectionColor:{default:"#9d4b4b"},sectionSize:{default:3.3},sectionThickness:{default:1.5},fadeDistance:{default:25},fadeStrength:{default:1},followCamera:{type:Boolean,default:!1},infiniteGrid:{type:Boolean,default:!0}},setup(n){const o=n,e=$({args:o.args,cellSize:o.cellSize,cellThickness:o.cellThickness,cellColor:new l(o.cellColor),sectionSize:o.sectionSize,sectionThickness:o.sectionThickness,sectionColor:new l(o.sectionColor),fadeDistance:o.fadeDistance,fadeStrength:o.fadeStrength,followCamera:o.followCamera,infiniteGrid:o.infiniteGrid});return N(()=>{const i=e.mesh.material;i.cellSize=o.cellSize,i.cellThickness=o.cellThickness,i.cellColor.set(o.cellColor),i.sectionColor.set(o.sectionColor),i.sectionSize=o.sectionSize,i.sectionThickness=o.sectionThickness,i.fadeDistance=o.fadeDistance,i.fadeStrength=o.fadeStrength,i.followCamera=o.followCamera,i.infiniteGrid=o.infiniteGrid}),(i,s)=>(W(),A("primitive",{object:L(e).mesh},null,8,q))}});export{U as _};
