import{m as n,e,a as t,o as r,f as o}from"./@tresjs.gjafZgVK1741594518249.js";import{P as i}from"./tweakpane.yDiyAAkA1741594518249.js";import{_ as c,c as a,aW as l,r as s,W as u,o as f}from"./three.8y0_KTxz1741594518249.js";import{d as p,a3 as v,b as g,o as d,f as x,u as h,g as m,j as y,al as w,r as b,N as R,aj as C,ak as I}from"./@vue.NRI7TcgI1741594518249.js";import"./postprocessing.iiPTtJPW1741594518249.js";import"./@vueuse.8xnC6EWf1741594518249.js";var _="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const M=A;!function(n,e){const t=A,r=T();for(;;)try{if(976181===-parseInt(t(291))/1+parseInt(t(326))/2+parseInt(t(321))/3*(-parseInt(t(308))/4)+parseInt(t(324))/5*(parseInt(t(313))/6)+-parseInt(t(295))/7+-parseInt(t(290))/8+-parseInt(t(307))/9*(-parseInt(t(282))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[A(319)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){z(this,(function(){const n=A,e=new RegExp(n(309)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=O(n(304));e[n(310)](r+"chain")&&t[n(310)](r+n(280))?O():r("0")}))()}();const D=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[A(319)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function A(n,e){const t=T();return(A=function(n,e){return t[n-=278]})(n,e)}function T(){const n=["setAttribute","bind","BufferAttribute","pool","FrontSide","RawShaderMaterial","tiles","Mesh","init","toString","trace","1251hErlMA","892fUXRmP","function *\\( *\\)","test","exception","console","194610DzyoNX","__proto__","gger","render","waterTexture","position","apply","action","7707lPJlzG","uniforms","constructor","25hUOBBA","value","2083768aqiHSl","string","log","error","input","warn","338090RXgkMM","BufferGeometry","causticTex","stateObject",'{}.constructor("return this")( )',"setIndex","debu","while (true) {}","11628760YgdUbx","1444297nUiAsf","info","prototype","length","10195850tgFVPJ"];return(T=function(){return n})()}D(void 0,(function(){const n=A;let e;try{e=Function("return (function() "+n(286)+");")()}catch(o){e=window}const t=e.console=e[n(312)]||{},r=[n(278),n(281),n(292),n(279),n(311),"table",n(306)];for(let i=0;i<r.length;i++){const e=D[n(323)][n(293)][n(297)](D),o=r[i],c=t[o]||e;e[n(314)]=D[n(297)](D),e[n(305)]=c[n(305)][n(297)](c),t[o]=e}}))();const L=p({__name:M(299),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=M,o=t,i=new(c[r(283)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(296)](r(318),new(c[r(298)])(l,3)),i[r(287)](new a(s,1));const u=new(c[r(301)])({uniforms:{light:{value:o.light},tiles:{value:o[r(302)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(300)]}),f=new(c[r(303)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{((n,e)=>{const t=r;u.uniforms.water.value=n,u[t(322)][t(284)][t(325)]=e,p.value[t(316)](f,v.value)})(o[r(317)],o.causticsTexture)})),(n,e)=>null}});function O(n){function e(n){const t=A;if(typeof n===t(327))return function(n){}[t(323)](t(289))[t(319)]("counter");1!==(""+n/n)[t(294)]||n%20==0?function(){return!0}.constructor(t(288)+t(315)).call(t(320)):function(){return!1}[t(323)](t(288)+t(315)).apply(t(285)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const S=P;!function(n,e){const t=P,r=E();for(;;)try{if(624097===-parseInt(t(248))/1*(parseInt(t(256))/2)+parseInt(t(270))/3+-parseInt(t(286))/4*(-parseInt(t(282))/5)+-parseInt(t(254))/6*(parseInt(t(245))/7)+parseInt(t(274))/8+-parseInt(t(291))/9*(-parseInt(t(235))/10)+-parseInt(t(247))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(275)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function E(){const n=["geometry","1674pcekaV","Mesh","test","error","debu","uniforms","init","CubeTextureLoader","value","neg-x.jpg","action","water","constructor","causticsTexture","894864cSvejd","chain","FrontSide","waterTexture","9709600VryQJa","apply","side","neg-y.jpg","neg-z.jpg","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","pos-y.jpg","trace","215015ebzfXd","warn","counter","tiles","80bkSWro","function *\\( *\\)","causticTex","render","exception","327042JNZPMm","pooRef","return (function() ","input","table","60JHsqAo","while (true) {}","BackSide","call","pos-x.jpg","toString","bind","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","Color","gger","231266rAJust","prototype","13365330FqbYwy","463nwWWeq","light","stateObject","setRenderTarget","underwater","pos-z.jpg","66zYjdip"];return(E=function(){return n})()}!function(){j(this,(function(){const n=P,e=new RegExp(n(287)),t=new RegExp(n(242),"i"),r=V(n(262));e[n(258)](r+n(271))&&t[n(258)](r+n(294))?V():r("0")}))()}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(275)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function P(n,e){const t=E();return(P=function(n,e){return t[n-=235]})(n,e)}F(void 0,(function(){const n=P,e=function(){const n=P;let e;try{e=Function(n(293)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e.console=e.console||{},r=["log",n(283),"info",n(259),n(290),n(295),n(281)];for(let o=0;o<r.length;o++){const e=F.constructor[n(246)][n(241)](F),i=r[o],c=t[i]||e;e.__proto__=F[n(241)](F),e[n(240)]=c[n(240)].bind(c),t[i]=e}}))();const W=p({__name:S(267),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=S;let i,a;const s=r,u=s[o(255)],f=(new(c[o(263)])).setPath(o(279)).load([o(239),o(265),o(280),o(277),o(253),o(278)]),p=([i,a]=v((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),m=new l({uniforms:{light:{value:s[o(249)]},tiles:{value:p},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new(c[o(257)])(u,m),w=g(null),b=new(c[o(243)])("white"),{renderer:R,camera:C}=n(),{onLoop:I}=e();return I((()=>{const n=o;R[n(264)][n(251)](null),R.value.setClearColor(b,1),R[n(264)].clear(),m[n(261)].water[n(264)]=s[n(273)],m[n(261)][n(288)].value=s.causticsTexture,m[n(276)]=c[n(272)],m[n(261)][n(252)][n(264)]=!0,R[n(264)][n(289)](y,C[n(264)]),m[n(276)]=c[n(237)],m[n(261)][n(252)].value=!1,R[n(264)][n(289)](y,C.value)})),(n,e)=>{const t=o;return d(),x(L,{tiles:h(p),light:n[t(249)],waterTexture:n[t(273)],causticsTexture:n[t(269)],ref_key:t(292),ref:w},null,8,[t(285),t(249),t(273),t(269)])}}});function V(n){function e(n){const t=P;if("string"==typeof n)return function(n){}[t(268)](t(236))[t(275)](t(284));1!==(""+n/n).length||n%20==0?function(){return!0}[t(268)]("debu"+t(244))[t(238)](t(266)):function(){return!1}[t(268)](t(260)+t(244))[t(275)](t(250)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=N,r=Z();for(;;)try{if(906039===-parseInt(t(181))/1+parseInt(t(172))/2+-parseInt(t(198))/3+-parseInt(t(177))/4+-parseInt(t(170))/5*(-parseInt(t(167))/6)+parseInt(t(209))/7+-parseInt(t(179))/8*(-parseInt(t(162))/9))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const k=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){k(this,(function(){const n=N,e=new RegExp(n(204)),t=new RegExp(n(193),"i"),r=G(n(197));e[n(213)](r+n(160))&&t.test(r+n(189))?G():r("0")}))()}();const H=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[N(185)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function N(n,e){const t=Z();return(N=function(n,e){return t[n-=160]})(n,e)}H(void 0,(function(){const n=N;let e;try{e=Function(n(205)+n(163)+");")()}catch(o){e=window}const t=e.console=e[n(199)]||{},r=[n(208),"warn",n(191),n(183),n(180),n(171),n(190)];for(let i=0;i<r[n(194)];i++){const e=H[n(195)][n(169)].bind(H),o=r[i],c=t[o]||e;e[n(176)]=H[n(161)](H),e.toString=c[n(184)].bind(c),t[o]=e}}))();const B=p({__name:"caustics",props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=N,o=t,i=new(c[r(207)])(0,1,1,0,0,2e3),a=new(c[r(178)])(2,2,200,200),l=new(c[r(173)])(1024,1024),u=new(c[r(187)])({uniforms:{light:{value:o[r(192)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),f=new s(a,u),p=new(c[r(164)])("black"),{renderer:v}=n(),{onBeforeLoop:g}=e();return g((()=>{const n=r;f[n(196)][n(186)].water[n(174)]=o[n(210)],v.value[n(206)](l),v[n(174)][n(211)](p,0),v[n(174)][n(188)](),v[n(174)][n(168)](f,i)})),(n,e)=>{const t=r;return d(),x(w,null,{default:m((()=>[y(W,{waterTexture:n[t(210)],causticsTexture:h(l)[t(202)],light:n[t(192)],geometry:h(a)},null,8,["waterTexture",t(182),t(192),t(203)])])),_:1})}}});function Z(){const n=["144ElSXpC","exception","1790162LueaaT","causticsTexture","error","toString","apply","uniforms","ShaderMaterial","clear","input","trace","info","light","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","length","constructor","material","init","2405763AyzWiY","console","string","while (true) {}","texture","geometry","function *\\( *\\)","return (function() ","setRenderTarget","OrthographicCamera","log","6159160wRPVUZ","waterTexture","setClearColor","counter","test","chain","bind","769239xvIPHX",'{}.constructor("return this")( )',"Color","debu","stateObject","121014BHjhkC","render","prototype","405DeJRgx","table","794202mfxAfo","WebGLRenderTarget","value","call","__proto__","3804104lgebPm","PlaneGeometry"];return(Z=function(){return n})()}function G(n){function e(n){const t=N;if(typeof n===t(200))return function(n){}.constructor(t(201))[t(185)](t(212));1!==(""+n/n).length||n%20==0?function(){return!0}[t(195)](t(165)+"gger")[t(175)]("action"):function(){return!1}.constructor(t(165)+"gger")[t(185)](t(166)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const q=J;function X(){const n=["WebGLRenderTarget","light","attributes","PlaneGeometry","console","test","setZ","mousemove","setRenderTarget","2756794tDVNpH","135245gygcDN","table","Mesh","2325673admKcN","domElement","3295688ilupzq",'{}.constructor("return this")( )',"getY","width","autoClear","return (function() ","texture","strength","Vector2","exception","position","waterSimulation","intersectObject","point","10388322EmLrlC","clientY","8244GHTXkO","2126808cMUrov","value","clientX","RawShaderMaterial","material","OrthographicCamera","chain","setFromCamera","prototype","left","init","count","toString","1772gOiBEt","string","bind","removeEventListener","uniforms","setY","top","height","lightFrontGeometry","apply","function *\\( *\\)","needsUpdate","warn","constructor","gger","call","debu","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","1schSsL","length","action","error","trace"];return(X=function(){return n})()}!function(n,e){const t=J,r=X();for(;;)try{if(993915===-parseInt(t(301))/1*(-parseInt(t(247))/2)+-parseInt(t(269))/3*(-parseInt(t(283))/4)+-parseInt(t(248))/5+-parseInt(t(267))/6+parseInt(t(251))/7+-parseInt(t(253))/8+parseInt(t(270))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const $=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){$(this,(function(){const n=J,e=new RegExp(n(293)),t=new RegExp(n(300),"i"),r=K(n(280));e.test(r+n(276))&&t[n(243)](r+"input")?K():r("0")}))()}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[J(292)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function J(n,e){const t=X();return(J=function(n,e){return t[n-=235]})(n,e)}U(void 0,(function(){const n=J;let e;try{e=Function(n(258)+n(254)+");")()}catch(o){e=window}const t=e[n(242)]=e.console||{},r=["log",n(295),"info",n(236),n(262),n(249),n(237)];for(let i=0;i<r.length;i++){const e=U[n(296)][n(278)][n(285)](U),o=r[i],c=t[o]||e;e.__proto__=U[n(285)](U),e.toString=c[n(282)][n(285)](c),t[o]=e}}))();const Y=p({__name:q(264),props:{light:{}},setup(t,{expose:r}){const o=q,i=new(c[o(275)])(0,1,1,0,0,2e3),a=new(c[o(241)])(2,2),s=new u(256,256,{type:f}),p=new(c[o(238)])(256,256,{type:f}),v=new(c[o(273)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),g=new l({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),m=new l({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),y=new(c[o(250)])(a,v),w=new(c[o(250)])(a,g),b=new(c[o(250)])(a,m);let R=s;const C=(n,e)=>{const t=o,r=R,c=R===s?p:s;e[t(274)][t(287)][t(259)][t(271)]=r[t(259)],n[t(246)](c),n.render(e,i),R=c},{renderer:I,camera:M,raycaster:z}=n();I.value[o(257)]=!1;const{onBeforeLoop:D}=e();D((()=>{const n=o;var e,t;t=I[n(271)],C(t,b),e=I[n(271)],C(e,w)}));const A=(n,e,t,r)=>{const i=o;y[i(274)][i(287)].center[i(271)]=[n,e],y[i(274)][i(287)].radius[i(271)]=t,y.material[i(287)][i(260)][i(271)]=r,C(I[i(271)],y)},T=new(c[o(261)]),L=new(c[o(241)])(2,2),O=L[o(240)][o(263)];for(let n=0;n<O[o(281)];n++){const e=-O[o(255)](n);O[o(288)](n,0),O[o(244)](n,e)}O[o(294)]=!0;const S=new(c[o(250)])(L),j={handleEvent:n=>{const e=o,t=I.value.domElement.getBoundingClientRect(),r=t[e(256)],i=t[e(290)];T.x=2*(n[e(272)]-t[e(279)])/r-1,T.y=2*-(n[e(268)]-t[e(289)])/i+1,z[e(271)][e(277)](T,M[e(271)]);const c=z[e(271)][e(265)](S);for(let o of c)A(o[e(266)].x,o.point.z,.03,.04)}};return r({addDrop:A,mouseEvent:n=>{const e=o;n?I[e(271)].domElement.addEventListener(e(245),j):I[e(271)][e(252)][e(286)](e(245),j)}}),(n,e)=>{const t=o;return d(),x(B,{lightFrontGeometry:h(a),waterTexture:h(R)[t(259)],light:n[t(239)]},null,8,[t(291),"waterTexture",t(239)])}}});function K(n){function e(n){const t=J;if(typeof n===t(284))return function(n){}[t(296)]("while (true) {}")[t(292)]("counter");1!==(""+n/n)[t(302)]||n%20==0?function(){return!0}[t(296)](t(299)+"gger")[t(298)](t(235)):function(){return!1}[t(296)](t(299)+t(297))[t(292)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=tn,r=en();for(;;)try{if(678703===-parseInt(t(421))/1*(parseInt(t(428))/2)+parseInt(t(442))/3+-parseInt(t(422))/4*(-parseInt(t(448))/5)+parseInt(t(444))/6+-parseInt(t(445))/7*(parseInt(t(457))/8)+-parseInt(t(426))/9+-parseInt(t(462))/10*(-parseInt(t(439))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(423)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Q(this,(function(){const n=tn,e=new RegExp(n(435)),t=new RegExp(n(420),"i"),r=on("init");e[n(438)](r+n(436))&&t.test(r+n(433))?on():r("0")}))()}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(423)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function en(){const n=["prototype","2099529KCctYj","click","202780RVmyqf","点击按钮","随机增加波纹","console","toString","input",'{}.constructor("return this")( )',"function *\\( *\\)","chain","gger","test","44igPfAm","table","while (true) {}","1526934lVEGxQ","error","5536362oUCWlP","7FuSNee","counter","debu","625xwbXfx","length","addBinding","constructor","mouseEvent","info","exception","manual","value","4948048MLmmNR","waterSimulationRef","bind","random","return (function() ","653200LudqJv","addDrop","addButton","action","stateObject","trace","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","8GezwRq","20756NiXDBP","apply","call"];return(en=function(){return n})()}function tn(n,e){const t=en();return(tn=function(n,e){return t[n-=415]})(n,e)}nn(void 0,(function(){const n=tn,e=function(){const n=tn;let e;try{e=Function(n(461)+n(434)+");")()}catch(t){e=window}return e}(),t=e[n(431)]=e[n(431)]||{},r=["log","warn",n(453),n(443),n(454),n(440),n(419)];for(let o=0;o<r[n(449)];o++){const e=nn[n(451)][n(425)][n(459)](nn),i=r[o],c=t[i]||e;e.__proto__=nn.bind(nn),e[n(432)]=c[n(432)][n(459)](c),t[i]=e}}))();const rn=p({__name:"realWater",setup(n){const e=tn,t=b({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(455)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=g(null),l=new i;l[e(416)]({label:e(429),title:e(430)}).on(e(427),(()=>{const n=e;for(var t=0;t<10;t++)a[n(456)][n(415)](2*Math[n(460)]()-1,2*Math[n(460)]()-1,.03,1&t?.02:-.02)}));const s=g(!1);return l[e(450)](s,e(456),{label:"鼠标波纹"}).on("change",(n=>{const t=e;a[t(456)][t(452)](n[t(456)])})),(n,i)=>{const l=e;return d(),x(h(o),C(I(t)),{default:m((()=>[i[0]||(i[0]=R("TresPerspectiveCamera",{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),y(h(r)),y(Y,{light:c,ref_key:l(458),ref:a},null,512)])),_:1},16)}}});function on(n){function e(n){const t=tn;if("string"==typeof n)return function(n){}.constructor(t(441))[t(423)](t(446));1!==(""+n/n).length||n%20==0?function(){return!0}[t(451)](t(447)+"gger")[t(424)](t(417)):function(){return!1}[t(451)](t(447)+t(437))[t(423)](t(418)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{rn as default};
