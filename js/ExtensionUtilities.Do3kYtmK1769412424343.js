import{importShared as t}from"./3d-tiles-renderer.DFcJBJdg1769412424343.js";const e=0,n=1,r=2,o=1.25,i=65535,s=Math.pow(2,-24),a=Symbol("SKIP_GENERATION"),{BufferAttribute:c}=await t("three");function l(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function u(t,e){if(!t.index){const n=t.attributes.position.count,r=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(n,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new c(r,1));for(let t=0;t<n;t++)r[t]=t}}function f(t,e){const n=l(t),r=e||t.drawRange,o=r.start/3,i=(r.start+r.count)/3,s=Math.max(0,o),a=Math.min(n,i)-s;return[{offset:Math.floor(s),count:Math.floor(a)}]}function d(t,e){if(!t.groups||!t.groups.length)return f(t,e);const n=[],r=new Set,o=e||t.drawRange,i=o.start/3,s=(o.start+o.count)/3;for(const c of t.groups){const t=c.start/3,e=(c.start+c.count)/3;r.add(Math.max(i,t)),r.add(Math.min(s,e))}const a=Array.from(r.values()).sort((t,e)=>t-e);for(let c=0;c<a.length-1;c++){const t=a[c],e=a[c+1];n.push({offset:Math.floor(t),count:Math.floor(e-t)})}return n}function p(t,e,n,r,o){let i=1/0,s=1/0,a=1/0,c=-1/0,l=-1/0,u=-1/0,f=1/0,d=1/0,p=1/0,h=-1/0,y=-1/0,x=-1/0;for(let g=6*e,m=6*(e+n);g<m;g+=6){const e=t[g+0],n=t[g+1],r=e-n,o=e+n;r<i&&(i=r),o>c&&(c=o),e<f&&(f=e),e>h&&(h=e);const m=t[g+2],w=t[g+3],B=m-w,b=m+w;B<s&&(s=B),b>l&&(l=b),m<d&&(d=m),m>y&&(y=m);const A=t[g+4],T=t[g+5],P=A-T,M=A+T;P<a&&(a=P),M>u&&(u=M),A<p&&(p=A),A>x&&(x=A)}r[0]=i,r[1]=s,r[2]=a,r[3]=c,r[4]=l,r[5]=u,o[0]=f,o[1]=d,o[2]=p,o[3]=h,o[4]=y,o[5]=x}function h(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function y(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const o=t[r+3]-t[r];o>n&&(n=o,e=r)}return e}function x(t,e){e.set(t)}function g(t,e,n){let r,o;for(let i=0;i<3;i++){const s=i+3;r=t[i],o=e[i],n[i]=r<o?r:o,r=t[s],o=e[s],n[s]=r>o?r:o}}function m(t,e,n){for(let r=0;r<3;r++){const o=e[t+2*r],i=e[t+2*r+1],s=o-i,a=o+i;s<n[r]&&(n[r]=s),a>n[r+3]&&(n[r+3]=a)}}function w(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}const B=32,b=(t,e)=>t.candidate-e.candidate,A=new Array(B).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),T=new Float32Array(6);class P{constructor(){this.boundingData=new Float32Array(6)}}function M(t,e,n,r,o,i){let s=r,a=r+o-1;const c=i.pos,l=2*i.axis;for(;;){for(;s<=a&&n[6*s+l]<c;)s++;for(;s<=a&&n[6*a+l]>=c;)a--;if(!(s<a))return s;for(let t=0;t<3;t++){let n=e[3*s+t];e[3*s+t]=e[3*a+t],e[3*a+t]=n}for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}function v(t,e,n,r,o,i){let s=r,a=r+o-1;const c=i.pos,l=2*i.axis;for(;;){for(;s<=a&&n[6*s+l]<c;)s++;for(;s<=a&&n[6*a+l]>=c;)a--;if(!(s<a))return s;{let e=t[s];t[s]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}}function S(t,e){return 65535===e[t+15]}function U(t,e){return e[t+6]}function I(t,e){return e[t+14]}function F(t){return t+8}function _(t,e){return e[t+6]}function V(t,e){return e[t+7]}function z(t){return t}let q,C,R,E;const N=Math.pow(2,32);function O(t){return"count"in t?1:1+O(t.left)+O(t.right)}function X(t,e,n){return q=new Float32Array(n),C=new Uint32Array(n),R=new Uint16Array(n),E=new Uint8Array(n),D(t,e)}function D(t,e){const n=t/4,r=t/2,o="count"in e,s=e.boundingData;for(let i=0;i<6;i++)q[n+i]=s[i];if(o){if(e.buffer){const r=e.buffer;E.set(new Uint8Array(r),t);for(let e=t,o=t+r.byteLength;e<o;e+=32){S(e/2,R)||(C[e/4+6]+=n)}return t+r.byteLength}{const o=e.offset,s=e.count;return C[n+6]=o,R[r+14]=s,R[r+15]=i,t+32}}{const r=e.left,o=e.right,i=e.splitAxis;let s;if(s=D(t+32,r),s/4>N)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return C[n+6]=s/4,s=D(s,o),C[n+7]=i,s}}function H(t,e,n,r,i){const{maxDepth:s,verbose:a,maxLeafTris:c,strategy:u,onProgress:f,indirect:d}=i,h=t._indirectBuffer,S=t.geometry,U=S.index?S.index.array:null,I=d?v:M,F=l(S),_=new Float32Array(6);let V=!1;const z=new P;return p(e,n,r,z.boundingData,_),function t(n,r,i,l=null,f=0){!V&&f>=s&&(V=!0,a&&(console.warn(`MeshBVH: Max depth of ${s} reached when generating BVH. Consider increasing maxDepth.`),console.warn(S)));if(i<=c||f>=s)return q(r+i),n.offset=r,n.count=i,n;const d=function(t,e,n,r,i,s){let a=-1,c=0;if(0===s)a=y(e),-1!==a&&(c=(e[a]+e[a+3])/2);else if(1===s)a=y(t),-1!==a&&(c=function(t,e,n,r){let o=0;for(let i=e,s=e+n;i<s;i++)o+=t[6*i+2*r];return o/n}(n,r,i,a));else if(2===s){const s=w(t);let l=o*i;const u=6*r,f=6*(r+i);for(let t=0;t<3;t++){const r=e[t],d=(e[t+3]-r)/B;if(i<8){const e=[...A];e.length=i;let r=0;for(let o=u;o<f;o+=6,r++){const i=e[r];i.candidate=n[o+2*t],i.count=0;const{bounds:s,leftCacheBounds:a,rightCacheBounds:c}=i;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,s[t]=1/0,s[t+3]=-1/0;m(o,n,s)}e.sort(b);let d=i;for(let t=0;t<d;t++){const n=e[t];for(;t+1<d&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),d--}for(let o=u;o<f;o+=6){const r=n[o+2*t];for(let t=0;t<d;t++){const i=e[t];r>=i.candidate?m(o,n,i.rightCacheBounds):(m(o,n,i.leftCacheBounds),i.count++)}}for(let n=0;n<d;n++){const r=e[n],u=r.count,f=i-r.count,d=r.leftCacheBounds,p=r.rightCacheBounds;let h=0;0!==u&&(h=w(d)/s);let y=0;0!==f&&(y=w(p)/s);const x=1+o*(h*u+y*f);x<l&&(a=t,l=x,c=r.candidate)}}else{for(let t=0;t<B;t++){const e=A[t];e.count=0,e.candidate=r+d+t*d;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let o=u;o<f;o+=6){let e=~~((n[o+2*t]-r)/d);e>=B&&(e=31);const i=A[e];i.count++,m(o,n,i.bounds)}const e=A[31];x(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=A[t],n=A[t+1];g(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let p=0;for(let n=0;n<31;n++){const e=A[n],r=e.count,u=e.bounds,f=A[n+1].rightCacheBounds;0!==r&&(0===p?x(u,T):g(u,T,T)),p+=r;let d=0,h=0;0!==p&&(d=w(T)/s);const y=i-p;0!==y&&(h=w(f)/s);const m=1+o*(d*p+h*y);m<l&&(a=t,l=m,c=e.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${s} used.`);return{axis:a,pos:c}}(n.boundingData,l,e,r,i,u);if(-1===d.axis)return q(r+i),n.offset=r,n.count=i,n;const M=I(h,U,e,r,i,d);if(M===r||M===r+i)q(r+i),n.offset=r,n.count=i;else{n.splitAxis=d.axis;const o=new P,s=r,a=M-r;n.left=o,p(e,s,a,o.boundingData,_),t(o,s,a,_,f+1);const c=new P,l=M,u=i-a;n.right=c,p(e,l,u,c.boundingData,_),t(c,l,u,_,f+1)}return n}(z,n,r,_),z;function q(t){f&&f(t/F)}}function L(t,e){const n=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const n=(t.index?t.index.count:t.attributes.position.count)/3,r=n>65536,o=r?4:2,i=e?new SharedArrayBuffer(n*o):new ArrayBuffer(n*o),s=r?new Uint32Array(i):new Uint16Array(i);for(let a=0,c=s.length;a<c;a++)s[a]=a;return s}(n,e.useSharedArrayBuffer),function(t,e){const n=l(t),r=d(t,e).sort((t,e)=>t.offset-e.offset),o=r[r.length-1];o.count=Math.min(n-o.offset,o.count);let i=0;return r.forEach(({count:t})=>i+=t),n!==i}(n,e.range)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||u(n,e);const r=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=function(t,e=null,n=null,r=null){const o=t.attributes.position,i=t.index?t.index.array:null,a=l(t),c=o.normalized;let u;null===e?(u=new Float32Array(6*a),n=0,r=a):(u=e,n=n||0,r=r||a);const f=o.array,d=o.offset||0;let p=3;o.isInterleavedBufferAttribute&&(p=o.data.stride);const h=["getX","getY","getZ"];for(let l=n;l<n+r;l++){const t=3*l,e=6*l;let n=t+0,r=t+1,a=t+2;i&&(n=i[n],r=i[r],a=i[a]),c||(n=n*p+d,r=r*p+d,a=a*p+d);for(let i=0;i<3;i++){let t,l,d;c?(t=o[h[i]](n),l=o[h[i]](r),d=o[h[i]](a)):(t=f[n+i],l=f[r+i],d=f[a+i]);let p=t;l<p&&(p=l),d<p&&(p=d);let y=t;l>y&&(y=l),d>y&&(y=d);const x=(y-p)/2,g=2*i;u[e+g+0]=p+x,u[e+g+1]=x+(Math.abs(p)+x)*s}}return u}(n),i=e.indirect?f(n,e.range):d(n,e.range);t._roots=i.map(n=>{const i=H(t,o,n.offset,n.count,e),s=O(i),a=new r(32*s);return X(0,i,a),a})}const{Vector3:k}=await t("three");class Y{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,r=-1/0;for(let o=0,i=t.length;o<i;o++){const i=t[o][e];n=i<n?i:n,r=i>r?i:r}this.min=n,this.max=r}setFromPoints(t,e){let n=1/0,r=-1/0;for(let o=0,i=e.length;o<i;o++){const i=e[o],s=t.dot(i);n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}Y.prototype.setFromBox=function(){const t=new k;return function(e,n){const r=n.min,o=n.max;let i=1/0,s=-1/0;for(let a=0;a<=1;a++)for(let n=0;n<=1;n++)for(let c=0;c<=1;c++){t.x=r.x*a+o.x*(1-a),t.y=r.y*n+o.y*(1-n),t.z=r.z*c+o.z*(1-c);const l=e.dot(t);i=Math.min(l,i),s=Math.max(l,s)}this.min=i,this.max=s}}();const{Vector3:Z,Vector2:j,Plane:G,Line3:W}=await t("three"),$=function(){const t=new Z,e=new Z,n=new Z;return function(r,o,i){const s=r.start,a=t,c=o.start,l=e;n.subVectors(s,c),t.subVectors(r.end,r.start),e.subVectors(o.end,o.start);const u=n.dot(l),f=l.dot(a),d=l.dot(l),p=n.dot(a),h=a.dot(a)*d-f*f;let y,x;y=0!==h?(u*f-p*d)/h:0,x=(u+y*f)/d,i.x=y,i.y=x}}(),K=function(){const t=new j,e=new Z,n=new Z;return function(r,o,i,s){$(r,o,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return r.at(a,i),void o.at(c,s);if(a>=0&&a<=1)return c<0?o.at(0,s):o.at(1,s),void r.closestPointToPoint(s,!0,i);if(c>=0&&c<=1)return a<0?r.at(0,i):r.at(1,i),void o.closestPointToPoint(i,!0,s);{let t,l;t=a<0?r.start:r.end,l=c<0?o.start:o.end;const u=e,f=n;return r.closestPointToPoint(l,!0,e),o.closestPointToPoint(t,!0,n),u.distanceToSquared(l)<=f.distanceToSquared(t)?(i.copy(u),void s.copy(l)):(i.copy(t),void s.copy(f))}}}(),J=function(){const t=new Z,e=new Z,n=new G,r=new W;return function(o,i){const{radius:s,center:a}=o,{a:c,b:l,c:u}=i;r.start=c,r.end=l;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;r.start=c,r.end=u;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;r.start=l,r.end=u;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;const f=i.getPlane(n);if(Math.abs(f.distanceToPoint(a))<=s){const t=f.projectPoint(a,e);if(i.containsPoint(t))return!0}return!1}}(),{Triangle:Q,Vector3:tt,Line3:et,Sphere:nt,Plane:rt}=await t("three");function ot(t){return Math.abs(t)<1e-15}class it extends Q{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new tt),this.satBounds=new Array(4).fill().map(()=>new Y),this.points=[this.a,this.b,this.c],this.sphere=new nt,this.plane=new rt,this.needsUpdate=!0}intersectsSphere(t){return J(t,this)}update(){const t=this.a,e=this.b,n=this.c,r=this.points,o=this.satAxes,i=this.satBounds,s=o[0],a=i[0];this.getNormal(s),a.setFromPoints(s,r);const c=o[1],l=i[1];c.subVectors(t,e),l.setFromPoints(c,r);const u=o[2],f=i[2];u.subVectors(e,n),f.setFromPoints(u,r);const d=o[3],p=i[3];d.subVectors(n,t),p.setFromPoints(d,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,t),this.needsUpdate=!1}}it.prototype.closestPointToSegment=function(){const t=new tt,e=new tt,n=new et;return function(r,o=null,i=null){const{start:s,end:a}=r,c=this.points;let l,u=1/0;for(let f=0;f<3;f++){const s=(f+1)%3;n.start.copy(c[f]),n.end.copy(c[s]),K(n,r,t,e),l=t.distanceToSquared(e),l<u&&(u=l,o&&o.copy(t),i&&i.copy(e))}return this.closestPointToPoint(s,t),l=s.distanceToSquared(t),l<u&&(u=l,o&&o.copy(t),i&&i.copy(s)),this.closestPointToPoint(a,t),l=a.distanceToSquared(t),l<u&&(u=l,o&&o.copy(t),i&&i.copy(a)),Math.sqrt(u)}}(),it.prototype.intersectsTriangle=function(){const t=new it,e=new Array(3),n=new Array(3),r=new Y,o=new Y,i=new tt,s=new tt,a=new tt,c=new tt,l=new tt,u=new et,f=new et,d=new et,p=new tt;function h(t,e,n){const r=t.points;let o=0,i=-1;for(let a=0;a<3;a++){const{start:t,end:c}=u;t.copy(r[a]),c.copy(r[(a+1)%3]),u.delta(s);const l=ot(e.distanceToPoint(t));if(ot(e.normal.dot(s))&&l){n.copy(u),o=2;break}const f=e.intersectLine(u,p);if(!f&&l&&p.copy(t),(f||l)&&!ot(p.distanceTo(c))){if(o<=1){(1===o?n.start:n.end).copy(p),l&&(i=o)}else if(o>=2){(1===i?n.start:n.end).copy(p),o=2;break}if(o++,2===o&&-1===i)break}}return o}return function(s,u=null,p=!1){this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const y=this.plane,x=s.plane;if(Math.abs(y.normal.dot(x.normal))>1-1e-10){const t=this.satBounds,a=this.satAxes;n[0]=s.a,n[1]=s.b,n[2]=s.c;for(let e=0;e<4;e++){const o=t[e],i=a[e];if(r.setFromPoints(i,n),o.isSeparated(r))return!1}const c=s.satBounds,l=s.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let n=0;n<4;n++){const t=c[n],o=l[n];if(r.setFromPoints(o,e),t.isSeparated(r))return!1}for(let s=0;s<4;s++){const t=a[s];for(let s=0;s<4;s++){const a=l[s];if(i.crossVectors(t,a),r.setFromPoints(i,e),o.setFromPoints(i,n),r.isSeparated(o))return!1}}return u&&(p||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),u.start.set(0,0,0),u.end.set(0,0,0)),!0}{const t=h(this,x,f);if(1===t&&s.containsPoint(f.end))return u&&(u.start.copy(f.end),u.end.copy(f.end)),!0;if(2!==t)return!1;const e=h(s,y,d);if(1===e&&this.containsPoint(d.end))return u&&(u.start.copy(d.end),u.end.copy(d.end)),!0;if(2!==e)return!1;if(f.delta(a),d.delta(c),a.dot(c)<0){let t=d.start;d.start=d.end,d.end=t}const n=f.start.dot(a),r=f.end.dot(a),o=d.start.dot(a),i=d.end.dot(a);return(n===i||o===r||r<o!==n<i)&&(u&&(l.subVectors(f.start,d.start),l.dot(a)>0?u.start.copy(f.start):u.start.copy(d.start),l.subVectors(f.end,d.end),l.dot(a)<0?u.end.copy(f.end):u.end.copy(d.end)),!0)}}}(),it.prototype.distanceToPoint=function(){const t=new tt;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),it.prototype.distanceToTriangle=function(){const t=new tt,e=new tt,n=["a","b","c"],r=new et,o=new et;return function(i,s=null,a=null){const c=s||a?r:null;if(this.intersectsTriangle(i,c))return(s||a)&&(s&&c.getCenter(s),a&&c.getCenter(a)),0;let l=1/0;for(let e=0;e<3;e++){let r;const o=n[e],c=i[o];this.closestPointToPoint(c,t),r=c.distanceToSquared(t),r<l&&(l=r,s&&s.copy(t),a&&a.copy(c));const u=this[o];i.closestPointToPoint(u,t),r=u.distanceToSquared(t),r<l&&(l=r,s&&s.copy(u),a&&a.copy(t))}for(let u=0;u<3;u++){const c=n[u],f=n[(u+1)%3];r.set(this[c],this[f]);for(let u=0;u<3;u++){const c=n[u],f=n[(u+1)%3];o.set(i[c],i[f]),K(r,o,t,e);const d=t.distanceToSquared(e);d<l&&(l=d,s&&s.copy(t),a&&a.copy(e))}}return Math.sqrt(l)}}();const{Vector3:st,Matrix4:at,Line3:ct}=await t("three");class lt{constructor(t,e,n){this.isOrientedBox=!0,this.min=new st,this.max=new st,this.matrix=new at,this.invMatrix=new at,this.points=new Array(8).fill().map(()=>new st),this.satAxes=new Array(3).fill().map(()=>new st),this.satBounds=new Array(3).fill().map(()=>new Y),this.alignedSatBounds=new Array(3).fill().map(()=>new Y),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}lt.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let c=0;c<=1;c++)for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const s=r[1*c|2*o|4*i];s.x=c?n.x:e.x,s.y=o?n.y:e.y,s.z=i?n.z:e.z,s.applyMatrix4(t)}const o=this.satBounds,i=this.satAxes,s=r[0];for(let c=0;c<3;c++){const t=i[c],e=o[c],n=r[1<<c];t.subVectors(s,n),e.setFromPoints(t,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},lt.prototype.intersectsBox=function(){const t=new Y;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,o=this.satBounds,i=this.satAxes,s=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,s[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,s[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,s[2].isSeparated(t))return!1;for(let a=0;a<3;a++){const n=i[a],r=o[a];if(t.setFromBox(n,e),r.isSeparated(t))return!1}return!0}}(),lt.prototype.intersectsTriangle=function(){const t=new it,e=new Array(3),n=new Y,r=new Y,o=new st;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(t.copy(i),t.update(),i=t);const s=this.satBounds,a=this.satAxes;e[0]=i.a,e[1]=i.b,e[2]=i.c;for(let t=0;t<3;t++){const r=s[t],o=a[t];if(n.setFromPoints(o,e),r.isSeparated(n))return!1}const c=i.satBounds,l=i.satAxes,u=this.points;for(let t=0;t<3;t++){const e=c[t],r=l[t];if(n.setFromPoints(r,u),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const i=a[t];for(let t=0;t<4;t++){const s=l[t];if(o.crossVectors(i,s),n.setFromPoints(o,e),r.setFromPoints(o,u),n.isSeparated(r))return!1}}return!0}}(),lt.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},lt.prototype.distanceToPoint=function(){const t=new st;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),lt.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map(()=>new ct),n=new Array(12).fill().map(()=>new ct),r=new st,o=new st;return function(i,s=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(a||c)&&(i.getCenter(o),this.closestPointToPoint(o,r),i.closestPointToPoint(r,o),a&&a.copy(r),c&&c.copy(o)),0;const l=s*s,u=i.min,f=i.max,d=this.points;let p=1/0;for(let t=0;t<8;t++){const e=d[t];o.copy(e).clamp(u,f);const n=e.distanceToSquared(o);if(n<p&&(p=n,a&&a.copy(e),c&&c.copy(o),n<l))return Math.sqrt(n)}let h=0;for(let r=0;r<3;r++)for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const s=(r+1)%3,a=(r+2)%3,c=1<<r|o<<s|i<<a,l=d[o<<s|i<<a],p=d[c];e[h].set(l,p);const y=t[r],x=t[s],g=t[a],m=n[h],w=m.start,B=m.end;w[y]=u[y],w[x]=o?u[x]:f[x],w[g]=i?u[g]:f[x],B[y]=f[y],B[x]=o?u[x]:f[x],B[g]=i?u[g]:f[x],h++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){o.x=t?f.x:u.x,o.y=e?f.y:u.y,o.z=n?f.z:u.z,this.closestPointToPoint(o,r);const i=o.distanceToSquared(r);if(i<p&&(p=i,a&&a.copy(r),c&&c.copy(o),i<l))return Math.sqrt(i)}for(let t=0;t<12;t++){const i=e[t];for(let t=0;t<12;t++){const e=n[t];K(i,e,r,o);const s=r.distanceToSquared(o);if(s<p&&(p=s,a&&a.copy(r),c&&c.copy(o),s<l))return Math.sqrt(s)}}return Math.sqrt(p)}}();class ut{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class ft extends ut{constructor(){super(()=>new it)}}const dt=new ft;const pt=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}},{Box3:ht}=await t("three");let yt,xt;const gt=[],mt=new ut(()=>new ht);function wt(t,e,n,r,o,i){yt=mt.getPrimitive(),xt=mt.getPrimitive(),gt.push(yt,xt),pt.setBuffer(t._roots[e]);const s=Bt(0,t.geometry,n,r,o,i);pt.clearBuffer(),mt.releasePrimitive(yt),mt.releasePrimitive(xt),gt.pop(),gt.pop();const a=gt.length;return a>0&&(xt=gt[a-1],yt=gt[a-2]),s}function Bt(t,e,n,r,o=null,i=0,s=0){const{float32Array:a,uint16Array:c,uint32Array:l}=pt;let u=2*t;if(S(u,c)){const f=U(t,l),d=I(u,c);return h(t,a,yt),r(f,d,!1,s,i+t,yt)}{const p=F(t),y=_(t,l);let x,g,m,w,B=p,b=y;if(o&&(m=yt,w=xt,h(B,a,m),h(b,a,w),x=o(m),g=o(w),g<x)){B=y,b=p;const z=x;x=g,g=z,m=w}m||(m=yt,h(B,a,m));const A=n(m,S(2*B,c),x,s+1,i+B);let T;if(2===A){const q=v(B);T=r(q,V(B)-q,!0,s+1,i+B,m)}else T=A&&Bt(B,e,n,r,o,i,s+1);if(T)return!0;w=xt,h(b,a,w);const P=n(w,S(2*b,c),g,s+1,i+b);let M;if(2===P){const C=v(b);M=r(C,V(b)-C,!0,s+1,i+b,w)}else M=P&&Bt(b,e,n,r,o,i,s+1);return!!M;function v(t){const{uint16Array:e,uint32Array:n}=pt;let r=2*t;for(;!S(r,e);)r=2*(t=F(t));return U(t,n)}function V(t){const{uint16Array:e,uint32Array:n}=pt;let r=2*t;for(;!S(r,e);)r=2*(t=_(t,n));return U(t,n)+I(r,e)}}}const{Vector3:bt}=await t("three"),At=new bt,Tt=new bt;const{Vector3:Pt,Vector2:Mt,Triangle:vt,DoubleSide:St,BackSide:Ut,REVISION:It}=await t("three"),Ft=parseInt(It)>=169,_t=new Pt,Vt=new Pt,zt=new Pt,qt=new Mt,Ct=new Mt,Rt=new Mt,Et=new Pt,Nt=new Pt,Ot=new Pt,Xt=new Pt;function Dt(t,e,n,r,o,i,s,a,c,l,u){_t.fromBufferAttribute(e,i),Vt.fromBufferAttribute(e,s),zt.fromBufferAttribute(e,a);const f=function(t,e,n,r,o,i,s,a){let c;if(c=i===Ut?t.intersectTriangle(r,n,e,!0,o):t.intersectTriangle(e,n,r,i!==St,o),null===c)return null;const l=t.origin.distanceTo(o);return l<s||l>a?null:{distance:l,point:o.clone()}}(t,_t,Vt,zt,Xt,c,l,u);if(f){const e=new Pt;vt.getBarycoord(Xt,_t,Vt,zt,e),r&&(qt.fromBufferAttribute(r,i),Ct.fromBufferAttribute(r,s),Rt.fromBufferAttribute(r,a),f.uv=vt.getInterpolation(Xt,_t,Vt,zt,qt,Ct,Rt,new Mt)),o&&(qt.fromBufferAttribute(o,i),Ct.fromBufferAttribute(o,s),Rt.fromBufferAttribute(o,a),f.uv1=vt.getInterpolation(Xt,_t,Vt,zt,qt,Ct,Rt,new Mt)),n&&(Et.fromBufferAttribute(n,i),Nt.fromBufferAttribute(n,s),Ot.fromBufferAttribute(n,a),f.normal=vt.getInterpolation(Xt,_t,Vt,zt,Et,Nt,Ot,new Pt),f.normal.dot(t.direction)>0&&f.normal.multiplyScalar(-1));const c={a:i,b:s,c:a,normal:new Pt,materialIndex:0};vt.getNormal(_t,Vt,zt,c.normal),f.face=c,f.faceIndex=i,Ft&&(f.barycoord=e)}return f}function Ht(t,e,n,r,o,i,s){const a=3*r;let c=a+0,l=a+1,u=a+2;const f=t.index;t.index&&(c=f.getX(c),l=f.getX(l),u=f.getX(u));const{position:d,normal:p,uv:h,uv1:y}=t.attributes,x=Dt(n,d,p,h,y,c,l,u,e,i,s);return x?(x.faceIndex=r,o&&o.push(x),x):null}const{Vector2:Lt,Vector3:kt,Triangle:Yt}=await t("three");function Zt(t,e,n,r){const o=t.a,i=t.b,s=t.c;let a=e,c=e+1,l=e+2;n&&(a=n.getX(a),c=n.getX(c),l=n.getX(l)),o.x=r.getX(a),o.y=r.getY(a),o.z=r.getZ(a),i.x=r.getX(c),i.y=r.getY(c),i.z=r.getZ(c),s.x=r.getX(l),s.y=r.getY(l),s.z=r.getZ(l)}function jt(t,e,n,r,o,i,s){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let u=t,f=e+t;u<f;u++){let t;if(t=u,Zt(s,3*t,c,l),s.needsUpdate=!0,r(s,t,o,i))return!0}return!1}function Gt(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let s,a,c,l,u=0;const f=t._roots;for(let i=0,p=f.length;i<p;i++)s=f[i],a=new Uint32Array(s),c=new Uint16Array(s),l=new Float32Array(s),d(0,u),u+=s.byteLength;function d(t,n,s=!1){const u=2*t;if(c[u+15]===i){const e=a[t+6];let n=1/0,i=1/0,s=1/0,f=-1/0,d=-1/0,p=-1/0;for(let t=3*e,a=3*(e+c[u+14]);t<a;t++){let e=r[t];const a=o.getX(e),c=o.getY(e),l=o.getZ(e);a<n&&(n=a),a>f&&(f=a),c<i&&(i=c),c>d&&(d=c),l<s&&(s=l),l>p&&(p=l)}return(l[t+0]!==n||l[t+1]!==i||l[t+2]!==s||l[t+3]!==f||l[t+4]!==d||l[t+5]!==p)&&(l[t+0]=n,l[t+1]=i,l[t+2]=s,l[t+3]=f,l[t+4]=d,l[t+5]=p,!0)}{const r=t+8,o=a[t+6],i=r+n,c=o+n;let u=s,f=!1,p=!1;e?u||(f=e.has(i),p=e.has(c),u=!f&&!p):(f=!0,p=!0);const h=u||p;let y=!1;(u||f)&&(y=d(r,n,u));let x=!1;h&&(x=d(o,n,u));const g=y||x;if(g)for(let e=0;e<3;e++){const n=r+e,i=o+e,s=l[n],a=l[n+3],c=l[i],u=l[i+3];l[t+e]=s<c?s:c,l[t+e+3]=a>u?a:u}return g}}}function Wt(t,e,n,r,o){let i,s,a,c,l,u;const f=1/n.direction.x,d=1/n.direction.y,p=1/n.direction.z,h=n.origin.x,y=n.origin.y,x=n.origin.z;let g=e[t],m=e[t+3],w=e[t+1],B=e[t+3+1],b=e[t+2],A=e[t+3+2];return f>=0?(i=(g-h)*f,s=(m-h)*f):(i=(m-h)*f,s=(g-h)*f),d>=0?(a=(w-y)*d,c=(B-y)*d):(a=(B-y)*d,c=(w-y)*d),!(i>c||a>s)&&((a>i||isNaN(i))&&(i=a),(c<s||isNaN(s))&&(s=c),p>=0?(l=(b-x)*p,u=(A-x)*p):(l=(A-x)*p,u=(b-x)*p),!(i>u||l>s)&&((l>i||i!=i)&&(i=l),(u<s||s!=s)&&(s=u),i<=o&&s>=r))}function $t(t,e,n,r,o,i,s){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let u=t,f=e+t;u<f;u++){let t;if(t=n.resolveTriangleIndex(u),Zt(s,3*t,c,l),s.needsUpdate=!0,r(s,t,o,i))return!0}return!1}function Kt(t,e,n,r,o,i,s){pt.setBuffer(t._roots[e]),Jt(0,t,n,r,o,i,s),pt.clearBuffer()}function Jt(t,e,n,r,o,i,s){const{float32Array:a,uint16Array:c,uint32Array:l}=pt,u=2*t;if(S(u,c)){!function(t,e,n,r,o,i,s,a){const{geometry:c,_indirectBuffer:l}=t;for(let u=r,f=r+o;u<f;u++)Ht(c,e,n,u,i,s,a)}(e,n,r,U(t,l),I(u,c),o,i,s)}else{const c=F(t);Wt(c,a,r,i,s)&&Jt(c,e,n,r,o,i,s);const u=_(t,l);Wt(u,a,r,i,s)&&Jt(u,e,n,r,o,i,s)}}const Qt=["x","y","z"];function te(t,e,n,r,o,i){pt.setBuffer(t._roots[e]);const s=ee(0,t,n,r,o,i);return pt.clearBuffer(),s}function ee(t,e,n,r,o,i){const{float32Array:s,uint16Array:a,uint32Array:c}=pt;let l=2*t;if(S(l,a)){return function(t,e,n,r,o,i,s){const{geometry:a,_indirectBuffer:c}=t;let l=1/0,u=null;for(let f=r,d=r+o;f<d;f++){let t;t=Ht(a,e,n,f,null,i,s),t&&t.distance<l&&(u=t,l=t.distance)}return u}(e,n,r,U(t,c),I(l,a),o,i)}{const a=V(t,c),l=Qt[a],u=r.direction[l]>=0;let f,d;u?(f=F(t),d=_(t,c)):(f=_(t,c),d=F(t));const p=Wt(f,s,r,o,i)?ee(f,e,n,r,o,i):null;if(p){const t=p.point[l];if(u?t<=s[d+a]:t>=s[d+a+3])return p}const h=Wt(d,s,r,o,i)?ee(d,e,n,r,o,i):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const{Box3:ne,Matrix4:re}=await t("three"),oe=new ne,ie=new it,se=new it,ae=new re,ce=new lt,le=new lt;function ue(t,e,n,r){pt.setBuffer(t._roots[e]);const o=fe(0,t,n,r);return pt.clearBuffer(),o}function fe(t,e,n,r,o=null){const{float32Array:i,uint16Array:s,uint32Array:a}=pt;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),ce.set(n.boundingBox.min,n.boundingBox.max,r),o=ce);if(!S(c,s)){const s=t+8,c=a[t+6];h(s,i,oe);if(o.intersectsBox(oe)&&fe(s,e,n,r,o))return!0;h(c,i,oe);return!!(o.intersectsBox(oe)&&fe(c,e,n,r,o))}{const o=e.geometry,l=o.index,u=o.attributes.position,f=n.index,d=n.attributes.position,p=U(t,a),y=I(c,s);if(ae.copy(r).invert(),n.boundsTree){h(t,i,le),le.matrix.copy(ae),le.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>le.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let e=3*p,n=3*(y+p);e<n;e+=3)if(Zt(se,e,l,u),se.needsUpdate=!0,t.intersectsTriangle(se))return!0;return!1}})}for(let t=3*p,e=3*(y+p);t<e;t+=3){Zt(ie,t,l,u),ie.a.applyMatrix4(ae),ie.b.applyMatrix4(ae),ie.c.applyMatrix4(ae),ie.needsUpdate=!0;for(let t=0,e=f.count;t<e;t+=3)if(Zt(se,t,f,d),se.needsUpdate=!0,ie.intersectsTriangle(se))return!0}}}const{Matrix4:de,Vector3:pe}=await t("three"),he=new de,ye=new lt,xe=new lt,ge=new pe,me=new pe,we=new pe,Be=new pe;function be(t,e,n,r={},o={},i=0,s=1/0){e.boundingBox||e.computeBoundingBox(),ye.set(e.boundingBox.min,e.boundingBox.max,n),ye.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,u=a.index,f=e.attributes.position,d=e.index,p=dt.getPrimitive(),h=dt.getPrimitive();let y=ge,x=me,g=null,m=null;o&&(g=we,m=Be);let w=1/0,B=null,b=null;return he.copy(n).invert(),xe.matrix.copy(he),t.shapecast({boundsTraverseOrder:t=>ye.distanceToBox(t),intersectsBounds:(t,e,n)=>n<w&&n<s&&(e&&(xe.min.copy(t.min),xe.max.copy(t.max),xe.needsUpdate=!0),!0),intersectsRange:(t,r)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>xe.distanceToBox(t),intersectsBounds:(t,e,n)=>n<w&&n<s,intersectsRange:(e,o)=>{for(let s=e,a=e+o;s<a;s++){Zt(h,3*s,d,f),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){Zt(p,3*e,u,c),p.needsUpdate=!0;const t=p.distanceToTriangle(h,y,g);if(t<w&&(x.copy(y),m&&m.copy(g),w=t,B=e,b=s),t<i)return!0}}}})}for(let o=0,s=l(e);o<s;o++){Zt(h,3*o,d,f),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){Zt(p,3*e,u,c),p.needsUpdate=!0;const t=p.distanceToTriangle(h,y,g);if(t<w&&(x.copy(y),m&&m.copy(g),w=t,B=e,b=o),t<i)return!0}}}}),dt.releasePrimitive(p),dt.releasePrimitive(h),w===1/0?null:(r.point?r.point.copy(x):r.point=x.clone(),r.distance=w,r.faceIndex=B,o&&(o.point?o.point.copy(m):o.point=m.clone(),o.point.applyMatrix4(he),x.applyMatrix4(he),o.distance=x.sub(o.point).length(),o.faceIndex=b),r)}function Ae(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let s,a,c,l,u=0;const f=t._roots;for(let i=0,p=f.length;i<p;i++)s=f[i],a=new Uint32Array(s),c=new Uint16Array(s),l=new Float32Array(s),d(0,u),u+=s.byteLength;function d(n,s,u=!1){const f=2*n;if(c[f+15]===i){const e=a[n+6];let i=1/0,s=1/0,u=1/0,d=-1/0,p=-1/0,h=-1/0;for(let n=e,a=e+c[f+14];n<a;n++){const e=3*t.resolveTriangleIndex(n);for(let t=0;t<3;t++){let n=e+t;n=r?r[n]:n;const a=o.getX(n),c=o.getY(n),l=o.getZ(n);a<i&&(i=a),a>d&&(d=a),c<s&&(s=c),c>p&&(p=c),l<u&&(u=l),l>h&&(h=l)}}return(l[n+0]!==i||l[n+1]!==s||l[n+2]!==u||l[n+3]!==d||l[n+4]!==p||l[n+5]!==h)&&(l[n+0]=i,l[n+1]=s,l[n+2]=u,l[n+3]=d,l[n+4]=p,l[n+5]=h,!0)}{const t=n+8,r=a[n+6],o=t+s,i=r+s;let c=u,f=!1,p=!1;e?c||(f=e.has(o),p=e.has(i),c=!f&&!p):(f=!0,p=!0);const h=c||p;let y=!1;(c||f)&&(y=d(t,s,c));let x=!1;h&&(x=d(r,s,c));const g=y||x;if(g)for(let e=0;e<3;e++){const o=t+e,i=r+e,s=l[o],a=l[o+3],c=l[i],u=l[i+3];l[n+e]=s<c?s:c,l[n+e+3]=a>u?a:u}return g}}}function Te(t,e,n,r,o,i,s){pt.setBuffer(t._roots[e]),Pe(0,t,n,r,o,i,s),pt.clearBuffer()}function Pe(t,e,n,r,o,i,s){const{float32Array:a,uint16Array:c,uint32Array:l}=pt,u=2*t;if(S(u,c)){!function(t,e,n,r,o,i,s,a){const{geometry:c,_indirectBuffer:l}=t;for(let u=r,f=r+o;u<f;u++)Ht(c,e,n,l?l[u]:u,i,s,a)}(e,n,r,U(t,l),I(u,c),o,i,s)}else{const c=F(t);Wt(c,a,r,i,s)&&Pe(c,e,n,r,o,i,s);const u=_(t,l);Wt(u,a,r,i,s)&&Pe(u,e,n,r,o,i,s)}}const Me=["x","y","z"];function ve(t,e,n,r,o,i){pt.setBuffer(t._roots[e]);const s=Se(0,t,n,r,o,i);return pt.clearBuffer(),s}function Se(t,e,n,r,o,i){const{float32Array:s,uint16Array:a,uint32Array:c}=pt;let l=2*t;if(S(l,a)){return function(t,e,n,r,o,i,s){const{geometry:a,_indirectBuffer:c}=t;let l=1/0,u=null;for(let f=r,d=r+o;f<d;f++){let t;t=Ht(a,e,n,c?c[f]:f,null,i,s),t&&t.distance<l&&(u=t,l=t.distance)}return u}(e,n,r,U(t,c),I(l,a),o,i)}{const a=V(t,c),l=Me[a],u=r.direction[l]>=0;let f,d;u?(f=F(t),d=_(t,c)):(f=_(t,c),d=F(t));const p=Wt(f,s,r,o,i)?Se(f,e,n,r,o,i):null;if(p){const t=p.point[l];if(u?t<=s[d+a]:t>=s[d+a+3])return p}const h=Wt(d,s,r,o,i)?Se(d,e,n,r,o,i):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const{Box3:Ue,Matrix4:Ie}=await t("three"),Fe=new Ue,_e=new it,Ve=new it,ze=new Ie,qe=new lt,Ce=new lt;function Re(t,e,n,r){pt.setBuffer(t._roots[e]);const o=Ee(0,t,n,r);return pt.clearBuffer(),o}function Ee(t,e,n,r,o=null){const{float32Array:i,uint16Array:s,uint32Array:a}=pt;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),qe.set(n.boundingBox.min,n.boundingBox.max,r),o=qe);if(!S(c,s)){const s=t+8,c=a[t+6];h(s,i,Fe);if(o.intersectsBox(Fe)&&Ee(s,e,n,r,o))return!0;h(c,i,Fe);return!!(o.intersectsBox(Fe)&&Ee(c,e,n,r,o))}{const o=e.geometry,l=o.index,u=o.attributes.position,f=n.index,d=n.attributes.position,p=U(t,a),y=I(c,s);if(ze.copy(r).invert(),n.boundsTree){h(t,i,Ce),Ce.matrix.copy(ze),Ce.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>Ce.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let n=p,r=y+p;n<r;n++)if(Zt(Ve,3*e.resolveTriangleIndex(n),l,u),Ve.needsUpdate=!0,t.intersectsTriangle(Ve))return!0;return!1}})}for(let t=p,n=y+p;t<n;t++){const n=e.resolveTriangleIndex(t);Zt(_e,3*n,l,u),_e.a.applyMatrix4(ze),_e.b.applyMatrix4(ze),_e.c.applyMatrix4(ze),_e.needsUpdate=!0;for(let t=0,e=f.count;t<e;t+=3)if(Zt(Ve,t,f,d),Ve.needsUpdate=!0,_e.intersectsTriangle(Ve))return!0}}}const{Matrix4:Ne,Vector3:Oe}=await t("three"),Xe=new Ne,De=new lt,He=new lt,Le=new Oe,ke=new Oe,Ye=new Oe,Ze=new Oe;function je(t,e,n,r={},o={},i=0,s=1/0){e.boundingBox||e.computeBoundingBox(),De.set(e.boundingBox.min,e.boundingBox.max,n),De.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,u=a.index,f=e.attributes.position,d=e.index,p=dt.getPrimitive(),h=dt.getPrimitive();let y=Le,x=ke,g=null,m=null;o&&(g=Ye,m=Ze);let w=1/0,B=null,b=null;return Xe.copy(n).invert(),He.matrix.copy(Xe),t.shapecast({boundsTraverseOrder:t=>De.distanceToBox(t),intersectsBounds:(t,e,n)=>n<w&&n<s&&(e&&(He.min.copy(t.min),He.max.copy(t.max),He.needsUpdate=!0),!0),intersectsRange:(r,o)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>He.distanceToBox(t),intersectsBounds:(t,e,n)=>n<w&&n<s,intersectsRange:(e,s)=>{for(let l=e,A=e+s;l<A;l++){const e=a.resolveTriangleIndex(l);Zt(h,3*e,d,f),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let n=r,s=r+o;n<s;n++){const e=t.resolveTriangleIndex(n);Zt(p,3*e,u,c),p.needsUpdate=!0;const r=p.distanceToTriangle(h,y,g);if(r<w&&(x.copy(y),m&&m.copy(g),w=r,B=n,b=l),r<i)return!0}}}})}for(let s=0,a=l(e);s<a;s++){Zt(h,3*s,d,f),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=r,n=r+o;e<n;e++){const n=t.resolveTriangleIndex(e);Zt(p,3*n,u,c),p.needsUpdate=!0;const r=p.distanceToTriangle(h,y,g);if(r<w&&(x.copy(y),m&&m.copy(g),w=r,B=e,b=s),r<i)return!0}}}}),dt.releasePrimitive(p),dt.releasePrimitive(h),w===1/0?null:(r.point?r.point.copy(x):r.point=x.clone(),r.distance=w,r.faceIndex=B,o&&(o.point?o.point.copy(m):o.point=m.clone(),o.point.applyMatrix4(Xe),x.applyMatrix4(Xe),o.distance=x.sub(o.point).length(),o.faceIndex=b),r)}const{Box3:Ge,Matrix4:We}=await t("three"),$e=new pt.constructor,Ke=new pt.constructor,Je=new ut(()=>new Ge),Qe=new Ge,tn=new Ge,en=new Ge,nn=new Ge;let rn=!1;function on(t,e,n,r,o,i=0,s=0,a=0,c=0,l=null,u=!1){let f,d;u?(f=Ke,d=$e):(f=$e,d=Ke);const p=f.float32Array,y=f.uint32Array,x=f.uint16Array,g=d.float32Array,m=d.uint32Array,w=d.uint16Array,B=2*e,b=S(2*t,x),A=S(B,w);let T=!1;if(A&&b)T=u?o(U(e,m),I(2*e,w),U(t,y),I(2*t,x),c,s+e,a,i+t):o(U(t,y),I(2*t,x),U(e,m),I(2*e,w),a,i+t,c,s+e);else if(A){const l=Je.getPrimitive();h(e,g,l),l.applyMatrix4(n);const f=F(t),d=_(t,y);h(f,p,Qe),h(d,p,tn);const x=l.intersectsBox(Qe),m=l.intersectsBox(tn);T=x&&on(e,f,r,n,o,s,i,c,a+1,l,!u)||m&&on(e,d,r,n,o,s,i,c,a+1,l,!u),Je.releasePrimitive(l)}else{const f=F(e),d=_(e,m);h(f,g,en),h(d,g,nn);const x=l.intersectsBox(en),w=l.intersectsBox(nn);if(x&&w)T=on(t,f,n,r,o,i,s,a,c+1,l,u)||on(t,d,n,r,o,i,s,a,c+1,l,u);else if(x)if(b)T=on(t,f,n,r,o,i,s,a,c+1,l,u);else{const e=Je.getPrimitive();e.copy(en).applyMatrix4(n);const l=F(t),d=_(t,y);h(l,p,Qe),h(d,p,tn);const x=e.intersectsBox(Qe),g=e.intersectsBox(tn);T=x&&on(f,l,r,n,o,s,i,c,a+1,e,!u)||g&&on(f,d,r,n,o,s,i,c,a+1,e,!u),Je.releasePrimitive(e)}else if(w)if(b)T=on(t,d,n,r,o,i,s,a,c+1,l,u);else{const e=Je.getPrimitive();e.copy(nn).applyMatrix4(n);const l=F(t),f=_(t,y);h(l,p,Qe),h(f,p,tn);const x=e.intersectsBox(Qe),g=e.intersectsBox(tn);T=x&&on(d,l,r,n,o,s,i,c,a+1,e,!u)||g&&on(d,f,r,n,o,s,i,c,a+1,e,!u),Je.releasePrimitive(e)}}return T}const{BufferAttribute:sn,Box3:an,FrontSide:cn}=await t("three"),ln=new lt,un=new an,fn={strategy:0,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class dn{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,r=t._roots,o=t._indirectBuffer,i=n.getIndex();let s;return s=e.cloneBuffers?{roots:r.map(t=>t.slice()),index:i?i.array.slice():null,indirectBuffer:o?o.slice():null}:{roots:r,index:i?i.array:null,indirectBuffer:o},s}static deserialize(t,e,n={}){n={setIndex:!0,indirect:Boolean(t.indirectBuffer),...n};const{index:r,roots:o,indirectBuffer:i}=t,s=new dn(e,{...n,[a]:!0});if(s._roots=o,s._indirectBuffer=i||null,n.setIndex){const n=e.getIndex();if(null===n){const n=new sn(t.index,1,!1);e.setIndex(n)}else n.array!==r&&(n.array.set(r),n.needsUpdate=!0)}return s}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({...fn,[a]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[a]||(L(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new an))),this.resolveTriangleIndex=e.indirect?t=>this._indirectBuffer[t]:t=>t}refit(t=null){return(this.indirect?Ae:Gt)(this,t)}traverse(t,e=0){const n=this._roots[e],r=new Uint32Array(n),o=new Uint16Array(n);!function e(s,a=0){const c=2*s,l=o[c+15]===i;if(l){const e=r[s+6],i=o[c+14];t(a,l,new Float32Array(n,4*s,6),e,i)}else{const o=s+8,i=r[s+6],c=r[s+7];t(a,l,new Float32Array(n,4*s,6),c)||(e(o,a+1),e(i,a+1))}}(0)}raycast(t,e=cn,n=0,r=1/0){const o=this._roots,i=this.geometry,s=[],a=e.isMaterial,c=Array.isArray(e),l=i.groups,u=a?e.side:e,f=this.indirect?Te:Kt;for(let d=0,p=o.length;d<p;d++){const o=c?e[l[d].materialIndex].side:u,i=s.length;if(f(this,d,o,t,s,n,r),c){const t=l[d].materialIndex;for(let e=i,n=s.length;e<n;e++)s[e].face.materialIndex=t}}return s}raycastFirst(t,e=cn,n=0,r=1/0){const o=this._roots,i=this.geometry,s=e.isMaterial,a=Array.isArray(e);let c=null;const l=i.groups,u=s?e.side:e,f=this.indirect?ve:te;for(let d=0,p=o.length;d<p;d++){const o=f(this,d,a?e[l[d].materialIndex].side:u,t,n,r);null!=o&&(null==c||o.distance<c.distance)&&(c=o,a&&(o.face.materialIndex=l[d].materialIndex))}return c}intersectsGeometry(t,e){let n=!1;const r=this._roots,o=this.indirect?Re:ue;for(let i=0,s=r.length;i<s&&(n=o(this,i,t,e),!n);i++);return n}shapecast(t){const e=dt.getPrimitive(),n=this.indirect?$t:jt;let{boundsTraverseOrder:r,intersectsBounds:o,intersectsRange:i,intersectsTriangle:s}=t;if(i&&s){const t=i;i=(r,o,i,a,c)=>!!t(r,o,i,a,c)||n(r,o,this,s,i,a,e)}else i||(i=s?(t,r,o,i)=>n(t,r,this,s,o,i,e):(t,e,n)=>n);let a=!1,c=0;const l=this._roots;for(let u=0,f=l.length;u<f;u++){const t=l[u];if(a=wt(this,u,o,i,r,c),a)break;c+=t.byteLength}return dt.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:r,intersectsTriangles:o}=n;const i=dt.getPrimitive(),s=this.geometry.index,a=this.geometry.attributes.position,c=this.indirect?t=>{const e=this.resolveTriangleIndex(t);Zt(i,3*e,s,a)}:t=>{Zt(i,3*t,s,a)},l=dt.getPrimitive(),u=t.geometry.index,f=t.geometry.attributes.position,d=t.indirect?e=>{const n=t.resolveTriangleIndex(e);Zt(l,3*n,u,f)}:t=>{Zt(l,3*t,u,f)};if(o){const t=(t,n,r,s,a,u,f,p)=>{for(let h=r,y=r+s;h<y;h++){d(h),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(c(e),i.needsUpdate=!0,o(i,l,e,h,a,u,f,p))return!0}return!1};if(r){const e=r;r=function(n,r,o,i,s,a,c,l){return!!e(n,r,o,i,s,a,c,l)||t(n,r,o,i,s,a,c,l)}}else r=t}return function(t,e,n,r){if(rn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");rn=!0;const o=t._roots,i=e._roots;let s,a=0,c=0;const l=(new We).copy(n).invert();for(let u=0,f=o.length;u<f;u++){$e.setBuffer(o[u]),c=0;const t=Je.getPrimitive();h(z(0),$e.float32Array,t),t.applyMatrix4(l);for(let e=0,o=i.length;e<o&&(Ke.setBuffer(i[e]),s=on(0,0,n,l,r,a,c,0,0,t),Ke.clearBuffer(),c+=i[e].length,!s);e++);if(Je.releasePrimitive(t),$e.clearBuffer(),a+=o[u].length,s)break}return rn=!1,s}(this,t,e,r)}intersectsBox(t,e){return ln.set(t.min,t.max,e),ln.needsUpdate=!0,this.shapecast({intersectsBounds:t=>ln.intersectsBox(t),intersectsTriangle:t=>ln.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},r={},o=0,i=1/0){return(this.indirect?je:be)(this,t,e,n,r,o,i)}closestPointToPoint(t,e={},n=0,r=1/0){return function(t,e,n={},r=0,o=1/0){const i=r*r,s=o*o;let a=1/0,c=null;if(t.shapecast({boundsTraverseOrder:t=>(At.copy(e).clamp(t.min,t.max),At.distanceToSquared(e)),intersectsBounds:(t,e,n)=>n<a&&n<s,intersectsTriangle:(t,n)=>{t.closestPointToPoint(e,At);const r=e.distanceToSquared(At);return r<a&&(Tt.copy(At),a=r,c=n),r<i}}),a===1/0)return null;const l=Math.sqrt(a);return n.point?n.point.copy(Tt):n.point=Tt.clone(),n.distance=l,n.faceIndex=c,n}(this,t,e,n,r)}getBoundingBox(t){t.makeEmpty();return this._roots.forEach(e=>{h(0,new Float32Array(e),un),t.union(un)}),t}}function pn(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t)}const{Ray:hn,Matrix4:yn,Mesh:xn,Vector3:gn,Sphere:mn,BatchedMesh:wn,REVISION:Bn}=await t("three"),bn=new hn,An=new gn,Tn=new yn,Pn=xn.prototype.raycast,Mn=wn.prototype.raycast,vn=new gn,Sn=new xn,Un=[];function In(t,e){this.isBatchedMesh?Fn.call(this,t,e):_n.call(this,t,e)}function Fn(t,e){if(this.boundsTrees){const n=this.boundsTrees,r=this._drawInfo||this._instanceInfo,o=this._drawRanges||this._geometryInfo,i=this.matrixWorld;Sn.material=this.material,Sn.geometry=this.geometry;const s=Sn.geometry.boundsTree,a=Sn.geometry.drawRange;null===Sn.geometry.boundingSphere&&(Sn.geometry.boundingSphere=new mn);for(let c=0,l=r.length;c<l;c++){if(!this.getVisibleAt(c))continue;const s=r[c].geometryIndex;if(Sn.geometry.boundsTree=n[s],this.getMatrixAt(c,Sn.matrixWorld).premultiply(i),!Sn.geometry.boundsTree){this.getBoundingBoxAt(s,Sn.geometry.boundingBox),this.getBoundingSphereAt(s,Sn.geometry.boundingSphere);const t=o[s];Sn.geometry.setDrawRange(t.start,t.count)}Sn.raycast(t,Un);for(let t=0,n=Un.length;t<n;t++){const n=Un[t];n.object=this,n.batchId=c,e.push(n)}Un.length=0}Sn.geometry.boundsTree=s,Sn.geometry.drawRange=a,Sn.material=null,Sn.geometry=null}else Mn.call(this,t,e)}function _n(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;Tn.copy(this.matrixWorld).invert(),bn.copy(t.ray).applyMatrix4(Tn),vn.setFromMatrixScale(this.matrixWorld),An.copy(bn.direction).multiply(vn);const n=An.length(),r=t.near/n,o=t.far/n,i=this.geometry.boundsTree;if(!0===t.firstHitOnly){const n=pn(i.raycastFirst(bn,this.material,r,o),this,t);n&&e.push(n)}else{const n=i.raycast(bn,this.material,r,o);for(let r=0,o=n.length;r<o;r++){const o=pn(n[r],this,t);o&&e.push(o)}}}else Pn.call(this,t,e)}function Vn(t={}){return this.boundsTree=new dn(this,t),this.boundsTree}function zn(){this.boundsTree=null}export{r as CONTAINED,n as INTERSECTED,e as NOT_INTERSECTED,In as acceleratedRaycast,Vn as computeBoundsTree,zn as disposeBoundsTree};
