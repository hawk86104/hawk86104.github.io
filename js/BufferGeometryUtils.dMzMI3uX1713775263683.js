import{au as y,av as T,bC as E,bD as b,bE as G}from"./vendor.KaB9nKOc1713775263683.js";function x(i,a=!1){const r=i[0].index!==null,m=new Set(Object.keys(i[0].attributes)),s=new Set(Object.keys(i[0].morphAttributes)),f={},t={},d=i[0].morphTargetsRelative,u=new y;let g=0;for(let e=0;e<i.length;++e){const n=i[e];let l=0;if(r!==(n.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const o in n.attributes){if(!m.has(o))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+o+'" attribute exists among all geometries, or in none of them.'),null;f[o]===void 0&&(f[o]=[]),f[o].push(n.attributes[o]),l++}if(l!==m.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes."),null;if(d!==n.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const o in n.morphAttributes){if(!s.has(o))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries."),null;t[o]===void 0&&(t[o]=[]),t[o].push(n.morphAttributes[o])}if(a){let o;if(r)o=n.index.count;else if(n.attributes.position!==void 0)o=n.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute"),null;u.addGroup(g,o,e),g+=o}}if(r){let e=0;const n=[];for(let l=0;l<i.length;++l){const o=i[l].index;for(let c=0;c<o.count;++c)n.push(o.getX(c)+e);e+=i[l].attributes.position.count}u.setIndex(n)}for(const e in f){const n=p(f[e]);if(!n)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;u.setAttribute(e,n)}for(const e in t){const n=t[e][0].length;if(n===0)break;u.morphAttributes=u.morphAttributes||{},u.morphAttributes[e]=[];for(let l=0;l<n;++l){const o=[];for(let h=0;h<t[e].length;++h)o.push(t[e][h][l]);const c=p(o);if(!c)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;u.morphAttributes[e].push(c)}}return u}function p(i){let a,r,m,s=-1,f=0;for(let g=0;g<i.length;++g){const e=i[g];if(a===void 0&&(a=e.array.constructor),a!==e.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(r===void 0&&(r=e.itemSize),r!==e.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(m===void 0&&(m=e.normalized),m!==e.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(s===-1&&(s=e.gpuType),s!==e.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;f+=e.count*r}const t=new a(f),d=new T(t,r,m);let u=0;for(let g=0;g<i.length;++g){const e=i[g];if(e.isInterleavedBufferAttribute){const n=u/r;for(let l=0,o=e.count;l<o;l++)for(let c=0;c<r;c++){const h=e.getComponent(l,c);d.setComponent(l+n,c,h)}}else t.set(e.array,u);u+=e.count*r}return s!==void 0&&(d.gpuType=s),d}function B(i,a){if(a===E)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),i;if(a===b||a===G){let r=i.getIndex();if(r===null){const t=[],d=i.getAttribute("position");if(d!==void 0){for(let u=0;u<d.count;u++)t.push(u);i.setIndex(t),r=i.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),i}const m=r.count-2,s=[];if(a===b)for(let t=1;t<=m;t++)s.push(r.getX(0)),s.push(r.getX(t)),s.push(r.getX(t+1));else for(let t=0;t<m;t++)t%2===0?(s.push(r.getX(t)),s.push(r.getX(t+1)),s.push(r.getX(t+2))):(s.push(r.getX(t+2)),s.push(r.getX(t+1)),s.push(r.getX(t)));s.length/3!==m&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const f=i.clone();return f.setIndex(s),f.clearGroups(),f}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",a),i}export{x as m,B as t};
