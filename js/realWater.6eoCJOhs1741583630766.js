import{m as n,e,a as t,o as r,f as o}from"./@tresjs.ZmhvXhx31741583630766.js";import{P as i}from"./tweakpane.yDiyAAkA1741583630766.js";import{_ as c,aW as a,K as l,s,l as u,W as f,o as p,r as v}from"./three.sQDbNBks1741583630766.js";import{d as g,a3 as d,b as x,o as h,f as m,u as y,g as w,j as b,al as R,r as C,N as I,aj as _,ak as M}from"./@vue.NRI7TcgI1741583630766.js";import"./postprocessing.7Yq_IN-m1741583630766.js";import"./@vueuse.Z9_WSajh1741583630766.js";var z="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const D=L;!function(n,e){const t=L,r=O();for(;;)try{if(704380===-parseInt(t(250))/1+-parseInt(t(229))/2+-parseInt(t(266))/3+parseInt(t(246))/4*(-parseInt(t(236))/5)+-parseInt(t(237))/6+parseInt(t(261))/7+-parseInt(t(265))/8*(-parseInt(t(232))/9))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[L(245)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){A(this,(function(){const n=L,e=new RegExp(n(253)),t=new RegExp(n(231),"i"),r=j(n(241));e[n(264)](r+n(249))&&t[n(264)](r+n(273))?j():r("0")}))()}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[L(245)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function L(n,e){const t=O();return(L=function(n,e){return t[n-=225]})(n,e)}function O(){const n=["80oGIMRp","counter","exception","chain","1375013IlZJOg","value","constructor","function *\\( *\\)","FrontSide","string","render","log","trace","waterTexture","tiles","9644663vBKuOD","action","table","test","22543432IudgSj","3416202XKLlvy","water",'{}.constructor("return this")( )',"BufferGeometry","uniforms","toString","causticTex","input","BufferAttribute","info","call","pool","664544skqqSY","debu","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","9YoHKGT","stateObject","bind","Mesh","124765AysxXP","877674FHGJZz","prototype","length","causticsTexture","init","gger","setAttribute","console","apply"];return(O=function(){return n})()}T(void 0,(function(){const n=L,e=function(){const n=L;let e;try{e=Function("return (function() "+n(268)+");")()}catch(t){e=window}return e}(),t=e[n(244)]=e[n(244)]||{},r=[n(257),"warn",n(226),"error",n(248),n(263),n(258)];for(let o=0;o<r.length;o++){const e=T.constructor[n(238)][n(234)](T),i=r[o],c=t[i]||e;e.__proto__=T.bind(T),e[n(271)]=c[n(271)][n(234)](c),t[i]=e}}))();const F=g({__name:D(228),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=D,o=t,i=new(c[r(269)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(243)]("position",new(c[r(225)])(l,3)),i.setIndex(new(c[r(225)])(s,1));const u=new a({uniforms:{light:{value:o.light},tiles:{value:o[r(260)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(254)]}),f=new(c[r(235)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{const n=r;((n,e)=>{const t=r;u[t(270)][t(267)][t(251)]=n,u[t(270)][t(272)][t(251)]=e,p[t(251)][t(256)](f,v[t(251)])})(o[n(259)],o[n(240)])})),(n,e)=>null}});function j(n){function e(n){const t=L;if(typeof n===t(255))return function(n){}[t(252)]("while (true) {}").apply(t(247));1!==(""+n/n)[t(239)]||n%20==0?function(){return!0}[t(252)](t(230)+"gger")[t(227)](t(262)):function(){return!1}[t(252)](t(230)+t(242))[t(245)](t(233)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function E(n,e){const t=P();return(E=function(n,e){return t[n-=352]})(n,e)}!function(n,e){const t=E,r=P();for(;;)try{if(518296===-parseInt(t(381))/1*(-parseInt(t(385))/2)+parseInt(t(365))/3*(parseInt(t(409))/4)+parseInt(t(400))/5+parseInt(t(402))/6+parseInt(t(369))/7*(parseInt(t(404))/8)+-parseInt(t(382))/9*(-parseInt(t(390))/10)+-parseInt(t(352))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[E(415)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){S(this,(function(){const n=E,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(357),"i"),r=H("init");e.test(r+n(414))&&t[n(361)](r+n(373))?H():r("0")}))()}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[E(415)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function P(){const n=["toString","setPath","counter","130024cfykMv","neg-x.jpg","log","while (true) {}","trace","chain","apply","23904991pADRfw","causticsTexture","action","table","waterTexture","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","stateObject","bind","debu","test","return (function() ","render","neg-z.jpg","15bEBKPk","setRenderTarget","Mesh","pos-z.jpg","10213pbWrPN","constructor","geometry","value","input","length","clear","pooRef","gger","light","info","causticTex","2SZttZM","711eEBRDI","white","console","352622aiVmAR",'{}.constructor("return this")( )',"neg-y.jpg","call","tiles","27290UwakdI","CubeTextureLoader","uniforms","Color","side","water","exception","underwater","prototype","error","1947665paeRGO","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","5951868gYkUgG","FrontSide","3176YegAyB","RawShaderMaterial"];return(P=function(){return n})()}W(void 0,(function(){const n=E;let e;try{e=Function(n(362)+n(386)+");")()}catch(o){e=window}const t=e[n(384)]=e[n(384)]||{},r=[n(411),"warn",n(379),n(399),n(396),n(355),n(413)];for(let i=0;i<r[n(374)];i++){const e=W.constructor[n(398)][n(359)](W),o=r[i],c=t[o]||e;e.__proto__=W[n(359)](W),e[n(406)]=c[n(406)][n(359)](c),t[o]=e}}))();const k=g({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=E;let i,a;const s=r,u=s[o(371)],f=(new(c[o(391)]))[o(407)](o(401)).load(["pos-x.jpg",o(410),"pos-y.jpg",o(387),o(368),o(364)]),p=([i,a]=d((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),v=new(c[o(405)])({uniforms:{light:{value:s[o(378)]},tiles:{value:p},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),g=new(c[o(367)])(u,v),w=x(null),b=new(c[o(393)])(o(383)),{renderer:R,camera:C}=n(),{onLoop:I}=e();return I((()=>{const n=o;R[n(372)][n(366)](null),R[n(372)].setClearColor(b,1),R[n(372)][n(375)](),v.uniforms[n(395)][n(372)]=s[n(356)],v[n(392)][n(380)][n(372)]=s[n(353)],v[n(394)]=c[n(403)],v.uniforms.underwater.value=!0,R[n(372)][n(363)](g,C[n(372)]),v[n(394)]=l,v[n(392)][n(397)][n(372)]=!1,R.value.render(g,C[n(372)])})),(n,e)=>{const t=o;return h(),m(F,{tiles:y(p),light:n[t(378)],waterTexture:n[t(356)],causticsTexture:n[t(353)],ref_key:t(376),ref:w},null,8,[t(389),"light",t(356),t(353)])}}});function H(n){function e(n){const t=E;if("string"==typeof n)return function(n){}[t(370)](t(412)).apply(t(408));1!==(""+n/n)[t(374)]||n%20==0?function(){return!0}[t(370)](t(360)+t(377))[t(388)](t(354)):function(){return!1}[t(370)](t(360)+t(377))[t(415)](t(358)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=G,r=B();for(;;)try{if(883275===-parseInt(t(430))/1*(parseInt(t(450))/2)+parseInt(t(454))/3+parseInt(t(463))/4+parseInt(t(457))/5+parseInt(t(468))/6+-parseInt(t(451))/7+parseInt(t(470))/8*(-parseInt(t(453))/9))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const V=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[G(445)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){V(this,(function(){const n=G,e=new RegExp(n(477)),t=new RegExp(n(469),"i"),r=K(n(476));e[n(460)](r+n(435))&&t[n(460)](r+n(462))?K():r("0")}))()}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[G(445)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function G(n,e){const t=B();return(G=function(n,e){return t[n-=428]})(n,e)}function B(){const n=["Color","geometry","setRenderTarget","uniforms","init","function *\\( *\\)","waterTexture","texture","69765KZuMME","stateObject","value","__proto__","warn","chain","call","material","render","string","error","debu","length","counter","Mesh","apply","table","setClearColor","info","while (true) {}","20mnZyCA","9770124IkqBJl","constructor","1764nPbJlH","5069868jGosOb","OrthographicCamera","exception","1994825xoEmHX","black","console","test","light","input","3985580mGUmtp","causticsTexture","gger","bind","WebGLRenderTarget","10310718HRZjKS","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","74576JKsIbd",'{}.constructor("return this")( )'];return(B=function(){return n})()}Z(void 0,(function(){const n=G;let e;try{e=Function("return (function() "+n(471)+");")()}catch(o){e=window}const t=e[n(459)]=e.console||{},r=["log",n(434),n(448),n(440),n(456),n(446),"trace"];for(let i=0;i<r[n(442)];i++){const e=Z[n(452)].prototype[n(466)](Z),o=r[i],c=t[o]||e;e[n(433)]=Z[n(466)](Z),e.toString=c.toString.bind(c),t[o]=e}}))();const N=g({__name:"caustics",props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=G,o=t,i=new(c[r(455)])(0,1,1,0,0,2e3),a=new s(2,2,200,200),l=new(c[r(467)])(1024,1024),f=new u({uniforms:{light:{value:o[r(461)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new(c[r(444)])(a,f),v=new(c[r(472)])(r(458)),{renderer:g}=n(),{onBeforeLoop:d}=e();return d((()=>{const n=r;p[n(437)][n(475)].water[n(432)]=o[n(428)],g[n(432)][n(474)](l),g.value[n(447)](v,0),g.value.clear(),g[n(432)][n(438)](p,i)})),(n,e)=>{const t=r;return h(),m(R,null,{default:w((()=>[b(k,{waterTexture:n.waterTexture,causticsTexture:y(l)[t(429)],light:n.light,geometry:y(a)},null,8,[t(428),t(464),t(461),t(473)])])),_:1})}}});function K(n){function e(n){const t=G;if(typeof n===t(439))return function(n){}[t(452)](t(449))[t(445)](t(443));1!==(""+n/n)[t(442)]||n%20==0?function(){return!0}[t(452)](t(441)+t(465))[t(436)]("action"):function(){return!1}[t(452)](t(441)+t(465))[t(445)](t(431)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const $=Y;!function(n,e){const t=Y,r=q();for(;;)try{if(913820===-parseInt(t(456))/1+parseInt(t(448))/2*(-parseInt(t(505))/3)+parseInt(t(441))/4+-parseInt(t(496))/5+parseInt(t(443))/6*(parseInt(t(481))/7)+-parseInt(t(471))/8+parseInt(t(444))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const J=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Y(459)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){J(this,(function(){const n=Y,e=new RegExp(n(472)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=Q(n(495));e[n(467)](r+n(498))&&t[n(467)](r+n(450))?Q():r("0")}))()}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Y(459)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Y(n,e){const t=q();return(Y=function(n,e){return t[n-=438]})(n,e)}function q(){const n=["getBoundingClientRect","needsUpdate","constructor","273226oVxNkD","PlaneGeometry","input","while (true) {}","height","render","bind","counter","1368485hEZJDm","value","RawShaderMaterial","apply","mousemove","Vector2","waterSimulation","stateObject","width","center","light","test","Mesh","FloatType","setZ","11208920oBfrcz","function *\\( *\\)","addEventListener","table","toString","setY","intersectObject","action","warn","getY","7pXFWIS","return (function() ","exception","removeEventListener","left","info","error","WebGLRenderTarget","top","clientY","lightFrontGeometry","point","texture","debu","init","6417845bVHSAU","radius","chain","OrthographicCamera","count","uniforms","console","trace","material","6rFyrPL","gger","domElement","string","666440tHufNe","waterTexture","5625504CPfqnv","37224189PwtTpk"];return(q=function(){return n})()}U(void 0,(function(){const n=Y;let e;try{e=Function(n(482)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(502)]=e[n(502)]||{},r=["log",n(479),n(486),n(487),n(483),n(474),n(503)];for(let i=0;i<r.length;i++){const e=U[n(447)].prototype[n(454)](U),o=r[i],c=t[o]||e;e.__proto__=U[n(454)](U),e[n(475)]=c[n(475)][n(454)](c),t[o]=e}}))();const X=g({__name:$(462),props:{light:{}},setup(t,{expose:r}){const o=$,i=new(c[o(499)])(0,1,1,0,0,2e3),a=new s(2,2),l=new f(256,256,{type:p}),u=new(c[o(488)])(256,256,{type:c[o(469)]}),g=new(c[o(458)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),d=new(c[o(458)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),x=new(c[o(458)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),w=new v(a,g),b=new(c[o(468)])(a,d),R=new v(a,x);let C=l;const I=(n,e)=>{const t=o,r=C,c=C===l?u:l;e[t(504)][t(501)].texture[t(457)]=r[t(493)],n.setRenderTarget(c),n[t(453)](e,i),C=c},{renderer:_,camera:M,raycaster:D}=n();_[o(457)].autoClear=!1;const{onBeforeLoop:A}=e();A((()=>{const n=o;var e,t;t=_[n(457)],I(t,R),e=_[n(457)],I(e,b)}));const T=(n,e,t,r)=>{const i=o;w[i(504)][i(501)][i(465)][i(457)]=[n,e],w[i(504)][i(501)][i(497)][i(457)]=t,w[i(504)].uniforms.strength.value=r,I(_[i(457)],w)},L=new(c[o(461)]),O=new(c[o(449)])(2,2),F=O.attributes.position;for(let n=0;n<F[o(500)];n++){const e=-F[o(480)](n);F[o(476)](n,0),F[o(470)](n,e)}F[o(446)]=!0;const j=new(c[o(468)])(O),E={handleEvent:n=>{const e=o,t=_[e(457)].domElement[e(445)](),r=t[e(464)],i=t[e(452)];L.x=2*(n.clientX-t[e(485)])/r-1,L.y=2*-(n[e(490)]-t[e(489)])/i+1,D[e(457)].setFromCamera(L,M[e(457)]);const c=D.value[e(477)](j);for(let o of c)T(o.point.x,o[e(492)].z,.03,.04)}};return r({addDrop:T,mouseEvent:n=>{const e=o;n?_[e(457)].domElement[e(473)](e(460),E):_[e(457)][e(439)][e(484)]("mousemove",E)}}),(n,e)=>{const t=o;return h(),m(N,{lightFrontGeometry:y(a),waterTexture:y(C)[t(493)],light:n.light},null,8,[t(491),t(442),t(466)])}}});function Q(n){function e(n){const t=Y;if(typeof n===t(440))return function(n){}[t(447)](t(451))[t(459)](t(455));1!==(""+n/n).length||n%20==0?function(){return!0}.constructor("debu"+t(438)).call(t(478)):function(){return!1}[t(447)](t(494)+t(438))[t(459)](t(463)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const nn=rn;!function(n,e){const t=rn,r=tn();for(;;)try{if(650732===parseInt(t(421))/1+parseInt(t(437))/2*(-parseInt(t(398))/3)+-parseInt(t(399))/4*(parseInt(t(427))/5)+-parseInt(t(397))/6*(-parseInt(t(420))/7)+-parseInt(t(422))/8*(parseInt(t(444))/9)+parseInt(t(434))/10*(-parseInt(t(405))/11)+parseInt(t(446))/12)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[rn(445)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function tn(){const n=["bind","378wpCMEU","apply","36429240YcvKFj","prototype","310398fBAOWL","201mufacy","1805276RdHxDv","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","random","addButton","log","点击按钮","11GRGQCJ","error","鼠标波纹","__proto__","call","while (true) {}","warn","info","value","change","debu","stateObject","length","随机增加波纹","toString","140UMORVw","10386hhNUAY","105632dvRffv",'{}.constructor("return this")( )',"test","addBinding","realWater","10jgcwJP","return (function() ","addDrop","console","counter","gger","TresPerspectiveCamera","9168910iCOyKK","string","trace","31522eSkWJb","constructor","mouseEvent","input","exception","table"];return(tn=function(){return n})()}function rn(n,e){const t=tn();return(rn=function(n,e){return t[n-=397]})(n,e)}!function(){en(this,(function(){const n=rn,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(400),"i"),r=an("init");e[n(424)](r+"chain")&&t[n(424)](r+n(440))?an():r("0")}))()}();const on=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[rn(445)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();on(void 0,(function(){const n=rn,e=function(){const n=rn;let e;try{e=Function(n(428)+n(423)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(430)]||{},r=[n(403),n(411),n(412),n(406),n(441),n(442),n(436)];for(let o=0;o<r[n(417)];o++){const e=on.constructor[n(447)][n(443)](on),i=r[o],c=t[i]||e;e[n(408)]=on.bind(on),e[n(419)]=c.toString[n(443)](c),t[i]=e}}))();const cn=g({__name:nn(426),setup(n){const e=nn,t=C({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:"manual"}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=x(null),l=new i;l[e(402)]({label:e(404),title:e(418)}).on("click",(()=>{const n=e;for(var t=0;t<10;t++)a[n(413)][n(429)](2*Math[n(401)]()-1,2*Math[n(401)]()-1,.03,1&t?.02:-.02)}));const s=x(!1);return l[e(425)](s,"value",{label:e(407)}).on(e(414),(n=>{const t=e;a[t(413)][t(439)](n.value)})),(n,i)=>{const l=e;return h(),m(y(o),_(M(t)),{default:w((()=>[i[0]||(i[0]=I(l(433),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),b(y(r)),b(X,{light:c,ref_key:"waterSimulationRef",ref:a},null,512)])),_:1},16)}}});function an(n){function e(n){const t=rn;if(typeof n===t(435))return function(n){}.constructor(t(410))[t(445)](t(431));1!==(""+n/n)[t(417)]||n%20==0?function(){return!0}[t(438)](t(415)+"gger")[t(409)]("action"):function(){return!1}[t(438)](t(415)+t(432))[t(445)](t(416)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{cn as default};
