import{importShared as t}from"./3d-tiles-renderer.de6b_qgz1767149344623.js";const e=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let i=1234567;const s=Math.PI/180,n=180/Math.PI;function r(t,e,i){return Math.max(e,Math.min(i,t))}function a(t,e){return(t%e+e)%e}function o(t,e,i){return(1-i)*t+i*e}const h={DEG2RAD:s,RAD2DEG:n,generateUUID:function(){const t=4294967295*Math.random()|0,i=4294967295*Math.random()|0,s=4294967295*Math.random()|0,n=4294967295*Math.random()|0;return(e[255&t]+e[t>>8&255]+e[t>>16&255]+e[t>>24&255]+"-"+e[255&i]+e[i>>8&255]+"-"+e[i>>16&15|64]+e[i>>24&255]+"-"+e[63&s|128]+e[s>>8&255]+"-"+e[s>>16&255]+e[s>>24&255]+e[255&n]+e[n>>8&255]+e[n>>16&255]+e[n>>24&255]).toLowerCase()},clamp:r,euclideanModulo:a,mapLinear:function(t,e,i,s,n){return s+(t-e)*(n-s)/(i-e)},inverseLerp:function(t,e,i){return t!==e?(i-t)/(e-t):0},lerp:o,damp:function(t,e,i,s){return o(t,e,1-Math.exp(-i*s))},pingpong:function(t,e=1){return e-Math.abs(a(t,2*e)-e)},smoothstep:function(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*(3-2*t)},smootherstep:function(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(i=t);let e=i+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},degToRad:function(t){return t*s},radToDeg:function(t){return t*n},isPowerOfTwo:function(t){return!(t&t-1)&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},setQuaternionFromProperEuler:function(t,e,i,s,n){const r=Math.cos,a=Math.sin,o=r(i/2),h=a(i/2),l=r((e+s)/2),c=a((e+s)/2),d=r((e-s)/2),u=a((e-s)/2),m=r((s-e)/2),p=a((s-e)/2);switch(n){case"XYX":t.set(o*c,h*d,h*u,o*l);break;case"YZY":t.set(h*u,o*c,h*d,o*l);break;case"ZXZ":t.set(h*d,h*u,o*c,o*l);break;case"XZX":t.set(o*c,h*p,h*m,o*l);break;case"YXY":t.set(h*m,o*c,h*p,o*l);break;case"ZYZ":t.set(h*p,h*m,o*c,o*l);break;default:console.warn("../math.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+n)}},normalize:function(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}},denormalize:function(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}};class l{constructor(t=0,e=0,i=0,s=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=i,this._w=s}static slerpFlat(t,e,i,s,n,r,a){let o=i[s+0],h=i[s+1],l=i[s+2],c=i[s+3];const d=n[r+0],u=n[r+1],m=n[r+2],p=n[r+3];if(0===a)return t[e+0]=o,t[e+1]=h,t[e+2]=l,void(t[e+3]=c);if(1===a)return t[e+0]=d,t[e+1]=u,t[e+2]=m,void(t[e+3]=p);if(c!==p||o!==d||h!==u||l!==m){let t=1-a;const e=o*d+h*u+l*m+c*p,i=e>=0?1:-1,s=1-e*e;if(s>Number.EPSILON){const n=Math.sqrt(s),r=Math.atan2(n,e*i);t=Math.sin(t*r)/n,a=Math.sin(a*r)/n}const n=a*i;if(o=o*t+d*n,h=h*t+u*n,l=l*t+m*n,c=c*t+p*n,t===1-a){const t=1/Math.sqrt(o*o+h*h+l*l+c*c);o*=t,h*=t,l*=t,c*=t}}t[e]=o,t[e+1]=h,t[e+2]=l,t[e+3]=c}static multiplyQuaternionsFlat(t,e,i,s,n,r){const a=i[s],o=i[s+1],h=i[s+2],l=i[s+3],c=n[r],d=n[r+1],u=n[r+2],m=n[r+3];return t[e]=a*m+l*c+o*u-h*d,t[e+1]=o*m+l*d+h*c-a*u,t[e+2]=h*m+l*u+a*d-o*c,t[e+3]=l*m-a*c-o*d-h*u,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,s){return this._x=t,this._y=e,this._z=i,this._w=s,this._onChangeCallback(),this}clone(){return new l(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const i=t._x,s=t._y,n=t._z,r=t._order,a=Math.cos,o=Math.sin,h=a(i/2),l=a(s/2),c=a(n/2),d=o(i/2),u=o(s/2),m=o(n/2);switch(r){case"XYZ":this._x=d*l*c+h*u*m,this._y=h*u*c-d*l*m,this._z=h*l*m+d*u*c,this._w=h*l*c-d*u*m;break;case"YXZ":this._x=d*l*c+h*u*m,this._y=h*u*c-d*l*m,this._z=h*l*m-d*u*c,this._w=h*l*c+d*u*m;break;case"ZXY":this._x=d*l*c-h*u*m,this._y=h*u*c+d*l*m,this._z=h*l*m+d*u*c,this._w=h*l*c-d*u*m;break;case"ZYX":this._x=d*l*c-h*u*m,this._y=h*u*c+d*l*m,this._z=h*l*m-d*u*c,this._w=h*l*c+d*u*m;break;case"YZX":this._x=d*l*c+h*u*m,this._y=h*u*c+d*l*m,this._z=h*l*m-d*u*c,this._w=h*l*c-d*u*m;break;case"XZY":this._x=d*l*c-h*u*m,this._y=h*u*c-d*l*m,this._z=h*l*m+d*u*c,this._w=h*l*c+d*u*m;break;default:console.warn("../math.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return!0===e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,s=Math.sin(i);return this._x=t.x*s,this._y=t.y*s,this._z=t.z*s,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],s=e[4],n=e[8],r=e[1],a=e[5],o=e[9],h=e[2],l=e[6],c=e[10],d=i+a+c;if(d>0){const t=.5/Math.sqrt(d+1);this._w=.25/t,this._x=(l-o)*t,this._y=(n-h)*t,this._z=(r-s)*t}else if(i>a&&i>c){const t=2*Math.sqrt(1+i-a-c);this._w=(l-o)/t,this._x=.25*t,this._y=(s+r)/t,this._z=(n+h)/t}else if(a>c){const t=2*Math.sqrt(1+a-i-c);this._w=(n-h)/t,this._x=(s+r)/t,this._y=.25*t,this._z=(o+l)/t}else{const t=2*Math.sqrt(1+c-i-a);this._w=(r-s)/t,this._x=(n+h)/t,this._y=(o+l)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(r(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(0===i)return this;const s=Math.min(1,e/i);return this.slerp(t,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,s=t._y,n=t._z,r=t._w,a=e._x,o=e._y,h=e._z,l=e._w;return this._x=i*l+r*a+s*h-n*o,this._y=s*l+r*o+n*a-i*h,this._z=n*l+r*h+i*o-s*a,this._w=r*l-i*a-s*o-n*h,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const i=this._x,s=this._y,n=this._z,r=this._w;let a=r*t._w+i*t._x+s*t._y+n*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=r,this._x=i,this._y=s,this._z=n,this;const o=1-a*a;if(o<=Number.EPSILON){const t=1-e;return this._w=t*r+e*this._w,this._x=t*i+e*this._x,this._y=t*s+e*this._y,this._z=t*n+e*this._z,this.normalize(),this}const h=Math.sqrt(o),l=Math.atan2(h,a),c=Math.sin((1-e)*l)/h,d=Math.sin(e*l)/h;return this._w=r*c+this._w*d,this._x=i*c+this._x*d,this._y=s*c+this._y*d,this._z=n*c+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),i=Math.random(),s=Math.sqrt(1-i),n=Math.sqrt(i);return this.set(s*Math.sin(t),s*Math.cos(t),n*Math.sin(e),n*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}let c=class t{constructor(e=0,i=0,s=0){this.isVector3=!0,t.prototype.isVector3=!0,this.x=e,this.y=i,this.z=s}set(t,e,i){return void 0===i&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new t(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(u.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(u.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,s=this.z,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6]*s,this.y=n[1]*e+n[4]*i+n[7]*s,this.z=n[2]*e+n[5]*i+n[8]*s,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,n=t.elements,r=1/(n[3]*e+n[7]*i+n[11]*s+n[15]);return this.x=(n[0]*e+n[4]*i+n[8]*s+n[12])*r,this.y=(n[1]*e+n[5]*i+n[9]*s+n[13])*r,this.z=(n[2]*e+n[6]*i+n[10]*s+n[14])*r,this}applyQuaternion(t){const e=this.x,i=this.y,s=this.z,n=t.x,r=t.y,a=t.z,o=t.w,h=2*(r*s-a*i),l=2*(a*e-n*s),c=2*(n*i-r*e);return this.x=e+o*h+r*c-a*l,this.y=i+o*l+a*h-n*c,this.z=s+o*c+n*l-r*h,this}transformDirection(t){const e=this.x,i=this.y,s=this.z,n=t.elements;return this.x=n[0]*e+n[4]*i+n[8]*s,this.y=n[1]*e+n[5]*i+n[9]*s,this.z=n[2]*e+n[6]*i+n[10]*s,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,s=t.y,n=t.z,r=e.x,a=e.y,o=e.z;return this.x=s*o-n*a,this.y=n*r-i*o,this.z=i*a-s*r,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return d.copy(this).projectOnVector(t),this.sub(d)}reflect(t){return this.sub(d.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(r(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,s=this.z-t.z;return e*e+i*i+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSphericalCoords(t,e,i){const s=Math.sin(e)*t;return this.x=s*Math.sin(i),this.y=Math.cos(e)*t,this.z=s*Math.cos(i),this}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),s=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=s,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=2*Math.random()-1,i=Math.sqrt(1-e*e);return this.x=i*Math.cos(t),this.y=e,this.z=i*Math.sin(t),this}abs(){return this.x=Math.abs(this.x),this.y=Math.abs(this.y),this.z=Math.abs(this.z),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}};const d=new c,u=new l,m=2e3;class p{constructor(t,e,i,s,n,r,a,o,h,l,c,d,u,m,f,y){this.isMatrix4=!0,p.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==t&&this.set(t,e,i,s,n,r,a,o,h,l,c,d,u,m,f,y)}extractPosition(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)}multiplyToArray(t,e,i){return console.error("THREE.Matrix4: .multiplyToArray() has been removed."),this}setRotationFromQuaternion(t){return this.makeRotationFromQuaternion(t)}set(t,e,i,s,n,r,a,o,h,l,c,d,u,m,p,f){const y=this.elements;return y[0]=t,y[4]=e,y[8]=i,y[12]=s,y[1]=n,y[5]=r,y[9]=a,y[13]=o,y[2]=h,y[6]=l,y[10]=c,y[14]=d,y[3]=u,y[7]=m,y[11]=p,y[15]=f,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new p).fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,s=1/f.setFromMatrixColumn(t,0).length(),n=1/f.setFromMatrixColumn(t,1).length(),r=1/f.setFromMatrixColumn(t,2).length();return e[0]=i[0]*s,e[1]=i[1]*s,e[2]=i[2]*s,e[3]=0,e[4]=i[4]*n,e[5]=i[5]*n,e[6]=i[6]*n,e[7]=0,e[8]=i[8]*r,e[9]=i[9]*r,e[10]=i[10]*r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,i=t.x,s=t.y,n=t.z,r=Math.cos(i),a=Math.sin(i),o=Math.cos(s),h=Math.sin(s),l=Math.cos(n),c=Math.sin(n);if("XYZ"===t.order){const t=r*l,i=r*c,s=a*l,n=a*c;e[0]=o*l,e[4]=-o*c,e[8]=h,e[1]=i+s*h,e[5]=t-n*h,e[9]=-a*o,e[2]=n-t*h,e[6]=s+i*h,e[10]=r*o}else if("YXZ"===t.order){const t=o*l,i=o*c,s=h*l,n=h*c;e[0]=t+n*a,e[4]=s*a-i,e[8]=r*h,e[1]=r*c,e[5]=r*l,e[9]=-a,e[2]=i*a-s,e[6]=n+t*a,e[10]=r*o}else if("ZXY"===t.order){const t=o*l,i=o*c,s=h*l,n=h*c;e[0]=t-n*a,e[4]=-r*c,e[8]=s+i*a,e[1]=i+s*a,e[5]=r*l,e[9]=n-t*a,e[2]=-r*h,e[6]=a,e[10]=r*o}else if("ZYX"===t.order){const t=r*l,i=r*c,s=a*l,n=a*c;e[0]=o*l,e[4]=s*h-i,e[8]=t*h+n,e[1]=o*c,e[5]=n*h+t,e[9]=i*h-s,e[2]=-h,e[6]=a*o,e[10]=r*o}else if("YZX"===t.order){const t=r*o,i=r*h,s=a*o,n=a*h;e[0]=o*l,e[4]=n-t*c,e[8]=s*c+i,e[1]=c,e[5]=r*l,e[9]=-a*l,e[2]=-h*l,e[6]=i*c+s,e[10]=t-n*c}else if("XZY"===t.order){const t=r*o,i=r*h,s=a*o,n=a*h;e[0]=o*l,e[4]=-c,e[8]=h*l,e[1]=t*c+n,e[5]=r*l,e[9]=i*c-s,e[2]=s*c-i,e[6]=a*l,e[10]=n*c+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(g,t,v)}lookAt(t,e,i){const s=this.elements;return M.subVectors(t,e),0===M.lengthSq()&&(M.z=1),M.normalize(),x.crossVectors(i,M),0===x.lengthSq()&&(1===Math.abs(i.z)?M.x+=1e-4:M.z+=1e-4,M.normalize(),x.crossVectors(i,M)),x.normalize(),S.crossVectors(M,x),s[0]=x.x,s[4]=S.x,s[8]=M.x,s[1]=x.y,s[5]=S.y,s[9]=M.y,s[2]=x.z,s[6]=S.z,s[10]=M.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,n=this.elements,r=i[0],a=i[4],o=i[8],h=i[12],l=i[1],c=i[5],d=i[9],u=i[13],m=i[2],p=i[6],f=i[10],y=i[14],g=i[3],v=i[7],x=i[11],S=i[15],M=s[0],_=s[4],w=s[8],z=s[12],b=s[1],O=s[5],A=s[9],T=s[13],N=s[2],E=s[6],P=s[10],U=s[14],C=s[3],B=s[7],R=s[11],k=s[15];return n[0]=r*M+a*b+o*N+h*C,n[4]=r*_+a*O+o*E+h*B,n[8]=r*w+a*A+o*P+h*R,n[12]=r*z+a*T+o*U+h*k,n[1]=l*M+c*b+d*N+u*C,n[5]=l*_+c*O+d*E+u*B,n[9]=l*w+c*A+d*P+u*R,n[13]=l*z+c*T+d*U+u*k,n[2]=m*M+p*b+f*N+y*C,n[6]=m*_+p*O+f*E+y*B,n[10]=m*w+p*A+f*P+y*R,n[14]=m*z+p*T+f*U+y*k,n[3]=g*M+v*b+x*N+S*C,n[7]=g*_+v*O+x*E+S*B,n[11]=g*w+v*A+x*P+S*R,n[15]=g*z+v*T+x*U+S*k,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],s=t[8],n=t[12],r=t[1],a=t[5],o=t[9],h=t[13],l=t[2],c=t[6],d=t[10],u=t[14];return t[3]*(+n*o*c-s*h*c-n*a*d+i*h*d+s*a*u-i*o*u)+t[7]*(+e*o*u-e*h*d+n*r*d-s*r*u+s*h*l-n*o*l)+t[11]*(+e*h*c-e*a*u-n*r*c+i*r*u+n*a*l-i*h*l)+t[15]*(-s*a*l-e*o*c+e*a*d+s*r*c-i*r*d+i*o*l)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const s=this.elements;return t.isVector3?(s[12]=t.x,s[13]=t.y,s[14]=t.z):(s[12]=t,s[13]=e,s[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],a=t[5],o=t[6],h=t[7],l=t[8],c=t[9],d=t[10],u=t[11],m=t[12],p=t[13],f=t[14],y=t[15],g=c*f*h-p*d*h+p*o*u-a*f*u-c*o*y+a*d*y,v=m*d*h-l*f*h-m*o*u+r*f*u+l*o*y-r*d*y,x=l*p*h-m*c*h+m*a*u-r*p*u-l*a*y+r*c*y,S=m*c*o-l*p*o-m*a*d+r*p*d+l*a*f-r*c*f,M=e*g+i*v+s*x+n*S;if(0===M)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const _=1/M;return t[0]=g*_,t[1]=(p*d*n-c*f*n-p*s*u+i*f*u+c*s*y-i*d*y)*_,t[2]=(a*f*n-p*o*n+p*s*h-i*f*h-a*s*y+i*o*y)*_,t[3]=(c*o*n-a*d*n-c*s*h+i*d*h+a*s*u-i*o*u)*_,t[4]=v*_,t[5]=(l*f*n-m*d*n+m*s*u-e*f*u-l*s*y+e*d*y)*_,t[6]=(m*o*n-r*f*n-m*s*h+e*f*h+r*s*y-e*o*y)*_,t[7]=(r*d*n-l*o*n+l*s*h-e*d*h-r*s*u+e*o*u)*_,t[8]=x*_,t[9]=(m*c*n-l*p*n-m*i*u+e*p*u+l*i*y-e*c*y)*_,t[10]=(r*p*n-m*a*n+m*i*h-e*p*h-r*i*y+e*a*y)*_,t[11]=(l*a*n-r*c*n-l*i*h+e*c*h+r*i*u-e*a*u)*_,t[12]=S*_,t[13]=(l*p*s-m*c*s+m*i*d-e*p*d-l*i*f+e*c*f)*_,t[14]=(m*a*s-r*p*s-m*i*o+e*p*o+r*i*f-e*a*f)*_,t[15]=(r*c*s-l*a*s+l*i*o-e*c*o-r*i*d+e*a*d)*_,this}scale(t){const e=this.elements,i=t.x,s=t.y,n=t.z;return e[0]*=i,e[4]*=s,e[8]*=n,e[1]*=i,e[5]*=s,e[9]*=n,e[2]*=i,e[6]*=s,e[10]*=n,e[3]*=i,e[7]*=s,e[11]*=n,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],s=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,s))}makeTranslation(t,e,i){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),s=Math.sin(e),n=1-i,r=t.x,a=t.y,o=t.z,h=n*r,l=n*a;return this.set(h*r+i,h*a-s*o,h*o+s*a,0,h*a+s*o,l*a+i,l*o-s*r,0,h*o-s*a,l*o+s*r,n*o*o+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,s,n,r){return this.set(1,i,n,0,t,1,r,0,e,s,1,0,0,0,0,1),this}compose(t,e,i){const s=this.elements,n=e._x,r=e._y,a=e._z,o=e._w,h=n+n,l=r+r,c=a+a,d=n*h,u=n*l,m=n*c,p=r*l,f=r*c,y=a*c,g=o*h,v=o*l,x=o*c,S=i.x,M=i.y,_=i.z;return s[0]=(1-(p+y))*S,s[1]=(u+x)*S,s[2]=(m-v)*S,s[3]=0,s[4]=(u-x)*M,s[5]=(1-(d+y))*M,s[6]=(f+g)*M,s[7]=0,s[8]=(m+v)*_,s[9]=(f-g)*_,s[10]=(1-(d+p))*_,s[11]=0,s[12]=t.x,s[13]=t.y,s[14]=t.z,s[15]=1,this}decompose(t,e,i){const s=this.elements;let n=f.set(s[0],s[1],s[2]).length();const r=f.set(s[4],s[5],s[6]).length(),a=f.set(s[8],s[9],s[10]).length();this.determinant()<0&&(n=-n),t.x=s[12],t.y=s[13],t.z=s[14],y.copy(this);const o=1/n,h=1/r,l=1/a;return y.elements[0]*=o,y.elements[1]*=o,y.elements[2]*=o,y.elements[4]*=h,y.elements[5]*=h,y.elements[6]*=h,y.elements[8]*=l,y.elements[9]*=l,y.elements[10]*=l,e.setFromRotationMatrix(y),i.x=n,i.y=r,i.z=a,this}makePerspective(t,e,i,s,n,r,a=2e3){const o=this.elements,h=2*n/(e-t),l=2*n/(i-s),c=(e+t)/(e-t),d=(i+s)/(i-s);let u,p;if(a===m)u=-(r+n)/(r-n),p=-2*r*n/(r-n);else{if(2001!==a)throw new Error("Matrix4.makePerspective(): Invalid coordinate system: "+a);u=-r/(r-n),p=-r*n/(r-n)}return o[0]=h,o[4]=0,o[8]=c,o[12]=0,o[1]=0,o[5]=l,o[9]=d,o[13]=0,o[2]=0,o[6]=0,o[10]=u,o[14]=p,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,i,s,n,r,a=2e3){const o=this.elements,h=1/(e-t),l=1/(i-s),c=1/(r-n),d=(e+t)*h,u=(i+s)*l;let p,f;if(a===m)p=(r+n)*c,f=-2*c;else{if(2001!==a)throw new Error("../math.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);p=n*c,f=-1*c}return o[0]=2*h,o[4]=0,o[8]=0,o[12]=-d,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-u,o[2]=0,o[6]=0,o[10]=f,o[14]=-p,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<16;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}const f=new c,y=new p,g=new c(0,0,0),v=new c(1,1,1),x=new c,S=new c,M=new c,_=new p,w=new l;class z{constructor(t=0,e=0,i=0,s=z.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=i,this._order=s}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,s=this._order){return this._x=t,this._y=e,this._z=i,this._order=s,this._onChangeCallback(),this}clone(){return new z(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const s=t.elements,n=s[0],a=s[4],o=s[8],h=s[1],l=s[5],c=s[9],d=s[2],u=s[6],m=s[10];switch(e){case"XYZ":this._y=Math.asin(r(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,m),this._z=Math.atan2(-a,n)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-r(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(o,m),this._z=Math.atan2(h,l)):(this._y=Math.atan2(-d,n),this._z=0);break;case"ZXY":this._x=Math.asin(r(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-d,m),this._z=Math.atan2(-a,l)):(this._y=0,this._z=Math.atan2(h,n));break;case"ZYX":this._y=Math.asin(-r(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(u,m),this._z=Math.atan2(h,n)):(this._x=0,this._z=Math.atan2(-a,l));break;case"YZX":this._z=Math.asin(r(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-d,n)):(this._x=0,this._y=Math.atan2(o,m));break;case"XZY":this._z=Math.asin(-r(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(o,n)):(this._x=Math.atan2(-c,m),this._y=0);break;default:console.warn("../math.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===i&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return _.makeRotationFromQuaternion(t),this.setFromRotationMatrix(_,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return w.setFromEuler(this),this.setFromQuaternion(w,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(t){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}z.DEFAULT_ORDER="XYZ";class b{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new b(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,s=t.elements;return this.x=s[0]*e+s[3]*i+s[6],this.y=s[1]*e+s[4]*i+s[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(r(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}rotateAround(t,e){const i=Math.cos(e),s=Math.sin(e),n=this.x-t.x,r=this.y-t.y;return this.x=n*i-r*s+t.x,this.y=n*s+r*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}b.isVector2=!0;class O{constructor(t=0,e=0,i=0,s=1){O.prototype.isVector4=!0,this.x=t,this.y=e,this.z=i,this.w=s}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,s){return this.x=t,this.y=e,this.z=i,this.w=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new O(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,n=this.w,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*s+r[12]*n,this.y=r[1]*e+r[5]*i+r[9]*s+r[13]*n,this.z=r[2]*e+r[6]*i+r[10]*s+r[14]*n,this.w=r[3]*e+r[7]*i+r[11]*s+r[15]*n,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,s,n;const r=.01,a=.1,o=t.elements,h=o[0],l=o[4],c=o[8],d=o[1],u=o[5],m=o[9],p=o[2],f=o[6],y=o[10];if(Math.abs(l-d)<r&&Math.abs(c-p)<r&&Math.abs(m-f)<r){if(Math.abs(l+d)<a&&Math.abs(c+p)<a&&Math.abs(m+f)<a&&Math.abs(h+u+y-3)<a)return this.set(1,0,0,0),this;e=Math.PI;const t=(h+1)/2,o=(u+1)/2,g=(y+1)/2,v=(l+d)/4,x=(c+p)/4,S=(m+f)/4;return t>o&&t>g?t<r?(i=0,s=.707106781,n=.707106781):(i=Math.sqrt(t),s=v/i,n=x/i):o>g?o<r?(i=.707106781,s=0,n=.707106781):(s=Math.sqrt(o),i=v/s,n=S/s):g<r?(i=.707106781,s=.707106781,n=0):(n=Math.sqrt(g),i=x/n,s=S/n),this.set(i,s,n,e),this}let g=Math.sqrt((f-m)*(f-m)+(c-p)*(c-p)+(d-l)*(d-l));return Math.abs(g)<.001&&(g=1),this.x=(f-m)/g,this.y=(c-p)/g,this.z=(d-l)/g,this.w=Math.acos((h+u+y-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class A{constructor(t,e,i,s,n,r,a,o,h){A.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,i,s,n,r,a,o,h)}set(t,e,i,s,n,r,a,o,h){const l=this.elements;return l[0]=t,l[1]=s,l[2]=a,l[3]=e,l[4]=n,l[5]=o,l[6]=i,l[7]=r,l[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,n=this.elements,r=i[0],a=i[3],o=i[6],h=i[1],l=i[4],c=i[7],d=i[2],u=i[5],m=i[8],p=s[0],f=s[3],y=s[6],g=s[1],v=s[4],x=s[7],S=s[2],M=s[5],_=s[8];return n[0]=r*p+a*g+o*S,n[3]=r*f+a*v+o*M,n[6]=r*y+a*x+o*_,n[1]=h*p+l*g+c*S,n[4]=h*f+l*v+c*M,n[7]=h*y+l*x+c*_,n[2]=d*p+u*g+m*S,n[5]=d*f+u*v+m*M,n[8]=d*y+u*x+m*_,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],a=t[5],o=t[6],h=t[7],l=t[8];return e*r*l-e*a*h-i*n*l+i*a*o+s*n*h-s*r*o}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],a=t[5],o=t[6],h=t[7],l=t[8],c=l*r-a*h,d=a*o-l*n,u=h*n-r*o,m=e*c+i*d+s*u;if(0===m)return this.set(0,0,0,0,0,0,0,0,0);const p=1/m;return t[0]=c*p,t[1]=(s*h-l*i)*p,t[2]=(a*i-s*r)*p,t[3]=d*p,t[4]=(l*e-s*o)*p,t[5]=(s*n-a*e)*p,t[6]=u*p,t[7]=(i*o-h*e)*p,t[8]=(r*e-i*n)*p,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,s,n,r,a){const o=Math.cos(n),h=Math.sin(n);return this.set(i*o,i*h,-i*(o*r+h*a)+r+t,-s*h,s*o,-s*(-h*r+o*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply(T.makeScale(t,e)),this}rotate(t){return this.premultiply(T.makeRotation(-t)),this}translate(t,e){return this.premultiply(T.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,i,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<9;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return(new A).fromArray(this.elements)}}const T=new A;var N;function E(t,e,i,s){let n;switch(N.Random===t?e=Math.random():N.Burst===t&&s.isBursting&&(e=s.burstParticleIndex/s.burstParticleCount),n=i>0?Math.floor(e/i)*i:e,t){case N.Loop:n%=1;break;case N.PingPong:n=Math.abs(n%2-1)}return n}!function(t){t[t.Random=0]="Random",t[t.Loop=1]="Loop",t[t.PingPong=2]="PingPong",t[t.Burst=3]="Burst"}(N||(N={}));class P{constructor(t,e,i,s){this.p=[t,e,i,s]}genValue(t){const e=t*t,i=t*t*t,s=1-t,n=s*s,r=n*s;return this.p[0]*r+this.p[1]*n*t*3+this.p[2]*s*e*3+this.p[3]*i}derivativeCoefficients(t){const e=[];for(let i=t,s=i.length-1;s>0;s--){const t=[];for(let e=0;e<s;e++){const n=s*(i[e+1]-i[e]);t.push(n)}e.push(t),i=t}return e}getSlope(t){const e=this.derivativeCoefficients(this.p)[0],i=1-t,s=i*t*2,n=t*t;return i*i*e[0]+s*e[1]+n*e[2]}controlCurve(t,e){this.p[1]=t/3+this.p[0],this.p[2]=this.p[3]-e/3}hull(t){let e,i=this.p,s=[],n=0,r=0,a=0;const o=[];for(o[n++]=i[0],o[n++]=i[1],o[n++]=i[2],o[n++]=i[3];i.length>1;){for(s=[],r=0,a=i.length-1;r<a;r++)e=t*i[r]+(1-t)*i[r+1],o[n++]=e,s.push(e);i=s}return o}split(t){const e=this.hull(t);return{left:new P(e[0],e[4],e[7],e[9]),right:new P(e[9],e[8],e[6],e[3]),span:e}}clone(){return new P(this.p[0],this.p[1],this.p[2],this.p[3])}toJSON(){return{p0:this.p[0],p1:this.p[1],p2:this.p[2],p3:this.p[3]}}static fromJSON(t){return new P(t.p0,t.p1,t.p2,t.p3)}}const U=t=>({r:t.x,g:t.y,b:t.z,a:t.w}),C=t=>new O(t.r,t.g,t.b,t.a),B=(t,e)=>{switch(e){case"Vector3":return new c(t.x,t.y,t.z);case"Vector4":return new O(t.x,t.y,t.z,t.w);case"Color":return new c(t.r,t.g,t.b);default:return t}},R=(t,e)=>{switch(e){case"Vector3":return{x:t.x,y:t.y,z:t.z};case"Vector4":return{x:t.x,y:t.y,z:t.z,w:t.w};case"Color":return{r:t.x,g:t.y,b:t.z};default:return t}};class k{constructor(t,e){this.a=t,this.b=e,this.type="value"}startGen(t){}genColor(t,e){const i=Math.random();return e.copy(this.a).lerp(this.b,i)}toJSON(){return{type:"RandomColor",a:U(this.a),b:U(this.b)}}static fromJSON(t){return new k(C(t.a),C(t.b))}clone(){return new k(this.a.clone(),this.b.clone())}}class F{constructor(t,e){this.a=t,this.b=e,this.indexCount=-1,this.type="value"}startGen(t){this.indexCount=t.length,t.push(Math.random())}genColor(t,e){return-1===this.indexCount&&this.startGen(t),e.copy(this.a).lerp(this.b,t[this.indexCount])}toJSON(){return{type:"ColorRange",a:U(this.a),b:U(this.b)}}static fromJSON(t){return new F(C(t.a),C(t.b))}clone(){return new F(this.a.clone(),this.b.clone())}}class L{constructor(t,e){this.subType=e,this.type="function",this.keys=t}findKey(t){let e=0,i=0,s=this.keys.length-1;for(;i+1<s;)if(e=Math.floor((i+s)/2),t<this.getStartX(e))s=e-1;else{if(!(t>this.getEndX(e)))return e;i=e+1}for(let n=i;n<=s;n++)if(t>=this.getStartX(n)&&t<=this.getEndX(n))return n;return-1}getStartX(t){return this.keys[t][1]}getEndX(t){return t+1<this.keys.length?this.keys[t+1][1]:1}genValue(t,e){const i=this.findKey(e);return"Number"===this.subType?-1===i?this.keys[0][0]:i+1>=this.keys.length?this.keys[this.keys.length-1][0]:(this.keys[i+1][0]-this.keys[i][0])*((e-this.getStartX(i))/(this.getEndX(i)-this.getStartX(i)))+this.keys[i][0]:-1===i?t.copy(this.keys[0][0]):i+1>=this.keys.length?t.copy(this.keys[this.keys.length-1][0]):t.copy(this.keys[i][0]).lerp(this.keys[i+1][0],(e-this.getStartX(i))/(this.getEndX(i)-this.getStartX(i)))}toJSON(){return this.keys[0][0].constructor.name,{type:"CLinearFunction",subType:this.subType,keys:this.keys.map(([t,e])=>({value:R(t,this.subType),pos:e}))}}static fromJSON(t){return new L(t.keys.map(e=>[B(e.value,t.subType),e.pos]),t.subType)}clone(){return"Number"===this.subType?new L(this.keys.map(([t,e])=>[t,e]),this.subType):new L(this.keys.map(([t,e])=>[t.clone(),e]),this.subType)}}const V=new c;class I{constructor(t=[[new c(0,0,0),0],[new c(1,1,1),0]],e=[[1,0],[1,1]]){this.type="function",this.color=new L(t,"Color"),this.alpha=new L(e,"Number")}genColor(t,e,i){return this.color.genValue(V,i),e.set(V.x,V.y,V.z,this.alpha.genValue(1,i))}toJSON(){return{type:"Gradient",color:this.color.toJSON(),alpha:this.alpha.toJSON()}}static fromJSON(t){if(t.functions){const e=t.functions.map(t=>[F.fromJSON(t.function).a,t.start]);return t.functions.length>0&&e.push([F.fromJSON(t.functions[t.functions.length-1].function).b,1]),new I(e.map(t=>[new c(t[0].x,t[0].y,t[0].z),t[1]]),e.map(t=>[t[0].w,t[1]]))}{const e=new I;return e.alpha=L.fromJSON(t.alpha),e.color=L.fromJSON(t.color),e}}clone(){const t=new I;return t.alpha=this.alpha.clone(),t.color=this.color.clone(),t}startGen(t){}}const J=new O;class D{constructor(t,e){this.indexCount=0,this.type="function",this.gradient1=t,this.gradient2=e}startGen(t){this.indexCount=t.length,t.push(Math.random())}genColor(t,e,i){return this.gradient1.genColor(t,e,i),this.gradient2.genColor(t,J,i),t&&void 0!==t[this.indexCount]?e.lerp(J,t[this.indexCount]):e.lerp(J,Math.random()),e}toJSON(){return{type:"RandomColorBetweenGradient",gradient1:this.gradient1.toJSON(),gradient2:this.gradient2.toJSON()}}static fromJSON(t){return new D(I.fromJSON(t.gradient1),I.fromJSON(t.gradient2))}clone(){return new D(this.gradient1.clone(),this.gradient2.clone())}}class G{constructor(t){this.color=t,this.type="value"}startGen(t){}genColor(t,e){return e.copy(this.color)}toJSON(){return{type:"ConstantColor",color:U(this.color)}}static fromJSON(t){return new G(C(t.color))}clone(){return new G(this.color.clone())}}function q(t){switch(t.type){case"ConstantColor":return G.fromJSON(t);case"ColorRange":return F.fromJSON(t);case"RandomColor":return k.fromJSON(t);case"Gradient":return I.fromJSON(t);case"RandomColorBetweenGradient":return D.fromJSON(t);default:return new G(new O(1,1,1,1))}}class X{constructor(t){this.value=t,this.type="value"}startGen(t){}genValue(t){return this.value}toJSON(){return{type:"ConstantValue",value:this.value}}static fromJSON(t){return new X(t.value)}clone(){return new X(this.value)}}class Y{constructor(t,e){this.a=t,this.b=e,this.indexCount=-1,this.type="value"}startGen(t){this.indexCount=t.length,t.push(Math.random())}genValue(t){return-1===this.indexCount&&this.startGen(t),h.lerp(this.a,this.b,t[this.indexCount])}toJSON(){return{type:"IntervalValue",a:this.a,b:this.b}}static fromJSON(t){return new Y(t.a,t.b)}clone(){return new Y(this.a,this.b)}}class H{constructor(){this.functions=new Array}findFunction(t){let e=0,i=0,s=this.functions.length-1;for(;i+1<s;)if(e=Math.floor((i+s)/2),t<this.getStartX(e))s=e-1;else{if(!(t>this.getEndX(e)))return e;i=e+1}for(let n=i;n<=s;n++)if(t>=this.functions[n][1]&&t<=this.getEndX(n))return n;return-1}getStartX(t){return this.functions[t][1]}setStartX(t,e){t>0&&(this.functions[t][1]=e)}getEndX(t){return t+1<this.functions.length?this.functions[t+1][1]:1}setEndX(t,e){t+1<this.functions.length&&(this.functions[t+1][1]=e)}insertFunction(t,e){const i=this.findFunction(t);this.functions.splice(i+1,0,[e,t])}removeFunction(t){return this.functions.splice(t,1)[0][0]}getFunction(t){return this.functions[t][0]}setFunction(t,e){this.functions[t][0]=e}get numOfFunctions(){return this.functions.length}}class Z extends H{constructor(t=[[new P(0,1/3,1/3*2,1),0]]){super(),this.type="function",this.functions=t}genValue(t,e=0){const i=this.findFunction(e);return-1===i?0:this.functions[i][0].genValue((e-this.getStartX(i))/(this.getEndX(i)-this.getStartX(i)))}toSVG(t,e){if(e<1)return"";let i=["M",0,this.functions[0][0].p[0]].join(" ");for(let s=1/e;s<=1;s+=1/e)i=[i,"L",s*t,this.genValue(void 0,s)].join(" ");return i}toJSON(){return{type:"PiecewiseBezier",functions:this.functions.map(([t,e])=>({function:t.toJSON(),start:e}))}}static fromJSON(t){return new Z(t.functions.map(t=>[P.fromJSON(t.function),t.start]))}clone(){return new Z(this.functions.map(([t,e])=>[t.clone(),e]))}startGen(t){}}function j(t){switch(t.type){case"ConstantValue":return X.fromJSON(t);case"IntervalValue":return Y.fromJSON(t);case"PiecewiseBezier":return Z.fromJSON(t);default:return new X(0)}}class W{constructor(){this.indexCount=0,this.type="rotation"}startGen(t){let e,i,s,n,r,a;this.indexCount=t.length,t.push(new l);do{e=2*Math.random()-1,i=2*Math.random()-1,s=e*e+i*i}while(s>1);do{n=2*Math.random()-1,r=2*Math.random()-1,a=n*n+r*r}while(a>1);const o=Math.sqrt((1-s)/a);t[this.indexCount].set(e,i,o*n,o*r)}genValue(t,e,i,s){return-1===this.indexCount&&this.startGen(t),e.copy(t[this.indexCount]),e}toJSON(){return{type:"RandomQuat"}}static fromJSON(t){return new W}clone(){return new W}}class Q{constructor(t,e){this.axis=t,this.angle=e,this.type="rotation"}startGen(t){this.angle.startGen(t)}genValue(t,e,i,s){return e.setFromAxisAngle(this.axis,this.angle.genValue(t,s)*i)}toJSON(){return{type:"AxisAngle",axis:{x:this.axis.x,y:this.axis.y,z:this.axis.z},angle:this.angle.toJSON()}}static fromJSON(t){return new Q(new c(t.axis.x,t.axis.y,t.axis.z),j(t.angle))}clone(){return new Q(this.axis.clone(),this.angle.clone())}}class K{constructor(t,e,i,s){this.angleX=t,this.angleY=e,this.angleZ=i,this.type="rotation",this.eular=new z(0,0,0,s)}startGen(t){this.angleX.startGen(t),this.angleY.startGen(t),this.angleZ.startGen(t)}genValue(t,e,i,s){return this.eular.set(this.angleX.genValue(t,s)*i,this.angleY.genValue(t,s)*i,this.angleZ.genValue(t,s)*i),e.setFromEuler(this.eular)}toJSON(){return{type:"Euler",angleX:this.angleX.toJSON(),angleY:this.angleY.toJSON(),angleZ:this.angleZ.toJSON(),eulerOrder:this.eular.order}}static fromJSON(t){return new K(j(t.angleX),j(t.angleY),j(t.angleZ),t.eulerOrder)}clone(){return new K(this.angleX,this.angleY,this.angleZ,this.eular.order)}}function $(t){switch(t.type){case"AxisAngle":return Q.fromJSON(t);case"Euler":return K.fromJSON(t);case"RandomQuat":return W.fromJSON(t);default:return new W}}class tt{constructor(t,e,i){this.x=t,this.y=e,this.z=i,this.type="vec3function"}startGen(t){this.x.startGen(t),this.y.startGen(t),this.z.startGen(t)}genValue(t,e,i){return e.set(this.x.genValue(t,i),this.y.genValue(t,i),this.z.genValue(t,i))}toJSON(){return{type:"Vector3Function",x:this.x.toJSON(),y:this.y.toJSON(),z:this.z.toJSON()}}static fromJSON(t){return new tt(j(t.x),j(t.y),j(t.z))}clone(){return new tt(this.x,this.y,this.z)}}function et(t){switch(t.type){case"ConstantValue":case"IntervalValue":case"PiecewiseBezier":return j(t);case"AxisAngle":case"RandomQuat":case"Euler":return $(t);case"Vector3Function":return function(t){return"Vector3Function"===t.type?tt.fromJSON(t):new tt(new X(0),new X(0),new X(0))}(t);default:return new X(0)}}class it{constructor(t={}){this.type="cone",this.currentValue=0,this.radius=t.radius??10,this.arc=t.arc??2*Math.PI,this.thickness=t.thickness??1,this.angle=t.angle??Math.PI/6,this.mode=t.mode??N.Random,this.spread=t.spread??0,this.speed=t.speed??new X(1),this.memory=[]}update(t,e){N.Random!=this.mode&&(this.currentValue+=this.speed.genValue(this.memory,t.emissionState.time/t.duration)*e)}initialize(t,e){const i=E(this.mode,this.currentValue,this.spread,e),s=h.lerp(1-this.thickness,1,Math.random()),n=i*this.arc,r=Math.sqrt(s),a=Math.sin(n),o=Math.cos(n);t.position.x=r*o,t.position.y=r*a,t.position.z=0;const l=this.angle*r;t.velocity.set(0,0,Math.cos(l)).addScaledVector(t.position,Math.sin(l)).multiplyScalar(t.startSpeed),t.position.multiplyScalar(this.radius)}toJSON(){return{type:"cone",radius:this.radius,arc:this.arc,thickness:this.thickness,angle:this.angle,mode:this.mode,spread:this.spread,speed:this.speed.toJSON()}}static fromJSON(t){return new it({radius:t.radius,arc:t.arc,thickness:t.thickness,angle:t.angle,mode:t.mode,speed:t.speed?j(t.speed):void 0,spread:t.spread})}clone(){return new it({radius:this.radius,arc:this.arc,thickness:this.thickness,angle:this.angle,mode:this.mode,speed:this.speed.clone(),spread:this.spread})}}class st{constructor(t={}){this.type="circle",this.currentValue=0,this.radius=t.radius??10,this.arc=t.arc??2*Math.PI,this.thickness=t.thickness??1,this.mode=t.mode??N.Random,this.spread=t.spread??0,this.speed=t.speed??new X(1),this.memory=[]}update(t,e){this.currentValue+=this.speed.genValue(this.memory,t.emissionState.time/t.duration)*e}initialize(t,e){const i=E(this.mode,this.currentValue,this.spread,e),s=h.lerp(1-this.thickness,1,Math.random()),n=i*this.arc;t.position.x=Math.cos(n),t.position.y=Math.sin(n),t.position.z=0,t.velocity.copy(t.position).multiplyScalar(t.startSpeed),t.position.multiplyScalar(this.radius*s)}toJSON(){return{type:"circle",radius:this.radius,arc:this.arc,thickness:this.thickness,mode:this.mode,spread:this.spread,speed:this.speed.toJSON()}}static fromJSON(t){return new st({radius:t.radius,arc:t.arc,thickness:t.thickness,mode:t.mode,speed:t.speed?j(t.speed):void 0,spread:t.spread})}clone(){return new st({radius:this.radius,arc:this.arc,thickness:this.thickness,mode:this.mode,speed:this.speed.clone(),spread:this.spread})}}function nt(t,e){return Math.floor(Math.random()*(e-t))+t}const rt=new c(0,1,0),at=new c(0,0,0),ot=new c(1,1,1),ht=new c(0,0,1);class lt{constructor(t={}){this.type="donut",this.currentValue=0,this.radius=t.radius??10,this.arc=t.arc??2*Math.PI,this.thickness=t.thickness??1,this.donutRadius=t.donutRadius??.2*this.radius,this.mode=t.mode??N.Random,this.spread=t.spread??0,this.speed=t.speed??new X(1),this.memory=[],this._m1=new p}update(t,e){N.Random!=this.mode&&(this.currentValue+=this.speed.genValue(this.memory,t.emissionState.time/t.duration)*e)}initialize(t,e){const i=E(this.mode,this.currentValue,this.spread,e),s=Math.random(),n=h.lerp(1-this.thickness,1,Math.random()),r=i*this.arc,a=s*Math.PI*2,o=Math.sin(r),c=Math.cos(r);t.position.x=this.radius*c,t.position.y=this.radius*o,t.position.z=0,t.velocity.z=this.donutRadius*n*Math.sin(a),t.velocity.x=this.donutRadius*n*Math.cos(a)*c,t.velocity.y=this.donutRadius*n*Math.cos(a)*o,t.position.add(t.velocity),t.velocity.normalize().multiplyScalar(t.startSpeed),t.rotation instanceof l&&(this._m1.lookAt(at,t.velocity,rt),t.rotation.setFromRotationMatrix(this._m1))}toJSON(){return{type:"donut",radius:this.radius,arc:this.arc,thickness:this.thickness,donutRadius:this.donutRadius,mode:this.mode,spread:this.spread,speed:this.speed.toJSON()}}static fromJSON(t){return new lt({radius:t.radius,arc:t.arc,thickness:t.thickness,donutRadius:t.donutRadius,mode:t.mode,speed:t.speed?j(t.speed):void 0,spread:t.spread})}clone(){return new lt({radius:this.radius,arc:this.arc,thickness:this.thickness,donutRadius:this.donutRadius,mode:this.mode,speed:this.speed.clone(),spread:this.spread})}}class ct{constructor(){this.type="point",this._m1=new p}update(t,e){}initialize(t){const e=Math.random(),i=Math.random(),s=e*Math.PI*2,n=Math.acos(2*i-1),r=Math.cbrt(Math.random()),a=Math.sin(s),o=Math.cos(s),h=Math.sin(n),c=Math.cos(n);t.velocity.x=r*h*o,t.velocity.y=r*h*a,t.velocity.z=r*c,t.velocity.multiplyScalar(t.startSpeed),t.position.setScalar(0),t.rotation instanceof l&&(this._m1.lookAt(at,t.position,rt),t.rotation.setFromRotationMatrix(this._m1))}toJSON(){return{type:"point"}}static fromJSON(t){return new ct}clone(){return new ct}}class dt{constructor(t={}){this.type="sphere",this.currentValue=0,this.radius=t.radius??10,this.arc=t.arc??2*Math.PI,this.thickness=t.thickness??1,this.mode=t.mode??N.Random,this.spread=t.spread??0,this.speed=t.speed??new X(1),this.memory=[],this._m1=new p}update(t,e){N.Random!=this.mode&&(this.currentValue+=this.speed.genValue(this.memory,t.emissionState.time/t.duration)*e)}initialize(t,e){const i=E(this.mode,this.currentValue,this.spread,e),s=Math.random(),n=h.lerp(1-this.thickness,1,Math.random()),r=i*this.arc,a=Math.acos(2*s-1),o=Math.sin(r),c=Math.cos(r),d=Math.sin(a),u=Math.cos(a);t.position.x=d*c,t.position.y=d*o,t.position.z=u,t.velocity.copy(t.position).multiplyScalar(t.startSpeed),t.position.multiplyScalar(this.radius*n),t.rotation instanceof l&&(this._m1.lookAt(at,t.position,rt),t.rotation.setFromRotationMatrix(this._m1))}toJSON(){return{type:"sphere",radius:this.radius,arc:this.arc,thickness:this.thickness,mode:this.mode,spread:this.spread,speed:this.speed.toJSON()}}static fromJSON(t){return new dt({radius:t.radius,arc:t.arc,thickness:t.thickness,mode:t.mode,speed:t.speed?j(t.speed):void 0,spread:t.spread})}clone(){return new dt({radius:this.radius,arc:this.arc,thickness:this.thickness,mode:this.mode,speed:this.speed.clone(),spread:this.spread})}}class ut{constructor(t={}){this.type="hemisphere",this.currentValue=0,this.radius=t.radius??10,this.arc=t.arc??2*Math.PI,this.thickness=t.thickness??1,this.mode=t.mode??N.Random,this.spread=t.spread??0,this.speed=t.speed??new X(1),this.memory=[],this._m1=new p}update(t,e){N.Random!=this.mode&&(this.currentValue+=this.speed.genValue(this.memory,t.emissionState.time/t.duration)*e)}initialize(t,e){const i=E(this.mode,this.currentValue,this.spread,e),s=Math.random(),n=h.lerp(1-this.thickness,1,Math.random()),r=i*this.arc,a=Math.acos(s),o=Math.sin(r),c=Math.cos(r),d=Math.sin(a),u=Math.cos(a);t.position.x=d*c,t.position.y=d*o,t.position.z=u,t.velocity.copy(t.position).multiplyScalar(t.startSpeed),t.position.multiplyScalar(this.radius*n),t.rotation instanceof l&&(this._m1.lookAt(at,t.position,rt),t.rotation.setFromRotationMatrix(this._m1))}toJSON(){return{type:"hemisphere",radius:this.radius,arc:this.arc,thickness:this.thickness,mode:this.mode,spread:this.spread,speed:this.speed.toJSON()}}static fromJSON(t){return new ut({radius:t.radius,arc:t.arc,thickness:t.thickness,mode:t.mode,speed:t.speed?j(t.speed):void 0,spread:t.spread})}clone(){return new ut({radius:this.radius,arc:this.arc,thickness:this.thickness,mode:this.mode,speed:this.speed.clone(),spread:this.spread})}}class mt{constructor(t={}){this.type="grid",this.width=t.width??1,this.height=t.height??1,this.column=t.column??10,this.row=t.row??10}initialize(t){const e=Math.floor(Math.random()*this.row),i=Math.floor(Math.random()*this.column);t.position.x=i*this.width/this.column-this.width/2,t.position.y=e*this.height/this.row-this.height/2,t.position.z=0,t.velocity.set(0,0,t.startSpeed)}toJSON(){return{type:"grid",width:this.width,height:this.height,column:this.column,row:this.row}}static fromJSON(t){return new mt(t)}clone(){return new mt({width:this.width,height:this.height,column:this.column,row:this.row})}update(t,e){}}class pt{constructor(t={}){this.type="rectangle",this.currentValue=0,this.width=t.width??10,this.height=t.height??10,this.thickness=t.thickness??1,this.mode=t.mode??N.Random,this.spread=t.spread??0,this.speed=t.speed??new X(1),this.memory=[],this._m1=new p}update(t,e){this.currentValue+=this.speed.genValue(this.memory,t.emissionState.time/t.duration)*e}initialize(t,e){const i=E(this.mode,this.currentValue,this.spread,e)*(2*(this.width+this.height));let s,n;i<this.width?(s=i-this.width/2,n=-this.height/2):i<this.width+this.height?(s=this.width/2,n=i-this.width-this.height/2):i<2*this.width+this.height?(s=this.width/2-(i-this.width-this.height),n=this.height/2):(s=-this.width/2,n=this.height/2-(i-2*this.width-this.height));const r=Math.random(),a=1-this.thickness*r;t.position.x=s*a,t.position.y=n*a,t.position.z=0,t.velocity.x=s,t.velocity.y=n,t.velocity.z=0,t.velocity.normalize().multiplyScalar(t.startSpeed),t.rotation instanceof l&&(this._m1.lookAt(at,t.velocity,rt),t.rotation.setFromRotationMatrix(this._m1))}toJSON(){return{type:"rectangle",width:this.width,height:this.height,thickness:this.thickness,mode:this.mode,spread:this.spread,speed:this.speed.toJSON()}}static fromJSON(t){return new pt({width:t.width,height:t.height,thickness:t.thickness,mode:t.mode,speed:t.speed?j(t.speed):void 0,spread:t.spread})}clone(){return new pt({width:this.width,height:this.height,thickness:this.thickness,mode:this.mode,speed:this.speed.clone(),spread:this.spread})}}const ft={circle:{type:"circle",params:[["radius",["number"]],["arc",["radian"]],["thickness",["number"]],["mode",["emitterMode"]],["spread",["number"]],["speed",["valueFunc","value"]]],constructor:st,loadJSON:st.fromJSON},cone:{type:"cone",params:[["radius",["number"]],["arc",["radian"]],["thickness",["number"]],["angle",["radian"]],["mode",["emitterMode"]],["spread",["number"]],["speed",["valueFunc","value"]]],constructor:it,loadJSON:it.fromJSON},donut:{type:"donut",params:[["radius",["number"]],["arc",["radian"]],["thickness",["number"]],["donutRadius",["number"]],["mode",["emitterMode"]],["spread",["number"]],["speed",["valueFunc","value"]]],constructor:lt,loadJSON:lt.fromJSON},point:{type:"point",params:[],constructor:ct,loadJSON:ct.fromJSON},sphere:{type:"sphere",params:[["radius",["number"]],["arc",["radian"]],["thickness",["number"]],["angle",["radian"]],["mode",["emitterMode"]],["spread",["number"]],["speed",["valueFunc","value"]]],constructor:dt,loadJSON:dt.fromJSON},hemisphere:{type:"hemisphere",params:[["radius",["number"]],["arc",["radian"]],["thickness",["number"]],["angle",["radian"]],["mode",["emitterMode"]],["spread",["number"]],["speed",["valueFunc","value"]]],constructor:ut,loadJSON:ut.fromJSON},grid:{type:"grid",params:[["width",["number"]],["height",["number"]],["rows",["number"]],["column",["number"]]],constructor:mt,loadJSON:mt.fromJSON},rectangle:{type:"rectangle",params:[["width",["number"]],["height",["number"]],["thickness",["number"]],["mode",["emitterMode"]],["spread",["number"]],["speed",["valueFunc","value"]]],constructor:pt,loadJSON:pt.fromJSON}};class yt{constructor(t){this.color=t,this.type="ColorOverLife"}initialize(t){this.color.startGen(t.memory)}update(t,e){this.color.genColor(t.memory,t.color,t.age/t.life),t.color.x*=t.startColor.x,t.color.y*=t.startColor.y,t.color.z*=t.startColor.z,t.color.w*=t.startColor.w}frameUpdate(t){}toJSON(){return{type:this.type,color:this.color.toJSON()}}static fromJSON(t){return new yt(q(t.color))}clone(){return new yt(this.color.clone())}reset(){}}class gt{constructor(t){this.angularVelocity=t,this.type="RotationOverLife"}initialize(t){"number"==typeof t.rotation&&this.angularVelocity.startGen(t.memory)}update(t,e){"number"==typeof t.rotation&&(t.rotation+=e*this.angularVelocity.genValue(t.memory,t.age/t.life))}toJSON(){return{type:this.type,angularVelocity:this.angularVelocity.toJSON()}}static fromJSON(t){return new gt(j(t.angularVelocity))}frameUpdate(t){}clone(){return new gt(this.angularVelocity.clone())}reset(){}}class vt{constructor(t){this.angularVelocity=t,this.type="Rotation3DOverLife",this.tempQuat=new l,this.tempQuat2=new l}initialize(t){t.rotation instanceof l&&(t.angularVelocity=new l,this.angularVelocity.startGen(t.memory))}update(t,e){t.rotation instanceof l&&(this.angularVelocity.genValue(t.memory,this.tempQuat,e,t.age/t.life),t.rotation.multiply(this.tempQuat))}toJSON(){return{type:this.type,angularVelocity:this.angularVelocity.toJSON()}}static fromJSON(t){return new vt($(t.angularVelocity))}frameUpdate(t){}clone(){return new vt(this.angularVelocity.clone())}reset(){}}class xt{initialize(t,e){this.ps=e,this.x.startGen(t.memory),this.y.startGen(t.memory),this.z.startGen(t.memory)}constructor(t,e,i){this.x=t,this.y=e,this.z=i,this.type="ForceOverLife",this._temp=new c,this._tempScale=new c,this._tempQ=new l}update(t,e){this._temp.set(this.x.genValue(t.memory,t.age/t.life),this.y.genValue(t.memory,t.age/t.life),this.z.genValue(t.memory,t.age/t.life)),this.ps.worldSpace||this._temp.multiply(this._tempScale).applyQuaternion(this._tempQ),t.velocity.addScaledVector(this._temp,e)}toJSON(){return{type:this.type,x:this.x.toJSON(),y:this.y.toJSON(),z:this.z.toJSON()}}static fromJSON(t){return new xt(j(t.x),j(t.y),j(t.z))}frameUpdate(t){if(this.ps&&!this.ps.worldSpace){const t=this._temp,e=this._tempQ,i=this._tempScale;this.ps.emitter.matrixWorld.decompose(t,e,i),e.invert(),i.set(1/i.x,1/i.y,1/i.z)}}clone(){return new xt(this.x.clone(),this.y.clone(),this.z.clone())}reset(){}}class St{initialize(t){this.size.startGen(t.memory)}constructor(t){this.size=t,this.type="SizeOverLife"}update(t){this.size instanceof tt?this.size.genValue(t.memory,t.size,t.age/t.life).multiply(t.startSize):t.size.copy(t.startSize).multiplyScalar(this.size.genValue(t.memory,t.age/t.life))}toJSON(){return{type:this.type,size:this.size.toJSON()}}static fromJSON(t){return new St(et(t.size))}frameUpdate(t){}clone(){return new St(this.size.clone())}reset(){}}class Mt{initialize(t){this.speed.startGen(t.memory)}constructor(t){this.speed=t,this.type="SpeedOverLife"}update(t){t.speedModifier=this.speed.genValue(t.memory,t.age/t.life)}toJSON(){return{type:this.type,speed:this.speed.toJSON()}}static fromJSON(t){return new Mt(j(t.speed))}frameUpdate(t){}clone(){return new Mt(this.speed.clone())}reset(){}}class _t{constructor(t){this.frame=t,this.type="FrameOverLife"}initialize(t){this.frame.startGen(t.memory)}update(t,e){this.frame instanceof Z&&(t.uvTile=this.frame.genValue(t.memory,t.age/t.life))}frameUpdate(t){}toJSON(){return{type:this.type,frame:this.frame.toJSON()}}static fromJSON(t){return new _t(j(t.frame))}clone(){return new _t(this.frame.clone())}reset(){}}class wt{constructor(t,e=new c(0,1,0)){this.orbitSpeed=t,this.axis=e,this.type="OrbitOverLife",this.temp=new c,this.rotation=new l}initialize(t){this.orbitSpeed.startGen(t.memory)}update(t,e){this.temp.copy(t.position).projectOnVector(this.axis),this.rotation.setFromAxisAngle(this.axis,this.orbitSpeed.genValue(t.memory,t.age/t.life)*e),t.position.sub(this.temp),t.position.applyQuaternion(this.rotation),t.position.add(this.temp)}frameUpdate(t){}toJSON(){return{type:this.type,orbitSpeed:this.orbitSpeed.toJSON(),axis:[this.axis.x,this.axis.y,this.axis.z]}}static fromJSON(t){return new wt(j(t.orbitSpeed),t.axis?new c(t.axis[0],t.axis[1],t.axis[2]):void 0)}clone(){return new wt(this.orbitSpeed.clone())}reset(){}}class zt{constructor(t){this.data=t,this.next=null,this.prev=null}hasPrev(){return null!==this.prev}hasNext(){return null!==this.next}}class bt{constructor(){this.length=0,this.head=this.tail=null}isEmpty(){return null===this.head}clear(){this.length=0,this.head=this.tail=null}front(){return null===this.head?null:this.head.data}back(){return null===this.tail?null:this.tail.data}dequeue(){if(this.head){const t=this.head.data;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,t}}pop(){if(this.tail){const t=this.tail.data;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,t}}queue(t){const e=new zt(t);this.tail||(this.tail=e),this.head&&(this.head.prev=e,e.next=this.head),this.head=e,this.length++}push(t){const e=new zt(t);this.head||(this.head=e),this.tail&&(this.tail.next=e,e.prev=this.tail),this.tail=e,this.length++}insertBefore(t,e){const i=new zt(e);i.next=t,i.prev=t.prev,null!==i.prev&&(i.prev.next=i),i.next.prev=i,t==this.head&&(this.head=i),this.length++}remove(t){if(null===this.head||null===this.tail)return;let e=this.head;for(t===this.head.data&&(this.head=this.head.next),t===this.tail.data&&(this.tail=this.tail.prev);null!==e.next&&e.data!==t;)e=e.next;e.data===t&&(null!==e.prev&&(e.prev.next=e.next),null!==e.next&&(e.next.prev=e.prev),this.length--)}*values(){let t=this.head;for(;null!==t;)yield t.data,t=t.next}}class Ot{constructor(){this.startSpeed=0,this.startColor=new O,this.startSize=new c(1,1,1),this.position=new c,this.velocity=new c,this.age=0,this.life=1,this.size=new c(1,1,1),this.speedModifier=1,this.rotation=0,this.color=new O,this.uvTile=0,this.memory=[]}get died(){return this.age>=this.life}reset(){this.memory.length=0}}class At{constructor(t,e,i){this.position=t,this.size=e,this.color=i}}class Tt{constructor(){this.startSpeed=0,this.startColor=new O,this.startSize=new c(1,1,1),this.position=new c,this.velocity=new c,this.age=0,this.life=1,this.size=new c(1,1,1),this.length=100,this.speedModifier=1,this.color=new O,this.previous=new bt,this.uvTile=0,this.memory=[]}update(){for(this.age<=this.life?this.previous.push(new At(this.position.clone(),this.size.x,this.color.clone())):this.previous.length>0&&this.previous.dequeue();this.previous.length>this.length;)this.previous.dequeue()}get died(){return this.age>=this.life}reset(){this.memory.length=0,this.previous.clear()}}class Nt{initialize(t){this.width.startGen(t.memory)}constructor(t){this.width=t,this.type="WidthOverLength"}update(t){if(t instanceof Tt){const e=t.previous.values();for(let i=0;i<t.previous.length;i++){e.next().value.size=this.width.genValue(t.memory,(t.previous.length-i)/t.length)}}}frameUpdate(t){}toJSON(){return{type:this.type,width:this.width.toJSON()}}static fromJSON(t){return new Nt(j(t.width))}clone(){return new Nt(this.width.clone())}reset(){}}class Et{constructor(t,e){this.direction=t,this.magnitude=e,this.type="ApplyForce",this.memory={data:[],dataCount:0},this.magnitudeValue=this.magnitude.genValue(this.memory)}initialize(t){}update(t,e){t.velocity.addScaledVector(this.direction,this.magnitudeValue*e)}frameUpdate(t){this.magnitudeValue=this.magnitude.genValue(this.memory)}toJSON(){return{type:this.type,direction:[this.direction.x,this.direction.y,this.direction.z],magnitude:this.magnitude.toJSON()}}static fromJSON(t){return new Et(new c(t.direction[0],t.direction[1],t.direction[2]),j(t.magnitude??t.force))}clone(){return new Et(this.direction.clone(),this.magnitude.clone())}reset(){}}class Pt{constructor(t,e){this.center=t,this.magnitude=e,this.type="GravityForce",this.temp=new c}initialize(t){}update(t,e){this.temp.copy(this.center).sub(t.position).normalize(),t.velocity.addScaledVector(this.temp,this.magnitude/t.position.distanceToSquared(this.center)*e)}frameUpdate(t){}toJSON(){return{type:this.type,center:[this.center.x,this.center.y,this.center.z],magnitude:this.magnitude}}static fromJSON(t){return new Pt(new c(t.center[0],t.center[1],t.center[2]),t.magnitude)}clone(){return new Pt(this.center.clone(),this.magnitude)}reset(){}}class Ut{constructor(t){this.angle=t,this.type="ChangeEmitDirection",this._temp=new c,this._q=new l,this.memory={data:[],dataCount:0}}initialize(t){const e=t.velocity.length();0!=e&&(t.velocity.normalize(),0===t.velocity.x&&0===t.velocity.y?this._temp.set(0,t.velocity.z,0):this._temp.set(-t.velocity.y,t.velocity.x,0),this.angle.startGen(this.memory),this._q.setFromAxisAngle(this._temp.normalize(),this.angle.genValue(this.memory)),this._temp.copy(t.velocity),t.velocity.applyQuaternion(this._q),this._q.setFromAxisAngle(this._temp,Math.random()*Math.PI*2),t.velocity.applyQuaternion(this._q),t.velocity.setLength(e))}update(t,e){}frameUpdate(t){}toJSON(){return{type:this.type,angle:this.angle.toJSON()}}static fromJSON(t){return new Ut(j(t.angle))}clone(){return new Ut(this.angle)}reset(){}}var Ct;!function(t){t[t.Death=0]="Death",t[t.Birth=1]="Birth",t[t.Frame=2]="Frame"}(Ct||(Ct={}));class Bt{constructor(t,e,i,s=Ct.Frame,n=1){this.particleSystem=t,this.useVelocityAsBasis=e,this.subParticleSystem=i,this.mode=s,this.emitProbability=n,this.type="EmitSubParticleSystem",this.q_=new l,this.v_=new c,this.v2_=new c,this.subEmissions=new Array,this.subParticleSystem&&this.subParticleSystem.system&&(this.subParticleSystem.system.onlyUsedByOther=!0)}initialize(t){}update(t,e){(this.mode===Ct.Frame||this.mode===Ct.Birth&&0===t.age||this.mode===Ct.Death&&t.age+e>=t.life)&&this.emit(t,e)}emit(t,e){if(!this.subParticleSystem)return;if(Math.random()>this.emitProbability)return;const i=new p;this.setMatrixFromParticle(i,t),this.subEmissions.push({burstParticleCount:0,burstParticleIndex:0,isBursting:!1,burstIndex:0,burstWaveIndex:0,time:0,waitEmiting:0,matrix:i,travelDistance:0,particle:t})}frameUpdate(t){if(this.subParticleSystem)for(let e=0;e<this.subEmissions.length;e++)if(this.subEmissions[e].time>=this.subParticleSystem.system.duration)this.subEmissions[e]=this.subEmissions[this.subEmissions.length-1],this.subEmissions.length=this.subEmissions.length-1,e--;else{const i=this.subEmissions[e];i.particle&&i.particle.age<i.particle.life?this.setMatrixFromParticle(i.matrix,i.particle):i.particle=void 0,this.subParticleSystem.system.emit(t,i,i.matrix)}}toJSON(){return{type:this.type,subParticleSystem:this.subParticleSystem?this.subParticleSystem.uuid:"",useVelocityAsBasis:this.useVelocityAsBasis,mode:this.mode,emitProbability:this.emitProbability}}static fromJSON(t,e){return new Bt(e,t.useVelocityAsBasis,t.subParticleSystem,t.mode,t.emitProbability)}clone(){return new Bt(this.particleSystem,this.useVelocityAsBasis,this.subParticleSystem,this.mode,this.emitProbability)}reset(){}setMatrixFromParticle(t,e){let i;if(void 0===e.rotation||this.useVelocityAsBasis)if(0!==e.velocity.x||0!==e.velocity.y||1!==e.velocity.z&&0!==e.velocity.z){this.v_.copy(ht).cross(e.velocity),this.v2_.copy(e.velocity).cross(this.v_);const i=this.v_.length(),s=this.v2_.length();t.set(this.v_.x/i,this.v2_.x/s,e.velocity.x,e.position.x,this.v_.y/i,this.v2_.y/s,e.velocity.y,e.position.y,this.v_.z/i,this.v2_.z/s,e.velocity.z,e.position.z,0,0,0,1)}else t.set(1,0,0,e.position.x,0,1,0,e.position.y,0,0,1,e.position.z,0,0,0,1);else e.rotation instanceof l?i=e.rotation:(this.q_.setFromAxisAngle(ht,e.rotation),i=this.q_),t.compose(e.position,i,ot);this.particleSystem.worldSpace||t.multiplyMatrices(this.particleSystem.emitter.matrixWorld,t)}}const Rt=.5*(Math.sqrt(3)-1),kt=(3-Math.sqrt(3))/6,Ft=1/3,Lt=1/6,Vt=(Math.sqrt(5)-1)/4,It=(5-Math.sqrt(5))/20,Jt=new Float32Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]),Dt=new Float32Array([0,1,1,1,0,1,1,-1,0,1,-1,1,0,1,-1,-1,0,-1,1,1,0,-1,1,-1,0,-1,-1,1,0,-1,-1,-1,1,0,1,1,1,0,1,-1,1,0,-1,1,1,0,-1,-1,-1,0,1,1,-1,0,1,-1,-1,0,-1,1,-1,0,-1,-1,1,1,0,1,1,1,0,-1,1,-1,0,1,1,-1,0,-1,-1,1,0,1,-1,1,0,-1,-1,-1,0,1,-1,-1,0,-1,1,1,1,0,1,1,-1,0,1,-1,1,0,1,-1,-1,0,-1,1,1,0,-1,1,-1,0,-1,-1,1,0,-1,-1,-1,0]);class Gt{constructor(t=Math.random){const e="function"==typeof t?t:function(t){let e=0,i=0,s=0,n=1;const r=function(){let t=4022871197;return function(e){e=e.toString();for(let i=0;i<e.length;i++){t+=e.charCodeAt(i);let s=.02519603282416938*t;t=s>>>0,s-=t,s*=t,t=s>>>0,s-=t,t+=4294967296*s}return 2.3283064365386963e-10*(t>>>0)}}();e=r(" "),i=r(" "),s=r(" "),e-=r(t),e<0&&(e+=1);i-=r(t),i<0&&(i+=1);s-=r(t),s<0&&(s+=1);return function(){const t=2091639*e+2.3283064365386963e-10*n;return e=i,i=s,s=t-(n=0|t)}}(t);this.p=function(t){const e=new Uint8Array(256);for(let i=0;i<256;i++)e[i]=i;for(let i=0;i<255;i++){const s=i+~~(t()*(256-i)),n=e[i];e[i]=e[s],e[s]=n}return e}(e),this.perm=new Uint8Array(512),this.permMod12=new Uint8Array(512);for(let i=0;i<512;i++)this.perm[i]=this.p[255&i],this.permMod12[i]=this.perm[i]%12}noise2D(t,e){const i=this.permMod12,s=this.perm;let n=0,r=0,a=0;const o=(t+e)*Rt,h=Math.floor(t+o),l=Math.floor(e+o),c=(h+l)*kt,d=t-(h-c),u=e-(l-c);let m,p;d>u?(m=1,p=0):(m=0,p=1);const f=d-m+kt,y=u-p+kt,g=d-1+2*kt,v=u-1+2*kt,x=255&h,S=255&l;let M=.5-d*d-u*u;if(M>=0){const t=3*i[x+s[S]];M*=M,n=M*M*(Jt[t]*d+Jt[t+1]*u)}let _=.5-f*f-y*y;if(_>=0){const t=3*i[x+m+s[S+p]];_*=_,r=_*_*(Jt[t]*f+Jt[t+1]*y)}let w=.5-g*g-v*v;if(w>=0){const t=3*i[x+1+s[S+1]];w*=w,a=w*w*(Jt[t]*g+Jt[t+1]*v)}return 70*(n+r+a)}noise3D(t,e,i){const s=this.permMod12,n=this.perm;let r,a,o,h;const l=(t+e+i)*Ft,c=Math.floor(t+l),d=Math.floor(e+l),u=Math.floor(i+l),m=(c+d+u)*Lt,p=t-(c-m),f=e-(d-m),y=i-(u-m);let g,v,x,S,M,_;p>=f?f>=y?(g=1,v=0,x=0,S=1,M=1,_=0):p>=y?(g=1,v=0,x=0,S=1,M=0,_=1):(g=0,v=0,x=1,S=1,M=0,_=1):f<y?(g=0,v=0,x=1,S=0,M=1,_=1):p<y?(g=0,v=1,x=0,S=0,M=1,_=1):(g=0,v=1,x=0,S=1,M=1,_=0);const w=p-g+Lt,z=f-v+Lt,b=y-x+Lt,O=p-S+2*Lt,A=f-M+2*Lt,T=y-_+2*Lt,N=p-1+.5,E=f-1+.5,P=y-1+.5,U=255&c,C=255&d,B=255&u;let R=.6-p*p-f*f-y*y;if(R<0)r=0;else{const t=3*s[U+n[C+n[B]]];R*=R,r=R*R*(Jt[t]*p+Jt[t+1]*f+Jt[t+2]*y)}let k=.6-w*w-z*z-b*b;if(k<0)a=0;else{const t=3*s[U+g+n[C+v+n[B+x]]];k*=k,a=k*k*(Jt[t]*w+Jt[t+1]*z+Jt[t+2]*b)}let F=.6-O*O-A*A-T*T;if(F<0)o=0;else{const t=3*s[U+S+n[C+M+n[B+_]]];F*=F,o=F*F*(Jt[t]*O+Jt[t+1]*A+Jt[t+2]*T)}let L=.6-N*N-E*E-P*P;if(L<0)h=0;else{const t=3*s[U+1+n[C+1+n[B+1]]];L*=L,h=L*L*(Jt[t]*N+Jt[t+1]*E+Jt[t+2]*P)}return 32*(r+a+o+h)}noise4D(t,e,i,s){const n=this.perm;let r,a,o,h,l;const c=(t+e+i+s)*Vt,d=Math.floor(t+c),u=Math.floor(e+c),m=Math.floor(i+c),p=Math.floor(s+c),f=(d+u+m+p)*It,y=t-(d-f),g=e-(u-f),v=i-(m-f),x=s-(p-f);let S=0,M=0,_=0,w=0;y>g?S++:M++,y>v?S++:_++,y>x?S++:w++,g>v?M++:_++,g>x?M++:w++,v>x?_++:w++;const z=S>=3?1:0,b=M>=3?1:0,O=_>=3?1:0,A=w>=3?1:0,T=S>=2?1:0,N=M>=2?1:0,E=_>=2?1:0,P=w>=2?1:0,U=S>=1?1:0,C=M>=1?1:0,B=_>=1?1:0,R=w>=1?1:0,k=y-z+It,F=g-b+It,L=v-O+It,V=x-A+It,I=y-T+2*It,J=g-N+2*It,D=v-E+2*It,G=x-P+2*It,q=y-U+3*It,X=g-C+3*It,Y=v-B+3*It,H=x-R+3*It,Z=y-1+4*It,j=g-1+4*It,W=v-1+4*It,Q=x-1+4*It,K=255&d,$=255&u,tt=255&m,et=255&p;let it=.6-y*y-g*g-v*v-x*x;if(it<0)r=0;else{const t=n[K+n[$+n[tt+n[et]]]]%32*4;it*=it,r=it*it*(Dt[t]*y+Dt[t+1]*g+Dt[t+2]*v+Dt[t+3]*x)}let st=.6-k*k-F*F-L*L-V*V;if(st<0)a=0;else{const t=n[K+z+n[$+b+n[tt+O+n[et+A]]]]%32*4;st*=st,a=st*st*(Dt[t]*k+Dt[t+1]*F+Dt[t+2]*L+Dt[t+3]*V)}let nt=.6-I*I-J*J-D*D-G*G;if(nt<0)o=0;else{const t=n[K+T+n[$+N+n[tt+E+n[et+P]]]]%32*4;nt*=nt,o=nt*nt*(Dt[t]*I+Dt[t+1]*J+Dt[t+2]*D+Dt[t+3]*G)}let rt=.6-q*q-X*X-Y*Y-H*H;if(rt<0)h=0;else{const t=n[K+U+n[$+C+n[tt+B+n[et+R]]]]%32*4;rt*=rt,h=rt*rt*(Dt[t]*q+Dt[t+1]*X+Dt[t+2]*Y+Dt[t+3]*H)}let at=.6-Z*Z-j*j-W*W-Q*Q;if(at<0)l=0;else{const t=n[K+1+n[$+1+n[tt+1+n[et+1]]]]%32*4;at*=at,l=at*at*(Dt[t]*Z+Dt[t+1]*j+Dt[t+2]*W+Dt[t+3]*Q)}return 27*(r+a+o+h+l)}}class qt{constructor(t,e,i,s){this.scale=t,this.octaves=e,this.velocityMultiplier=i,this.timeScale=s,this.type="TurbulenceField",this.generator=new Gt,this.timeOffset=new c,this.temp=new c,this.temp2=new c,this.timeOffset.x=Math.random()/this.scale.x*this.timeScale.x,this.timeOffset.y=Math.random()/this.scale.y*this.timeScale.y,this.timeOffset.z=Math.random()/this.scale.z*this.timeScale.z}initialize(t){}update(t,e){const i=t.position.x/this.scale.x,s=t.position.y/this.scale.y,n=t.position.z/this.scale.z;this.temp.set(0,0,0);let r=1;for(let a=0;a<this.octaves;a++)this.temp2.set(this.generator.noise4D(i*r,s*r,n*r,this.timeOffset.x*r)/r,this.generator.noise4D(i*r,s*r,n*r,this.timeOffset.y*r)/r,this.generator.noise4D(i*r,s*r,n*r,this.timeOffset.z*r)/r),this.temp.add(this.temp2),r*=2;this.temp.multiply(this.velocityMultiplier),t.velocity.addScaledVector(this.temp,e)}toJSON(){return{type:this.type,scale:[this.scale.x,this.scale.y,this.scale.z],octaves:this.octaves,velocityMultiplier:[this.velocityMultiplier.x,this.velocityMultiplier.y,this.velocityMultiplier.z],timeScale:[this.timeScale.x,this.timeScale.y,this.timeScale.z]}}frameUpdate(t){this.timeOffset.x+=t*this.timeScale.x,this.timeOffset.y+=t*this.timeScale.y,this.timeOffset.z+=t*this.timeScale.z}static fromJSON(t){return new qt(new c(t.scale[0],t.scale[1],t.scale[2]),t.octaves,new c(t.velocityMultiplier[0],t.velocityMultiplier[1],t.velocityMultiplier[2]),new c(t.timeScale[0],t.timeScale[1],t.timeScale[2]))}clone(){return new qt(this.scale.clone(),this.octaves,this.velocityMultiplier.clone(),this.timeScale.clone())}reset(){}}const Xt=[],Yt=new c,Ht=new l;class Zt{constructor(t,e,i=new X(1),s=new X(0)){if(this.frequency=t,this.power=e,this.positionAmount=i,this.rotationAmount=s,this.type="Noise",this.duration=0,0===Xt.length)for(let n=0;n<100;n++)Xt.push(new Gt)}initialize(t){t.lastPosNoise=new c,"number"==typeof t.rotation?t.lastRotNoise=0:t.lastRotNoise=new l,t.generatorIndex=[nt(0,100),nt(0,100),nt(0,100),nt(0,100)],this.positionAmount.startGen(t.memory),this.rotationAmount.startGen(t.memory),this.frequency.startGen(t.memory),this.power.startGen(t.memory)}update(t,e){let i=this.frequency.genValue(t.memory,t.age/t.life),s=this.power.genValue(t.memory,t.age/t.life),n=this.positionAmount.genValue(t.memory,t.age/t.life),r=this.rotationAmount.genValue(t.memory,t.age/t.life);n>0&&void 0!==t.lastPosNoise&&(t.position.sub(t.lastPosNoise),Yt.set(Xt[t.generatorIndex[0]].noise2D(0,t.age*i)*s*n,Xt[t.generatorIndex[1]].noise2D(0,t.age*i)*s*n,Xt[t.generatorIndex[2]].noise2D(0,t.age*i)*s*n),t.position.add(Yt),t.lastPosNoise.copy(Yt)),r>0&&void 0!==t.lastRotNoise&&("number"==typeof t.rotation?(t.rotation-=t.lastRotNoise,t.rotation+=Xt[t.generatorIndex[3]].noise2D(0,t.age*i)*Math.PI*s*r):(t.lastRotNoise.invert(),t.rotation.multiply(t.lastRotNoise),Ht.set(Xt[t.generatorIndex[0]].noise2D(0,t.age*i)*s*r,Xt[t.generatorIndex[1]].noise2D(0,t.age*i)*s*r,Xt[t.generatorIndex[2]].noise2D(0,t.age*i)*s*r,Xt[t.generatorIndex[3]].noise2D(0,t.age*i)*s*r).normalize(),t.rotation.multiply(Ht),t.lastRotNoise.copy(Ht)))}toJSON(){return{type:this.type,frequency:this.frequency.toJSON(),power:this.power.toJSON(),positionAmount:this.positionAmount.toJSON(),rotationAmount:this.rotationAmount.toJSON()}}frameUpdate(t){this.duration+=t}static fromJSON(t){return new Zt(j(t.frequency),j(t.power),j(t.positionAmount),j(t.rotationAmount))}clone(){return new Zt(this.frequency.clone(),this.power.clone(),this.positionAmount.clone(),this.rotationAmount.clone())}reset(){}}class jt{constructor(t,e){this.color=t,this.speedRange=e,this.type="ColorBySpeed"}initialize(t){this.color.startGen(t.memory)}update(t,e){const i=(t.startSpeed-this.speedRange.a)/(this.speedRange.b-this.speedRange.a);this.color.genColor(t.memory,t.color,i),t.color.x*=t.startColor.x,t.color.y*=t.startColor.y,t.color.z*=t.startColor.z,t.color.w*=t.startColor.w}frameUpdate(t){}toJSON(){return{type:this.type,color:this.color.toJSON(),speedRange:this.speedRange.toJSON()}}static fromJSON(t){return new jt(q(t.color),Y.fromJSON(t.speedRange))}clone(){return new jt(this.color.clone(),this.speedRange.clone())}reset(){}}class Wt{initialize(t){this.size.startGen(t.memory)}constructor(t,e){this.size=t,this.speedRange=e,this.type="SizeBySpeed"}update(t){const e=(t.startSpeed-this.speedRange.a)/(this.speedRange.b-this.speedRange.a);this.size instanceof tt?this.size.genValue(t.memory,t.size,e).multiply(t.startSize):t.size.copy(t.startSize).multiplyScalar(this.size.genValue(t.memory,e))}toJSON(){return{type:this.type,size:this.size.toJSON(),speedRange:this.speedRange.toJSON()}}static fromJSON(t){return new Wt(et(t.size),Y.fromJSON(t.speedRange))}frameUpdate(t){}clone(){return new Wt(this.size.clone(),this.speedRange.clone())}reset(){}}class Qt{constructor(t,e){this.angularVelocity=t,this.speedRange=e,this.type="RotationBySpeed",this.tempQuat=new l}initialize(t){"number"==typeof t.rotation&&this.angularVelocity.startGen(t.memory)}update(t,e){if("number"==typeof t.rotation){const i=(t.startSpeed-this.speedRange.a)/(this.speedRange.b-this.speedRange.a);t.rotation+=e*this.angularVelocity.genValue(t.memory,i)}}toJSON(){return{type:this.type,angularVelocity:this.angularVelocity.toJSON(),speedRange:this.speedRange.toJSON()}}static fromJSON(t){return new Qt(j(t.angularVelocity),Y.fromJSON(t.speedRange))}frameUpdate(t){}clone(){return new Qt(this.angularVelocity.clone(),this.speedRange.clone())}reset(){}}class Kt{initialize(t){this.speed.startGen(t.memory)}constructor(t,e){this.speed=t,this.dampen=e,this.type="LimitSpeedOverLife"}update(t,e){let i=t.velocity.length(),s=this.speed.genValue(t.memory,t.age/t.life);if(i>s){const n=(i-s)/i;t.velocity.multiplyScalar(1-n*this.dampen*e*20)}}toJSON(){return{type:this.type,speed:this.speed.toJSON(),dampen:this.dampen}}static fromJSON(t){return new Kt(j(t.speed),t.dampen)}frameUpdate(t){}clone(){return new Kt(this.speed.clone(),this.dampen)}reset(){}}const $t={ApplyForce:{type:"ApplyForce",constructor:Et,params:[["direction",["vec3"]],["magnitude",["value"]]],loadJSON:Et.fromJSON},Noise:{type:"Noise",constructor:Zt,params:[["frequency",["value"]],["power",["value"]],["positionAmount",["value"]],["rotationAmount",["value"]]],loadJSON:Zt.fromJSON},TurbulenceField:{type:"TurbulenceField",constructor:qt,params:[["scale",["vec3"]],["octaves",["number"]],["velocityMultiplier",["vec3"]],["timeScale",["vec3"]]],loadJSON:qt.fromJSON},GravityForce:{type:"GravityForce",constructor:Pt,params:[["center",["vec3"]],["magnitude",["number"]]],loadJSON:Pt.fromJSON},ColorOverLife:{type:"ColorOverLife",constructor:yt,params:[["color",["colorFunc"]]],loadJSON:yt.fromJSON},RotationOverLife:{type:"RotationOverLife",constructor:gt,params:[["angularVelocity",["value","valueFunc"]]],loadJSON:gt.fromJSON},Rotation3DOverLife:{type:"Rotation3DOverLife",constructor:vt,params:[["angularVelocity",["rotationFunc"]]],loadJSON:vt.fromJSON},SizeOverLife:{type:"SizeOverLife",constructor:St,params:[["size",["value","valueFunc","vec3Func"]]],loadJSON:St.fromJSON},ColorBySpeed:{type:"ColorBySpeed",constructor:jt,params:[["color",["colorFunc"]],["speedRange",["range"]]],loadJSON:jt.fromJSON},RotationBySpeed:{type:"RotationBySpeed",constructor:Qt,params:[["angularVelocity",["value","valueFunc"]],["speedRange",["range"]]],loadJSON:Qt.fromJSON},SizeBySpeed:{type:"SizeBySpeed",constructor:Wt,params:[["size",["value","valueFunc","vec3Func"]],["speedRange",["range"]]],loadJSON:Wt.fromJSON},SpeedOverLife:{type:"SpeedOverLife",constructor:Mt,params:[["speed",["value","valueFunc"]]],loadJSON:Mt.fromJSON},FrameOverLife:{type:"FrameOverLife",constructor:_t,params:[["frame",["value","valueFunc"]]],loadJSON:_t.fromJSON},ForceOverLife:{type:"ForceOverLife",constructor:xt,params:[["x",["value","valueFunc"]],["y",["value","valueFunc"]],["z",["value","valueFunc"]]],loadJSON:xt.fromJSON},OrbitOverLife:{type:"OrbitOverLife",constructor:wt,params:[["orbitSpeed",["value","valueFunc"]],["axis",["vec3"]]],loadJSON:wt.fromJSON},WidthOverLength:{type:"WidthOverLength",constructor:Nt,params:[["width",["value","valueFunc"]]],loadJSON:Nt.fromJSON},ChangeEmitDirection:{type:"ChangeEmitDirection",constructor:Ut,params:[["angle",["value"]]],loadJSON:Ut.fromJSON},EmitSubParticleSystem:{type:"EmitSubParticleSystem",constructor:Bt,params:[["particleSystem",["self"]],["useVelocityAsBasis",["boolean"]],["subParticleSystem",["particleSystem"]],["mode",["number"]],["emitProbability",["number"]]],loadJSON:Bt.fromJSON},LimitSpeedOverLife:{type:"LimitSpeedOverLife",constructor:Kt,params:[["speed",["value","valueFunc"]],["dampen",["number"]]],loadJSON:Kt.fromJSON}};const te=[];const{Triangle:ee,Vector3:ie,ShaderChunk:se,Object3D:ne,Mesh:re,Layers:ae,PlaneGeometry:oe,MeshBasicMaterial:he,DoubleSide:le,AdditiveBlending:ce,MeshStandardMaterial:de,MeshPhysicalMaterial:ue,InstancedBufferAttribute:me,DynamicDrawUsage:pe,InstancedBufferGeometry:fe,Uniform:ye,ShaderMaterial:ge,BufferGeometry:ve,BufferAttribute:xe,Group:Se,Clock:Me,AnimationMixer:_e,LoopOnce:we,ObjectLoader:ze,Bone:be,Sprite:Oe,Points:Ae,LineSegments:Te,LineLoop:Ne,Line:Ee,LOD:Pe,BatchedMesh:Ue,Box3:Ce,Sphere:Be,InstancedMesh:Re,SkinnedMesh:ke,LightProbe:Fe,HemisphereLight:Le,SpotLight:Ve,RectAreaLight:Ie,PointLight:Je,DirectionalLight:De,AmbientLight:Ge,OrthographicCamera:qe,PerspectiveCamera:Xe,Scene:Ye,Color:He,Fog:Ze,FogExp2:je}=await t("three");class We{get geometry(){return this._geometry}set geometry(t){if(this._geometry=t,void 0===t)return;if("string"==typeof t)return;const e=new ee;this._triangleIndexToArea.length=0;let i=0;if(!t.getIndex())return;const s=t.getIndex().array,n=s.length/3;this._triangleIndexToArea.push(0);for(let r=0;r<n;r++)e.setFromAttributeAndIndices(t.getAttribute("position"),s[3*r],s[3*r+1],s[3*r+2]),i+=e.getArea(),this._triangleIndexToArea.push(i);t.userData.triangleIndexToArea=this._triangleIndexToArea}constructor(t){this.type="mesh_surface",this._triangleIndexToArea=[],this._tempA=new ie,this._tempB=new ie,this._tempC=new ie,t&&(this.geometry=t)}initialize(t){const e=this._geometry;if(!e||null===e.getIndex())return t.position.set(0,0,0),void t.velocity.set(0,0,1).multiplyScalar(t.startSpeed);const i=this._triangleIndexToArea.length-1;let s=0,n=i;const r=Math.random()*this._triangleIndexToArea[i];for(;s+1<n;){const t=Math.floor((s+n)/2);r<this._triangleIndexToArea[t]?n=t:s=t}let a=Math.random(),o=Math.random();a+o>1&&(a=1-a,o=1-o);const h=e.getIndex().array[3*s],l=e.getIndex().array[3*s+1],c=e.getIndex().array[3*s+2],d=e.getAttribute("position");this._tempA.fromBufferAttribute(d,h),this._tempB.fromBufferAttribute(d,l),this._tempC.fromBufferAttribute(d,c),this._tempB.sub(this._tempA),this._tempC.sub(this._tempA),this._tempA.addScaledVector(this._tempB,a).addScaledVector(this._tempC,o),t.position.copy(this._tempA),this._tempA.copy(this._tempB).cross(this._tempC).normalize(),t.velocity.copy(this._tempA).normalize().multiplyScalar(t.startSpeed)}toJSON(){return{type:"mesh_surface",mesh:this._geometry?this._geometry.uuid:""}}static fromJSON(t,e){return new We(e.geometries[t.geometry])}clone(){return new We(this._geometry)}update(t,e){}}const Qe={id:"three.quarks",emitterShapes:[{type:"mesh_surface",params:[["geometry",["geometry"]]],constructor:We,loadJSON:We.fromJSON}],behaviors:[]};const Ke=se;class $e extends ne{constructor(t){super(),this.type="ParticleEmitter",this.system=t}clone(){const t=this.system.clone();return t.emitter.copy(this,!0),t.emitter}dispose(){}extractFromCache(t){const e=[];for(const i in t){const s=t[i];delete s.metadata,e.push(s)}return e}toJSON(t,e={}){const i=this.children;this.children=this.children.filter(t=>"ParticleSystemPreview"!==t.type);const s=super.toJSON(t);return this.children=i,null!==this.system&&(s.object.ps=this.system.toJSON(t,e)),s}}var ti;!function(t){t[t.BillBoard=0]="BillBoard",t[t.StretchedBillBoard=1]="StretchedBillBoard",t[t.Mesh=2]="Mesh",t[t.Trail=3]="Trail",t[t.HorizontalBillBoard=4]="HorizontalBillBoard",t[t.VerticalBillBoard=5]="VerticalBillBoard"}(ti||(ti={}));class ei extends re{constructor(t){super(),this.type="VFXBatch",this.maxParticles=1e3,this.systems=new Set;const e=new ae;e.mask=t.layers.mask;const i=t.material.clone();i.defines={},Object.assign(i.defines,t.material.defines),this.settings={instancingGeometry:t.instancingGeometry,renderMode:t.renderMode,renderOrder:t.renderOrder,material:i,uTileCount:t.uTileCount,vTileCount:t.vTileCount,blendTiles:t.blendTiles,softParticles:t.softParticles,softNearFade:t.softNearFade,softFarFade:t.softFarFade,layers:e},this.frustumCulled=!1,this.renderOrder=this.settings.renderOrder}addSystem(t){this.systems.add(t)}removeSystem(t){this.systems.delete(t)}applyDepthTexture(t){const e=this.material.uniforms.depthTexture;e&&e.value!==t&&(e.value=t,this.material.needsUpdate=!0)}getVisibleSystems(){return Array.from(this.systems).filter(t=>t.emitter.visible)}}const ii=new c(0,0,1),si=new l,ni=new c,ri=new c;new c;const ai=new oe(1,1,1,1);class oi{set time(t){this.emissionState.time=t}get time(){return this.emissionState.time}get layers(){return this.rendererSettings.layers}get texture(){return this.rendererSettings.material.map}set texture(t){this.rendererSettings.material.map=t,this.neededToUpdateRender=!0}get material(){return this.rendererSettings.material}set material(t){this.rendererSettings.material=t,this.neededToUpdateRender=!0}get uTileCount(){return this.rendererSettings.uTileCount}set uTileCount(t){this.rendererSettings.uTileCount=t,this.neededToUpdateRender=!0}get vTileCount(){return this.rendererSettings.vTileCount}set vTileCount(t){this.rendererSettings.vTileCount=t,this.neededToUpdateRender=!0}get blendTiles(){return this.rendererSettings.blendTiles}set blendTiles(t){this.rendererSettings.blendTiles=t,this.neededToUpdateRender=!0}get softParticles(){return this.rendererSettings.softParticles}set softParticles(t){this.rendererSettings.softParticles=t,this.neededToUpdateRender=!0}get softNearFade(){return this.rendererSettings.softNearFade}set softNearFade(t){this.rendererSettings.softNearFade=t,this.neededToUpdateRender=!0}get softFarFade(){return this.rendererSettings.softFarFade}set softFarFade(t){this.rendererSettings.softFarFade=t,this.neededToUpdateRender=!0}get instancingGeometry(){return this.rendererSettings.instancingGeometry}set instancingGeometry(t){this.restart(),this.particles.length=0,this.rendererSettings.instancingGeometry=t,this.neededToUpdateRender=!0}get renderMode(){return this.rendererSettings.renderMode}set renderMode(t){if(this.rendererSettings.renderMode!==t){let e=!1;switch(this.rendererSettings.renderMode===ti.Trail&&(e=!0),this.rendererSettings.renderMode===ti.Mesh&&(this.startRotation=new X(0)),t){case ti.Trail:this.rendererEmitterSettings={startLength:new X(30),followLocalOrigin:!1},e=!0;break;case ti.Mesh:this.rendererEmitterSettings={geometry:ai},this.startRotation=new Q(new c(0,1,0),new X(0));break;case ti.StretchedBillBoard:this.rendererEmitterSettings={speedFactor:0,lengthFactor:2},this.rendererSettings.instancingGeometry=ai;break;case ti.BillBoard:case ti.VerticalBillBoard:case ti.HorizontalBillBoard:this.rendererEmitterSettings={},this.rendererSettings.instancingGeometry=ai}this.rendererSettings.renderMode=t,e&&(this.restart(),this.particles.length=0),this.neededToUpdateRender=!0}}get renderOrder(){return this.rendererSettings.renderOrder}set renderOrder(t){this.rendererSettings.renderOrder=t,this.neededToUpdateRender=!0}get blending(){return this.rendererSettings.material.blending}set blending(t){this.rendererSettings.material.blending=t,this.neededToUpdateRender=!0}constructor(t){if(this.temp=new c,this.travelDistance=0,this.normalMatrix=new A,this.memory=[],this.listeners={},this.firstTimeUpdate=!0,this.autoDestroy=void 0!==t.autoDestroy&&t.autoDestroy,this.duration=t.duration??1,this.looping=void 0===t.looping||t.looping,this.prewarm=void 0!==t.prewarm&&t.prewarm,this.startLife=t.startLife??new X(5),this.startSpeed=t.startSpeed??new X(0),this.startRotation=t.startRotation??new X(0),this.startSize=t.startSize??new X(1),this.startColor=t.startColor??new G(new O(1,1,1,1)),this.emissionOverTime=t.emissionOverTime??new X(10),this.emissionOverDistance=t.emissionOverDistance??new X(0),this.emissionBursts=t.emissionBursts??[],this.onlyUsedByOther=t.onlyUsedByOther??!1,this.emitterShape=t.shape??new dt,this.behaviors=t.behaviors??new Array,this.worldSpace=t.worldSpace??!1,this.rendererEmitterSettings=t.rendererEmitterSettings??{},t.renderMode===ti.StretchedBillBoard){const e=this.rendererEmitterSettings;void 0!==t.speedFactor&&(e.speedFactor=t.speedFactor),e.speedFactor=e.speedFactor??0,e.lengthFactor=e.lengthFactor??0}this.rendererSettings={instancingGeometry:t.instancingGeometry??ai,renderMode:t.renderMode??ti.BillBoard,renderOrder:t.renderOrder??0,material:t.material,uTileCount:t.uTileCount??1,vTileCount:t.vTileCount??1,blendTiles:t.blendTiles??!1,softParticles:t.softParticles??!1,softNearFade:t.softNearFade??0,softFarFade:t.softFarFade??0,layers:t.layers??new ae},this.neededToUpdateRender=!0,this.particles=new Array,this.startTileIndex=t.startTileIndex||new X(0),this.emitter=new $e(this),this.paused=!1,this.particleNum=0,this.emissionState={isBursting:!1,burstParticleIndex:0,burstParticleCount:0,burstIndex:0,burstWaveIndex:0,time:0,waitEmiting:0,travelDistance:0},this.emissionBursts.forEach(t=>t.count.startGen(this.memory)),this.emissionOverDistance.startGen(this.memory),this.emitEnded=!1,this.markForDestroy=!1,this.prewarmed=!1}pause(){this.paused=!0}play(){this.paused=!1}stop(){this.restart(),this.pause()}spawn(t,e,i){si.setFromRotationMatrix(i);const s=ni,n=si,r=ri;i.decompose(s,n,r);for(let a=0;a<t;a++){for(e.burstParticleIndex=a,this.particleNum++;this.particles.length<this.particleNum;)this.rendererSettings.renderMode===ti.Trail?this.particles.push(new Tt):this.particles.push(new Ot);const t=this.particles[this.particleNum-1];if(t.reset(),t.speedModifier=1,this.startColor.startGen(t.memory),this.startColor.genColor(t.memory,t.startColor,this.emissionState.time),t.color.copy(t.startColor),this.startSpeed.startGen(t.memory),t.startSpeed=this.startSpeed.genValue(t.memory,e.time/this.duration),this.startLife.startGen(t.memory),t.life=this.startLife.genValue(t.memory,e.time/this.duration),t.age=0,this.startSize.startGen(t.memory),"vec3function"===this.startSize.type)this.startSize.genValue(t.memory,t.startSize,e.time/this.duration);else{const i=this.startSize.genValue(t.memory,e.time/this.duration);t.startSize.set(i,i,i)}if(this.startTileIndex.startGen(t.memory),t.uvTile=this.startTileIndex.genValue(t.memory),t.size.copy(t.startSize),this.rendererSettings.renderMode===ti.Mesh||this.rendererSettings.renderMode===ti.BillBoard||this.rendererSettings.renderMode===ti.VerticalBillBoard||this.rendererSettings.renderMode===ti.HorizontalBillBoard||this.rendererSettings.renderMode===ti.StretchedBillBoard){const i=t;this.startRotation.startGen(t.memory),this.rendererSettings.renderMode===ti.Mesh?(i.rotation instanceof l||(i.rotation=new l),"rotation"===this.startRotation.type?this.startRotation.genValue(t.memory,i.rotation,1,e.time/this.duration):i.rotation.setFromAxisAngle(ii,this.startRotation.genValue(i.memory,e.time/this.duration))):"rotation"===this.startRotation.type?i.rotation=0:i.rotation=this.startRotation.genValue(i.memory,e.time/this.duration)}else if(this.rendererSettings.renderMode===ti.Trail){const i=t;this.rendererEmitterSettings.startLength.startGen(i.memory),i.length=this.rendererEmitterSettings.startLength.genValue(i.memory,e.time/this.duration)}if(this.emitterShape.initialize(t,e),this.rendererSettings.renderMode===ti.Trail&&this.rendererEmitterSettings.followLocalOrigin){const e=t;e.localPosition=(new c).copy(e.position)}this.worldSpace?(t.position.applyMatrix4(i),t.startSize.multiply(r).abs(),t.size.copy(t.startSize),t.velocity.multiply(r).applyMatrix3(this.normalMatrix),t.rotation&&t.rotation instanceof l&&t.rotation.multiplyQuaternions(si,t.rotation)):this.onlyUsedByOther&&(t.parentMatrix=i);for(let e=0;e<this.behaviors.length;e++)this.behaviors[e].initialize(t,this)}}endEmit(){this.emitEnded=!0,this.autoDestroy&&(this.markForDestroy=!0),this.fire({type:"emitEnd",particleSystem:this})}dispose(){this._renderer&&this._renderer.deleteSystem(this),this.emitter.dispose(),this.emitter.parent&&this.emitter.parent.remove(this.emitter),this.fire({type:"destroy",particleSystem:this})}restart(){this.memory.length=0,this.paused=!1,this.particleNum=0,this.emissionState.isBursting=!1,this.emissionState.burstIndex=0,this.emissionState.burstWaveIndex=0,this.emissionState.time=0,this.emissionState.waitEmiting=0,this.behaviors.forEach(t=>{t.reset()}),this.emitEnded=!1,this.markForDestroy=!1,this.prewarmed=!1,this.emissionBursts.forEach(t=>t.count.startGen(this.memory)),this.emissionOverDistance.startGen(this.memory)}update(t){if(this.paused)return;let e=this.emitter;for(;e.parent;)e=e.parent;if("Scene"===e.type)if(this.firstTimeUpdate&&(this.firstTimeUpdate=!1,this.emitter.updateWorldMatrix(!0,!1)),this.emitEnded&&0===this.particleNum)this.markForDestroy&&this.emitter.parent&&this.dispose();else{if(this.looping&&this.prewarm&&!this.prewarmed){this.prewarmed=!0;for(let t=0;t<60*this.duration;t++)this.update(1/60)}t>.1&&(t=.1),this.neededToUpdateRender&&(this._renderer&&this._renderer.updateSystem(this),this.neededToUpdateRender=!1),this.onlyUsedByOther||this.emit(t,this.emissionState,this.emitter.matrixWorld),this.emitterShape.update(this,t);for(let e=0;e<this.behaviors.length;e++){this.behaviors[e].frameUpdate(t);for(let i=0;i<this.particleNum;i++)this.particles[i].died||this.behaviors[e].update(this.particles[i],t)}for(let e=0;e<this.particleNum;e++)this.rendererEmitterSettings.followLocalOrigin&&this.particles[e].localPosition?(this.particles[e].position.copy(this.particles[e].localPosition),this.particles[e].parentMatrix?this.particles[e].position.applyMatrix4(this.particles[e].parentMatrix):this.particles[e].position.applyMatrix4(this.emitter.matrixWorld)):this.particles[e].position.addScaledVector(this.particles[e].velocity,t*this.particles[e].speedModifier),this.particles[e].age+=t;if(this.rendererSettings.renderMode===ti.Trail)for(let t=0;t<this.particleNum;t++){this.particles[t].update()}for(let t=0;t<this.particleNum;t++){const e=this.particles[t];!e.died||e instanceof Tt&&0!==e.previous.length||(this.particles[t]=this.particles[this.particleNum-1],this.particles[this.particleNum-1]=e,this.particleNum--,t--,this.fire({type:"particleDied",particleSystem:this,particle:e}))}}else this.dispose()}emit(t,e,i){e.time>this.duration&&(this.looping?(e.time-=this.duration,e.burstIndex=0,this.behaviors.forEach(t=>{t.reset()})):this.emitEnded||this.onlyUsedByOther||this.endEmit()),this.normalMatrix.getNormalMatrix(i);const s=Math.ceil(e.waitEmiting);for(this.spawn(s,e,i),e.waitEmiting-=s;e.burstIndex<this.emissionBursts.length&&this.emissionBursts[e.burstIndex].time<=e.time;){if(Math.random()<this.emissionBursts[e.burstIndex].probability){const t=this.emissionBursts[e.burstIndex].count.genValue(this.memory,this.time);e.isBursting=!0,e.burstParticleCount=t,this.spawn(t,e,i),e.isBursting=!1}e.burstIndex++}if(!this.emitEnded&&(e.waitEmiting+=t*this.emissionOverTime.genValue(this.memory,e.time/this.duration),null!=e.previousWorldPos)){this.temp.set(i.elements[12],i.elements[13],i.elements[14]),e.travelDistance+=e.previousWorldPos.distanceTo(this.temp);const t=this.emissionOverDistance.genValue(this.memory,e.time/this.duration);if(e.travelDistance*t>0){const i=Math.floor(e.travelDistance*t);e.travelDistance-=i/t,e.waitEmiting+=i}}void 0===e.previousWorldPos&&(e.previousWorldPos=new c),e.previousWorldPos.set(i.elements[12],i.elements[13],i.elements[14]),e.time+=t}toJSON(t,e={}){if((void 0===t||"string"==typeof t)&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}}),t.materials[this.rendererSettings.material.uuid]=this.rendererSettings.material.toJSON(t),e.useUrlForImage&&void 0!==this.texture?.source){const e=this.texture.source;t.images[e.uuid]={uuid:e.uuid,url:this.texture.image.url}}let i;i=this.renderMode===ti.Trail?{startLength:this.rendererEmitterSettings.startLength.toJSON(),followLocalOrigin:this.rendererEmitterSettings.followLocalOrigin}:this.renderMode===ti.Mesh?{}:this.renderMode===ti.StretchedBillBoard?{speedFactor:this.rendererEmitterSettings.speedFactor,lengthFactor:this.rendererEmitterSettings.lengthFactor}:{};const s=this.rendererSettings.instancingGeometry;return t.geometries&&!t.geometries[s.uuid]&&(t.geometries[s.uuid]=s.toJSON()),{version:"3.0",autoDestroy:this.autoDestroy,looping:this.looping,prewarm:this.prewarm,duration:this.duration,shape:this.emitterShape.toJSON(),startLife:this.startLife.toJSON(),startSpeed:this.startSpeed.toJSON(),startRotation:this.startRotation.toJSON(),startSize:this.startSize.toJSON(),startColor:this.startColor.toJSON(),emissionOverTime:this.emissionOverTime.toJSON(),emissionOverDistance:this.emissionOverDistance.toJSON(),emissionBursts:this.emissionBursts.map(t=>({time:t.time,count:t.count.toJSON(),probability:t.probability,interval:t.interval,cycle:t.cycle})),onlyUsedByOther:this.onlyUsedByOther,instancingGeometry:this.rendererSettings.instancingGeometry.uuid,renderOrder:this.renderOrder,renderMode:this.renderMode,rendererEmitterSettings:i,material:this.rendererSettings.material.uuid,layers:this.layers.mask,startTileIndex:this.startTileIndex.toJSON(),uTileCount:this.uTileCount,vTileCount:this.vTileCount,blendTiles:this.blendTiles,softParticles:this.rendererSettings.softParticles,softFarFade:this.rendererSettings.softFarFade,softNearFade:this.rendererSettings.softNearFade,behaviors:this.behaviors.map(t=>t.toJSON()),worldSpace:this.worldSpace}}static fromJSON(t,e,i){const s=function(t,e){return ft[t.type].loadJSON(t,e)}(t.shape,e);let n;if(t.renderMode===ti.Trail){const e=t.rendererEmitterSettings;n={startLength:null!=e.startLength?j(e.startLength):new X(30),followLocalOrigin:e.followLocalOrigin}}else t.renderMode===ti.Mesh?n={}:t.renderMode===ti.StretchedBillBoard?(n=t.rendererEmitterSettings,null!=t.speedFactor&&(n.speedFactor=t.speedFactor)):n={};const r=new ae;t.layers&&(r.mask=t.layers);const a=new oi({autoDestroy:t.autoDestroy,looping:t.looping,prewarm:t.prewarm,duration:t.duration,shape:s,startLife:j(t.startLife),startSpeed:j(t.startSpeed),startRotation:et(t.startRotation),startSize:et(t.startSize),startColor:q(t.startColor),emissionOverTime:j(t.emissionOverTime),emissionOverDistance:j(t.emissionOverDistance),emissionBursts:t.emissionBursts?.map(t=>({time:t.time,count:"number"==typeof t.count?new X(t.count):j(t.count),probability:t.probability??1,interval:t.interval??.1,cycle:t.cycle??1})),onlyUsedByOther:t.onlyUsedByOther,instancingGeometry:e.geometries[t.instancingGeometry],renderMode:t.renderMode,rendererEmitterSettings:n,renderOrder:t.renderOrder,layers:r,material:t.material?e.materials[t.material]:t.texture?new he({map:e.textures[t.texture],transparent:t.transparent??!0,blending:t.blending,side:le}):new he({color:16777215,transparent:!0,blending:ce,side:le}),startTileIndex:"number"==typeof t.startTileIndex?new X(t.startTileIndex):j(t.startTileIndex),uTileCount:t.uTileCount,vTileCount:t.vTileCount,blendTiles:t.blendTiles,softParticles:t.softParticles,softFarFade:t.softFarFade,softNearFade:t.softNearFade,behaviors:[],worldSpace:t.worldSpace});return a.behaviors=t.behaviors.map(t=>{const e=function(t,e){return $t[t.type]?$t[t.type].loadJSON(t,e):null}(t,a);return e&&"EmitSubParticleSystem"===e.type&&(i[t.subParticleSystem]=e),e}).filter(t=>null!==t),a}addBehavior(t){this.behaviors.push(t)}getRendererSettings(){return this.rendererSettings}addEventListener(t,e){this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(e)}removeAllEventListeners(t){this.listeners[t]&&(this.listeners[t]=[])}removeEventListener(t,e){if(this.listeners[t]){const i=this.listeners[t].indexOf(e);-1!==i&&this.listeners[t].splice(i,1)}}fire(t){this.listeners[t.type]&&this.listeners[t.type].forEach(e=>e(t))}clone(){const t=[];for(const n of this.emissionBursts){const e={};Object.assign(e,n),t.push(e)}const e=[];for(const n of this.behaviors)e.push(n.clone());let i;i=this.renderMode===ti.Trail?{startLength:this.rendererEmitterSettings.startLength.clone(),followLocalOrigin:this.rendererEmitterSettings.followLocalOrigin}:this.renderMode===ti.StretchedBillBoard?{lengthFactor:this.rendererEmitterSettings.lengthFactor,speedFactor:this.rendererEmitterSettings.speedFactor}:{};const s=new ae;return s.mask=this.layers.mask,new oi({autoDestroy:this.autoDestroy,looping:this.looping,duration:this.duration,shape:this.emitterShape.clone(),startLife:this.startLife.clone(),startSpeed:this.startSpeed.clone(),startRotation:this.startRotation.clone(),startSize:this.startSize.clone(),startColor:this.startColor.clone(),emissionOverTime:this.emissionOverTime.clone(),emissionOverDistance:this.emissionOverDistance.clone(),emissionBursts:t,onlyUsedByOther:this.onlyUsedByOther,instancingGeometry:this.rendererSettings.instancingGeometry,renderMode:this.renderMode,renderOrder:this.renderOrder,rendererEmitterSettings:i,material:this.rendererSettings.material,startTileIndex:this.startTileIndex,uTileCount:this.uTileCount,vTileCount:this.vTileCount,blendTiles:this.blendTiles,softParticles:this.softParticles,softFarFade:this.softFarFade,softNearFade:this.softNearFade,behaviors:e,worldSpace:this.worldSpace,layers:s})}}var hi="\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <alphatest_pars_fragment>\n\n#include <tile_pars_fragment>\n#include <soft_pars_fragment>\n\nvoid main() {\n\n    #include <clipping_planes_fragment>\n    \n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vColor;\n    \n    #include <logdepthbuf_fragment>\n    \n    #include <tile_fragment>\n    #include <alphatest_fragment>\n\n    outgoingLight = diffuseColor.rgb;\n    \n    #ifdef USE_COLOR_AS_ALPHA\n    gl_FragColor = vec4( outgoingLight, diffuseColor.r );\n    #else\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #endif\n    \n    #include <soft_fragment>\n    #include <tonemapping_fragment>\n}\n",li="\n#define STANDARD\n\n#ifdef PHYSICAL\n#define IOR\n#define USE_SPECULAR\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef IOR\nuniform float ior;\n#endif\n\n#ifdef USE_SPECULAR\nuniform float specularIntensity;\nuniform vec3 specularColor;\n\n#ifdef USE_SPECULAR_COLORMAP\nuniform sampler2D specularColorMap;\n#endif\n\n#ifdef USE_SPECULAR_INTENSITYMAP\nuniform sampler2D specularIntensityMap;\n#endif\n#endif\n\n#ifdef USE_CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_DISPERSION\nuniform float dispersion;\n#endif\n\n#ifdef USE_IRIDESCENCE\nuniform float iridescence;\nuniform float iridescenceIOR;\nuniform float iridescenceThicknessMinimum;\nuniform float iridescenceThicknessMaximum;\n#endif\n\n#ifdef USE_SHEEN\nuniform vec3 sheenColor;\nuniform float sheenRoughness;\n\n#ifdef USE_SHEEN_COLORMAP\nuniform sampler2D sheenColorMap;\n#endif\n\n#ifdef USE_SHEEN_ROUGHNESSMAP\nuniform sampler2D sheenRoughnessMap;\n#endif\n#endif\n\n#ifdef USE_ANISOTROPY\nuniform vec2 anisotropyVector;\n\n#ifdef USE_ANISOTROPYMAP\nuniform sampler2D anisotropyMap;\n#endif\n#endif\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\nvec4 diffuseColor = vec4( diffuse, opacity );\n#include <clipping_planes_fragment>\n\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\nvec3 totalEmissiveRadiance = emissive;\n\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <alphahash_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n\n// accumulation\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n\n// modulation\n#include <aomap_fragment>\n\nvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\nvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n#include <transmission_fragment>\n\nvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n#ifdef USE_SHEEN\n\n// Sheen energy compensation approximation calculation can be found at the end of\n// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\noutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\n#endif\n\n#ifdef USE_CLEARCOAT\n\nfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\nvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\noutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\n#endif\n\n#include <opaque_fragment>\n#include <tonemapping_fragment>\n#include <colorspace_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",ci="\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n\nattribute vec3 offset;\nattribute vec4 rotation;\nattribute vec3 size;\n#include <tile_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n    #include <tile_vertex>\n    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;\n    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;\n    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;\n    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;\n    float sx = size.x, sy = size.y, sz = size.z;\n\n    mat4 particleMatrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column\n                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column\n                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column\n                      offset.x, offset.y, offset.z, 1.0);\n\n#include <color_vertex>\n#include <morphinstance_vertex>\n#include <morphcolor_vertex>\n#include <batching_vertex>\n\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n\n\t// replace defaultnormal_vertex\n\tvec3 transformedNormal = objectNormal;\n    mat3 m = mat3( particleMatrix );\n    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n    transformedNormal = m * transformedNormal;\n    transformedNormal = normalMatrix * transformedNormal;\n    #ifdef FLIP_SIDED\n        transformedNormal = - transformedNormal;\n    #endif\n    #ifdef USE_TANGENT\n        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n        #ifdef FLIP_SIDED\n        transformedTangent = - transformedTangent;\n        #endif\n    #endif\n\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\n\t// replace include <project_vertex>\n  vec4 mvPosition = vec4( transformed, 1.0 );\n  mvPosition = modelViewMatrix * (particleMatrix * mvPosition);\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t\n\tvViewPosition = - mvPosition.xyz;\n\t\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n    vWorldPosition = worldPosition.xyz;\n#endif\n}\n";function di(t){return 0===t?"uv":`uv${t}`}class ui extends de{constructor(t){super(t)}onBeforeCompile(t,e){super.onBeforeCompile(t,e),t.vertexShader=ci,t.fragmentShader=li}}class mi extends ue{constructor(t){super(t)}onBeforeCompile(t,e){super.onBeforeCompile(t,e),t.vertexShader=ci,t.fragmentShader=li}}class pi extends ei{constructor(t){super(t),this.vector_=new c,this.vector2_=new c,this.vector3_=new c,this.quaternion_=new l,this.quaternion2_=new l,this.quaternion3_=new l,this.rotationMat_=new A,this.rotationMat2_=new A,this.maxParticles=1e3,this.setupBuffers(),this.rebuildMaterial()}buildExpandableBuffers(){this.offsetBuffer=new me(new Float32Array(3*this.maxParticles),3),this.offsetBuffer.setUsage(pe),this.geometry.setAttribute("offset",this.offsetBuffer),this.colorBuffer=new me(new Float32Array(4*this.maxParticles),4),this.colorBuffer.setUsage(pe),this.geometry.setAttribute("color",this.colorBuffer),this.settings.renderMode===ti.Mesh?(this.rotationBuffer=new me(new Float32Array(4*this.maxParticles),4),this.rotationBuffer.setUsage(pe),this.geometry.setAttribute("rotation",this.rotationBuffer)):this.settings.renderMode!==ti.BillBoard&&this.settings.renderMode!==ti.HorizontalBillBoard&&this.settings.renderMode!==ti.VerticalBillBoard&&this.settings.renderMode!==ti.StretchedBillBoard||(this.rotationBuffer=new me(new Float32Array(this.maxParticles),1),this.rotationBuffer.setUsage(pe),this.geometry.setAttribute("rotation",this.rotationBuffer)),this.sizeBuffer=new me(new Float32Array(3*this.maxParticles),3),this.sizeBuffer.setUsage(pe),this.geometry.setAttribute("size",this.sizeBuffer),this.uvTileBuffer=new me(new Float32Array(this.maxParticles),1),this.uvTileBuffer.setUsage(pe),this.geometry.setAttribute("uvTile",this.uvTileBuffer),this.settings.renderMode===ti.StretchedBillBoard&&(this.velocityBuffer=new me(new Float32Array(4*this.maxParticles),4),this.velocityBuffer.setUsage(pe),this.geometry.setAttribute("velocity",this.velocityBuffer))}setupBuffers(){this.geometry&&this.geometry.dispose(),this.geometry=new fe,this.geometry.setIndex(this.settings.instancingGeometry.getIndex()),this.settings.instancingGeometry.hasAttribute("normal")&&this.geometry.setAttribute("normal",this.settings.instancingGeometry.getAttribute("normal")),this.geometry.setAttribute("position",this.settings.instancingGeometry.getAttribute("position")),this.settings.instancingGeometry.hasAttribute("uv")&&this.geometry.setAttribute("uv",this.settings.instancingGeometry.getAttribute("uv")),this.buildExpandableBuffers()}expandBuffers(t){for(;t>=this.maxParticles;)this.maxParticles*=2;this.setupBuffers()}rebuildMaterial(){this.layers.mask=this.settings.layers.mask;const t={},e={};"MeshStandardMaterial"!==this.settings.material.type&&"MeshPhysicalMaterial"!==this.settings.material.type&&(t.map=new ye(this.settings.material.map)),this.settings.material.alphaTest&&(e.USE_ALPHATEST="",t.alphaTest=new ye(this.settings.material.alphaTest)),e.USE_UV="";const i=this.settings.uTileCount,s=this.settings.vTileCount;let n;if((i>1||s>1)&&(e.UV_TILE="",t.tileCount=new ye(new b(i,s))),this.settings.material.defines&&void 0!==this.settings.material.defines.USE_COLOR_AS_ALPHA&&(e.USE_COLOR_AS_ALPHA=""),this.settings.material.normalMap&&(e.USE_NORMALMAP="",e.NORMALMAP_UV=di(this.settings.material.normalMap.channel),t.normalMapTransform=new ye((new A).copy(this.settings.material.normalMap.matrix))),this.settings.material.map&&(e.USE_MAP="",this.settings.blendTiles&&(e.TILE_BLEND=""),e.MAP_UV=di(this.settings.material.map.channel),t.mapTransform=new ye((new A).copy(this.settings.material.map.matrix))),e.USE_COLOR_ALPHA="",this.settings.softParticles){e.SOFT_PARTICLES="";const i=this.settings.softNearFade,s=1/(this.settings.softFarFade-this.settings.softNearFade);t.softParams=new ye(new b(i,s)),t.depthTexture=new ye(null);const r=t.projParams=new ye(new O);n=(t,e,i)=>{r.value.set(i.near,i.far,0,0)}}let r=!1;if(this.settings.renderMode===ti.BillBoard||this.settings.renderMode===ti.VerticalBillBoard||this.settings.renderMode===ti.HorizontalBillBoard||this.settings.renderMode===ti.Mesh){let i,s;this.settings.renderMode===ti.Mesh?"MeshStandardMaterial"===this.settings.material.type||"MeshPhysicalMaterial"===this.settings.material.type?(e.USE_COLOR="",i=ci,s=li,r=!0):(i="\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute vec4 rotation;\nattribute vec3 size;\n// attribute vec4 color;\n\nvoid main() {\n\n    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;\n    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;\n    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;\n    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;\n    float sx = size.x, sy = size.y, sz = size.z;\n    \n    mat4 matrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column\n                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column\n                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column\n                      offset.x, offset.y, offset.z, 1.0);\n    \n    vec4 mvPosition = modelViewMatrix * (matrix * vec4( position, 1.0 ));\n\n\tvColor = color;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n    #include <tile_vertex>\n    #include <soft_vertex>\n}\n",s=hi):(i="\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute float rotation;\nattribute vec3 size;\n\nvoid main() {\n\t\n    vec2 alignedPosition = position.xy * size.xy;\n    \n    vec2 rotatedPosition;\n    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n#ifdef HORIZONTAL\n    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );\n    mvPosition.x += rotatedPosition.x;\n    mvPosition.z -= rotatedPosition.y;\n    mvPosition = viewMatrix * mvPosition;\n#elif defined(VERTICAL)\n    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );\n    mvPosition.y += rotatedPosition.y;\n    mvPosition = viewMatrix * mvPosition;\n    mvPosition.x += rotatedPosition.x;\n#else\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    mvPosition.xy += rotatedPosition;\n#endif\n\n\tvColor = color;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\n\t#include <clipping_planes_vertex>\n\n\t#include <tile_vertex>\n\t#include <soft_vertex>\n}\n",s=hi),this.settings.renderMode===ti.VerticalBillBoard?e.VERTICAL="":this.settings.renderMode===ti.HorizontalBillBoard&&(e.HORIZONTAL="");let n=!1;this.settings.renderMode===ti.Mesh&&("MeshStandardMaterial"===this.settings.material.type?(this.material=new ui({}),this.material.copy(this.settings.material),this.material.uniforms=t,this.material.defines=e,n=!0):"MeshPhysicalMaterial"===this.settings.material.type&&(this.material=new mi({}),this.material.copy(this.settings.material),this.material.uniforms=t,this.material.defines=e,n=!0)),n||(this.material=new ge({uniforms:t,defines:e,vertexShader:i,fragmentShader:s,transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,blending:this.settings.material.blending,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha,side:this.settings.material.side,alphaTest:this.settings.material.alphaTest,depthTest:this.settings.material.depthTest,lights:r}))}else{if(this.settings.renderMode!==ti.StretchedBillBoard)throw new Error("render mode unavailable");t.speedFactor=new ye(1),this.material=new ge({uniforms:t,defines:e,vertexShader:"\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute float rotation;\nattribute vec3 size;\nattribute vec4 velocity;\n\nuniform float speedFactor;\n\nvoid main() {\n    float lengthFactor = velocity.w;\n    float avgSize = (size.x + size.y) * 0.5;\n#ifdef USE_SKEW\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    vec3 viewVelocity = normalMatrix * velocity.xyz;\n\n    vec3 scaledPos = vec3(position.xy * size.xy, position.z);\n    float vlength = length(viewVelocity);\n    vec3 projVelocity =  dot(scaledPos, viewVelocity) * viewVelocity / vlength;\n    mvPosition.xyz += scaledPos + projVelocity * (speedFactor / avgSize + lengthFactor / vlength);\n#else\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    vec3 viewVelocity = normalMatrix * velocity.xyz;\n    float vlength = length(viewVelocity); \n    mvPosition.xyz += position.y * normalize(cross(mvPosition.xyz, viewVelocity)) * avgSize; // switch the cross to  match unity implementation\n    mvPosition.xyz -= (position.x + 0.5) * viewVelocity * (1.0 + lengthFactor / vlength) * avgSize; // minus position.x to match unity implementation\n#endif\n\tvColor = color;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <tile_vertex>\n\t#include <soft_vertex>\n}\n",fragmentShader:hi,transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,blending:this.settings.material.blending,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha,side:this.settings.material.side,alphaTest:this.settings.material.alphaTest,depthTest:this.settings.material.depthTest})}this.material&&n&&(this.material.onBeforeRender=n)}update(){let t=0,e=0;const i=this.getVisibleSystems();for(const s of i)e+=s.particleNum;e>this.maxParticles&&this.expandBuffers(e);for(const s of i){s.emitter.updateMatrixWorld&&(s.emitter.updateWorldMatrix(!0,!1),s.emitter.updateMatrixWorld(!0));const e=s.particles,i=s.particleNum,n=this.quaternion2_,r=this.vector2_,a=this.vector3_;s.emitter.matrixWorld.decompose(r,n,a),this.rotationMat_.setFromMatrix4(s.emitter.matrixWorld);for(let o=0;o<i;o++,t++){const i=e[o];if(this.settings.renderMode===ti.Mesh){let e;if(s.worldSpace)e=i.rotation;else{let t;t=i.parentMatrix?this.quaternion3_.setFromRotationMatrix(i.parentMatrix):n,e=this.quaternion_,e.copy(t).multiply(i.rotation)}this.rotationBuffer.setXYZW(t,e.x,e.y,e.z,e.w)}else this.settings.renderMode!==ti.StretchedBillBoard&&this.settings.renderMode!==ti.VerticalBillBoard&&this.settings.renderMode!==ti.HorizontalBillBoard&&this.settings.renderMode!==ti.BillBoard||this.rotationBuffer.setX(t,i.rotation);let r;if(s.worldSpace?r=i.position:(r=this.vector_,i.parentMatrix?r.copy(i.position).applyMatrix4(i.parentMatrix):r.copy(i.position).applyMatrix4(s.emitter.matrixWorld)),this.offsetBuffer.setXYZ(t,r.x,r.y,r.z),this.colorBuffer.setXYZW(t,i.color.x,i.color.y,i.color.z,i.color.w),s.worldSpace||i.parentMatrix?this.sizeBuffer.setXYZ(t,i.size.x,i.size.y,i.size.z):this.sizeBuffer.setXYZ(t,i.size.x*Math.abs(a.x),i.size.y*Math.abs(a.y),i.size.z*Math.abs(a.z)),this.uvTileBuffer.setX(t,i.uvTile),this.settings.renderMode===ti.StretchedBillBoard&&this.velocityBuffer){let e=s.rendererEmitterSettings.speedFactor;0===e&&(e=.001);const n=s.rendererEmitterSettings.lengthFactor;let r;s.worldSpace?r=i.velocity:(r=this.vector_,i.parentMatrix?(this.rotationMat2_.setFromMatrix4(i.parentMatrix),r.copy(i.velocity).applyMatrix3(this.rotationMat2_)):r.copy(i.velocity).applyMatrix3(this.rotationMat_)),this.velocityBuffer.setXYZW(t,r.x*e,r.y*e,r.z*e,n)}}}this.geometry.instanceCount=t,t>0&&(this.offsetBuffer.clearUpdateRanges(),this.offsetBuffer.addUpdateRange(0,3*t),this.offsetBuffer.needsUpdate=!0,this.sizeBuffer.clearUpdateRanges(),this.sizeBuffer.addUpdateRange(0,3*t),this.sizeBuffer.needsUpdate=!0,this.colorBuffer.clearUpdateRanges(),this.colorBuffer.addUpdateRange(0,4*t),this.colorBuffer.needsUpdate=!0,this.uvTileBuffer.clearUpdateRanges(),this.uvTileBuffer.addUpdateRange(0,t),this.uvTileBuffer.needsUpdate=!0,this.settings.renderMode===ti.StretchedBillBoard&&this.velocityBuffer&&(this.velocityBuffer.clearUpdateRanges(),this.velocityBuffer.addUpdateRange(0,4*t),this.velocityBuffer.needsUpdate=!0),this.settings.renderMode===ti.Mesh?(this.rotationBuffer.clearUpdateRanges(),this.rotationBuffer.addUpdateRange(0,4*t),this.rotationBuffer.needsUpdate=!0):this.settings.renderMode!==ti.StretchedBillBoard&&this.settings.renderMode!==ti.HorizontalBillBoard&&this.settings.renderMode!==ti.VerticalBillBoard&&this.settings.renderMode!==ti.BillBoard||(this.rotationBuffer.clearUpdateRanges(),this.rotationBuffer.addUpdateRange(0,t),this.rotationBuffer.needsUpdate=!0))}dispose(){this.geometry.dispose()}}class fi extends ei{constructor(t){super(t),this.vector_=new c,this.vector2_=new c,this.vector3_=new c,this.quaternion_=new l,this.maxParticles=1e4,this.setupBuffers(),this.rebuildMaterial()}setupBuffers(){this.geometry&&this.geometry.dispose(),this.geometry=new ve,this.indexBuffer=new xe(new Uint32Array(6*this.maxParticles),1),this.indexBuffer.setUsage(pe),this.geometry.setIndex(this.indexBuffer),this.positionBuffer=new xe(new Float32Array(6*this.maxParticles),3),this.positionBuffer.setUsage(pe),this.geometry.setAttribute("position",this.positionBuffer),this.previousBuffer=new xe(new Float32Array(6*this.maxParticles),3),this.previousBuffer.setUsage(pe),this.geometry.setAttribute("previous",this.previousBuffer),this.nextBuffer=new xe(new Float32Array(6*this.maxParticles),3),this.nextBuffer.setUsage(pe),this.geometry.setAttribute("next",this.nextBuffer),this.widthBuffer=new xe(new Float32Array(2*this.maxParticles),1),this.widthBuffer.setUsage(pe),this.geometry.setAttribute("width",this.widthBuffer),this.sideBuffer=new xe(new Float32Array(2*this.maxParticles),1),this.sideBuffer.setUsage(pe),this.geometry.setAttribute("side",this.sideBuffer),this.uvBuffer=new xe(new Float32Array(4*this.maxParticles),2),this.uvBuffer.setUsage(pe),this.geometry.setAttribute("uv",this.uvBuffer),this.colorBuffer=new xe(new Float32Array(8*this.maxParticles),4),this.colorBuffer.setUsage(pe),this.geometry.setAttribute("color",this.colorBuffer)}expandBuffers(t){for(;t>=this.maxParticles;)this.maxParticles*=2;this.setupBuffers()}rebuildMaterial(){this.layers.mask=this.settings.layers.mask;const t={lineWidth:{value:1},map:{value:null},useMap:{value:0},alphaMap:{value:null},useAlphaMap:{value:0},resolution:{value:new b(1,1)},sizeAttenuation:{value:1},visibility:{value:1},alphaTest:{value:0}},e={USE_UV:"",USE_COLOR_ALPHA:""};if(this.settings.material.map&&(e.USE_MAP="",e.MAP_UV=di(this.settings.material.map.channel),t.map=new ye(this.settings.material.map),t.mapTransform=new ye((new A).copy(this.settings.material.map.matrix))),this.settings.material.defines&&void 0!==this.settings.material.defines.USE_COLOR_AS_ALPHA&&(e.USE_COLOR_AS_ALPHA=""),this.settings.renderMode!==ti.Trail)throw new Error("render mode unavailable");this.material=new ge({uniforms:t,defines:e,vertexShader:"\n#include <common>\n#include <tile_pars_vertex>\n#include <color_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <fog_pars_vertex>\n\nattribute vec3 previous;\nattribute vec3 next;\nattribute float side;\nattribute float width;\n\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform float sizeAttenuation;\n    \nvec2 fix(vec4 i, float aspect) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n    return res;\n}\n    \nvoid main() {\n\n    #include <tile_vertex>\n    \n    float aspect = resolution.x / resolution.y;\n\n    vColor = color;\n\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec4 finalPosition = m * vec4( position, 1.0 );\n    vec4 prevPos = m * vec4( previous, 1.0 );\n    vec4 nextPos = m * vec4( next, 1.0 );\n\n    vec2 currentP = fix( finalPosition, aspect );\n    vec2 prevP = fix( prevPos, aspect );\n    vec2 nextP = fix( nextPos, aspect );\n\n    float w = lineWidth * width;\n\n    vec2 dir;\n    if( nextP == currentP ) dir = normalize( currentP - prevP );\n    else if( prevP == currentP ) dir = normalize( nextP - currentP );\n    else {\n        vec2 dir1 = normalize( currentP - prevP );\n        vec2 dir2 = normalize( nextP - currentP );\n        dir = normalize( dir1 + dir2 );\n\n        vec2 perp = vec2( -dir1.y, dir1.x );\n        vec2 miter = vec2( -dir.y, dir.x );\n        //w = clamp( w / dot( miter, perp ), 0., 4., * lineWidth * width );\n\n    }\n\n    //vec2 normal = ( cross( vec3( dir, 0. ) vec3( 0., 0., 1. ) ) ).xy;\n    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );\n    normal.xy *= .5 * w;\n    normal *= projectionMatrix;\n    if( sizeAttenuation == 0. ) {\n        normal.xy *= finalPosition.w;\n        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;\n    }\n\n    finalPosition.xy += normal.xy * side;\n\n    gl_Position = finalPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    \n\t#include <fog_vertex>\n}",fragmentShader:"\n\n#include <common>\n#include <tile_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nuniform sampler2D alphaMap;\nuniform float useAlphaMap;\nuniform float visibility;\nuniform float alphaTest;\n\nvarying vec4 vColor;\n    \nvoid main() {\n    #include <clipping_planes_fragment>\n    #include <logdepthbuf_fragment>\n\n    vec4 diffuseColor = vColor;\n    \n    #ifdef USE_MAP\n    #include <tile_fragment>\n    #ifndef USE_COLOR_AS_ALPHA\n    #endif\n    #endif\n    if( useAlphaMap == 1. ) diffuseColor.a *= texture2D( alphaMap, vUv).a;\n    if( diffuseColor.a < alphaTest ) discard;\n    gl_FragColor = diffuseColor;\n\n    #include <fog_fragment>\n    #include <tonemapping_fragment>\n}",transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,side:this.settings.material.side,blending:this.settings.material.blending||ce,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha})}update(){let t=0,e=0,i=0;const s=this.getVisibleSystems();for(const n of s)for(let t=0;t<n.particleNum;t++)i+=2*n.particles[t].previous.length;i>this.maxParticles&&this.expandBuffers(i);for(const n of s){n.emitter.updateMatrixWorld&&(n.emitter.updateWorldMatrix(!0,!1),n.emitter.updateMatrixWorld(!0));const i=this.quaternion_,s=this.vector2_,r=this.vector3_;n.emitter.matrixWorld.decompose(s,i,r);const a=n.particles,o=n.particleNum,h=this.settings.uTileCount,l=this.settings.vTileCount,c=1/h,d=1/l;for(let u=0;u<o;u++){const i=a[u],s=i.uvTile%l,o=Math.floor(i.uvTile/l+.001),h=i.previous.values();let m,p=h.next(),f=p.value,y=f;p.done||(p=h.next()),m=void 0!==p.value?p.value:y;for(let a=0;a<i.previous.length;a++,t+=2){if(this.positionBuffer.setXYZ(t,y.position.x,y.position.y,y.position.z),this.positionBuffer.setXYZ(t+1,y.position.x,y.position.y,y.position.z),n.worldSpace?(this.positionBuffer.setXYZ(t,y.position.x,y.position.y,y.position.z),this.positionBuffer.setXYZ(t+1,y.position.x,y.position.y,y.position.z)):(i.parentMatrix?this.vector_.copy(y.position).applyMatrix4(i.parentMatrix):this.vector_.copy(y.position).applyMatrix4(n.emitter.matrixWorld),this.positionBuffer.setXYZ(t,this.vector_.x,this.vector_.y,this.vector_.z),this.positionBuffer.setXYZ(t+1,this.vector_.x,this.vector_.y,this.vector_.z)),n.worldSpace?(this.previousBuffer.setXYZ(t,f.position.x,f.position.y,f.position.z),this.previousBuffer.setXYZ(t+1,f.position.x,f.position.y,f.position.z)):(i.parentMatrix?this.vector_.copy(f.position).applyMatrix4(i.parentMatrix):this.vector_.copy(f.position).applyMatrix4(n.emitter.matrixWorld),this.previousBuffer.setXYZ(t,this.vector_.x,this.vector_.y,this.vector_.z),this.previousBuffer.setXYZ(t+1,this.vector_.x,this.vector_.y,this.vector_.z)),n.worldSpace?(this.nextBuffer.setXYZ(t,m.position.x,m.position.y,m.position.z),this.nextBuffer.setXYZ(t+1,m.position.x,m.position.y,m.position.z)):(i.parentMatrix?this.vector_.copy(m.position).applyMatrix4(i.parentMatrix):this.vector_.copy(m.position).applyMatrix4(n.emitter.matrixWorld),this.nextBuffer.setXYZ(t,this.vector_.x,this.vector_.y,this.vector_.z),this.nextBuffer.setXYZ(t+1,this.vector_.x,this.vector_.y,this.vector_.z)),this.sideBuffer.setX(t,1),this.sideBuffer.setX(t+1,-1),n.worldSpace)this.widthBuffer.setX(t,y.size),this.widthBuffer.setX(t+1,y.size);else if(i.parentMatrix)this.widthBuffer.setX(t,y.size),this.widthBuffer.setX(t+1,y.size);else{const e=(Math.abs(r.x)+Math.abs(r.y)+Math.abs(r.z))/3;this.widthBuffer.setX(t,y.size*e),this.widthBuffer.setX(t+1,y.size*e)}this.uvBuffer.setXY(t,(a/i.previous.length+s)*c,(l-o-1)*d),this.uvBuffer.setXY(t+1,(a/i.previous.length+s)*c,(l-o)*d),this.colorBuffer.setXYZW(t,y.color.x,y.color.y,y.color.z,y.color.w),this.colorBuffer.setXYZW(t+1,y.color.x,y.color.y,y.color.z,y.color.w),a+1<i.previous.length&&(this.indexBuffer.setX(3*e,t),this.indexBuffer.setX(3*e+1,t+1),this.indexBuffer.setX(3*e+2,t+2),e++,this.indexBuffer.setX(3*e,t+2),this.indexBuffer.setX(3*e+1,t+1),this.indexBuffer.setX(3*e+2,t+3),e++),f=y,y=m,p.done||(p=h.next(),void 0!==p.value&&(m=p.value))}}}this.positionBuffer.clearUpdateRanges(),this.positionBuffer.addUpdateRange(0,3*t),this.positionBuffer.needsUpdate=!0,this.previousBuffer.clearUpdateRanges(),this.previousBuffer.addUpdateRange(0,3*t),this.previousBuffer.needsUpdate=!0,this.nextBuffer.clearUpdateRanges(),this.nextBuffer.addUpdateRange(0,3*t),this.nextBuffer.needsUpdate=!0,this.sideBuffer.clearUpdateRanges(),this.sideBuffer.addUpdateRange(0,t),this.sideBuffer.needsUpdate=!0,this.widthBuffer.clearUpdateRanges(),this.widthBuffer.addUpdateRange(0,t),this.widthBuffer.needsUpdate=!0,this.uvBuffer.clearUpdateRanges(),this.uvBuffer.addUpdateRange(0,2*t),this.uvBuffer.needsUpdate=!0,this.colorBuffer.clearUpdateRanges(),this.colorBuffer.addUpdateRange(0,4*t),this.colorBuffer.needsUpdate=!0,this.indexBuffer.clearUpdateRanges(),this.indexBuffer.addUpdateRange(0,3*e),this.indexBuffer.needsUpdate=!0,this.geometry.setDrawRange(0,3*e)}dispose(){this.geometry.dispose()}}class yi extends ne{constructor(){super(),this.batches=[],this.systemToBatchIndex=new Map,this.type="BatchedRenderer",this.depthTexture=null}static equals(t,e){return t.material.side===e.material.side&&t.material.blending===e.material.blending&&t.material.blendSrc===e.material.blendSrc&&t.material.blendDst===e.material.blendDst&&t.material.blendEquation===e.material.blendEquation&&t.material.premultipliedAlpha===e.material.premultipliedAlpha&&t.material.transparent===e.material.transparent&&t.material.depthTest===e.material.depthTest&&t.material.type===e.material.type&&t.material.alphaTest===e.material.alphaTest&&t.material.map===e.material.map&&t.renderMode===e.renderMode&&t.blendTiles===e.blendTiles&&t.softParticles===e.softParticles&&t.softFarFade===e.softFarFade&&t.softNearFade===e.softNearFade&&t.uTileCount===e.uTileCount&&t.vTileCount===e.vTileCount&&t.instancingGeometry===e.instancingGeometry&&t.renderOrder===e.renderOrder&&t.layers.mask===e.layers.mask}addSystem(t){t._renderer=this;const e=t.getRendererSettings();for(let s=0;s<this.batches.length;s++)if(yi.equals(this.batches[s].settings,e))return this.batches[s].addSystem(t),void this.systemToBatchIndex.set(t,s);let i;switch(e.renderMode){case ti.Trail:i=new fi(e);break;case ti.Mesh:case ti.BillBoard:case ti.VerticalBillBoard:case ti.HorizontalBillBoard:case ti.StretchedBillBoard:i=new pi(e)}this.depthTexture&&i.applyDepthTexture(this.depthTexture),i.addSystem(t),this.batches.push(i),this.systemToBatchIndex.set(t,this.batches.length-1),this.add(i)}deleteSystem(t){const e=this.systemToBatchIndex.get(t);null!=e&&(this.batches[e].removeSystem(t),this.systemToBatchIndex.delete(t))}setDepthTexture(t){this.depthTexture=t;for(const e of this.batches)e.applyDepthTexture(t)}updateSystem(t){this.deleteSystem(t),this.addSystem(t)}update(t){this.systemToBatchIndex.forEach((e,i)=>{i.update(t)});for(let e=0;e<this.batches.length;e++)this.batches[e].update()}}class gi extends Se{constructor(){super(),this.type="QuarksPrefab",this.animationData=[],this.isPlaying=!1,this.currentTime=-1e-5,this.timeScale=1,this.duration=0,this._mixers=new Map,this._tempAnimationJSON=[],this._clock=new Me(!0)}registerBatchedRenderer(t){this._batchedRenderer=t}getOrCreateMixer(t){if(!this._mixers.has(t)){const e=new _e(t);this._mixers.set(t,e)}return this._mixers.get(t)}addThreeAnimation(t,e,i=0,s=e.duration,n=!1){const r=this.getOrCreateMixer(t),a=r.clipAction(e);n||(a.setLoop(we,1),a.clampWhenFinished=!0);const o={startTime:i,duration:s,type:"three",loop:n,target:t,clip:e,mixer:r,action:a};return this.animationData.push(o),this.updateDuration(),o}addParticleSystemAnimation(t,e=0,i=0,s=!1){i<=0&&(i=t.system.duration);const n={startTime:e,duration:i,type:"ps",loop:s,target:t};return this.animationData.push(n),this.pause(),this.updateDuration(),n}removeAnimation(t){this.animationData.splice(t,1),this.updateDuration()}play(){this.isPlaying||(this.isPlaying=!0)}pause(){this.isPlaying&&(this.isPlaying=!1,this.animationData.forEach(t=>{t.target&&("ps"!==t.type||t.target.system.paused?"three"===t.type&&t.action&&t.action.isRunning()&&(t.action.paused=!0):t.target.system.pause())}))}stop(){this.pause(),this.currentTime=-1e-5,this.animationData.forEach(t=>{"ps"===t.type&&t.target?t.target.system.stop():"three"===t.type&&t.mixer&&t.action&&t.action.reset()})}update(t){if(!this.isPlaying)return;const e=void 0!==t?t:this._clock.getDelta();this.currentTime+=e*this.timeScale,this.currentTime>this.duration&&this.stop();const i=new Set;this.animationData.forEach(t=>{const{startTime:s,duration:n,type:r,loop:a,target:o,action:h,mixer:l}=t,c=s+n,d=this.currentTime>=s,u=this.currentTime>c,m=Math.abs(this.currentTime-s)<e;"three"===r&&h&&l?d&&!u?(m?(h.reset(),h.play()):h.paused&&(h.paused=!1,h.play()),this.currentTime,i.add(l)):u&&(h.paused=!0):"ps"===r&&o&&(d&&!u?m&&t.target.system.restart():u&&t.target.system.endEmit())}),i.forEach(t=>{t.update(e)})}setTime(t){const e=this.currentTime;this.currentTime=t,this.animationData.forEach(i=>{const{startTime:s,duration:n,type:r,target:a,action:o,mixer:h}=i;if("three"===r&&o&&h){if(o.reset(),t>=s&&t<s+n){const e=t-s;o.time=e,o.play(),h.update(0),o.paused=!this.isPlaying}}else"ps"===r&&a&&(t>=s&&t<s+n?(e<s||e>=s+n)&&a.system.restart():a.system.endEmit())})}getDuration(){return this.duration}updateDuration(){let t=0;this.animationData.forEach(e=>{const i=e.startTime+e.duration;i>t&&(t=i)}),this.duration=t}resolveReferences(t){this._tempAnimationJSON.forEach(e=>{let i;if(t.traverse(t=>{t.uuid===e.targetUUID&&(i=t)}),i)if("three"===e.type&&e.clipUUID){let t;i.animations&&(t=i.animations.find(t=>t.uuid===e.clipUUID)),t&&this.addThreeAnimation(i,t,e.startTime,e.duration,e.loop)}else"ps"===e.type&&this.addParticleSystemAnimation(i,e.startTime,e.duration,e.loop)}),this.updateDuration(),this._tempAnimationJSON=[]}toJSON(){const t=super.toJSON();return t.object.animationData=this.animationData.map(t=>({startTime:t.startTime,duration:t.duration,type:t.type,targetUUID:t.target.uuid,clipUUID:t.clip?.uuid,loop:t.loop})),t}static fromJSON(t){const e=new gi;return t.animationData&&(e._tempAnimationJSON=t.animationData),e}}class vi extends ze{constructor(t){super(t)}linkReference(t){const e={};t.traverse(function(t){e[t.uuid]=t}),t.traverse(function(t){if("ParticleEmitter"===t.type){const i=t.system;i.emitterShape;for(let t=0;t<i.behaviors.length;t++)i.behaviors[t]instanceof Bt&&(i.behaviors[t].subParticleSystem=e[i.behaviors[t].subParticleSystem])}})}parse(t,e){const i=super.parse(t,e);return this.linkReference(i),i}parseObject(t,e,i,s,n){let r,a,o;function h(t){return void 0===e[t]&&console.warn("THREE.ObjectLoader: Undefined geometry",t),e[t]}function l(t){if(void 0!==t){if(Array.isArray(t)){const e=[];for(let s=0,n=t.length;s<n;s++){const n=t[s];void 0===i[n]&&console.warn("THREE.ObjectLoader: Undefined material",n),e.push(i[n])}return e}return void 0===i[t]&&console.warn("THREE.ObjectLoader: Undefined material",t),i[t]}}function c(t){return void 0===s[t]&&console.warn("THREE.ObjectLoader: Undefined texture",t),s[t]}const d={textures:s,geometries:e,materials:i},u={};switch(t.type){case"QuarksPrefab":r=gi.fromJSON(t);break;case"ParticleEmitter":r=oi.fromJSON(t.ps,d,u).emitter;break;case"Scene":r=new Ye,void 0!==t.background&&(Number.isInteger(t.background)?r.background=new He(t.background):r.background=c(t.background)),void 0!==t.environment&&(r.environment=c(t.environment)),void 0!==t.fog&&("Fog"===t.fog.type?r.fog=new Ze(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(r.fog=new je(t.fog.color,t.fog.density)),""!==t.fog.name&&(r.fog.name=t.fog.name)),void 0!==t.backgroundBlurriness&&(r.backgroundBlurriness=t.backgroundBlurriness),void 0!==t.backgroundIntensity&&(r.backgroundIntensity=t.backgroundIntensity),void 0!==t.backgroundRotation&&r.backgroundRotation.fromArray(t.backgroundRotation),void 0!==t.environmentIntensity&&(r.environmentIntensity=t.environmentIntensity),void 0!==t.environmentRotation&&r.environmentRotation.fromArray(t.environmentRotation);break;case"PerspectiveCamera":r=new Xe(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(r.focus=t.focus),void 0!==t.zoom&&(r.zoom=t.zoom),void 0!==t.filmGauge&&(r.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(r.filmOffset=t.filmOffset),void 0!==t.view&&(r.view=Object.assign({},t.view));break;case"OrthographicCamera":r=new qe(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(r.zoom=t.zoom),void 0!==t.view&&(r.view=Object.assign({},t.view));break;case"AmbientLight":r=new Ge(t.color,t.intensity);break;case"DirectionalLight":r=new De(t.color,t.intensity);break;case"PointLight":r=new Je(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":r=new Ie(t.color,t.intensity,t.width,t.height);break;case"SpotLight":r=new Ve(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);break;case"HemisphereLight":r=new Le(t.color,t.groundColor,t.intensity);break;case"LightProbe":r=(new Fe).fromJSON(t);break;case"SkinnedMesh":a=h(t.geometry),o=l(t.material),r=new ke(a,o),void 0!==t.bindMode&&(r.bindMode=t.bindMode),void 0!==t.bindMatrix&&r.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(r.skeleton=t.skeleton);break;case"Mesh":a=h(t.geometry),o=l(t.material),r=new re(a,o);break;case"InstancedMesh":{a=h(t.geometry),o=l(t.material);const e=t.count,i=t.instanceMatrix,s=t.instanceColor;r=new Re(a,o,e),r.instanceMatrix=new me(new Float32Array(i.array),16),void 0!==s&&(r.instanceColor=new me(new Float32Array(s.array),s.itemSize));break}case"BatchedMesh":a=h(t.geometry),o=l(t.material),r=new Ue(t.maxGeometryCount,t.maxVertexCount,t.maxIndexCount,o),r.geometry=a,r.perObjectFrustumCulled=t.perObjectFrustumCulled,r.sortObjects=t.sortObjects,r._drawRanges=t.drawRanges,r._reservedRanges=t.reservedRanges,r._visibility=t.visibility,r._active=t.active,r._bounds=t.bounds.map(t=>{const e=new Ce;e.min.fromArray(t.boxMin),e.max.fromArray(t.boxMax);const i=new Be;return i.radius=t.sphereRadius,i.center.fromArray(t.sphereCenter),{boxInitialized:t.boxInitialized,box:e,sphereInitialized:t.sphereInitialized,sphere:i}}),r._maxGeometryCount=t.maxGeometryCount,r._maxVertexCount=t.maxVertexCount,r._maxIndexCount=t.maxIndexCount,r._geometryInitialized=t.geometryInitialized,r._geometryCount=t.geometryCount,r._matricesTexture=c(t.matricesTexture.uuid);break;case"LOD":r=new Pe;break;case"Line":r=new Ee(h(t.geometry),l(t.material));break;case"LineLoop":r=new Ne(h(t.geometry),l(t.material));break;case"LineSegments":r=new Te(h(t.geometry),l(t.material));break;case"PointCloud":case"Points":r=new Ae(h(t.geometry),l(t.material));break;case"Sprite":r=new Oe(l(t.material));break;case"Group":r=new Se;break;case"Bone":r=new be;break;default:r=new ne}if(r.uuid=t.uuid,void 0!==t.name&&(r.name=t.name),void 0!==t.matrix?(r.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(r.matrixAutoUpdate=t.matrixAutoUpdate),r.matrixAutoUpdate&&(r.matrix.decompose(r.position,r.quaternion,r.scale),isNaN(r.quaternion.x)&&r.quaternion.set(0,0,0,1))):(void 0!==t.position&&r.position.fromArray(t.position),void 0!==t.rotation&&r.rotation.fromArray(t.rotation),void 0!==t.quaternion&&r.quaternion.fromArray(t.quaternion),void 0!==t.scale&&r.scale.fromArray(t.scale)),void 0!==t.up&&r.up.fromArray(t.up),void 0!==t.castShadow&&(r.castShadow=t.castShadow),void 0!==t.receiveShadow&&(r.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.bias&&(r.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(r.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(r.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&r.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(r.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(r.visible=t.visible),void 0!==t.frustumCulled&&(r.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(r.renderOrder=t.renderOrder),void 0!==t.userData&&(r.userData=t.userData),void 0!==t.layers&&(r.layers.mask=t.layers),void 0!==t.children){const a=t.children;for(let t=0;t<a.length;t++)r.add(this.parseObject(a[t],e,i,s,n))}if(void 0!==t.animations){const e=t.animations;for(let t=0;t<e.length;t++){const i=e[t];r.animations.push(n[i])}}if("LOD"===t.type){void 0!==t.autoUpdate&&(r.autoUpdate=t.autoUpdate);const e=t.levels;for(let t=0;t<e.length;t++){const i=e[t],s=r.getObjectByProperty("uuid",i.object);void 0!==s&&r.addLevel(s,i.distance)}}else"QuarksPrefab"===t.type&&r.resolveReferences(r);return r}}Ke.tile_pars_vertex="\n#ifdef UV_TILE\n    attribute float uvTile;\n    uniform vec2 tileCount;\n    \n    mat3 makeTileTransform(float uvTile) {\n        float col = mod(uvTile, tileCount.x);\n        float row = (tileCount.y - floor(uvTile / tileCount.x) - 1.0);\n        \n        return mat3(\n          1.0 / tileCount.x, 0.0, 0.0,\n          0.0, 1.0 / tileCount.y, 0.0, \n          col / tileCount.x, row / tileCount.y, 1.0);\n    }\n#else\n    mat3 makeTileTransform(float uvTile) {\n        return mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    }\n#endif\n\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\n\tvarying vec2 vUv;\n#ifdef TILE_BLEND\n    varying vec2 vUvNext;\n    varying float vUvBlend;\n#endif\n\n#endif\n#ifdef USE_MAP\n\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#ifdef TILE_BLEND\n    varying vec2 vMapUvNext;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n\n#endif\n#ifdef USE_AOMAP\n\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n\n#endif\n#ifdef USE_BUMPMAP\n\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n\n#endif\n#ifdef USE_NORMALMAP\n\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n\n#endif\n#ifdef USE_METALNESSMAP\n\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n\n#endif\n#ifdef USE_SPECULARMAP\n\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n\n#endif\n",Ke.tile_vertex="\n#ifdef UV_TILE\n    mat3 tileTransform = makeTileTransform(floor(uvTile));\n    #ifdef TILE_BLEND\n        mat3 nextTileTransform = makeTileTransform(ceil(uvTile));\n        vUvBlend = fract(uvTile);\n    #endif\n#else\n    mat3 tileTransform = makeTileTransform(0.0);\n#endif\n\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\nvUv = (tileTransform *vec3( uv, 1 )).xy;\n#if defined( TILE_BLEND ) && defined( UV_TILE )\n    vUvNext = (nextTileTransform *vec3( uv, 1 )).xy;\n#endif\n\n#endif\n#ifdef USE_MAP\n\nvMapUv = ( tileTransform * (mapTransform * vec3( MAP_UV, 1 ) )).xy;\n#if defined( TILE_BLEND ) && defined( UV_TILE )\n    vMapUvNext = (nextTileTransform * (mapTransform * vec3( MAP_UV, 1 ))).xy;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\nvAlphaMapUv = ( tileTransform * (alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) )).xy;\n    \n#endif\n#ifdef USE_LIGHTMAP\n\nvLightMapUv = ( tileTransform * (lightMapTransform * vec3( LIGHTMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_AOMAP\n\nvAoMapUv = ( tileTransform * (aoMapTransform * vec3( AOMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_BUMPMAP\n\nvBumpMapUv = ( tileTransform * (bumpMapTransform * vec3( BUMPMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_NORMALMAP\n\nvNormalMapUv = ( tileTransform * (normalMapTransform * vec3( NORMALMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\nvDisplacementMapUv = ( tileTransform * (displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\nvEmissiveMapUv = ( tileTransform * (emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_METALNESSMAP\n\nvMetalnessMapUv = ( tileTransform * (metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\nvRoughnessMapUv = ( tileTransform * (roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\nvAnisotropyMapUv = ( tileTransform * (anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\nvClearcoatMapUv = ( tileTransform * (clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\nvClearcoatNormalMapUv = ( tileTransform * (clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\nvClearcoatRoughnessMapUv = ( tileTransform * (clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\nvIridescenceMapUv = ( tileTransform * (iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\nvIridescenceThicknessMapUv = ( tileTransform * (iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\nvSheenColorMapUv = ( tileTransform * (sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\nvSheenRoughnessMapUv = ( tileTransform * (sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULARMAP\n\nvSpecularMapUv = ( tileTransform * (specularMapTransform * vec3( SPECULARMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\nvSpecularColorMapUv = ( tileTransform * (specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\nvSpecularIntensityMapUv = ( tileTransform * (specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\nvTransmissionMapUv = ( tileTransform * transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\nvThicknessMapUv = ( tileTransform * thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) )).xy;\n\n#endif\n\n",Ke.tile_pars_fragment="\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\n\tvarying vec2 vUv;\n#ifdef TILE_BLEND\n    varying vec2 vUvNext;\n    varying float vUvBlend;\n#endif\n\n#endif\n#ifdef USE_MAP\n\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#ifdef TILE_BLEND\n    varying vec2 vMapUvNext;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n\n#endif\n#ifdef USE_AOMAP\n\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n\n#endif\n#ifdef USE_BUMPMAP\n\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n\n#endif\n#ifdef USE_NORMALMAP\n\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n\n#endif\n#ifdef USE_METALNESSMAP\n\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n\n#endif\n#ifdef USE_SPECULARMAP\n\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n\n#endif\n",Ke.tile_fragment="\n#ifdef USE_MAP\n    vec4 texelColor = texture2D( map, vUv);\n    #ifdef TILE_BLEND\n        texelColor = mix( texelColor, texture2D( map, vUvNext ), vUvBlend );\n    #endif\n    diffuseColor *= texelColor;\n#endif\n",Ke.soft_pars_vertex="\n#ifdef SOFT_PARTICLES\n    varying vec4 projPosition;\n    varying float linearDepth;\n#endif\n",Ke.soft_vertex="\n#ifdef SOFT_PARTICLES\n    projPosition = gl_Position;\n    linearDepth = -mvPosition.z;\n#endif\n",Ke.soft_pars_fragment="\n#ifdef SOFT_PARTICLES\n\n    uniform sampler2D depthTexture;\n    uniform vec4 projParams;\n    uniform vec2 softParams;\n\n    varying vec4 projPosition;\n    varying float linearDepth;\n\n    #define SOFT_NEAR_FADE softParams.x\n    #define SOFT_INV_FADE_DISTANCE softParams.y\n\n    #define zNear projParams.x\n    #define zFar projParams.y\n\n    float linearize_depth(float d)\n    {\n        return (zFar * zNear) / (zFar - d * (zFar - zNear));\n    }\n\n#endif\n",Ke.soft_fragment="\n#ifdef SOFT_PARTICLES\n\n    /* #ifdef LOGDEPTH\n    float distSample = linearize_depth_log(sampleDepth, near, far);\n    #else\n    float distSample = ortho ? linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far);\n    #endif */\n\n    vec2 p2 = projPosition.xy / projPosition.w;\n    \n    p2 = 0.5 * p2 + 0.5;\n\n    float readDepth = texture2D(depthTexture, p2.xy).r;\n    float viewDepth = linearize_depth(readDepth);\n\n    float softParticlesFade = saturate(SOFT_INV_FADE_DISTANCE * ((viewDepth - SOFT_NEAR_FADE) - linearDepth));\n    \n    gl_FragColor *= softParticlesFade;\n\n    //gl_FragColor = vec4(softParticlesFade , 0, 0, 1);\n#endif\n",function(t){if(!te.find(e=>e.id===t.id)){for(const e of t.emitterShapes)ft[e.type]||(ft[e.type]=e);for(const e of t.behaviors)$t[e.type]||($t[e.type]=e)}}(Qe),console.log("%c Particle system powered by three.quarks. https://quarks.art/","font-size: 14px; font-weight: bold;");export{yi as BatchedRenderer,P as Bezier,yt as ColorOverLife,F as ColorRange,it as ConeEmitter,G as ConstantColor,X as ConstantValue,xt as ForceOverLife,_t as FrameOverLife,mt as GridEmitter,Y as IntervalValue,Zt as Noise,oi as ParticleSystem,Z as PiecewiseBezier,vi as QuarksLoader,ti as RenderMode,St as SizeOverLife,O as Vector4};
