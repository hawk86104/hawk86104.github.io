import{a1 as _,l as i,aA as b,ap as M,az as c,w as y,a6 as w,o as P,c as R,Y as d,aa as T,ab as F,a9 as A,bl as C,ck as k,b3 as x}from"./vendor.-IAgWGvB1715174954944.js";const B=["position"],W=["args"],L=_({__name:"radraA",props:{position:{default:[0,0,0]},size:{default:300},radius:{default:240},color:{default:"#ffff00"},opacity:{default:.9},speed:{default:300},followWidth:{default:220}},setup(f,{expose:v}){const e=f,{onLoop:t}=A(),l={value:0},r=i();t(({delta:a})=>{l.value+=a});const n={transparent:!0,blending:b,depthWrite:!1,side:M,depthTest:!0,vertexShader:"\n	varying vec3 vPosition;\n	void main() {\n		vPosition = position;\n		vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n		vec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectionPosition = projectionMatrix * viewPosition;\n    gl_Position = projectionPosition;\n  }\n  ",fragmentShader:"\n	uniform float uRadius;     \n  uniform float uTime;            \n  uniform float uSpeed; \n  uniform float uFollowWidth; \n  varying vec3 vPosition;\n	uniform vec3 ncolor;\n  float calcAngle(vec3 oFrag){\n    float fragAngle;\n    const vec3 ox = vec3(1,0,0);\n    float dianji = oFrag.x * ox.x + oFrag.z*ox.z;\n    float oFrag_length = length(oFrag); // length是内置函数\n    float ox_length = length(ox); // length是内置函数\n    float yuxian = dianji / (oFrag_length * ox_length);\n    fragAngle = acos(yuxian);\n    fragAngle = degrees(fragAngle);\n    if(oFrag.z > 0.0) {\n      fragAngle = -fragAngle + 360.0;\n    }\n    float scanAngle = uTime * uSpeed - floor(uTime * uSpeed / 360.0) * 360.0;\n    float angle = scanAngle - fragAngle;\n    if(angle < 0.0){\n      angle = angle + 360.0;\n    }\n    return angle;\n  }\n  void main() {\n			// length内置函数，取向量的长度\n		if(length(vPosition) == 0.0 || length(vPosition) > uRadius-2.0){\n			gl_FragColor = vec4( ncolor, 1.0 );\n		} else {\n			float angle = calcAngle(vPosition);\n			if(angle < uFollowWidth){\n				// 尾焰区域\n				float opacity =  1.0 - angle / uFollowWidth; \n				gl_FragColor = vec4( ncolor, 1.0 * opacity );  \n			} else {\n				// 其他位置的像素均为透明\n				gl_FragColor = vec4( ncolor, 0.0 ); \n			}\n		}\n	}\n  ",uniforms:{uSpeed:{value:e.speed},uRadius:{value:e.radius},uTime:l,uFollowWidth:{value:e.followWidth},ncolor:{value:new c(e.color)}}};y(r,(a,s)=>{if(a&&s===void 0){const g=new C().makeRotationX(-Math.PI/180*90);r.value.applyMatrix4(g)}});const o=i();return w(()=>{e.color&&(n.uniforms.ncolor.value=new c(e.color)),e.radius&&(n.uniforms.uRadius.value=e.radius)}),i(-Math.PI/180*90),v({MeshRef:o}),(a,s)=>(P(),R("TresMesh",{ref_key:"MeshRef",ref:o,position:e.position},[d("TresCircleGeometry",{ref_key:"TresCircleGeometryRef",ref:r,args:[e.size,1e3]},null,8,W),d("TresShaderMaterial",T(F(n)),null,16)],8,B))}}),z=["position"],j=["args"],V=_({__name:"radraB",props:{position:{default:[0,0,0]},radius:{default:10},maxRadius:{default:200},color:{default:"#ffff00"},opacity:{default:.5},period:{default:2},height:{default:100}},setup(f,{expose:v}){const e=f,t=i(),l=i(1),r=i(.1),n={color:e.color,opacity:e.opacity,transparent:!0,depthWrite:!1,depthTest:!0,side:M,vertexShader:"\n	varying vec4 vPosition;\n  void main() {\n    vPosition = modelMatrix * vec4(position,1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n  ",fragmentShader:"\n	uniform vec3 uColor; // 光墙半径        \n  uniform vec3 uMax; \n  uniform vec3 uMin;\n  uniform mat4 modelMatrix; // 世界矩阵\n  varying vec4 vPosition; // 接收顶点着色传递进来的位置数据\n  void main() {\n    // 转世界坐标\n    vec4 uMax_world = modelMatrix * vec4(uMax,1.0);\n    vec4 uMin_world = modelMatrix * vec4(uMin,1.0);\n    // 根据像素点世界坐标的y轴高度,设置透明度\n    float opacity =1.0 - (vPosition.y - uMin_world.y) / (uMax_world.y -uMin_world.y) ; \n    gl_FragColor = vec4( uColor, opacity);\n  }\n  ",uniforms:{uMax:l,uMin:r,uColor:{value:new c(e.color)}}},o=i();let a=null;y(o,(u,p)=>{u&&p===void 0&&(o.value.computeBoundingBox(),l.value=o.value.boundingBox.max,r.value=o.value.boundingBox.min,a=t.value.scale.clone())});const s=i(new k(new x(0,0,0),new x(0,e.height,0)));w(()=>{e.color&&(n.uniforms.uColor.value=new c(e.color))});const{onLoop:g}=A(),m={value:0};return g(({delta:u})=>{m.value+=u;const h=(m.value%e.period/e.period*(e.maxRadius-e.radius)+e.radius)/e.radius,S=new C().makeScale(h,1,h);a&&(t.value.scale.copy(a.clone().applyMatrix4(S)),t.value.updateMatrix())}),v({MeshRef:t}),(u,p)=>(P(),R("TresMesh",{ref_key:"MeshRef",ref:t,position:e.position,renderOrder:2e3},[d("TresTubeGeometry",{ref_key:"TresTubeGeometryRef",ref:o,args:[s.value,20,e.radius,100,!1]},null,8,j),d("TresShaderMaterial",T(F(n)),null,16)],8,z))}});export{L as _,V as a};
