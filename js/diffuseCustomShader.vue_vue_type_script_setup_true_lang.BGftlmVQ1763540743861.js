import{B as e}from"./three-custom-shader-material.C6taB_aY1763540743861.js";import{_ as i}from"./@tresjs.BCHtwiaC1763540743861.js";import{d as o,w as n,H as r,o as t,u as a}from"./@vue.Co_gxueH1763540743861.js";import{l as s}from"./three.rXKzP9fQ1763540743861.js";const u=["object"],l=o({__name:"diffuseCustomShader",props:{baseMaterial:{},isCircularDiffusion:{type:Boolean,default:!0},speed:{default:.3},color:{default:"#8e9b9e"},width:{default:1}},setup(o){const l=o,f={baseMaterial:l.baseMaterial,fragmentShader:"\n   \tuniform float uTime;\n    uniform float uWidth;\n    uniform vec3 uColor;\n    uniform bool uCircularDiffusion;\n    varying vec3 vPosition;\n\n    void main() {\n      vec3 ogLight = csm_DiffuseColor.rgb;\n\n      // 扩散圆的半径随着时间增加而增大\n      float r = uTime * 0.1; // 控制扩散速度\n      float w = uWidth; // 扩散圆的宽度\n\n      vec2 center = vec2(0.0, 0.0);\n\n      float rDistance = uCircularDiffusion ? distance(vPosition.xy, center) : distance(vPosition.xz, center);\n      \n      float innerEdge = r;\n      float outerEdge = r + w;\n      \n      if(rDistance > innerEdge && rDistance < outerEdge) {\n          float per = (rDistance - innerEdge) / w;\n          ogLight = mix(ogLight, uColor, per);\n          float alphaV = mix(0.0, csm_DiffuseColor.a, per);\n          csm_FragColor = vec4(ogLight, alphaV);\n      } else if(rDistance >= outerEdge && rDistance < outerEdge + w) {\n          float per = (rDistance - outerEdge) / w;\n          ogLight = mix(uColor, ogLight, per);\n          float alphaV = mix(csm_DiffuseColor.a, 0.0, per);\n          csm_FragColor = vec4(ogLight, alphaV);\n      } else {\n          csm_FragColor = vec4(ogLight, 0.0);\n      }\n    }\n  ",vertexShader:"\n   \tvarying vec3 vPosition;\n    void main() {\n      vPosition = position;\n\t\t\tcsm_Position = position * vec3(1.0);\n    }\n  ",uniforms:{uTime:{value:0},uWidth:{value:l.width},uColor:{value:new s(l.color)},uCircularDiffusion:{value:l.isCircularDiffusion}}},c=new e(f),{onBeforeRender:m}=i();return m(({delta:e})=>{c.uniforms.uTime.value+=e*l.speed*100,c.uniforms.uTime.value>100&&(c.uniforms.uTime.value=0)}),n(()=>[l.isCircularDiffusion,l.color,l.width],([e,i,o])=>{c.uniforms.uCircularDiffusion.value=e,c.uniforms.uColor.value.set(i),c.uniforms.uWidth.value=o}),(e,i)=>(t(),r("primitive",{object:a(c)},null,8,u))}});export{l as _};
