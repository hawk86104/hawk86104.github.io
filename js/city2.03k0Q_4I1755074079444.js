import{e,k as n,a as i}from"./@tresjs.B1VqNfqw1755074079444.js";import{n as o,ae as a,C as r,p as l,bL as s,aa as t,a3 as m,au as c,az as d,cC as u,cD as f,cE as v}from"./three.QlBabAUP1755074079444.js";import{z as g}from"./three-custom-shader-material.BkclajdY1755074079444.js";import{r as p,i as h,s as _}from"./utils.Q4chzsad1755074079444.js";import{b as y,a as x}from"./buildingsCustomShaderMaterial.DyBo--wu1755074079444.js";import{d as b,aa as w,b as S,G as j,o as C,e as O,j as k,a5 as B,f as z,I as M,u as T,F as P,h as U}from"./@vue.BzMISRrV1755074079444.js";import{_ as N}from"./roadLight.vue_vue_type_script_setup_true_lang.HnoVUtJO1755074079444.js";import"./postprocessing.D49g_X_Q1755074079444.js";import"./@vueuse.C47q1p2Z1755074079444.js";import"./@fesjs.DpbLChem1755074079444.js";import"./vue-router.JcHWg-wh1755074079444.js";import"./lodash-es.C7pWAXPe1755074079444.js";import"./pinia.PwbQelYZ1755074079444.js";import"./@qlin.q6OWdsQV1755074079444.js";import"./@babel.BPq7uOAK1755074079444.js";import"./@floating-ui.BFjFSAYt1755074079444.js";import"./@juggle.CcBCnTIR1755074079444.js";import"./three-mesh-bvh.C-Cei7hn1755074079444.js";class W extends o{constructor(e={}){super(),this.vertexShader="\n      #define STANDARD\n      varying vec3 vViewPosition;\n      #ifdef USE_TRANSMISSION\n      varying vec3 vWorldPosition;\n      #endif\n    \n      varying vec2 vUv;\n      varying vec4 vPos;\n      varying vec3 vNormalW;\n      varying vec3 vPositionW;\n\n      #include <common>\n      #include <uv_pars_vertex>\n      #include <envmap_pars_vertex>\n      #include <color_pars_vertex>\n      #include <fog_pars_vertex>\n      #include <morphtarget_pars_vertex>\n      #include <skinning_pars_vertex>\n      #include <logdepthbuf_pars_vertex>\n      #include <clipping_planes_pars_vertex>\n\n      void main() {\n        \n        #include <uv_vertex>\n        #include <color_vertex>\n        #include <morphcolor_vertex>\n      \n        #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n      \n          #include <beginnormal_vertex>\n          #include <morphnormal_vertex>\n          #include <skinbase_vertex>\n          #include <skinnormal_vertex>\n          #include <defaultnormal_vertex>\n      \n        #endif\n      \n        #include <begin_vertex>\n        #include <morphtarget_vertex>\n        #include <skinning_vertex>\n        #include <project_vertex>\n        #include <logdepthbuf_vertex>\n        #include <clipping_planes_vertex>\n      \n        #include <worldpos_vertex>\n        #include <envmap_vertex>\n        #include <fog_vertex>\n\n        mat4 modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;\n\n        vUv = uv;\n        vPos = projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 );\n        vPositionW = vec3( vec4( transformed, 1.0 ) * modelMatrix);\n        vNormalW = normalize( vec3( vec4( normal, 0.0 ) * modelMatrix ) );\n        \n        gl_Position = modelViewProjectionMatrix * vec4( transformed, 1.0 );\n\n      }",this.fragmentShader=" \n      varying vec2 vUv;\n      varying vec3 vPositionW;\n      varying vec4 vPos;\n      varying vec3 vNormalW;\n      \n      uniform float time;\n      uniform float fresnelOpacity;\n      uniform float scanlineSize;\n      uniform float fresnelAmount;\n      uniform float signalSpeed;\n      uniform float hologramBrightness;\n      uniform float hologramOpacity;\n      uniform bool blinkFresnelOnly;\n      uniform bool enableBlinking;\n      uniform vec3 hologramColor;\n\n      float flicker( float amt, float time ) {return clamp( fract( cos( time ) * 43758.5453123 ), amt, 1.0 );}\n      float random(in float a, in float b) { return fract((cos(dot(vec2(a,b) ,vec2(12.9898,78.233))) * 43758.5453)); }\n\n      void main() {\n        vec2 vCoords = vPos.xy;\n        vCoords /= vPos.w;\n        vCoords = vCoords * 0.5 + 0.5;\n        vec2 myUV = fract( vCoords );\n\n        // Defines hologram main color\n        vec4 hologramColor = vec4(hologramColor, mix(hologramBrightness, vUv.y, 0.5));\n\n        // Add scanlines\n        float scanlines = 10.;\n        scanlines += 20. * sin(time *signalSpeed * 20.8 - myUV.y * 60. * scanlineSize);\n        scanlines *= smoothstep(1.3 * cos(time *signalSpeed + myUV.y * scanlineSize), 0.78, 0.9);\n        scanlines *= max(0.25, sin(time *signalSpeed) * 1.0);        \n        \n        // Scanlines offsets\n        float r = random(vUv.x, vUv.y);\n        float g = random(vUv.y * 20.2, \tvUv.y * .2);\n        float b = random(vUv.y * .9, \tvUv.y * .2);\n\n        // Scanline composition\n        hologramColor += vec4(r*scanlines, b*scanlines, r, 1.0) / 84.;\n        vec4 scanlineMix = mix(vec4(0.0), hologramColor, hologramColor.a);\n\n        // Calculates fresnel\n        vec3 viewDirectionW = normalize(cameraPosition - vPositionW);\n        float fresnelEffect = dot(viewDirectionW, vNormalW) * (1.6 - fresnelOpacity/2.);\n        fresnelEffect = clamp(fresnelAmount - fresnelEffect, 0., fresnelOpacity);\n\n        // Blinkin effect\n        //Suggested by Octano - https://x.com/OtanoDesign?s=20\n        float blinkValue = enableBlinking ? 0.6 - signalSpeed : 1.0;\n        float blink = flicker(blinkValue, time * signalSpeed * .02);\n    \n        // Final shader composition\n        vec3 finalColor;\n\n        if(blinkFresnelOnly){\n          // finalColor = vec3(1.0,1.0,0);\n          finalColor = scanlineMix.rgb + fresnelEffect * blink;\n        }else{\n          finalColor = scanlineMix.rgb * blink + fresnelEffect;\n        }\n\n        gl_FragColor = vec4( finalColor, hologramOpacity);\n\n      }",this.uniforms={time:new a(0),fresnelOpacity:new a(void 0!==e.fresnelOpacity?e.fresnelOpacity:1),fresnelAmount:new a(void 0!==e.fresnelAmount?e.fresnelAmount:.45),scanlineSize:new a(void 0!==e.scanlineSize?e.scanlineSize:8),hologramBrightness:new a(void 0!==e.hologramBrightness?e.hologramBrightness:1),signalSpeed:new a(void 0!==e.signalSpeed?e.signalSpeed:1),hologramColor:new a(void 0!==e.hologramColor?new r(e.hologramColor):new r("#00d5ff")),enableBlinking:new a(void 0===e.enableBlinking||e.enableBlinking),blinkFresnelOnly:new a(void 0===e.blinkFresnelOnly||e.blinkFresnelOnly),hologramOpacity:new a(void 0!==e.hologramOpacity?e.hologramOpacity:1)},this.clock=new l,this.setValues(e),this.depthTest=void 0!==e.depthTest&&e.depthTest,this.blending=void 0!==e.blendMode?e.blendMode:s,this.transparent=!0,this.side=void 0!==e.side?e.side:t}update(){this.uniforms.time.value=this.clock.getElapsedTime()}}const A=b({__name:"importantBuildings",props:{group:{}},setup(n){const i=n,o=0,a=0,l=15,t=1.3,c="#e05b0f",d=new W({blendMode:s,hologramBrightness:2.5,side:m});d.uniforms.fresnelAmount.value=o,d.uniforms.scanlineSize.value=l,d.uniforms.signalSpeed.value=t,d.uniforms.fresnelOpacity.value=a,d.uniforms.hologramColor.value=new r(c),d.uniforms.enableBlinking.value=!1,d.depthTest=!0;let u,f,v=null;(()=>{const e=i.group.getObjectByName("02-huanqiujinrongzhongxin_huanqiujinrongzhongxin_0");e.name="环球金融中心",e.material.dispose(),p(e.geometry),e.material=d,u=i.group.getObjectByName("01-shanghaizhongxindasha_shanghaizhongxindasha_0"),u.name="上海中心",u.material.dispose(),p(u.geometry),u.material=d.clone(),u.material.uniforms.hologramColor.value=new r("#006cf9"),u.material.uniforms.fresnelAmount.value=1,u.material.uniforms.scanlineSize.value=2.1,u.material.uniforms.signalSpeed.value=.4,f=i.group.getObjectByName("03-jinmaodasha_jjinmaodasha_0"),f.name="金茂大厦",f.material.dispose(),p(f.geometry),f.material=d.clone(),f.material.uniforms.hologramColor.value=new r("#5e0fe0"),f.material.uniforms.scanlineSize.value=15,f.material.uniforms.signalSpeed.value=.18,v=i.group.getObjectByName("04-dongfangmingzhu_dongfangmingzhu_0"),v.name="东方明珠塔",v.material.dispose(),p(v.geometry),v.material=d.clone(),v.material.uniforms.scanlineSize.value=5,v.material.uniforms.signalSpeed.value=1.3,v.material.uniforms.hologramColor.value=new r("#e00f0f"),v.material.uniforms.fresnelOpacity.value=.1})();const{onLoop:g}=e();return g((()=>{d.update(),u.material.update(),f.material.update(),v.material.update()})),(e,n)=>null}}),E=["object"],V=b({__name:"buildingsMode",async setup(i){let o,a;h();const{scene:l}=([o,a]=w((()=>n("./plugins/digitalCity/model/shanghaiDraco/shanghaiDraco.gltf",{draco:!0,decoderPath:"./draco/"}))),o=await o,a(),o),s=l.clone(),t=S(0);s.traverse((async e=>{if(e.isMesh&&(-1!==e.name.indexOf("Shanghai")||-1!==e.name.indexOf("Object")))if(-1!==e.name.indexOf("Floor"));else if(-1!==e.name.indexOf("River")){const n=await _(e);n.position.set(0,0,1800),e.add(n)}else(e=>{const{geometry:n}=e;n.computeBoundingBox(),n.computeBoundingSphere(),n.computeBoundsTree();const{max:i,min:o}=n.boundingBox,a=new g({baseMaterial:c,vertexShader:x,fragmentShader:y,silent:!0,uniforms:{uMax:{value:i},uMin:{value:o},uBorderWidth:{value:.006},uCircleTime:{value:3},uColor:{value:new r("#005c58")},uOpacity:{value:.8},uLightColor:{value:new r("#990")},uTopColor:{value:new r("#888800")},uTime:t,uGradient:{value:!0}},depthWrite:!0,depthTest:!0,transparent:!0,side:m});e.material.dispose(),e.material=a})(e),(e=>{const n=new d(e.geometry,1e3);let i=(new u).fromEdgesGeometry(n);i.computeBoundsTree();let o=new f({color:new r("#000"),linewidth:.8,opacity:.6,transparent:!0,depthWrite:!0,depthTest:!0});o.resolution.set(window.innerWidth,window.innerHeight),e.add(new v(i,o))})(e)}));const{onLoop:p}=e();return p((({delta:e})=>{t.value+=e})),(e,n)=>(C(),j(P,null,[(C(),O(B,null,{default:z((()=>[M("primitive",{object:T(s),position:[1,0,1],"cast-shadow":"","receive-shadow":""},null,8,E)])),_:1})),k(A,{group:T(s)},null,8,["group"])],64))}}),D=b({__name:"city2",setup:e=>(e,n)=>{const o=U("TresCanvas");return C(),O(o,{shadows:"","window-size":"",clearColor:"#333"},{default:z((()=>[n[0]||(n[0]=M("TresPerspectiveCamera",{position:[.5,2,1.5],fov:45,near:.1,far:1e5},null,-1)),k(T(i)),n[1]||(n[1]=M("TresAmbientLight",{color:"#ffffff"},null,-1)),n[2]||(n[2]=M("TresDirectionalLight",{position:[0,3,3],intensity:2,color:"#ffffff","cast-shadow":"","shadow-mapSize-width":1024,"shadow-mapSize-height":1024},null,-1)),(C(),O(B,null,{default:z((()=>[k(V)])),_:1})),(C(),O(B,null,{default:z((()=>[k(N,{color:"#ffffff",radius:1,speed:1,geoJson:"plugins/digitalCity/geojson/secondarySmall.geojson","rotation-y":1.3826597599330712,scale:.001025905404044292,position:[-1.877460474821603,.01,-1.5464791950519081]})])),_:1})),n[3]||(n[3]=M("TresGridHelper",{args:[6,10],position:[0,0,0]},null,-1))])),_:1})}});export{D as default};
