import{u as a}from"./colorList.DbCLsRg71763540743861.js";import{d as n,a as e,w as o,H as i,o as l,u as s,J as t,ac as r,ao as c}from"./@vue.Co_gxueH1763540743861.js";import{f as v,l as _,V as m,ae as p}from"./three.rXKzP9fQ1763540743861.js";const u=["position","scale","visible"],f=n({__name:"volumeMesh",props:{texture:{},paneControl:{}},setup(n){const f=n,d=a(),b=e(!0),x=e("#336633"),g=e("#cc3333"),h=e("#ffffff"),y=e(0),w={uniforms:{u_size:{value:new m(1,1,1)},u_renderstyle:{value:y.value},u_iso_threshold:{value:.5},u_iso_ambient_color:{value:new _(x.value)},u_iso_diffuse_color:{value:new _(g.value)},u_iso_specular_color:{value:new _(h.value)},u_iso_shininess:{value:40},u_clim:{value:new v(.05,0)},u_data:{value:f.texture},u_cmdata:{value:d.updateTransferFunction()}},side:p,vertexShader:"varying vec3 v_backpos;\nvarying vec4 v_nearpos;\nvarying vec4 v_farpos;\nuniform vec3 u_size;\n\nmat4 inversemat(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n        a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n        a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n        a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n        b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32,\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 +\n              b05 * b06;\n  return mat4(a11 * b11 - a12 * b10 + a13 * b09,\n              a02 * b10 - a01 * b11 - a03 * b09,\n              a31 * b05 - a32 * b04 + a33 * b03,\n              a22 * b04 - a21 * b05 - a23 * b03,\n              a12 * b08 - a10 * b11 - a13 * b07,\n              a00 * b11 - a02 * b08 + a03 * b07,\n              a32 * b02 - a30 * b05 - a33 * b01,\n              a20 * b05 - a22 * b02 + a23 * b01,\n              a10 * b10 - a11 * b08 + a13 * b06,\n              a01 * b08 - a00 * b10 - a03 * b06,\n              a30 * b04 - a31 * b02 + a33 * b00,\n              a21 * b02 - a20 * b04 - a23 * b00,\n              a11 * b07 - a10 * b09 - a12 * b06,\n              a00 * b09 - a01 * b07 + a02 * b06,\n              a31 * b01 - a30 * b03 - a32 * b00,\n              a20 * b03 - a21 * b01 + a22 * b00) /\n         det;\n}\n\nvoid main() {\n  mat4 viewtransformf = modelViewMatrix;\n  mat4 viewtransformi = inversemat(modelViewMatrix);\n  vec4 position4 = vec4(position, 1.0);\n  vec4 pos_in_cam = viewtransformf * position4;\n  v_backpos = (position + 0.5) * u_size;\n  gl_Position = projectionMatrix * pos_in_cam;\n  pos_in_cam.z = -pos_in_cam.w;\n  v_nearpos = viewtransformi * pos_in_cam;\n  v_nearpos.xyz = (v_nearpos.xyz + 0.5 * v_nearpos.w) * u_size;\n  pos_in_cam.z = pos_in_cam.w;\n  v_farpos = viewtransformi * pos_in_cam;\n  v_farpos.xyz = (v_farpos.xyz + 0.5 * v_farpos.w) * u_size;\n}",fragmentShader:"precision highp float;\nprecision mediump sampler3D;\n\nuniform mat4 projectionMatrix;\nuniform vec3 u_size;\nuniform int u_renderstyle;\nuniform float u_iso_threshold;\nuniform vec2 u_clim;\n\nuniform sampler3D u_data;\nuniform sampler2D u_cmdata;\n\nvarying vec3 v_backpos;\nvarying vec4 v_nearpos;\nvarying vec4 v_farpos;\n\nuniform vec3 u_iso_ambient_color;\nuniform vec3 u_iso_diffuse_color;\nuniform vec3 u_iso_specular_color;\nuniform float u_iso_shininess;\n\nvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\nvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\n\nfloat sample1(vec3 texcoords);\nvec4 apply_colormap(float val);\nvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);\n\nvoid main() {\n    vec3 farpos = v_farpos.xyz / v_farpos.w;\n    vec3 nearpos = v_nearpos.xyz / v_nearpos.w;\n    vec3 backpos = v_backpos;\n\n    vec3 view_ray = normalize(nearpos - farpos);\n\n    float distance = dot(nearpos - backpos, view_ray);\n    vec3 distances = min(u_size / view_ray, 0.0) - backpos / view_ray;\n    distance = max(distance, distances.x);\n    distance = max(distance, distances.y);\n    distance = max(distance, distances.z);\n\n    vec3 frontpos = backpos + view_ray * distance;\n\n    int nsteps = int(0.5 - distance / STEP_SIZE);\n    if (nsteps < 1)\n        discard;\n\n    vec3 step = (backpos - frontpos) / float(nsteps);\n\n    if (u_renderstyle == 0)\n        cast_mip(frontpos / u_size, step / u_size, nsteps, view_ray);\n    else if (u_renderstyle == 1)\n        cast_iso(frontpos / u_size, step / u_size, nsteps, view_ray);\n\n    if (gl_FragColor.a < 0.05)\n        discard;\n}\n\nfloat sample1(vec3 texcoords) {\n    return (texture(u_data, texcoords.xyz).r - u_clim[0]) / (u_clim[1] - u_clim[0]);\n}\n\nvec4 apply_colormap(float val) {\n    return texture2D(u_cmdata, vec2(val, 0.5));\n}\n\nvoid setFragDepth(vec3 loc) {\n    vec4 position4 = vec4(loc * u_size, 1.0);\n    vec4 position = projectionMatrix * viewMatrix * position4;\n    gl_FragDepth = 0.5 * position.z / position.w + 0.5;\n}\n\nvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\n    float max_val = -1e6;\n    int max_i = MAX_STEPS;\n    vec3 loc = start_loc;\n    for (int iter = 0; iter < MAX_STEPS; iter++) {\n        if (iter >= nsteps)\n            break;\n        float val = sample1(loc);\n        if (val > max_val) {\n            max_val = val;\n            max_i = iter;\n        }\n        loc += step;\n    }\n\n    vec3 iloc = start_loc + step * (float(max_i) - 0.5);\n    vec3 istep = step / float(REFINEMENT_STEPS);\n    vec3 max_iloc = iloc;\n    for (int i = 0; i < REFINEMENT_STEPS; i++) {\n        float val = sample1(loc);\n        if (val > max_val) {\n            max_val = val;\n            max_iloc = iloc;\n        }\n        iloc += istep;\n    }\n\n    gl_FragColor = apply_colormap(max_val);\n    setFragDepth(max_iloc);\n}\n\nvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\n    gl_FragColor = vec4(0.0);\n    vec4 color3 = vec4(0.0);\n    vec3 dstep = 1.5 / u_size;\n    vec3 loc = start_loc;\n\n    float low_threshold = u_iso_threshold - 0.02 * (u_clim[1] - u_clim[0]);\n\n    for (int iter = 0; iter < MAX_STEPS; iter++) {\n        if (iter >= nsteps)\n            break;\n\n        float val = sample1(loc);\n\n        if (val > low_threshold) {\n            vec3 iloc = loc - 0.5 * step;\n            vec3 istep = step / float(REFINEMENT_STEPS);\n            for (int i = 0; i < REFINEMENT_STEPS; i++) {\n                val = sample1(iloc);\n                if (val > u_iso_threshold) {\n                    gl_FragColor = add_lighting(val, iloc, dstep, view_ray);\n                    setFragDepth(iloc);\n                    return;\n                }\n                iloc += istep;\n            }\n        }\n        loc += step;\n    }\n}\n\nvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray) {\n    vec3 V = normalize(view_ray);\n\n    vec3 N;\n    float val1, val2;\n    val1 = sample1(loc + vec3(-step[0], 0.0, 0.0));\n    val2 = sample1(loc + vec3(+step[0], 0.0, 0.0));\n    N[0] = val1 - val2;\n    val = max(max(val1, val2), val);\n    val1 = sample1(loc + vec3(0.0, -step[1], 0.0));\n    val2 = sample1(loc + vec3(0.0, +step[1], 0.0));\n    N[1] = val1 - val2;\n    val = max(max(val1, val2), val);\n    val1 = sample1(loc + vec3(0.0, 0.0, -step[2]));\n    val2 = sample1(loc + vec3(0.0, 0.0, +step[2]));\n    N[2] = val1 - val2;\n    val = max(max(val1, val2), val);\n\n    float gm = length(N);\n    N = normalize(N);\n\n    float Nselect = float(dot(N, V) > 0.0);\n    N = (2.0 * Nselect - 1.0) * N;\n\n    vec3 ambient_color = vec3(0.0);\n    vec3 diffuse_color = vec3(0.0);\n    vec3 specular_color = vec3(0.0);\n\n    for (int i = 0; i < 1; i++) {\n        vec3 L = normalize(view_ray);\n        float lightEnabled = float(length(L) > 0.0);\n        L = normalize(L + (1.0 - lightEnabled));\n\n        float lambertTerm = clamp(dot(N, L), 0.0, 1.0);\n        vec3 H = normalize(L + V);\n        float specularTerm = pow(max(dot(H, N), 0.0), u_iso_shininess);\n\n        float mask1 = lightEnabled;\n\n        ambient_color += mask1 * u_iso_ambient_color;\n        diffuse_color += mask1 * lambertTerm * u_iso_diffuse_color;\n        specular_color += mask1 * specularTerm * u_iso_specular_color;\n    }\n\n    vec4 final_color;\n    vec4 color = apply_colormap(val);\n    final_color.rgb = color.rgb * (ambient_color + diffuse_color) + specular_color;\n    final_color.a = color.a;\n    return final_color;\n}",transparent:!0,depthWrite:!0,depthTest:!0,defines:{}},z=f.texture.image.width,E=f.texture.image.height,S=f.texture.image.depth;return w.uniforms.u_size.value.set(z,E,S),w.defines.STEP_SIZE=.3,w.defines.MAX_STEPS=Math.ceil(Math.sqrt(z*z+E*E+S*S)/.3),w.defines.REFINEMENT_STEPS=10,f.paneControl.addBinding(b,"value",{label:"显示体渲染"}),f.paneControl.addBinding(w.uniforms.u_clim.value,"x",{label:"clim1",min:.01,max:.6,step:.001}),f.paneControl.addBinding(w.uniforms.u_clim.value,"y",{label:"clim2",min:-.1,max:.03,step:.001}),f.paneControl.addBinding(y,"value",{label:"渲染模式",options:{MIP:0,ISO:1}}),f.paneControl.addBinding(w.uniforms.u_iso_threshold,"value",{label:"isoThreshold",min:0,max:1,step:.001}),f.paneControl.addBinding(x,"value",{label:"体环境色"}),f.paneControl.addBinding(g,"value",{label:"体漫反射色"}),f.paneControl.addBinding(h,"value",{label:"体高光色"}),o(()=>d.colorsStops,()=>{w.uniforms.u_cmdata.value=d.updateTransferFunction()},{deep:!0,immediate:!0}),o(()=>[x.value,g.value,h.value,y.value],([a,n,e,o])=>{w.uniforms.u_iso_ambient_color.value.setStyle(a),w.uniforms.u_iso_diffuse_color.value.setStyle(n),w.uniforms.u_iso_specular_color.value.setStyle(e),w.uniforms.u_renderstyle.value=o}),(a,n)=>(l(),i("TresMesh",{position:[s(z)/2,s(E)/2,s(S)/2],scale:[s(z),s(E),s(S)],renderOrder:99990,visible:b.value},[n[0]||(n[0]=t("TresBoxGeometry",null,null,-1)),t("TresShaderMaterial",r(c(w)),null,16)],8,u))}});export{f as _};
