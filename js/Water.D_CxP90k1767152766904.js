import{importShared as t}from"./3d-tiles-renderer.CPyPbRB51767152766904.js";const{Color:e,FrontSide:r,Matrix4:n,Mesh:o,PerspectiveCamera:i,Plane:a,ShaderMaterial:l,UniformsLib:s,UniformsUtils:u,Vector3:m,Vector4:c,WebGLRenderTarget:d}=await t("three");class v extends o{constructor(t,o={}){super(t),this.isWater=!0;const v=this,f=void 0!==o.textureWidth?o.textureWidth:512,p=void 0!==o.textureHeight?o.textureHeight:512,x=void 0!==o.clipBias?o.clipBias:0,g=void 0!==o.alpha?o.alpha:1,w=void 0!==o.time?o.time:0,h=void 0!==o.waterNormals?o.waterNormals:null,y=void 0!==o.sunDirection?o.sunDirection:new m(.70707,.70707,0),C=new e(void 0!==o.sunColor?o.sunColor:16777215),S=new e(void 0!==o.waterColor?o.waterColor:8355711),M=void 0!==o.eye?o.eye:new m(0,0,0),_=void 0!==o.distortionScale?o.distortionScale:20,D=void 0!==o.side?o.side:r,b=void 0!==o.fog&&o.fog,z=new a,P=new m,N=new m,L=new m,W=new n,R=new m(0,0,-1),T=new c,j=new m,F=new m,U=new c,k=new n,V=new i,B=new d(f,p),E={name:"MirrorShader",uniforms:u.merge([s.fog,s.lights,{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},distortionScale:{value:20},textureMatrix:{value:new n},sunColor:{value:new e(8355711)},sunDirection:{value:new m(.70707,.70707,0)},eye:{value:new m},waterColor:{value:new e(5592405)}}]),vertexShader:"\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}",fragmentShader:"\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <colorspace_fragment>\n\t\t\t\t\t#include <fog_fragment>\t\n\t\t\t\t}"},A=new l({name:E.name,uniforms:u.clone(E.uniforms),vertexShader:E.vertexShader,fragmentShader:E.fragmentShader,lights:!0,side:D,fog:b});A.uniforms.mirrorSampler.value=B.texture,A.uniforms.textureMatrix.value=k,A.uniforms.alpha.value=g,A.uniforms.time.value=w,A.uniforms.normalSampler.value=h,A.uniforms.sunColor.value=C,A.uniforms.waterColor.value=S,A.uniforms.sunDirection.value=y,A.uniforms.distortionScale.value=_,A.uniforms.eye.value=M,v.material=A,v.onBeforeRender=function(t,e,r){if(N.setFromMatrixPosition(v.matrixWorld),L.setFromMatrixPosition(r.matrixWorld),W.extractRotation(v.matrixWorld),P.set(0,0,1),P.applyMatrix4(W),j.subVectors(N,L),j.dot(P)>0)return;j.reflect(P).negate(),j.add(N),W.extractRotation(r.matrixWorld),R.set(0,0,-1),R.applyMatrix4(W),R.add(L),F.subVectors(N,R),F.reflect(P).negate(),F.add(N),V.position.copy(j),V.up.set(0,1,0),V.up.applyMatrix4(W),V.up.reflect(P),V.lookAt(F),V.far=r.far,V.updateMatrixWorld(),V.projectionMatrix.copy(r.projectionMatrix),k.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),k.multiply(V.projectionMatrix),k.multiply(V.matrixWorldInverse),z.setFromNormalAndCoplanarPoint(P,N),z.applyMatrix4(V.matrixWorldInverse),T.set(z.normal.x,z.normal.y,z.normal.z,z.constant);const n=V.projectionMatrix;U.x=(Math.sign(T.x)+n.elements[8])/n.elements[0],U.y=(Math.sign(T.y)+n.elements[9])/n.elements[5],U.z=-1,U.w=(1+n.elements[10])/n.elements[14],T.multiplyScalar(2/T.dot(U)),n.elements[2]=T.x,n.elements[6]=T.y,n.elements[10]=T.z+1-x,n.elements[14]=T.w,M.setFromMatrixPosition(r.matrixWorld);const o=t.getRenderTarget(),i=t.xr.enabled,a=t.shadowMap.autoUpdate;v.visible=!1,t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.setRenderTarget(B),t.state.buffers.depth.setMask(!0),!1===t.autoClear&&t.clear(),t.render(e,V),v.visible=!0,t.xr.enabled=i,t.shadowMap.autoUpdate=a,t.setRenderTarget(o);const l=r.viewport;void 0!==l&&t.state.viewport(l)}}}export{v as Water};
