var e=Object.defineProperty,n=Object.getOwnPropertySymbols,a=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,t=(n,a,c)=>a in n?e(n,a,{enumerable:!0,configurable:!0,writable:!0,value:c}):n[a]=c,r=(e,r)=>{for(var s in r||(r={}))a.call(r,s)&&t(e,s,r[s]);if(n)for(var s of n(r))c.call(r,s)&&t(e,s,r[s]);return e};import{bO as s,aP as i}from"./three.sQDbNBks1741583630766.js";const o="csm_DiffuseColor",l="csm_Roughness",m="csm_Metalness",d="csm_Emissive",_="csm_AO",f="csm_Bump",S="csm_FragNormal",M="csm_Clearcoat",h="csm_ClearcoatRoughness",A="csm_ClearcoatNormal",u="csm_Transmission",p="csm_Thickness",E="csm_Iridescence",g="csm_PointSize",I="csm_FragColor",v="csm_DepthAlpha",T="csm_UnlitFac",R="csm_Position",C="csm_PositionRaw",L="csm_Normal",N={["".concat(R)]:"*",["".concat(C)]:"*",["".concat(L)]:"*",["".concat(v)]:"*",["".concat(g)]:["PointsMaterial"],["".concat(o)]:"*",["".concat(I)]:"*",["".concat(S)]:"*",["".concat(T)]:"*",["".concat(d)]:["MeshStandardMaterial","MeshPhysicalMaterial"],["".concat(l)]:["MeshStandardMaterial","MeshPhysicalMaterial"],["".concat(m)]:["MeshStandardMaterial","MeshPhysicalMaterial"],["".concat(E)]:["MeshStandardMaterial","MeshPhysicalMaterial"],["".concat(_)]:["MeshStandardMaterial","MeshPhysicalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial"],["".concat(f)]:["MeshLambertMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MeshToonMaterial","ShadowMaterial"],["".concat(M)]:["MeshPhysicalMaterial"],["".concat(h)]:["MeshPhysicalMaterial"],["".concat(A)]:["MeshPhysicalMaterial"],["".concat(u)]:["MeshPhysicalMaterial"],["".concat(p)]:["MeshPhysicalMaterial"]},P={"*":{"#include <lights_physical_fragment>":s.lights_physical_fragment,"#include <transmission_fragment>":s.transmission_fragment},["".concat(L)]:{"#include <beginnormal_vertex>":"\n    vec3 objectNormal = ".concat(L,";\n    #ifdef USE_TANGENT\n\t    vec3 objectTangent = vec3( tangent.xyz );\n    #endif\n    ")},["".concat(R)]:{"#include <begin_vertex>":"\n    vec3 transformed = ".concat(R,";\n  ")},["".concat(C)]:{"#include <begin_vertex>":"\n    vec4 csm_internal_positionUnprojected = ".concat(C,";\n    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;\n    #ifdef USE_INSTANCING\n      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;\n    #endif\n    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;\n    vec3 transformed = csm_internal_positionUnprojected.xyz;\n  ")},["".concat(g)]:{"gl_PointSize = size;":"\n    gl_PointSize = ".concat(g,";\n    ")},["".concat(o)]:{"#include <color_fragment>":"\n    #include <color_fragment>\n    diffuseColor = ".concat(o,";\n  ")},["".concat(I)]:{"#include <opaque_fragment>":"\n    #include <opaque_fragment>\n    gl_FragColor = mix(gl_FragColor, ".concat(I,", ").concat(T,");\n  ")},["".concat(d)]:{"vec3 totalEmissiveRadiance = emissive;":"\n    vec3 totalEmissiveRadiance = ".concat(d,";\n    ")},["".concat(l)]:{"#include <roughnessmap_fragment>":"\n    #include <roughnessmap_fragment>\n    roughnessFactor = ".concat(l,";\n    ")},["".concat(m)]:{"#include <metalnessmap_fragment>":"\n    #include <metalnessmap_fragment>\n    metalnessFactor = ".concat(m,";\n    ")},["".concat(_)]:{"#include <aomap_fragment>":"\n    #include <aomap_fragment>\n    reflectedLight.indirectDiffuse *= 1. - ".concat(_,";\n    ")},["".concat(f)]:{"#include <normal_fragment_maps>":"\n    #include <normal_fragment_maps>\n\n    vec3 csm_internal_orthogonal = ".concat(f," - (dot(").concat(f,", normal) * normal);\n    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;\n    normal = normalize(normal - csm_internal_projectedbump);\n    ")},["".concat(S)]:{"#include <normal_fragment_maps>":"\n      #include <normal_fragment_maps>\n      normal = ".concat(S,";\n    ")},["".concat(v)]:{"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );":"\n      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * 1.0 - ".concat(v," );\n    "),"gl_FragColor = packDepthToRGBA( fragCoordZ );":"\n      if(".concat(v," < 1.0) discard;\n      gl_FragColor = packDepthToRGBA( dist );\n    "),"gl_FragColor = packDepthToRGBA( dist );":"\n      if(".concat(v," < 1.0) discard;\n      gl_FragColor = packDepthToRGBA( dist );\n    ")},["".concat(M)]:{"material.clearcoat = clearcoat;":"material.clearcoat = ".concat(M,";")},["".concat(h)]:{"material.clearcoatRoughness = clearcoatRoughness;":"material.clearcoatRoughness = ".concat(h,";")},["".concat(A)]:{"#include <clearcoat_normal_fragment_begin>":"\n      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);\n      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;\n      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);\n    "},["".concat(u)]:{"material.transmission = transmission;":"\n      material.transmission = ".concat(u,";\n    ")},["".concat(p)]:{"material.thickness = thickness;":"\n      material.thickness = ".concat(p,";\n    ")},["".concat(E)]:{"material.iridescence = iridescence;":"\n      material.iridescence = ".concat(E,";\n    ")}},y={clearcoat:[M,A,h],transmission:[u],iridescence:[E]};function O(e){return e.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g,"")}class D extends i{constructor(e){var t=e,{baseMaterial:s,vertexShader:i,fragmentShader:o,uniforms:l,patchMap:m,cacheKey:d}=t,_=((e,t)=>{var r={};for(var s in e)a.call(e,s)&&t.indexOf(s)<0&&(r[s]=e[s]);if(null!=e&&n)for(var s of n(e))t.indexOf(s)<0&&c.call(e,s)&&(r[s]=e[s]);return r})(t,["baseMaterial","vertexShader","fragmentShader","uniforms","patchMap","cacheKey"]);if(!s)throw new Error("CustomShaderMaterial: baseMaterial is required.");let f;if(function(e){try{new e}catch(s){if(s.message.indexOf("is not a constructor")>=0)return!1}return!0}(s)){const e=0===Object.keys(_).length;f=new s(e?void 0:_)}else f=s,Object.assign(f,_);if(["ShaderMaterial","RawShaderMaterial"].includes(f.type))throw new Error("CustomShaderMaterial does not support ".concat(f.type," as a base material."));super(),this.uniforms={},this.vertexShader="",this.fragmentShader="";const S=f;S.name="CustomShaderMaterial<".concat(f.name||f.type,">"),S.update=this.update.bind(S),S.__csm={prevOnBeforeCompile:f.onBeforeCompile,baseMaterial:f,vertexShader:i,fragmentShader:o,uniforms:l,patchMap:m,cacheKey:d};const M=r(r({},S.uniforms||{}),l||{});S.uniforms=this.uniforms=M,S.vertexShader=this.vertexShader=i||"",S.fragmentShader=this.fragmentShader=o||"",S.update({fragmentShader:S.fragmentShader,vertexShader:S.vertexShader,uniforms:S.uniforms,patchMap:m,cacheKey:d}),Object.assign(this,S);const h=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(S));for(const n in h){const e=h[n];(e.get||e.set)&&Object.defineProperty(this,n,e)}return Object.defineProperty(this,"type",{get:()=>f.type,set(e){f.type=e}}),this}update({fragmentShader:e,vertexShader:n,uniforms:a,cacheKey:c,patchMap:t}){const s=O(n||""),i=O(e||""),o=this;a&&(o.uniforms=a),n&&(o.vertexShader=n),e&&(o.fragmentShader=e),Object.entries(y).forEach((([e,n])=>{for(const a in n){const c=n[a];(i&&i.includes(c)||s&&s.includes(c))&&(o[e]||(o[e]=1))}}));const l=o.__csm.prevOnBeforeCompile,m=(e,n,a)=>{let c,t="";if(n){const e=n.search(/void\s+main\s*\(\s*\)\s*{/);if(-1!==e){t=n.slice(0,e);let a=0,r=-1;for(let c=e;c<n.length;c++)if("{"===n[c]&&a++,"}"===n[c]&&(a--,0===a)){r=c;break}if(-1!==r){const a=n.slice(e,r+1);c=a.slice(a.indexOf("{")+1,-1)}}else t=n}if(a&&n&&n.includes(I)&&c&&(c="csm_UnlitFac = 1.0;\n"+c),e.includes("//~CSM_DEFAULTS")){const n=(e=e.replace("void main() {","\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\n  \n          ".concat(t,"\n          \n          void main() {\n          "))).lastIndexOf("//~CSM_MAIN_END");if(-1!==n){const a="\n            ".concat(c?"".concat(c):"","\n            //~CSM_MAIN_END\n          ");e=e.slice(0,n)+a+e.slice(n)}}else{const n=/void\s*main\s*\(\s*\)\s*{/gm;e=e.replace(n,"\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\n  \n          //~CSM_DEFAULTS\n          ".concat("\n    varying mat4 csm_internal_vModelViewMatrix;\n","\n          ").concat("\n    \n#ifdef IS_VERTEX\n    vec3 csm_Position;\n    vec4 csm_PositionRaw;\n    vec3 csm_Normal;\n\n    // csm_PointSize\n    #ifdef IS_POINTSMATERIAL\n        float csm_PointSize;\n    #endif\n#else\n    vec4 csm_DiffuseColor;\n    vec4 csm_FragColor;\n    float csm_UnlitFac;\n\n    // csm_Emissive, csm_Roughness, csm_Metalness\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\n        vec3 csm_Emissive;\n        float csm_Roughness;\n        float csm_Metalness;\n        float csm_Iridescence;\n        \n        #if defined IS_MESHPHYSICALMATERIAL\n            float csm_Clearcoat;\n            float csm_ClearcoatRoughness;\n            vec3 csm_ClearcoatNormal;\n            float csm_Transmission;\n            float csm_Thickness;\n        #endif\n    #endif\n\n    // csm_AO\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\n        float csm_AO;\n    #endif\n\n    // csm_Bump\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \n        vec3 csm_Bump;\n        vec3 csm_FragNormal;\n    #endif\n\n    float csm_DepthAlpha;\n#endif\n","\n  \n          ").concat(t,"\n          \n          void main() {\n            {\n              ").concat("\n\n#ifdef IS_VERTEX\n    // csm_Position & csm_PositionRaw\n    #ifdef IS_UNKNOWN\n        csm_Position = vec3(0.0);\n        csm_PositionRaw = vec4(0.0);\n        csm_Normal = vec3(0.0);\n    #else\n        csm_Position = position;\n        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n        csm_Normal = normal;\n    #endif\n\n    // csm_PointSize\n    #ifdef IS_POINTSMATERIAL\n        csm_PointSize = size;\n    #endif\n#else\n    csm_UnlitFac = 0.0;\n\n    // csm_DiffuseColor & csm_FragColor\n    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL\n        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\n        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n    #else\n        #ifdef USE_MAP\n            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);\n\n            #ifdef DECODE_VIDEO_TEXTURE\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\n            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);\n            #endif\n\n            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\n            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\n        #else\n            csm_DiffuseColor = vec4(diffuse, opacity);\n            csm_FragColor = vec4(diffuse, opacity);\n        #endif\n    #endif\n\n    // csm_Emissive, csm_Roughness, csm_Metalness\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\n        csm_Emissive = emissive;\n        csm_Roughness = roughness;\n        csm_Metalness = metalness;\n\n        #ifdef USE_IRIDESCENCE\n            csm_Iridescence = iridescence;\n        #else\n            csm_Iridescence = 0.0;\n        #endif\n\n        #if defined IS_MESHPHYSICALMATERIAL\n            #ifdef USE_CLEARCOAT\n                csm_Clearcoat = clearcoat;\n                csm_ClearcoatRoughness = clearcoatRoughness;\n            #else\n                csm_Clearcoat = 0.0;\n                csm_ClearcoatRoughness = 0.0;\n            #endif\n\n            #ifdef USE_TRANSMISSION\n                csm_Transmission = transmission;\n                csm_Thickness = thickness;\n            #else\n                csm_Transmission = 0.0;\n                csm_Thickness = 0.0;\n            #endif\n        #endif\n    #endif\n\n    // csm_AO\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\n        csm_AO = 0.0;\n    #endif\n\n    // csm_Bump\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \n        csm_Bump = vec3(0.0);\n        #ifdef FLAT_SHADED\n            vec3 fdx = dFdx( vViewPosition );\n            vec3 fdy = dFdy( vViewPosition );\n            csm_FragNormal = normalize( cross( fdx, fdy ) );\n        #else\n            csm_FragNormal = normalize(vNormal);\n            #ifdef DOUBLE_SIDED\n                csm_FragNormal *= gl_FrontFacing ? 1.0 : - 1.0;\n            #endif\n        #endif\n    #endif\n\n    csm_DepthAlpha = 1.0;\n#endif\n","\n            }\n            ").concat(a?"\n    \n":"\n    csm_internal_vModelViewMatrix = modelViewMatrix;\n","\n\n            ").concat(c?"".concat(c):"","\n            //~CSM_MAIN_END\n          "))}return e};o.onBeforeCompile=(e,n)=>{null==l||l(e,n);const c=t||{},d=o.type,_=d?"#define IS_".concat(d.toUpperCase(),";\n"):"#define IS_UNKNOWN;\n";e.vertexShader=_+"#define IS_VERTEX\n"+e.vertexShader,e.fragmentShader=_+"#define IS_FRAGMENT\n"+e.fragmentShader;const f=n=>{for(const a in n){const c="*"===a||s&&s.includes(a);if("*"===a||i&&i.includes(a)||c){const c=N[a];if(c&&"*"!==c&&(Array.isArray(c)?!c.includes(d):c!==d))return void console.error("CustomShaderMaterial: ".concat(a," is not available in ").concat(d,". Shader cannot compile."));const t=n[a];for(const n in t){const a=t[n];if("object"==typeof a){const c=a.type,t=a.value;"fs"===c?e.fragmentShader=e.fragmentShader.replace(n,t):"vs"===c&&(e.vertexShader=e.vertexShader.replace(n,t))}else a&&(e.vertexShader=e.vertexShader.replace(n,a),e.fragmentShader=e.fragmentShader.replace(n,a))}}}};f(P),f(c),e.vertexShader=m(e.vertexShader,s,!1),e.fragmentShader=m(e.fragmentShader,i,!0),a&&(e.uniforms=r(r({},e.uniforms),o.uniforms)),o.uniforms=e.uniforms};const d=o.customProgramCacheKey;o.customProgramCacheKey=()=>((null==c?void 0:c())||function(e){let n=0;for(let a=0;a<e.length;a++)n=e.charCodeAt(a)+(n<<6)+(n<<16)-n;return String(n>>>0)}((s||"")+(i||"")))+(null==d?void 0:d.call(o)),o.needsUpdate=!0}clone(){const e=this;return new e.constructor({baseMaterial:e.__csm.baseMaterial.clone(),vertexShader:e.__csm.vertexShader,fragmentShader:e.__csm.fragmentShader,uniforms:e.__csm.uniforms,patchMap:e.__csm.patchMap,cacheKey:e.__csm.cacheKey})}}export{D as z};
