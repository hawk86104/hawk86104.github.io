import{m as n,e,b as t,U as r,c as o}from"./@tresjs.AACxYGk_1736406294003.js";import{P as i}from"./tweakpane.yHWGBmom1736406294003.js";import{B as c,a,aA as l,_ as s,s as u,C as f,K as p,W as v,O as g}from"./three.jaHX2_hY1736406294003.js";import{d,a4 as x,b as h,o as m,f as y,u as w,g as b,j as I,al as C,r as R,J as _,aj as M,ak as z}from"./@vue.yG49nQHr1736406294003.js";import"./@vueuse.d_orRt1V1736406294003.js";var D="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";function A(n,e){const t=O();return(A=function(n,e){return t[n-=492]})(n,e)}const T=A;!function(n,e){const t=A,r=O();for(;;)try{if(632180===-parseInt(t(496))/1*(parseInt(t(503))/2)+parseInt(t(521))/3+parseInt(t(543))/4*(parseInt(t(528))/5)+parseInt(t(517))/6+-parseInt(t(527))/7+-parseInt(t(498))/8*(-parseInt(t(516))/9)+-parseInt(t(515))/10*(-parseInt(t(536))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[A(525)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){L(this,(function(){const n=A,e=new RegExp(n(508)),t=new RegExp(n(493),"i"),r=S(n(530));e[n(506)](r+n(524))&&t[n(506)](r+n(494))?S():r("0")}))()}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function O(){const n=["causticsTexture","48SoAFIi","stateObject","setIndex","setAttribute","console","37158QxYTIp","toString","water","test","error","function *\\( *\\)","tiles","waterTexture","uniforms","info","log","position","126120Bnznkd","1571508UNFhPs","7377600olIYQp","action","string","counter","354810DUoCeF","table","trace","chain","apply","FrontSide","7204687ADPgbZ","5nyvqcD","constructor","init","length","warn","pool","return (function() ",'{}.constructor("return this")( )',"110tkjzzh","call","Mesh","gger","while (true) {}","value","exception","274836xlwFAG","bind","prototype","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","input","__proto__","50xNvboC"];return(O=function(){return n})()}F(void 0,(function(){const n=A,e=function(){const n=A;let e;try{e=Function(n(534)+n(535)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(502)]||{},r=[n(513),n(532),n(512),n(507),n(542),n(522),n(523)];for(let o=0;o<r.length;o++){const e=F[n(529)][n(492)][n(544)](F),i=r[o],c=t[i]||e;e[n(495)]=F.bind(F),e[n(504)]=c.toString[n(544)](c),t[i]=e}}))();const E=d({__name:T(533),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=T,o=t,i=new c,u=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),f=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(501)](r(514),new a(u,3)),i[r(500)](new a(f,1));const p=new l({uniforms:{light:{value:o.light},tiles:{value:o[r(509)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:s[r(526)]}),v=new(s[r(538)])(i,p),{renderer:g,camera:d}=n(),{onAfterLoop:x}=e();return x((()=>{const n=r;((n,e)=>{const t=r;p[t(511)][t(505)][t(541)]=n,p[t(511)].causticTex[t(541)]=e,g[t(541)].render(v,d[t(541)])})(o[n(510)],o[n(497)])})),(n,e)=>null}});function S(n){function e(n){const t=A;if(typeof n===t(519))return function(n){}[t(529)](t(540)).apply(t(520));1!==(""+n/n)[t(531)]||n%20==0?function(){return!0}.constructor("debu"+t(539))[t(537)](t(518)):function(){return!1}[t(529)]("debugger").apply(t(499)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=k,r=P();for(;;)try{if(917764===parseInt(t(161))/1+-parseInt(t(139))/2+parseInt(t(168))/3*(parseInt(t(142))/4)+parseInt(t(132))/5+-parseInt(t(172))/6*(-parseInt(t(164))/7)+parseInt(t(165))/8+-parseInt(t(163))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[k(150)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){j(this,(function(){const n=k,e=new RegExp(n(144)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=V(n(143));e.test(r+n(146))&&t.test(r+n(154))?V():r("0")}))()}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[k(150)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function P(){const n=["chain","pos-x.jpg","toString","info","apply","prototype","tiles","log","input","render","underwater","action","stateObject","return (function() ","clear","117180QmUmPc","value","44912808BSiilO","21sQPrBs","13137256AXTeEF","light","pos-z.jpg","281091gYnBAi","neg-x.jpg",'{}.constructor("return this")( )',"waterTexture","1991400VBWJaA","causticsTexture","neg-z.jpg","error","bind","causticTex","__proto__","CubeTextureLoader","string","RawShaderMaterial","pos-y.jpg","while (true) {}","length","9149095EGuxSJ","gger","constructor","console","white","FrontSide","debu","539258TIuXBw","geometry","uniforms","68YlwuET","init","function *\\( *\\)","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/"];return(P=function(){return n})()}function k(n,e){const t=P();return(k=function(n,e){return t[n-=125]})(n,e)}W(void 0,(function(){const n=k;let e;try{e=Function(n(159)+n(170)+");")()}catch(o){e=window}const t=e[n(135)]=e[n(135)]||{},r=[n(153),"warn",n(149),n(175),"exception","table","trace"];for(let i=0;i<r[n(131)];i++){const e=W[n(134)][n(151)][n(176)](W),o=r[i],c=t[o]||e;e[n(125)]=W.bind(W),e.toString=c[n(148)][n(176)](c),t[o]=e}}))();const H=d({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=k;let i,c;const a=r,l=a[o(140)],v=(new(s[o(126)])).setPath(o(145)).load([o(147),o(169),o(129),"neg-y.jpg",o(167),o(174)]),g=([i,c]=x((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,c(),i),d=new(s[o(128)])({uniforms:{light:{value:a[o(166)]},tiles:{value:g},sky:{value:v},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),b=new u(l,d),I=h(null),C=new f(o(136)),{renderer:R,camera:_}=n(),{onLoop:M}=e();return M((()=>{const n=o;R[n(162)].setRenderTarget(null),R[n(162)].setClearColor(C,1),R[n(162)][n(160)](),d[n(141)].water[n(162)]=a.waterTexture,d[n(141)][n(177)].value=a[n(173)],d.side=s[n(137)],d[n(141)][n(156)][n(162)]=!0,R.value.render(b,_[n(162)]),d.side=p,d.uniforms[n(156)][n(162)]=!1,R.value[n(155)](b,_[n(162)])})),(n,e)=>{const t=o;return m(),y(E,{tiles:w(g),light:n.light,waterTexture:n.waterTexture,causticsTexture:n[t(173)],ref_key:"pooRef",ref:I},null,8,[t(152),"light",t(171),"causticsTexture"])}}});function V(n){function e(n){const t=k;if(typeof n===t(127))return function(n){}[t(134)](t(130))[t(150)]("counter");1!==(""+n/n)[t(131)]||n%20==0?function(){return!0}[t(134)](t(138)+t(133)).call(t(157)):function(){return!1}[t(134)](t(138)+t(133))[t(150)](t(158)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const Z=U;!function(n,e){const t=U,r=Y();for(;;)try{if(737834===parseInt(t(314))/1+-parseInt(t(317))/2*(-parseInt(t(308))/3)+parseInt(t(311))/4*(parseInt(t(352))/5)+parseInt(t(319))/6*(parseInt(t(320))/7)+-parseInt(t(323))/8*(-parseInt(t(333))/9)+parseInt(t(334))/10+parseInt(t(325))/11*(-parseInt(t(318))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[U(360)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){B(this,(function(){const n=U,e=new RegExp(n(337)),t=new RegExp(n(321),"i"),r=G(n(309));e[n(313)](r+n(347))&&t[n(313)](r+n(353))?G():r("0")}))()}();const N=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Y(){const n=["__proto__","error","159606wSYFMi","8268370PLpvCE","table","water","function *\\( *\\)","console","ShaderMaterial","geometry","gger","string","render","info","debu","stateObject","chain","waterTexture","uniforms","caustics","value","1935VmzYnU","input","length",'{}.constructor("return this")( )',"material","light","bind","action","apply","warn","constructor","trace","counter","causticsTexture","151203qKQLir","init","setRenderTarget","492YgWnqK","black","test","400550HPaWrh","while (true) {}","exception","50tIvMYf","111084EbrEUJ","12hHAkOe","2082955KfCZMF","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","setClearColor","136DdiFvu","Color","3201AcfpKp","toString","texture","PlaneGeometry","OrthographicCamera","Mesh"];return(Y=function(){return n})()}function U(n,e){const t=Y();return(U=function(n,e){return t[n-=305]})(n,e)}N(void 0,(function(){const n=U,e=function(){const n=U;let e;try{e=Function("return (function() "+n(355)+");")()}catch(t){e=window}return e}(),t=e[n(338)]=e.console||{},r=["log",n(361),n(344),n(332),n(316),n(335),n(305)];for(let o=0;o<r[n(354)];o++){const e=N[n(362)].prototype[n(358)](N),i=r[o],c=t[i]||e;e[n(331)]=N.bind(N),e[n(326)]=c.toString[n(358)](c),t[i]=e}}))();const $=d({__name:Z(350),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=Z,o=t,i=new(s[r(329)])(0,1,1,0,0,2e3),c=new(s[r(328)])(2,2,200,200),a=new v(1024,1024),l=new(s[r(339)])({uniforms:{light:{value:o.light},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),u=new(s[r(330)])(c,l),f=new(s[r(324)])(r(312)),{renderer:p}=n(),{onBeforeLoop:g}=e();return g((()=>{const n=r;u[n(356)][n(349)][n(336)][n(351)]=o[n(348)],p[n(351)][n(310)](a),p.value[n(322)](f,0),p[n(351)].clear(),p[n(351)][n(343)](u,i)})),(n,e)=>{const t=r;return m(),y(C,null,{default:b((()=>[I(H,{waterTexture:n[t(348)],causticsTexture:w(a)[t(327)],light:n[t(357)],geometry:w(c)},null,8,[t(348),t(307),t(357),t(340)])])),_:1})}}});function G(n){function e(n){const t=U;if(typeof n===t(342))return function(n){}[t(362)](t(315)).apply(t(306));1!==(""+n/n)[t(354)]||n%20==0?function(){return!0}[t(362)](t(345)+t(341)).call(t(359)):function(){return!1}[t(362)](t(345)+t(341)).apply(t(346)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const J=q;!function(n,e){const t=q,r=nn();for(;;)try{if(519776===-parseInt(t(284))/1+-parseInt(t(318))/2*(-parseInt(t(273))/3)+parseInt(t(315))/4+-parseInt(t(298))/5*(parseInt(t(288))/6)+parseInt(t(286))/7+-parseInt(t(300))/8*(-parseInt(t(308))/9)+-parseInt(t(307))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){K(this,(function(){const n=q,e=new RegExp(n(320)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=en(n(282));e[n(277)](r+n(319))&&t[n(277)](r+n(275))?en():r("0")}))()}();const X=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(301)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function q(n,e){const t=nn();return(q=function(n,e){return t[n-=270]})(n,e)}X(void 0,(function(){const n=q,e=function(){let n;try{n=Function('return (function() {}.constructor("return this")( ));')()}catch(e){n=window}return n}(),t=e[n(289)]=e.console||{},r=["log",n(321),n(293),n(297),n(305),n(317),n(290)];for(let o=0;o<r[n(285)];o++){const e=X[n(287)].prototype[n(295)](X),i=r[o],c=t[i]||e;e[n(296)]=X[n(295)](X),e[n(281)]=c[n(281)].bind(c),t[i]=e}}))();const Q=d({__name:J(333),props:{light:{}},setup(t,{expose:r}){const o=J,i=new g(0,1,1,0,0,2e3),c=new(s[o(316)])(2,2),a=new(s[o(312)])(256,256,{type:s[o(278)]}),f=new(s[o(312)])(256,256,{type:s[o(278)]}),p=new l({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),v=new(s[o(326)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),d=new(s[o(326)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),x=new u(c,p),h=new(s[o(311)])(c,v),b=new(s[o(311)])(c,d);let I=a;const C=(n,e)=>{const t=o,r=I,c=I===a?f:a;e.material.uniforms[t(313)][t(310)]=r[t(313)],n.setRenderTarget(c),n[t(283)](e,i),I=c},{renderer:R,camera:_,raycaster:M}=n();R[o(310)][o(323)]=!1;const{onBeforeLoop:z}=e();z((()=>{const n=o;var e,t;t=R[n(310)],C(t,b),e=R[n(310)],C(e,h)}));const A=(n,e,t,r)=>{const i=o;x[i(335)][i(299)][i(327)].value=[n,e],x[i(335)][i(299)][i(334)][i(310)]=t,x[i(335)][i(299)].strength[i(310)]=r,C(R.value,x)},T=new(s[o(332)]),L=new(s[o(316)])(2,2),F=L[o(302)][o(329)];for(let n=0;n<F[o(291)];n++){const e=-F[o(331)](n);F[o(303)](n,0),F.setZ(n,e)}F.needsUpdate=!0;const O=new(s[o(311)])(L),E={handleEvent:n=>{const e=o,t=R.value[e(272)][e(304)](),r=t[e(271)],i=t[e(325)];T.x=2*(n[e(328)]-t.left)/r-1,T.y=2*-(n.clientY-t[e(330)])/i+1,M.value.setFromCamera(T,_[e(310)]);const c=M.value[e(279)](O);for(let o of c)A(o[e(322)].x,o[e(322)].z,.03,.04)}};return r({addDrop:A,mouseEvent:n=>{const e=o;n?R[e(310)][e(272)][e(324)](e(306),E):R.value[e(272)][e(274)](e(306),E)}}),(n,e)=>{const t=o;return m(),y($,{lightFrontGeometry:w(c),waterTexture:w(I)[t(313)],light:n[t(336)]},null,8,[t(280),t(309),t(336)])}}});function nn(){const n=["position","top","getY","Vector2","waterSimulation","radius","material","light","gger","width","domElement","3udTUrj","removeEventListener","input","counter","test","FloatType","intersectObject","lightFrontGeometry","toString","init","render","732569ZIAWgx","length","238161INudYt","constructor","2905962gerHEA","console","trace","count","action","info","stateObject","bind","__proto__","error","5jaEBkX","uniforms","8IMHKAs","apply","attributes","setY","getBoundingClientRect","exception","mousemove","1574340MWJcqu","7408701IZRmKJ","waterTexture","value","Mesh","WebGLRenderTarget","texture","call","3473940tYXXLC","PlaneGeometry","table","336818nGQUWo","chain","function *\\( *\\)","warn","point","autoClear","addEventListener","height","RawShaderMaterial","center","clientX"];return(nn=function(){return n})()}function en(n){function e(n){const t=q;if("string"==typeof n)return function(n){}[t(287)]("while (true) {}")[t(301)](t(276));1!==(""+n/n)[t(285)]||n%20==0?function(){return!0}.constructor("debu"+t(270))[t(314)](t(292)):function(){return!1}[t(287)]("debu"+t(270))[t(301)](t(294)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const tn=cn;!function(n,e){const t=cn,r=an();for(;;)try{if(637063===-parseInt(t(489))/1*(-parseInt(t(491))/2)+parseInt(t(479))/3*(-parseInt(t(459))/4)+-parseInt(t(482))/5+-parseInt(t(500))/6+-parseInt(t(502))/7*(-parseInt(t(454))/8)+-parseInt(t(485))/9+parseInt(t(488))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[cn(466)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){rn(this,(function(){const n=cn,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(468),"i"),r=sn(n(499));e[n(492)](r+n(486))&&t[n(492)](r+n(455))?sn():r("0")}))()}();const on=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[cn(466)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function cn(n,e){const t=an();return(cn=function(n,e){return t[n-=453]})(n,e)}function an(){const n=["\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","length","manual","value","change","string","__proto__","click","stateObject","exception","call","3uhZxut","console","table","2954015eiEdHf","counter","debu","6705900kAJkpH","chain","随机增加波纹","34361360XnBRXW","6ckZJaL","addButton","86362bkgjWO","test","TresPerspectiveCamera","prototype","info","action","log","random","init","4418982UnxNdR","return (function() ","7HzVPsg","warn","realWater","点击按钮","鼠标波纹","1422560zxKjdD","input","gger","bind","mouseEvent","4654316fuynAN","addBinding","while (true) {}","waterSimulationRef","toString","addDrop",'{}.constructor("return this")( )',"apply","constructor"];return(an=function(){return n})()}on(void 0,(function(){const n=cn,e=function(){const n=cn;let e;try{e=Function(n(501)+n(465)+");")()}catch(t){e=window}return e}(),t=e[n(480)]=e[n(480)]||{},r=[n(497),n(503),n(495),"error",n(477),n(481),"trace"];for(let o=0;o<r.length;o++){const e=on[n(467)][n(494)][n(457)](on),i=r[o],c=t[i]||e;e[n(474)]=on[n(457)](on),e[n(463)]=c.toString[n(457)](c),t[i]=e}}))();const ln=d({__name:tn(504),setup(n){const e=tn,t=R({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(470)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=h(null),l=new i;l[e(490)]({label:e(505),title:e(487)}).on(e(475),(()=>{const n=e;for(var t=0;t<10;t++)a.value[n(464)](2*Math[n(498)]()-1,2*Math[n(498)]()-1,.03,1&t?.02:-.02)}));const s=h(!1);return l[e(460)](s,e(471),{label:e(453)}).on(e(472),(n=>{const t=e;a[t(471)][t(458)](n[t(471)])})),(n,i)=>{const l=e;return m(),y(w(o),M(z(t)),{default:b((()=>[i[0]||(i[0]=_(l(493),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),I(w(r)),I(Q,{light:c,ref_key:l(462),ref:a},null,512)])),_:1},16)}}});function sn(n){function e(n){const t=cn;if(typeof n===t(473))return function(n){}[t(467)](t(461)).apply(t(483));1!==(""+n/n)[t(469)]||n%20==0?function(){return!0}.constructor(t(484)+t(456))[t(478)](t(496)):function(){return!1}.constructor(t(484)+t(456))[t(466)](t(476)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{ln as default};
