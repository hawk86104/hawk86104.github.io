import{b as i}from"./pagesShow.vue_vue_type_script_setup_true_lang.Z9hdhU_Y1757651394539.js";import{e as t,I as e,K as s}from"./@tresjs.DIdO2Yiu1757651394539.js";import{B as r,V as a,cL as n,al as o,b9 as h,b as u,$ as c,A as m,l as d,C as l}from"./three.CMHPKQCP1757651394539.js";import{a as g}from"./simplex-noise.DjNkejFf1757651394539.js";import{d as p,a2 as y,G as b,o as S,u as P,r as x,j as f,f as v,m as T,F as w}from"./@vue.pEDXJ_3Z1757651394539.js";import"./OimoPhysicsBuffer.Coy4VN8N1757651394539.js";import"./vite-plugin-qiankun.B06WoCqG1757651394539.js";import"./vanilla.esm.5.5.0.D0BMVBT81757651394539.js";import"./PackedMipMapGenerator.CCEAAbuB1757651394539.js";import{_ as M}from"./gridPlusCom.vue_vue_type_script_setup_true_lang.C-0bolna1757651394539.js";import"./Resource.KHds72Cg1757651394539.js";import"./three-custom-shader-material.CVkd-Kby1757651394539.js";import"./buildingsCustomShaderMaterial.DyBo--wu1757651394539.js";import"./postprocessing.BgyKo9Ns1757651394539.js";import"./@vueuse.nD2ilM161757651394539.js";import"./oimophysics.BBtHVm4j1757651394539.js";import"./object-hash.DhyHayLV1757651394539.js";import"./@amap.CGUF9xH41757651394539.js";import"./jszip.B0YFdb0L1757651394539.js";import"./three-stdlib.fnNZ6jf61757651394539.js";import"./@pmndrs.q_KK0ImS1757651394539.js";class C extends r{constructor(i={}){super(),this.isLightningStrike=!0,this.type="LightningStrike",this.init(C.copyParameters(i,i)),this.createMesh()}static createRandomGenerator(){const i=2053,t=[];for(let s=0;s<i;s++)t.push(Math.random());const e={currentSeed:0,random:function(){const s=t[e.currentSeed];return e.currentSeed=(e.currentSeed+1)%i,s},getSeed:function(){return e.currentSeed/i},setSeed:function(t){e.currentSeed=Math.floor(t*i)%i}};return e}static copyParameters(i={},t={}){const e=function(e){return t===i?e:e.clone()};return i.sourceOffset=void 0!==t.sourceOffset?e(t.sourceOffset):new a(0,100,0),i.destOffset=void 0!==t.destOffset?e(t.destOffset):new a(0,0,0),i.timeScale=void 0!==t.timeScale?t.timeScale:1,i.roughness=void 0!==t.roughness?t.roughness:.9,i.straightness=void 0!==t.straightness?t.straightness:.7,i.up0=void 0!==t.up0?e(t.up0):new a(0,0,1),i.up1=void 0!==t.up1?e(t.up1):new a(0,0,1),i.radius0=void 0!==t.radius0?t.radius0:1,i.radius1=void 0!==t.radius1?t.radius1:1,i.radius0Factor=void 0!==t.radius0Factor?t.radius0Factor:.5,i.radius1Factor=void 0!==t.radius1Factor?t.radius1Factor:.2,i.minRadius=void 0!==t.minRadius?t.minRadius:.2,i.isEternal=void 0!==t.isEternal?t.isEternal:void 0===t.birthTime||void 0===t.deathTime,i.birthTime=t.birthTime,i.deathTime=t.deathTime,i.propagationTimeFactor=void 0!==t.propagationTimeFactor?t.propagationTimeFactor:.1,i.vanishingTimeFactor=void 0!==t.vanishingTimeFactor?t.vanishingTimeFactor:.9,i.subrayPeriod=void 0!==t.subrayPeriod?t.subrayPeriod:4,i.subrayDutyCycle=void 0!==t.subrayDutyCycle?t.subrayDutyCycle:.6,i.maxIterations=void 0!==t.maxIterations?t.maxIterations:9,i.isStatic=void 0!==t.isStatic&&t.isStatic,i.ramification=void 0!==t.ramification?t.ramification:5,i.maxSubrayRecursion=void 0!==t.maxSubrayRecursion?t.maxSubrayRecursion:3,i.recursionProbability=void 0!==t.recursionProbability?t.recursionProbability:.6,i.generateUVs=void 0!==t.generateUVs&&t.generateUVs,i.randomGenerator=t.randomGenerator,i.noiseSeed=t.noiseSeed,i.onDecideSubrayCreation=t.onDecideSubrayCreation,i.onSubrayCreation=t.onSubrayCreation,i}update(i){this.isStatic||(this.rayParameters.isEternal||this.rayParameters.birthTime<=i&&i<=this.rayParameters.deathTime?(this.updateMesh(i),i<this.subrays[0].endPropagationTime?this.state=C.RAY_PROPAGATING:i>this.subrays[0].beginVanishingTime?this.state=C.RAY_VANISHING:this.state=C.RAY_STEADY,this.visible=!0):(this.visible=!1,i<this.rayParameters.birthTime?this.state=C.RAY_UNBORN:this.state=C.RAY_EXTINGUISHED))}init(i){this.rayParameters=i,this.maxIterations=void 0!==i.maxIterations?Math.floor(i.maxIterations):9,i.maxIterations=this.maxIterations,this.isStatic=void 0!==i.isStatic&&i.isStatic,i.isStatic=this.isStatic,this.ramification=void 0!==i.ramification?Math.floor(i.ramification):5,i.ramification=this.ramification,this.maxSubrayRecursion=void 0!==i.maxSubrayRecursion?Math.floor(i.maxSubrayRecursion):3,i.maxSubrayRecursion=this.maxSubrayRecursion,this.recursionProbability=void 0!==i.recursionProbability?i.recursionProbability:.6,i.recursionProbability=this.recursionProbability,this.generateUVs=void 0!==i.generateUVs&&i.generateUVs,i.generateUVs=this.generateUVs,void 0!==i.randomGenerator?(this.randomGenerator=i.randomGenerator,this.seedGenerator=i.randomGenerator,void 0!==i.noiseSeed&&this.seedGenerator.setSeed(i.noiseSeed)):(this.randomGenerator=C.createRandomGenerator(),this.seedGenerator=Math),void 0!==i.onDecideSubrayCreation?this.onDecideSubrayCreation=i.onDecideSubrayCreation:(this.createDefaultSubrayCreationCallbacks(),void 0!==i.onSubrayCreation&&(this.onSubrayCreation=i.onSubrayCreation)),this.state=C.RAY_INITIALIZED,this.maxSubrays=Math.ceil(1+Math.pow(this.ramification,Math.max(0,this.maxSubrayRecursion-1))),i.maxSubrays=this.maxSubrays,this.maxRaySegments=2*(1<<this.maxIterations),this.subrays=[];for(let t=0;t<this.maxSubrays;t++)this.subrays.push(this.createSubray());this.raySegments=[];for(let t=0;t<this.maxRaySegments;t++)this.raySegments.push(this.createSegment());this.time=0,this.timeFraction=0,this.currentSegmentCallback=null,this.currentCreateTriangleVertices=this.generateUVs?this.createTriangleVerticesWithUVs:this.createTriangleVerticesWithoutUVs,this.numSubrays=0,this.currentSubray=null,this.currentSegmentIndex=0,this.isInitialSegment=!1,this.subrayProbability=0,this.currentVertex=0,this.currentIndex=0,this.currentCoordinate=0,this.currentUVCoordinate=0,this.vertices=null,this.uvs=null,this.indices=null,this.positionAttribute=null,this.uvsAttribute=null,this.simplexX=g(this.seedGenerator.random),this.simplexY=g(this.seedGenerator.random),this.simplexZ=g(this.seedGenerator.random),this.forwards=new a,this.forwardsFill=new a,this.side=new a,this.down=new a,this.middlePos=new a,this.middleLinPos=new a,this.newPos=new a,this.vPos=new a,this.cross1=new a}createMesh(){const i=1<<this.maxIterations,t=3*(i+1)*this.maxSubrays,e=18*i*this.maxSubrays;this.vertices=new Float32Array(3*t),this.indices=new Uint32Array(e),this.generateUVs&&(this.uvs=new Float32Array(2*t)),this.fillMesh(0),this.setIndex(new n(this.indices,1)),this.positionAttribute=new o(this.vertices,3),this.setAttribute("position",this.positionAttribute),this.generateUVs&&(this.uvsAttribute=new o(new Float32Array(this.uvs),2),this.setAttribute("uv",this.uvsAttribute)),this.isStatic||(this.index.usage=h,this.positionAttribute.usage=h,this.generateUVs&&(this.uvsAttribute.usage=h)),this.vertices=this.positionAttribute.array,this.indices=this.index.array,this.generateUVs&&(this.uvs=this.uvsAttribute.array)}updateMesh(i){this.fillMesh(i),this.drawRange.count=this.currentIndex,this.index.needsUpdate=!0,this.positionAttribute.needsUpdate=!0,this.generateUVs&&(this.uvsAttribute.needsUpdate=!0)}fillMesh(i){const t=this;this.currentVertex=0,this.currentIndex=0,this.currentCoordinate=0,this.currentUVCoordinate=0,this.fractalRay(i,(function(e){const s=t.currentSubray;i<s.birthTime||(this.rayParameters.isEternal&&0==t.currentSubray.recursion?(t.createPrism(e),t.onDecideSubrayCreation(e,t)):i<s.endPropagationTime?t.timeFraction>=e.fraction0*s.propagationTimeFactor&&(t.createPrism(e),t.onDecideSubrayCreation(e,t)):i<s.beginVanishingTime?(t.createPrism(e),t.onDecideSubrayCreation(e,t)):(t.timeFraction<=s.vanishingTimeFactor+e.fraction1*(1-s.vanishingTimeFactor)&&t.createPrism(e),t.onDecideSubrayCreation(e,t)))}))}addNewSubray(){return this.subrays[this.numSubrays++]}initSubray(i,t){i.pos0.copy(t.sourceOffset),i.pos1.copy(t.destOffset),i.up0.copy(t.up0),i.up1.copy(t.up1),i.radius0=t.radius0,i.radius1=t.radius1,i.birthTime=t.birthTime,i.deathTime=t.deathTime,i.timeScale=t.timeScale,i.roughness=t.roughness,i.straightness=t.straightness,i.propagationTimeFactor=t.propagationTimeFactor,i.vanishingTimeFactor=t.vanishingTimeFactor,i.maxIterations=this.maxIterations,i.seed=void 0!==t.noiseSeed?t.noiseSeed:0,i.recursion=0}fractalRay(i,t){this.time=i,this.currentSegmentCallback=t,this.numSubrays=0,this.initSubray(this.addNewSubray(),this.rayParameters);for(let e=0;e<this.numSubrays;e++){const t=this.subrays[e];this.currentSubray=t,this.randomGenerator.setSeed(t.seed),t.endPropagationTime=u.lerp(t.birthTime,t.deathTime,t.propagationTimeFactor),t.beginVanishingTime=u.lerp(t.deathTime,t.birthTime,1-t.vanishingTimeFactor);const s=this.randomGenerator.random;t.linPos0.set(s(),s(),s()).multiplyScalar(1e3),t.linPos1.set(s(),s(),s()).multiplyScalar(1e3),this.timeFraction=(i-t.birthTime)/(t.deathTime-t.birthTime),this.currentSegmentIndex=0,this.isInitialSegment=!0;const r=this.getNewSegment();r.iteration=0,r.pos0.copy(t.pos0),r.pos1.copy(t.pos1),r.linPos0.copy(t.linPos0),r.linPos1.copy(t.linPos1),r.up0.copy(t.up0),r.up1.copy(t.up1),r.radius0=t.radius0,r.radius1=t.radius1,r.fraction0=0,r.fraction1=1,r.positionVariationFactor=1-t.straightness,this.subrayProbability=this.ramification*Math.pow(this.recursionProbability,t.recursion)/(1<<t.maxIterations),this.fractalRayRecursive(r)}this.currentSegmentCallback=null,this.currentSubray=null}fractalRayRecursive(i){if(i.iteration>=this.currentSubray.maxIterations)return void this.currentSegmentCallback(i);this.forwards.subVectors(i.pos1,i.pos0);let t=this.forwards.length();t<1e-6&&(this.forwards.set(0,0,.01),t=this.forwards.length());const e=.5*(i.radius0+i.radius1),s=.5*(i.fraction0+i.fraction1),r=this.time*this.currentSubray.timeScale*Math.pow(2,i.iteration);this.middlePos.lerpVectors(i.pos0,i.pos1,.5),this.middleLinPos.lerpVectors(i.linPos0,i.linPos1,.5);const a=this.middleLinPos;this.newPos.set(this.simplexX(a.x,a.y,a.z,r),this.simplexY(a.x,a.y,a.z,r),this.simplexZ(a.x,a.y,a.z,r)),this.newPos.multiplyScalar(i.positionVariationFactor*t),this.newPos.add(this.middlePos);const n=this.getNewSegment();n.pos0.copy(i.pos0),n.pos1.copy(this.newPos),n.linPos0.copy(i.linPos0),n.linPos1.copy(this.middleLinPos),n.up0.copy(i.up0),n.up1.copy(i.up1),n.radius0=i.radius0,n.radius1=e,n.fraction0=i.fraction0,n.fraction1=s,n.positionVariationFactor=i.positionVariationFactor*this.currentSubray.roughness,n.iteration=i.iteration+1;const o=this.getNewSegment();o.pos0.copy(this.newPos),o.pos1.copy(i.pos1),o.linPos0.copy(this.middleLinPos),o.linPos1.copy(i.linPos1),this.cross1.crossVectors(i.up0,this.forwards.normalize()),o.up0.crossVectors(this.forwards,this.cross1).normalize(),o.up1.copy(i.up1),o.radius0=e,o.radius1=i.radius1,o.fraction0=s,o.fraction1=i.fraction1,o.positionVariationFactor=i.positionVariationFactor*this.currentSubray.roughness,o.iteration=i.iteration+1,this.fractalRayRecursive(n),this.fractalRayRecursive(o)}createPrism(i){this.forwardsFill.subVectors(i.pos1,i.pos0).normalize(),this.isInitialSegment&&(this.currentCreateTriangleVertices(i.pos0,i.up0,this.forwardsFill,i.radius0,0),this.isInitialSegment=!1),this.currentCreateTriangleVertices(i.pos1,i.up0,this.forwardsFill,i.radius1,i.fraction1),this.createPrismFaces()}createTriangleVerticesWithoutUVs(i,t,e,s){this.side.crossVectors(t,e).multiplyScalar(s*C.COS30DEG),this.down.copy(t).multiplyScalar(-s*C.SIN30DEG);const r=this.vPos,a=this.vertices;r.copy(i).sub(this.side).add(this.down),a[this.currentCoordinate++]=r.x,a[this.currentCoordinate++]=r.y,a[this.currentCoordinate++]=r.z,r.copy(i).add(this.side).add(this.down),a[this.currentCoordinate++]=r.x,a[this.currentCoordinate++]=r.y,a[this.currentCoordinate++]=r.z,r.copy(t).multiplyScalar(s).add(i),a[this.currentCoordinate++]=r.x,a[this.currentCoordinate++]=r.y,a[this.currentCoordinate++]=r.z,this.currentVertex+=3}createTriangleVerticesWithUVs(i,t,e,s,r){this.side.crossVectors(t,e).multiplyScalar(s*C.COS30DEG),this.down.copy(t).multiplyScalar(-s*C.SIN30DEG);const a=this.vPos,n=this.vertices,o=this.uvs;a.copy(i).sub(this.side).add(this.down),n[this.currentCoordinate++]=a.x,n[this.currentCoordinate++]=a.y,n[this.currentCoordinate++]=a.z,o[this.currentUVCoordinate++]=r,o[this.currentUVCoordinate++]=0,a.copy(i).add(this.side).add(this.down),n[this.currentCoordinate++]=a.x,n[this.currentCoordinate++]=a.y,n[this.currentCoordinate++]=a.z,o[this.currentUVCoordinate++]=r,o[this.currentUVCoordinate++]=.5,a.copy(t).multiplyScalar(s).add(i),n[this.currentCoordinate++]=a.x,n[this.currentCoordinate++]=a.y,n[this.currentCoordinate++]=a.z,o[this.currentUVCoordinate++]=r,o[this.currentUVCoordinate++]=1,this.currentVertex+=3}createPrismFaces(i){const t=this.indices;i=this.currentVertex-6,t[this.currentIndex++]=i+1,t[this.currentIndex++]=i+2,t[this.currentIndex++]=i+5,t[this.currentIndex++]=i+1,t[this.currentIndex++]=i+5,t[this.currentIndex++]=i+4,t[this.currentIndex++]=i+0,t[this.currentIndex++]=i+1,t[this.currentIndex++]=i+4,t[this.currentIndex++]=i+0,t[this.currentIndex++]=i+4,t[this.currentIndex++]=i+3,t[this.currentIndex++]=i+2,t[this.currentIndex++]=i+0,t[this.currentIndex++]=i+3,t[this.currentIndex++]=i+2,t[this.currentIndex++]=i+3,t[this.currentIndex++]=i+5}createDefaultSubrayCreationCallbacks(){const i=this.randomGenerator.random;this.onDecideSubrayCreation=function(t,e){const s=e.currentSubray,r=e.rayParameters.subrayPeriod,a=e.rayParameters.subrayDutyCycle,n=e.rayParameters.isEternal&&0==s.recursion?-i()*r:u.lerp(s.birthTime,s.endPropagationTime,t.fraction0)-i()*r,o=e.time-n,h=Math.floor(o/r),c=i()*(h+1);let m=0;if(o%r<=a*r&&(m=e.subrayProbability),s.recursion<e.maxSubrayRecursion&&e.numSubrays<e.maxSubrays&&i()<m){const o=e.addNewSubray(),u=e.randomGenerator.getSeed();o.seed=c,e.randomGenerator.setSeed(c),o.recursion=s.recursion+1,o.maxIterations=Math.max(1,s.maxIterations-1),o.linPos0.set(i(),i(),i()).multiplyScalar(1e3),o.linPos1.set(i(),i(),i()).multiplyScalar(1e3),o.up0.copy(s.up0),o.up1.copy(s.up1),o.radius0=t.radius0*e.rayParameters.radius0Factor,o.radius1=Math.min(e.rayParameters.minRadius,t.radius1*e.rayParameters.radius1Factor),o.birthTime=n+h*r,o.deathTime=o.birthTime+r*a,e.rayParameters.isEternal||0!=s.recursion||(o.birthTime=Math.max(o.birthTime,s.birthTime),o.deathTime=Math.min(o.deathTime,s.deathTime)),o.timeScale=2*s.timeScale,o.roughness=s.roughness,o.straightness=s.straightness,o.propagationTimeFactor=s.propagationTimeFactor,o.vanishingTimeFactor=s.vanishingTimeFactor,e.onSubrayCreation(t,s,o,e),e.randomGenerator.setSeed(u)}};const t=new a,e=new a,s=new a,r=new a;this.onSubrayCreation=function(i,t,e,s){s.subrayCylinderPosition(i,t,e,.5,.6,.2)},this.subrayConePosition=function(a,n,o,h,u,c){o.pos0.copy(a.pos0),t.subVectors(n.pos1,n.pos0),e.copy(t).normalize(),t.multiplyScalar(a.fraction0+(1-a.fraction0)*(i()*h));const m=t.length();s.crossVectors(n.up0,e);const d=2*Math.PI*i();s.multiplyScalar(Math.cos(d)),r.copy(n.up0).multiplyScalar(Math.sin(d)),o.pos1.copy(s).add(r).multiplyScalar(m*u*(c+i()*(1-c))).add(t).add(n.pos0)},this.subrayCylinderPosition=function(a,n,o,h,u,c){o.pos0.copy(a.pos0),t.subVectors(n.pos1,n.pos0),e.copy(t).normalize(),t.multiplyScalar(a.fraction0+(1-a.fraction0)*((2*i()-1)*h));const m=t.length();s.crossVectors(n.up0,e);const d=2*Math.PI*i();s.multiplyScalar(Math.cos(d)),r.copy(n.up0).multiplyScalar(Math.sin(d)),o.pos1.copy(s).add(r).multiplyScalar(m*u*(c+i()*(1-c))).add(t).add(n.pos0)}}createSubray(){return{seed:0,maxIterations:0,recursion:0,pos0:new a,pos1:new a,linPos0:new a,linPos1:new a,up0:new a,up1:new a,radius0:0,radius1:0,birthTime:0,deathTime:0,timeScale:0,roughness:0,straightness:0,propagationTimeFactor:0,vanishingTimeFactor:0,endPropagationTime:0,beginVanishingTime:0}}createSegment(){return{iteration:0,pos0:new a,pos1:new a,linPos0:new a,linPos1:new a,up0:new a,up1:new a,radius0:0,radius1:0,fraction0:0,fraction1:0,positionVariationFactor:0}}getNewSegment(){return this.raySegments[this.currentSegmentIndex++]}copy(i){return super.copy(i),this.init(C.copyParameters({},i.rayParameters)),this}clone(){return new this.constructor(C.copyParameters({},this.rayParameters))}}C.RAY_INITIALIZED=0,C.RAY_UNBORN=1,C.RAY_PROPAGATING=2,C.RAY_STEADY=3,C.RAY_VANISHING=4,C.RAY_EXTINGUISHED=5,C.COS30DEG=Math.cos(30*Math.PI/180),C.SIN30DEG=Math.sin(30*Math.PI/180);class I extends c{constructor(i={}){super(),this.isLightningStorm=!0,this.stormParams=i,i.size=void 0!==i.size?i.size:1e3,i.minHeight=void 0!==i.minHeight?i.minHeight:80,i.maxHeight=void 0!==i.maxHeight?i.maxHeight:100,i.maxSlope=void 0!==i.maxSlope?i.maxSlope:1.1,i.maxLightnings=void 0!==i.maxLightnings?i.maxLightnings:3,i.lightningMinPeriod=void 0!==i.lightningMinPeriod?i.lightningMinPeriod:3,i.lightningMaxPeriod=void 0!==i.lightningMaxPeriod?i.lightningMaxPeriod:7,i.lightningMinDuration=void 0!==i.lightningMinDuration?i.lightningMinDuration:1,i.lightningMaxDuration=void 0!==i.lightningMaxDuration?i.lightningMaxDuration:2.5,this.lightningParameters=C.copyParameters(i.lightningParameters,i.lightningParameters),this.lightningParameters.isEternal=!1,this.lightningMaterial=void 0!==i.lightningMaterial?i.lightningMaterial:new m({color:11599871}),void 0!==i.onRayPosition?this.onRayPosition=i.onRayPosition:this.onRayPosition=function(t,e){e.set((Math.random()-.5)*i.size,0,(Math.random()-.5)*i.size);const s=u.lerp(i.minHeight,i.maxHeight,Math.random());t.set(i.maxSlope*(2*Math.random()-1),1,i.maxSlope*(2*Math.random()-1)).multiplyScalar(s).add(e)},this.onLightningDown=i.onLightningDown,this.inited=!1,this.nextLightningTime=0,this.lightningsMeshes=[],this.deadLightningsMeshes=[];for(let t=0;t<this.stormParams.maxLightnings;t++){const i=new C(C.copyParameters({},this.lightningParameters)),t=new d(i,this.lightningMaterial);this.deadLightningsMeshes.push(t)}}update(i){if(this.inited||(this.nextLightningTime=this.getNextLightningTime(i)*Math.random(),this.inited=!0),i>=this.nextLightningTime){const t=this.deadLightningsMeshes.pop();if(t){const e=C.copyParameters(t.geometry.rayParameters,this.lightningParameters);e.birthTime=i,e.deathTime=i+u.lerp(this.stormParams.lightningMinDuration,this.stormParams.lightningMaxDuration,Math.random()),this.onRayPosition(e.sourceOffset,e.destOffset),e.noiseSeed=Math.random(),this.add(t),this.lightningsMeshes.push(t)}this.nextLightningTime=this.getNextLightningTime(i)}let t=0,e=this.lightningsMeshes.length;for(;t<e;){const s=this.lightningsMeshes[t],r=s.geometry,a=r.state;r.update(i),a===C.RAY_PROPAGATING&&r.state>a&&this.onLightningDown&&this.onLightningDown(r),r.state===C.RAY_EXTINGUISHED?(this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(s),1),this.deadLightningsMeshes.push(s),this.remove(s),e--):t++}}getNextLightningTime(i){return i+u.lerp(this.stormParams.lightningMinPeriod,this.stormParams.lightningMaxPeriod,Math.random())/(this.stormParams.maxLightnings+1)}copy(i,t){return super.copy(i,t),this.stormParams.size=i.stormParams.size,this.stormParams.minHeight=i.stormParams.minHeight,this.stormParams.maxHeight=i.stormParams.maxHeight,this.stormParams.maxSlope=i.stormParams.maxSlope,this.stormParams.maxLightnings=i.stormParams.maxLightnings,this.stormParams.lightningMinPeriod=i.stormParams.lightningMinPeriod,this.stormParams.lightningMaxPeriod=i.stormParams.lightningMaxPeriod,this.stormParams.lightningMinDuration=i.stormParams.lightningMinDuration,this.stormParams.lightningMaxDuration=i.stormParams.lightningMaxDuration,this.lightningParameters=C.copyParameters({},i.lightningParameters),this.lightningMaterial=i.stormParams.lightningMaterial,this.onLightningDown=i.onLightningDown,this}clone(){return new this.constructor(this.stormParams).copy(this)}}const V=["object"],R=p({__name:"lightStorm",props:{color:{default:"#b0ffff"},size:{default:2e3},minHeight:{default:100},maxHeight:{default:500},maxLightnings:{default:18},roughness:{default:.85},straightness:{default:.65},radius0:{default:1},radius1:{default:.5},timeScale:{default:.15},subrayPeriod:{default:4},subrayDutyCycle:{default:.6}},setup(i){const e=i,s=new l(e.color),r=new m({color:s}),n=new a(0,-1,0);let o=0;const h=new a,u=new a,c={roughness:e.roughness,straightness:e.straightness,radius0:e.radius0,radius1:e.radius1,timeScale:e.timeScale,subrayPeriod:e.subrayPeriod,subrayDutyCycle:e.subrayDutyCycle,minRadius:.3,maxIterations:7,propagationTimeFactor:.2,vanishingTimeFactor:.9,maxSubrayRecursion:3,ramification:3,recursionProbability:.4,onSubrayCreation:function(i,t,e,s){s.subrayConePosition(i,t,e,.6,.6,.5),o=s.rayParameters.sourceOffset.y,h.subVectors(e.pos1,s.rayParameters.sourceOffset);const r=n.dot(h);u.copy(n).multiplyScalar(r),h.sub(u);const a=r/o>.5?o/r:1;u.multiplyScalar(a),h.add(u),e.pos1.addVectors(h,s.rayParameters.sourceOffset)}},d=new I({size:e.size,minHeight:e.minHeight,maxHeight:e.maxHeight,maxSlope:.6,maxLightnings:e.maxLightnings,lightningParameters:c,lightningMaterial:r});y((()=>{const i=d.stormParams;i.size=e.size,i.minHeight=e.minHeight,i.maxHeight=e.maxHeight,r.color.set(e.color),c.roughness=e.roughness,c.straightness=e.straightness,c.radius0=e.radius0,c.radius1=e.radius1,c.timeScale=e.timeScale}));const{onLoop:g}=t();return g((({elapsed:i})=>{d.update(i)})),(i,t)=>(S(),b("primitive",{object:P(d),renderOrder:9999},null,8,V))}}),F=p({__name:"lightningStorm",setup(t){const r=x({cellSize:60,cellThickness:1,cellColor:"#6f6f6f",sectionColor:"#92399e",sectionSize:330,sectionThickness:1.5,fadeDistance:3600,fadeStrength:1,followCamera:!1,infiniteGrid:!0}),{minHeight:a,maxHeight:n,color:o,roughness:h,straightness:u,radius0:c,radius1:m,timeScale:d}=e({minHeight:{label:"最低",value:100,min:10,max:500,step:10},maxHeight:{label:"最高",value:1e3,min:50,max:2e3,step:10},color:"#ffbde7",roughness:{label:"粗糙度",value:.85,min:0,max:1,step:.01},straightness:{label:"直度度",value:.65,min:0,max:1,step:.01},radius0:{label:"端部半径",value:1,min:.1,max:10,step:.01},radius1:{label:"未部半径",value:.5,min:.1,max:10,step:.01},timeScale:{label:"时间缩放",value:.15,min:.01,max:1,step:.01}});return(t,e)=>(S(),b(w,null,[f(i,{showAxesHelper:!1,showGridHelper:!1},{ability:v((()=>[f(R,{minHeight:P(a).value,maxHeight:P(n).value,color:P(o).value,roughness:P(h).value,straightness:P(u).value,radius0:P(c).value,radius1:P(m).value,timeScale:P(d).value},null,8,["minHeight","maxHeight","color","roughness","straightness","radius0","radius1","timeScale"]),f(P(M),T({args:[100,100]},r,{position:[0,-50,0]}),null,16)])),_:1}),f(P(s))],64))}});export{F as default};
