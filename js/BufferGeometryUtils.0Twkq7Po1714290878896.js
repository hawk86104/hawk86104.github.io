import{au as M,av as v,b3 as p,bH as X,bI as H,bJ as V}from"./vendor.tzPtBocu1714290878896.js";function D(n,m=!1){const s=n[0].index!==null,c=new Set(Object.keys(n[0].attributes)),o=new Set(Object.keys(n[0].morphAttributes)),a={},t={},b=n[0].morphTargetsRelative,u=new M;let d=0;for(let e=0;e<n.length;++e){const r=n[e];let l=0;if(s!==(r.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const i in r.attributes){if(!c.has(i))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+i+'" attribute exists among all geometries, or in none of them.'),null;a[i]===void 0&&(a[i]=[]),a[i].push(r.attributes[i]),l++}if(l!==c.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes."),null;if(b!==r.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const i in r.morphAttributes){if(!o.has(i))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries."),null;t[i]===void 0&&(t[i]=[]),t[i].push(r.morphAttributes[i])}if(m){let i;if(s)i=r.index.count;else if(r.attributes.position!==void 0)i=r.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute"),null;u.addGroup(d,i,e),d+=i}}if(s){let e=0;const r=[];for(let l=0;l<n.length;++l){const i=n[l].index;for(let h=0;h<i.count;++h)r.push(i.getX(h)+e);e+=n[l].attributes.position.count}u.setIndex(r)}for(const e in a){const r=z(a[e]);if(!r)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;u.setAttribute(e,r)}for(const e in t){const r=t[e][0].length;if(r===0)break;u.morphAttributes=u.morphAttributes||{},u.morphAttributes[e]=[];for(let l=0;l<r;++l){const i=[];for(let f=0;f<t[e].length;++f)i.push(t[e][f][l]);const h=z(i);if(!h)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;u.morphAttributes[e].push(h)}}return u}function z(n){let m,s,c,o=-1,a=0;for(let d=0;d<n.length;++d){const e=n[d];if(m===void 0&&(m=e.array.constructor),m!==e.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(s===void 0&&(s=e.itemSize),s!==e.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(c===void 0&&(c=e.normalized),c!==e.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(o===-1&&(o=e.gpuType),o!==e.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;a+=e.count*s}const t=new m(a),b=new v(t,s,c);let u=0;for(let d=0;d<n.length;++d){const e=n[d];if(e.isInterleavedBufferAttribute){const r=u/s;for(let l=0,i=e.count;l<i;l++)for(let h=0;h<s;h++){const f=e.getComponent(l,h);b.setComponent(l+r,h,f)}}else t.set(e.array,u);u+=e.count*s}return o!==void 0&&(b.gpuType=o),b}function S(n,m){if(m===X)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),n;if(m===H||m===V){let s=n.getIndex();if(s===null){const t=[],b=n.getAttribute("position");if(b!==void 0){for(let u=0;u<b.count;u++)t.push(u);n.setIndex(t),s=n.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n}const c=s.count-2,o=[];if(m===H)for(let t=1;t<=c;t++)o.push(s.getX(0)),o.push(s.getX(t)),o.push(s.getX(t+1));else for(let t=0;t<c;t++)t%2===0?(o.push(s.getX(t)),o.push(s.getX(t+1)),o.push(s.getX(t+2))):(o.push(s.getX(t+2)),o.push(s.getX(t+1)),o.push(s.getX(t)));o.length/3!==c&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const a=n.clone();return a.setIndex(o),a.clearGroups(),a}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",m),n}function N(n,m=Math.PI/3){const s=Math.cos(m),c=(1+1e-10)*100,o=[new p,new p,new p],a=new p,t=new p,b=new p,u=new p;function d(f){const T=~~(f.x*c),g=~~(f.y*c),w=~~(f.z*c);return"".concat(T,",").concat(g,",").concat(w)}const e=n.index?n.toNonIndexed():n,r=e.attributes.position,l={};for(let f=0,T=r.count/3;f<T;f++){const g=3*f,w=o[0].fromBufferAttribute(r,g+0),x=o[1].fromBufferAttribute(r,g+1),G=o[2].fromBufferAttribute(r,g+2);a.subVectors(G,x),t.subVectors(w,x);const y=new p().crossVectors(a,t).normalize();for(let E=0;E<3;E++){const B=o[E],A=d(B);A in l||(l[A]=[]),l[A].push(y)}}const i=new Float32Array(r.count*3),h=new v(i,3,!1);for(let f=0,T=r.count/3;f<T;f++){const g=3*f,w=o[0].fromBufferAttribute(r,g+0),x=o[1].fromBufferAttribute(r,g+1),G=o[2].fromBufferAttribute(r,g+2);a.subVectors(G,x),t.subVectors(w,x),b.crossVectors(a,t).normalize();for(let y=0;y<3;y++){const E=o[y],B=d(E),A=l[B];u.set(0,0,0);for(let U=0,I=A.length;U<I;U++){const R=A[U];b.dot(R)>s&&u.add(R)}u.normalize(),h.setXYZ(g+y,u.x,u.y,u.z)}}return e.setAttribute("normal",h),e}export{S as a,D as m,N as t};
