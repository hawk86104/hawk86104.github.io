import{m as e,bZ as t,au as i,bf as n,f as r,ac as s,d as a,bb as o,bc as l,aj as d,b_ as f,bS as m,h as c,e as h,I as u,a7 as p,l as v,af as g,b$ as y,c0 as _,b7 as S,c1 as x,b8 as M,b9 as T,bo as E,O as U,q as A,_ as P,C as b,c2 as w,bX as B,c3 as C,A as O,ab as R,a$ as N,bR as z,ax as I,b as L,a8 as F,bU as D,b1 as V,n as k,B as H,c as G,aT as j,ah as X}from"./three.2wx8FU0g1743660816268.js";import{l as Y,E as W,V as q,C as J,A as Z,M as K,a as Q,b as $,S as ee,T as te,c as ie,Q as ne,d as re,e as se,G as ae,f as oe,B as le,g as de}from"./quarks.core.TCS8Grzm1743660816268.js";const fe=z;class me extends i{constructor(e){super(),this.type="ParticleEmitter",this.system=e}clone(){const e=this.system.clone();return e.emitter.copy(this,!0),e.emitter}dispose(){}extractFromCache(e){const t=[];for(const i in e){const n=e[i];delete n.metadata,t.push(n)}return t}toJSON(e,t={}){const i=this.children;this.children=this.children.filter((e=>"ParticleSystemPreview"!==e.type));const n=super.toJSON(e);return this.children=i,null!==this.system&&(n.object.ps=this.system.toJSON(e,t)),n}}var ce;!function(e){e[e.BillBoard=0]="BillBoard",e[e.StretchedBillBoard=1]="StretchedBillBoard",e[e.Mesh=2]="Mesh",e[e.Trail=3]="Trail",e[e.HorizontalBillBoard=4]="HorizontalBillBoard",e[e.VerticalBillBoard=5]="VerticalBillBoard"}(ce||(ce={}));class he extends v{constructor(e){super(),this.type="VFXBatch",this.maxParticles=1e3,this.systems=new Set;const t=new C;t.mask=e.layers.mask;const i=e.material.clone();i.defines={},Object.assign(i.defines,e.material.defines),this.settings={instancingGeometry:e.instancingGeometry,renderMode:e.renderMode,renderOrder:e.renderOrder,material:i,uTileCount:e.uTileCount,vTileCount:e.vTileCount,blendTiles:e.blendTiles,softParticles:e.softParticles,softNearFade:e.softNearFade,softFarFade:e.softFarFade,layers:t},this.frustumCulled=!1,this.renderOrder=this.settings.renderOrder}addSystem(e){this.systems.add(e)}removeSystem(e){this.systems.delete(e)}applyDepthTexture(e){const t=this.material.uniforms.depthTexture;t&&t.value!==e&&(t.value=e,this.material.needsUpdate=!0)}}const ue=new q(0,0,1),pe=new ne,ve=new q,ge=new q;new q;const ye=new e(1,1,1,1);class _e{set time(e){this.emissionState.time=e}get time(){return this.emissionState.time}get layers(){return this.rendererSettings.layers}get texture(){return this.rendererSettings.material.map}set texture(e){this.rendererSettings.material.map=e,this.neededToUpdateRender=!0}get material(){return this.rendererSettings.material}set material(e){this.rendererSettings.material=e,this.neededToUpdateRender=!0}get uTileCount(){return this.rendererSettings.uTileCount}set uTileCount(e){this.rendererSettings.uTileCount=e,this.neededToUpdateRender=!0}get vTileCount(){return this.rendererSettings.vTileCount}set vTileCount(e){this.rendererSettings.vTileCount=e,this.neededToUpdateRender=!0}get blendTiles(){return this.rendererSettings.blendTiles}set blendTiles(e){this.rendererSettings.blendTiles=e,this.neededToUpdateRender=!0}get softParticles(){return this.rendererSettings.softParticles}set softParticles(e){this.rendererSettings.softParticles=e,this.neededToUpdateRender=!0}get softNearFade(){return this.rendererSettings.softNearFade}set softNearFade(e){this.rendererSettings.softNearFade=e,this.neededToUpdateRender=!0}get softFarFade(){return this.rendererSettings.softFarFade}set softFarFade(e){this.rendererSettings.softFarFade=e,this.neededToUpdateRender=!0}get instancingGeometry(){return this.rendererSettings.instancingGeometry}set instancingGeometry(e){this.restart(),this.particles.length=0,this.rendererSettings.instancingGeometry=e,this.neededToUpdateRender=!0}get renderMode(){return this.rendererSettings.renderMode}set renderMode(t){if(this.rendererSettings.renderMode!==t){let i=!1;switch(this.rendererSettings.renderMode===ce.Trail&&(i=!0),this.rendererSettings.renderMode===ce.Mesh&&(this.startRotation=new J(0)),t){case ce.Trail:this.rendererEmitterSettings={startLength:new J(30),followLocalOrigin:!1},i=!0;break;case ce.Mesh:this.rendererEmitterSettings={geometry:new e(1,1)},this.startRotation=new Z(new q(0,1,0),new J(0));break;case ce.StretchedBillBoard:this.rendererEmitterSettings={speedFactor:0,lengthFactor:2};break;case ce.BillBoard:case ce.VerticalBillBoard:case ce.HorizontalBillBoard:this.rendererEmitterSettings={}}this.rendererSettings.renderMode=t,i&&(this.restart(),this.particles.length=0),this.neededToUpdateRender=!0}}get renderOrder(){return this.rendererSettings.renderOrder}set renderOrder(e){this.rendererSettings.renderOrder=e,this.neededToUpdateRender=!0}get blending(){return this.rendererSettings.material.blending}set blending(e){this.rendererSettings.material.blending=e,this.neededToUpdateRender=!0}constructor(e){var t,i,n,r,s,a,o,l,d,f,m,c,h,u,p,v,g,y,_,S,x,M,T,E,U,A;if(this.temp=new q,this.travelDistance=0,this.normalMatrix=new K,this.memory=[],this.listeners={},this.firstTimeUpdate=!0,this.autoDestroy=void 0!==e.autoDestroy&&e.autoDestroy,this.duration=null!==(t=e.duration)&&void 0!==t?t:1,this.looping=void 0===e.looping||e.looping,this.prewarm=void 0!==e.prewarm&&e.prewarm,this.startLife=null!==(i=e.startLife)&&void 0!==i?i:new J(5),this.startSpeed=null!==(n=e.startSpeed)&&void 0!==n?n:new J(0),this.startRotation=null!==(r=e.startRotation)&&void 0!==r?r:new J(0),this.startSize=null!==(s=e.startSize)&&void 0!==s?s:new J(1),this.startColor=null!==(a=e.startColor)&&void 0!==a?a:new Q(new $(1,1,1,1)),this.emissionOverTime=null!==(o=e.emissionOverTime)&&void 0!==o?o:new J(10),this.emissionOverDistance=null!==(l=e.emissionOverDistance)&&void 0!==l?l:new J(0),this.emissionBursts=null!==(d=e.emissionBursts)&&void 0!==d?d:[],this.onlyUsedByOther=null!==(f=e.onlyUsedByOther)&&void 0!==f&&f,this.emitterShape=null!==(m=e.shape)&&void 0!==m?m:new ee,this.behaviors=null!==(c=e.behaviors)&&void 0!==c?c:new Array,this.worldSpace=null!==(h=e.worldSpace)&&void 0!==h&&h,this.rendererEmitterSettings=null!==(u=e.rendererEmitterSettings)&&void 0!==u?u:{},e.renderMode===ce.StretchedBillBoard){const t=this.rendererEmitterSettings;void 0!==e.speedFactor&&(t.speedFactor=e.speedFactor),t.speedFactor=null!==(p=t.speedFactor)&&void 0!==p?p:0,t.lengthFactor=null!==(v=t.lengthFactor)&&void 0!==v?v:0}this.rendererSettings={instancingGeometry:null!==(g=e.instancingGeometry)&&void 0!==g?g:ye,renderMode:null!==(y=e.renderMode)&&void 0!==y?y:ce.BillBoard,renderOrder:null!==(_=e.renderOrder)&&void 0!==_?_:0,material:e.material,uTileCount:null!==(S=e.uTileCount)&&void 0!==S?S:1,vTileCount:null!==(x=e.vTileCount)&&void 0!==x?x:1,blendTiles:null!==(M=e.blendTiles)&&void 0!==M&&M,softParticles:null!==(T=e.softParticles)&&void 0!==T&&T,softNearFade:null!==(E=e.softNearFade)&&void 0!==E?E:0,softFarFade:null!==(U=e.softFarFade)&&void 0!==U?U:0,layers:null!==(A=e.layers)&&void 0!==A?A:new C},this.neededToUpdateRender=!0,this.particles=new Array,this.startTileIndex=e.startTileIndex||new J(0),this.emitter=new me(this),this.paused=!1,this.particleNum=0,this.emissionState={isBursting:!1,burstParticleIndex:0,burstParticleCount:0,burstIndex:0,burstWaveIndex:0,time:0,waitEmiting:0,travelDistance:0},this.emissionBursts.forEach((e=>e.count.startGen(this.memory))),this.emissionOverDistance.startGen(this.memory),this.emitEnded=!1,this.markForDestroy=!1,this.prewarmed=!1}pause(){this.paused=!0}play(){this.paused=!1}stop(){this.restart(),this.pause()}spawn(e,t,i){pe.setFromRotationMatrix(i);const n=ve,r=pe,s=ge;i.decompose(n,r,s);for(let a=0;a<e;a++){for(t.burstParticleIndex=a,this.particleNum++;this.particles.length<this.particleNum;)this.rendererSettings.renderMode===ce.Trail?this.particles.push(new te):this.particles.push(new ie);const e=this.particles[this.particleNum-1];if(e.reset(),e.speedModifier=1,this.startColor.startGen(e.memory),this.startColor.genColor(e.memory,e.startColor,this.emissionState.time),e.color.copy(e.startColor),this.startSpeed.startGen(e.memory),e.startSpeed=this.startSpeed.genValue(e.memory,t.time/this.duration),this.startLife.startGen(e.memory),e.life=this.startLife.genValue(e.memory,t.time/this.duration),e.age=0,this.startSize.startGen(e.memory),"vec3function"===this.startSize.type)this.startSize.genValue(e.memory,e.startSize,t.time/this.duration);else{const i=this.startSize.genValue(e.memory,t.time/this.duration);e.startSize.set(i,i,i)}if(this.startTileIndex.startGen(e.memory),e.uvTile=this.startTileIndex.genValue(e.memory),e.size.copy(e.startSize),this.rendererSettings.renderMode===ce.Mesh||this.rendererSettings.renderMode===ce.BillBoard||this.rendererSettings.renderMode===ce.VerticalBillBoard||this.rendererSettings.renderMode===ce.HorizontalBillBoard||this.rendererSettings.renderMode===ce.StretchedBillBoard){const i=e;this.startRotation.startGen(e.memory),this.rendererSettings.renderMode===ce.Mesh?(i.rotation instanceof ne||(i.rotation=new ne),"rotation"===this.startRotation.type?this.startRotation.genValue(e.memory,i.rotation,1,t.time/this.duration):i.rotation.setFromAxisAngle(ue,this.startRotation.genValue(i.memory,t.time/this.duration))):"rotation"===this.startRotation.type?i.rotation=0:i.rotation=this.startRotation.genValue(i.memory,t.time/this.duration)}else if(this.rendererSettings.renderMode===ce.Trail){const i=e;this.rendererEmitterSettings.startLength.startGen(i.memory),i.length=this.rendererEmitterSettings.startLength.genValue(i.memory,t.time/this.duration)}if(this.emitterShape.initialize(e,t),this.rendererSettings.renderMode===ce.Trail&&this.rendererEmitterSettings.followLocalOrigin){const t=e;t.localPosition=(new q).copy(t.position)}this.worldSpace?(e.position.applyMatrix4(i),e.startSize.multiply(s).abs(),e.size.copy(e.startSize),e.velocity.multiply(s).applyMatrix3(this.normalMatrix),e.rotation&&e.rotation instanceof ne&&e.rotation.multiplyQuaternions(pe,e.rotation)):this.onlyUsedByOther&&(e.parentMatrix=i);for(let t=0;t<this.behaviors.length;t++)this.behaviors[t].initialize(e,this)}}endEmit(){this.emitEnded=!0,this.autoDestroy&&(this.markForDestroy=!0),this.fire({type:"emitEnd",particleSystem:this})}dispose(){this._renderer&&this._renderer.deleteSystem(this),this.emitter.dispose(),this.emitter.parent&&this.emitter.parent.remove(this.emitter),this.fire({type:"destroy",particleSystem:this})}restart(){this.memory.length=0,this.paused=!1,this.particleNum=0,this.emissionState.isBursting=!1,this.emissionState.burstIndex=0,this.emissionState.burstWaveIndex=0,this.emissionState.time=0,this.emissionState.waitEmiting=0,this.behaviors.forEach((e=>{e.reset()})),this.emitEnded=!1,this.markForDestroy=!1,this.prewarmed=!1,this.emissionBursts.forEach((e=>e.count.startGen(this.memory))),this.emissionOverDistance.startGen(this.memory)}update(e){if(this.paused)return;let t=this.emitter;for(;t.parent;)t=t.parent;if("Scene"===t.type)if(this.firstTimeUpdate&&(this.firstTimeUpdate=!1,this.emitter.updateWorldMatrix(!0,!1)),this.emitEnded&&0===this.particleNum)this.markForDestroy&&this.emitter.parent&&this.dispose();else{if(this.looping&&this.prewarm&&!this.prewarmed){this.prewarmed=!0;for(let e=0;e<60*this.duration;e++)this.update(1/60)}e>.1&&(e=.1),this.neededToUpdateRender&&(this._renderer&&this._renderer.updateSystem(this),this.neededToUpdateRender=!1),this.onlyUsedByOther||this.emit(e,this.emissionState,this.emitter.matrixWorld),this.emitterShape.update(this,e);for(let t=0;t<this.behaviors.length;t++){this.behaviors[t].frameUpdate(e);for(let i=0;i<this.particleNum;i++)this.particles[i].died||this.behaviors[t].update(this.particles[i],e)}for(let t=0;t<this.particleNum;t++)this.rendererEmitterSettings.followLocalOrigin&&this.particles[t].localPosition?(this.particles[t].position.copy(this.particles[t].localPosition),this.particles[t].parentMatrix?this.particles[t].position.applyMatrix4(this.particles[t].parentMatrix):this.particles[t].position.applyMatrix4(this.emitter.matrixWorld)):this.particles[t].position.addScaledVector(this.particles[t].velocity,e*this.particles[t].speedModifier),this.particles[t].age+=e;if(this.rendererSettings.renderMode===ce.Trail)for(let e=0;e<this.particleNum;e++){this.particles[e].update()}for(let e=0;e<this.particleNum;e++){const t=this.particles[e];!t.died||t instanceof te&&0!==t.previous.length||(this.particles[e]=this.particles[this.particleNum-1],this.particles[this.particleNum-1]=t,this.particleNum--,e--,this.fire({type:"particleDied",particleSystem:this,particle:t}))}}else this.dispose()}emit(e,t,i){t.time>this.duration&&(this.looping?(t.time-=this.duration,t.burstIndex=0,this.behaviors.forEach((e=>{e.reset()}))):this.emitEnded||this.onlyUsedByOther||this.endEmit()),this.normalMatrix.getNormalMatrix(i);const n=Math.ceil(t.waitEmiting);for(this.spawn(n,t,i),t.waitEmiting-=n;t.burstIndex<this.emissionBursts.length&&this.emissionBursts[t.burstIndex].time<=t.time;){if(Math.random()<this.emissionBursts[t.burstIndex].probability){const e=this.emissionBursts[t.burstIndex].count.genValue(this.memory,this.time);t.isBursting=!0,t.burstParticleCount=e,this.spawn(e,t,i),t.isBursting=!1}t.burstIndex++}if(!this.emitEnded&&(t.waitEmiting+=e*this.emissionOverTime.genValue(this.memory,t.time/this.duration),null!=t.previousWorldPos)){this.temp.set(i.elements[12],i.elements[13],i.elements[14]),t.travelDistance+=t.previousWorldPos.distanceTo(this.temp);const e=this.emissionOverDistance.genValue(this.memory,t.time/this.duration);if(t.travelDistance*e>0){const i=Math.floor(t.travelDistance*e);t.travelDistance-=i/e,t.waitEmiting+=i}}void 0===t.previousWorldPos&&(t.previousWorldPos=new q),t.previousWorldPos.set(i.elements[12],i.elements[13],i.elements[14]),t.time+=e}toJSON(e,t={}){var i;if((void 0===e||"string"==typeof e)&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}}),e.materials[this.rendererSettings.material.uuid]=this.rendererSettings.material.toJSON(e),t.useUrlForImage&&void 0!==(null===(i=this.texture)||void 0===i?void 0:i.source)){const t=this.texture.source;e.images[t.uuid]={uuid:t.uuid,url:this.texture.image.url}}let n;n=this.renderMode===ce.Trail?{startLength:this.rendererEmitterSettings.startLength.toJSON(),followLocalOrigin:this.rendererEmitterSettings.followLocalOrigin}:this.renderMode===ce.Mesh?{}:this.renderMode===ce.StretchedBillBoard?{speedFactor:this.rendererEmitterSettings.speedFactor,lengthFactor:this.rendererEmitterSettings.lengthFactor}:{};const r=this.rendererSettings.instancingGeometry;return e.geometries&&!e.geometries[r.uuid]&&(e.geometries[r.uuid]=r.toJSON()),{version:"3.0",autoDestroy:this.autoDestroy,looping:this.looping,prewarm:this.prewarm,duration:this.duration,shape:this.emitterShape.toJSON(),startLife:this.startLife.toJSON(),startSpeed:this.startSpeed.toJSON(),startRotation:this.startRotation.toJSON(),startSize:this.startSize.toJSON(),startColor:this.startColor.toJSON(),emissionOverTime:this.emissionOverTime.toJSON(),emissionOverDistance:this.emissionOverDistance.toJSON(),emissionBursts:this.emissionBursts.map((e=>({time:e.time,count:e.count.toJSON(),probability:e.probability,interval:e.interval,cycle:e.cycle}))),onlyUsedByOther:this.onlyUsedByOther,instancingGeometry:this.rendererSettings.instancingGeometry.uuid,renderOrder:this.renderOrder,renderMode:this.renderMode,rendererEmitterSettings:n,material:this.rendererSettings.material.uuid,layers:this.layers.mask,startTileIndex:this.startTileIndex.toJSON(),uTileCount:this.uTileCount,vTileCount:this.vTileCount,blendTiles:this.blendTiles,softParticles:this.rendererSettings.softParticles,softFarFade:this.rendererSettings.softFarFade,softNearFade:this.rendererSettings.softNearFade,behaviors:this.behaviors.map((e=>e.toJSON())),worldSpace:this.worldSpace}}static fromJSON(e,t,i){var n,r;const s=re(e.shape,t);let a;if(e.renderMode===ce.Trail){const t=e.rendererEmitterSettings;a={startLength:null!=t.startLength?se(t.startLength):new J(30),followLocalOrigin:t.followLocalOrigin}}else e.renderMode===ce.Mesh?a={}:e.renderMode===ce.StretchedBillBoard?(a=e.rendererEmitterSettings,null!=e.speedFactor&&(a.speedFactor=e.speedFactor)):a={};const o=new C;e.layers&&(o.mask=e.layers);const l=new _e({autoDestroy:e.autoDestroy,looping:e.looping,prewarm:e.prewarm,duration:e.duration,shape:s,startLife:se(e.startLife),startSpeed:se(e.startSpeed),startRotation:ae(e.startRotation),startSize:ae(e.startSize),startColor:oe(e.startColor),emissionOverTime:se(e.emissionOverTime),emissionOverDistance:se(e.emissionOverDistance),emissionBursts:null===(n=e.emissionBursts)||void 0===n?void 0:n.map((e=>{var t,i,n;return{time:e.time,count:"number"==typeof e.count?new J(e.count):se(e.count),probability:null!==(t=e.probability)&&void 0!==t?t:1,interval:null!==(i=e.interval)&&void 0!==i?i:.1,cycle:null!==(n=e.cycle)&&void 0!==n?n:1}})),onlyUsedByOther:e.onlyUsedByOther,instancingGeometry:t.geometries[e.instancingGeometry],renderMode:e.renderMode,rendererEmitterSettings:a,renderOrder:e.renderOrder,layers:o,material:e.material?t.materials[e.material]:e.texture?new O({map:t.textures[e.texture],transparent:null===(r=e.transparent)||void 0===r||r,blending:e.blending,side:R}):new O({color:16777215,transparent:!0,blending:N,side:R}),startTileIndex:"number"==typeof e.startTileIndex?new J(e.startTileIndex):se(e.startTileIndex),uTileCount:e.uTileCount,vTileCount:e.vTileCount,blendTiles:e.blendTiles,softParticles:e.softParticles,softFarFade:e.softFarFade,softNearFade:e.softNearFade,behaviors:[],worldSpace:e.worldSpace});return l.behaviors=e.behaviors.map((e=>{const t=le(e,l);return t&&"EmitSubParticleSystem"===t.type&&(i[e.subParticleSystem]=t),t})).filter((e=>null!==e)),l}addBehavior(e){this.behaviors.push(e)}getRendererSettings(){return this.rendererSettings}addEventListener(e,t){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(t)}removeAllEventListeners(e){this.listeners[e]&&(this.listeners[e]=[])}removeEventListener(e,t){if(this.listeners[e]){const i=this.listeners[e].indexOf(t);-1!==i&&this.listeners[e].splice(i,1)}}fire(e){this.listeners[e.type]&&this.listeners[e.type].forEach((t=>t(e)))}clone(){const e=[];for(const r of this.emissionBursts){const t={};Object.assign(t,r),e.push(t)}const t=[];for(const r of this.behaviors)t.push(r.clone());let i;i=this.renderMode===ce.Trail?{startLength:this.rendererEmitterSettings.startLength.clone(),followLocalOrigin:this.rendererEmitterSettings.followLocalOrigin}:this.renderMode===ce.StretchedBillBoard?{lengthFactor:this.rendererEmitterSettings.lengthFactor,speedFactor:this.rendererEmitterSettings.speedFactor}:{};const n=new C;return n.mask=this.layers.mask,new _e({autoDestroy:this.autoDestroy,looping:this.looping,duration:this.duration,shape:this.emitterShape.clone(),startLife:this.startLife.clone(),startSpeed:this.startSpeed.clone(),startRotation:this.startRotation.clone(),startSize:this.startSize.clone(),startColor:this.startColor.clone(),emissionOverTime:this.emissionOverTime.clone(),emissionOverDistance:this.emissionOverDistance.clone(),emissionBursts:e,onlyUsedByOther:this.onlyUsedByOther,instancingGeometry:this.rendererSettings.instancingGeometry,renderMode:this.renderMode,renderOrder:this.renderOrder,rendererEmitterSettings:i,material:this.rendererSettings.material,startTileIndex:this.startTileIndex,uTileCount:this.uTileCount,vTileCount:this.vTileCount,blendTiles:this.blendTiles,softParticles:this.softParticles,softFarFade:this.softFarFade,softNearFade:this.softNearFade,behaviors:t,worldSpace:this.worldSpace,layers:n})}}var Se="\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <alphatest_pars_fragment>\n\n#include <tile_pars_fragment>\n#include <soft_pars_fragment>\n\nvoid main() {\n\n    #include <clipping_planes_fragment>\n    \n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vColor;\n    \n    #include <logdepthbuf_fragment>\n    \n    #include <tile_fragment>\n    #include <alphatest_fragment>\n\n    outgoingLight = diffuseColor.rgb;\n    \n    #ifdef USE_COLOR_AS_ALPHA\n    gl_FragColor = vec4( outgoingLight, diffuseColor.r );\n    #else\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #endif\n    \n    #include <soft_fragment>\n    #include <tonemapping_fragment>\n}\n",xe="\n#define STANDARD\n\n#ifdef PHYSICAL\n#define IOR\n#define USE_SPECULAR\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef IOR\nuniform float ior;\n#endif\n\n#ifdef USE_SPECULAR\nuniform float specularIntensity;\nuniform vec3 specularColor;\n\n#ifdef USE_SPECULAR_COLORMAP\nuniform sampler2D specularColorMap;\n#endif\n\n#ifdef USE_SPECULAR_INTENSITYMAP\nuniform sampler2D specularIntensityMap;\n#endif\n#endif\n\n#ifdef USE_CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_DISPERSION\nuniform float dispersion;\n#endif\n\n#ifdef USE_IRIDESCENCE\nuniform float iridescence;\nuniform float iridescenceIOR;\nuniform float iridescenceThicknessMinimum;\nuniform float iridescenceThicknessMaximum;\n#endif\n\n#ifdef USE_SHEEN\nuniform vec3 sheenColor;\nuniform float sheenRoughness;\n\n#ifdef USE_SHEEN_COLORMAP\nuniform sampler2D sheenColorMap;\n#endif\n\n#ifdef USE_SHEEN_ROUGHNESSMAP\nuniform sampler2D sheenRoughnessMap;\n#endif\n#endif\n\n#ifdef USE_ANISOTROPY\nuniform vec2 anisotropyVector;\n\n#ifdef USE_ANISOTROPYMAP\nuniform sampler2D anisotropyMap;\n#endif\n#endif\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\nvec4 diffuseColor = vec4( diffuse, opacity );\n#include <clipping_planes_fragment>\n\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\nvec3 totalEmissiveRadiance = emissive;\n\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <alphahash_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n\n// accumulation\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n\n// modulation\n#include <aomap_fragment>\n\nvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\nvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n#include <transmission_fragment>\n\nvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n#ifdef USE_SHEEN\n\n// Sheen energy compensation approximation calculation can be found at the end of\n// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\noutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\n#endif\n\n#ifdef USE_CLEARCOAT\n\nfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\nvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\noutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\n#endif\n\n#include <opaque_fragment>\n#include <tonemapping_fragment>\n#include <colorspace_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",Me="\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n\nattribute vec3 offset;\nattribute vec4 rotation;\nattribute vec3 size;\n#include <tile_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n    #include <tile_vertex>\n    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;\n    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;\n    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;\n    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;\n    float sx = size.x, sy = size.y, sz = size.z;\n\n    mat4 particleMatrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column\n                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column\n                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column\n                      offset.x, offset.y, offset.z, 1.0);\n\n#include <color_vertex>\n#include <morphinstance_vertex>\n#include <morphcolor_vertex>\n#include <batching_vertex>\n\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n\n\t// replace defaultnormal_vertex\n\tvec3 transformedNormal = objectNormal;\n    mat3 m = mat3( particleMatrix );\n    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n    transformedNormal = m * transformedNormal;\n    transformedNormal = normalMatrix * transformedNormal;\n    #ifdef FLIP_SIDED\n        transformedNormal = - transformedNormal;\n    #endif\n    #ifdef USE_TANGENT\n        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n        #ifdef FLIP_SIDED\n        transformedTangent = - transformedTangent;\n        #endif\n    #endif\n\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\n\t// replace include <project_vertex>\n  vec4 mvPosition = vec4( transformed, 1.0 );\n  mvPosition = modelViewMatrix * (particleMatrix * mvPosition);\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t\n\tvViewPosition = - mvPosition.xyz;\n\t\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n    vWorldPosition = worldPosition.xyz;\n#endif\n}\n";function Te(e){return 0===e?"uv":`uv${e}`}class Ee extends j{constructor(e){super(e)}onBeforeCompile(e,t){super.onBeforeCompile(e,t),e.vertexShader=Me,e.fragmentShader=xe}}class Ue extends X{constructor(e){super(e)}onBeforeCompile(e,t){super.onBeforeCompile(e,t),e.vertexShader=Me,e.fragmentShader=xe}}class Ae extends he{constructor(e){super(e),this.vector_=new q,this.vector2_=new q,this.vector3_=new q,this.quaternion_=new ne,this.quaternion2_=new ne,this.quaternion3_=new ne,this.rotationMat_=new K,this.rotationMat2_=new K,this.maxParticles=1e3,this.setupBuffers(),this.rebuildMaterial()}buildExpandableBuffers(){this.offsetBuffer=new p(new Float32Array(3*this.maxParticles),3),this.offsetBuffer.setUsage(F),this.geometry.setAttribute("offset",this.offsetBuffer),this.colorBuffer=new p(new Float32Array(4*this.maxParticles),4),this.colorBuffer.setUsage(F),this.geometry.setAttribute("color",this.colorBuffer),this.settings.renderMode===ce.Mesh?(this.rotationBuffer=new p(new Float32Array(4*this.maxParticles),4),this.rotationBuffer.setUsage(F),this.geometry.setAttribute("rotation",this.rotationBuffer)):this.settings.renderMode!==ce.BillBoard&&this.settings.renderMode!==ce.HorizontalBillBoard&&this.settings.renderMode!==ce.VerticalBillBoard&&this.settings.renderMode!==ce.StretchedBillBoard||(this.rotationBuffer=new p(new Float32Array(this.maxParticles),1),this.rotationBuffer.setUsage(F),this.geometry.setAttribute("rotation",this.rotationBuffer)),this.sizeBuffer=new p(new Float32Array(3*this.maxParticles),3),this.sizeBuffer.setUsage(F),this.geometry.setAttribute("size",this.sizeBuffer),this.uvTileBuffer=new p(new Float32Array(this.maxParticles),1),this.uvTileBuffer.setUsage(F),this.geometry.setAttribute("uvTile",this.uvTileBuffer),this.settings.renderMode===ce.StretchedBillBoard&&(this.velocityBuffer=new p(new Float32Array(4*this.maxParticles),4),this.velocityBuffer.setUsage(F),this.geometry.setAttribute("velocity",this.velocityBuffer))}setupBuffers(){this.geometry&&this.geometry.dispose(),this.geometry=new D,this.geometry.setIndex(this.settings.instancingGeometry.getIndex()),this.settings.instancingGeometry.hasAttribute("normal")&&this.geometry.setAttribute("normal",this.settings.instancingGeometry.getAttribute("normal")),this.geometry.setAttribute("position",this.settings.instancingGeometry.getAttribute("position")),this.geometry.setAttribute("uv",this.settings.instancingGeometry.getAttribute("uv")),this.buildExpandableBuffers()}expandBuffers(e){for(;e>=this.maxParticles;)this.maxParticles*=2;this.setupBuffers()}rebuildMaterial(){this.layers.mask=this.settings.layers.mask;const e={},t={};"MeshStandardMaterial"!==this.settings.material.type&&"MeshPhysicalMaterial"!==this.settings.material.type&&(e.map=new V(this.settings.material.map)),this.settings.material.alphaTest&&(t.USE_ALPHATEST="",e.alphaTest=new V(this.settings.material.alphaTest)),t.USE_UV="";const i=this.settings.uTileCount,n=this.settings.vTileCount;let r;if((i>1||n>1)&&(t.UV_TILE="",e.tileCount=new V(new de(i,n))),this.settings.material.defines&&void 0!==this.settings.material.defines.USE_COLOR_AS_ALPHA&&(t.USE_COLOR_AS_ALPHA=""),this.settings.material.normalMap&&(t.USE_NORMALMAP="",t.NORMALMAP_UV=Te(this.settings.material.normalMap.channel),e.normalMapTransform=new V((new K).copy(this.settings.material.normalMap.matrix))),this.settings.material.map&&(t.USE_MAP="",this.settings.blendTiles&&(t.TILE_BLEND=""),t.MAP_UV=Te(this.settings.material.map.channel),e.mapTransform=new V((new K).copy(this.settings.material.map.matrix))),t.USE_COLOR_ALPHA="",this.settings.softParticles){t.SOFT_PARTICLES="";const i=this.settings.softNearFade,n=1/(this.settings.softFarFade-this.settings.softNearFade);e.softParams=new V(new de(i,n)),e.depthTexture=new V(null);const s=e.projParams=new V(new $);r=(e,t,i)=>{s.value.set(i.near,i.far,0,0)}}let s=!1;if(this.settings.renderMode===ce.BillBoard||this.settings.renderMode===ce.VerticalBillBoard||this.settings.renderMode===ce.HorizontalBillBoard||this.settings.renderMode===ce.Mesh){let i,n;this.settings.renderMode===ce.Mesh?"MeshStandardMaterial"===this.settings.material.type||"MeshPhysicalMaterial"===this.settings.material.type?(t.USE_COLOR="",i=Me,n=xe,s=!0):(i="\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute vec4 rotation;\nattribute vec3 size;\n// attribute vec4 color;\n\nvoid main() {\n\n    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;\n    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;\n    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;\n    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;\n    float sx = size.x, sy = size.y, sz = size.z;\n    \n    mat4 matrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column\n                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column\n                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column\n                      offset.x, offset.y, offset.z, 1.0);\n    \n    vec4 mvPosition = modelViewMatrix * (matrix * vec4( position, 1.0 ));\n\n\tvColor = color;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n    #include <tile_vertex>\n    #include <soft_vertex>\n}\n",n=Se):(i="\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute float rotation;\nattribute vec3 size;\n\nvoid main() {\n\t\n    vec2 alignedPosition = position.xy * size.xy;\n    \n    vec2 rotatedPosition;\n    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n#ifdef HORIZONTAL\n    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );\n    mvPosition.x += rotatedPosition.x;\n    mvPosition.z -= rotatedPosition.y;\n    mvPosition = viewMatrix * mvPosition;\n#elif defined(VERTICAL)\n    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );\n    mvPosition.y += rotatedPosition.y;\n    mvPosition = viewMatrix * mvPosition;\n    mvPosition.x += rotatedPosition.x;\n#else\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    mvPosition.xy += rotatedPosition;\n#endif\n\n\tvColor = color;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\n\t#include <clipping_planes_vertex>\n\n\t#include <tile_vertex>\n\t#include <soft_vertex>\n}\n",n=Se),this.settings.renderMode===ce.VerticalBillBoard?t.VERTICAL="":this.settings.renderMode===ce.HorizontalBillBoard&&(t.HORIZONTAL="");let r=!1;this.settings.renderMode===ce.Mesh&&("MeshStandardMaterial"===this.settings.material.type?(this.material=new Ee({}),this.material.copy(this.settings.material),this.material.uniforms=e,this.material.defines=t,r=!0):"MeshPhysicalMaterial"===this.settings.material.type&&(this.material=new Ue({}),this.material.copy(this.settings.material),this.material.uniforms=e,this.material.defines=t,r=!0)),r||(this.material=new k({uniforms:e,defines:t,vertexShader:i,fragmentShader:n,transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,blending:this.settings.material.blending,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha,side:this.settings.material.side,alphaTest:this.settings.material.alphaTest,depthTest:this.settings.material.depthTest,lights:s}))}else{if(this.settings.renderMode!==ce.StretchedBillBoard)throw new Error("render mode unavailable");e.speedFactor=new V(1),this.material=new k({uniforms:e,defines:t,vertexShader:"\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute float rotation;\nattribute vec3 size;\nattribute vec4 velocity;\n\nuniform float speedFactor;\n\nvoid main() {\n    float lengthFactor = velocity.w;\n    float avgSize = (size.x + size.y) * 0.5;\n#ifdef USE_SKEW\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    vec3 viewVelocity = normalMatrix * velocity.xyz;\n\n    vec3 scaledPos = vec3(position.xy * size.xy, position.z);\n    float vlength = length(viewVelocity);\n    vec3 projVelocity =  dot(scaledPos, viewVelocity) * viewVelocity / vlength;\n    mvPosition.xyz += scaledPos + projVelocity * (speedFactor / avgSize + lengthFactor / vlength);\n#else\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    vec3 viewVelocity = normalMatrix * velocity.xyz;\n    float vlength = length(viewVelocity); \n    mvPosition.xyz += position.y * normalize(cross(mvPosition.xyz, viewVelocity)) * avgSize; // switch the cross to  match unity implementation\n    mvPosition.xyz -= (position.x + 0.5) * viewVelocity * (1.0 + lengthFactor / vlength) * avgSize; // minus position.x to match unity implementation\n#endif\n\tvColor = color;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <tile_vertex>\n\t#include <soft_vertex>\n}\n",fragmentShader:Se,transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,blending:this.settings.material.blending,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha,side:this.settings.material.side,alphaTest:this.settings.material.alphaTest,depthTest:this.settings.material.depthTest})}this.material&&r&&(this.material.onBeforeRender=r)}update(){let e=0,t=0;this.systems.forEach((e=>{t+=e.particleNum})),t>this.maxParticles&&this.expandBuffers(t),this.systems.forEach((t=>{t.emitter.updateMatrixWorld&&(t.emitter.updateWorldMatrix(!0,!1),t.emitter.updateMatrixWorld(!0));const i=t.particles,n=t.particleNum,r=this.quaternion2_,s=this.vector2_,a=this.vector3_;t.emitter.matrixWorld.decompose(s,r,a),this.rotationMat_.setFromMatrix4(t.emitter.matrixWorld);for(let o=0;o<n;o++,e++){const n=i[o];if(this.settings.renderMode===ce.Mesh){let i;if(t.worldSpace)i=n.rotation;else{let e;e=n.parentMatrix?this.quaternion3_.setFromRotationMatrix(n.parentMatrix):r,i=this.quaternion_,i.copy(e).multiply(n.rotation)}this.rotationBuffer.setXYZW(e,i.x,i.y,i.z,i.w)}else this.settings.renderMode!==ce.StretchedBillBoard&&this.settings.renderMode!==ce.VerticalBillBoard&&this.settings.renderMode!==ce.HorizontalBillBoard&&this.settings.renderMode!==ce.BillBoard||this.rotationBuffer.setX(e,n.rotation);let s;if(t.worldSpace?s=n.position:(s=this.vector_,n.parentMatrix?s.copy(n.position).applyMatrix4(n.parentMatrix):s.copy(n.position).applyMatrix4(t.emitter.matrixWorld)),this.offsetBuffer.setXYZ(e,s.x,s.y,s.z),this.colorBuffer.setXYZW(e,n.color.x,n.color.y,n.color.z,n.color.w),t.worldSpace||n.parentMatrix?this.sizeBuffer.setXYZ(e,n.size.x,n.size.y,n.size.z):this.sizeBuffer.setXYZ(e,n.size.x*Math.abs(a.x),n.size.y*Math.abs(a.y),n.size.z*Math.abs(a.z)),this.uvTileBuffer.setX(e,n.uvTile),this.settings.renderMode===ce.StretchedBillBoard&&this.velocityBuffer){let i=t.rendererEmitterSettings.speedFactor;0===i&&(i=.001);const r=t.rendererEmitterSettings.lengthFactor;let s;t.worldSpace?s=n.velocity:(s=this.vector_,n.parentMatrix?(this.rotationMat2_.setFromMatrix4(n.parentMatrix),s.copy(n.velocity).applyMatrix3(this.rotationMat2_)):s.copy(n.velocity).applyMatrix3(this.rotationMat_)),this.velocityBuffer.setXYZW(e,s.x*i,s.y*i,s.z*i,r)}}})),this.geometry.instanceCount=e,e>0&&(this.offsetBuffer.clearUpdateRanges(),this.offsetBuffer.addUpdateRange(0,3*e),this.offsetBuffer.needsUpdate=!0,this.sizeBuffer.clearUpdateRanges(),this.sizeBuffer.addUpdateRange(0,3*e),this.sizeBuffer.needsUpdate=!0,this.colorBuffer.clearUpdateRanges(),this.colorBuffer.addUpdateRange(0,4*e),this.colorBuffer.needsUpdate=!0,this.uvTileBuffer.clearUpdateRanges(),this.uvTileBuffer.addUpdateRange(0,e),this.uvTileBuffer.needsUpdate=!0,this.settings.renderMode===ce.StretchedBillBoard&&this.velocityBuffer&&(this.velocityBuffer.clearUpdateRanges(),this.velocityBuffer.addUpdateRange(0,4*e),this.velocityBuffer.needsUpdate=!0),this.settings.renderMode===ce.Mesh?(this.rotationBuffer.clearUpdateRanges(),this.rotationBuffer.addUpdateRange(0,4*e),this.rotationBuffer.needsUpdate=!0):this.settings.renderMode!==ce.StretchedBillBoard&&this.settings.renderMode!==ce.HorizontalBillBoard&&this.settings.renderMode!==ce.VerticalBillBoard&&this.settings.renderMode!==ce.BillBoard||(this.rotationBuffer.clearUpdateRanges(),this.rotationBuffer.addUpdateRange(0,e),this.rotationBuffer.needsUpdate=!0))}dispose(){this.geometry.dispose()}}class Pe extends he{constructor(e){super(e),this.vector_=new q,this.vector2_=new q,this.vector3_=new q,this.quaternion_=new ne,this.maxParticles=1e4,this.setupBuffers(),this.rebuildMaterial()}setupBuffers(){this.geometry&&this.geometry.dispose(),this.geometry=new H,this.indexBuffer=new G(new Uint32Array(6*this.maxParticles),1),this.indexBuffer.setUsage(F),this.geometry.setIndex(this.indexBuffer),this.positionBuffer=new G(new Float32Array(6*this.maxParticles),3),this.positionBuffer.setUsage(F),this.geometry.setAttribute("position",this.positionBuffer),this.previousBuffer=new G(new Float32Array(6*this.maxParticles),3),this.previousBuffer.setUsage(F),this.geometry.setAttribute("previous",this.previousBuffer),this.nextBuffer=new G(new Float32Array(6*this.maxParticles),3),this.nextBuffer.setUsage(F),this.geometry.setAttribute("next",this.nextBuffer),this.widthBuffer=new G(new Float32Array(2*this.maxParticles),1),this.widthBuffer.setUsage(F),this.geometry.setAttribute("width",this.widthBuffer),this.sideBuffer=new G(new Float32Array(2*this.maxParticles),1),this.sideBuffer.setUsage(F),this.geometry.setAttribute("side",this.sideBuffer),this.uvBuffer=new G(new Float32Array(4*this.maxParticles),2),this.uvBuffer.setUsage(F),this.geometry.setAttribute("uv",this.uvBuffer),this.colorBuffer=new G(new Float32Array(8*this.maxParticles),4),this.colorBuffer.setUsage(F),this.geometry.setAttribute("color",this.colorBuffer)}expandBuffers(e){for(;e>=this.maxParticles;)this.maxParticles*=2;this.setupBuffers()}rebuildMaterial(){this.layers.mask=this.settings.layers.mask;const e={lineWidth:{value:1},map:{value:null},useMap:{value:0},alphaMap:{value:null},useAlphaMap:{value:0},resolution:{value:new de(1,1)},sizeAttenuation:{value:1},visibility:{value:1},alphaTest:{value:0}},t={USE_UV:"",USE_COLOR_ALPHA:""};if(this.settings.material.map&&(t.USE_MAP="",t.MAP_UV=Te(this.settings.material.map.channel),e.map=new V(this.settings.material.map),e.mapTransform=new V((new K).copy(this.settings.material.map.matrix))),this.settings.material.defines&&void 0!==this.settings.material.defines.USE_COLOR_AS_ALPHA&&(t.USE_COLOR_AS_ALPHA=""),this.settings.renderMode!==ce.Trail)throw new Error("render mode unavailable");this.material=new k({uniforms:e,defines:t,vertexShader:"\n#include <common>\n#include <tile_pars_vertex>\n#include <color_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <fog_pars_vertex>\n\nattribute vec3 previous;\nattribute vec3 next;\nattribute float side;\nattribute float width;\n\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform float sizeAttenuation;\n    \nvec2 fix(vec4 i, float aspect) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n    return res;\n}\n    \nvoid main() {\n\n    #include <tile_vertex>\n    \n    float aspect = resolution.x / resolution.y;\n\n    vColor = color;\n\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec4 finalPosition = m * vec4( position, 1.0 );\n    vec4 prevPos = m * vec4( previous, 1.0 );\n    vec4 nextPos = m * vec4( next, 1.0 );\n\n    vec2 currentP = fix( finalPosition, aspect );\n    vec2 prevP = fix( prevPos, aspect );\n    vec2 nextP = fix( nextPos, aspect );\n\n    float w = lineWidth * width;\n\n    vec2 dir;\n    if( nextP == currentP ) dir = normalize( currentP - prevP );\n    else if( prevP == currentP ) dir = normalize( nextP - currentP );\n    else {\n        vec2 dir1 = normalize( currentP - prevP );\n        vec2 dir2 = normalize( nextP - currentP );\n        dir = normalize( dir1 + dir2 );\n\n        vec2 perp = vec2( -dir1.y, dir1.x );\n        vec2 miter = vec2( -dir.y, dir.x );\n        //w = clamp( w / dot( miter, perp ), 0., 4., * lineWidth * width );\n\n    }\n\n    //vec2 normal = ( cross( vec3( dir, 0. ) vec3( 0., 0., 1. ) ) ).xy;\n    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );\n    normal.xy *= .5 * w;\n    normal *= projectionMatrix;\n    if( sizeAttenuation == 0. ) {\n        normal.xy *= finalPosition.w;\n        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;\n    }\n\n    finalPosition.xy += normal.xy * side;\n\n    gl_Position = finalPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    \n\t#include <fog_vertex>\n}",fragmentShader:"\n\n#include <common>\n#include <tile_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nuniform sampler2D alphaMap;\nuniform float useAlphaMap;\nuniform float visibility;\nuniform float alphaTest;\n\nvarying vec4 vColor;\n    \nvoid main() {\n    #include <clipping_planes_fragment>\n    #include <logdepthbuf_fragment>\n\n    vec4 diffuseColor = vColor;\n    \n    #ifdef USE_MAP\n    #include <tile_fragment>\n    #ifndef USE_COLOR_AS_ALPHA\n    #endif\n    #endif\n    if( useAlphaMap == 1. ) diffuseColor.a *= texture2D( alphaMap, vUv).a;\n    if( diffuseColor.a < alphaTest ) discard;\n    gl_FragColor = diffuseColor;\n\n    #include <fog_fragment>\n    #include <tonemapping_fragment>\n}",transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,side:this.settings.material.side,blending:this.settings.material.blending||N,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha})}update(){let e=0,t=0,i=0;this.systems.forEach((e=>{for(let t=0;t<e.particleNum;t++)i+=2*e.particles[t].previous.length})),i>this.maxParticles&&this.expandBuffers(i),this.systems.forEach((i=>{i.emitter.updateMatrixWorld&&(i.emitter.updateWorldMatrix(!0,!1),i.emitter.updateMatrixWorld(!0));const n=this.quaternion_,r=this.vector2_,s=this.vector3_;i.emitter.matrixWorld.decompose(r,n,s);const a=i.particles,o=i.particleNum,l=this.settings.uTileCount,d=this.settings.vTileCount,f=1/l,m=1/d;for(let c=0;c<o;c++){const n=a[c],r=n.uvTile%d,o=Math.floor(n.uvTile/d+.001),l=n.previous.values();let h,u=l.next(),p=u.value,v=p;u.done||(u=l.next()),h=void 0!==u.value?u.value:v;for(let a=0;a<n.previous.length;a++,e+=2){if(this.positionBuffer.setXYZ(e,v.position.x,v.position.y,v.position.z),this.positionBuffer.setXYZ(e+1,v.position.x,v.position.y,v.position.z),i.worldSpace?(this.positionBuffer.setXYZ(e,v.position.x,v.position.y,v.position.z),this.positionBuffer.setXYZ(e+1,v.position.x,v.position.y,v.position.z)):(n.parentMatrix?this.vector_.copy(v.position).applyMatrix4(n.parentMatrix):this.vector_.copy(v.position).applyMatrix4(i.emitter.matrixWorld),this.positionBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.positionBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),i.worldSpace?(this.previousBuffer.setXYZ(e,p.position.x,p.position.y,p.position.z),this.previousBuffer.setXYZ(e+1,p.position.x,p.position.y,p.position.z)):(n.parentMatrix?this.vector_.copy(p.position).applyMatrix4(n.parentMatrix):this.vector_.copy(p.position).applyMatrix4(i.emitter.matrixWorld),this.previousBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.previousBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),i.worldSpace?(this.nextBuffer.setXYZ(e,h.position.x,h.position.y,h.position.z),this.nextBuffer.setXYZ(e+1,h.position.x,h.position.y,h.position.z)):(n.parentMatrix?this.vector_.copy(h.position).applyMatrix4(n.parentMatrix):this.vector_.copy(h.position).applyMatrix4(i.emitter.matrixWorld),this.nextBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.nextBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),this.sideBuffer.setX(e,1),this.sideBuffer.setX(e+1,-1),i.worldSpace)this.widthBuffer.setX(e,v.size),this.widthBuffer.setX(e+1,v.size);else if(n.parentMatrix)this.widthBuffer.setX(e,v.size),this.widthBuffer.setX(e+1,v.size);else{const t=(Math.abs(s.x)+Math.abs(s.y)+Math.abs(s.z))/3;this.widthBuffer.setX(e,v.size*t),this.widthBuffer.setX(e+1,v.size*t)}this.uvBuffer.setXY(e,(a/n.previous.length+r)*f,(d-o-1)*m),this.uvBuffer.setXY(e+1,(a/n.previous.length+r)*f,(d-o)*m),this.colorBuffer.setXYZW(e,v.color.x,v.color.y,v.color.z,v.color.w),this.colorBuffer.setXYZW(e+1,v.color.x,v.color.y,v.color.z,v.color.w),a+1<n.previous.length&&(this.indexBuffer.setX(3*t,e),this.indexBuffer.setX(3*t+1,e+1),this.indexBuffer.setX(3*t+2,e+2),t++,this.indexBuffer.setX(3*t,e+2),this.indexBuffer.setX(3*t+1,e+1),this.indexBuffer.setX(3*t+2,e+3),t++),p=v,v=h,u.done||(u=l.next(),void 0!==u.value&&(h=u.value))}}})),this.positionBuffer.clearUpdateRanges(),this.positionBuffer.addUpdateRange(0,3*e),this.positionBuffer.needsUpdate=!0,this.previousBuffer.clearUpdateRanges(),this.previousBuffer.addUpdateRange(0,3*e),this.previousBuffer.needsUpdate=!0,this.nextBuffer.clearUpdateRanges(),this.nextBuffer.addUpdateRange(0,3*e),this.nextBuffer.needsUpdate=!0,this.sideBuffer.clearUpdateRanges(),this.sideBuffer.addUpdateRange(0,e),this.sideBuffer.needsUpdate=!0,this.widthBuffer.clearUpdateRanges(),this.widthBuffer.addUpdateRange(0,e),this.widthBuffer.needsUpdate=!0,this.uvBuffer.clearUpdateRanges(),this.uvBuffer.addUpdateRange(0,2*e),this.uvBuffer.needsUpdate=!0,this.colorBuffer.clearUpdateRanges(),this.colorBuffer.addUpdateRange(0,4*e),this.colorBuffer.needsUpdate=!0,this.indexBuffer.clearUpdateRanges(),this.indexBuffer.addUpdateRange(0,3*t),this.indexBuffer.needsUpdate=!0,this.geometry.setDrawRange(0,3*t)}dispose(){this.geometry.dispose()}}class be{get geometry(){return this._geometry}set geometry(e){if(this._geometry=e,void 0===e)return;if("string"==typeof e)return;const t=new I;this._triangleIndexToArea.length=0;let i=0;if(!e.getIndex())return;const n=e.getIndex().array,r=n.length/3;this._triangleIndexToArea.push(0);for(let s=0;s<r;s++)t.setFromAttributeAndIndices(e.getAttribute("position"),n[3*s],n[3*s+1],n[3*s+2]),i+=t.getArea(),this._triangleIndexToArea.push(i);e.userData.triangleIndexToArea=this._triangleIndexToArea}constructor(e){this.type="mesh_surface",this._triangleIndexToArea=[],this._tempA=new L,this._tempB=new L,this._tempC=new L,e&&(this.geometry=e)}initialize(e){const t=this._geometry;if(!t||null===t.getIndex())return e.position.set(0,0,0),void e.velocity.set(0,0,1).multiplyScalar(e.startSpeed);const i=this._triangleIndexToArea.length-1;let n=0,r=i;const s=Math.random()*this._triangleIndexToArea[i];for(;n+1<r;){const e=Math.floor((n+r)/2);s<this._triangleIndexToArea[e]?r=e:n=e}let a=Math.random(),o=Math.random();a+o>1&&(a=1-a,o=1-o);const l=t.getIndex().array[3*n],d=t.getIndex().array[3*n+1],f=t.getIndex().array[3*n+2],m=t.getAttribute("position");this._tempA.fromBufferAttribute(m,l),this._tempB.fromBufferAttribute(m,d),this._tempC.fromBufferAttribute(m,f),this._tempB.sub(this._tempA),this._tempC.sub(this._tempA),this._tempA.addScaledVector(this._tempB,a).addScaledVector(this._tempC,o),e.position.copy(this._tempA),this._tempA.copy(this._tempB).cross(this._tempC).normalize(),e.velocity.copy(this._tempA).normalize().multiplyScalar(e.startSpeed)}toJSON(){return{type:"mesh_surface",mesh:this._geometry?this._geometry.uuid:""}}static fromJSON(e,t){return new be(t.geometries[e.geometry])}clone(){return new be(this._geometry)}update(e,t){}}Y({id:"three.quarks",initialize:()=>{},emitterShapes:[{type:"mesh_surface",params:[["geometry",["geometry"]]],constructor:be,loadJSON:be.fromJSON}],behaviors:[]});class we extends i{constructor(){super(),this.batches=[],this.systemToBatchIndex=new Map,this.type="BatchedRenderer",this.depthTexture=null}static equals(e,t){return e.material.side===t.material.side&&e.material.blending===t.material.blending&&e.material.blendSrc===t.material.blendSrc&&e.material.blendDst===t.material.blendDst&&e.material.blendEquation===t.material.blendEquation&&e.material.premultipliedAlpha===t.material.premultipliedAlpha&&e.material.transparent===t.material.transparent&&e.material.depthTest===t.material.depthTest&&e.material.type===t.material.type&&e.material.alphaTest===t.material.alphaTest&&e.material.map===t.material.map&&e.renderMode===t.renderMode&&e.blendTiles===t.blendTiles&&e.softParticles===t.softParticles&&e.softFarFade===t.softFarFade&&e.softNearFade===t.softNearFade&&e.uTileCount===t.uTileCount&&e.vTileCount===t.vTileCount&&e.instancingGeometry===t.instancingGeometry&&e.renderOrder===t.renderOrder&&e.layers.mask===t.layers.mask}addSystem(e){e._renderer=this;const t=e.getRendererSettings();for(let n=0;n<this.batches.length;n++)if(we.equals(this.batches[n].settings,t))return this.batches[n].addSystem(e),void this.systemToBatchIndex.set(e,n);let i;switch(t.renderMode){case ce.Trail:i=new Pe(t);break;case ce.Mesh:case ce.BillBoard:case ce.VerticalBillBoard:case ce.HorizontalBillBoard:case ce.StretchedBillBoard:i=new Ae(t)}this.depthTexture&&i.applyDepthTexture(this.depthTexture),i.addSystem(e),this.batches.push(i),this.systemToBatchIndex.set(e,this.batches.length-1),this.add(i)}deleteSystem(e){const t=this.systemToBatchIndex.get(e);null!=t&&(this.batches[t].removeSystem(e),this.systemToBatchIndex.delete(e))}setDepthTexture(e){this.depthTexture=e;for(const t of this.batches)t.applyDepthTexture(e)}updateSystem(e){this.deleteSystem(e),this.addSystem(e)}update(e){this.systemToBatchIndex.forEach(((t,i)=>{i.update(e)}));for(let t=0;t<this.batches.length;t++)this.batches[t].update()}}class Be extends t{constructor(e){super(e)}linkReference(e){const t={};e.traverse((function(e){t[e.uuid]=e})),e.traverse((function(e){if("ParticleEmitter"===e.type){const i=e.system;i.emitterShape;for(let e=0;e<i.behaviors.length;e++)i.behaviors[e]instanceof W&&(i.behaviors[e].subParticleSystem=t[i.behaviors[e].subParticleSystem])}}))}parse(e,t){const i=super.parse(e,t);return this.linkReference(i),i}parseObject(e,t,C,O,R){let N,z,I;function L(e){return void 0===t[e]&&console.warn("THREE.ObjectLoader: Undefined geometry",e),t[e]}function F(e){if(void 0!==e){if(Array.isArray(e)){const t=[];for(let i=0,n=e.length;i<n;i++){const n=e[i];void 0===C[n]&&console.warn("THREE.ObjectLoader: Undefined material",n),t.push(C[n])}return t}return void 0===C[e]&&console.warn("THREE.ObjectLoader: Undefined material",e),C[e]}}function D(e){return void 0===O[e]&&console.warn("THREE.ObjectLoader: Undefined texture",e),O[e]}const V={textures:O,geometries:t,materials:C},k={};switch(e.type){case"ParticleEmitter":N=_e.fromJSON(e.ps,V,k).emitter;break;case"Scene":N=new P,void 0!==e.background&&(Number.isInteger(e.background)?N.background=new b(e.background):N.background=D(e.background)),void 0!==e.environment&&(N.environment=D(e.environment)),void 0!==e.fog&&("Fog"===e.fog.type?N.fog=new w(e.fog.color,e.fog.near,e.fog.far):"FogExp2"===e.fog.type&&(N.fog=new B(e.fog.color,e.fog.density)),""!==e.fog.name&&(N.fog.name=e.fog.name)),void 0!==e.backgroundBlurriness&&(N.backgroundBlurriness=e.backgroundBlurriness),void 0!==e.backgroundIntensity&&(N.backgroundIntensity=e.backgroundIntensity),void 0!==e.backgroundRotation&&N.backgroundRotation.fromArray(e.backgroundRotation),void 0!==e.environmentIntensity&&(N.environmentIntensity=e.environmentIntensity),void 0!==e.environmentRotation&&N.environmentRotation.fromArray(e.environmentRotation);break;case"PerspectiveCamera":N=new A(e.fov,e.aspect,e.near,e.far),void 0!==e.focus&&(N.focus=e.focus),void 0!==e.zoom&&(N.zoom=e.zoom),void 0!==e.filmGauge&&(N.filmGauge=e.filmGauge),void 0!==e.filmOffset&&(N.filmOffset=e.filmOffset),void 0!==e.view&&(N.view=Object.assign({},e.view));break;case"OrthographicCamera":N=new U(e.left,e.right,e.top,e.bottom,e.near,e.far),void 0!==e.zoom&&(N.zoom=e.zoom),void 0!==e.view&&(N.view=Object.assign({},e.view));break;case"AmbientLight":N=new E(e.color,e.intensity);break;case"DirectionalLight":N=new T(e.color,e.intensity);break;case"PointLight":N=new M(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":N=new x(e.color,e.intensity,e.width,e.height);break;case"SpotLight":N=new S(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":N=new _(e.color,e.groundColor,e.intensity);break;case"LightProbe":N=(new y).fromJSON(e);break;case"SkinnedMesh":z=L(e.geometry),I=F(e.material),N=new g(z,I),void 0!==e.bindMode&&(N.bindMode=e.bindMode),void 0!==e.bindMatrix&&N.bindMatrix.fromArray(e.bindMatrix),void 0!==e.skeleton&&(N.skeleton=e.skeleton);break;case"Mesh":z=L(e.geometry),I=F(e.material),N=new v(z,I);break;case"InstancedMesh":{z=L(e.geometry),I=F(e.material);const t=e.count,i=e.instanceMatrix,n=e.instanceColor;N=new u(z,I,t),N.instanceMatrix=new p(new Float32Array(i.array),16),void 0!==n&&(N.instanceColor=new p(new Float32Array(n.array),n.itemSize));break}case"BatchedMesh":z=L(e.geometry),I=F(e.material),N=new m(e.maxGeometryCount,e.maxVertexCount,e.maxIndexCount,I),N.geometry=z,N.perObjectFrustumCulled=e.perObjectFrustumCulled,N.sortObjects=e.sortObjects,N._drawRanges=e.drawRanges,N._reservedRanges=e.reservedRanges,N._visibility=e.visibility,N._active=e.active,N._bounds=e.bounds.map((e=>{const t=new c;t.min.fromArray(e.boxMin),t.max.fromArray(e.boxMax);const i=new h;return i.radius=e.sphereRadius,i.center.fromArray(e.sphereCenter),{boxInitialized:e.boxInitialized,box:t,sphereInitialized:e.sphereInitialized,sphere:i}})),N._maxGeometryCount=e.maxGeometryCount,N._maxVertexCount=e.maxVertexCount,N._maxIndexCount=e.maxIndexCount,N._geometryInitialized=e.geometryInitialized,N._geometryCount=e.geometryCount,N._matricesTexture=D(e.matricesTexture.uuid);break;case"LOD":N=new f;break;case"Line":N=new d(L(e.geometry),F(e.material));break;case"LineLoop":N=new l(L(e.geometry),F(e.material));break;case"LineSegments":N=new o(L(e.geometry),F(e.material));break;case"PointCloud":case"Points":N=new a(L(e.geometry),F(e.material));break;case"Sprite":N=new s(F(e.material));break;case"Group":N=new r;break;case"Bone":N=new n;break;default:N=new i}if(N.uuid=e.uuid,void 0!==e.name&&(N.name=e.name),void 0!==e.matrix?(N.matrix.fromArray(e.matrix),void 0!==e.matrixAutoUpdate&&(N.matrixAutoUpdate=e.matrixAutoUpdate),N.matrixAutoUpdate&&(N.matrix.decompose(N.position,N.quaternion,N.scale),isNaN(N.quaternion.x)&&N.quaternion.set(0,0,0,1))):(void 0!==e.position&&N.position.fromArray(e.position),void 0!==e.rotation&&N.rotation.fromArray(e.rotation),void 0!==e.quaternion&&N.quaternion.fromArray(e.quaternion),void 0!==e.scale&&N.scale.fromArray(e.scale)),void 0!==e.up&&N.up.fromArray(e.up),void 0!==e.castShadow&&(N.castShadow=e.castShadow),void 0!==e.receiveShadow&&(N.receiveShadow=e.receiveShadow),e.shadow&&(void 0!==e.shadow.bias&&(N.shadow.bias=e.shadow.bias),void 0!==e.shadow.normalBias&&(N.normalBias=e.shadow.normalBias),void 0!==e.shadow.radius&&(N.radius=e.shadow.radius),void 0!==e.shadow.mapSize&&N.mapSize.fromArray(e.shadow.mapSize),void 0!==e.shadow.camera&&(N.camera=this.parseObject(e.shadow.camera))),void 0!==e.visible&&(N.visible=e.visible),void 0!==e.frustumCulled&&(N.frustumCulled=e.frustumCulled),void 0!==e.renderOrder&&(N.renderOrder=e.renderOrder),void 0!==e.userData&&(N.userData=e.userData),void 0!==e.layers&&(N.layers.mask=e.layers),void 0!==e.children){const i=e.children;for(let e=0;e<i.length;e++)N.add(this.parseObject(i[e],t,C,O,R))}if(void 0!==e.animations){const t=e.animations;for(let e=0;e<t.length;e++){const i=t[e];N.animations.push(R[i])}}if("LOD"===e.type){void 0!==e.autoUpdate&&(N.autoUpdate=e.autoUpdate);const t=e.levels;for(let e=0;e<t.length;e++){const i=t[e],n=N.getObjectByProperty("uuid",i.object);void 0!==n&&N.addLevel(n,i.distance)}}return N}}fe.tile_pars_vertex="\n#ifdef UV_TILE\n    attribute float uvTile;\n    uniform vec2 tileCount;\n    \n    mat3 makeTileTransform(float uvTile) {\n        float col = mod(uvTile, tileCount.x);\n        float row = (tileCount.y - floor(uvTile / tileCount.x) - 1.0);\n        \n        return mat3(\n          1.0 / tileCount.x, 0.0, 0.0,\n          0.0, 1.0 / tileCount.y, 0.0, \n          col / tileCount.x, row / tileCount.y, 1.0);\n    }\n#else\n    mat3 makeTileTransform(float uvTile) {\n        return mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    }\n#endif\n\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\n\tvarying vec2 vUv;\n#ifdef TILE_BLEND\n    varying vec2 vUvNext;\n    varying float vUvBlend;\n#endif\n\n#endif\n#ifdef USE_MAP\n\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#ifdef TILE_BLEND\n    varying vec2 vMapUvNext;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n\n#endif\n#ifdef USE_AOMAP\n\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n\n#endif\n#ifdef USE_BUMPMAP\n\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n\n#endif\n#ifdef USE_NORMALMAP\n\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n\n#endif\n#ifdef USE_METALNESSMAP\n\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n\n#endif\n#ifdef USE_SPECULARMAP\n\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n\n#endif\n",fe.tile_vertex="\n#ifdef UV_TILE\n    mat3 tileTransform = makeTileTransform(floor(uvTile));\n    #ifdef TILE_BLEND\n        mat3 nextTileTransform = makeTileTransform(ceil(uvTile));\n        vUvBlend = fract(uvTile);\n    #endif\n#else\n    mat3 tileTransform = makeTileTransform(0.0);\n#endif\n\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\nvUv = (tileTransform *vec3( uv, 1 )).xy;\n#if defined( TILE_BLEND ) && defined( UV_TILE )\n    vUvNext = (nextTileTransform *vec3( uv, 1 )).xy;\n#endif\n\n#endif\n#ifdef USE_MAP\n\nvMapUv = ( tileTransform * (mapTransform * vec3( MAP_UV, 1 ) )).xy;\n#if defined( TILE_BLEND ) && defined( UV_TILE )\n    vMapUvNext = (nextTileTransform * (mapTransform * vec3( MAP_UV, 1 ))).xy;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\nvAlphaMapUv = ( tileTransform * (alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) )).xy;\n    \n#endif\n#ifdef USE_LIGHTMAP\n\nvLightMapUv = ( tileTransform * (lightMapTransform * vec3( LIGHTMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_AOMAP\n\nvAoMapUv = ( tileTransform * (aoMapTransform * vec3( AOMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_BUMPMAP\n\nvBumpMapUv = ( tileTransform * (bumpMapTransform * vec3( BUMPMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_NORMALMAP\n\nvNormalMapUv = ( tileTransform * (normalMapTransform * vec3( NORMALMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\nvDisplacementMapUv = ( tileTransform * (displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\nvEmissiveMapUv = ( tileTransform * (emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_METALNESSMAP\n\nvMetalnessMapUv = ( tileTransform * (metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\nvRoughnessMapUv = ( tileTransform * (roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\nvAnisotropyMapUv = ( tileTransform * (anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\nvClearcoatMapUv = ( tileTransform * (clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\nvClearcoatNormalMapUv = ( tileTransform * (clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\nvClearcoatRoughnessMapUv = ( tileTransform * (clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\nvIridescenceMapUv = ( tileTransform * (iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\nvIridescenceThicknessMapUv = ( tileTransform * (iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\nvSheenColorMapUv = ( tileTransform * (sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\nvSheenRoughnessMapUv = ( tileTransform * (sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULARMAP\n\nvSpecularMapUv = ( tileTransform * (specularMapTransform * vec3( SPECULARMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\nvSpecularColorMapUv = ( tileTransform * (specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\nvSpecularIntensityMapUv = ( tileTransform * (specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\nvTransmissionMapUv = ( tileTransform * transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\nvThicknessMapUv = ( tileTransform * thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) )).xy;\n\n#endif\n\n",fe.tile_pars_fragment="\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\n\tvarying vec2 vUv;\n#ifdef TILE_BLEND\n    varying vec2 vUvNext;\n    varying float vUvBlend;\n#endif\n\n#endif\n#ifdef USE_MAP\n\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#ifdef TILE_BLEND\n    varying vec2 vMapUvNext;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n\n#endif\n#ifdef USE_AOMAP\n\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n\n#endif\n#ifdef USE_BUMPMAP\n\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n\n#endif\n#ifdef USE_NORMALMAP\n\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n\n#endif\n#ifdef USE_METALNESSMAP\n\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n\n#endif\n#ifdef USE_SPECULARMAP\n\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n\n#endif\n",fe.tile_fragment="\n#ifdef USE_MAP\n    vec4 texelColor = texture2D( map, vUv);\n    #ifdef TILE_BLEND\n        texelColor = mix( texelColor, texture2D( map, vUvNext ), vUvBlend );\n    #endif\n    diffuseColor *= texelColor;\n#endif\n",fe.soft_pars_vertex="\n#ifdef SOFT_PARTICLES\n    varying vec4 projPosition;\n    varying float linearDepth;\n#endif\n",fe.soft_vertex="\n#ifdef SOFT_PARTICLES\n    projPosition = gl_Position;\n    linearDepth = -mvPosition.z;\n#endif\n",fe.soft_pars_fragment="\n#ifdef SOFT_PARTICLES\n\n    uniform sampler2D depthTexture;\n    uniform vec4 projParams;\n    uniform vec2 softParams;\n\n    varying vec4 projPosition;\n    varying float linearDepth;\n\n    #define SOFT_NEAR_FADE softParams.x\n    #define SOFT_INV_FADE_DISTANCE softParams.y\n\n    #define zNear projParams.x\n    #define zFar projParams.y\n\n    float linearize_depth(float d)\n    {\n        return (zFar * zNear) / (zFar - d * (zFar - zNear));\n    }\n\n#endif\n",fe.soft_fragment="\n#ifdef SOFT_PARTICLES\n\n    /* #ifdef LOGDEPTH\n    float distSample = linearize_depth_log(sampleDepth, near, far);\n    #else\n    float distSample = ortho ? linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far);\n    #endif */\n\n    vec2 p2 = projPosition.xy / projPosition.w;\n    \n    p2 = 0.5 * p2 + 0.5;\n\n    float readDepth = texture2D(depthTexture, p2.xy).r;\n    float viewDepth = linearize_depth(readDepth);\n\n    float softParticlesFade = saturate(SOFT_INV_FADE_DISTANCE * ((viewDepth - SOFT_NEAR_FADE) - linearDepth));\n    \n    gl_FragColor *= softParticlesFade;\n\n    //gl_FragColor = vec4(softParticlesFade , 0, 0, 1);\n#endif\n",console.log("%c Particle system powered by three.quarks. https://quarks.art/","font-size: 14px; font-weight: bold;");export{we as B,_e as P,Be as Q,ce as R};
