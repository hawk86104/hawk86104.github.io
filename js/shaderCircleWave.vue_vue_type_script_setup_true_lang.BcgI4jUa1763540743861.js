import{_ as a}from"./@tresjs.BCHtwiaC1763540743861.js";import{o as n}from"./index.Crdf3MNx1763540743861.js";import{d as e,a as o,a8 as t,r,a6 as s,H as l,o as i,J as c,ac as v,ao as u}from"./@vue.Co_gxueH1763540743861.js";import{az as f,l as m,b8 as d,ae as p}from"./three.rXKzP9fQ1763540743861.js";const k=["rotation-x","scale"],S=e({__name:"shaderCircleWave",props:{color:{default:"#ffffff"},colorDark:{default:"#000000"},speed:{default:1},scale:{default:2}},async setup(e){let S,g;const w=e,M=o(),{onBeforeRender:C}=a();C(({delta:a})=>{M.value&&(M.value.material.uniforms.uTime.value+=a*w.speed)});const h=([S,g]=t(()=>n("./plugins/floor/image/scan.png")),S=await S,g(),S);h.wrapS=f,h.wrapT=f;const x=r({side:p,transparent:!0,blending:d,flatShading:!0,depthTest:!1,uniforms:{uTime:{type:"f",value:0},uScanTex:{type:"t",value:h},uScanColor:{type:"v3",value:new m(w.color)},uScanColorDark:{type:"v3",value:new m(w.colorDark)}},vertexShader:"\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvoid main(){\n\tvUv=uv;\n\tvPosition=position;\n\tgl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\n}\n",fragmentShader:"\n#define uScanOrigin vec3(0.,0.,0.)\n#define uScanWaveRatio1 3.2\n#define uScanWaveRatio2 2.8\n\nuniform float uTime;\nuniform sampler2D uScanTex;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform vec3 uScanColor;\nuniform vec3 uScanColorDark;\n\nfloat circleWave(vec3 p,vec3 origin,float distRatio){\n    float t=uTime;\n    float dist=distance(p,origin)*distRatio;\n    float radialMove=fract(dist-t);\n    float fadeOutMask=1.-smoothstep(1.,3.,dist);\n    radialMove*=fadeOutMask;\n    float cutInitialMask=1.-step(t,dist);\n    radialMove*=cutInitialMask;\n    return radialMove;\n}\n\nvec3 getScanColor(vec3 worldPos,vec2 uv,vec3 col){\n    // mask\n    float scanMask=texture(uScanTex,uv).r;\n    // waves\n    float cw=circleWave(worldPos,uScanOrigin,uScanWaveRatio1);\n    float cw2=circleWave(worldPos,uScanOrigin,uScanWaveRatio2);\n    // scan\n    float mask1=smoothstep(.3,0.,1.-cw);\n    mask1*=(1.+scanMask*.7);\n    \n    float mask2=smoothstep(.07,0.,1.-cw2)*.8;\n    mask1+=mask2;\n    \n    float mask3=smoothstep(.09,0.,1.-cw)*1.5;\n    mask1+=mask3;\n\n    // color\n    vec3 scanCol=mix(uScanColorDark,uScanColor,mask1);\n    col=mix(col,scanCol,mask1);\n    \n    return col;\n\t\t// return vec3(cw);\n\t\t// return vec3(scanMask);\n\t\t// return worldPos;\n\t\t// return vec3(mask1);\n\t\t// return scanCol;\n}\n\nvoid main()\n{\n    vec3 col=vec3(0.);\n    col=getScanColor(vPosition,vUv*10.0,col);\n    gl_FragColor=vec4(col,1.);\n}\n"});return s(()=>{M.value&&(M.value.material.uniforms.uScanColor.value=new m(w.color),M.value.material.uniforms.uScanColorDark.value=new m(w.colorDark))}),(a,n)=>(i(),l("TresMesh",{ref_key:"tmRef",ref:M,"rotation-x":-Math.PI/2,scale:a.scale},[n[0]||(n[0]=c("TresPlaneGeometry",{args:[1,1]},null,-1)),c("TresShaderMaterial",v(u(x)),null,16)],8,k))}});export{S as _};
