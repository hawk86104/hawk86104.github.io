import{V as o,k as a,l as n,n as e,c$ as r}from"./three.rXKzP9fQ1763540743861.js";import{_ as t}from"./@tresjs.BCHtwiaC1763540743861.js";import{u as s,o as i}from"./index.Crdf3MNx1763540743861.js";import{P as c}from"./tweakpane.CqZAnw7f1763540743861.js";import{d as l,a8 as m,r as v,a as u,w as p,H as x,o as d,J as g,ac as f,ao as y,u as w}from"./@vue.Co_gxueH1763540743861.js";const b=["geometry"],C=l({__name:"fragmentModelCom",async setup(l){let C,P;const z=o=>{const a=[];return o.traverse(o=>{o instanceof e&&(o.geometry.deleteAttribute("uv"),o.geometry.deleteAttribute("tangent"),a.push(o.geometry))}),r(a)},h=z(([C,P]=m(()=>s("https://opensource.cdn.icegl.cn/model/eCommerce/guanYu.glb")),C=await C,P(),C).scene.children[0]);h.rotateX(Math.PI/2),h.translate(0,-.9,0);const _=h.clone().toNonIndexed(),A=z(([C,P]=m(()=>s("https://opensource.cdn.icegl.cn/model/industry4/modelDraco.glb")),C=await C,P(),C).scene.children[0]);A.rotateX(-Math.PI/2),A.rotateY(Math.PI/3);const M=A.clone().toNonIndexed(),N=_.attributes.position.array,D=_.attributes.position.count,V=M.attributes.position.array,j=M.attributes.normal.array,I=M.attributes.position.count,B=new Float32Array(D),F=new Float32Array(3*(D+2)),R=new Float32Array(3*(D+2)),S=new Float32Array(3*(D+2));for(let a=0;a<D;a+=3){const n=1*Math.random(),e=a%I;B[a]=n,B[a+1]=n,B[a+2]=n;const r=3*a,t=N[r],s=N[r+1],i=N[r+2],c=N[r+3],l=N[r+4],m=N[r+5],v=N[r+6],u=N[r+7],p=N[r+8],x=new o(t+c+v,s+l+u,i+m+p).divideScalar(3);F.set([x.x,x.y,x.z],3*a),F.set([x.x,x.y,x.z],3*(a+1)),F.set([x.x,x.y,x.z],3*(a+2));const d=(o,a,n)=>{const e=3*n;for(let r=0;r<3;r++){const t=e+3*r;a.set([o[t],o[t+1],o[t+2]],3*(n+r))}};d(V,R,e),d(j,S,e)}_.setAttribute("aRandom",new a(B,1)),_.setAttribute("aCenter",new a(F,3)),_.setAttribute("toPosition",new a(R,3)),_.setAttribute("toNormal",new a(S,3)),console.log(_.attributes);const U=([C,P]=m(()=>i("./plugins/visualArts/image/fragment512px.png")),C=await C,P(),C),k={uniforms:{u_progress:{value:-.1},matcap1:{value:U},m1Color:{type:"v3",value:new n("#ffc0fa")},matcap2:{value:U},m2Color:{type:"v3",value:new n("#bcd4ff")}},vertexShader:"varying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\n\nattribute vec3 aCenter;\nattribute vec3 toPosition;\nattribute vec3 toNormal;\nattribute float aRandom;\n\nuniform float u_progress;\n\n#include <common>\n\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n      oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,\n      oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,\n      oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n      oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s,\n      oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\nvoid main() {\n  vUv = uv;\n\n  float progress = u_progress;\n  float sinProgress = sin(progress * PI);\n\n  vec3 pos = mix(position, toPosition, progress);\n  vec3 nor = mix(normal, toNormal, progress);\n\n  vNormal = normalMatrix * normalize(nor);\n\n  float prog = ((pos.y + 1.) / 2.) * 1.1;\n\n  float locprog = clamp((sinProgress - 0.9 * prog) / 0.2, 0., 1.);\n\n  vec3 transform = pos - aCenter;\n\n  transform += 3. * aRandom * nor * locprog;\n\n  transform *= (1.0 - locprog);\n\n  transform += aCenter;\n\n  mat4 rotation = rotation3d(vec3(0., 1., 0.), aRandom * (locprog)*PI * 3.);\n\n  transform = (rotation * vec4(transform, 1.)).xyz;\n\n  vec4 modelViewPosition = modelViewMatrix * vec4(transform, 1.0);\n\n  gl_Position = projectionMatrix * modelViewPosition;\n\n  vViewPosition = -modelViewPosition.xyz;\n}",fragmentShader:"varying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vViewPosition;\nuniform sampler2D matcap;\nuniform sampler2D matcap2;\nuniform float u_progress;\nuniform vec3 m1Color;\nuniform vec3 m2Color;\n\nvoid main() {\n  vec3 viewDir = normalize(vViewPosition);\n  vec3 x = normalize(vec3(viewDir.z, 0.0, -viewDir.x));\n  vec3 y = cross(viewDir, x);\n  vec2 uv = vec2(dot(x, vNormal), dot(y, vNormal)) * 0.495 + 0.5;\n\n  float progress = abs(sin(u_progress));\n\n  vec3 matcapColor = texture2D(matcap, uv).rgb;\n  matcapColor = mix(matcapColor, m1Color, 0.5);\n  vec3 matcap2Color = texture2D(matcap2, uv).rgb;\n  matcap2Color = mix(matcap2Color, m2Color, 0.5);\n\n  vec3 color = vec3(matcapColor);\n  color = mix(color, matcap2Color, progress);\n\n  gl_FragColor = vec4(color, 1.0);\n}"},T=v({c1:"#ffc0fa",c2:"#bcd4ff"}),X=u(.5),Y=new c({title:"参数"});return Y.addBinding(k.uniforms.u_progress,"value",{label:"变化量",min:-.1,max:1,step:.001}).disabled=!0,Y.addBinding(T,"c1",{label:"颜色1st"}),Y.addBinding(T,"c2",{label:"颜色2rd"}),Y.addBinding(X,"value",{label:"速度",min:.001,max:1,step:.001}),p(T,o=>{k.uniforms.m1Color.value.set(o.c1),k.uniforms.m2Color.value.set(o.c2)},{deep:!0}),t().onBeforeRender(({elapsed:o})=>{k.uniforms.u_progress.value=(Math.sin(o*X.value)+1)/2,Y.refresh()}),(o,a)=>(d(),x("TresMesh",{geometry:w(_)},[g("TresShaderMaterial",f(y(k)),null,16)],8,b))}});export{C as _};
