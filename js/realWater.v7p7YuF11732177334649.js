import{m as n,e,b as t,U as r,c as o}from"./@tresjs.ty5XF8T_1732177334649.js";import{P as i}from"./tweakpane.yHWGBmom1732177334649.js";import{_ as c,a,s as l,aR as s,K as u,m as f,C as p,O as v,aA as g}from"./three.rV-MfnQb1732177334649.js";import{d,a6 as x,b as h,o as m,f as y,u as w,g as b,j as R,al as C,r as I,J as _,aj as M,ak as z}from"./@vue.-THQH3GC1732177334649.js";import"./@vueuse.n223N0GC1732177334649.js";var D="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const A=F;!function(n,e){const t=F,r=O();for(;;)try{if(804340===-parseInt(t(135))/1*(-parseInt(t(159))/2)+parseInt(t(153))/3*(parseInt(t(158))/4)+parseInt(t(123))/5+parseInt(t(146))/6+parseInt(t(150))/7+parseInt(t(145))/8+-parseInt(t(128))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[F(161)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){T(this,(function(){const n=F,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(130),"i"),r=E(n(121));e[n(148)](r+n(141))&&t[n(148)](r+n(154))?E():r("0")}))()}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function O(){const n=["apply","trace","BufferAttribute","FrontSide","__proto__","init","light","5155035wRQZvf","render","console","debu","causticsTexture","45911052EjDOle","prototype","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","pool","causticTex","constructor","call","16RseoGz","BufferGeometry","uniforms","setIndex","table","gger","chain","RawShaderMaterial","info","exception","12787832PfWxDs","256410aYwcKK","water","test","toString","5060482uLAIqB","waterTexture","counter","135zOnMuY","input","length",'{}.constructor("return this")( )',"value","84644YwkFcn","194772erKcpY","bind"];return(O=function(){return n})()}function F(n,e){const t=O();return(F=function(n,e){return t[n-=120]})(n,e)}L(void 0,(function(){const n=F;let e;try{e=Function("return (function() "+n(156)+");")()}catch(o){e=window}const t=e[n(125)]=e.console||{},r=["log","warn",n(143),"error",n(144),n(139),n(162)];for(let i=0;i<r[n(155)];i++){const e=L[n(133)][n(129)][n(160)](L),o=r[i],c=t[o]||e;e[n(120)]=L.bind(L),e[n(149)]=c[n(149)].bind(c),t[o]=e}}))();const j=d({__name:A(131),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=A,o=t,i=new(c[r(136)]),s=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),u=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i.setAttribute("position",new(c[r(163)])(s,3)),i[r(138)](new a(u,1));const f=new(c[r(142)])({uniforms:{light:{value:o[r(122)]},tiles:{value:o.tiles},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(164)]}),p=new l(i,f),{renderer:v,camera:g}=n(),{onAfterLoop:d}=e();return d((()=>{const n=r;((n,e)=>{const t=r;f.uniforms[t(147)][t(157)]=n,f[t(137)][t(132)].value=e,v.value[t(124)](p,g[t(157)])})(o[n(151)],o[n(127)])})),(n,e)=>null}});function E(n){function e(n){const t=F;if("string"==typeof n)return function(n){}[t(133)]("while (true) {}").apply(t(152));1!==(""+n/n).length||n%20==0?function(){return!0}[t(133)](t(126)+t(140))[t(134)]("action"):function(){return!1}.constructor(t(126)+t(140))[t(161)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const S=P;!function(n,e){const t=P,r=N();for(;;)try{if(418338===-parseInt(t(428))/1+parseInt(t(432))/2*(-parseInt(t(394))/3)+-parseInt(t(414))/4*(parseInt(t(385))/5)+parseInt(t(398))/6*(parseInt(t(438))/7)+parseInt(t(429))/8+-parseInt(t(408))/9*(-parseInt(t(416))/10)+parseInt(t(391))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function P(n,e){const t=N();return(P=function(n,e){return t[n-=380]})(n,e)}!function(){W(this,(function(){const n=P,e=new RegExp(n(382)),t=new RegExp(n(427),"i"),r=k(n(396));e[n(418)](r+"chain")&&t.test(r+n(439))?k():r("0")}))()}();const V=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(440)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();V(void 0,(function(){const n=P;let e;try{e=Function(n(388)+n(400)+");")()}catch(o){e=window}const t=e[n(397)]=e[n(397)]||{},r=[n(433),n(402),n(419),n(420),"exception",n(383),n(406)];for(let i=0;i<r[n(389)];i++){const e=V[n(436)][n(410)][n(417)](V),o=r[i],c=t[o]||e;e[n(405)]=V[n(417)](V),e.toString=c[n(404)][n(417)](c),t[o]=e}}))();const H=d({__name:S(395),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=S;let i,a;const l=r,f=l[o(441)],p=(new s).setPath(o(401)).load(["pos-x.jpg",o(437),o(430),o(390),"pos-z.jpg",o(423)]),v=([i,a]=x((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),g=new(c[o(424)])({uniforms:{light:{value:l.light},tiles:{value:v},sky:{value:p},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),d=new(c[o(403)])(f,g),b=h(null),R=new(c[o(413)])(o(426)),{renderer:C,camera:I}=n(),{onLoop:_}=e();return _((()=>{const n=o;C.value.setRenderTarget(null),C[n(425)].setClearColor(R,1),C[n(425)][n(380)](),g[n(434)][n(395)].value=l[n(407)],g[n(434)][n(392)][n(425)]=l[n(393)],g[n(422)]=c[n(386)],g[n(434)][n(411)][n(425)]=!0,C[n(425)][n(381)](d,I[n(425)]),g[n(422)]=u,g[n(434)][n(411)][n(425)]=!1,C[n(425)][n(381)](d,I.value)})),(n,e)=>{const t=o;return m(),y(j,{tiles:w(v),light:n[t(412)],waterTexture:n[t(407)],causticsTexture:n[t(393)],ref_key:"pooRef",ref:b},null,8,[t(384),t(412),t(407),"causticsTexture"])}}});function k(n){function e(n){const t=P;if(typeof n===t(399))return function(n){}[t(436)](t(435))[t(440)](t(431));1!==(""+n/n)[t(389)]||n%20==0?function(){return!0}[t(436)](t(387)+t(421))[t(409)]("action"):function(){return!1}[t(436)](t(387)+"gger")[t(440)](t(415)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function N(){const n=["2363808MKamWO","pos-y.jpg","counter","309050CGUSKV","log","uniforms","while (true) {}","constructor","neg-x.jpg","1897ANYXuW","input","apply","geometry","clear","render","function *\\( *\\)","table","tiles","2335lCHjQN","FrontSide","debu","return (function() ","length","neg-y.jpg","18051154ySEVYI","causticTex","causticsTexture","15wvWhhO","water","init","console","1218hjFsPg","string",'{}.constructor("return this")( )',"https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","warn","Mesh","toString","__proto__","trace","waterTexture","846TBXhec","call","prototype","underwater","light","Color","1544JKAdzv","stateObject","13070ORHASH","bind","test","info","error","gger","side","neg-z.jpg","RawShaderMaterial","value","white","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","743136kqWMzK"];return(N=function(){return n})()}const Z=G;!function(n,e){const t=G,r=U();for(;;)try{if(889130===parseInt(t(251))/1*(parseInt(t(240))/2)+parseInt(t(247))/3*(-parseInt(t(238))/4)+parseInt(t(224))/5*(parseInt(t(253))/6)+-parseInt(t(256))/7*(parseInt(t(220))/8)+parseInt(t(266))/9+parseInt(t(219))/10*(parseInt(t(252))/11)+-parseInt(t(227))/12)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[G(243)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function G(n,e){const t=U();return(G=function(n,e){return t[n-=215]})(n,e)}!function(){B(this,(function(){const n=G,e=new RegExp(n(231)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=K(n(223));e[n(267)](r+n(270))&&t[n(267)](r+n(215))?K():r("0")}))()}();const Y=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function U(){const n=["error","OrthographicCamera","3480430LjaHBL","1158888jCUCbN","__proto__","black","init","995RHJxyq","log",'{}.constructor("return this")( )',"6683124CjPOQF","exception","gger","causticsTexture","function *\\( *\\)","toString","texture","setRenderTarget","waterTexture","Mesh","caustics","2604284cOvAXR","uniforms","22hTgGjC","PlaneGeometry","debu","apply","render","length","light","3UxeUWD","stateObject","info","call","105887haLRrc","11AoVtMw","10440IdrVGx","WebGLRenderTarget","table","56aHrPrU","warn","material","string","action","console","prototype","constructor","water","geometry","12572604HDYcTq","test","value","setClearColor","chain","input","bind"];return(U=function(){return n})()}Y(void 0,(function(){const n=G,e=function(){const n=G;let e;try{e=Function("return (function() "+n(226)+");")()}catch(t){e=window}return e}(),t=e[n(261)]=e.console||{},r=[n(225),n(257),n(249),n(217),n(228),n(255),"trace"];for(let o=0;o<r[n(245)];o++){const e=Y[n(263)][n(262)][n(216)](Y),i=r[o],c=t[i]||e;e[n(221)]=Y[n(216)](Y),e[n(232)]=c.toString[n(216)](c),t[i]=e}}))();const $=d({__name:Z(237),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=Z,o=t,i=new(c[r(218)])(0,1,1,0,0,2e3),a=new(c[r(241)])(2,2,200,200),l=new(c[r(254)])(1024,1024),s=new f({uniforms:{light:{value:o[r(246)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),u=new(c[r(236)])(a,s),v=new p(r(222)),{renderer:g}=n(),{onBeforeLoop:d}=e();return d((()=>{const n=r;u[n(258)][n(239)][n(264)].value=o[n(235)],g[n(268)][n(234)](l),g[n(268)][n(269)](v,0),g.value.clear(),g.value[n(244)](u,i)})),(n,e)=>{const t=r;return m(),y(C,null,{default:b((()=>[R(H,{waterTexture:n[t(235)],causticsTexture:w(l)[t(233)],light:n.light,geometry:w(a)},null,8,["waterTexture",t(230),t(246),t(265)])])),_:1})}}});function K(n){function e(n){const t=G;if(typeof n===t(259))return function(n){}[t(263)]("while (true) {}")[t(243)]("counter");1!==(""+n/n)[t(245)]||n%20==0?function(){return!0}.constructor(t(242)+t(229))[t(250)](t(260)):function(){return!1}.constructor(t(242)+"gger")[t(243)](t(248)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const q=X;function X(n,e){const t=nn();return(X=function(n,e){return t[n-=315]})(n,e)}!function(n,e){const t=X,r=nn();for(;;)try{if(666636===-parseInt(t(359))/1+parseInt(t(334))/2+parseInt(t(381))/3*(parseInt(t(350))/4)+-parseInt(t(368))/5*(-parseInt(t(329))/6)+parseInt(t(357))/7+-parseInt(t(352))/8*(-parseInt(t(319))/9)+-parseInt(t(335))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const J=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[X(373)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){J(this,(function(){const n=X,e=new RegExp(n(322)),t=new RegExp(n(332),"i"),r=tn(n(369));e[n(361)](r+"chain")&&t.test(r+n(371))?tn():r("0")}))()}();const Q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[X(373)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function nn(){const n=["waterTexture","setY","length","bind","__proto__","Vector2","removeEventListener","getBoundingClientRect","toString","string","waterSimulation","count","render","197404KHVeZO","clientY","1352XbVtqU","material",'{}.constructor("return this")( )',"PlaneGeometry","strength","6432881lyPFme","info","407726UabtXP","left","test","call","Mesh","console","gger","needsUpdate","texture","5TnUdru","init","domElement","input","value","apply","attributes","light","top","exception","radius","while (true) {}","mousemove","15VFgNNC","log","setRenderTarget","autoClear","getY","trace","center","9855zNDVYV","uniforms","debu","function *\\( *\\)","FloatType","RawShaderMaterial","setFromCamera","WebGLRenderTarget","point","return (function() ","5310774RpNTuy","clientX","constructor","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","prototype","2018724EvrJiE","21709220VaQIgf","stateObject"];return(nn=function(){return n})()}Q(void 0,(function(){const n=X;let e;try{e=Function(n(328)+n(354)+");")()}catch(o){e=window}const t=e[n(364)]=e[n(364)]||{},r=[n(382),"warn",n(358),"error",n(377),"table",n(317)];for(let i=0;i<r[n(339)];i++){const e=Q[n(331)][n(333)][n(340)](Q),o=r[i],c=t[o]||e;e[n(341)]=Q[n(340)](Q),e[n(345)]=c[n(345)][n(340)](c),t[o]=e}}))();const en=d({__name:q(347),props:{light:{}},setup(t,{expose:r}){const o=q,i=new v(0,1,1,0,0,2e3),a=new(c[o(355)])(2,2),l=new(c[o(326)])(256,256,{type:c[o(323)]}),s=new(c[o(326)])(256,256,{type:c[o(323)]}),u=new g({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),f=new g({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),p=new(c[o(324)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),d=new(c[o(363)])(a,u),x=new(c[o(363)])(a,f),h=new(c[o(363)])(a,p);let b=l;const R=(n,e)=>{const t=o,r=b,c=b===l?s:l;e[t(353)].uniforms.texture.value=r[t(367)],n[t(383)](c),n[t(349)](e,i),b=c},{renderer:C,camera:I,raycaster:_}=n();C[o(372)][o(315)]=!1;const{onBeforeLoop:M}=e();M((()=>{const n=o;var e,t;t=C[n(372)],R(t,h),e=C[n(372)],R(e,x)}));const z=(n,e,t,r)=>{const i=o;d.material[i(320)][i(318)].value=[n,e],d[i(353)][i(320)][i(378)][i(372)]=t,d[i(353)][i(320)][i(356)][i(372)]=r,R(C.value,d)},A=new(c[o(342)]),T=new(c[o(355)])(2,2),L=T[o(374)].position;for(let n=0;n<L[o(348)];n++){const e=-L[o(316)](n);L[o(338)](n,0),L.setZ(n,e)}L[o(366)]=!0;const O=new(c[o(363)])(T),F={handleEvent:n=>{const e=o,t=C[e(372)][e(370)][e(344)](),r=t.width,i=t.height;A.x=2*(n[e(330)]-t[e(360)])/r-1,A.y=2*-(n[e(351)]-t[e(376)])/i+1,_[e(372)][e(325)](A,I[e(372)]);const c=_[e(372)].intersectObject(O);for(let o of c)z(o[e(327)].x,o[e(327)].z,.03,.04)}};return r({addDrop:z,mouseEvent:n=>{const e=o;n?C[e(372)][e(370)].addEventListener("mousemove",F):C[e(372)].domElement[e(343)](e(380),F)}}),(n,e)=>{const t=o;return m(),y($,{lightFrontGeometry:w(a),waterTexture:w(b).texture,light:n[t(375)]},null,8,["lightFrontGeometry",t(337),t(375)])}}});function tn(n){function e(n){const t=X;if(typeof n===t(346))return function(n){}[t(331)](t(379))[t(373)]("counter");1!==(""+n/n)[t(339)]||n%20==0?function(){return!0}[t(331)](t(321)+t(365))[t(362)]("action"):function(){return!1}[t(331)](t(321)+t(365)).apply(t(336)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const rn=ln;!function(n,e){const t=ln,r=cn();for(;;)try{if(982017===parseInt(t(422))/1+-parseInt(t(434))/2+-parseInt(t(413))/3*(parseInt(t(431))/4)+-parseInt(t(427))/5+parseInt(t(449))/6*(-parseInt(t(411))/7)+-parseInt(t(414))/8+-parseInt(t(452))/9*(-parseInt(t(424))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const on=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function cn(){const n=["57kZxedk","1853608cabYLF","随机增加波纹","function *\\( *\\)","trace","call","prototype","toString","addButton","1951103bbsGyN","realWater","208460wIByuo","action","mouseEvent","6992760MupBDS","TresPerspectiveCamera","__proto__","点击按钮","197944eZFECX","error","test","3090888PVsAHO","bind","stateObject","length","addDrop",'{}.constructor("return this")( )',"addBinding","click","apply","constructor","warn","waterSimulationRef","while (true) {}","change","鼠标波纹","6AteJAg","console","gger","2043FIImNC","debu","value","counter","init","random","log","11096379ReItid","chain"];return(cn=function(){return n})()}!function(){on(this,(function(){const n=ln,e=new RegExp(n(416)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=un(n(456));e[n(433)](r+n(412))&&t[n(433)](r+"input")?un():r("0")}))()}();const an=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[ln(442)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function ln(n,e){const t=cn();return(ln=function(n,e){return t[n-=409]})(n,e)}an(void 0,(function(){const n=ln,e=function(){const n=ln;let e;try{e=Function("return (function() "+n(439)+");")()}catch(t){e=window}return e}(),t=e[n(450)]=e[n(450)]||{},r=[n(410),n(444),"info",n(432),"exception","table",n(417)];for(let o=0;o<r[n(437)];o++){const e=an.constructor[n(419)][n(435)](an),i=r[o],c=t[i]||e;e[n(429)]=an[n(435)](an),e[n(420)]=c.toString[n(435)](c),t[i]=e}}))();const sn=d({__name:rn(423),setup(n){const e=rn,t=I({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:"manual"}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=h(null),l=new i;l[e(421)]({label:e(430),title:e(415)}).on(e(441),(()=>{const n=e;for(var t=0;t<10;t++)a[n(454)][n(438)](2*Math[n(409)]()-1,2*Math[n(409)]()-1,.03,1&t?.02:-.02)}));const s=h(!1);return l[e(440)](s,e(454),{label:e(448)}).on(e(447),(n=>{const t=e;a[t(454)][t(426)](n[t(454)])})),(n,i)=>{const l=e;return m(),y(w(o),M(z(t)),{default:b((()=>[i[0]||(i[0]=_(l(428),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),R(w(r)),R(en,{light:c,ref_key:l(445),ref:a},null,512)])),_:1},16)}}});function un(n){function e(n){const t=ln;if("string"==typeof n)return function(n){}[t(443)](t(446))[t(442)](t(455));1!==(""+n/n).length||n%20==0?function(){return!0}.constructor(t(453)+"gger")[t(418)](t(425)):function(){return!1}[t(443)](t(453)+t(451)).apply(t(436)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{sn as default};
