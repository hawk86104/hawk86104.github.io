import{e,h as i,b as a,a as n}from"./@tresjs.C2b5OFct1756974009013.js";import{P as s}from"./tweakpane.C0HtAJSg1756974009013.js";import{_ as t}from"./reflectorDUDV.vue_vue_type_script_setup_true_lang.C67v7SVK1756974009013.js";import{d as o,aa as r,w as l,e as d,o as u,u as v,G as m,I as c,a5 as f,f as g,j as p,m as h,r as w,h as x}from"./@vue.pEDXJ_3Z1756974009013.js";import{bD as b,a3 as y,A as B}from"./three.QlBabAUP1756974009013.js";import"./postprocessing.DuMTjsTx1756974009013.js";import"./@vueuse.BbWOQEYU1756974009013.js";import"./dither.glsl.tNAdkJUa1756974009013.js";import"./Reflector.bvx43fzt1756974009013.js";import"./OimoPhysicsBuffer.pgtVNLyp1756974009013.js";import"./oimophysics.BBtHVm4j1756974009013.js";import"./vite-plugin-qiankun.B06WoCqG1756974009013.js";const _=o({__name:"hexGridMaterial",props:{baseMaterial:{default:new b},speed:{default:1},gridWeight:{default:.03},raisedBottom:{default:.05},waveFrequency:{default:.2},wavePow:{default:4},division:{default:32},divisionScaleX:{default:1},direction:{default:4},isReversed:{default:!1},hasMaskTexture:{default:!1},maskTexture:{default:null}},async setup(n){let s,t;const o=n,m={gridWeight:{value:o.gridWeight},raisedBottom:{value:o.raisedBottom},waveFrequency:{value:o.waveFrequency},wavePow:{value:o.wavePow},direction:{value:o.direction},isReversed:{value:o.isReversed},hasMaskTexture:{value:o.hasMaskTexture},maskTexture:{value:null},division:{value:o.division},divisionScaleX:{value:o.divisionScaleX},time:{value:0}};o.maskTexture&&(m.maskTexture.value=([s,t]=r((()=>a([o.maskTexture]))),s=await s,t(),s)),l((()=>[o.gridWeight,o.raisedBottom,o.waveFrequency,o.wavePow,o.division,o.divisionScaleX,o.direction,o.isReversed,o.hasMaskTexture]),(([e,i,a,n,s,t,o,r,l])=>{m.gridWeight.value=e,m.raisedBottom.value=i,m.waveFrequency.value=a,m.wavePow.value=n,m.division.value=s,m.divisionScaleX.value=t,m.direction.value=o,m.isReversed.value=r,m.hasMaskTexture.value=l}));const{onLoop:c}=e();return c((({delta:e})=>{m.time.value+=e*o.speed})),(e,a)=>(u(),d(v(i),{baseMaterial:n.baseMaterial,vertexShader:"\nvarying vec2 uvPosition;\nvoid main() {\n    uvPosition = uv;\n}\n",side:y,transparent:"",fragmentShader:v("varying vec2 uvPosition;\n\nuniform float time;\n\nuniform float raisedBottom;\nuniform float waveFrequency;\nuniform float wavePow;\nuniform int direction;\n\nuniform float division;\nuniform float divisionScaleX;\n\nuniform bool hasMaskTexture;\nuniform sampler2D maskTexture;\n\nuniform bool isReversed;\n\nuniform float gridWeight;\n\nfloat hexDist(vec2 p) {\n  p = abs(p);\n  float d = dot(p, normalize(vec2(1.0, 1.73)));\n  return max(d, p.x);\n}\nvec4 hexCoords(vec2 uv) {\n  vec2 r = vec2(1.0, 1.73);\n  vec2 h = r * 0.5;\n  vec2 a = mod(uv, r) - h;\n  vec2 b = mod(uv - h, r) - h;\n\n  vec2 gv = length(a) < length(b) ? a : b;\n  vec2 id = uv - gv;\n\n  float x = atan(gv.x, gv.y);\n  float y = 0.5 - hexDist(gv);\n\n  return vec4(x, y, id);\n}\n\nvoid main() {\n  vec2 uv = uvPosition * vec2(division * divisionScaleX, division);\n  vec4 hc = hexCoords(uv);\n  vec2 id = hc.zw;\n  float distance = id.y;\n  if (direction == 3) {\n    distance = id.x;\n  } else if (direction == 5) {\n    distance = length(id.xy);\n  } else if (direction == 6) {\n    vec2 center = vec2(0.5 * division * divisionScaleX, 0.5 * division);\n    distance = length(uv - center);\n  }\n  float wavy =\n      pow(sin((distance * waveFrequency - time)), wavePow) + raisedBottom;\n\n  float diffuseColorA = csm_DiffuseColor.a;\n  diffuseColorA *= wavy;\n\n  float mask = 1.0;\n  if (hasMaskTexture) {\n    vec2 uVm = id / vec2(division * divisionScaleX, division);\n    mask = texture2D(maskTexture, uVm).g;\n  }\n\n  float w = gridWeight + (1.0 - mask);\n  w = clamp(w, 0.0, 1.0);\n\n  float margin = clamp(w * 0.33, 0.00, 0.02);\n  float stepMax = w + margin;\n\n  float gridLine = smoothstep(w, stepMax, hc.y);\n  gridLine = isReversed ? 1.0 - gridLine : gridLine;\n  diffuseColorA *= gridLine;\n\n  \n  \n  csm_DiffuseColor.rgb *= diffuseColorA;\n\nfloat brightness = length(csm_DiffuseColor.rgb);\n\nfloat alphaBlend = smoothstep(0.0, 1.0, brightness);\n\ncsm_DiffuseColor.a *= alphaBlend;\n\ncsm_FragColor = vec4(csm_DiffuseColor.rgb, csm_DiffuseColor.a);\n}"),uniforms:m},null,8,["baseMaterial","side","fragmentShader"]))}}),k=["rotation"],M=o({__name:"hexGridMesh",setup(e){const i=new B;return(e,a)=>(u(),m("TresMesh",{rotation:[-Math.PI/2,0,0]},[a[0]||(a[0]=c("TresPlaneGeometry",{args:[1,1]},null,-1)),(u(),d(f,null,{default:g((()=>[p(_,h({baseMaterial:v(i)},e.$attrs,{maskTexture:"./plugins/floor/image/logoBlack.png"}),null,16,["baseMaterial"])])),_:1}))],8,k))}}),T=o({__name:"hexGridGround",setup(e){const i=w({reflectivity:.8,showGridHelper:!1,scale:1}),a=w({color:"#de62f2",speed:1.9,gridWeight:.223,raisedBottom:.66,waveFrequency:.066,wavePow:19,division:46,divisionScaleX:1,isReversed:!1,direction:4,hasMaskTexture:!0}),o=new s({title:"hexGridGround",expanded:!0});return o.addBinding(a,"hasMaskTexture",{label:"图片纹理"}),o.addBinding(a,"color",{label:"颜色"}),o.addBinding(a,"speed",{label:"速度",min:-5,max:5,step:.1}),o.addBinding(a,"gridWeight",{label:"网格宽度",min:.001,max:.5,step:.001}),o.addBinding(a,"raisedBottom",{label:"渐变宽度",min:.001,max:1,step:.001}),o.addBinding(a,"waveFrequency",{label:"分段",min:.001,max:1,step:.001}),o.addBinding(a,"wavePow",{label:"渐变强度",min:1,max:30,step:.1}),o.addBinding(a,"division",{label:"网格整体缩放",min:.1,max:50,step:.1}),o.addBinding(a,"divisionScaleX",{label:"网格横向缩放",min:.1,max:10,step:.1}),o.addBinding(a,"isReversed",{label:"颜色取反"}),o.addBinding(a,"direction",{label:"方向类别",min:3,max:6,step:1}),(e,s)=>{const o=x("TresCanvas");return u(),d(o,{clearColor:"#666666","window-size":""},{default:g((()=>[s[0]||(s[0]=c("TresPerspectiveCamera",{position:[3,3,0],fov:45,near:.1,far:1e4},null,-1)),p(v(n),{enableDamping:"",autoRotate:""}),p(M,h(a,{scale:9}),null,16),(u(),d(f,null,{default:g((()=>[p(t,h({position:[0,-.06,0]},i),null,16)])),_:1}))])),_:1})}}});export{T as default};
