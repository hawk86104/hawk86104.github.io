import{m as n,e,a as t,o as r,f as o}from"./@tresjs.05J-Im0t1743039954535.js";import{P as i}from"./tweakpane.ivGeiIdz1743039954535.js";import{_ as c,c as a,a_ as l,aR as s,m as u,l as f,X as p}from"./three.XuMWWlrU1743039954535.js";import{d as v,a3 as g,b as d,o as x,f as h,u as m,g as y,j as w,al as b,r as I,N as R,aj as C,ak as _}from"./@vue.C4dqouNn1743039954535.js";import"./postprocessing.YRVqsIkW1743039954535.js";import"./@vueuse.NzAeD-Dt1743039954535.js";var z="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";function M(){const n=["stateObject","string","uniforms","trace","function *\\( *\\)","position","tiles","init","18854VRTImr","4512888bxsuhH","FrontSide","BufferAttribute","189028DkHGoe","input","test","apply","call","816Dhfdqb","BufferGeometry","toString","debu",'{}.constructor("return this")( )',"1030869yVrnTI","water","value","6515pEtnyJ","3730iacTge","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","23iZLTFG","causticsTexture","warn","constructor","console","bind","light","27jSgEbN","exception","1631493ObRFEu","setIndex","Mesh","gger","prototype","log","24218YnIzDF","causticTex","action","render"];return(M=function(){return n})()}!function(n,e){const t=L,r=M();for(;;)try{if(283735===parseInt(t(209))/1*(parseInt(t(177))/2)+parseInt(t(169))/3*(-parseInt(t(193))/4)+-parseInt(t(206))/5*(-parseInt(t(198))/6)+parseInt(t(203))/7+parseInt(t(190))/8+parseInt(t(171))/9+parseInt(t(207))/10*(-parseInt(t(189))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const D=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[L(196)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){D(this,(function(){const n=L,e=new RegExp(n(185)),t=new RegExp(n(208),"i"),r=F(n(188));e[n(195)](r+"chain")&&t.test(r+n(194))?F():r("0")}))()}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[L(196)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();T(void 0,(function(){const n=L;let e;try{e=Function("return (function() "+n(202)+");")()}catch(o){e=window}const t=e[n(166)]=e[n(166)]||{},r=[n(176),n(164),"info","error",n(170),"table",n(184)];for(let i=0;i<r.length;i++){const e=T[n(165)][n(175)].bind(T),o=r[i],c=t[o]||e;e.__proto__=T[n(167)](T),e[n(200)]=c[n(200)][n(167)](c),t[o]=e}}))();const A=v({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=L,o=t,i=new(c[r(199)]),s=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),u=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i.setAttribute(r(186),new(c[r(192)])(s,3)),i[r(172)](new a(u,1));const f=new l({uniforms:{light:{value:o[r(168)]},tiles:{value:o[r(187)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(191)]}),p=new(c[r(173)])(i,f),{renderer:v,camera:g}=n(),{onAfterLoop:d}=e();return d((()=>{const n=r;((n,e)=>{const t=r;f[t(183)][t(204)][t(205)]=n,f[t(183)][t(178)][t(205)]=e,v[t(205)][t(180)](p,g.value)})(o.waterTexture,o[n(163)])})),(n,e)=>null}});function L(n,e){const t=M();return L=function(n,e){return t[n-=163]},L(n,e)}function F(n){function e(n){const t=L;if(typeof n===t(182))return function(n){}[t(165)]("while (true) {}")[t(196)]("counter");1!==(""+n/n).length||n%20==0?function(){return!0}.constructor("debu"+t(174))[t(197)](t(179)):function(){return!1}[t(165)](t(201)+t(174))[t(196)](t(181)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const O=E;!function(n,e){const t=E,r=S();for(;;)try{if(200142===parseInt(t(338))/1+-parseInt(t(304))/2*(parseInt(t(342))/3)+parseInt(t(318))/4*(-parseInt(t(311))/5)+parseInt(t(319))/6*(-parseInt(t(309))/7)+-parseInt(t(324))/8+parseInt(t(308))/9*(-parseInt(t(306))/10)+parseInt(t(335))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[E(325)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function S(){const n=["https://opensource.cdn.icegl.cn","Color","resource.cos","neg-z.jpg","length","prototype","pos-x.jpg","load","chain","14DjFmse","gger","890oFrZnM","value","21582dgpYip","994QySBqo","error","6630JhISbX","debu","side","console","setPath","BackSide","neg-y.jpg","528KxCNmJ","8538wVTrtU","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","causticsTexture","while (true) {}","exception","1183552zWfzIT","apply","init","uniforms","stateObject","tiles","/images/skyBox/6jpg/","pos-y.jpg","__proto__","constructor",'{}.constructor("return this")( )',"10469591ArhsNZ","counter","info","210566kNbjBD","render","call","clear","95889WXlUWX","water","white","string","pooRef","FrontSide","toString","trace","waterTexture","light","Mesh","return (function() ","underwater","test"];return(S=function(){return n})()}function E(n,e){const t=S();return E=function(n,e){return t[n-=303]},E(n,e)}!function(){j(this,(function(){const n=E,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(320),"i"),r=V(n(326));e.test(r+n(303))&&t[n(355)](r+"input")?V():r("0")}))()}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[E(325)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();W(void 0,(function(){const n=E,e=function(){const n=E;let e;try{e=Function(n(353)+n(334)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(314)]||{},r=["log","warn",n(337),n(310),n(323),"table",n(349)];for(let o=0;o<r[n(360)];o++){const e=W[n(333)][n(361)].bind(W),i=r[o],c=t[i]||e;e[n(332)]=W.bind(W),e[n(348)]=c[n(348)].bind(c),t[i]=e}}))();const P=v({__name:O(343),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=O;let i,a;const u=r,f=u.geometry,p=(new s)[o(315)](o(356)+o(330))[o(363)]([o(362),"neg-x.jpg",o(331),o(317),"pos-z.jpg",o(359)]),v=([i,a]=g((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),y=new l({uniforms:{light:{value:u[o(351)]},tiles:{value:v},sky:{value:p},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),w=new(c[o(352)])(f,y),b=d(null),I=new(c[o(357)])(o(344)),{renderer:R,camera:C}=n(),{onLoop:_}=e();return _((()=>{const n=o;R[n(307)].setRenderTarget(null),R.value.setClearColor(I,1),R.value[n(341)](),y[n(327)][n(343)].value=u[n(350)],y[n(327)].causticTex[n(307)]=u[n(321)],y[n(313)]=c[n(347)],y[n(327)][n(354)][n(307)]=!0,R[n(307)][n(339)](w,C[n(307)]),y[n(313)]=c[n(316)],y[n(327)].underwater.value=!1,R[n(307)].render(w,C.value)})),(n,e)=>{const t=o;return x(),h(A,{tiles:m(v),light:n[t(351)],waterTexture:n[t(350)],causticsTexture:n[t(321)],ref_key:t(346),ref:b},null,8,[t(329),"light",t(350),t(321)])}}});function V(n){function e(n){const t=E;if(typeof n===t(345))return function(n){}[t(333)](t(322))[t(325)](t(336));1!==(""+n/n)[t(360)]||n%20==0?function(){return!0}[t(333)](t(312)+t(305))[t(340)]("action"):function(){return!1}.constructor("debu"+t(305))[t(325)](t(328)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function k(n,e){const t=B();return k=function(n,e){return t[n-=457]},k(n,e)}const H=k;!function(n,e){const t=k,r=B();for(;;)try{if(417311===parseInt(t(493))/1+parseInt(t(461))/2+-parseInt(t(487))/3*(-parseInt(t(467))/4)+parseInt(t(496))/5+-parseInt(t(465))/6+parseInt(t(469))/7*(-parseInt(t(468))/8)+-parseInt(t(492))/9*(parseInt(t(463))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const N=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[k(481)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){N(this,(function(){const n=k,e=new RegExp(n(475)),t=new RegExp(n(482),"i"),r=$("init");e[n(499)](r+n(474))&&t[n(499)](r+"input")?$():r("0")}))()}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[k(481)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function B(){const n=["function *\\( *\\)","gger","trace","return (function() ","prototype","setClearColor","apply","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","error","Color","light","warn","3585MwUNJQ","console","material","call","action","63Tlhohv","767894ZMefpW","caustics","ShaderMaterial","359290iaYGZV","counter","uniforms","test","waterTexture","WebGLRenderTarget","constructor","OrthographicCamera","info",'{}.constructor("return this")( )',"black","value","1376182yKUVNR","render","1070950jpzeCx","toString","4230438HLmkDX","geometry","1276kccefl","32888vRKgXQ","63PvFaqS","bind","stateObject","while (true) {}","length","chain"];return(B=function(){return n})()}Z(void 0,(function(){const n=k,e=function(){const n=k;let e;try{e=Function(n(478)+n(458)+");")()}catch(t){e=window}return e}(),t=e[n(488)]=e.console||{},r=["log",n(486),n(457),n(483),"exception","table",n(477)];for(let o=0;o<r[n(473)];o++){const e=Z[n(502)][n(479)].bind(Z),i=r[o],c=t[i]||e;e.__proto__=Z[n(470)](Z),e[n(464)]=c[n(464)][n(470)](c),t[i]=e}}))();const G=v({__name:H(494),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=H,o=t,i=new(c[r(503)])(0,1,1,0,0,2e3),a=new u(2,2,200,200),l=new(c[r(501)])(1024,1024),s=new(c[r(495)])({uniforms:{light:{value:o.light},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new f(a,s),v=new(c[r(484)])(r(459)),{renderer:g}=n(),{onBeforeLoop:d}=e();return d((()=>{const n=r;p[n(489)][n(498)].water.value=o[n(500)],g[n(460)].setRenderTarget(l),g[n(460)][n(480)](v,0),g[n(460)].clear(),g[n(460)][n(462)](p,i)})),(n,e)=>{const t=r;return x(),h(b,null,{default:y((()=>[w(P,{waterTexture:n[t(500)],causticsTexture:m(l).texture,light:n[t(485)],geometry:m(a)},null,8,["waterTexture","causticsTexture","light",t(466)])])),_:1})}}});function $(n){function e(n){const t=k;if("string"==typeof n)return function(n){}.constructor(t(472))[t(481)](t(497));1!==(""+n/n)[t(473)]||n%20==0?function(){return!0}[t(502)]("debu"+t(476))[t(490)](t(491)):function(){return!1}.constructor("debu"+t(476))[t(481)](t(471)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const U=J;function X(){const n=["warn","10tuySAm","return (function() ","render","autoClear","counter",'{}.constructor("return this")( )',"Vector2","point","1508100gTTLwX","__proto__","removeEventListener","RawShaderMaterial","WebGLRenderTarget","bind","material","getBoundingClientRect","waterSimulation","1771602HHTjhz","init","log","exception","gger","setY","4547784ccRrpY","27TVXdAt","prototype","PlaneGeometry","height","center","trace","waterTexture","intersectObject","count","OrthographicCamera","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","error","domElement","lightFrontGeometry","setRenderTarget","table","value","addEventListener","uniforms","needsUpdate","texture","constructor","attributes","clientX","getY","console","apply","Mesh","info","length","5158202mgnBJv","mousemove","top","strength","setZ","debu","39vrrfQe","3351069wQwUoK","19156VDlUss","input","call","toString","clientY","position","light","while (true) {}","164244eLchVj","test"];return(X=function(){return n})()}!function(n,e){const t=J,r=X();for(;;)try{if(399440===-parseInt(t(269))/1*(-parseInt(t(234))/2)+-parseInt(t(232))/3*(-parseInt(t(242))/4)+-parseInt(t(253))/5+-parseInt(t(262))/6+-parseInt(t(299))/7+parseInt(t(268))/8+-parseInt(t(233))/9*(-parseInt(t(245))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Y=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[J(295)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Y(this,(function(){const n=J,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(279),"i"),r=K(n(263));e[n(243)](r+"chain")&&t[n(243)](r+n(235))?K():r("0")}))()}();const Q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function J(n,e){const t=X();return J=function(n,e){return t[n-=232]},J(n,e)}Q(void 0,(function(){const n=J;let e;try{e=Function(n(246)+n(250)+");")()}catch(o){e=window}const t=e[n(294)]=e.console||{},r=[n(264),n(244),n(297),n(280),n(265),n(284),n(274)];for(let i=0;i<r.length;i++){const e=Q.constructor[n(270)].bind(Q),o=r[i],c=t[o]||e;e[n(254)]=Q[n(258)](Q),e[n(237)]=c.toString.bind(c),t[o]=e}}))();const q=v({__name:U(261),props:{light:{}},setup(t,{expose:r}){const o=U,i=new(c[o(278)])(0,1,1,0,0,2e3),a=new u(2,2),l=new(c[o(257)])(256,256,{type:p}),s=new(c[o(257)])(256,256,{type:p}),v=new(c[o(256)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),g=new(c[o(256)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),d=new(c[o(256)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),y=new f(a,v),w=new(c[o(296)])(a,g),b=new(c[o(296)])(a,d);let I=l;const R=(n,e)=>{const t=o,r=I,c=I===l?s:l;e[t(259)][t(287)][t(289)][t(285)]=r.texture,n[t(283)](c),n[t(247)](e,i),I=c},{renderer:C,camera:_,raycaster:M}=n();C[o(285)][o(248)]=!1;const{onBeforeLoop:D}=e();D((()=>{const n=o;var e,t;t=C.value,R(t,b),e=C[n(285)],R(e,w)}));const T=(n,e,t,r)=>{const i=o;y[i(259)][i(287)][i(273)][i(285)]=[n,e],y.material[i(287)].radius[i(285)]=t,y.material[i(287)][i(302)][i(285)]=r,R(C.value,y)},A=new(c[o(251)]),L=new(c[o(271)])(2,2),F=L[o(291)][o(239)];for(let n=0;n<F[o(277)];n++){const e=-F[o(293)](n);F[o(267)](n,0),F[o(303)](n,e)}F[o(288)]=!0;const O=new(c[o(296)])(L),j={handleEvent:n=>{const e=o,t=C[e(285)][e(281)][e(260)](),r=t.width,i=t[e(272)];A.x=2*(n[e(292)]-t.left)/r-1,A.y=2*-(n[e(238)]-t[e(301)])/i+1,M[e(285)].setFromCamera(A,_.value);const c=M[e(285)][e(276)](O);for(let o of c)T(o[e(252)].x,o[e(252)].z,.03,.04)}};return r({addDrop:T,mouseEvent:n=>{const e=o;n?C[e(285)].domElement[e(286)]("mousemove",j):C[e(285)][e(281)][e(255)](e(300),j)}}),(n,e)=>{const t=o;return x(),h(G,{lightFrontGeometry:m(a),waterTexture:m(I)[t(289)],light:n[t(240)]},null,8,[t(282),t(275),"light"])}}});function K(n){function e(n){const t=J;if("string"==typeof n)return function(n){}[t(290)](t(241))[t(295)](t(249));1!==(""+n/n)[t(298)]||n%20==0?function(){return!0}[t(290)](t(304)+t(266))[t(236)]("action"):function(){return!1}[t(290)]("debu"+t(266))[t(295)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const nn=on;function en(){const n=["log","table","counter","input","trace","6280fiyooq","console","298708NMLvBN","length","toString","string","addButton","prototype","warn","2QYKhAH","16434clbfiz","value","click","random","7PtgfuW","1517694kWfKTx","action","14857128BTmDOA","65nJHdFb","waterSimulationRef","constructor","7294686uneITa","exception","bind",'{}.constructor("return this")( )',"addDrop","test","info","function *\\( *\\)","call","realWater","change","鼠标波纹","apply","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","init","13356464UhxJQQ","TresPerspectiveCamera","点击按钮","4583091REtYIS","debu","return (function() ","while (true) {}","gger","mouseEvent","addBinding","stateObject"];return(en=function(){return n})()}!function(n,e){const t=on,r=en();for(;;)try{if(876563===-parseInt(t(284))/1+-parseInt(t(278))/2*(parseInt(t(256))/3)+-parseInt(t(271))/4*(-parseInt(t(287))/5)+-parseInt(t(290))/6*(parseInt(t(283))/7)+parseInt(t(253))/8+-parseInt(t(279))/9*(-parseInt(t(269))/10)+parseInt(t(286))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const tn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(250)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){tn(this,(function(){const n=on,e=new RegExp(n(297)),t=new RegExp(n(251),"i"),r=an(n(252));e[n(295)](r+"chain")&&t[n(295)](r+n(267))?an():r("0")}))()}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(250)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function on(n,e){const t=en();return on=function(n,e){return t[n-=246]},on(n,e)}rn(void 0,(function(){const n=on,e=function(){const n=on;let e;try{e=Function(n(258)+n(293)+");")()}catch(t){e=window}return e}(),t=e[n(270)]=e[n(270)]||{},r=[n(264),n(277),n(296),"error",n(291),n(265),n(268)];for(let o=0;o<r[n(272)];o++){const e=rn.constructor[n(276)][n(292)](rn),i=r[o],c=t[i]||e;e.__proto__=rn[n(292)](rn),e.toString=c[n(273)].bind(c),t[i]=e}}))();const cn=v({__name:nn(247),setup(n){const e=nn,t=I({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:"manual"}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=d(null),l=new i;l[e(275)]({label:e(255),title:"随机增加波纹"}).on(e(281),(()=>{const n=e;for(var t=0;t<10;t++)a.value[n(294)](2*Math[n(282)]()-1,2*Math.random()-1,.03,1&t?.02:-.02)}));const s=d(!1);return l[e(262)](s,e(280),{label:e(249)}).on(e(248),(n=>{const t=e;a[t(280)][t(261)](n[t(280)])})),(n,i)=>{const l=e;return x(),h(m(o),C(_(t)),{default:y((()=>[i[0]||(i[0]=R(l(254),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),w(m(r)),w(q,{light:c,ref_key:l(288),ref:a},null,512)])),_:1},16)}}});function an(n){function e(n){const t=on;if(typeof n===t(274))return function(n){}.constructor(t(259)).apply(t(266));1!==(""+n/n)[t(272)]||n%20==0?function(){return!0}[t(289)]("debu"+t(260))[t(246)](t(285)):function(){return!1}[t(289)](t(257)+t(260)).apply(t(263)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{cn as default};
