import{importShared as e}from"./3d-tiles-renderer.de6b_qgz1767149344623.js";import{request as t}from"./index.Btae5S5d1767149344623.js";import{useTexture$1 as r}from"./customShaderMaterial.vue_vue_type_script_setup_true_lang.C_pYeFAB1767149344623.js";import"./index.vue_vue_type_script_setup_true_lang.C9DbtXj-1767149344623.js";import{Water as o}from"./Water2.BcBDlhVT1767149344623.js";import{computeBoundsTree as i,disposeBoundsTree as n,acceleratedRaycast as s}from"./ExtensionUtilities.CsZ72cLy1767149344623.js";const{BufferAttribute:a,Box3:u,Vector3:p,RepeatWrapping:l,Color:c,Mesh:m,PlaneGeometry:g,Vector2:f,DoubleSide:d,Material:h,MeshBasicMaterial:y,BufferGeometry:x,Matrix4:_}=await e("three"),w=(e,t=!1)=>{e.computeBoundingBox();const{max:r,min:o}=e.boundingBox;e.deleteAttribute("uv");const i=r.x-o.x,n=r.y-o.y,s=[];for(let a=0;a<e.attributes.position.count;a++)t?(s.push((e.attributes.position.getX(a)-(o.x+r.x)/2)/i),s.push((e.attributes.position.getY(a)-(o.y+r.y)/2)/n)):(s.push((e.attributes.position.getX(a)-o.x)/i),s.push((e.attributes.position.getY(a)-o.y)/n));const u=new Float32Array(s);e.setAttribute("uv",new a(u,2))},b=(e,r)=>new Promise((o,i)=>{t(e,{},{method:"get",mergeRequest:!0,responseType:"json"}).then(e=>{r&&o(e[r]),o(e.features)}).catch(e=>{console.error(e),i(e)})}),j=e=>{const t=(new THREE.Box3).setFromObject(e),r=new THREE.Vector3;t.getCenter(r),e.children.forEach(e=>{e.position.sub(r)}),e.position.copy(r.negate())},B=()=>{x.prototype.computeBoundsTree=i,x.prototype.disposeBoundsTree=n,m.prototype.raycast=s},v=async e=>{const t=await r(["./plugins/water/images/Water_1_M_Normal.jpg","./plugins/water/images/Water_2_M_Normal.jpg"]),i=e.geometry.clone();w(i),i.computeBoundsTree();const n=new o(i,{color:new c("#fff"),scale:20,flowDirection:new f(1,1),textureWidth:1024,textureHeight:1024,normalMap0:t[0],normalMap1:t[1]});return n.material.transparent=!0,n.material.depthWrite=!0,n.material.depthTest=!0,n.material.side=d,n.material.uniforms.config.value.w=20,n.material.uniforms.reflectivity.value=.46,n};function M(e){const t=[];for(let o=0;o<e.length;o++)t.push(new f(e[o].x,e[o].y));const r=new f;for(let o=0;o<t.length;o++)r.add(t[o]);r.divideScalar(t.length);for(let o=0;o<t.length;o++)t[o].sub(r);return{points:t,centerPoint:r}}export{j as adjustGroupCenter,M as getcenterPoint,B as initMeshBvh,b as loadGeojson,w as resetUV,v as setThreeWater2};
