import{_ as e}from"./@tresjs.CC-VM6g11766394917683.js";import{k as t,M as a,a6 as o,ab as n,V as i}from"./three.F31Lz30M1766394917683.js";import{d as l,a as r,w as s,s as u,a3 as f,G as c,o as g,I as d,m as v,u as p,a9 as h,aa as m}from"./@vue.BxPWGdWw1766394917683.js";const y=["args"],x=["side"],w=l({__name:"radraA",props:{size:{default:300},radius:{default:240},color:{default:"#ffff00"},opacity:{default:.9},speed:{default:1},followWidth:{default:220}},setup(n){const i=n,{onBeforeRender:l}=e(),h={value:0},m=r();l(()=>{h.value+=.02*i.speed});const w={transparent:!0,depthWrite:!1,depthTest:!0,vertexShader:"\n\tvarying vec3 vPosition;\n\tvoid main() {\n\t\tvPosition = position;\n\t\tvec4 modelPosition = modelMatrix * vec4(position, 1.0);\n\t\tvec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectionPosition = projectionMatrix * viewPosition;\n    gl_Position = projectionPosition;\n  }\n  ",fragmentShader:"\n\tuniform float uRadius;     \n  uniform float uTime;      \n  uniform float uFollowWidth; \n  varying vec3 vPosition;\n\tuniform float uOpacity;\n\tuniform vec3 ncolor;\n  float calcAngle(vec3 oFrag){\n    float fragAngle;\n    const vec3 ox = vec3(1,0,0);\n    float dianji = oFrag.x * ox.x + oFrag.z*ox.z;\n    float oFrag_length = length(oFrag); // length是内置函数\n    float ox_length = length(ox); // length是内置函数\n    float yuxian = dianji / (oFrag_length * ox_length);\n    fragAngle = acos(yuxian);\n    fragAngle = degrees(fragAngle);\n    if(oFrag.z > 0.0) {\n      fragAngle = -fragAngle + 360.0;\n    }\n    float scanAngle = uTime * 100.0 - floor(uTime * 100.0 / 360.0) * 360.0;\n    float angle = scanAngle - fragAngle;\n    if(angle < 0.0){\n      angle = angle + 360.0;\n    }\n    return angle;\n  }\n  void main() {\n\t\t\t// length内置函数，取向量的长度\n\t\tif(length(vPosition) == 0.0 || length(vPosition) > uRadius-2.0){\n\t\t\tgl_FragColor = vec4( ncolor, uOpacity );\n\t\t} else {\n\t\t\tfloat angle = calcAngle(vPosition);\n\t\t\tif(angle < uFollowWidth){\n\t\t\t\t// 尾焰区域\n\t\t\t\tfloat opacity =  1.0 - angle / uFollowWidth; \n\t\t\t\tgl_FragColor = vec4( ncolor, uOpacity * opacity );  \n\t\t\t} else {\n\t\t\t\t// 其他位置的像素均为透明\n\t\t\t\tgl_FragColor = vec4( ncolor, 0.0 ); \n\t\t\t}\n\t\t}\n\t}\n  ",uniforms:{uRadius:{value:i.radius},uTime:h,uFollowWidth:{value:i.followWidth},ncolor:{value:new t(i.color)},uOpacity:{value:i.opacity}}};return s(m,(e,t)=>{e&&void 0===t&&m.value.applyMatrix4((new a).makeRotationX(-Math.PI/2))}),s(()=>i.size,()=>{u(()=>{m.value.applyMatrix4((new a).makeRotationX(Math.PI/2))})}),f(()=>{i.color&&(w.uniforms.ncolor.value=new t(i.color)),i.opacity&&(w.uniforms.uOpacity.value=i.opacity),i.radius&&(w.uniforms.uRadius.value=i.radius),i.followWidth&&(w.uniforms.uFollowWidth.value=i.followWidth)}),(e,t)=>(g(),c("TresMesh",null,[d("TresCircleGeometry",{ref_key:"TresCircleGeometryRef",ref:m,args:[i.size,64]},null,8,y),d("TresShaderMaterial",v(w,{side:p(o)}),null,16,x)]))}}),_=["args"],F=l({__name:"radraB",props:{radius:{default:1},maxRadius:{default:20},color:{default:"#ffff00"},opacity:{default:1},speed:{default:.3},height:{default:100}},setup(a,{expose:l}){const s=a,u=r(),v=r(1),p={transparent:!0,depthWrite:!1,side:o,uniforms:{uColor:{value:new t(s.color)},uOpacity:{value:s.opacity},uHeight:{value:s.height},uScale:v},vertexShader:"\n    uniform float uScale;\n    varying float vY;\n\n    void main() {\n      vec3 p = position;\n      p.xz *= uScale;\n      vY = position.y;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);\n    }\n  ",fragmentShader:"\n    uniform vec3 uColor;\n    uniform float uOpacity;\n    uniform float uHeight;\n    varying float vY;\n\n    void main() {\n      float alpha = (1.0 - vY / uHeight) * uOpacity;\n      gl_FragColor = vec4(uColor, alpha);\n    }\n  "};f(()=>{p.uniforms.uColor.value.set(s.color),p.uniforms.uOpacity.value=s.opacity,p.uniforms.uHeight.value=s.height});const{onBeforeRender:y}=e();let x=0;y(()=>{x+=.02*s.speed;const e=x%1,t=s.radius+e*(s.maxRadius-s.radius);v.value=t/s.radius});const w=r(new n(new i(0,0,0),new i(0,10,0)));return l({MeshRef:u}),(e,t)=>(g(),c("TresMesh",{ref_key:"MeshRef",ref:u,renderOrder:2e3},[d("TresTubeGeometry",{args:[w.value,20,s.radius,64,!1]},null,8,_),d("TresShaderMaterial",h(m(p)),null,16)],512))}});export{w as _,F as a};
