import{b7 as e,bW as n}from"./three.BCtXTlZY1750295690454.js";const a="csm_DiffuseColor",s="csm_Roughness",i="csm_Metalness",r="csm_Emissive",t="csm_AO",c="csm_Bump",o="csm_FragNormal",m="csm_Clearcoat",l="csm_ClearcoatRoughness",d="csm_ClearcoatNormal",_="csm_Transmission",f="csm_Thickness",M="csm_Iridescence",S="csm_PointSize",h="csm_FragColor",A="csm_DepthAlpha",u="csm_UnlitFac",E="csm_Position",p="csm_PositionRaw",g="csm_Normal",I={[`${E}`]:"*",[`${p}`]:"*",[`${g}`]:"*",[`${A}`]:"*",[`${S}`]:["PointsMaterial"],[`${a}`]:"*",[`${h}`]:"*",[`${o}`]:"*",[`${u}`]:"*",[`${r}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${s}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${i}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${M}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${t}`]:["MeshStandardMaterial","MeshPhysicalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial"],[`${c}`]:["MeshLambertMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MeshToonMaterial","ShadowMaterial"],[`${m}`]:["MeshPhysicalMaterial"],[`${l}`]:["MeshPhysicalMaterial"],[`${d}`]:["MeshPhysicalMaterial"],[`${_}`]:["MeshPhysicalMaterial"],[`${f}`]:["MeshPhysicalMaterial"]},v={"*":{"#include <lights_physical_fragment>":n.lights_physical_fragment,"#include <transmission_fragment>":n.transmission_fragment},[`${g}`]:{"#include <beginnormal_vertex>":`\n    vec3 objectNormal = ${g};\n    #ifdef USE_TANGENT\n\t    vec3 objectTangent = vec3( tangent.xyz );\n    #endif\n    `},[`${E}`]:{"#include <begin_vertex>":`\n    vec3 transformed = ${E};\n  `},[`${p}`]:{"#include <begin_vertex>":`\n    vec4 csm_internal_positionUnprojected = ${p};\n    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;\n    #ifdef USE_INSTANCING\n      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;\n    #endif\n    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;\n    vec3 transformed = csm_internal_positionUnprojected.xyz;\n  `},[`${S}`]:{"gl_PointSize = size;":`\n    gl_PointSize = ${S};\n    `},[`${a}`]:{"#include <color_fragment>":`\n    #include <color_fragment>\n    diffuseColor = ${a};\n  `},[`${h}`]:{"#include <opaque_fragment>":`\n    #include <opaque_fragment>\n    gl_FragColor = mix(gl_FragColor, ${h}, ${u});\n  `},[`${r}`]:{"vec3 totalEmissiveRadiance = emissive;":`\n    vec3 totalEmissiveRadiance = ${r};\n    `},[`${s}`]:{"#include <roughnessmap_fragment>":`\n    #include <roughnessmap_fragment>\n    roughnessFactor = ${s};\n    `},[`${i}`]:{"#include <metalnessmap_fragment>":`\n    #include <metalnessmap_fragment>\n    metalnessFactor = ${i};\n    `},[`${t}`]:{"#include <aomap_fragment>":`\n    #include <aomap_fragment>\n    reflectedLight.indirectDiffuse *= 1. - ${t};\n    `},[`${c}`]:{"#include <normal_fragment_maps>":`\n    #include <normal_fragment_maps>\n\n    vec3 csm_internal_orthogonal = ${c} - (dot(${c}, normal) * normal);\n    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;\n    normal = normalize(normal - csm_internal_projectedbump);\n    `},[`${o}`]:{"#include <normal_fragment_maps>":`\n      #include <normal_fragment_maps>\n      normal = ${o};\n    `},[`${A}`]:{"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );":`\n      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * 1.0 - ${A} );\n    `,"gl_FragColor = packDepthToRGBA( fragCoordZ );":`\n      if(${A} < 1.0) discard;\n      gl_FragColor = packDepthToRGBA( dist );\n    `,"gl_FragColor = packDepthToRGBA( dist );":`\n      if(${A} < 1.0) discard;\n      gl_FragColor = packDepthToRGBA( dist );\n    `},[`${m}`]:{"material.clearcoat = clearcoat;":`material.clearcoat = ${m};`},[`${l}`]:{"material.clearcoatRoughness = clearcoatRoughness;":`material.clearcoatRoughness = ${l};`},[`${d}`]:{"#include <clearcoat_normal_fragment_begin>":"\n      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);\n      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;\n      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);\n    "},[`${_}`]:{"material.transmission = transmission;":`\n      material.transmission = ${_};\n    `},[`${f}`]:{"material.thickness = thickness;":`\n      material.thickness = ${f};\n    `},[`${M}`]:{"material.iridescence = iridescence;":`\n      material.iridescence = ${M};\n    `}},T={clearcoat:[m,d,l],transmission:[_],iridescence:[M]};function R(e){return e.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g,"")}class C extends e{constructor({baseMaterial:e,vertexShader:n,fragmentShader:a,uniforms:s,patchMap:i,cacheKey:r,...t}){if(!e)throw new Error("CustomShaderMaterial: baseMaterial is required.");let c;if(function(n){try{new n}catch(e){if(e.message.indexOf("is not a constructor")>=0)return!1}return!0}(e)){const n=0===Object.keys(t).length;c=new e(n?void 0:t)}else c=e,Object.assign(c,t);if(["ShaderMaterial","RawShaderMaterial"].includes(c.type))throw new Error(`CustomShaderMaterial does not support ${c.type} as a base material.`);super(),this.uniforms={},this.vertexShader="",this.fragmentShader="";const o=c;o.name=`CustomShaderMaterial<${c.name||c.type}>`,o.update=this.update.bind(o),o.__csm={prevOnBeforeCompile:c.onBeforeCompile,baseMaterial:c,vertexShader:n,fragmentShader:a,uniforms:s,patchMap:i,cacheKey:r};const m={...o.uniforms||{},...s||{}};o.uniforms=this.uniforms=m,o.vertexShader=this.vertexShader=n||"",o.fragmentShader=this.fragmentShader=a||"",o.update({fragmentShader:o.fragmentShader,vertexShader:o.vertexShader,uniforms:o.uniforms,patchMap:i,cacheKey:r}),Object.assign(this,o);const l=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(o));for(const d in l){const e=l[d];(e.get||e.set)&&Object.defineProperty(this,d,e)}return Object.defineProperty(this,"type",{get:()=>c.type,set(e){c.type=e}}),this}update({fragmentShader:e,vertexShader:n,uniforms:a,cacheKey:s,patchMap:i}){const r=R(n||""),t=R(e||""),c=this;a&&(c.uniforms=a),n&&(c.vertexShader=n),e&&(c.fragmentShader=e),Object.entries(T).forEach((([e,n])=>{for(const a in n){const s=n[a];(t&&t.includes(s)||r&&r.includes(s))&&(c[e]||(c[e]=1))}}));const o=c.__csm.prevOnBeforeCompile,m=(e,n,a)=>{let s,i="";if(n){const e=n.search(/void\s+main\s*\(\s*\)\s*{/);if(-1!==e){i=n.slice(0,e);let a=0,r=-1;for(let s=e;s<n.length;s++)if("{"===n[s]&&a++,"}"===n[s]&&(a--,0===a)){r=s;break}if(-1!==r){const a=n.slice(e,r+1);s=a.slice(a.indexOf("{")+1,-1)}}else i=n}if(a&&n&&n.includes(h)&&s&&(s="csm_UnlitFac = 1.0;\n"+s),e.includes("//~CSM_DEFAULTS")){const n=(e=e.replace("void main() {",`\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\n  \n          ${i}\n          \n          void main() {\n          `)).lastIndexOf("//~CSM_MAIN_END");if(-1!==n){const a=`\n            ${s?`${s}`:""}\n            //~CSM_MAIN_END\n          `;e=e.slice(0,n)+a+e.slice(n)}}else{const n=/void\s*main\s*\(\s*\)\s*{/gm;e=e.replace(n,`\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\n  \n          //~CSM_DEFAULTS\n          \n    varying mat4 csm_internal_vModelViewMatrix;\n\n          \n    \n#ifdef IS_VERTEX\n    vec3 csm_Position;\n    vec4 csm_PositionRaw;\n    vec3 csm_Normal;\n\n    // csm_PointSize\n    #ifdef IS_POINTSMATERIAL\n        float csm_PointSize;\n    #endif\n#else\n    vec4 csm_DiffuseColor;\n    vec4 csm_FragColor;\n    float csm_UnlitFac;\n\n    // csm_Emissive, csm_Roughness, csm_Metalness\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\n        vec3 csm_Emissive;\n        float csm_Roughness;\n        float csm_Metalness;\n        float csm_Iridescence;\n        \n        #if defined IS_MESHPHYSICALMATERIAL\n            float csm_Clearcoat;\n            float csm_ClearcoatRoughness;\n            vec3 csm_ClearcoatNormal;\n            float csm_Transmission;\n            float csm_Thickness;\n        #endif\n    #endif\n\n    // csm_AO\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\n        float csm_AO;\n    #endif\n\n    // csm_Bump\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \n        vec3 csm_Bump;\n        vec3 csm_FragNormal;\n    #endif\n\n    float csm_DepthAlpha;\n#endif\n\n  \n          ${i}\n          \n          void main() {\n            {\n              \n\n#ifdef IS_VERTEX\n    // csm_Position & csm_PositionRaw\n    #ifdef IS_UNKNOWN\n        csm_Position = vec3(0.0);\n        csm_PositionRaw = vec4(0.0);\n        csm_Normal = vec3(0.0);\n    #else\n        csm_Position = position;\n        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n        csm_Normal = normal;\n    #endif\n\n    // csm_PointSize\n    #ifdef IS_POINTSMATERIAL\n        csm_PointSize = size;\n    #endif\n#else\n    csm_UnlitFac = 0.0;\n\n    // csm_DiffuseColor & csm_FragColor\n    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL\n        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\n        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n    #else\n        #ifdef USE_MAP\n            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);\n\n            #ifdef DECODE_VIDEO_TEXTURE\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\n            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);\n            #endif\n\n            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\n            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\n        #else\n            csm_DiffuseColor = vec4(diffuse, opacity);\n            csm_FragColor = vec4(diffuse, opacity);\n        #endif\n    #endif\n\n    // csm_Emissive, csm_Roughness, csm_Metalness\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\n        csm_Emissive = emissive;\n        csm_Roughness = roughness;\n        csm_Metalness = metalness;\n\n        #ifdef USE_IRIDESCENCE\n            csm_Iridescence = iridescence;\n        #else\n            csm_Iridescence = 0.0;\n        #endif\n\n        #if defined IS_MESHPHYSICALMATERIAL\n            #ifdef USE_CLEARCOAT\n                csm_Clearcoat = clearcoat;\n                csm_ClearcoatRoughness = clearcoatRoughness;\n            #else\n                csm_Clearcoat = 0.0;\n                csm_ClearcoatRoughness = 0.0;\n            #endif\n\n            #ifdef USE_TRANSMISSION\n                csm_Transmission = transmission;\n                csm_Thickness = thickness;\n            #else\n                csm_Transmission = 0.0;\n                csm_Thickness = 0.0;\n            #endif\n        #endif\n    #endif\n\n    // csm_AO\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\n        csm_AO = 0.0;\n    #endif\n\n    // csm_Bump\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \n        csm_Bump = vec3(0.0);\n        #ifdef FLAT_SHADED\n            vec3 fdx = dFdx( vViewPosition );\n            vec3 fdy = dFdy( vViewPosition );\n            csm_FragNormal = normalize( cross( fdx, fdy ) );\n        #else\n            csm_FragNormal = normalize(vNormal);\n            #ifdef DOUBLE_SIDED\n                csm_FragNormal *= gl_FrontFacing ? 1.0 : - 1.0;\n            #endif\n        #endif\n    #endif\n\n    csm_DepthAlpha = 1.0;\n#endif\n\n            }\n            ${a?"\n    \n":"\n    csm_internal_vModelViewMatrix = modelViewMatrix;\n"}\n\n            ${s?`${s}`:""}\n            //~CSM_MAIN_END\n          `)}return e};c.onBeforeCompile=(e,n)=>{null==o||o(e,n);const s=i||{},l=c.type,d=l?`#define IS_${l.toUpperCase()};\n`:"#define IS_UNKNOWN;\n";e.vertexShader=d+"#define IS_VERTEX\n"+e.vertexShader,e.fragmentShader=d+"#define IS_FRAGMENT\n"+e.fragmentShader;const _=n=>{for(const a in n){const s="*"===a||r&&r.includes(a);if("*"===a||t&&t.includes(a)||s){const s=I[a];if(s&&"*"!==s&&(Array.isArray(s)?!s.includes(l):s!==l))return void console.error(`CustomShaderMaterial: ${a} is not available in ${l}. Shader cannot compile.`);const i=n[a];for(const n in i){const a=i[n];if("object"==typeof a){const s=a.type,i=a.value;"fs"===s?e.fragmentShader=e.fragmentShader.replace(n,i):"vs"===s&&(e.vertexShader=e.vertexShader.replace(n,i))}else a&&(e.vertexShader=e.vertexShader.replace(n,a),e.fragmentShader=e.fragmentShader.replace(n,a))}}}};_(v),_(s),e.vertexShader=m(e.vertexShader,r,!1),e.fragmentShader=m(e.fragmentShader,t,!0),a&&(e.uniforms={...e.uniforms,...c.uniforms}),c.uniforms=e.uniforms};const l=c.customProgramCacheKey;c.customProgramCacheKey=()=>((null==s?void 0:s())||function(e){let n=0;for(let a=0;a<e.length;a++)n=e.charCodeAt(a)+(n<<6)+(n<<16)-n;return String(n>>>0)}((r||"")+(t||"")))+(null==l?void 0:l.call(c)),c.needsUpdate=!0}clone(){const e=this;return new e.constructor({baseMaterial:e.__csm.baseMaterial.clone(),vertexShader:e.__csm.vertexShader,fragmentShader:e.__csm.fragmentShader,uniforms:e.__csm.uniforms,patchMap:e.__csm.patchMap,cacheKey:e.__csm.cacheKey})}}export{C as z};
