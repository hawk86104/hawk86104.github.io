import{c0 as t,ak as n,am as e,bk as o}from"./three.WgQSjl1J1738818486026.js";import{o as r}from"./@tresjs.ZGxFoQtw1738818486026.js";import{P as s}from"./tweakpane.yDiyAAkA1738818486026.js";import{d as i,r as a,b as u,q as c,p as l,W as f,w as p,e as h,o as g,f as b,g as d,N as m,u as y,H as T,M as x,j as M,m as w}from"./@vue.NRI7TcgI1738818486026.js";import"./@vueuse.Fak-HUpz1738818486026.js";function I(t,n){const e=v();return(I=function(t,n){return e[t-=237]})(t,n)}function v(){const t=["addBinding","22020nSkrTg","groupVisible","function *\\( *\\)","info","boxVisible","input","init","863779miGqza","boxRef","gger","length","toString","TresPerspectiveCamera","4YHVZtv","#000000","#ff0000","1011640DPqPZW","warn","call","TresGroup","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","stateObject","236013evxnUC","1534563WCNLZP","TresAmbientLight","#ef11ef","bind","7925QJJARp","6568580mWEMsi","#efefef","12HQIYys","constructor","test","theConditional","TresCanvas","prototype","TresBoxGeometry","TresMesh","TresDirectionalLight","apply","164INXItg","console","table","return (function() ","boxPropMaterialVisible","action","#efef11","counter","$refs","debu","value","TresMeshBasicMaterial","error"];return(v=function(){return t})()}const j=I;!function(t,n){const e=I,o=v();for(;;)try{if(128399===-parseInt(e(279))/1+-parseInt(e(265))/2*(parseInt(e(274))/3)+-parseInt(e(238))/4*(-parseInt(e(252))/5)+-parseInt(e(282))/6*(parseInt(e(259))/7)+-parseInt(e(268))/8+-parseInt(e(275))/9+parseInt(e(280))/10)break;o.push(o.shift())}catch(r){o.push(o.shift())}}();const k=function(){let t=!0;return function(n,e){const o=t?function(){if(e){const t=e[I(237)](n,arguments);return e=null,t}}:function(){};return t=!1,o}}();!function(){k(this,(function(){const t=I,n=new RegExp(t(254)),e=new RegExp(t(272),"i"),o=L(t(258));n[t(284)](o+"chain")&&e[t(284)](o+t(257))?L():o("0")}))()}();const _=function(){let t=!0;return function(n,e){const o=t?function(){if(e){const t=e[I(237)](n,arguments);return e=null,t}}:function(){};return t=!1,o}}();_(void 0,(function(){const t=I,n=function(){const t=I;let n;try{n=Function(t(241)+'{}.constructor("return this")( ));')()}catch(e){n=window}return n}(),e=n[t(239)]=n.console||{},o=["log",t(269),t(255),t(250),"exception",t(240),"trace"];for(let r=0;r<o[t(262)];r++){const n=_.constructor[t(287)][t(278)](_),s=o[r],i=e[s]||n;n.__proto__=_.bind(_),n[t(263)]=i.toString.bind(i),e[s]=n}}))();const C=["material"],P={key:0,position:[4,0,0]},B={key:1,position:[4,1,0]},G={key:2,position:[0,-4,-5]},V=i({__name:j(285),setup(i){const I=j,v=a({clearColor:I(266),shadows:!0,alpha:!1,shadowMapType:t,outputColorSpace:n,toneMapping:e,useLegacyLights:!1}),k=u({groupVisible:!0,boxPropMaterialVisible:!0}),_=u(null),V=u(!0);let L=null,R=null;c((()=>{const t=I;!L&&(L=new s({title:"显隐参数",expanded:!0}),L[t(251)](V,t(248),{label:t(256)}),L[t(251)](k[t(248)],t(242)),L[t(251)](k[t(248)],t(253))),R=l().proxy})),f((()=>{L&&(L.dispose(),L=null)})),p((()=>V),((t,n)=>{const e=I;void 0!==n&&(R[e(246)].boxRef.visible=t[e(248)])}),{deep:!0});const Z=new o({color:I(267)});return(t,n)=>{const e=I,o=h(e(286));return g(),b(o,w(v,{"window-size":""}),{default:d((()=>[n[4]||(n[4]=m(e(264),{position:[11,11,11],fov:45,near:.1,far:1e3,"look-at":[-8,3,-3]},null,-1)),n[5]||(n[5]=m(e(290),{position:[0,8,4],intensity:.2,"cast-shadow":""},null,-1)),m("TresMesh",{ref_key:e(260),ref:_,position:[0,0,0],material:y(Z)},n[0]||(n[0]=[m(e(288),{args:[1,1,1]},null,-1)]),8,C),k[e(248)][e(242)]?(g(),T("TresMesh",P,n[1]||(n[1]=[m("TresBoxGeometry",{args:[1,1,1]},null,-1),m("TresMeshToonMaterial",{color:e(281)},null,-1)]))):x("",!0),k[e(248)][e(242)]?(g(),T(e(289),B,n[2]||(n[2]=[m("TresBoxGeometry",{args:[1,1,1]},null,-1),m("TresMeshToonMaterial",{color:e(281)},null,-1)]))):x("",!0),k[e(248)][e(253)]?(g(),T(e(271),G,n[3]||(n[3]=[m(e(271),null,[m(e(289),{position:[0,0,0]},[m("TresBoxGeometry",{args:[1,1,1]}),m(e(249),{color:e(244)})]),m("TresMesh",{position:[0,2,0]},[m(e(288),{args:[1,1,1]}),m(e(249),{color:e(277)})])],-1)]))):x("",!0),M(y(r)),n[6]||(n[6]=m(e(276),{intensity:.5},null,-1))])),_:1},16)}}});function L(t){function n(t){const e=I;if("string"==typeof t)return function(t){}.constructor("while (true) {}")[e(237)](e(245));1!==(""+t/t)[e(262)]||t%20==0?function(){return!0}[e(283)]("debugger")[e(270)](e(243)):function(){return!1}[e(283)](e(247)+e(261))[e(237)](e(273)),n(++t)}try{if(t)return n;n(0)}catch(e){}}export{V as default};
