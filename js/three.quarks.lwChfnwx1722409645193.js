import{ae as e,q as t,r as n,bH as i,Y as r,Z as s,aL as a,aN as o,a3 as l,K as d,N as f,bI as m,ba as c,k as h,B as u,a as p,af as v,V as g,bJ as y,b4 as _,c as S,_ as x,b as M,b0 as T,b1 as E,aA as U,bK as P,bL as A,f as w,g as B,I as b,a1 as C,bM as O,bN as R,aY as N,bO as z,aZ as L,a_ as I,bl as F,O as D,a7 as V,o as k,C as G,bP as H,bQ as j,bR as X}from"./three.6E5muTWJ1722409645193.js";import{V as Y,C as J,A as W,M as q,a as Z,b as K,S as Q,T as $,c as ee,Q as te,E as ne,d as ie,G as re,e as se,B as ae,l as oe,f as le,g as de,h as fe,i as me,j as ce,k as he,m as ue,n as pe,o as ve,p as ge,q as ye,r as _e,s as Se,D as xe,t as Me,u as Te,v as Ee,w as Ue,x as Pe,F as Ae,y as we,z as Be,H as be,I as Ce,J as Oe,K as Re,L as Ne,N as ze,O as Le,P as Ie,R as Fe,U as De,W as Ve,X as ke,Y as Ge,Z as He,_ as je,$ as Xe,a0 as Ye,a1 as Je,a2 as We,a3 as qe,a4 as Ze,a5 as Ke,a6 as Qe,a7 as $e,a8 as et,a9 as tt,aa as nt,ab as it,ac as rt,ad as st,ae as at,af as ot,ag as lt,ah as dt,ai as ft,aj as mt,ak as ct,al as ht,am as ut,an as pt,ao as vt,ap as gt,aq as yt,ar as _t,as as St,at as xt,au as Mt,av as Tt,aw as Et,ax as Ut,ay as Pt,az as At,aA as wt,aB as Bt,aC as bt,aD as Ct,aE as Ot,aF as Rt,aG as Nt,aH as zt,aI as Lt}from"./quarks.core.4MLLO9vf1722409645193.js";const It=X;function Ft(){It.tile_pars_vertex="\n#ifdef UV_TILE\n    attribute float uvTile;\n    uniform vec2 tileCount;\n    \n    mat3 makeTileTransform(float uvTile) {\n        float col = mod(uvTile, tileCount.x);\n        float row = (tileCount.y - floor(uvTile / tileCount.x) - 1.0);\n        \n        return mat3(\n          1.0 / tileCount.x, 0.0, 0.0,\n          0.0, 1.0 / tileCount.y, 0.0, \n          col / tileCount.x, row / tileCount.y, 1.0);\n    }\n#else\n    mat3 makeTileTransform(float uvTile) {\n        return mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    }\n#endif\n\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\n\tvarying vec2 vUv;\n#ifdef TILE_BLEND\n    varying vec2 vUvNext;\n    varying float vUvBlend;\n#endif\n\n#endif\n#ifdef USE_MAP\n\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#ifdef TILE_BLEND\n    varying vec2 vMapUvNext;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n\n#endif\n#ifdef USE_AOMAP\n\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n\n#endif\n#ifdef USE_BUMPMAP\n\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n\n#endif\n#ifdef USE_NORMALMAP\n\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n\n#endif\n#ifdef USE_METALNESSMAP\n\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n\n#endif\n#ifdef USE_SPECULARMAP\n\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n\n#endif\n",It.tile_vertex="\n#ifdef UV_TILE\n    mat3 tileTransform = makeTileTransform(floor(uvTile));\n    #ifdef TILE_BLEND\n        mat3 nextTileTransform = makeTileTransform(ceil(uvTile));\n        vUvBlend = fract(uvTile);\n    #endif\n#else\n    mat3 tileTransform = makeTileTransform(0.0);\n#endif\n\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\nvUv = (tileTransform *vec3( uv, 1 )).xy;\n#if defined( TILE_BLEND ) && defined( UV_TILE )\n    vUvNext = (nextTileTransform *vec3( uv, 1 )).xy;\n#endif\n\n#endif\n#ifdef USE_MAP\n\nvMapUv = ( tileTransform * (mapTransform * vec3( MAP_UV, 1 ) )).xy;\n#if defined( TILE_BLEND ) && defined( UV_TILE )\n    vMapUvNext = (nextTileTransform * (mapTransform * vec3( MAP_UV, 1 ))).xy;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\nvAlphaMapUv = ( tileTransform * (alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) )).xy;\n    \n#endif\n#ifdef USE_LIGHTMAP\n\nvLightMapUv = ( tileTransform * (lightMapTransform * vec3( LIGHTMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_AOMAP\n\nvAoMapUv = ( tileTransform * (aoMapTransform * vec3( AOMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_BUMPMAP\n\nvBumpMapUv = ( tileTransform * (bumpMapTransform * vec3( BUMPMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_NORMALMAP\n\nvNormalMapUv = ( tileTransform * (normalMapTransform * vec3( NORMALMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\nvDisplacementMapUv = ( tileTransform * (displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\nvEmissiveMapUv = ( tileTransform * (emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_METALNESSMAP\n\nvMetalnessMapUv = ( tileTransform * (metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\nvRoughnessMapUv = ( tileTransform * (roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\nvAnisotropyMapUv = ( tileTransform * (anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\nvClearcoatMapUv = ( tileTransform * (clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\nvClearcoatNormalMapUv = ( tileTransform * (clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\nvClearcoatRoughnessMapUv = ( tileTransform * (clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\nvIridescenceMapUv = ( tileTransform * (iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\nvIridescenceThicknessMapUv = ( tileTransform * (iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\nvSheenColorMapUv = ( tileTransform * (sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\nvSheenRoughnessMapUv = ( tileTransform * (sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULARMAP\n\nvSpecularMapUv = ( tileTransform * (specularMapTransform * vec3( SPECULARMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\nvSpecularColorMapUv = ( tileTransform * (specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\nvSpecularIntensityMapUv = ( tileTransform * (specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\nvTransmissionMapUv = ( tileTransform * transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\nvThicknessMapUv = ( tileTransform * thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) )).xy;\n\n#endif\n\n",It.tile_pars_fragment="\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\n\tvarying vec2 vUv;\n#ifdef TILE_BLEND\n    varying vec2 vUvNext;\n    varying float vUvBlend;\n#endif\n\n#endif\n#ifdef USE_MAP\n\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#ifdef TILE_BLEND\n    varying vec2 vMapUvNext;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n\n#endif\n#ifdef USE_AOMAP\n\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n\n#endif\n#ifdef USE_BUMPMAP\n\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n\n#endif\n#ifdef USE_NORMALMAP\n\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n\n#endif\n#ifdef USE_METALNESSMAP\n\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n\n#endif\n#ifdef USE_SPECULARMAP\n\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n\n#endif\n",It.tile_fragment="\n#ifdef USE_MAP\n    vec4 texelColor = texture2D( map, vUv);\n    #ifdef TILE_BLEND\n        texelColor = mix( texelColor, texture2D( map, vUvNext ), vUvBlend );\n    #endif\n    diffuseColor *= texelColor;\n#endif\n",It.soft_pars_vertex="\n#ifdef SOFT_PARTICLES\n    varying vec4 projPosition;\n    varying float linearDepth;\n#endif\n",It.soft_vertex="\n#ifdef SOFT_PARTICLES\n    projPosition = gl_Position;\n    linearDepth = -mvPosition.z;\n#endif\n",It.soft_pars_fragment="\n#ifdef SOFT_PARTICLES\n\n    uniform sampler2D depthTexture;\n    uniform vec4 projParams;\n    uniform vec2 softParams;\n\n    varying vec4 projPosition;\n    varying float linearDepth;\n\n    #define SOFT_NEAR_FADE softParams.x\n    #define SOFT_INV_FADE_DISTANCE softParams.y\n\n    #define zNear projParams.x\n    #define zFar projParams.y\n\n    float linearize_depth(float d)\n    {\n        return (zFar * zNear) / (zFar - d * (zFar - zNear));\n    }\n\n#endif\n",It.soft_fragment="\n#ifdef SOFT_PARTICLES\n\n    /* #ifdef LOGDEPTH\n    float distSample = linearize_depth_log(sampleDepth, near, far);\n    #else\n    float distSample = ortho ? linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far);\n    #endif */\n\n    vec2 p2 = projPosition.xy / projPosition.w;\n    \n    p2 = 0.5 * p2 + 0.5;\n\n    float readDepth = texture2D(depthTexture, p2.xy).r;\n    float viewDepth = linearize_depth(readDepth);\n\n    float softParticlesFade = saturate(SOFT_INV_FADE_DISTANCE * ((viewDepth - SOFT_NEAR_FADE) - linearDepth));\n    \n    gl_FragColor *= softParticlesFade;\n\n    //gl_FragColor = vec4(softParticlesFade , 0, 0, 1);\n#endif\n"}class Dt extends e{constructor(e){super(),this.type="ParticleEmitter",this.system=e}clone(){const e=this.system.clone();return e.emitter.copy(this,!0),e.emitter}dispose(){}extractFromCache(e){const t=[];for(const n in e){const i=e[n];delete i.metadata,t.push(i)}return t}toJSON(e,t={}){const n=this.children;this.children=this.children.filter((e=>"ParticleSystemPreview"!==e.type));const i=super.toJSON(e);return this.children=n,null!==this.system&&(i.object.ps=this.system.toJSON(e,t)),i}}var Vt,kt;(kt=Vt||(Vt={}))[kt.BillBoard=0]="BillBoard",kt[kt.StretchedBillBoard=1]="StretchedBillBoard",kt[kt.Mesh=2]="Mesh",kt[kt.Trail=3]="Trail",kt[kt.HorizontalBillBoard=4]="HorizontalBillBoard",kt[kt.VerticalBillBoard=5]="VerticalBillBoard";class Gt extends t{constructor(e){super(),this.type="VFXBatch",this.maxParticles=1e3,this.systems=new Set;const t=new i;t.mask=e.layers.mask;const n=e.material.clone();n.defines={},Object.assign(n.defines,e.material.defines),this.settings={instancingGeometry:e.instancingGeometry,renderMode:e.renderMode,renderOrder:e.renderOrder,material:n,uTileCount:e.uTileCount,vTileCount:e.vTileCount,blendTiles:e.blendTiles,softParticles:e.softParticles,softNearFade:e.softNearFade,softFarFade:e.softFarFade,layers:t},this.frustumCulled=!1,this.renderOrder=this.settings.renderOrder}addSystem(e){this.systems.add(e)}removeSystem(e){this.systems.delete(e)}applyDepthTexture(e){const t=this.material.uniforms.depthTexture;t&&t.value!==e&&(t.value=e,this.material.needsUpdate=!0)}}const Ht=new Y(0,0,1),jt=new te,Xt=new Y,Yt=new Y;new Y;const Jt=new n(1,1,1,1);class Wt{set time(e){this.emissionState.time=e}get time(){return this.emissionState.time}get layers(){return this.rendererSettings.layers}get texture(){return this.rendererSettings.material.map}set texture(e){this.rendererSettings.material.map=e,this.neededToUpdateRender=!0}get material(){return this.rendererSettings.material}set material(e){this.rendererSettings.material=e,this.neededToUpdateRender=!0}get uTileCount(){return this.rendererSettings.uTileCount}set uTileCount(e){this.rendererSettings.uTileCount=e,this.neededToUpdateRender=!0}get vTileCount(){return this.rendererSettings.vTileCount}set vTileCount(e){this.rendererSettings.vTileCount=e,this.neededToUpdateRender=!0}get blendTiles(){return this.rendererSettings.blendTiles}set blendTiles(e){this.rendererSettings.blendTiles=e,this.neededToUpdateRender=!0}get softParticles(){return this.rendererSettings.softParticles}set softParticles(e){this.rendererSettings.softParticles=e,this.neededToUpdateRender=!0}get softNearFade(){return this.rendererSettings.softNearFade}set softNearFade(e){this.rendererSettings.softNearFade=e,this.neededToUpdateRender=!0}get softFarFade(){return this.rendererSettings.softFarFade}set softFarFade(e){this.rendererSettings.softFarFade=e,this.neededToUpdateRender=!0}get instancingGeometry(){return this.rendererSettings.instancingGeometry}set instancingGeometry(e){this.restart(),this.particles.length=0,this.rendererSettings.instancingGeometry=e,this.neededToUpdateRender=!0}get renderMode(){return this.rendererSettings.renderMode}set renderMode(e){if((this.rendererSettings.renderMode!=Vt.Trail&&e===Vt.Trail||this.rendererSettings.renderMode==Vt.Trail&&e!==Vt.Trail)&&(this.restart(),this.particles.length=0),this.rendererSettings.renderMode!==e)switch(e){case Vt.Trail:this.rendererEmitterSettings={startLength:new J(30),followLocalOrigin:!1};break;case Vt.Mesh:this.rendererEmitterSettings={geometry:new n(1,1)},this.startRotation=new W(new Y(0,1,0),new J(0));break;case Vt.StretchedBillBoard:this.rendererEmitterSettings={speedFactor:0,lengthFactor:2},this.rendererSettings.renderMode===Vt.Mesh&&(this.startRotation=new J(0));break;case Vt.BillBoard:case Vt.VerticalBillBoard:case Vt.HorizontalBillBoard:this.rendererEmitterSettings={},this.rendererSettings.renderMode===Vt.Mesh&&(this.startRotation=new J(0))}this.rendererSettings.renderMode=e,this.neededToUpdateRender=!0}get renderOrder(){return this.rendererSettings.renderOrder}set renderOrder(e){this.rendererSettings.renderOrder=e,this.neededToUpdateRender=!0}get blending(){return this.rendererSettings.material.blending}set blending(e){this.rendererSettings.material.blending=e,this.neededToUpdateRender=!0}constructor(e){var t,n,r,s,a,o,l,d,f,m,c,h,u,p,v,g,y,_,S,x,M,T,E,U,P,A;if(this.temp=new Y,this.travelDistance=0,this.normalMatrix=new q,this.memory=[],this.firstTimeUpdate=!0,this.autoDestroy=void 0!==e.autoDestroy&&e.autoDestroy,this.duration=null!==(t=e.duration)&&void 0!==t?t:1,this.looping=void 0===e.looping||e.looping,this.prewarm=void 0!==e.prewarm&&e.prewarm,this.startLife=null!==(n=e.startLife)&&void 0!==n?n:new J(5),this.startSpeed=null!==(r=e.startSpeed)&&void 0!==r?r:new J(0),this.startRotation=null!==(s=e.startRotation)&&void 0!==s?s:new J(0),this.startSize=null!==(a=e.startSize)&&void 0!==a?a:new J(1),this.startColor=null!==(o=e.startColor)&&void 0!==o?o:new Z(new K(1,1,1,1)),this.emissionOverTime=null!==(l=e.emissionOverTime)&&void 0!==l?l:new J(10),this.emissionOverDistance=null!==(d=e.emissionOverDistance)&&void 0!==d?d:new J(0),this.emissionBursts=null!==(f=e.emissionBursts)&&void 0!==f?f:[],this.onlyUsedByOther=null!==(m=e.onlyUsedByOther)&&void 0!==m&&m,this.emitterShape=null!==(c=e.shape)&&void 0!==c?c:new Q,this.behaviors=null!==(h=e.behaviors)&&void 0!==h?h:new Array,this.worldSpace=null!==(u=e.worldSpace)&&void 0!==u&&u,this.rendererEmitterSettings=null!==(p=e.rendererEmitterSettings)&&void 0!==p?p:{},e.renderMode===Vt.StretchedBillBoard){const t=this.rendererEmitterSettings;void 0!==e.speedFactor&&(t.speedFactor=e.speedFactor),t.speedFactor=null!==(v=t.speedFactor)&&void 0!==v?v:0,t.lengthFactor=null!==(g=t.lengthFactor)&&void 0!==g?g:0}this.rendererSettings={instancingGeometry:null!==(y=e.instancingGeometry)&&void 0!==y?y:Jt,renderMode:null!==(_=e.renderMode)&&void 0!==_?_:Vt.BillBoard,renderOrder:null!==(S=e.renderOrder)&&void 0!==S?S:0,material:e.material,uTileCount:null!==(x=e.uTileCount)&&void 0!==x?x:1,vTileCount:null!==(M=e.vTileCount)&&void 0!==M?M:1,blendTiles:null!==(T=e.blendTiles)&&void 0!==T&&T,softParticles:null!==(E=e.softParticles)&&void 0!==E&&E,softNearFade:null!==(U=e.softNearFade)&&void 0!==U?U:0,softFarFade:null!==(P=e.softFarFade)&&void 0!==P?P:0,layers:null!==(A=e.layers)&&void 0!==A?A:new i},this.neededToUpdateRender=!0,this.particles=new Array,this.startTileIndex=e.startTileIndex||new J(0),this.emitter=new Dt(this),this.paused=!1,this.particleNum=0,this.emissionState={isBursting:!1,burstParticleIndex:0,burstParticleCount:0,burstIndex:0,burstWaveIndex:0,time:0,waitEmiting:0,travelDistance:0},this.emissionBursts.forEach((e=>e.count.startGen(this.memory))),this.emissionOverDistance.startGen(this.memory),this.emitEnded=!1,this.markForDestroy=!1,this.prewarmed=!1}pause(){this.paused=!0}play(){this.paused=!1}stop(){this.restart(),this.pause()}spawn(e,t,n){jt.setFromRotationMatrix(n);const i=Xt,r=jt,s=Yt;n.decompose(i,r,s);for(let a=0;a<e;a++){for(t.burstParticleIndex=a,this.particleNum++;this.particles.length<this.particleNum;)this.rendererSettings.renderMode===Vt.Trail?this.particles.push(new $):this.particles.push(new ee);const e=this.particles[this.particleNum-1];if(e.reset(),e.speedModifier=1,this.startColor.startGen(e.memory),this.startColor.genColor(e.memory,e.startColor,this.emissionState.time),e.color.copy(e.startColor),this.startSpeed.startGen(e.memory),e.startSpeed=this.startSpeed.genValue(e.memory,t.time/this.duration),this.startLife.startGen(e.memory),e.life=this.startLife.genValue(e.memory,t.time/this.duration),e.age=0,this.startSize.startGen(e.memory),"vec3function"===this.startSize.type)this.startSize.genValue(e.memory,e.startSize,t.time/this.duration);else{const n=this.startSize.genValue(e.memory,t.time/this.duration);e.startSize.set(n,n,n)}if(this.startTileIndex.startGen(e.memory),e.uvTile=this.startTileIndex.genValue(e.memory),e.size.copy(e.startSize),this.rendererSettings.renderMode===Vt.Mesh||this.rendererSettings.renderMode===Vt.BillBoard||this.rendererSettings.renderMode===Vt.VerticalBillBoard||this.rendererSettings.renderMode===Vt.HorizontalBillBoard||this.rendererSettings.renderMode===Vt.StretchedBillBoard){const n=e;this.startRotation.startGen(e.memory),this.rendererSettings.renderMode===Vt.Mesh?(n.rotation instanceof te||(n.rotation=new te),"rotation"===this.startRotation.type?this.startRotation.genValue(e.memory,n.rotation,1,t.time/this.duration):n.rotation.setFromAxisAngle(Ht,this.startRotation.genValue(n.memory,t.time/this.duration))):"rotation"===this.startRotation.type?n.rotation=0:n.rotation=this.startRotation.genValue(n.memory,t.time/this.duration)}else if(this.rendererSettings.renderMode===Vt.Trail){const n=e;this.rendererEmitterSettings.startLength.startGen(n.memory),n.length=this.rendererEmitterSettings.startLength.genValue(n.memory,t.time/this.duration)}if(this.emitterShape.initialize(e,t),this.rendererSettings.renderMode===Vt.Trail&&this.rendererEmitterSettings.followLocalOrigin){const t=e;t.localPosition=(new Y).copy(t.position)}this.worldSpace?(e.position.applyMatrix4(n),e.startSize.multiply(s).abs(),e.size.copy(e.startSize),e.velocity.multiply(s).applyMatrix3(this.normalMatrix),e.rotation&&e.rotation instanceof te&&e.rotation.multiplyQuaternions(jt,e.rotation)):this.onlyUsedByOther&&(e.parentMatrix=n);for(let t=0;t<this.behaviors.length;t++)this.behaviors[t].initialize(e,this)}}endEmit(){this.emitEnded=!0,this.autoDestroy&&(this.markForDestroy=!0)}dispose(){this._renderer&&this._renderer.deleteSystem(this),this.emitter.dispose(),this.emitter.parent&&this.emitter.parent.remove(this.emitter)}restart(){this.memory.length=0,this.paused=!1,this.particleNum=0,this.emissionState.isBursting=!1,this.emissionState.burstIndex=0,this.emissionState.burstWaveIndex=0,this.emissionState.time=0,this.emissionState.waitEmiting=0,this.behaviors.forEach((e=>{e.reset()})),this.emitEnded=!1,this.markForDestroy=!1,this.prewarmed=!1,this.emissionBursts.forEach((e=>e.count.startGen(this.memory))),this.emissionOverDistance.startGen(this.memory)}update(e){if(this.paused)return;let t=this.emitter;for(;t.parent;)t=t.parent;if("Scene"===t.type)if(this.firstTimeUpdate&&(this.firstTimeUpdate=!1,this.emitter.updateWorldMatrix(!0,!1)),this.emitEnded&&0===this.particleNum)this.markForDestroy&&this.emitter.parent&&this.dispose();else{if(this.looping&&this.prewarm&&!this.prewarmed){this.prewarmed=!0;for(let e=0;e<60*this.duration;e++)this.update(1/60)}e>.1&&(e=.1),this.neededToUpdateRender&&(this._renderer&&this._renderer.updateSystem(this),this.neededToUpdateRender=!1),this.onlyUsedByOther||this.emit(e,this.emissionState,this.emitter.matrixWorld),this.emitterShape.update(this,e);for(let t=0;t<this.behaviors.length;t++){this.behaviors[t].frameUpdate(e);for(let n=0;n<this.particleNum;n++)this.particles[n].died||this.behaviors[t].update(this.particles[n],e)}for(let t=0;t<this.particleNum;t++)this.rendererEmitterSettings.followLocalOrigin&&this.particles[t].localPosition?(this.particles[t].position.copy(this.particles[t].localPosition),this.particles[t].parentMatrix?this.particles[t].position.applyMatrix4(this.particles[t].parentMatrix):this.particles[t].position.applyMatrix4(this.emitter.matrixWorld)):this.particles[t].position.addScaledVector(this.particles[t].velocity,e*this.particles[t].speedModifier),this.particles[t].age+=e;if(this.rendererSettings.renderMode===Vt.Trail)for(let e=0;e<this.particleNum;e++){this.particles[e].update()}for(let e=0;e<this.particleNum;e++){const t=this.particles[e];!t.died||t instanceof $&&0!==t.previous.length||(this.particles[e]=this.particles[this.particleNum-1],this.particles[this.particleNum-1]=t,this.particleNum--,e--)}}else this.dispose()}emit(e,t,n){t.time>this.duration&&(this.looping?(t.time-=this.duration,t.burstIndex=0,this.behaviors.forEach((e=>{e.reset()}))):this.emitEnded||this.onlyUsedByOther||this.endEmit()),this.normalMatrix.getNormalMatrix(n);const i=Math.ceil(t.waitEmiting);for(this.spawn(i,t,n),t.waitEmiting-=i;t.burstIndex<this.emissionBursts.length&&this.emissionBursts[t.burstIndex].time<=t.time;){if(Math.random()<this.emissionBursts[t.burstIndex].probability){const e=this.emissionBursts[t.burstIndex].count.genValue(this.memory,this.time);t.isBursting=!0,t.burstParticleCount=e,this.spawn(e,t,n),t.isBursting=!1}t.burstIndex++}if(!this.emitEnded&&(t.waitEmiting+=e*this.emissionOverTime.genValue(this.memory,t.time/this.duration),null!=t.previousWorldPos)){this.temp.set(n.elements[12],n.elements[13],n.elements[14]),t.travelDistance+=t.previousWorldPos.distanceTo(this.temp);const e=this.emissionOverDistance.genValue(this.memory,t.time/this.duration);if(t.travelDistance*e>0){const n=Math.floor(t.travelDistance*e);t.travelDistance-=n/e,t.waitEmiting+=n}}void 0===t.previousWorldPos&&(t.previousWorldPos=new Y),t.previousWorldPos.set(n.elements[12],n.elements[13],n.elements[14]),t.time+=e}toJSON(e,t={}){var n;if((void 0===e||"string"==typeof e)&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}}),e.materials[this.rendererSettings.material.uuid]=this.rendererSettings.material.toJSON(e),t.useUrlForImage&&void 0!==(null===(n=this.texture)||void 0===n?void 0:n.source)){const t=this.texture.source;e.images[t.uuid]={uuid:t.uuid,url:this.texture.image.url}}let i;i=this.renderMode===Vt.Trail?{startLength:this.rendererEmitterSettings.startLength.toJSON(),followLocalOrigin:this.rendererEmitterSettings.followLocalOrigin}:this.renderMode===Vt.Mesh?{}:this.renderMode===Vt.StretchedBillBoard?{speedFactor:this.rendererEmitterSettings.speedFactor,lengthFactor:this.rendererEmitterSettings.lengthFactor}:{};const r=this.rendererSettings.instancingGeometry;return e.geometries&&!e.geometries[r.uuid]&&(e.geometries[r.uuid]=r.toJSON()),{version:"3.0",autoDestroy:this.autoDestroy,looping:this.looping,prewarm:this.prewarm,duration:this.duration,shape:this.emitterShape.toJSON(),startLife:this.startLife.toJSON(),startSpeed:this.startSpeed.toJSON(),startRotation:this.startRotation.toJSON(),startSize:this.startSize.toJSON(),startColor:this.startColor.toJSON(),emissionOverTime:this.emissionOverTime.toJSON(),emissionOverDistance:this.emissionOverDistance.toJSON(),emissionBursts:this.emissionBursts.map((e=>({time:e.time,count:e.count.toJSON(),probability:e.probability,interval:e.interval,cycle:e.cycle}))),onlyUsedByOther:this.onlyUsedByOther,instancingGeometry:this.rendererSettings.instancingGeometry.uuid,renderOrder:this.renderOrder,renderMode:this.renderMode,rendererEmitterSettings:i,material:this.rendererSettings.material.uuid,layers:this.layers.mask,startTileIndex:this.startTileIndex.toJSON(),uTileCount:this.uTileCount,vTileCount:this.vTileCount,blendTiles:this.blendTiles,softParticles:this.rendererSettings.softParticles,softFarFade:this.rendererSettings.softFarFade,softNearFade:this.rendererSettings.softNearFade,behaviors:this.behaviors.map((e=>e.toJSON())),worldSpace:this.worldSpace}}static fromJSON(e,t,n){var o,l;const d=ne(e.shape,t);let f;if(e.renderMode===Vt.Trail){const t=e.rendererEmitterSettings;f={startLength:null!=t.startLength?ie(t.startLength):new J(30),followLocalOrigin:t.followLocalOrigin}}else e.renderMode===Vt.Mesh?f={}:e.renderMode===Vt.StretchedBillBoard?(f=e.rendererEmitterSettings,null!=e.speedFactor&&(f.speedFactor=e.speedFactor)):f={};const m=new i;e.layers&&(m.mask=e.layers);const c=new Wt({autoDestroy:e.autoDestroy,looping:e.looping,prewarm:e.prewarm,duration:e.duration,shape:d,startLife:ie(e.startLife),startSpeed:ie(e.startSpeed),startRotation:re(e.startRotation),startSize:re(e.startSize),startColor:se(e.startColor),emissionOverTime:ie(e.emissionOverTime),emissionOverDistance:ie(e.emissionOverDistance),emissionBursts:null===(o=e.emissionBursts)||void 0===o?void 0:o.map((e=>{var t,n,i;return{time:e.time,count:"number"==typeof e.count?new J(e.count):ie(e.count),probability:null!==(t=e.probability)&&void 0!==t?t:1,interval:null!==(n=e.interval)&&void 0!==n?n:.1,cycle:null!==(i=e.cycle)&&void 0!==i?i:1}})),onlyUsedByOther:e.onlyUsedByOther,instancingGeometry:t.geometries[e.instancingGeometry],renderMode:e.renderMode,rendererEmitterSettings:f,renderOrder:e.renderOrder,layers:m,material:e.material?t.materials[e.material]:e.texture?new r({map:t.textures[e.texture],transparent:null===(l=e.transparent)||void 0===l||l,blending:e.blending,side:s}):new r({color:16777215,transparent:!0,blending:a,side:s}),startTileIndex:"number"==typeof e.startTileIndex?new J(e.startTileIndex):ie(e.startTileIndex),uTileCount:e.uTileCount,vTileCount:e.vTileCount,blendTiles:e.blendTiles,softParticles:e.softParticles,softFarFade:e.softFarFade,softNearFade:e.softNearFade,behaviors:[],worldSpace:e.worldSpace});return c.behaviors=e.behaviors.map((e=>{const t=ae(e,c);return"EmitSubParticleSystem"===t.type&&(n[e.subParticleSystem]=t),t})),c}addBehavior(e){this.behaviors.push(e)}getRendererSettings(){return this.rendererSettings}clone(){const e=[];for(const i of this.emissionBursts){const t={};Object.assign(t,i),e.push(t)}const t=[];for(const i of this.behaviors)t.push(i.clone());let n;n=this.renderMode===Vt.Trail?{startLength:this.rendererEmitterSettings.startLength.clone(),followLocalOrigin:this.rendererEmitterSettings.followLocalOrigin}:{};const r=new i;return r.mask=this.layers.mask,new Wt({autoDestroy:this.autoDestroy,looping:this.looping,duration:this.duration,shape:this.emitterShape.clone(),startLife:this.startLife.clone(),startSpeed:this.startSpeed.clone(),startRotation:this.startRotation.clone(),startSize:this.startSize.clone(),startColor:this.startColor.clone(),emissionOverTime:this.emissionOverTime.clone(),emissionOverDistance:this.emissionOverDistance.clone(),emissionBursts:e,onlyUsedByOther:this.onlyUsedByOther,instancingGeometry:this.rendererSettings.instancingGeometry,renderMode:this.renderMode,renderOrder:this.renderOrder,rendererEmitterSettings:n,material:this.rendererSettings.material,startTileIndex:this.startTileIndex,uTileCount:this.uTileCount,vTileCount:this.vTileCount,blendTiles:this.blendTiles,softParticles:this.softParticles,softFarFade:this.softFarFade,softNearFade:this.softNearFade,behaviors:t,worldSpace:this.worldSpace,layers:r})}}var qt="\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <alphatest_pars_fragment>\n\n#include <tile_pars_fragment>\n#include <soft_pars_fragment>\n\nvoid main() {\n\n    #include <clipping_planes_fragment>\n    \n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vColor;\n    \n    #include <logdepthbuf_fragment>\n    \n    #include <tile_fragment>\n    #include <alphatest_fragment>\n\n    outgoingLight = diffuseColor.rgb;\n    \n    #ifdef USE_COLOR_AS_ALPHA\n    gl_FragColor = vec4( outgoingLight, diffuseColor.r );\n    #else\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #endif\n    \n    #include <soft_fragment>\n    #include <tonemapping_fragment>\n}\n",Zt="\n#define STANDARD\n\n#ifdef PHYSICAL\n#define IOR\n#define USE_SPECULAR\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef IOR\nuniform float ior;\n#endif\n\n#ifdef USE_SPECULAR\nuniform float specularIntensity;\nuniform vec3 specularColor;\n\n#ifdef USE_SPECULAR_COLORMAP\nuniform sampler2D specularColorMap;\n#endif\n\n#ifdef USE_SPECULAR_INTENSITYMAP\nuniform sampler2D specularIntensityMap;\n#endif\n#endif\n\n#ifdef USE_CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_DISPERSION\nuniform float dispersion;\n#endif\n\n#ifdef USE_IRIDESCENCE\nuniform float iridescence;\nuniform float iridescenceIOR;\nuniform float iridescenceThicknessMinimum;\nuniform float iridescenceThicknessMaximum;\n#endif\n\n#ifdef USE_SHEEN\nuniform vec3 sheenColor;\nuniform float sheenRoughness;\n\n#ifdef USE_SHEEN_COLORMAP\nuniform sampler2D sheenColorMap;\n#endif\n\n#ifdef USE_SHEEN_ROUGHNESSMAP\nuniform sampler2D sheenRoughnessMap;\n#endif\n#endif\n\n#ifdef USE_ANISOTROPY\nuniform vec2 anisotropyVector;\n\n#ifdef USE_ANISOTROPYMAP\nuniform sampler2D anisotropyMap;\n#endif\n#endif\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\nvec4 diffuseColor = vec4( diffuse, opacity );\n#include <clipping_planes_fragment>\n\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\nvec3 totalEmissiveRadiance = emissive;\n\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <alphahash_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n\n// accumulation\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n\n// modulation\n#include <aomap_fragment>\n\nvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\nvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n#include <transmission_fragment>\n\nvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n#ifdef USE_SHEEN\n\n// Sheen energy compensation approximation calculation can be found at the end of\n// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\noutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\n#endif\n\n#ifdef USE_CLEARCOAT\n\nfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\nvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\noutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\n#endif\n\n#include <opaque_fragment>\n#include <tonemapping_fragment>\n#include <colorspace_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",Kt="\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n\nattribute vec3 offset;\nattribute vec4 rotation;\nattribute vec3 size;\n#include <tile_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n    #include <tile_vertex>\n    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;\n    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;\n    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;\n    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;\n    float sx = size.x, sy = size.y, sz = size.z;\n\n    mat4 particleMatrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column\n                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column\n                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column\n                      offset.x, offset.y, offset.z, 1.0);\n\n#include <color_vertex>\n#include <morphinstance_vertex>\n#include <morphcolor_vertex>\n#include <batching_vertex>\n\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n\n\t// replace defaultnormal_vertex\n\tvec3 transformedNormal = objectNormal;\n    mat3 m = mat3( particleMatrix );\n    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n    transformedNormal = m * transformedNormal;\n    transformedNormal = normalMatrix * transformedNormal;\n    #ifdef FLIP_SIDED\n        transformedNormal = - transformedNormal;\n    #endif\n    #ifdef USE_TANGENT\n        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n        #ifdef FLIP_SIDED\n        transformedTangent = - transformedTangent;\n        #endif\n    #endif\n\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\n\t// replace include <project_vertex>\n  vec4 mvPosition = vec4( transformed, 1.0 );\n  mvPosition = modelViewMatrix * (particleMatrix * mvPosition);\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t\n\tvViewPosition = - mvPosition.xyz;\n\t\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n    vWorldPosition = worldPosition.xyz;\n#endif\n}\n";function Qt(e){return 0===e?"uv":"uv".concat(e)}class $t extends o{constructor(e){super(e)}onBeforeCompile(e,t){super.onBeforeCompile(e,t),e.vertexShader=Kt,e.fragmentShader=Zt}}class en extends l{constructor(e){super(e)}onBeforeCompile(e,t){super.onBeforeCompile(e,t),e.vertexShader=Kt,e.fragmentShader=Zt}}new Y(0,0,1);class tn extends Gt{constructor(e){super(e),this.vector_=new Y,this.vector2_=new Y,this.vector3_=new Y,this.quaternion_=new te,this.quaternion2_=new te,this.quaternion3_=new te,this.rotationMat_=new q,this.rotationMat2_=new q,this.maxParticles=1e3,this.setupBuffers(),this.rebuildMaterial()}buildExpandableBuffers(){this.offsetBuffer=new d(new Float32Array(3*this.maxParticles),3),this.offsetBuffer.setUsage(f),this.geometry.setAttribute("offset",this.offsetBuffer),this.colorBuffer=new d(new Float32Array(4*this.maxParticles),4),this.colorBuffer.setUsage(f),this.geometry.setAttribute("color",this.colorBuffer),this.settings.renderMode===Vt.Mesh?(this.rotationBuffer=new d(new Float32Array(4*this.maxParticles),4),this.rotationBuffer.setUsage(f),this.geometry.setAttribute("rotation",this.rotationBuffer)):this.settings.renderMode!==Vt.BillBoard&&this.settings.renderMode!==Vt.HorizontalBillBoard&&this.settings.renderMode!==Vt.VerticalBillBoard&&this.settings.renderMode!==Vt.StretchedBillBoard||(this.rotationBuffer=new d(new Float32Array(this.maxParticles),1),this.rotationBuffer.setUsage(f),this.geometry.setAttribute("rotation",this.rotationBuffer)),this.sizeBuffer=new d(new Float32Array(3*this.maxParticles),3),this.sizeBuffer.setUsage(f),this.geometry.setAttribute("size",this.sizeBuffer),this.uvTileBuffer=new d(new Float32Array(this.maxParticles),1),this.uvTileBuffer.setUsage(f),this.geometry.setAttribute("uvTile",this.uvTileBuffer),this.settings.renderMode===Vt.StretchedBillBoard&&(this.velocityBuffer=new d(new Float32Array(4*this.maxParticles),4),this.velocityBuffer.setUsage(f),this.geometry.setAttribute("velocity",this.velocityBuffer))}setupBuffers(){this.geometry&&this.geometry.dispose(),this.geometry=new m,this.geometry.setIndex(this.settings.instancingGeometry.getIndex()),this.settings.instancingGeometry.hasAttribute("normal")&&this.geometry.setAttribute("normal",this.settings.instancingGeometry.getAttribute("normal")),this.geometry.setAttribute("position",this.settings.instancingGeometry.getAttribute("position")),this.geometry.setAttribute("uv",this.settings.instancingGeometry.getAttribute("uv")),this.buildExpandableBuffers()}expandBuffers(e){for(;e>=this.maxParticles;)this.maxParticles*=2;this.setupBuffers()}rebuildMaterial(){this.layers.mask=this.settings.layers.mask;const e={},t={};"MeshStandardMaterial"!==this.settings.material.type&&"MeshPhysicalMaterial"!==this.settings.material.type&&(e.map=new c(this.settings.material.map)),this.settings.material.alphaTest&&(t.USE_ALPHATEST="",e.alphaTest=new c(this.settings.material.alphaTest)),t.USE_UV="";const n=this.settings.uTileCount,i=this.settings.vTileCount;let r;if((n>1||i>1)&&(t.UV_TILE="",e.tileCount=new c(new de(n,i))),this.settings.material.defines&&void 0!==this.settings.material.defines.USE_COLOR_AS_ALPHA&&(t.USE_COLOR_AS_ALPHA=""),this.settings.material.normalMap&&(t.USE_NORMALMAP="",t.NORMALMAP_UV=Qt(this.settings.material.normalMap.channel),e.normalMapTransform=new c((new q).copy(this.settings.material.normalMap.matrix))),this.settings.material.map&&(t.USE_MAP="",this.settings.blendTiles&&(t.TILE_BLEND=""),t.MAP_UV=Qt(this.settings.material.map.channel),e.mapTransform=new c((new q).copy(this.settings.material.map.matrix))),t.USE_COLOR_ALPHA="",this.settings.softParticles){t.SOFT_PARTICLES="";const n=this.settings.softNearFade,i=1/(this.settings.softFarFade-this.settings.softNearFade);e.softParams=new c(new de(n,i)),e.depthTexture=new c(null);const s=e.projParams=new c(new K);r=(e,t,n)=>{s.value.set(n.near,n.far,0,0)}}let s=!1;if(this.settings.renderMode===Vt.BillBoard||this.settings.renderMode===Vt.VerticalBillBoard||this.settings.renderMode===Vt.HorizontalBillBoard||this.settings.renderMode===Vt.Mesh){let n,i;this.settings.renderMode===Vt.Mesh?"MeshStandardMaterial"===this.settings.material.type||"MeshPhysicalMaterial"===this.settings.material.type?(t.USE_COLOR="",n=Kt,i=Zt,s=!0):(n="\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute vec4 rotation;\nattribute vec3 size;\n// attribute vec4 color;\n\nvoid main() {\n\n    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;\n    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;\n    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;\n    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;\n    float sx = size.x, sy = size.y, sz = size.z;\n    \n    mat4 matrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column\n                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column\n                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column\n                      offset.x, offset.y, offset.z, 1.0);\n    \n    vec4 mvPosition = modelViewMatrix * (matrix * vec4( position, 1.0 ));\n\n\tvColor = color;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n    #include <tile_vertex>\n    #include <soft_vertex>\n}\n",i=qt):(n="\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute float rotation;\nattribute vec3 size;\n\nvoid main() {\n\t\n    vec2 alignedPosition = position.xy * size.xy;\n    \n    vec2 rotatedPosition;\n    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n#ifdef HORIZONTAL\n    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );\n    mvPosition.x += rotatedPosition.x;\n    mvPosition.z -= rotatedPosition.y;\n    mvPosition = viewMatrix * mvPosition;\n#elif defined(VERTICAL)\n    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );\n    mvPosition.y += rotatedPosition.y;\n    mvPosition = viewMatrix * mvPosition;\n    mvPosition.x += rotatedPosition.x;\n#else\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    mvPosition.xy += rotatedPosition;\n#endif\n\n\tvColor = color;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\n\t#include <clipping_planes_vertex>\n\n\t#include <tile_vertex>\n\t#include <soft_vertex>\n}\n",i=qt),this.settings.renderMode===Vt.VerticalBillBoard?t.VERTICAL="":this.settings.renderMode===Vt.HorizontalBillBoard&&(t.HORIZONTAL="");let r=!1;this.settings.renderMode===Vt.Mesh&&("MeshStandardMaterial"===this.settings.material.type?(this.material=new $t({}),this.material.copy(this.settings.material),this.material.uniforms=e,this.material.defines=t,r=!0):"MeshPhysicalMaterial"===this.settings.material.type&&(this.material=new en({}),this.material.copy(this.settings.material),this.material.uniforms=e,this.material.defines=t,r=!0)),r||(this.material=new h({uniforms:e,defines:t,vertexShader:n,fragmentShader:i,transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,blending:this.settings.material.blending,side:this.settings.material.side,alphaTest:this.settings.material.alphaTest,depthTest:this.settings.material.depthTest,lights:s}))}else{if(this.settings.renderMode!==Vt.StretchedBillBoard)throw new Error("render mode unavailable");e.speedFactor=new c(1),this.material=new h({uniforms:e,defines:t,vertexShader:"\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute float rotation;\nattribute vec3 size;\nattribute vec4 velocity;\n\nuniform float speedFactor;\n\nvoid main() {\n    float lengthFactor = velocity.w;\n    float avgSize = (size.x + size.y) * 0.5;\n#ifdef USE_SKEW\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    vec3 viewVelocity = normalMatrix * velocity.xyz;\n\n    vec3 scaledPos = vec3(position.xy * size.xy, position.z);\n    float vlength = length(viewVelocity);\n    vec3 projVelocity =  dot(scaledPos, viewVelocity) * viewVelocity / vlength;\n    mvPosition.xyz += scaledPos + projVelocity * (speedFactor / avgSize + lengthFactor / vlength);\n#else\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    vec3 viewVelocity = normalMatrix * velocity.xyz;\n    float vlength = length(viewVelocity); \n    mvPosition.xyz += position.y * normalize(cross(mvPosition.xyz, viewVelocity)) * avgSize; // switch the cross to  match unity implementation\n    mvPosition.xyz -= (position.x + 0.5) * viewVelocity * (1.0 + lengthFactor / vlength) * avgSize; // minus position.x to match unity implementation\n#endif\n\tvColor = color;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <tile_vertex>\n\t#include <soft_vertex>\n}\n",fragmentShader:qt,transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,blending:this.settings.material.blending,side:this.settings.material.side,alphaTest:this.settings.material.alphaTest,depthTest:this.settings.material.depthTest})}this.material&&r&&(this.material.onBeforeRender=r)}update(){let e=0,t=0;this.systems.forEach((e=>{t+=e.particleNum})),t>this.maxParticles&&this.expandBuffers(t),this.systems.forEach((t=>{const n=t.particles,i=t.particleNum,r=this.quaternion2_,s=this.vector2_,a=this.vector3_;t.emitter.matrixWorld.decompose(s,r,a),this.rotationMat_.setFromMatrix4(t.emitter.matrixWorld);for(let o=0;o<i;o++,e++){const i=n[o];if(this.settings.renderMode===Vt.Mesh){let n;if(t.worldSpace)n=i.rotation;else{let e;e=i.parentMatrix?this.quaternion3_.setFromRotationMatrix(i.parentMatrix):r,n=this.quaternion_,n.copy(e).multiply(i.rotation)}this.rotationBuffer.setXYZW(e,n.x,n.y,n.z,n.w)}else this.settings.renderMode!==Vt.StretchedBillBoard&&this.settings.renderMode!==Vt.VerticalBillBoard&&this.settings.renderMode!==Vt.HorizontalBillBoard&&this.settings.renderMode!==Vt.BillBoard||this.rotationBuffer.setX(e,i.rotation);let s;if(t.worldSpace?s=i.position:(s=this.vector_,i.parentMatrix?s.copy(i.position).applyMatrix4(i.parentMatrix):s.copy(i.position).applyMatrix4(t.emitter.matrixWorld)),this.offsetBuffer.setXYZ(e,s.x,s.y,s.z),this.colorBuffer.setXYZW(e,i.color.x,i.color.y,i.color.z,i.color.w),t.worldSpace||i.parentMatrix?this.sizeBuffer.setXYZ(e,i.size.x,i.size.y,i.size.z):this.sizeBuffer.setXYZ(e,i.size.x*Math.abs(a.x),i.size.y*Math.abs(a.y),i.size.z*Math.abs(a.z)),this.uvTileBuffer.setX(e,i.uvTile),this.settings.renderMode===Vt.StretchedBillBoard&&this.velocityBuffer){let n=t.rendererEmitterSettings.speedFactor;0===n&&(n=.001);const r=t.rendererEmitterSettings.lengthFactor;let s;t.worldSpace?s=i.velocity:(s=this.vector_,i.parentMatrix?(this.rotationMat2_.setFromMatrix4(i.parentMatrix),s.copy(i.velocity).applyMatrix3(this.rotationMat2_)):s.copy(i.velocity).applyMatrix3(this.rotationMat_)),this.velocityBuffer.setXYZW(e,s.x*n,s.y*n,s.z*n,r)}}})),this.geometry.instanceCount=e,e>0&&(this.offsetBuffer.clearUpdateRanges(),this.offsetBuffer.addUpdateRange(0,3*e),this.offsetBuffer.needsUpdate=!0,this.sizeBuffer.clearUpdateRanges(),this.sizeBuffer.addUpdateRange(0,3*e),this.sizeBuffer.needsUpdate=!0,this.colorBuffer.clearUpdateRanges(),this.colorBuffer.addUpdateRange(0,4*e),this.colorBuffer.needsUpdate=!0,this.uvTileBuffer.clearUpdateRanges(),this.uvTileBuffer.addUpdateRange(0,e),this.uvTileBuffer.needsUpdate=!0,this.settings.renderMode===Vt.StretchedBillBoard&&this.velocityBuffer&&(this.velocityBuffer.clearUpdateRanges(),this.velocityBuffer.addUpdateRange(0,4*e),this.velocityBuffer.needsUpdate=!0),this.settings.renderMode===Vt.Mesh?(this.rotationBuffer.clearUpdateRanges(),this.rotationBuffer.addUpdateRange(0,4*e),this.rotationBuffer.needsUpdate=!0):this.settings.renderMode!==Vt.StretchedBillBoard&&this.settings.renderMode!==Vt.HorizontalBillBoard&&this.settings.renderMode!==Vt.VerticalBillBoard&&this.settings.renderMode!==Vt.BillBoard||(this.rotationBuffer.clearUpdateRanges(),this.rotationBuffer.addUpdateRange(0,e),this.rotationBuffer.needsUpdate=!0))}dispose(){this.geometry.dispose()}}new Y(0,0,1);class nn extends Gt{constructor(e){super(e),this.vector_=new Y,this.vector2_=new Y,this.vector3_=new Y,this.quaternion_=new te,this.maxParticles=1e4,this.setupBuffers(),this.rebuildMaterial()}setupBuffers(){this.geometry&&this.geometry.dispose(),this.geometry=new u,this.indexBuffer=new p(new Uint32Array(6*this.maxParticles),1),this.indexBuffer.setUsage(f),this.geometry.setIndex(this.indexBuffer),this.positionBuffer=new p(new Float32Array(6*this.maxParticles),3),this.positionBuffer.setUsage(f),this.geometry.setAttribute("position",this.positionBuffer),this.previousBuffer=new p(new Float32Array(6*this.maxParticles),3),this.previousBuffer.setUsage(f),this.geometry.setAttribute("previous",this.previousBuffer),this.nextBuffer=new p(new Float32Array(6*this.maxParticles),3),this.nextBuffer.setUsage(f),this.geometry.setAttribute("next",this.nextBuffer),this.widthBuffer=new p(new Float32Array(2*this.maxParticles),1),this.widthBuffer.setUsage(f),this.geometry.setAttribute("width",this.widthBuffer),this.sideBuffer=new p(new Float32Array(2*this.maxParticles),1),this.sideBuffer.setUsage(f),this.geometry.setAttribute("side",this.sideBuffer),this.uvBuffer=new p(new Float32Array(4*this.maxParticles),2),this.uvBuffer.setUsage(f),this.geometry.setAttribute("uv",this.uvBuffer),this.colorBuffer=new p(new Float32Array(8*this.maxParticles),4),this.colorBuffer.setUsage(f),this.geometry.setAttribute("color",this.colorBuffer)}expandBuffers(e){for(;e>=this.maxParticles;)this.maxParticles*=2;this.setupBuffers()}rebuildMaterial(){this.layers.mask=this.settings.layers.mask;const e={lineWidth:{value:1},map:{value:null},useMap:{value:0},alphaMap:{value:null},useAlphaMap:{value:0},resolution:{value:new de(1,1)},sizeAttenuation:{value:1},visibility:{value:1},alphaTest:{value:0}},t={USE_UV:"",USE_COLOR_ALPHA:""};if(this.settings.material.map&&(t.USE_MAP="",t.MAP_UV=Qt(this.settings.material.map.channel),e.map=new c(this.settings.material.map),e.mapTransform=new c((new q).copy(this.settings.material.map.matrix))),this.settings.material.defines&&void 0!==this.settings.material.defines.USE_COLOR_AS_ALPHA&&(t.USE_COLOR_AS_ALPHA=""),this.settings.renderMode!==Vt.Trail)throw new Error("render mode unavailable");this.material=new h({uniforms:e,defines:t,vertexShader:"\n#include <common>\n#include <tile_pars_vertex>\n#include <color_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <fog_pars_vertex>\n\nattribute vec3 previous;\nattribute vec3 next;\nattribute float side;\nattribute float width;\n\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform float sizeAttenuation;\n    \nvec2 fix(vec4 i, float aspect) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n    return res;\n}\n    \nvoid main() {\n\n    #include <tile_vertex>\n    \n    float aspect = resolution.x / resolution.y;\n\n    vColor = color;\n\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec4 finalPosition = m * vec4( position, 1.0 );\n    vec4 prevPos = m * vec4( previous, 1.0 );\n    vec4 nextPos = m * vec4( next, 1.0 );\n\n    vec2 currentP = fix( finalPosition, aspect );\n    vec2 prevP = fix( prevPos, aspect );\n    vec2 nextP = fix( nextPos, aspect );\n\n    float w = lineWidth * width;\n\n    vec2 dir;\n    if( nextP == currentP ) dir = normalize( currentP - prevP );\n    else if( prevP == currentP ) dir = normalize( nextP - currentP );\n    else {\n        vec2 dir1 = normalize( currentP - prevP );\n        vec2 dir2 = normalize( nextP - currentP );\n        dir = normalize( dir1 + dir2 );\n\n        vec2 perp = vec2( -dir1.y, dir1.x );\n        vec2 miter = vec2( -dir.y, dir.x );\n        //w = clamp( w / dot( miter, perp ), 0., 4., * lineWidth * width );\n\n    }\n\n    //vec2 normal = ( cross( vec3( dir, 0. ) vec3( 0., 0., 1. ) ) ).xy;\n    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );\n    normal.xy *= .5 * w;\n    normal *= projectionMatrix;\n    if( sizeAttenuation == 0. ) {\n        normal.xy *= finalPosition.w;\n        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;\n    }\n\n    finalPosition.xy += normal.xy * side;\n\n    gl_Position = finalPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    \n\t#include <fog_vertex>\n}",fragmentShader:"\n\n#include <common>\n#include <tile_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nuniform sampler2D alphaMap;\nuniform float useAlphaMap;\nuniform float visibility;\nuniform float alphaTest;\n\nvarying vec4 vColor;\n    \nvoid main() {\n    #include <clipping_planes_fragment>\n    #include <logdepthbuf_fragment>\n\n    vec4 diffuseColor = vColor;\n    \n    #ifdef USE_MAP\n    #include <tile_fragment>\n    #ifndef USE_COLOR_AS_ALPHA\n    #endif\n    #endif\n    if( useAlphaMap == 1. ) diffuseColor.a *= texture2D( alphaMap, vUv).a;\n    if( diffuseColor.a < alphaTest ) discard;\n    gl_FragColor = diffuseColor;\n\n    #include <fog_fragment>\n    #include <tonemapping_fragment>\n}",transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,side:this.settings.material.side,blending:this.settings.material.blending||a})}update(){let e=0,t=0,n=0;this.systems.forEach((e=>{for(let t=0;t<e.particleNum;t++)n+=2*e.particles[t].previous.length})),n>this.maxParticles&&this.expandBuffers(n),this.systems.forEach((n=>{const i=this.quaternion_,r=this.vector2_,s=this.vector3_;n.emitter.matrixWorld.decompose(r,i,s);const a=n.particles,o=n.particleNum,l=this.settings.uTileCount,d=this.settings.vTileCount,f=1/l,m=1/d;for(let c=0;c<o;c++){const i=a[c],r=i.uvTile%d,o=Math.floor(i.uvTile/d+.001),l=i.previous.values();let h,u=l.next(),p=u.value,v=p;u.done||(u=l.next()),h=void 0!==u.value?u.value:v;for(let a=0;a<i.previous.length;a++,e+=2){if(this.positionBuffer.setXYZ(e,v.position.x,v.position.y,v.position.z),this.positionBuffer.setXYZ(e+1,v.position.x,v.position.y,v.position.z),n.worldSpace?(this.positionBuffer.setXYZ(e,v.position.x,v.position.y,v.position.z),this.positionBuffer.setXYZ(e+1,v.position.x,v.position.y,v.position.z)):(i.parentMatrix?this.vector_.copy(v.position).applyMatrix4(i.parentMatrix):this.vector_.copy(v.position).applyMatrix4(n.emitter.matrixWorld),this.positionBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.positionBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),n.worldSpace?(this.previousBuffer.setXYZ(e,p.position.x,p.position.y,p.position.z),this.previousBuffer.setXYZ(e+1,p.position.x,p.position.y,p.position.z)):(i.parentMatrix?this.vector_.copy(p.position).applyMatrix4(i.parentMatrix):this.vector_.copy(p.position).applyMatrix4(n.emitter.matrixWorld),this.previousBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.previousBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),n.worldSpace?(this.nextBuffer.setXYZ(e,h.position.x,h.position.y,h.position.z),this.nextBuffer.setXYZ(e+1,h.position.x,h.position.y,h.position.z)):(i.parentMatrix?this.vector_.copy(h.position).applyMatrix4(i.parentMatrix):this.vector_.copy(h.position).applyMatrix4(n.emitter.matrixWorld),this.nextBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.nextBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),this.sideBuffer.setX(e,-1),this.sideBuffer.setX(e+1,1),n.worldSpace)this.widthBuffer.setX(e,v.size),this.widthBuffer.setX(e+1,v.size);else if(i.parentMatrix)this.widthBuffer.setX(e,v.size),this.widthBuffer.setX(e+1,v.size);else{const t=(Math.abs(s.x)+Math.abs(s.y)+Math.abs(s.z))/3;this.widthBuffer.setX(e,v.size*t),this.widthBuffer.setX(e+1,v.size*t)}this.uvBuffer.setXY(e,(a/i.previous.length+r)*f,(d-o-1)*m),this.uvBuffer.setXY(e+1,(a/i.previous.length+r)*f,(d-o)*m),this.colorBuffer.setXYZW(e,v.color.x,v.color.y,v.color.z,v.color.w),this.colorBuffer.setXYZW(e+1,v.color.x,v.color.y,v.color.z,v.color.w),a+1<i.previous.length&&(this.indexBuffer.setX(3*t,e),this.indexBuffer.setX(3*t+1,e+1),this.indexBuffer.setX(3*t+2,e+2),t++,this.indexBuffer.setX(3*t,e+2),this.indexBuffer.setX(3*t+1,e+1),this.indexBuffer.setX(3*t+2,e+3),t++),p=v,v=h,u.done||(u=l.next(),void 0!==u.value&&(h=u.value))}}})),this.positionBuffer.clearUpdateRanges(),this.positionBuffer.addUpdateRange(0,3*e),this.positionBuffer.needsUpdate=!0,this.previousBuffer.clearUpdateRanges(),this.previousBuffer.addUpdateRange(0,3*e),this.previousBuffer.needsUpdate=!0,this.nextBuffer.clearUpdateRanges(),this.nextBuffer.addUpdateRange(0,3*e),this.nextBuffer.needsUpdate=!0,this.sideBuffer.clearUpdateRanges(),this.sideBuffer.addUpdateRange(0,e),this.sideBuffer.needsUpdate=!0,this.widthBuffer.clearUpdateRanges(),this.widthBuffer.addUpdateRange(0,e),this.widthBuffer.needsUpdate=!0,this.uvBuffer.clearUpdateRanges(),this.uvBuffer.addUpdateRange(0,2*e),this.uvBuffer.needsUpdate=!0,this.colorBuffer.clearUpdateRanges(),this.colorBuffer.addUpdateRange(0,4*e),this.colorBuffer.needsUpdate=!0,this.indexBuffer.clearUpdateRanges(),this.indexBuffer.addUpdateRange(0,3*t),this.indexBuffer.needsUpdate=!0,this.geometry.setDrawRange(0,3*t)}dispose(){this.geometry.dispose()}}class rn{get geometry(){return this._geometry}set geometry(e){if(this._geometry=e,void 0===e)return;if("string"==typeof e)return;const t=new v;this._triangleIndexToArea.length=0;let n=0;if(!e.getIndex())return;const i=e.getIndex().array,r=i.length/3;this._triangleIndexToArea.push(0);for(let s=0;s<r;s++)t.setFromAttributeAndIndices(e.getAttribute("position"),i[3*s],i[3*s+1],i[3*s+2]),n+=t.getArea(),this._triangleIndexToArea.push(n);e.userData.triangleIndexToArea=this._triangleIndexToArea}constructor(e){this.type="mesh_surface",this._triangleIndexToArea=[],this._tempA=new g,this._tempB=new g,this._tempC=new g,e&&(this.geometry=e)}initialize(e){const t=this._geometry;if(!t||null===t.getIndex())return e.position.set(0,0,0),void e.velocity.set(0,0,1).multiplyScalar(e.startSpeed);const n=this._triangleIndexToArea.length-1;let i=0,r=n;const s=Math.random()*this._triangleIndexToArea[n];for(;i+1<r;){const e=Math.floor((i+r)/2);s<this._triangleIndexToArea[e]?r=e:i=e}let a=Math.random(),o=Math.random();a+o>1&&(a=1-a,o=1-o);const l=t.getIndex().array[3*i],d=t.getIndex().array[3*i+1],f=t.getIndex().array[3*i+2],m=t.getAttribute("position");this._tempA.fromBufferAttribute(m,l),this._tempB.fromBufferAttribute(m,d),this._tempC.fromBufferAttribute(m,f),this._tempB.sub(this._tempA),this._tempC.sub(this._tempA),this._tempA.addScaledVector(this._tempB,a).addScaledVector(this._tempC,o),e.position.copy(this._tempA),this._tempA.copy(this._tempB).cross(this._tempC).normalize(),e.velocity.copy(this._tempA).normalize().multiplyScalar(e.startSpeed)}toJSON(){return{type:"mesh_surface",mesh:this._geometry?this._geometry.uuid:""}}static fromJSON(e,t){return new rn(t.geometries[e.geometry])}clone(){return new rn(this._geometry)}update(e,t){}}oe({id:"three.quarks",initialize:()=>{},emitterShapes:[{type:"mesh_surface",params:[["geometry",["geometry"]]],constructor:rn,loadJSON:rn.fromJSON}],behaviors:[]});class sn extends e{constructor(){super(),this.batches=[],this.systemToBatchIndex=new Map,this.type="BatchedRenderer",this.depthTexture=null}static equals(e,t){return e.material.side===t.material.side&&e.material.blending===t.material.blending&&e.material.transparent===t.material.transparent&&e.material.depthTest===t.material.depthTest&&e.material.type===t.material.type&&e.material.alphaTest===t.material.alphaTest&&e.material.map===t.material.map&&e.renderMode===t.renderMode&&e.blendTiles===t.blendTiles&&e.softParticles===t.softParticles&&e.softFarFade===t.softFarFade&&e.softNearFade===t.softNearFade&&e.uTileCount===t.uTileCount&&e.vTileCount===t.vTileCount&&e.instancingGeometry===t.instancingGeometry&&e.renderOrder===t.renderOrder&&e.layers.mask===t.layers.mask}addSystem(e){e._renderer=this;const t=e.getRendererSettings();for(let i=0;i<this.batches.length;i++)if(sn.equals(this.batches[i].settings,t))return this.batches[i].addSystem(e),void this.systemToBatchIndex.set(e,i);let n;switch(t.renderMode){case Vt.Trail:n=new nn(t);break;case Vt.Mesh:case Vt.BillBoard:case Vt.VerticalBillBoard:case Vt.HorizontalBillBoard:case Vt.StretchedBillBoard:n=new tn(t)}this.depthTexture&&n.applyDepthTexture(this.depthTexture),n.addSystem(e),this.batches.push(n),this.systemToBatchIndex.set(e,this.batches.length-1),this.add(n)}deleteSystem(e){const t=this.systemToBatchIndex.get(e);null!=t&&(this.batches[t].removeSystem(e),this.systemToBatchIndex.delete(e))}setDepthTexture(e){this.depthTexture=e;for(const t of this.batches)t.applyDepthTexture(e)}updateSystem(e){this.deleteSystem(e),this.addSystem(e)}update(e){this.systemToBatchIndex.forEach(((t,n)=>{n.update(e)}));for(let t=0;t<this.batches.length;t++)this.batches[t].update()}}const an=sn;Ft(),console.log("%c Particle system powered by three.quarks. https://quarks.art/","font-size: 14px; font-weight: bold;");const on=Object.freeze(Object.defineProperty({__proto__:null,ApplyCollision:fe,ApplyForce:me,ApplySequences:ce,AxisAngleGenerator:W,BatchedParticleRenderer:an,BatchedRenderer:sn,BehaviorFromJSON:ae,BehaviorTypes:he,Bezier:ue,ChangeEmitDirection:pe,CircleEmitter:ve,ColorBySpeed:ge,ColorGeneratorFromJSON:se,ColorOverLife:ye,ColorRange:_e,ConeEmitter:Se,ConstantColor:Z,ConstantValue:J,DEG2RAD:xe,DonutEmitter:Me,EmitSubParticleSystem:le,EmitterFromJSON:ne,get EmitterMode(){return Te},EmitterShapes:Ee,Euler:Ue,EulerGenerator:Pe,ForceOverLife:Ae,FrameOverLife:we,GeneratorFromJSON:re,Gradient:Be,GravityForce:be,GridEmitter:Ce,HemisphereEmitter:Oe,IntervalValue:Re,LimitSpeedOverLife:Ne,MathUtils:ze,Matrix3:q,Matrix4:Le,MeshSurfaceEmitter:rn,NodeParticle:Ie,Noise:Fe,OrbitOverLife:De,ParticleEmitter:Dt,ParticleMeshPhysicsMaterial:en,ParticleMeshStandardMaterial:$t,ParticleSystem:Wt,PiecewiseBezier:Ve,PiecewiseFunction:ke,Plugins:Ge,PointEmitter:He,QuarksLoader:class extends y{constructor(e){super(e)}linkReference(e){const t={};e.traverse((function(e){t[e.uuid]=e})),e.traverse((function(e){if("ParticleEmitter"===e.type){const n=e.system;n.emitterShape;for(let e=0;e<n.behaviors.length;e++)n.behaviors[e]instanceof le&&(n.behaviors[e].subParticleSystem=t[n.behaviors[e].subParticleSystem])}}))}parse(e,t){const n=super.parse(e,t);return this.linkReference(n),n}parseObject(n,i,r,s,a){let o,l,f;function m(e){return void 0===i[e]&&console.warn("THREE.ObjectLoader: Undefined geometry",e),i[e]}function c(e){if(void 0!==e){if(Array.isArray(e)){const t=[];for(let n=0,i=e.length;n<i;n++){const i=e[n];void 0===r[i]&&console.warn("THREE.ObjectLoader: Undefined material",i),t.push(r[i])}return t}return void 0===r[e]&&console.warn("THREE.ObjectLoader: Undefined material",e),r[e]}}function h(e){return void 0===s[e]&&console.warn("THREE.ObjectLoader: Undefined texture",e),s[e]}const u={textures:s,geometries:i,materials:r},p={};switch(n.type){case"ParticleEmitter":o=Wt.fromJSON(n.ps,u,p).emitter;break;case"Scene":o=new k,void 0!==n.background&&(Number.isInteger(n.background)?o.background=new G(n.background):o.background=h(n.background)),void 0!==n.environment&&(o.environment=h(n.environment)),void 0!==n.fog&&("Fog"===n.fog.type?o.fog=new H(n.fog.color,n.fog.near,n.fog.far):"FogExp2"===n.fog.type&&(o.fog=new j(n.fog.color,n.fog.density)),""!==n.fog.name&&(o.fog.name=n.fog.name)),void 0!==n.backgroundBlurriness&&(o.backgroundBlurriness=n.backgroundBlurriness),void 0!==n.backgroundIntensity&&(o.backgroundIntensity=n.backgroundIntensity),void 0!==n.backgroundRotation&&o.backgroundRotation.fromArray(n.backgroundRotation),void 0!==n.environmentIntensity&&(o.environmentIntensity=n.environmentIntensity),void 0!==n.environmentRotation&&o.environmentRotation.fromArray(n.environmentRotation);break;case"PerspectiveCamera":o=new V(n.fov,n.aspect,n.near,n.far),void 0!==n.focus&&(o.focus=n.focus),void 0!==n.zoom&&(o.zoom=n.zoom),void 0!==n.filmGauge&&(o.filmGauge=n.filmGauge),void 0!==n.filmOffset&&(o.filmOffset=n.filmOffset),void 0!==n.view&&(o.view=Object.assign({},n.view));break;case"OrthographicCamera":o=new D(n.left,n.right,n.top,n.bottom,n.near,n.far),void 0!==n.zoom&&(o.zoom=n.zoom),void 0!==n.view&&(o.view=Object.assign({},n.view));break;case"AmbientLight":o=new F(n.color,n.intensity);break;case"DirectionalLight":o=new I(n.color,n.intensity);break;case"PointLight":o=new L(n.color,n.intensity,n.distance,n.decay);break;case"RectAreaLight":o=new z(n.color,n.intensity,n.width,n.height);break;case"SpotLight":o=new N(n.color,n.intensity,n.distance,n.angle,n.penumbra,n.decay);break;case"HemisphereLight":o=new R(n.color,n.groundColor,n.intensity);break;case"LightProbe":o=(new O).fromJSON(n);break;case"SkinnedMesh":l=m(n.geometry),f=c(n.material),o=new C(l,f),void 0!==n.bindMode&&(o.bindMode=n.bindMode),void 0!==n.bindMatrix&&o.bindMatrix.fromArray(n.bindMatrix),void 0!==n.skeleton&&(o.skeleton=n.skeleton);break;case"Mesh":l=m(n.geometry),f=c(n.material),o=new t(l,f);break;case"InstancedMesh":{l=m(n.geometry),f=c(n.material);const e=n.count,t=n.instanceMatrix,i=n.instanceColor;o=new b(l,f,e),o.instanceMatrix=new d(new Float32Array(t.array),16),void 0!==i&&(o.instanceColor=new d(new Float32Array(i.array),i.itemSize));break}case"BatchedMesh":l=m(n.geometry),f=c(n.material),o=new A(n.maxGeometryCount,n.maxVertexCount,n.maxIndexCount,f),o.geometry=l,o.perObjectFrustumCulled=n.perObjectFrustumCulled,o.sortObjects=n.sortObjects,o._drawRanges=n.drawRanges,o._reservedRanges=n.reservedRanges,o._visibility=n.visibility,o._active=n.active,o._bounds=n.bounds.map((e=>{const t=new w;t.min.fromArray(e.boxMin),t.max.fromArray(e.boxMax);const n=new B;return n.radius=e.sphereRadius,n.center.fromArray(e.sphereCenter),{boxInitialized:e.boxInitialized,box:t,sphereInitialized:e.sphereInitialized,sphere:n}})),o._maxGeometryCount=n.maxGeometryCount,o._maxVertexCount=n.maxVertexCount,o._maxIndexCount=n.maxIndexCount,o._geometryInitialized=n.geometryInitialized,o._geometryCount=n.geometryCount,o._matricesTexture=h(n.matricesTexture.uuid);break;case"LOD":o=new P;break;case"Line":o=new U(m(n.geometry),c(n.material));break;case"LineLoop":o=new E(m(n.geometry),c(n.material));break;case"LineSegments":o=new T(m(n.geometry),c(n.material));break;case"PointCloud":case"Points":o=new M(m(n.geometry),c(n.material));break;case"Sprite":o=new x(c(n.material));break;case"Group":o=new S;break;case"Bone":o=new _;break;default:o=new e}if(o.uuid=n.uuid,void 0!==n.name&&(o.name=n.name),void 0!==n.matrix?(o.matrix.fromArray(n.matrix),void 0!==n.matrixAutoUpdate&&(o.matrixAutoUpdate=n.matrixAutoUpdate),o.matrixAutoUpdate&&(o.matrix.decompose(o.position,o.quaternion,o.scale),isNaN(o.quaternion.x)&&o.quaternion.set(0,0,0,1))):(void 0!==n.position&&o.position.fromArray(n.position),void 0!==n.rotation&&o.rotation.fromArray(n.rotation),void 0!==n.quaternion&&o.quaternion.fromArray(n.quaternion),void 0!==n.scale&&o.scale.fromArray(n.scale)),void 0!==n.up&&o.up.fromArray(n.up),void 0!==n.castShadow&&(o.castShadow=n.castShadow),void 0!==n.receiveShadow&&(o.receiveShadow=n.receiveShadow),n.shadow&&(void 0!==n.shadow.bias&&(o.shadow.bias=n.shadow.bias),void 0!==n.shadow.normalBias&&(o.normalBias=n.shadow.normalBias),void 0!==n.shadow.radius&&(o.radius=n.shadow.radius),void 0!==n.shadow.mapSize&&o.mapSize.fromArray(n.shadow.mapSize),void 0!==n.shadow.camera&&(o.camera=this.parseObject(n.shadow.camera))),void 0!==n.visible&&(o.visible=n.visible),void 0!==n.frustumCulled&&(o.frustumCulled=n.frustumCulled),void 0!==n.renderOrder&&(o.renderOrder=n.renderOrder),void 0!==n.userData&&(o.userData=n.userData),void 0!==n.layers&&(o.layers.mask=n.layers),void 0!==n.children){const e=n.children;for(let t=0;t<e.length;t++)o.add(this.parseObject(e[t],i,r,s,a))}if(void 0!==n.animations){const e=n.animations;for(let t=0;t<e.length;t++){const n=e[t];o.animations.push(a[n])}}if("LOD"===n.type){void 0!==n.autoUpdate&&(o.autoUpdate=n.autoUpdate);const e=n.levels;for(let t=0;t<e.length;t++){const n=e[t],i=o.getObjectByProperty("uuid",n.object);void 0!==i&&o.addLevel(i,n.distance)}}return o}},Quaternion:te,RAD2DEG:je,RandomColor:Xe,RandomColorBetweenGradient:Ye,RandomQuatGenerator:Je,RecordState:We,get RenderMode(){return Vt},Rotation3DOverLife:qe,RotationBySpeed:Ze,RotationGeneratorFromJSON:Ke,RotationOverLife:Qe,SequencerFromJSON:$e,SizeBySpeed:et,SizeOverLife:tt,SpeedOverLife:nt,SphereEmitter:Q,SpriteBatch:tn,SpriteParticle:ee,get SubParticleEmitMode(){return it},TextureSequencer:rt,TrailBatch:nn,TrailParticle:$,TurbulenceField:st,VFXBatch:Gt,ValueGeneratorFromJSON:ie,Vector2:de,Vector3:Y,Vector3Function:at,Vector3GeneratorFromJSON:ot,Vector4:K,WebGLCoordinateSystem:lt,WebGPUCoordinateSystem:dt,WidthOverLength:ft,ceilPowerOfTwo:mt,clamp:ct,damp:ht,degToRad:ut,denormalize:pt,euclideanModulo:vt,floorPowerOfTwo:gt,generateUUID:yt,getPhysicsResolver:_t,getValueFromEmitterMode:St,inverseLerp:xt,isPowerOfTwo:Mt,lerp:Tt,loadPlugin:oe,mapLinear:Et,normalize:Ut,pingpong:Pt,radToDeg:At,randFloat:wt,randFloatSpread:Bt,randInt:bt,registerShaderChunks:Ft,seededRandom:Ct,setPhysicsResolver:Ot,setQuaternionFromProperEuler:Rt,smootherstep:Nt,smoothstep:zt,unloadPlugin:Lt},Symbol.toStringTag,{value:"Module"}));export{Wt as P,Vt as R,on as _};
