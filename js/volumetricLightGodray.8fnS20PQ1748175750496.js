import{m as e,e as t,F as r,a,H as n}from"./@tresjs.B58fmDCJ1748175750496.js";import"./index.5Jaf08no1748175750496.js";import{n as i,a as l,bs as o,br as s,a5 as u,u as h,N as v,r as m,_ as d,au as f,B as p,c,l as x,aI as g,M as _,q as T,t as D,V as M,h as B,X as S,ck as w,cl as U,ay as y,az as b,as as P,A as R,aM as C}from"./three.CMW1jU-t1748175750496.js";import{d as F,_ as E,v as j,a as k,a2 as A,a3 as z,A as W,G as I,o as O,m as L,u as N,b as G,w as H,I as $,L as V,a5 as q,j as X,f as J,F as K,a6 as Q,r as Y,t as Z,e as ee,H as te,ak as re,al as ae,am as ne}from"./@vue.C_fjx3FT1748175750496.js";import{E as ie,R as le,B as oe,G as se,a as ue}from"./postprocessing.B9ARLmQH1748175750496.js";import"./@vueuse.BIIpTDNs1748175750496.js";import"./object-hash.B8Cv8r3-1748175750496.js";import"./@amap.CGUF9xH41748175750496.js";import"./jszip.CxOzuUTx1748175750496.js";const he=parseInt(u.replace(/\D+/g,""));class ve extends i{constructor(e=new l){super({uniforms:{inputBuffer:new s(null),depthBuffer:new s(null),resolution:new s(new l),texelSize:new s(new l),halfTexelSize:new s(new l),kernel:new s(0),scale:new s(1),cameraNear:new s(0),cameraFar:new s(1),minDepthThreshold:new s(0),maxDepthThreshold:new s(1),depthScale:new s(0),depthToBlurRatioBias:new s(.25)},fragmentShader:`#include <common>\n        #include <dithering_pars_fragment>      \n        uniform sampler2D inputBuffer;\n        uniform sampler2D depthBuffer;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          float depthFactor = 0.0;\n          \n          #ifdef USE_DEPTH\n            vec4 depth = texture2D(depthBuffer, vUv);\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n            depthFactor *= depthScale;\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\n          #endif\n          \n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\n          gl_FragColor = sum * 0.25 ;\n\n          #include <dithering_fragment>\n          #include <tonemapping_fragment>\n          #include <${he>=154?"colorspace_fragment":"encodings_fragment"}>\n        }`,vertexShader:"uniform vec2 texelSize;\n        uniform vec2 halfTexelSize;\n        uniform float kernel;\n        uniform float scale;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          vec2 uv = position.xy * 0.5 + 0.5;\n          vUv = uv;\n\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0);\n        }",blending:o,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}class me{constructor({resolution:e,width:t=500,height:r=500,minDepthThreshold:a=0,maxDepthThreshold:n=1,depthScale:i=0,depthToBlurRatioBias:o=.25}){this.renderToScreen=!1,this.renderTargetA=new h(e,e,{minFilter:m,magFilter:m,stencilBuffer:!1,depthBuffer:!1,type:v}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new ve,this.convolutionMaterial.setTexelSize(1/t,1/r),this.convolutionMaterial.setResolution(new l(t,r)),this.scene=new d,this.camera=new f,this.convolutionMaterial.uniforms.minDepthThreshold.value=a,this.convolutionMaterial.uniforms.maxDepthThreshold.value=n,this.convolutionMaterial.uniforms.depthScale.value=i,this.convolutionMaterial.uniforms.depthToBlurRatioBias.value=o,this.convolutionMaterial.defines.USE_DEPTH=i>0;const s=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),u=new Float32Array([0,0,2,0,0,2]),g=new p;g.setAttribute("position",new c(s,3)),g.setAttribute("uv",new c(u,2)),this.screen=new x(g,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,r){const a=this.scene,n=this.camera,i=this.renderTargetA,l=this.renderTargetB,o=this.convolutionMaterial,s=o.uniforms;s.depthBuffer.value=t.depthTexture;const u=o.kernel;let h,v,m,d=t;for(v=0,m=u.length-1;v<m;++v)h=1&v?l:i,s.kernel.value=u[v],s.inputBuffer.value=d.texture,e.setRenderTarget(h),e.render(a,n),d=h;s.kernel.value=u[v],s.inputBuffer.value=d.texture,e.setRenderTarget(this.renderToScreen?null:r),e.render(a,n)}}class de extends g{constructor(e={}){super(e),this._tDepth={value:null},this._distortionMap={value:null},this._tDiffuse={value:null},this._tDiffuseBlur={value:null},this._textureMatrix={value:null},this._hasBlur={value:!1},this._mirror={value:0},this._mixBlur={value:0},this._blurStrength={value:.5},this._minDepthThreshold={value:.9},this._maxDepthThreshold={value:1},this._depthScale={value:0},this._depthToBlurRatioBias={value:.25},this._distortion={value:1},this._mixContrast={value:1},this.setValues(e)}onBeforeCompile(e){e.defines?.USE_UV||(e.defines.USE_UV=""),e.uniforms.hasBlur=this._hasBlur,e.uniforms.tDiffuse=this._tDiffuse,e.uniforms.tDepth=this._tDepth,e.uniforms.distortionMap=this._distortionMap,e.uniforms.tDiffuseBlur=this._tDiffuseBlur,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mirror=this._mirror,e.uniforms.mixBlur=this._mixBlur,e.uniforms.mixStrength=this._blurStrength,e.uniforms.minDepthThreshold=this._minDepthThreshold,e.uniforms.maxDepthThreshold=this._maxDepthThreshold,e.uniforms.depthScale=this._depthScale,e.uniforms.depthToBlurRatioBias=this._depthToBlurRatioBias,e.uniforms.distortion=this._distortion,e.uniforms.mixContrast=this._mixContrast,e.vertexShader=`\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;\n      ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace("#include <project_vertex>","#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );"),e.fragmentShader=`\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDiffuseBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n\t\t\t  uniform float cameraFar;\n        uniform bool hasBlur;\n        uniform float mixBlur;\n        uniform float mirror;\n        uniform float mixStrength;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float mixContrast;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec4 my_vUv;\n        ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>","#include <emissivemap_fragment>\n\n      float distortionFactor = 0.0;\n      #ifdef USE_DISTORTION\n        distortionFactor = texture2D(distortionMap, vUv).r * distortion;\n      #endif\n\n      vec4 new_vUv = my_vUv;\n      new_vUv.x += distortionFactor;\n      new_vUv.y += distortionFactor;\n\n      vec4 base = texture2DProj(tDiffuse, new_vUv);\n      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\n\n      vec4 merge = base;\n\n      #ifdef USE_NORMALMAP\n        vec2 normal_uv = vec2(0.0);\n        vec4 normalColor = texture2D(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n        vec4 base_normal = texture2D(tDiffuse, normal_uv);\n        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\n        merge = base_normal;\n        blur = blur_normal;\n      #endif\n\n      float depthFactor = 0.0001;\n      float blurFactor = 0.0;\n\n      #ifdef USE_DEPTH\n        vec4 depth = texture2DProj(tDepth, new_vUv);\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n        depthFactor *= depthScale;\n        depthFactor = max(0.0001, min(1.0, depthFactor));\n\n        #ifdef USE_BLUR\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\n          merge = merge * min(1.0, depthFactor + 0.5);\n        #else\n          merge = merge * depthFactor;\n        #endif\n\n      #endif\n\n      float reflectorRoughnessFactor = roughness;\n      #ifdef USE_ROUGHNESSMAP\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n      #endif\n\n      #ifdef USE_BLUR\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n        merge = mix(merge, blur, blurFactor);\n      #endif\n\n      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);\n      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;\n      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;\n      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;\n\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);\n      ")}get tDiffuse(){return this._tDiffuse.value}set tDiffuse(e){this._tDiffuse.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tDiffuseBlur(){return this._tDiffuseBlur.value}set tDiffuseBlur(e){this._tDiffuseBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get hasBlur(){return this._hasBlur.value}set hasBlur(e){this._hasBlur.value=e}get mirror(){return this._mirror.value}set mirror(e){this._mirror.value=e}get mixBlur(){return this._mixBlur.value}set mixBlur(e){this._mixBlur.value=e}get mixStrength(){return this._blurStrength.value}set mixStrength(e){this._blurStrength.value=e}get minDepthThreshold(){return this._minDepthThreshold.value}set minDepthThreshold(e){this._minDepthThreshold.value=e}get maxDepthThreshold(){return this._maxDepthThreshold.value}set maxDepthThreshold(e){this._maxDepthThreshold.value=e}get depthScale(){return this._depthScale.value}set depthScale(e){this._depthScale.value=e}get depthToBlurRatioBias(){return this._depthToBlurRatioBias.value}set depthToBlurRatioBias(e){this._depthToBlurRatioBias.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}get mixContrast(){return this._mixContrast.value}set mixContrast(e){this._mixContrast.value=e}}const fe=["texture-matrix","mirror","t-diffuse","t-depth","t-diffuse-blur","has-blur","mix-strength","min-depth-threshold","max-depth-threshold","depth-scale","depth-to-blur-ratio-bias","distortion","distortionMap","mix-contrast","defines-USE_BLUR","defines-USE_DEPTH","defines-USE_DISTORTION"],pe=F({__name:"index",props:{resolution:{default:256},mixBlur:{default:0},mixStrength:{default:1},blur:{default:()=>[0,0]},mirror:{default:0},minDepthThreshold:{default:.9},maxDepthThreshold:{default:1},depthScale:{default:0},depthToBlurRatioBias:{default:.25},distortionMap:{},distortion:{default:1},mixContrast:{default:1},reflectorOffset:{default:0}},setup(r){const a=r;const{resolution:n,minDepthThreshold:i,maxDepthThreshold:l,depthScale:o,depthToBlurRatioBias:s,blur:u,mirror:d,mixBlur:f,mixStrength:p,distortion:c,distortionMap:x,mixContrast:g}=E(a),{camera:y,scene:b,renderer:P,extend:R}=e();R({MeshReflectorMaterial:de});const C=j(),F=j(),G=j(),H=j(),$=k((()=>"number"==typeof u.value?[u.value,u.value]:u.value)),V=k((()=>$.value[0]>0||$.value[1]>0)),q={reflectorPlane:new B,normal:new M,reflectorWorldPosition:new M,cameraWorldPosition:new M,rotationMatrix:new _,lookAtPosition:new M(0,0,-1),clipPlane:new D,view:new M,target:new M,q:new D,virtualCamera:new T,textureMatrix:new _};A((()=>{C.value?.texture.dispose();const e={minFilter:m,magFilter:m,type:v};C.value=new h(n.value,n.value,{...e,depthBuffer:!0,depthTexture:new S(n.value,n.value,w,U)}),F.value=new h(n.value,n.value,e),G.value=new me({resolution:n.value,width:$.value[0],height:$.value[1],minDepthThreshold:i.value,maxDepthThreshold:l.value,depthScale:o.value,depthToBlurRatioBias:s.value}),H.value={mirror:d,textureMatrix:q.textureMatrix,mixBlur:f,tDiffuse:C.value.texture,tDepth:C.value.depthTexture,tDiffuseBlur:C.value.texture,hasBlur:V,mixStrength:p,minDepthThreshold:i,maxDepthThreshold:l,depthScale:o,depthToBlurRatioBias:s,distortion:c,distortionMap:x.value,mixContrast:g,"defines-USE_BLUR":V.value?"":void 0,"defines-USE_DEPTH":o.value>0?"":void 0,"defines-USE_DISTORTION":x.value?"":void 0}}));const X=j(),{onLoop:J}=t();J((()=>{if(!(X.value&&P.value&&C.value&&y.value))return;const e=function(e,t){let r;return e.traverse((e=>{e.isMesh&&e.material&&e.material.uuid===t&&(r=e)})),r}(b.value,X.value.uuid);if(!e)return;e.visible=!1;const t=P.value.xr.enabled,r=P.value.shadowMap.autoUpdate;!function(e){if(q.reflectorWorldPosition.setFromMatrixPosition(e.matrixWorld),q.cameraWorldPosition.setFromMatrixPosition(y.value?.matrixWorld),q.rotationMatrix.extractRotation(e.matrixWorld),q.normal.set(0,0,1),q.normal.applyMatrix4(q.rotationMatrix),q.reflectorWorldPosition.addScaledVector(q.normal,a.reflectorOffset),q.view.subVectors(q.reflectorWorldPosition,q.cameraWorldPosition),q.view.dot(q.normal)>0)return;q.view.reflect(q.normal).negate(),q.view.add(q.reflectorWorldPosition),q.rotationMatrix.extractRotation(y.value?.matrixWorld),q.lookAtPosition.set(0,0,-1),q.lookAtPosition.applyMatrix4(q.rotationMatrix),q.lookAtPosition.add(q.cameraWorldPosition),q.target.subVectors(q.reflectorWorldPosition,q.lookAtPosition),q.target.reflect(q.normal).negate(),q.target.add(q.reflectorWorldPosition),q.virtualCamera.position.copy(q.view),q.virtualCamera.up.set(0,1,0),q.virtualCamera.up.applyMatrix4(q.rotationMatrix),q.virtualCamera.up.reflect(q.normal),q.virtualCamera.lookAt(q.target),q.virtualCamera.far=(y?.value).far,q.virtualCamera.updateMatrixWorld(),q.virtualCamera.projectionMatrix.copy((y?.value).projectionMatrix),q.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),q.textureMatrix.multiply(q.virtualCamera.projectionMatrix),q.textureMatrix.multiply(q.virtualCamera.matrixWorldInverse),q.textureMatrix.multiply(e.matrixWorld),q.reflectorPlane.setFromNormalAndCoplanarPoint(q.normal,q.reflectorWorldPosition),q.reflectorPlane.applyMatrix4(q.virtualCamera.matrixWorldInverse),q.clipPlane.set(q.reflectorPlane.normal.x,q.reflectorPlane.normal.y,q.reflectorPlane.normal.z,q.reflectorPlane.constant);const t=q.virtualCamera.projectionMatrix;q.q.x=(Math.sign(q.clipPlane.x)+t.elements[8])/t.elements[0],q.q.y=(Math.sign(q.clipPlane.y)+t.elements[9])/t.elements[5],q.q.z=-1,q.q.w=(1+t.elements[10])/t.elements[14],q.clipPlane.multiplyScalar(2/q.clipPlane.dot(q.q)),t.elements[2]=q.clipPlane.x,t.elements[6]=q.clipPlane.y,t.elements[10]=q.clipPlane.z+1,t.elements[14]=q.clipPlane.w}(e),P.value.shadowMap.autoUpdate=!1,P.value.setRenderTarget(C.value),P.value.autoClear||P.value.clear(),P.value.render(b.value,q.virtualCamera),G?.value?.render(P.value,C.value,F.value),P.value.xr.enabled=t,P.value.shadowMap.autoUpdate=r,e.visible=!0,P.value.setRenderTarget(null)}));const K=z(),Q=k((()=>{const e={};return Object.assign(e,a),Object.assign(e,K.value),e}));return W((()=>{C?.value?.dispose(),F?.value?.dispose()})),(e,t)=>(O(),I("TresMeshReflectorMaterial",L({key:`key${H.value["defines-USE_BLUR"]}${H.value["defines-USE_DEPTH"]}${H.value["defines-USE_DISTORTION"]}`,ref_key:"materialRef",ref:X},Q.value,{"texture-matrix":q.textureMatrix,mirror:N(d),"t-diffuse":C.value?.texture,"t-depth":C.value?.depthTexture,"t-diffuse-blur":F.value?.texture,"has-blur":V.value,"mix-strength":N(p),"min-depth-threshold":N(i),"max-depth-threshold":N(l),"depth-scale":N(o),"depth-to-blur-ratio-bias":N(s),distortion:N(c),distortionMap:N(x),"mix-contrast":N(g),"defines-USE_BLUR":V.value?"":void 0,"defines-USE_DEPTH":N(o)>0?"":void 0,"defines-USE_DISTORTION":N(x)?"":void 0}),null,16,fe))}});const ce=["object"],xe=F({__name:"index",props:{resolution:{default:256},near:{default:.1},far:{default:1e3},envMap:{default:null},fog:{default:null},frames:{default:1/0}},setup(r,{expose:a}){const n=r,{fbo:i,camera:l,update:o}=function({resolution:t=256,near:r=.1,far:a=1e3,envMap:n,fog:i}={}){const{renderer:l,scene:o}=e(),s=G(null),u=G(t),h=G(r),m=G(a),d=G(null);let f,p;return H((()=>u),(e=>{s.value?.dispose(),s.value=new y(e.value),s.value.texture.type=v}),{immediate:!0}),H([h,m,s],(([e,t,r])=>{r&&(d.value=new b(e,t,r))}),{immediate:!0}),W((()=>{s.value?.dispose()})),{fbo:s,camera:d,update:()=>{f=o.value.fog,p=o.value.background,o.value.background=n||p,o.value.fog=i||f,d.value?.update(l.value,o.value),o.value.fog=f,o.value.background=p}}}({resolution:n.resolution,near:n.near,far:n.far,envMap:n.envMap,fog:n.fog}),{onBeforeLoop:s}=t();let u=0;const h=G(null);return s((()=>{h.value&&(n.frames===1/0||u<n.frames)&&(h.value.visible=!1,o(),h.value.visible=!0,u++)})),a({texture:i.value?.texture}),(e,t)=>(O(),I("TresGroup",null,[$("primitive",{object:N(l)},null,8,ce),$("TresGroup",{ref_key:"rgRef",ref:h},[V(e.$slots,"default")],512)]))}}),ge=["map"],_e=["envMap"],Te=F({__name:"screen",async setup(e){let t,a;const n=G();n.value=([t,a]=q((()=>r("./plugins/visualArts/video/vlg.mp4",{loop:!0}))),t=await t,a(),t),n.value.colorSpace=P;const i=G(),l=G();H(i,(e=>{l.value=e.texture}));const o=G();return(e,t)=>(O(),I(K,null,[$("TresMesh",{ref_key:"tmSceen",ref:o,position:[0,0,-16]},[t[0]||(t[0]=$("TresPlaneGeometry",{args:[16,10]},null,-1)),$("TresMeshBasicMaterial",{map:n.value},null,8,ge),t[1]||(t[1]=$("TresMesh",{scale:[16.05,10.05,1],position:[0,0,-.01]},[$("TresPlaneGeometry"),$("TresMeshBasicMaterial",{color:"black"})],-1))],512),X(N(xe),{ref_key:"cubeCameraRef",ref:i,position:[-3,-1,-5],resolution:256},{default:J((()=>[$("TresMesh",null,[t[2]||(t[2]=$("TresSphereGeometry",{args:[2,32,32]},null,-1)),$("TresMeshStandardMaterial",{metalness:1,roughness:.1,envMap:l.value},null,8,_e)])])),_:1},512)],64))}}),De=F({__name:"effectComposer",props:{screen:{}},setup(r){const a=r,{camera:n,renderer:i,scene:l,sizes:o}=e();let s=null,u=null;const h=[];A((()=>{if(o.width.value){const e=n.value;((e,t,r)=>{s=new ie(r,{frameBufferType:v,multisampling:8});const a=new le(e,t);s.addPass(a)})(l.value,e,i.value,o.width.value,o.height.value),(e=>{const t=new R({color:16768426,transparent:!0,fog:!1}),r=new C(.75,32,32),n=new x(r,t);n.frustumCulled=!1,n.matrixAutoUpdate=!1;const i=new se(e,Q(a.screen),{blur:!0,decay:.8,exposure:.34});h.push(i)})(e),h.push(new oe({luminanceThreshold:0,mipmapBlur:!0,luminanceSmoothing:0,intensity:1})),u=new ue(e,...h),s.addPass(u)}}));const{onAfterLoop:m}=t();return m((()=>{s&&s.render()})),(e,t)=>null}}),Me=["rotation"],Be=F({__name:"volumetricLightGodray",setup(e){const t=Y({clearColor:"#050505",antialias:!1,renderMode:"manual"}),r=Y({enableDamping:!0}),i=G(null),l=G(null);return H((()=>i),(e=>{Z((()=>{e&&void 0!==e.value.$refs.tmSceen&&(l.value=e.value.$refs.tmSceen)}))}),{deep:!0}),(e,o)=>(O(),ee(N(n),L(t,{"window-size":""}),{default:J((()=>[o[1]||(o[1]=$("TresPerspectiveCamera",{position:[0,0,30],fov:45,near:.1,far:1e3},null,-1)),X(N(a),re(ae(r)),null,16),o[2]||(o[2]=$("TresAmbientLight",{intensity:.5},null,-1)),(O(),ee(ne,null,{default:J((()=>[X(Te,{ref_key:"screenRef",ref:i},null,512)])),_:1})),$("TresMesh",{position:[0,-5.02,0],receiveShadow:"",rotation:[-Math.PI/2,0,0]},[o[0]||(o[0]=$("TresPlaneGeometry",{args:[50,50]},null,-1)),X(N(pe),{blur:[300,50],resolution:1024,mixBlur:1,mixStrength:100,roughness:1,depthScale:1.2,minDepthThreshold:.4,maxDepthThreshold:1.4,color:"#202020",metalness:.8})],8,Me),l.value?(O(),ee(De,{key:0,screen:l.value},null,8,["screen"])):te("",!0)])),_:1},16))}});export{Be as default};
