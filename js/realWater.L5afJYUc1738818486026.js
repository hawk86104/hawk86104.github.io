import{m as n,e,a as t,o as r,f as o}from"./@tresjs.ZGxFoQtw1738818486026.js";import{P as i}from"./tweakpane.yDiyAAkA1738818486026.js";import{_ as c,r as a,aM as l,aW as s,K as u,O as f,C as p}from"./three.WgQSjl1J1738818486026.js";import{d as v,a3 as g,b as d,o as x,f as h,u as m,g as y,j as w,al as b,r as R,N as I,aj as C,ak as _}from"./@vue.NRI7TcgI1738818486026.js";import"./@vueuse.Fak-HUpz1738818486026.js";var z="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const M=D;function D(n,e){const t=O();return(D=function(n,e){return t[n-=338]})(n,e)}!function(n,e){const t=D,r=O();for(;;)try{if(711144===-parseInt(t(375))/1*(-parseInt(t(348))/2)+-parseInt(t(381))/3+parseInt(t(361))/4+parseInt(t(368))/5*(-parseInt(t(352))/6)+parseInt(t(365))/7+-parseInt(t(386))/8+parseInt(t(372))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){T(this,(function(){const n=D,e=new RegExp(n(351)),t=new RegExp(n(357),"i"),r=F(n(366));e[n(350)](r+n(354))&&t[n(350)](r+n(360))?F():r("0")}))()}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[D(340)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();L(void 0,(function(){const n=D;let e;try{e=Function("return (function() "+n(346)+");")()}catch(o){e=window}const t=e[n(380)]=e[n(380)]||{},r=[n(370),n(342),n(369),n(364),n(363),n(383),n(384)];for(let i=0;i<r[n(374)];i++){const e=L[n(359)][n(376)].bind(L),o=r[i],c=t[o]||e;e.__proto__=L.bind(L),e.toString=c[n(353)][n(338)](c),t[o]=e}}))();const A=v({__name:M(371),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=M,o=t,i=new(c[r(355)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(347)](r(385),new(c[r(367)])(l,3)),i[r(362)](new(c[r(367)])(s,1));const u=new(c[r(356)])({uniforms:{light:{value:o[r(388)]},tiles:{value:o[r(379)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(373)]}),f=new a(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{((n,e)=>{const t=r;u[t(343)][t(382)].value=n,u[t(343)][t(349)][t(389)]=e,p.value[t(344)](f,v[t(389)])})(o[r(345)],o.causticsTexture)})),(n,e)=>null}});function O(){const n=["2CPDdaX","causticTex","test","function *\\( *\\)","4814316TGNlWp","toString","chain","BufferGeometry","RawShaderMaterial","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","debu","constructor","input","3238212kdZytc","setIndex","exception","error","4318650zXhVdf","init","BufferAttribute","5ipIZuW","info","log","pool","7094745ifrTCg","FrontSide","length","863689AosBLV","prototype","while (true) {}","gger","tiles","console","2888415snLrHZ","water","table","trace","position","4817296UUweHj","string","light","value","bind","call","apply","counter","warn","uniforms","render","waterTexture",'{}.constructor("return this")( )',"setAttribute"];return(O=function(){return n})()}function F(n){function e(n){const t=D;if(typeof n===t(387))return function(n){}[t(359)](t(377))[t(340)](t(341));1!==(""+n/n)[t(374)]||n%20==0?function(){return!0}[t(359)]("debu"+t(378))[t(339)]("action"):function(){return!1}[t(359)](t(358)+t(378))[t(340)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const j=P;!function(n,e){const t=P,r=E();for(;;)try{if(650504===parseInt(t(246))/1+parseInt(t(257))/2+-parseInt(t(270))/3*(parseInt(t(247))/4)+parseInt(t(242))/5+-parseInt(t(278))/6+parseInt(t(287))/7*(-parseInt(t(263))/8)+-parseInt(t(273))/9*(-parseInt(t(284))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(244)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){S(this,(function(){const n=P,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(258),"i"),r=k(n(283));e[n(240)](r+"chain")&&t[n(240)](r+n(267))?k():r("0")}))()}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(244)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function E(){const n=["2379928OttOQW","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","pos-z.jpg","causticTex","clear","causticsTexture","169760lDkwYY","string","prototype","constructor","input","value","pooRef","2445pcwNKd","stateObject","neg-z.jpg","171MelDup","geometry","render","bind","load","6711660iyephD","waterTexture","toString","side","light","init","180130cMoUlI","return (function() ","Color","21bLSgoI","while (true) {}","underwater","console","debu","Mesh","white","warn","log","test","FrontSide","5371955KlKzRQ","setPath","apply","setRenderTarget","516317owkKvA","6332MLnFbB","uniforms","neg-x.jpg","setClearColor","action","call","gger","water","length",'{}.constructor("return this")( )'];return(E=function(){return n})()}function P(n,e){const t=E();return(P=function(n,e){return t[n-=234]})(n,e)}W(void 0,(function(){const n=P;let e;try{e=Function(n(285)+n(256)+");")()}catch(o){e=window}const t=e[n(234)]=e[n(234)]||{},r=[n(239),n(238),"info","error","exception","table","trace"];for(let i=0;i<r[n(255)];i++){const e=W[n(266)][n(265)][n(276)](W),o=r[i],c=t[o]||e;e.__proto__=W.bind(W),e[n(280)]=c.toString[n(276)](c),t[o]=e}}))();const V=v({__name:j(254),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=j;let i,a;const f=r,p=f[o(274)],v=(new l)[o(243)]("https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/")[o(277)](["pos-x.jpg",o(249),"pos-y.jpg","neg-y.jpg",o(259),o(272)]),y=([i,a]=g((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),w=new s({uniforms:{light:{value:f[o(282)]},tiles:{value:y},sky:{value:v},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),b=new(c[o(236)])(p,w),R=d(null),I=new(c[o(286)])(o(237)),{renderer:C,camera:_}=n(),{onLoop:z}=e();return z((()=>{const n=o;C.value[n(245)](null),C[n(268)][n(250)](I,1),C.value[n(261)](),w.uniforms[n(254)][n(268)]=f[n(279)],w[n(248)][n(260)].value=f[n(262)],w[n(281)]=c[n(241)],w[n(248)][n(289)][n(268)]=!0,C[n(268)][n(275)](b,_[n(268)]),w[n(281)]=u,w.uniforms.underwater[n(268)]=!1,C[n(268)].render(b,_.value)})),(n,e)=>{const t=o;return x(),h(A,{tiles:m(y),light:n[t(282)],waterTexture:n[t(279)],causticsTexture:n.causticsTexture,ref_key:t(269),ref:R},null,8,["tiles",t(282),t(279),t(262)])}}});function k(n){function e(n){const t=P;if(typeof n===t(264))return function(n){}[t(266)](t(288))[t(244)]("counter");1!==(""+n/n)[t(255)]||n%20==0?function(){return!0}[t(266)](t(235)+t(253))[t(252)](t(251)):function(){return!1}[t(266)]("debu"+t(253)).apply(t(271)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const H=B;!function(n,e){const t=B,r=G();for(;;)try{if(969899===parseInt(t(475))/1*(parseInt(t(481))/2)+-parseInt(t(447))/3*(parseInt(t(472))/4)+-parseInt(t(441))/5+parseInt(t(483))/6*(-parseInt(t(445))/7)+parseInt(t(460))/8*(parseInt(t(461))/9)+-parseInt(t(439))/10+parseInt(t(444))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Z(this,(function(){const n=B,e=new RegExp(n(442)),t=new RegExp(n(440),"i"),r=Y(n(466));e[n(486)](r+"chain")&&t[n(486)](r+"input")?Y():r("0")}))()}();const N=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function B(n,e){const t=G();return(B=function(n,e){return t[n-=438]})(n,e)}function G(){const n=["value","apply","debu","gger","764914ZZUXfD","action","217164uOOtLa","console","causticsTexture","test","WebGLRenderTarget","ShaderMaterial","setRenderTarget","2474930bVrplh","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","244545yVrbtX","function *\\( *\\)","return (function() ","19145335tBoKwn","70WATIbU","Mesh","3467241TiETRd","bind","clear","toString","call","length","error","caustics","water","prototype","setClearColor","info","while (true) {}","8CyDOhF","2507301FtSLcm","black","geometry","warn","constructor","init","exception","texture","waterTexture","uniforms","PlaneGeometry","4QeoLSj",'{}.constructor("return this")( )',"light","2jsvYhW","table"];return(G=function(){return n})()}N(void 0,(function(){const n=B,e=function(){const n=B;let e;try{e=Function(n(443)+n(473)+");")()}catch(t){e=window}return e}(),t=e[n(484)]=e.console||{},r=["log",n(464),n(458),n(453),n(467),n(476),"trace"];for(let o=0;o<r[n(452)];o++){const e=N.constructor[n(456)][n(448)](N),i=r[o],c=t[i]||e;e.__proto__=N[n(448)](N),e.toString=c[n(450)][n(448)](c),t[i]=e}}))();const X=v({__name:H(454),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=H,o=t,i=new f(0,1,1,0,0,2e3),a=new(c[r(471)])(2,2,200,200),l=new(c[r(487)])(1024,1024),s=new(c[r(488)])({uniforms:{light:{value:o[r(474)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),u=new(c[r(446)])(a,s),v=new p(r(462)),{renderer:g}=n(),{onBeforeLoop:d}=e();return d((()=>{const n=r;u.material[n(470)][n(455)][n(477)]=o[n(469)],g[n(477)][n(438)](l),g.value[n(457)](v,0),g[n(477)][n(449)](),g[n(477)].render(u,i)})),(n,e)=>{const t=r;return x(),h(b,null,{default:y((()=>[w(V,{waterTexture:n[t(469)],causticsTexture:m(l)[t(468)],light:n[t(474)],geometry:m(a)},null,8,[t(469),t(485),t(474),t(463)])])),_:1})}}});function Y(n){function e(n){const t=B;if("string"==typeof n)return function(n){}[t(465)](t(459))[t(478)]("counter");1!==(""+n/n)[t(452)]||n%20==0?function(){return!0}.constructor(t(479)+"gger")[t(451)](t(482)):function(){return!1}[t(465)](t(479)+t(480)).apply("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const $=q;!function(n,e){const t=q,r=Q();for(;;)try{if(738714===parseInt(t(472))/1*(-parseInt(t(529))/2)+parseInt(t(523))/3*(parseInt(t(480))/4)+-parseInt(t(507))/5+parseInt(t(492))/6+-parseInt(t(482))/7*(parseInt(t(483))/8)+-parseInt(t(490))/9+parseInt(t(500))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(495)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){K(this,(function(){const n=q,e=new RegExp(n(533)),t=new RegExp(n(502),"i"),r=nn(n(510));e[n(520)](r+"chain")&&t[n(520)](r+n(508))?nn():r("0")}))()}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(495)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Q(){const n=["init","OrthographicCamera","getBoundingClientRect","WebGLRenderTarget","call","constructor",'{}.constructor("return this")( )',"warn","getY","texture","test","waterSimulation","return (function() ","356613KzAYwH","uniforms","setY","debu","Vector2","exception","334ucsraV","count","mousemove","waterTexture","function *\\( *\\)","addEventListener","left","lightFrontGeometry","material","6517lyJmSR","light","length","domElement","setFromCamera","autoClear","string","Mesh","24xrrthA","clientY","3633wBnglF","20936tjcMaT","__proto__","action","gger","width","needsUpdate","FloatType","5469669oqcacR","strength","6481158RlJjWg","trace","toString","apply","PlaneGeometry","while (true) {}","stateObject","removeEventListener","21841350sAyPQj","bind","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","value","top","point","center","922685SOwlNO","input","table"];return(Q=function(){return n})()}function q(n,e){const t=Q();return(q=function(n,e){return t[n-=468]})(n,e)}U(void 0,(function(){const n=q,e=function(){const n=q;let e;try{e=Function(n(522)+n(516)+");")()}catch(t){e=window}return e}(),t=e.console=e.console||{},r=["log",n(517),"info","error",n(528),n(509),n(493)];for(let o=0;o<r[n(474)];o++){const e=U[n(515)].prototype[n(501)](U),i=r[o],c=t[i]||e;e[n(484)]=U.bind(U),e[n(494)]=c.toString[n(501)](c),t[i]=e}}))();const J=v({__name:$(521),props:{light:{}},setup(t,{expose:r}){const o=$,i=new(c[o(511)])(0,1,1,0,0,2e3),l=new(c[o(496)])(2,2),u=new(c[o(513)])(256,256,{type:c[o(489)]}),f=new(c[o(513)])(256,256,{type:c[o(489)]}),p=new s({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),v=new s({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),g=new s({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),d=new(c[o(479)])(l,p),y=new(c[o(479)])(l,v),w=new(c[o(479)])(l,g);let b=u;const R=(n,e)=>{const t=o,r=b,c=b===u?f:u;e[t(471)][t(524)][t(519)][t(503)]=r.texture,n.setRenderTarget(c),n.render(e,i),b=c},{renderer:I,camera:C,raycaster:_}=n();I[o(503)][o(477)]=!1;const{onBeforeLoop:M}=e();M((()=>{const n=o;var e,t;t=I[n(503)],R(t,w),e=I[n(503)],R(e,y)}));const D=(n,e,t,r)=>{const i=o;d[i(471)][i(524)][i(506)][i(503)]=[n,e],d.material[i(524)].radius[i(503)]=t,d.material[i(524)][i(491)].value=r,R(I[i(503)],d)},T=new(c[o(527)]),L=new(c[o(496)])(2,2),A=L.attributes.position;for(let n=0;n<A[o(530)];n++){const e=-A[o(518)](n);A[o(525)](n,0),A.setZ(n,e)}A[o(488)]=!0;const O=new a(L),F={handleEvent:n=>{const e=o,t=I[e(503)][e(475)][e(512)](),r=t[e(487)],i=t.height;T.x=2*(n.clientX-t[e(469)])/r-1,T.y=2*-(n[e(481)]-t[e(504)])/i+1,_[e(503)][e(476)](T,C.value);const c=_.value.intersectObject(O);for(let o of c)D(o[e(505)].x,o[e(505)].z,.03,.04)}};return r({addDrop:D,mouseEvent:n=>{const e=o;n?I[e(503)][e(475)][e(468)](e(531),F):I.value[e(475)][e(499)](e(531),F)}}),(n,e)=>{const t=o;return x(),h(X,{lightFrontGeometry:m(l),waterTexture:m(b)[t(519)],light:n[t(473)]},null,8,[t(470),t(532),t(473)])}}});function nn(n){function e(n){const t=q;if(typeof n===t(478))return function(n){}[t(515)](t(497))[t(495)]("counter");1!==(""+n/n)[t(474)]||n%20==0?function(){return!0}.constructor(t(526)+"gger")[t(514)](t(485)):function(){return!1}[t(515)]("debu"+t(486))[t(495)](t(498)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=on,r=tn();for(;;)try{if(995076===parseInt(t(450))/1*(parseInt(t(449))/2)+parseInt(t(458))/3+-parseInt(t(472))/4+-parseInt(t(428))/5*(-parseInt(t(457))/6)+parseInt(t(451))/7+-parseInt(t(429))/8*(-parseInt(t(455))/9)+-parseInt(t(462))/10*(parseInt(t(441))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(444)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function tn(){const n=["28183YRzkNz","7147728wTtcGC","click","addDrop","stateObject","351tQCzLH","bind","150csaVnl","547263RAidIY","call","trace","mouseEvent","165380jKhPbX","chain","prototype","随机增加波纹","counter","return (function() ",'{}.constructor("return this")( )',"constructor","exception","action","1483600HpiFYx","value","change","waterSimulationRef","393265RkFGJI","247976tXuvep","manual","debu","warn","random","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","function *\\( *\\)","gger","info","__proto__","length","error","2585XIKXzl","test","toString","apply","input","string","console","table","62LXlBfP"];return(tn=function(){return n})()}!function(){en(this,(function(){const n=on,e=new RegExp(n(435)),t=new RegExp(n(434),"i"),r=an("init");e[n(442)](r+n(463))&&t[n(442)](r+n(445))?an():r("0")}))()}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(444)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function on(n,e){const t=tn();return(on=function(n,e){return t[n-=425]})(n,e)}rn(void 0,(function(){const n=on,e=function(){const n=on;let e;try{e=Function(n(467)+n(468)+");")()}catch(t){e=window}return e}(),t=e[n(447)]=e[n(447)]||{},r=["log",n(432),n(437),n(440),n(470),n(448),n(460)];for(let o=0;o<r.length;o++){const e=rn.constructor[n(464)][n(456)](rn),i=r[o],c=t[i]||e;e[n(438)]=rn[n(456)](rn),e[n(443)]=c[n(443)][n(456)](c),t[i]=e}}))();const cn=v({__name:"realWater",setup(n){const e=on,t=R({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(430)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=d(null),l=new i;l.addButton({label:"点击按钮",title:e(465)}).on(e(452),(()=>{const n=e;for(var t=0;t<10;t++)a.value[n(453)](2*Math[n(433)]()-1,2*Math[n(433)]()-1,.03,1&t?.02:-.02)}));const s=d(!1);return l.addBinding(s,e(425),{label:"鼠标波纹"}).on(e(426),(n=>{const t=e;a[t(425)][t(461)](n[t(425)])})),(n,i)=>{const l=e;return x(),h(m(o),C(_(t)),{default:y((()=>[i[0]||(i[0]=I("TresPerspectiveCamera",{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),w(m(r)),w(J,{light:c,ref_key:l(427),ref:a},null,512)])),_:1},16)}}});function an(n){function e(n){const t=on;if(typeof n===t(446))return function(n){}.constructor("while (true) {}")[t(444)](t(466));1!==(""+n/n)[t(439)]||n%20==0?function(){return!0}[t(469)](t(431)+"gger")[t(459)](t(471)):function(){return!1}[t(469)](t(431)+t(436))[t(444)](t(454)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{cn as default};
