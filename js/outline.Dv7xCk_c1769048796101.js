import{mergeVertices as e,importShared as t,toCreasedNormals as n,mergeGeometries as o}from"./3d-tiles-renderer.DoRCwQO21769048796101.js";import{useTres as s,useGLTF as i,TresCanvas_default as r,OrbitControls_default as a}from"./index.DY1Qq3wV1769048796101.js";import{Pane as l}from"./tweakpane.BbuIEN141769048796101.js";import{shaderMaterial as c}from"./shaderMaterial.BbGBamvu1769048796101.js";const{BufferGeometry:h,Color:u,Float32BufferAttribute:f,Vector2:p,Vector3:d,Vector4:g}=await t("three"),m=new d,v=new d;class b{modify(t,n){delete(t=t.clone()).morphAttributes.position,delete t.morphAttributes.normal;const o=t.attributes;for(const e in o)"position"!==e&&"uv"!==e&&"normal"!==e&&"tangent"!==e&&"color"!==e&&t.deleteAttribute(e);const s=[],i=[],r=(t=e(t)).getAttribute("position"),a=t.getAttribute("uv"),l=t.getAttribute("normal"),c=t.getAttribute("tangent"),m=t.getAttribute("color");let v=null,b=null,w=null,N=null;for(let e=0;e<r.count;e++){const t=(new d).fromBufferAttribute(r,e);a&&(b=(new p).fromBufferAttribute(a,e)),l&&(w=(new d).fromBufferAttribute(l,e)),c&&(v=(new g).fromBufferAttribute(c,e)),m&&(N=(new u).fromBufferAttribute(m,e));const n=new B(t,b,w,v,N);s.push(n)}let y,k=t.getIndex();if(null!==k)for(let e=0;e<k.count;e+=3){const t=k.getX(e),n=k.getX(e+1),o=k.getX(e+2),r=new _(s[t],s[n],s[o],t,n,o);i.push(r)}else for(let e=0;e<r.count;e+=3){const t=e,n=e+1,o=e+2,r=new _(s[t],s[n],s[o],t,n,o);i.push(r)}for(let e=0,h=s.length;e<h;e++)x(s[e]);let A=n;for(;A--;){if(y=C(s),!y){console.log("THREE.SimplifyModifier: No next vertex");break}M(s,i,y,y.collapseNeighbor)}const V=new h,I=[],P=[],O=[],z=[],T=[];k=[];for(let e=0;e<s.length;e++){const t=s[e];I.push(t.position.x,t.position.y,t.position.z),t.uv&&P.push(t.uv.x,t.uv.y),t.normal&&O.push(t.normal.x,t.normal.y,t.normal.z),t.tangent&&z.push(t.tangent.x,t.tangent.y,t.tangent.z,t.tangent.w),t.color&&T.push(t.color.r,t.color.g,t.color.b),t.id=e}for(let e=0;e<i.length;e++){const t=i[e];k.push(t.v1.id,t.v2.id,t.v3.id)}return V.setAttribute("position",new f(I,3)),P.length>0&&V.setAttribute("uv",new f(P,2)),O.length>0&&V.setAttribute("normal",new f(O,3)),z.length>0&&V.setAttribute("tangent",new f(z,4)),T.length>0&&V.setAttribute("color",new f(T,3)),V.setIndex(k),V}}function w(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}function N(e,t){const n=t.position.distanceTo(e.position);let o=0;const s=[];for(let i=0,r=e.faces.length;i<r;i++){const n=e.faces[i];n.hasVertex(t)&&s.push(n)}for(let i=0,r=e.faces.length;i<r;i++){let t=1;const n=e.faces[i];for(let e=0;e<s.length;e++){const o=s[e],i=n.normal.dot(o.normal);t=Math.min(t,(1.001-i)/2)}o=Math.max(o,t)}s.length<2&&(o=1);return n*o+0}function x(e){if(0===e.neighbors.length)return e.collapseNeighbor=null,void(e.collapseCost=-.01);e.collapseCost=1e5,e.collapseNeighbor=null;for(let t=0;t<e.neighbors.length;t++){const n=N(e,e.neighbors[t]);e.collapseNeighbor||(e.collapseNeighbor=e.neighbors[t],e.collapseCost=n,e.minCost=n,e.totalCost=0,e.costCount=0),e.costCount++,e.totalCost+=n,n<e.minCost&&(e.collapseNeighbor=e.neighbors[t],e.minCost=n)}e.collapseCost=e.totalCost/e.costCount}function y(e,t){for(console.assert(0===e.faces.length);e.neighbors.length;){w(e.neighbors.pop().neighbors,e)}w(t,e)}function k(e,t){w(t,e),e.v1&&w(e.v1.faces,e),e.v2&&w(e.v2.faces,e),e.v3&&w(e.v3.faces,e);const n=[e.v1,e.v2,e.v3];for(let o=0;o<3;o++){const e=n[o],t=n[(o+1)%3];e&&t&&(e.removeIfNonNeighbor(t),t.removeIfNonNeighbor(e))}}function M(e,t,n,o){if(!o)return void y(n,e);o.uv&&n.uv.copy(o.uv),o.normal&&o.normal.add(n.normal).normalize(),o.tangent&&o.tangent.add(n.tangent).normalize();const s=[];for(let i=0;i<n.neighbors.length;i++)s.push(n.neighbors[i]);for(let i=n.faces.length-1;i>=0;i--)n.faces[i]&&n.faces[i].hasVertex(o)&&k(n.faces[i],t);for(let i=n.faces.length-1;i>=0;i--)n.faces[i].replaceVertex(n,o);y(n,e);for(let i=0;i<s.length;i++)x(s[i])}function C(e){let t=e[0];for(let n=0;n<e.length;n++)e[n].collapseCost<t.collapseCost&&(t=e[n]);return t}class _{constructor(e,t,n,o,s,i){this.a=o,this.b=s,this.c=i,this.v1=e,this.v2=t,this.v3=n,this.normal=new d,this.computeNormal(),e.faces.push(this),e.addUniqueNeighbor(t),e.addUniqueNeighbor(n),t.faces.push(this),t.addUniqueNeighbor(e),t.addUniqueNeighbor(n),n.faces.push(this),n.addUniqueNeighbor(e),n.addUniqueNeighbor(t)}computeNormal(){const e=this.v1.position,t=this.v2.position,n=this.v3.position;m.subVectors(n,t),v.subVectors(e,t),m.cross(v).normalize(),this.normal.copy(m)}hasVertex(e){return e===this.v1||e===this.v2||e===this.v3}replaceVertex(e,t){e===this.v1?this.v1=t:e===this.v2?this.v2=t:e===this.v3&&(this.v3=t),w(e.faces,this),t.faces.push(this),e.removeIfNonNeighbor(this.v1),this.v1.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v2),this.v2.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v3),this.v3.removeIfNonNeighbor(e),this.v1.addUniqueNeighbor(this.v2),this.v1.addUniqueNeighbor(this.v3),this.v2.addUniqueNeighbor(this.v1),this.v2.addUniqueNeighbor(this.v3),this.v3.addUniqueNeighbor(this.v1),this.v3.addUniqueNeighbor(this.v2),this.computeNormal()}}class B{constructor(e,t,n,o,s){this.position=e,this.uv=t,this.normal=n,this.tangent=o,this.color=s,this.id=-1,this.faces=[],this.neighbors=[],this.collapseCost=0,this.collapseNeighbor=null}addUniqueNeighbor(e){var t,n;t=this.neighbors,n=e,-1===t.indexOf(n)&&t.push(n)}removeIfNonNeighbor(e){const t=this.neighbors,n=this.faces,o=t.indexOf(e);if(-1!==o){for(let t=0;t<n.length;t++)if(n[t].hasVertex(e))return;t.splice(o,1)}}}const A=await t("three"),V=c({screenspace:!1,color:new A.Color("black"),opacity:1,thickness:.05,size:new A.Vector2},"\n   #include <common>\n   #include <morphtarget_pars_vertex>\n   #include <skinning_pars_vertex>\n   uniform float thickness;\n   uniform float screenspace;\n   uniform vec2 size;\n   void main() {\n     #if defined (USE_SKINNING)\n\t   #include <beginnormal_vertex>\n       #include <morphnormal_vertex>\n       #include <skinbase_vertex>\n       #include <skinnormal_vertex>\n       #include <defaultnormal_vertex>\n     #endif\n     #include <begin_vertex>\n\t   #include <morphtarget_vertex>\n\t   #include <skinning_vertex>\n     #include <project_vertex>\n     vec4 tNormal = vec4(normal, 0.0);\n     vec4 tPosition = vec4(transformed, 1.0);\n     #ifdef USE_INSTANCING\n       tNormal = instanceMatrix * tNormal;\n       tPosition = instanceMatrix * tPosition;\n     #endif\n     if (screenspace == 0.0) {\n       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;\n       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); \n     } else {\n       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;\n       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;\n       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;\n       clipPosition.xy += offset;\n       gl_Position = clipPosition;\n     }\n   }",`\n   uniform vec3 color;\n   uniform float opacity;\n   void main(){\n     gl_FragColor = vec4(color, opacity);\n     #include <tonemapping_fragment>\n     #include <${parseInt(A.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n   }`);const{defineComponent:I}=await t("vue"),{unref:P,openBlock:O,createElementBlock:z}=await t("vue"),T=["object"],U=await t("three"),{onMounted:j,watchEffect:q}=await t("vue"),S=I({__name:"outlineCom",props:{color:{default:"#ffffff"},thickness:{default:.1},screenspace:{type:Boolean,default:!1}},setup(e){const t=e,{renderer:o}=s(),i=function({color:e=new A.Color("black"),opacity:t=1,transparent:o=!1,screenspace:s=!1,toneMapped:i=!0,polygonOffset:r=!1,polygonOffsetFactor:a=0,renderOrder:l=0,thickness:c=.05,angle:h=Math.PI,gl:u}={}){const f=new A.Group;let p={color:e,opacity:t,transparent:o,screenspace:s,toneMapped:i,polygonOffset:r,polygonOffsetFactor:a,renderOrder:l,thickness:c,angle:h};function d(e){const t=f.parent;if(f.clear(),t&&t.geometry){let o;const s=new V({side:A.BackSide});t.skeleton?(o=new A.SkinnedMesh,o.material=s,o.bind(t.skeleton,t.bindMatrix),f.add(o)):t.isInstancedMesh?(o=new A.InstancedMesh(t.geometry,s,t.count),o.instanceMatrix=t.instanceMatrix,f.add(o)):(o=new A.Mesh,o.material=s,f.add(o)),o.geometry=e?n(t.geometry,e):t.geometry}}function g(e){p={...p,...e};const t=f.children[0];if(t){const{transparent:e,thickness:n,color:o,opacity:s,screenspace:i,toneMapped:r,polygonOffset:a,polygonOffsetFactor:l,renderOrder:c}=p,h=new A.Vector2;!u&&p.screenspace&&console.warn('Outlines: "screenspace" requires a WebGLRenderer instance to calculate the outline size'),u&&u.getSize(h),Object.assign(t.material,{transparent:e,thickness:n,color:o,opacity:s,size:h,screenspace:i,toneMapped:r,polygonOffset:a,polygonOffsetFactor:l}),void 0!==c&&(t.renderOrder=c)}}return{group:f,updateProps(e){var t;const n=null!==(t=e.angle)&&void 0!==t?t:p.angle;n!==p.angle&&d(n),g(e)},generate(){d(p.angle),g(p)}}}({color:new U.Color(t.color),thickness:t.thickness,screenspace:t.screenspace,gl:o});return j(()=>{i.generate()}),q(()=>{i.updateProps({color:new U.Color(t.color),thickness:t.thickness,screenspace:t.screenspace})}),(e,t)=>(O(),z("primitive",{object:P(i).group},null,8,T))}}),{defineComponent:E}=await t("vue"),{unref:G,createElementVNode:F,createVNode:R,openBlock:D,createElementBlock:L,createCommentVNode:X}=await t("vue"),K=["object"],W=["geometry"],{watch:H}=await t("vue"),$=await t("three"),J=E({__name:"outlineModel",props:{color:{default:"#ffffff"},thickness:{default:.1},screenspace:{type:Boolean,default:!1}},setup(e){const{state:t}=i("./plugins/basic/htmls/model/model.gltf",{draco:!0,decoderPath:"./draco/"});function n(e){const t=[];e.traverse(e=>{if(e.isMesh&&e.geometry.isBufferGeometry&&e.geometry.attributes.position.count<1e5){const n=e.geometry.clone(),o=new $.Matrix4;o.copy(e.matrixWorld),n.applyMatrix4(o),n.isBufferGeometry&&(Object.keys(n.attributes).forEach(e=>{"position"!==e&&n.deleteAttribute(e)}),t.push(function(e,t=.1){return(new b).modify(e,Math.floor(e.attributes.position.count*t))}(n,.1)))}});return o(t)}let s=null;return H(()=>t.value,e=>{e.scene&&(s=n(e.scene))}),(e,n)=>G(t)?(D(),L("primitive",{key:0,object:G(t)?.scene,scale:1,position:[3,-1,-3]},[F("TresMesh",{geometry:G(s)},[n[0]||(n[0]=F("TresMeshBasicMaterial",{color:"#000000",transparent:"",opacity:0},null,-1)),R(S,{thickness:e.thickness,screenspace:e.screenspace,color:e.color},null,8,["thickness","screenspace","color"])],8,W)],8,K)):X("",!0)}}),{defineComponent:Q}=await t("vue"),{createElementVNode:Y,unref:Z,normalizeProps:ee,guardReactiveProps:te,createVNode:ne,Suspense:oe,withCtx:se,openBlock:ie,createBlock:re,mergeProps:ae}=await t("vue"),le={position:[0,.9,0],name:"torus"},ce={position:[-2.5,.5,2.5],"receive-shadow":"","cast-shadow":"",name:"cube"},{ACESFilmicToneMapping:he}=await t("three"),{reactive:ue}=await t("vue"),fe=Q({__name:"outline",setup(e){const t=ue({alpha:!0,toneMapping:he,windowSize:!0,clearColor:"#000000"}),n=ue({enableDamping:!0,autoRotate:!1}),o=ue({color:"#ff00ae",thickness:.1,screenspace:!1}),s=new l;s.addBinding(o,"color",{label:"颜色"}),s.addBinding(o,"thickness",{label:"thickness",min:0,max:2,step:.01}),s.addBinding(o,"screenspace",{label:"space"});const i=ue({color:"#ffffff",thickness:.026,screenspace:!1});return s.addBinding(i,"color",{label:"模型边框颜色"}),s.addBinding(i,"thickness",{label:"模型边框粗细",min:0,max:.2,step:.001}),s.addBinding(i,"screenspace",{label:"模型边框类型"}),(e,s)=>(ie(),re(Z(r),ae(t,{"window-size":""}),{default:se(()=>[s[4]||(s[4]=Y("TresPerspectiveCamera",{position:[10,10,10],fov:45,near:1,far:1e3},null,-1)),ne(Z(a),ee(te(n)),null,16),s[5]||(s[5]=Y("TresAmbientLight",{intensity:.5},null,-1)),s[6]||(s[6]=Y("TresDirectionalLight",{position:[15,15,15],intensity:1},null,-1)),Y("TresMesh",le,[s[0]||(s[0]=Y("TresTorusKnotGeometry",{args:[1,.35,100,32]},null,-1)),s[1]||(s[1]=Y("TresMeshStandardMaterial",{color:"#ff33ff",roughness:.3,metalness:.5},null,-1)),ne(S,ee(te(o)),null,16)]),Y("TresMesh",ce,[s[2]||(s[2]=Y("TresCylinderGeometry",{args:[1.5,1.5,2]},null,-1)),s[3]||(s[3]=Y("TresMeshStandardMaterial",{color:3407871,roughness:0,metalness:0},null,-1)),ne(S)]),(ie(),re(oe,null,{default:se(()=>[ne(J,ee(te(i)),null,16)]),_:1}))]),_:1},16))}});export{fe as default};
