import{m as n,e,b as t,U as r,c as o}from"./@tresjs.dTM0HLnZ1735031078130.js";import{P as i}from"./tweakpane.yHWGBmom1735031078130.js";import{B as c,_ as a,W as l,m as s,t as u,p as f,s as p,k as v}from"./three.bc6MLGU_1735031078130.js";import{d as g,a6 as d,b as x,o as h,f as m,u as y,g as w,j as b,al as R,r as C,J as I,aj as _,ak as M}from"./@vue.-THQH3GC1735031078130.js";import"./@vueuse.COyzlgw71735031078130.js";var z="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";function D(n,e){const t=O();return(D=function(n,e){return t[n-=114]})(n,e)}const T=D;!function(n,e){const t=D,r=O();for(;;)try{if(754022===-parseInt(t(145))/1+-parseInt(t(154))/2+-parseInt(t(128))/3+-parseInt(t(123))/4*(-parseInt(t(134))/5)+parseInt(t(156))/6+-parseInt(t(138))/7*(-parseInt(t(136))/8)+parseInt(t(120))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){L(this,(function(){const n=D,e=new RegExp(n(151)),t=new RegExp(n(117),"i"),r=F(n(131));e.test(r+n(115))&&t[n(130)](r+"input")?F():r("0")}))()}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function O(){const n=["toString","trace","2905416YXMqfc","apply","test","init","bind","console","3989980pPfFIT","return (function() ","9356824fSJzos","value","7GYgqvi","setIndex","uniforms","debu","stateObject","error","info","282178RqPWMA","warn","BufferAttribute","table","counter","call","function *\\( *\\)","water","RawShaderMaterial","1252336kkRJNT","gger","327234ShpQEK","constructor","pool","chain","waterTexture","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","while (true) {}","exception","5478318lDXqHw","setAttribute","FrontSide","4oSsbMO","Mesh","length"];return(O=function(){return n})()}A(void 0,(function(){const n=D,e=function(){const n=D;let e;try{e=Function(n(135)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e.console=e[n(133)]||{},r=["log",n(146),n(144),n(143),n(119),n(148),n(127)];for(let o=0;o<r[n(125)];o++){const e=A[n(157)].prototype.bind(A),i=r[o],c=t[i]||e;e.__proto__=A[n(132)](A),e[n(126)]=c[n(126)].bind(c),t[i]=e}}))();const S=g({__name:T(114),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=T,o=t,i=new c,l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(121)]("position",new(a[r(147)])(l,3)),i[r(139)](new(a[r(147)])(s,1));const u=new(a[r(153)])({uniforms:{light:{value:o.light},tiles:{value:o.tiles},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:a[r(122)]}),f=new(a[r(124)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{((n,e)=>{const t=r;u[t(140)][t(152)][t(137)]=n,u[t(140)].causticTex[t(137)]=e,p[t(137)].render(f,v[t(137)])})(o[r(116)],o.causticsTexture)})),(n,e)=>null}});function F(n){function e(n){const t=D;if("string"==typeof n)return function(n){}[t(157)](t(118))[t(129)](t(149));1!==(""+n/n)[t(125)]||n%20==0?function(){return!0}[t(157)](t(141)+t(155))[t(150)]("action"):function(){return!1}[t(157)](t(141)+t(155))[t(129)](t(142)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const j=k;!function(n,e){const t=k,r=P();for(;;)try{if(805096===-parseInt(t(477))/1*(-parseInt(t(528))/2)+-parseInt(t(538))/3+parseInt(t(487))/4*(-parseInt(t(513))/5)+-parseInt(t(510))/6*(-parseInt(t(533))/7)+parseInt(t(532))/8+parseInt(t(539))/9*(-parseInt(t(526))/10)+parseInt(t(522))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const E=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[k(481)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){E(this,(function(){const n=k,e=new RegExp(n(498)),t=new RegExp(n(540),"i"),r=V(n(486));e[n(494)](r+n(506))&&t[n(494)](r+"input")?V():r("0")}))()}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[k(481)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function P(){const n=["pos-y.jpg","BackSide","action","toString","Mesh","test","string","causticsTexture","stateObject","function *\\( *\\)","light","table","setRenderTarget","length","side","value","debu","chain","prototype","log","return (function() ","4267086GQzIHH","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","FrontSide","145sSUUDX","warn","pos-x.jpg","white","underwater","gger","Color","CubeTextureLoader","counter","21531664eyhPha","setClearColor","geometry","call","10ZErfsF","tiles","8266ZsHQYo","water","bind","trace","7815272TvbgtB","7mAcUbg","waterTexture","console","neg-z.jpg","RawShaderMaterial","4454886ciirLU","11131146vFUvdS","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","pooRef","157oxdJyj","setPath","info","pos-z.jpg","apply","uniforms","__proto__","causticTex","neg-y.jpg","init","105868iLRouW","constructor"];return(P=function(){return n})()}function k(n,e){const t=P();return(k=function(n,e){return t[n-=476]})(n,e)}W(void 0,(function(){const n=k,e=function(){const n=k;let e;try{e=Function(n(509)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(535)]=e[n(535)]||{},r=[n(508),n(514),n(479),"error","exception",n(500),n(531)];for(let o=0;o<r[n(502)];o++){const e=W.constructor[n(507)][n(530)](W),i=r[o],c=t[i]||e;e[n(483)]=W[n(530)](W),e[n(492)]=c[n(492)][n(530)](c),t[i]=e}}))();const H=g({__name:j(529),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=j;let i,c;const l=r,s=l[o(524)],u=(new(a[o(520)]))[o(478)](o(511)).load([o(515),"neg-x.jpg",o(489),o(485),o(480),o(536)]),f=([i,c]=d((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,c(),i),p=new(a[o(537)])({uniforms:{light:{value:l[o(499)]},tiles:{value:f},sky:{value:u},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),v=new(a[o(493)])(s,p),g=x(null),w=new(a[o(519)])(o(516)),{renderer:b,camera:R}=n(),{onLoop:C}=e();return C((()=>{const n=o;b[n(504)][n(501)](null),b[n(504)][n(523)](w,1),b.value.clear(),p[n(482)].water.value=l[n(534)],p[n(482)][n(484)].value=l.causticsTexture,p[n(503)]=a[n(512)],p.uniforms[n(517)].value=!0,b[n(504)].render(v,R[n(504)]),p[n(503)]=a[n(490)],p[n(482)][n(517)].value=!1,b[n(504)].render(v,R[n(504)])})),(n,e)=>{const t=o;return h(),m(S,{tiles:y(f),light:n[t(499)],waterTexture:n[t(534)],causticsTexture:n[t(496)],ref_key:t(476),ref:g},null,8,[t(527),"light","waterTexture",t(496)])}}});function V(n){function e(n){const t=k;if(typeof n===t(495))return function(n){}[t(488)]("while (true) {}")[t(481)](t(521));1!==(""+n/n)[t(502)]||n%20==0?function(){return!0}[t(488)](t(505)+t(518))[t(525)](t(491)):function(){return!1}[t(488)](t(505)+t(518)).apply(t(497)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const B=q;!function(n,e){const t=q,r=X();for(;;)try{if(981569===parseInt(t(501))/1+parseInt(t(507))/2+-parseInt(t(529))/3+parseInt(t(502))/4+-parseInt(t(503))/5+-parseInt(t(504))/6+-parseInt(t(540))/7*(parseInt(t(524))/8))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const N=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(527)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){N(this,(function(){const n=q,e=new RegExp(n(532)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=U(n(530));e.test(r+n(539))&&t.test(r+n(512))?U():r("0")}))()}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(527)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function q(n,e){const t=X();return(q=function(n,e){return t[n-=500]})(n,e)}function X(){const n=["debu","chain","2989063AlSJrv","length","exception","causticsTexture","waterTexture","constructor","977715RYBBKf","6637804phmhFz","3900035ryzbsm","318936gXlcOL","texture","Mesh","1857714ZOdLqx","material","light","Color","PlaneGeometry","input","value",'{}.constructor("return this")( )',"geometry","uniforms","bind","water","call","gger","info","render","OrthographicCamera","16NRCJGd","console","__proto__","apply","caustics","2691819SLWOZy","init","action","function *\\( *\\)","string","clear","toString","counter","black"];return(X=function(){return n})()}Z(void 0,(function(){const n=q,e=function(){const n=q;let e;try{e=Function("return (function() "+n(514)+");")()}catch(t){e=window}return e}(),t=e[n(525)]=e.console||{},r=["log","warn",n(521),"error",n(542),"table","trace"];for(let o=0;o<r[n(541)];o++){const e=Z[n(500)].prototype[n(517)](Z),i=r[o],c=t[i]||e;e[n(526)]=Z[n(517)](Z),e[n(535)]=c[n(535)][n(517)](c),t[i]=e}}))();const $=g({__name:B(528),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=B,o=t,i=new(a[r(523)])(0,1,1,0,0,2e3),c=new(a[r(511)])(2,2,200,200),u=new l(1024,1024),f=new s({uniforms:{light:{value:o.light},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new(a[r(506)])(c,f),v=new(a[r(510)])(r(537)),{renderer:g}=n(),{onBeforeLoop:d}=e();return d((()=>{const n=r;p[n(508)][n(516)][n(518)][n(513)]=o[n(544)],g[n(513)].setRenderTarget(u),g[n(513)].setClearColor(v,0),g.value[n(534)](),g[n(513)][n(522)](p,i)})),(n,e)=>{const t=r;return h(),m(R,null,{default:w((()=>[b(H,{waterTexture:n[t(544)],causticsTexture:y(u)[t(505)],light:n.light,geometry:y(c)},null,8,[t(544),t(543),t(509),t(515)])])),_:1})}}});function U(n){function e(n){const t=q;if(typeof n===t(533))return function(n){}.constructor("while (true) {}").apply(t(536));1!==(""+n/n)[t(541)]||n%20==0?function(){return!0}[t(500)]("debu"+t(520))[t(519)](t(531)):function(){return!1}[t(500)](t(538)+"gger")[t(527)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const G=Q;!function(n,e){const t=Q,r=nn();for(;;)try{if(632410===-parseInt(t(388))/1+parseInt(t(372))/2*(parseInt(t(342))/3)+parseInt(t(380))/4*(-parseInt(t(382))/5)+-parseInt(t(412))/6+-parseInt(t(362))/7*(-parseInt(t(345))/8)+parseInt(t(395))/9*(-parseInt(t(393))/10)+parseInt(t(368))/11*(parseInt(t(343))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const J=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Q(354)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){J(this,(function(){const n=Q,e=new RegExp(n(353)),t=new RegExp(n(361),"i"),r=en(n(351));e[n(341)](r+n(416))&&t[n(341)](r+n(407))?en():r("0")}))()}();const Y=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Q(354)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Q(n,e){const t=nn();return(Q=function(n,e){return t[n-=341]})(n,e)}Y(void 0,(function(){const n=Q;let e;try{e=Function(n(344)+n(406)+");")()}catch(o){e=window}const t=e.console=e[n(356)]||{},r=[n(408),n(402),n(363),n(367),n(409),n(357),"trace"];for(let i=0;i<r.length;i++){const e=Y.constructor[n(396)].bind(Y),o=r[i],c=t[o]||e;e[n(360)]=Y[n(365)](Y),e[n(358)]=c.toString[n(365)](c),t[o]=e}}))();const K=g({__name:G(373),props:{light:{}},setup(t,{expose:r}){const o=G,i=new(a[o(364)])(0,1,1,0,0,2e3),c=new u(2,2),s=new l(256,256,{type:a[o(386)]}),g=new l(256,256,{type:f}),d=new(a[o(378)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),x=new(a[o(378)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),w=new(a[o(378)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),b=new(a[o(384)])(c,d),R=new p(c,x),C=new p(c,w);let I=s;const _=(n,e)=>{const t=o,r=I,c=I===s?g:s;e[t(376)][t(352)][t(359)][t(400)]=r[t(359)],n[t(371)](c),n[t(413)](e,i),I=c},{renderer:M,camera:D,raycaster:T}=n();M.value[o(410)]=!1;const{onBeforeLoop:L}=e();L((()=>{const n=o;var e,t;t=M[n(400)],_(t,C),e=M[n(400)],_(e,R)}));const A=(n,e,t,r)=>{const i=o;b[i(376)].uniforms[i(370)].value=[n,e],b.material[i(352)][i(394)][i(400)]=t,b[i(376)][i(352)][i(374)].value=r,_(M[i(400)],b)},O=new v,S=new u(2,2),F=S[o(347)][o(392)];for(let n=0;n<F.count;n++){const e=-F[o(346)](n);F[o(389)](n,0),F[o(401)](n,e)}F[o(355)]=!0;const j=new(a[o(384)])(S),E={handleEvent:n=>{const e=o,t=M[e(400)].domElement[e(375)](),r=t[e(349)],i=t[e(390)];O.x=2*(n[e(398)]-t.left)/r-1,O.y=2*-(n[e(348)]-t[e(405)])/i+1,T.value[e(387)](O,D[e(400)]);const c=T[e(400)][e(377)](j);for(let o of c)A(o[e(366)].x,o.point.z,.03,.04)}};return r({addDrop:A,mouseEvent:n=>{const e=o;n?M[e(400)].domElement.addEventListener("mousemove",E):M[e(400)][e(399)].removeEventListener(e(403),E)}}),(n,e)=>{const t=o;return h(),m($,{lightFrontGeometry:y(c),waterTexture:y(I)[t(359)],light:n.light},null,8,[t(415),t(350),t(404)])}}});function nn(){const n=["toString","texture","__proto__","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","7bPHkXT","info","OrthographicCamera","bind","point","error","4972FcurBX","action","center","setRenderTarget","6TLWdfi","waterSimulation","strength","getBoundingClientRect","material","intersectObject","RawShaderMaterial","stateObject","60604nlLCrO","gger","355wTRFYB","while (true) {}","Mesh","length","FloatType","setFromCamera","880810AWpiRp","setY","height","string","position","190pCMjXS","radius","476469HkgVyK","prototype","counter","clientX","domElement","value","setZ","warn","mousemove","light","top",'{}.constructor("return this")( )',"input","log","exception","autoClear","debu","4096044EDjscp","render","constructor","lightFrontGeometry","chain","test","522927xVSbGV","71076MNIavS","return (function() ","8618968AMXdJT","getY","attributes","clientY","width","waterTexture","init","uniforms","function *\\( *\\)","apply","needsUpdate","console","table"];return(nn=function(){return n})()}function en(n){function e(n){const t=Q;if(typeof n===t(391))return function(n){}[t(414)](t(383)).apply(t(397));1!==(""+n/n)[t(385)]||n%20==0?function(){return!0}[t(414)](t(411)+t(381)).call(t(369)):function(){return!1}.constructor(t(411)+t(381)).apply(t(379)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function tn(){const n=["90ANXbVt","addButton","string","随机增加波纹","value","mouseEvent","length","click","change","5965512mLSSfp","鼠标波纹","init","chain","bind","info","966162cBCfUS","2208544cpoQaO","prototype","while (true) {}","addDrop","4649325LeotJj","toString","854531tOLBjf","random","__proto__","manual","table","6kbMDOt","4283872eBFmNm","input","console","return (function() ","3008487wvyDqL","apply","test","constructor","gger","function *\\( *\\)","log","waterSimulationRef","TresPerspectiveCamera","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","counter","debu","warn"];return(tn=function(){return n})()}!function(n,e){const t=on,r=tn();for(;;)try{if(675288===-parseInt(t(194))/1+parseInt(t(187))/2+-parseInt(t(204))/3+parseInt(t(200))/4+parseInt(t(192))/5*(-parseInt(t(199))/6)+-parseInt(t(181))/7+parseInt(t(188))/8*(parseInt(t(217))/9))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(205)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function on(n,e){const t=tn();return(on=function(n,e){return t[n-=180]})(n,e)}!function(){rn(this,(function(){const n=on,e=new RegExp(n(209)),t=new RegExp(n(213),"i"),r=ln(n(183));e[n(206)](r+n(184))&&t.test(r+n(201))?ln():r("0")}))()}();const cn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();cn(void 0,(function(){const n=on,e=function(){const n=on;let e;try{e=Function(n(203)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(202)]=e.console||{},r=[n(210),n(216),n(186),"error","exception",n(198),"trace"];for(let o=0;o<r[n(223)];o++){const e=cn.constructor[n(189)][n(185)](cn),i=r[o],c=t[i]||e;e[n(196)]=cn.bind(cn),e.toString=c[n(193)][n(185)](c),t[i]=e}}))();const an=g({__name:"realWater",setup(n){const e=on,t=C({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(197)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=x(null),l=new i;l[e(218)]({label:"点击按钮",title:e(220)}).on(e(224),(()=>{const n=e;for(var t=0;t<10;t++)a[n(221)][n(191)](2*Math[n(195)]()-1,2*Math[n(195)]()-1,.03,1&t?.02:-.02)}));const s=x(!1);return l.addBinding(s,e(221),{label:e(182)}).on(e(180),(n=>{const t=e;a[t(221)][t(222)](n[t(221)])})),(n,i)=>{const l=e;return h(),m(y(o),_(M(t)),{default:w((()=>[i[0]||(i[0]=I(l(212),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),b(y(r)),b(K,{light:c,ref_key:l(211),ref:a},null,512)])),_:1},16)}}});function ln(n){function e(n){const t=on;if(typeof n===t(219))return function(n){}.constructor(t(190))[t(205)](t(214));1!==(""+n/n)[t(223)]||n%20==0?function(){return!0}[t(207)](t(215)+t(208)).call("action"):function(){return!1}[t(207)](t(215)+"gger").apply("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{an as default};
