import{m as n,e,a as t,o as r,f as o}from"./@tresjs.rE98Wm941741490461506.js";import{P as i}from"./tweakpane.yDiyAAkA1741490461506.js";import{_ as c,aW as a,C as l,y as s,O as u,W as f,r as p,s as v}from"./three.Vxh8Czkt1741490461506.js";import{d as g,a3 as d,b as x,o as h,f as m,u as y,g as w,j as b,al as I,r as C,N as R,aj as _,ak as M}from"./@vue.NRI7TcgI1741490461506.js";import"./postprocessing.wUw4_rsV1741490461506.js";import"./@vueuse.9Z-Ayxy41741490461506.js";var z="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const D=O;!function(n,e){const t=O,r=L();for(;;)try{if(702479===-parseInt(t(197))/1*(-parseInt(t(190))/2)+-parseInt(t(203))/3*(parseInt(t(206))/4)+-parseInt(t(204))/5+parseInt(t(168))/6*(parseInt(t(189))/7)+parseInt(t(201))/8*(parseInt(t(192))/9)+-parseInt(t(194))/10+-parseInt(t(171))/11*(-parseInt(t(210))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[O(193)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){T(this,(function(){const n=O,e=new RegExp(n(205)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=j(n(212));e[n(213)](r+n(176))&&t[n(213)](r+"input")?j():r("0")}))()}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[O(193)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function L(){const n=["Mesh","BufferGeometry","7051ByEnYm","FrontSide","return (function() ","value","info","chain","debu","position","log","render","pool","counter","exception","setAttribute","uniforms","light","__proto__","stateObject","4560941eCVbLh","2aMxjlU","bind","2215071cczBpN","apply","8526290UlPdAq","toString","trace","463371AzvOMS","constructor","waterTexture","string","8cZdOjy","prototype","6747bZeDXL","3455015sNzJbN","function *\\( *\\)","808yVxzZx","length","BufferAttribute","setIndex","12876BfTIkS","call","init","test","gger","console","12XEARJh"];return(L=function(){return n})()}A(void 0,(function(){const n=O;let e;try{e=Function(n(173)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e.console=e[n(167)]||{},r=[n(179),"warn",n(175),"error",n(183),"table",n(196)];for(let i=0;i<r[n(207)];i++){const e=A[n(198)][n(202)][n(191)](A),o=r[i],c=t[o]||e;e[n(187)]=A.bind(A),e[n(195)]=c[n(195)][n(191)](c),t[o]=e}}))();const E=g({__name:D(181),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=D,o=t,i=new(c[r(170)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(184)](r(178),new(c[r(208)])(l,3)),i[r(209)](new(c[r(208)])(s,1));const u=new a({uniforms:{light:{value:o[r(186)]},tiles:{value:o.tiles},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(172)]}),f=new(c[r(169)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{((n,e)=>{const t=r;u[t(185)].water[t(174)]=n,u[t(185)].causticTex[t(174)]=e,p[t(174)][t(180)](f,v[t(174)])})(o[r(199)],o.causticsTexture)})),(n,e)=>null}});function O(n,e){const t=L();return(O=function(n,e){return t[n-=167]})(n,e)}function j(n){function e(n){const t=O;if(typeof n===t(200))return function(n){}[t(198)]("while (true) {}").apply(t(182));1!==(""+n/n)[t(207)]||n%20==0?function(){return!0}[t(198)](t(177)+t(214))[t(211)]("action"):function(){return!1}[t(198)](t(177)+t(214)).apply(t(188)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=P,r=W();for(;;)try{if(971531===parseInt(t(452))/1+parseInt(t(477))/2*(parseInt(t(444))/3)+parseInt(t(466))/4*(parseInt(t(445))/5)+-parseInt(t(473))/6*(-parseInt(t(440))/7)+-parseInt(t(455))/8*(-parseInt(t(488))/9)+-parseInt(t(456))/10*(-parseInt(t(489))/11)+parseInt(t(482))/12*(-parseInt(t(476))/13))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(463)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){F(this,(function(){const n=P,e=new RegExp(n(454)),t=new RegExp(n(458),"i"),r=B(n(430));e[n(467)](r+n(478))&&t[n(467)](r+n(427))?B():r("0")}))()}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(463)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function P(n,e){const t=W();return(P=function(n,e){return t[n-=427]})(n,e)}function W(){const n=["12KaZgwX","setRenderTarget",'{}.constructor("return this")( )',"geometry","tiles","neg-x.jpg","1644174GWTICc","17765edtKIb","setClearColor","input","call","trace","init","Mesh","pooRef","render","white","__proto__","error","toString","RawShaderMaterial","gger","1001FyFqgd","waterTexture","action","debu","107931qsDUgm","3582935tQkZcl","console","warn","clear","counter","pos-z.jpg","stateObject","654836XYrnuQ","neg-y.jpg","function *\\( *\\)","40PTVZTO","2210BElxUs","pos-y.jpg","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","setPath","bind","BackSide","value","apply","return (function() ","uniforms","4vXnQBO","test","causticsTexture","constructor","CubeTextureLoader","table","neg-z.jpg","67722fnzwae","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","side","60468252MrHxNE","76XIhJZc","chain","light","causticTex","underwater"];return(W=function(){return n})()}S(void 0,(function(){const n=P;let e;try{e=Function(n(464)+n(484)+");")()}catch(o){e=window}const t=e[n(446)]=e[n(446)]||{},r=["log",n(447),"info",n(436),"exception",n(471),n(429)];for(let i=0;i<r.length;i++){const e=S[n(469)].prototype[n(460)](S),o=r[i],c=t[o]||e;e[n(435)]=S[n(460)](S),e[n(437)]=c[n(437)][n(460)](c),t[o]=e}}))();const V=g({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=P;let i,a;const u=r,f=u[o(485)],p=(new(c[o(470)]))[o(459)](o(474)).load(["pos-x.jpg",o(487),o(457),o(453),o(450),o(472)]),v=([i,a]=d((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),g=new(c[o(438)])({uniforms:{light:{value:u[o(479)]},tiles:{value:v},sky:{value:p},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),w=new(c[o(431)])(f,g),b=x(null),I=new l(o(434)),{renderer:C,camera:R}=n(),{onLoop:_}=e();return _((()=>{const n=o;C[n(462)][n(483)](null),C[n(462)][n(490)](I,1),C.value[n(448)](),g.uniforms.water[n(462)]=u.waterTexture,g.uniforms[n(480)].value=u[n(468)],g[n(475)]=s,g.uniforms[n(481)][n(462)]=!0,C.value[n(433)](w,R[n(462)]),g[n(475)]=c[n(461)],g[n(465)][n(481)][n(462)]=!1,C.value[n(433)](w,R[n(462)])})),(n,e)=>{const t=o;return h(),m(E,{tiles:y(v),light:n[t(479)],waterTexture:n[t(441)],causticsTexture:n[t(468)],ref_key:t(432),ref:b},null,8,[t(486),t(479),t(441),t(468)])}}});function B(n){function e(n){const t=P;if("string"==typeof n)return function(n){}[t(469)]("while (true) {}").apply(t(449));1!==(""+n/n).length||n%20==0?function(){return!0}[t(469)](t(443)+t(439))[t(428)](t(442)):function(){return!1}[t(469)]("debu"+t(439))[t(463)](t(451)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const k=X;function Z(){const n=["5KdjBBE","9LYsIuP","while (true) {}","prototype","info","clear","uniforms","debu","light","PlaneGeometry","value","569284uMdONh","black","caustics","setRenderTarget","819078DsUWos","counter","warn","stateObject","call","828130NMBcSE","input","string","apply","9852VSCvqy",'{}.constructor("return this")( )',"table","1253bHSWXV","texture","chain","return (function() ","ShaderMaterial","setClearColor","test","gger","function *\\( *\\)","bind","42AumpAP","5646993qtgUZj","length","render","__proto__","exception","Color","357247lxXOKf","trace","log","11288gUwTVu","constructor","Mesh","waterTexture","toString","geometry","error"];return(Z=function(){return n})()}!function(n,e){const t=X,r=Z();for(;;)try{if(251100===-parseInt(t(398))/1+-parseInt(t(432))/2*(parseInt(t(391))/3)+-parseInt(t(419))/4+-parseInt(t(408))/5*(-parseInt(t(423))/6)+-parseInt(t(435))/7*(-parseInt(t(401))/8)+-parseInt(t(409))/9*(parseInt(t(428))/10)+parseInt(t(392))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const H=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[X(431)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){H(this,(function(){const n=X,e=new RegExp(n(389)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=Y("init");e[n(441)](r+n(437))&&t[n(441)](r+n(429))?Y():r("0")}))()}();const N=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[X(431)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function X(n,e){const t=Z();return(X=function(n,e){return t[n-=388]})(n,e)}N(void 0,(function(){const n=X;let e;try{e=Function(n(438)+n(433)+");")()}catch(o){e=window}const t=e.console=e.console||{},r=[n(400),n(425),n(412),n(407),n(396),n(434),n(399)];for(let i=0;i<r[n(393)];i++){const e=N.constructor[n(411)].bind(N),o=r[i],c=t[o]||e;e[n(395)]=N[n(390)](N),e[n(405)]=c.toString.bind(c),t[o]=e}}))();const U=g({__name:k(421),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=k,o=t,i=new u(0,1,1,0,0,2e3),a=new(c[r(417)])(2,2,200,200),l=new f(1024,1024),s=new(c[r(439)])({uniforms:{light:{value:o.light},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new(c[r(403)])(a,s),v=new(c[r(397)])(r(420)),{renderer:g}=n(),{onBeforeLoop:d}=e();return d((()=>{const n=r;p.material[n(414)].water[n(418)]=o[n(404)],g[n(418)][n(422)](l),g[n(418)][n(440)](v,0),g.value[n(413)](),g[n(418)][n(394)](p,i)})),(n,e)=>{const t=r;return h(),m(I,null,{default:w((()=>[b(V,{waterTexture:n[t(404)],causticsTexture:y(l)[t(436)],light:n[t(416)],geometry:y(a)},null,8,[t(404),"causticsTexture",t(416),t(406)])])),_:1})}}});function Y(n){function e(n){const t=X;if(typeof n===t(430))return function(n){}[t(402)](t(410))[t(431)](t(424));1!==(""+n/n)[t(393)]||n%20==0?function(){return!0}[t(402)](t(415)+"gger")[t(427)]("action"):function(){return!1}[t(402)](t(415)+t(388)).apply(t(426)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const $=K;!function(n,e){const t=K,r=nn();for(;;)try{if(647154===parseInt(t(185))/1+parseInt(t(174))/2+-parseInt(t(150))/3*(parseInt(t(124))/4)+parseInt(t(177))/5+-parseInt(t(139))/6+-parseInt(t(123))/7*(-parseInt(t(126))/8)+-parseInt(t(176))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[K(151)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){q(this,(function(){const n=K,e=new RegExp(n(144)),t=new RegExp(n(137),"i"),r=Q(n(163));e.test(r+n(142))&&t[n(179)](r+n(113))?Q():r("0")}))()}();const G=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[K(151)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function K(n,e){const t=nn();return(K=function(n,e){return t[n-=113]})(n,e)}G(void 0,(function(){const n=K,e=function(){const n=K;let e;try{e=Function(n(131)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(152)]=e[n(152)]||{},r=[n(158),"warn",n(153),n(156),n(171),n(157),n(175)];for(let o=0;o<r[n(149)];o++){const e=G[n(141)][n(140)][n(134)](G),i=r[o],c=t[i]||e;e[n(183)]=G[n(134)](G),e[n(127)]=c[n(127)][n(134)](c),t[i]=e}}))();const J=g({__name:$(167),props:{light:{}},setup(t,{expose:r}){const o=$,i=new(c[o(125)])(0,1,1,0,0,2e3),l=new(c[o(132)])(2,2),s=new(c[o(184)])(256,256,{type:c[o(168)]}),u=new(c[o(184)])(256,256,{type:c[o(168)]}),f=new(c[o(116)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),g=new a({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),d=new(c[o(116)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),x=new(c[o(115)])(l,f),w=new p(l,g),b=new(c[o(115)])(l,d);let I=s;const C=(n,e)=>{const t=o,r=I,c=I===s?u:s;e.material[t(114)][t(172)][t(143)]=r[t(172)],n.setRenderTarget(c),n.render(e,i),I=c},{renderer:R,camera:_,raycaster:M}=n();R[o(143)][o(160)]=!1;const{onBeforeLoop:D}=e();D((()=>{const n=o;var e,t;t=R[n(143)],C(t,b),e=R[n(143)],C(e,w)}));const T=(n,e,t,r)=>{const i=o;x[i(147)][i(114)][i(136)].value=[n,e],x[i(147)][i(114)][i(133)][i(143)]=t,x[i(147)][i(114)].strength[i(143)]=r,C(R[i(143)],x)},A=new(c[o(120)]),L=new v(2,2),E=L[o(129)][o(122)];for(let n=0;n<E[o(117)];n++){const e=-E[o(162)](n);E[o(169)](n,0),E[o(154)](n,e)}E[o(146)]=!0;const O=new(c[o(115)])(L),j={handleEvent:n=>{const e=o,t=R[e(143)][e(135)][e(182)](),r=t[e(148)],i=t[e(145)];A.x=2*(n[e(178)]-t[e(161)])/r-1,A.y=2*-(n[e(165)]-t[e(164)])/i+1,M[e(143)][e(130)](A,_.value);const c=M.value[e(138)](O);for(let o of c)T(o.point.x,o[e(118)].z,.03,.04)}};return r({addDrop:T,mouseEvent:n=>{const e=o;n?R[e(143)][e(135)][e(180)](e(119),j):R[e(143)].domElement.removeEventListener(e(119),j)}}),(n,e)=>{const t=o;return h(),m(U,{lightFrontGeometry:y(l),waterTexture:y(I)[t(172)],light:n.light},null,8,["lightFrontGeometry","waterTexture",t(121)])}}});function Q(n){function e(n){const t=K;if("string"==typeof n)return function(n){}[t(141)](t(170))[t(151)](t(173));1!==(""+n/n)[t(149)]||n%20==0?function(){return!0}[t(141)](t(128)+"gger")[t(155)](t(181)):function(){return!1}[t(141)](t(128)+t(166))[t(151)](t(159)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function nn(){const n=["setFromCamera","return (function() ","PlaneGeometry","radius","bind","domElement","center","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","intersectObject","7263168vHLiYC","prototype","constructor","chain","value","function *\\( *\\)","height","needsUpdate","material","width","length","51qsPIoY","apply","console","info","setZ","call","error","table","log","stateObject","autoClear","left","getY","init","top","clientY","gger","waterSimulation","FloatType","setY","while (true) {}","exception","texture","counter","1110794kgyUYe","trace","13011246ZjIRCX","4941560TKEPvE","clientX","test","addEventListener","action","getBoundingClientRect","__proto__","WebGLRenderTarget","955807haaAWe","input","uniforms","Mesh","RawShaderMaterial","count","point","mousemove","Vector2","light","position","8172311bsBlTs","85556FEREtT","OrthographicCamera","8mJNFSs","toString","debu","attributes"];return(nn=function(){return n})()}const en=on;!function(n,e){const t=on,r=cn();for(;;)try{if(950594===parseInt(t(127))/1+parseInt(t(160))/2*(-parseInt(t(149))/3)+-parseInt(t(131))/4*(-parseInt(t(155))/5)+-parseInt(t(167))/6+parseInt(t(148))/7+-parseInt(t(163))/8*(-parseInt(t(132))/9)+-parseInt(t(138))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const tn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){tn(this,(function(){const n=on,e=new RegExp(n(145)),t=new RegExp(n(140),"i"),r=ln(n(164));e[n(146)](r+n(130))&&t[n(146)](r+n(161))?ln():r("0")}))()}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function on(n,e){const t=cn();return(on=function(n,e){return t[n-=126]})(n,e)}function cn(){const n=["2bggEfC","input","value","5848MwwwkM","init","constructor","bind","524028dPMWbX","log","__proto__","manual","点击按钮","227122xiiQyR","length","mouseEvent","chain","159244YeNPjE","13113PnBSYz","TresPerspectiveCamera","change","stateObject","action","waterSimulationRef","6798300KMMuJo","addBinding","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","table","warn","return (function() ","random","function *\\( *\\)","test","console","4238143gRUEMB","2092257XpaHGB","gger","trace","鼠标波纹","realWater","toString","65uRTQpB","debu","counter","click","apply"];return(cn=function(){return n})()}rn(void 0,(function(){const n=on;let e;try{e=Function(n(143)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(147)]=e[n(147)]||{},r=[n(168),n(142),"info","error","exception",n(141),n(151)];for(let i=0;i<r[n(128)];i++){const e=rn.constructor.prototype[n(166)](rn),o=r[i],c=t[o]||e;e[n(169)]=rn[n(166)](rn),e[n(154)]=c[n(154)][n(166)](c),t[o]=e}}))();const an=g({__name:en(153),setup(n){const e=en,t=C({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(170)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=x(null),l=new i;l.addButton({label:e(126),title:"随机增加波纹"}).on(e(158),(()=>{const n=e;for(var t=0;t<10;t++)a.value.addDrop(2*Math[n(144)]()-1,2*Math.random()-1,.03,1&t?.02:-.02)}));const s=x(!1);return l[e(139)](s,e(162),{label:e(152)}).on(e(134),(n=>{const t=e;a[t(162)][t(129)](n[t(162)])})),(n,i)=>{const l=e;return h(),m(y(o),_(M(t)),{default:w((()=>[i[0]||(i[0]=R(l(133),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),b(y(r)),b(J,{light:c,ref_key:l(137),ref:a},null,512)])),_:1},16)}}});function ln(n){function e(n){const t=on;if("string"==typeof n)return function(n){}[t(165)]("while (true) {}")[t(159)](t(157));1!==(""+n/n)[t(128)]||n%20==0?function(){return!0}[t(165)]("debu"+t(150)).call(t(136)):function(){return!1}[t(165)](t(156)+t(150))[t(159)](t(135)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{an as default};
