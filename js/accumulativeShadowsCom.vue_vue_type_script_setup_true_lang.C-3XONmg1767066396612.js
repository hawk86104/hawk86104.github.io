import{i as a}from"./3d-tiles-renderer.CbgZh8zU1767066396612.js";import{F as e}from"./@tresjs.B1f7s3pS1767066396612.js";import{S as t,P as o}from"./@pmndrs.Dko8Ps5C1767066396612.js";const{defineComponent:s}=await a("vue"),{createElementVNode:i,normalizeProps:r,guardReactiveProps:n,openBlock:l,createElementBlock:d}=await a("vue"),h=["rotate-x"],c=await a("three"),{ref:p,watch:m,watchEffect:u,toRaw:f}=await a("vue"),w=s({__name:"accumulativeShadowsCom",props:{opacity:{default:.8},alphaTest:{default:.9},color:{default:"#000000"},blend:{default:2},lightPosition:{default:{x:3,y:5,z:3}},frames:{default:60},blendWindow:{default:100},ambient:{default:.5}},setup(a){const s=a;let w=p();const{extend:M,scene:g,renderer:v,camera:b}=e();M({SoftShadowMaterial:t});const S={position:(new c.Vector3).set(s.lightPosition.x,s.lightPosition.y,s.lightPosition.z),radius:1,amount:8,intensity:Math.PI,bias:.001,mapSize:1024,size:8,near:.5,far:200},P=new o(v,g.value,S.mapSize),y={map:P.progressiveLightMap2.texture,transparent:!0,depthWrite:!1,toneMapped:!0,blend:s.blend,alphaTest:s.alphaTest,opacity:s.opacity,color:s.color},z=new c.Group;for(let e=0;e<S.amount;e++){const a=new c.DirectionalLight(16777215,S.intensity/S.amount);a.castShadow=!0,a.shadow.bias=S.bias,a.shadow.camera.near=S.near,a.shadow.camera.far=S.far,a.shadow.camera.right=S.size/2,a.shadow.camera.left=-4,a.shadow.camera.top=S.size/2,a.shadow.camera.bottom=-4,a.shadow.mapSize.width=S.mapSize,a.shadow.mapSize.height=S.mapSize,z.add(a)}const x=()=>{const a=S.position.length();for(let e=0;e<z.children.length;e++){const t=z.children[e];if(Math.random()>s.ambient)t.position.set(S.position.x+c.MathUtils.randFloatSpread(S.radius),S.position.y+c.MathUtils.randFloatSpread(S.radius),S.position.z+c.MathUtils.randFloatSpread(S.radius));else{let e=Math.acos(2*Math.random()-1)-Math.PI/2,o=2*Math.PI*Math.random();t.position.set(Math.cos(e)*Math.cos(o)*a,Math.abs(Math.cos(e)*Math.sin(o)*a),Math.sin(e)*a)}}},T=(a=1)=>{g.value.add(z),P.prepare();for(let e=0;e<a;e++)x(),P.update(b.value,s.blendWindow),console.log("shadows plm update",e);g.value.remove(z),P.finish()};m(()=>w.value,a=>{a&&(P.configure(f(a)),P.clear(),console.log("shadows render start"),T(s.frames),console.log("shadows render end"))});const j=()=>{P.clear(),T(s.frames)};return u(()=>{w.value&&(s.opacity&&(w.value.material.opacity=s.opacity),s.alphaTest&&(w.value.material.alphaTest=s.alphaTest),s.color&&w.value.material.color.set(s.color),s.blend&&(w.value.material.blend=s.blend))}),m(()=>s.lightPosition,a=>{a&&(console.log(s.lightPosition),S.position.set(a.x,a.y,a.z),j())},{deep:!0}),m(()=>[s.frames,s.blendWindow,s.ambient],()=>{j()}),(a,e)=>(l(),d("TresMesh",{"receive-shadow":"",ref_key:"gPlane",ref:w,scale:10,"rotate-x":-Math.PI/2},[e[0]||(e[0]=i("TresPlaneGeometry",{args:[1,1]},null,-1)),i("TresSoftShadowMaterial",r(n(y)),null,16)],8,h))}});export{w as _};
