import{importShared as e}from"./3d-tiles-renderer.CvhCoabY1768360010900.js";import{useTres as t,useLoop as a,useTextures as n,useGLTF as o,useAnimations as r,useTexture as i,useTresContext as l}from"./index.CsTVQ09Z1768360010900.js";import{useFBO as s,useTexture as c}from"./customShaderMaterial.vue_vue_type_script_setup_true_lang.DRa1gKCP1768360010900.js";import"./index.vue_vue_type_script_setup_true_lang.Bmv2kfnV1768360010900.js";import{instance as p}from"./Resource.DY5WJYsh1768360010900.js";import{gsapWithCSS as u}from"./index.a0YeKcgi1768360010900.js";import{EffectComposer as m,RenderPass as d,ShaderPass as v}from"./RenderPass.CD9rkIUE1768360010900.js";import{UnrealBloomPass as f}from"./UnrealBloomPass.DC7Tu3CB1768360010900.js";import{BatchedRenderer as h,QuarksLoader as w,ConstantValue as g,ConstantColor as x}from"./three.quarks.esm.BhAdFLVs1768360010900.js";var y=Object.defineProperty,S=(e,t,a)=>(((e,t,a)=>{t in e?y(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a})(e,"symbol"!=typeof t?t+"":t,a),a);const{OrthographicCamera:M,PlaneGeometry:P,Mesh:_}=await e("three");class b{constructor(e){S(this,"camera",new M(-1,1,1,-1,0,1)),S(this,"geometry",new P(2,2)),S(this,"mesh"),this.mesh=new _(this.geometry,e)}get material(){return this.mesh.material}set material(e){this.mesh.material=e}dispose(){this.mesh.geometry.dispose()}render(e){e.render(this.mesh,this.camera)}}const z={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  ",fragmentShader:"\n    uniform float opacity;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 texel = texture2D( tDiffuse, vUv );\n    \tgl_FragColor = opacity * texel;\n\n    }\n  "},{BackSide:T,BoxGeometry:C,InstancedMesh:E,Mesh:k,MeshLambertMaterial:R,MeshStandardMaterial:A,PointLight:L,Scene:V,Object3D:W}=await e("three");class U extends V{constructor(){super();const e=new C;e.deleteAttribute("uv");const t=new A({side:T}),a=new A,n=new L(16777215,900,28,2);n.position.set(.418,16.199,.3),this.add(n);const o=new k(e,t);o.position.set(-.757,13.219,.717),o.scale.set(31.713,28.305,28.591),this.add(o);const r=new E(e,a,6),i=new W;i.position.set(-10.906,2.009,1.846),i.rotation.set(0,-.195,0),i.scale.set(2.328,7.905,4.651),i.updateMatrix(),r.setMatrixAt(0,i.matrix),i.position.set(-5.607,-.754,-.758),i.rotation.set(0,.994,0),i.scale.set(1.97,1.534,3.955),i.updateMatrix(),r.setMatrixAt(1,i.matrix),i.position.set(6.167,.857,7.803),i.rotation.set(0,.561,0),i.scale.set(3.927,6.285,3.687),i.updateMatrix(),r.setMatrixAt(2,i.matrix),i.position.set(-2.017,.018,6.124),i.rotation.set(0,.333,0),i.scale.set(2.002,4.566,2.064),i.updateMatrix(),r.setMatrixAt(3,i.matrix),i.position.set(2.291,-.756,-2.621),i.rotation.set(0,-.286,0),i.scale.set(1.546,1.552,1.496),i.updateMatrix(),r.setMatrixAt(4,i.matrix),i.position.set(-2.193,-.369,-5.547),i.rotation.set(0,.516,0),i.scale.set(3.875,3.487,2.986),i.updateMatrix(),r.setMatrixAt(5,i.matrix),this.add(r);const l=new k(e,D(50));l.position.set(-16.116,14.37,8.208),l.scale.set(.1,2.428,2.739),this.add(l);const s=new k(e,D(50));s.position.set(-16.109,18.021,-8.207),s.scale.set(.1,2.425,2.751),this.add(s);const c=new k(e,D(17));c.position.set(14.904,12.198,-1.832),c.scale.set(.15,4.265,6.331),this.add(c);const p=new k(e,D(43));p.position.set(-.462,8.89,14.52),p.scale.set(4.38,5.441,.088),this.add(p);const u=new k(e,D(20));u.position.set(3.235,11.486,-12.541),u.scale.set(2.5,2,.1),this.add(u);const m=new k(e,D(100));m.position.set(0,20,0),m.scale.set(1,.1,1),this.add(m)}dispose(){const e=new Set;this.traverse(t=>{t.isMesh&&(e.add(t.geometry),e.add(t.material))});for(const t of e)t.dispose()}}function D(e){return new R({color:0,emissive:16777215,emissiveIntensity:e})}const{UniformsUtils:B,Vector2:I}=await e("three");function j(e){const t={...e};return"defines"in e&&(t.defines={...e.defines}),"uniforms"in e&&(t.uniforms=B.clone(e.uniforms)),t}const O={defines:{X_IS_EVEN:1,Y_IS_EVEN:1},uniforms:{map:{value:null},originalMapSize:{value:new I},parentMapSize:{value:new I},parentLevel:{value:0}},vertexShader:"\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\n\t\t\t#include <begin_vertex>\n\t\t\t#include <project_vertex>\n\t\t\tvUv = uv;\n\n\t\t}\n\t",fragmentShader:'\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D map;\n\t\tuniform int parentLevel;\n\t\tuniform vec2 parentMapSize;\n\t\tuniform vec2 originalMapSize;\n\n\t\t\n\n\t// Without original size argument for power of two targets\n\tvec4 packedTexture2DLOD( sampler2D tex, vec2 uv, int level ) {\n\n\t\t// the fraction of the uv space used by the target mip\n\t\tfloat targetSubview = 1.0 / pow( 2.0, float( level ) );\n\t\tfloat widthRatio = 2.0 / 3.0;\n\t\tvec2 scaledDimensions = vec2( targetSubview * widthRatio, targetSubview );\n\n\t\t// all levels > 0 are on the right third of the texture\n\t\t// y is offset from the bottom\n\t\tvec2 offset = vec2(\n\t\t\tlevel > 0 ? widthRatio : 0.0,\n\t\t\tlevel > 0 ? targetSubview : 0.0\n\t\t);\n\n\t\tvec2 samplePoint = mix( offset, offset + scaledDimensions, uv );\n\t\treturn texture2D( tex, samplePoint );\n\n\t}\n\n\tvec4 packedTexture2DLOD( sampler2D tex, vec2 uv, float level ) {\n\n\t\tfloat ratio = mod( level, 1.0 );\n\t\tint minLevel = int( floor( level ) );\n\t\tint maxLevel = int( ceil( level ) );\n\n\t\tvec4 minValue = packedTexture2DLOD( tex, uv, minLevel );\n\t\tvec4 maxValue = packedTexture2DLOD( tex, uv, maxLevel );\n\n\t\treturn mix( minValue, maxValue, ratio );\n\n\t}\n\n\t// With original size argument\n\tvec4 packedTexture2DLOD( sampler2D tex, vec2 uv, int level, vec2 originalPixelSize ) {\n\n\t\tfloat floatLevel = float( level );\n\t\tvec2 atlasSize;\n\t\tatlasSize.x = floor( originalPixelSize.x * 1.5 );\n\t\tatlasSize.y = originalPixelSize.y;\n\n\t\t// we stop making mip maps when one dimension == 1\n\t\tfloat maxLevel = min( floor( log2( originalPixelSize.x ) ), floor( log2( originalPixelSize.y ) ) );\n\t\tfloatLevel = min( floatLevel, maxLevel );\n\n\t\t// use inverse pow of 2 to simulate right bit shift operator\n\t\tvec2 currentPixelDimensions = floor( originalPixelSize / pow( 2.0, floatLevel ) );\n\t\tvec2 pixelOffset = vec2(\n\t\t\tfloatLevel > 0.0 ? originalPixelSize.x : 0.0,\n\t\t\tfloatLevel > 0.0 ? currentPixelDimensions.y : 0.0\n\t\t);\n\n\t\t// "minPixel / atlasSize" samples the top left piece of the first pixel\n\t\t// "maxPixel / atlasSize" samples the bottom right piece of the last pixel\n\t\tvec2 minPixel = pixelOffset;\n\t\tvec2 maxPixel = pixelOffset + currentPixelDimensions;\n\t\tvec2 samplePoint = mix( minPixel, maxPixel, uv );\n\t\tsamplePoint /= atlasSize;\n\n\t\tvec2 halfPixelSize = 1.0 / ( 2.0 * atlasSize );\n\t\tsamplePoint = min( samplePoint, maxPixel / atlasSize - halfPixelSize );\n\t\tsamplePoint = max( samplePoint, minPixel / atlasSize + halfPixelSize );\n\n\t\treturn texture2D( tex, samplePoint );\n\n\t}\n\n\tvec4 packedTexture2DLOD( sampler2D tex, vec2 uv, float level, vec2 originalPixelSize ) {\n\n\t\tfloat ratio = mod( level, 1.0 );\n\t\tint minLevel = int( floor( level ) );\n\t\tint maxLevel = int( ceil( level ) );\n\n\t\tvec4 minValue = packedTexture2DLOD( tex, uv, minLevel, originalPixelSize );\n\t\tvec4 maxValue = packedTexture2DLOD( tex, uv, maxLevel, originalPixelSize );\n\n\t\treturn mix( minValue, maxValue, ratio );\n\n\t}\n\n\n\n\t\t#if X_IS_EVEN && Y_IS_EVEN\n\n\t\t#define SAMPLES 4\n\t\t#define WIDTH 2\n\t\t#define HEIGHT 2\n\n\t\t#elif X_IS_EVEN\n\n\t\t#define SAMPLES 6\n\t\t#define WIDTH 2\n\t\t#define HEIGHT 3\n\n\t\t#elif Y_IS_EVEN\n\n\t\t#define SAMPLES 6\n\t\t#define WIDTH 3\n\t\t#define HEIGHT 2\n\n\t\t#else\n\n\t\t#define SAMPLES 9\n\t\t#define WIDTH 3\n\t\t#define HEIGHT 3\n\n\t\t#endif\n\n\t\tvec4 sampleAt( vec2 uv ) {\n\n\t\t\treturn packedTexture2DLOD( map, uv, parentLevel, originalMapSize );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec2 childMapSize = parentMapSize / 2.0;\n\t\t\t// vec2 childPixelSize = 1.0 / childMapSize;\n\t\t\t// vec2 halfChildPixelSize = childPixelSize / 2.0;\n\t\t\tvec2 childPixelPos = floor( vUv * childMapSize );\n\n\t\t\tvec2 parentPixelSize = 1.0 / parentMapSize;\n\t\t\tvec2 halfParentPixelSize = parentPixelSize / 2.0;\n\t\t\tvec2 parentPixelPos = childPixelPos * 2.0;\n\n\t\t\tvec2 baseUv = ( parentPixelPos / parentMapSize ) + halfParentPixelSize;\n\n\t\t\tvec4 samples[ SAMPLES ];\n\t\t\tfloat weights[ SAMPLES ];\n\n\t\t\t#if X_IS_EVEN && Y_IS_EVEN\n\n\t\t\tsamples[ 0 ] = sampleAt( baseUv );\n\t\t\tsamples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );\n\t\t\tsamples[ 2 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );\n\t\t\tsamples[ 3 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );\n\n\t\t\tweights[ 0 ] = 0.25;\n\t\t\tweights[ 1 ] = 0.25;\n\t\t\tweights[ 2 ] = 0.25;\n\t\t\tweights[ 3 ] = 0.25;\n\n\t\t\t#elif X_IS_EVEN\n\n\t\t\tfloat wx0 = 0.5;\n\t\t\tfloat wx1 = 0.5;\n\n\t\t\tfloat yden = 2.0 * parentMapSize.y + 1.0;\n\t\t\tfloat wy0 = ( parentMapSize.y - parentPixelPos.y ) / yden;\n\t\t\tfloat wy1 = ( parentMapSize.y ) / yden;\n\t\t\tfloat wy2 = ( parentPixelPos.y + 1.0 ) / yden;\n\n\t\t\tsamples[ 0 ] = sampleAt( baseUv );\n\t\t\tsamples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );\n\n\t\t\tsamples[ 2 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );\n\t\t\tsamples[ 3 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );\n\n\t\t\tsamples[ 4 ] = sampleAt( baseUv + vec2( 0.0, 2.0 * parentPixelSize.y ) );\n\t\t\tsamples[ 5 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 2.0 * parentPixelSize.y ) );\n\n\t\t\tweights[ 0 ] = wx0 * wy0;\n\t\t\tweights[ 1 ] = wx1 * wy0;\n\n\t\t\tweights[ 2 ] = wx0 * wy1;\n\t\t\tweights[ 3 ] = wx1 * wy1;\n\n\t\t\tweights[ 4 ] = wx0 * wy2;\n\t\t\tweights[ 5 ] = wx1 * wy2;\n\n\t\t\t#elif Y_IS_EVEN\n\n\t\t\tfloat xden = 2.0 * parentMapSize.x + 1.0;\n\t\t\tfloat wx0 = ( parentMapSize.x - parentPixelPos.x ) / xden;\n\t\t\tfloat wx1 = ( parentMapSize.x ) / xden;\n\t\t\tfloat wx2 = ( parentPixelPos.x + 1.0 ) / xden;\n\n\t\t\tfloat wy0 = 0.5;\n\t\t\tfloat wy1 = 0.5;\n\n\t\t\tsamples[ 0 ] = sampleAt( baseUv );\n\t\t\tsamples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );\n\t\t\tsamples[ 2 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 0.0 ) );\n\n\t\t\tsamples[ 3 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );\n\t\t\tsamples[ 4 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );\n\t\t\tsamples[ 5 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, parentPixelSize.y ) );\n\n\t\t\tweights[ 0 ] = wx0 * wy0;\n\t\t\tweights[ 1 ] = wx1 * wy0;\n\t\t\tweights[ 2 ] = wx2 * wy0;\n\n\t\t\tweights[ 3 ] = wx0 * wy1;\n\t\t\tweights[ 4 ] = wx1 * wy1;\n\t\t\tweights[ 5 ] = wx2 * wy1;\n\n\t\t\t#else\n\n\t\t\tfloat xden = 2.0 * parentMapSize.x + 1.0;\n\t\t\tfloat wx0 = ( parentMapSize.x - parentPixelPos.x ) / xden;\n\t\t\tfloat wx1 = ( parentMapSize.x ) / xden;\n\t\t\tfloat wx2 = ( parentPixelPos.x + 1.0 ) / xden;\n\n\t\t\tfloat yden = 2.0 * parentMapSize.y + 1.0;\n\t\t\tfloat wy0 = ( parentMapSize.y - parentPixelPos.y ) / yden;\n\t\t\tfloat wy1 = ( parentMapSize.y ) / yden;\n\t\t\tfloat wy2 = ( parentPixelPos.y + 1.0 ) / yden;\n\n\t\t\tsamples[ 0 ] = sampleAt( baseUv );\n\t\t\tsamples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );\n\t\t\tsamples[ 2 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 0.0 ) );\n\n\t\t\tsamples[ 3 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );\n\t\t\tsamples[ 4 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );\n\t\t\tsamples[ 5 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, parentPixelSize.y ) );\n\n\t\t\tsamples[ 6 ] = sampleAt( baseUv + vec2( 0.0, 2.0 * parentPixelSize.y ) );\n\t\t\tsamples[ 7 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 2.0 * parentPixelSize.y ) );\n\t\t\tsamples[ 8 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 2.0 * parentPixelSize.y ) );\n\n\t\t\tweights[ 0 ] = wx0 * wy0;\n\t\t\tweights[ 1 ] = wx1 * wy0;\n\t\t\tweights[ 2 ] = wx2 * wy0;\n\n\t\t\tweights[ 3 ] = wx0 * wy1;\n\t\t\tweights[ 4 ] = wx1 * wy1;\n\t\t\tweights[ 5 ] = wx2 * wy1;\n\n\t\t\tweights[ 6 ] = wx0 * wy2;\n\t\t\tweights[ 7 ] = wx1 * wy2;\n\t\t\tweights[ 8 ] = wx2 * wy2;\n\n\t\t\t#endif\n\n\t\t\t<mipmap_logic>\n\n\t\t}\n\t'},{Color:F,ShaderMaterial:N,MathUtils:G,WebGLRenderTarget:H,NearestFilter:Q}=await e("three"),$=new F;class X{constructor(e){e||(e="\n\n\t\t\t\t#pragma unroll_loop\n\t\t\t\tfor ( int i = 0; i < SAMPLES; i ++ ) {\n\n\t\t\t\t\tgl_FragColor += samples[ i ] * weights[ i ];\n\n\t\t\t\t}\n\n\t\t\t");const t=j(O);t.fragmentShader=t.fragmentShader.replace(/<mipmap_logic>/g,e);const a=new Array(4);a[0]=new N(j(t)),a[0].defines.X_IS_EVEN=0,a[0].defines.Y_IS_EVEN=0,a[1]=new N(j(t)),a[1].defines.X_IS_EVEN=1,a[1].defines.Y_IS_EVEN=0,a[2]=new N(j(t)),a[2].defines.X_IS_EVEN=0,a[2].defines.Y_IS_EVEN=1,a[3]=new N(j(t)),a[3].defines.X_IS_EVEN=1,a[3].defines.Y_IS_EVEN=1;const n=new H;n.texture.minFilter=Q,n.texture.magFilter=Q,this._swapTarget=n,this._copyQuad=new b(new N(z)),this._mipQuad=new b(null),this._mipMaterials=a}update(e,t,a,n=!1){e.isWebGLRenderTarget&&(e=e.texture);const o=a.autoClear,r=a.getClearAlpha(),i=a.getRenderTarget();a.getClearColor($);const l=this._copyQuad,s=this._mipQuad,c=this._swapTarget,p=this._mipMaterials;let u,m;n?(u=G.floorPowerOfTwo(e.image.width),m=G.floorPowerOfTwo(e.image.height)):(u=Math.floor(e.image.width),m=Math.floor(e.image.height));const d=Math.floor(1.5*u),v=Math.floor(m);t.setSize(d,v),c.texture.type!==t.texture.type?(c.dispose(),c.copy(t),c.texture.image={...c.texture.image}):c.setSize(d,v),a.autoClear=!1,a.setClearColor(0),a.setClearAlpha(),l.material.uniforms.tDiffuse.value=e,l.camera.setViewOffset(u,m,0,0,d,v),a.setRenderTarget(t),a.clear(),l.render(a),a.setRenderTarget(c),a.clear(),l.render(a);let f=u,h=m,w=0;for(;f>1&&h>1;){const e=p[(f%2==0?1:0)|(h%2==0?2:0)];e.uniforms.map.value=c.texture,e.uniforms.parentLevel.value=w,e.uniforms.parentMapSize.value.set(f,h),e.uniforms.originalMapSize.value.set(u,m),s.material=e,f=Math.floor(f/2),h=Math.floor(h/2);const n=v-2*h;a.setRenderTarget(t),s.camera.setViewOffset(f,h,-u,-n,d,v),s.render(a),a.setRenderTarget(c),e.uniforms.map.value=t.texture,s.render(a),w++}return a.setRenderTarget(i),a.setClearAlpha(r),a.setClearColor($),a.autoClear=o,w+1}dispose(){this._swapTarget.dispose(),this._mipQuad.dispose(),this._copyQuad.dispose(),this._mipMaterials.forEach(e=>e.dispose())}}const{defineComponent:Y}=await e("vue"),Z=await e("three"),J=Y({__name:"reflectorMipMap",props:{parent:{},resolution:{default:512},ignoreObjects:{default:[]}},setup(e,{expose:n}){const o=e,r=new Z.Plane,i=new Z.Matrix4,l=new Z.PerspectiveCamera,c=new X,p=s({width:o.resolution,height:o.resolution,settings:{type:Z.UnsignedByteType}}),u=s({width:o.resolution,height:o.resolution,settings:{type:Z.UnsignedByteType}}),{camera:m,renderer:d,scene:v}=t(),{onBeforeRender:f}=a();return f(()=>{(()=>{if(!m.value)return;r.set(new Z.Vector3(0,1,0),0),r.applyMatrix4(o.parent.matrixWorld),l.copy(m.value);const e=new Z.Vector3(0,0,1).clone().negate(),t=m.value.getWorldPosition(new Z.Vector3);e.reflect(r.normal);const a=new Z.Vector3;r.projectPoint(t,a);const n=a.clone();n.sub(t),n.add(a),l.position.copy(n);const s=new Z.Vector3(0,0,-1);s.applyQuaternion(m.value.getWorldQuaternion(new Z.Quaternion)),s.add(t);const c=new Z.Vector3;o.parent.getWorldPosition(c),c.sub(s),c.reflect(r.normal).negate(),c.add(o.parent.getWorldPosition(new Z.Vector3)),l.up.set(0,1,0),l.applyQuaternion(m.value.getWorldQuaternion(new Z.Quaternion)),l.up.reflect(r.normal),l.lookAt(c),l.updateMatrixWorld();const u=new Z.Matrix4;u.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),u.multiply(l.projectionMatrix),u.multiply(l.matrixWorldInverse),i.copy(u),r.applyMatrix4(l.matrixWorldInverse);const f=new Z.Vector4(r.normal.x,r.normal.y,r.normal.z,r.constant),h=l.projectionMatrix,w=new Z.Vector4;w.x=(Math.sign(f.x)+h.elements[8])/h.elements[0],w.y=(Math.sign(f.y)+h.elements[9])/h.elements[5],w.z=-1,w.w=(1+h.elements[10])/h.elements[14],f.multiplyScalar(2/f.dot(w)),h.elements[2]=f.x,h.elements[6]=f.y,h.elements[10]=f.z+1,h.elements[14]=f.w;const g=d.getRenderTarget();d.setRenderTarget(p.value),d.state.buffers.depth.setMask(!0),!1===d.autoClear&&d.clear(),o.ignoreObjects.forEach(e=>e.visible=!1),d.render(v.value,l),o.ignoreObjects.forEach(e=>e.visible=!0),d.setRenderTarget(g)})(),p.value&&u.value&&d&&c.update(p.value.texture,u.value,d)}),n({matrix:i,renderTarget:u}),(e,t)=>null}}),{withAsyncContext:q,defineComponent:K}=await e("vue"),{createElementVNode:ee,unref:te,openBlock:ae,createElementBlock:ne}=await e("vue"),oe=["rotateX","receiveShadow"],re=["color","map","normalMap","metalnessMap","roughnessMap","metalness","roughness","normalScale","side"],{watch:ie}=await e("vue"),le=await e("three"),se=K({__name:"rubberTiles",props:{color:{default:"#FFFFFF"},repeat:{default:{x:1,y:1}},metalness:{default:1},roughness:{default:.66},normalScale:{default:1},receiveShadow:{type:Boolean,default:!1}},async setup(e){let t,a;const o=e,{textures:r}=([t,a]=q(()=>n(["./plugins/floor/image/rubber_tiles_diff_1k.jpg","./plugins/floor/image/rubber_tiles_nor_gl_1k.jpg","./plugins/floor/image/rubber_tiles_arm_1k.jpg"])),t=await t,a(),t);return ie([r],([e])=>{if(e&&e.length)for(let t=0;t<e.length;t++)e[t].colorSpace=le.LinearSRGBColorSpace,e[t].wrapS=le.RepeatWrapping,e[t].wrapT=le.RepeatWrapping,e[t].magFilter=le.LinearFilter,e[t].minFilter=le.LinearMipmapLinearFilter,e[t].repeat.set(o.repeat.x,o.repeat.y)}),ie(()=>o.repeat,e=>{for(let t=0;t<r.value.length;t++)r.value[t].repeat.set(e.x,e.y)},{deep:!0}),(e,t)=>(ae(),ne("TresGroup",null,[ee("TresMesh",{rotateX:-Math.PI/2,receiveShadow:e.receiveShadow},[t[0]||(t[0]=ee("TresPlaneGeometry",{args:[10,10]},null,-1)),ee("TresMeshStandardMaterial",{color:o.color,map:te(r)[0],normalMap:te(r)[1],metalnessMap:te(r)[2],roughnessMap:te(r)[2],metalness:e.metalness,roughness:e.roughness,normalScale:e.normalScale,side:le.DoubleSide},null,8,re)],8,oe)]))}}),{defineComponent:ce}=await e("vue"),{openBlock:pe,createElementBlock:ue,createCommentVNode:me}=await e("vue"),de=["object"],{ref:ve,toRaw:fe,watch:he}=await e("vue"),we=ce({__name:"topoBase",props:{selected:{default:"baseModelA"},type:{default:["baseModelA","baseModelB"]},colorlist:{default:["#6381EE","#FFFFFF"]},roughness:{default:.5},metalness:{default:.6}},setup(e){const t=e,a=ve(!1);(async()=>{for(const e of t.type)await p.getResource("GLTFLoader",`./plugins/floor/models/topoBase/${e}.glb`,`topo-${e}.glb`);a.value=!0})();const n=ve(null),o={};he(()=>a.value,e=>{e&&(n.value=p.getReactiveItem(`topo-${t.selected}.glb`)().scene.clone(),r(n.value))},{immediate:!0}),he(()=>t.selected,async e=>{n.value=p.getReactiveItem(`topo-${e}.glb`)().scene.clone(),r(n.value)});const r=e=>{for(const t in o)o[t].dispose(),delete o[t];e.traverse(e=>{if(e.isMesh&&e.material){const t=e.material;o[t.uuid]||(o[t.uuid]=t.clone()),e.material=o[t.uuid]}}),i(t.colorlist)},i=e=>{let t=0;for(const a in o)o.hasOwnProperty(a)&&o[a].color.set(e[t]),t++},l=(e,t)=>{for(const a in o)o.hasOwnProperty(a)&&(o[a][e]=t)};return he(()=>t.colorlist,e=>{i(e)},{deep:!0}),he(()=>[t.roughness,t.metalness],([e,t])=>{l("roughness",e),l("metalness",t)},{deep:!0}),(e,t)=>(pe(),ue("TresGroup",null,[n.value?(pe(),ue("primitive",{key:0,object:fe(n.value)},null,8,de)):me("",!0)]))}}),{defineComponent:ge}=await e("vue"),{unref:xe,openBlock:ye,createElementBlock:Se,createCommentVNode:Me}=await e("vue"),Pe=["object"],{watch:_e}=await e("vue"),be=await e("three"),ze=ge({__name:"hexagonalWall",props:{color:{default:"#7432B4"}},setup(e){const{renderer:r,scene:i,camera:l,sizes:s}=t(),c=e;let p=null;const{textures:v,isLoading:h}=n(["./plugins/floor/image/concrete_wet_floor_basecolor.jpg","./plugins/floor/image/metal_plate_diff_1k.jpg"]),{state:w}=o("https://opensource.cdn.icegl.cn/model/floor/baseModelI.glb",{draco:!0,decoderPath:"./draco/"});let g=null;_e([w,v,h],([e,t,a])=>{e&&t&&!a&&(g=e.scene,g.traverse(e=>{if(e instanceof be.Mesh){const a=e.position.clone(),n=20+30*Math.random(),o=Math.random()*Math.PI*2,r=20*(Math.random()-.5),i=new be.Vector3(a.x+Math.cos(o)*n,a.y+r,a.z+Math.sin(o)*n);x.push({mesh:e,originalPosition:a,scatteredPosition:i}),e.position.copy(i),e.name.includes("_")?(t[0].wrapS=be.RepeatWrapping,t[0].wrapT=be.RepeatWrapping,t[0].repeat.set(10,10),e.material.map=v.map,e.material.needsUpdate=!0,e.material.emissive=new be.Color("#7432B4"),e.material.emissiveIntensity=3.5):(t[1]&&(t[1].wrapS=be.RepeatWrapping,t[1].wrapT=be.RepeatWrapping,t[1].repeat.set(10,10),e.material.map=t[1]),e.material.color=new be.Color("#7432B4"),e.material.metalness=.8,e.material.roughness=.2,e.material.envMapIntensity=2.5,e.material.needsUpdate=!0)}}),P(),M(),y())});const x=[],y=()=>{if(0===x.length)return;const e=u.timeline();x.forEach((t,a)=>{const n=.8*Math.random(),o={x:(Math.random()-.5)*Math.PI*2,y:(Math.random()-.5)*Math.PI*2,z:(Math.random()-.5)*Math.PI*2};t.mesh.rotation.set(o.x,o.y,o.z),e.to(t.mesh.position,{x:t.originalPosition.x,y:t.originalPosition.y,z:t.originalPosition.z,duration:3,ease:"power2.out",delay:n},0),e.to(t.mesh.rotation,{x:0,y:0,z:0,duration:3,ease:"power2.out",delay:n},0)}),e.call(()=>{S()}),console.log(`开始拼合动画，共 ${x.length} 个mesh`)},S=()=>{x.forEach((e,t)=>{u.to(e.mesh.position,{z:e.originalPosition.z+3+t/50,duration:2,repeat:-1,yoyo:!0,ease:"power1.inOut"})}),console.log("Z轴微动动画已启动")},M=()=>{if(!r||!l.value||!s.width.value)return;p=new m(r);const e=new d(i.value,l.value);p.addPass(e);const t=new f(new be.Vector2(s.width.value,s.height.value),.6,.05,.25);p.addPass(t)},P=()=>{const e=new be.PMREMGenerator(r),t=new U,a=e.fromScene(t).texture;i.value.environment=a,g.traverse(e=>{e instanceof be.Mesh&&e.material&&(e.material.envMap=a,e.material.needsUpdate=!0)}),t.dispose()},{onRender:_}=a();return _(()=>{p&&p.render()}),_e(()=>[c.color],([e])=>{g.traverse(t=>{t instanceof be.Mesh&&t.material&&(t.material.color=new be.Color(e),t.material.emissive=new be.Color(e))})}),(e,t)=>xe(w)?(ye(),Se("primitive",{key:0,object:xe(w)?.scene,"position-y":.01},null,8,Pe)):Me("",!0)}}),{defineComponent:Te}=await e("vue"),{createElementVNode:Ce,unref:Ee,openBlock:ke,createElementBlock:Re,createCommentVNode:Ae}=await e("vue"),Le={key:0},Ve=["object"],We=["object"],Ue=["object"],{onMounted:De,watch:Be,computed:Ie}=await e("vue"),je=await e("three"),Oe=Te({__name:"mechaFloor",props:{color:{default:"#ffed00"}},setup(e){const{renderer:n,scene:i,camera:l,sizes:s}=t(),c=e;let p=null;const u={uniforms:{tDiffuse:{value:null},contrast:{value:1.8}},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n    ",fragmentShader:"\n        uniform sampler2D tDiffuse;\n        uniform float contrast;\n        varying vec2 vUv;\n        void main() {\n            vec4 color = texture2D(tDiffuse, vUv);\n            color.rgb = (color.rgb - 0.5) * contrast + 0.8;\n            gl_FragColor = color;\n        }\n    "},{state:h}=o("https://opensource.cdn.icegl.cn/model/floor/baseModelJ.glb",{draco:!0,decoderPath:"./draco/"}),w=Ie(()=>h?.value?.scene),{state:g}=o("plugins/floor/models/topoBase/baseModelL.glb",{draco:!0,decoderPath:"./draco/"}),{state:x}=o("https://opensource.cdn.icegl.cn/model/floor/baseModelK.glb",{draco:!0,decoderPath:"./draco/"}),y=Ie(()=>x.value?.animations||[]),S=Ie(()=>x?.value?.scene),{actions:M}=r(y,S);Be(M,e=>{e.Scene&&e.Scene.play()}),Be(w,e=>{e&&e.traverse(e=>{e instanceof je.Mesh&&(e.material.emissive=new je.Color("#ffed00"),e.material.emissiveIntensity=20.5,e.material.toneMapped=!0,e.material.needsUpdate=!0)})});const{onRender:P}=a();return P(()=>{p&&p.render()}),De(()=>{(()=>{const e=new je.PMREMGenerator(n),t=new U,a=e.fromScene(t).texture;i.value.environment=a,w.value&&w.value.traverse(e=>{e instanceof je.Mesh&&e.material&&(e.material.envMap=a,e.material.needsUpdate=!0)}),t.dispose()})(),setTimeout(()=>{(()=>{if(!n||!l.value||!s.width.value)return;p=new m(n);const e=new d(i.value,l.value);p.addPass(e);const t=new f(new je.Vector2(s.width.value,s.height.value),.1,.1,.1);p.addPass(t);const a=new v(u);a.uniforms.contrast.value=1.1,p.addPass(a)})()},200)}),Be(()=>[c.color],([e])=>{w.value&&w.value.traverse(t=>{t instanceof je.Mesh&&t.material&&(t.material.emissive=new je.Color(e))})}),(e,t)=>w.value&&S.value?(ke(),Re("TresGroup",Le,[Ce("primitive",{object:w.value,"position-y":.01},null,8,Ve),Ee(g)?(ke(),Re("primitive",{key:0,object:Ee(g)?.scene,"position-y":.1},null,8,We)):Ae("",!0),Ce("primitive",{object:S.value,"position-y":.1},null,8,Ue)])):Ae("",!0)}}),{defineComponent:Fe}=await e("vue"),{unref:Ne,openBlock:Ge,createElementBlock:He,createCommentVNode:Qe}=await e("vue"),$e=["object"],{watch:Xe}=await e("vue"),Ye=await e("three"),Ze=Fe({__name:"hexagonalFloor",props:{floorColor:{default:"#ff0000"},floorMetalness:{default:.8},floorRoughness:{default:.2},floorEnvMapIntensity:{default:2.5},sideColor:{default:"#ffffff"},sideOpacity:{default:.9},speed:{default:.3}},setup(e){const{renderer:a,scene:n}=t(),r=e,{state:l}=i("./plugins/floor/image/concrete_wet_floor_basecolor.jpg");Xe(l,e=>{e&&(e.wrapS=Ye.RepeatWrapping,e.wrapT=Ye.RepeatWrapping,e.repeat.set(10,10))});const{state:s}=o("https://opensource.cdn.icegl.cn/model/floor/baseModelI.glb",{draco:!0,decoderPath:"./draco/"}),c=[],p=u.timeline();Xe(()=>s.value,e=>{if(!e.scene)return;e.scene.traverse(e=>{if(e instanceof Ye.Mesh){const t=e.position.clone(),a=e.rotation.clone(),n=Math.random()-.5,o=new Ye.Vector3(t.x,t.y+n,t.z),r=Math.PI/12,i=new Ye.Euler(a.x+(Math.random()-.5)*r,a.y+(Math.random()-.5)*r,a.z);c.push({mesh:e,originalPosition:t,scatteredPosition:o,originalRotation:a,scatteredRotation:i}),e.name.includes("_")?(e.material.emissiveIntensity=2,e.material.metalness=1,e.material.roughness=0,e.material.transparent=!0):e.material.map=l.value,e.material.needsUpdate=!0}}),c.forEach(({mesh:e,scatteredPosition:t,scatteredRotation:a},n)=>{p.to(e.position,{x:t.x,y:t.y,z:t.z,ease:"power1.inOut",repeat:-1,yoyo:!0},0),p.to(e.rotation,{x:a.x,y:a.y,z:a.z,ease:"power1.inOut",repeat:-1,yoyo:!0},0)}),m()});const m=()=>{const e=new Ye.PMREMGenerator(a),t=new U,o=e.fromScene(t).texture;n.value.environment=o,s.value.scene.traverse(e=>{e instanceof Ye.Mesh&&e.material&&(e.material.envMap=o,e.material.needsUpdate=!0)}),t.dispose(),d(r.sideColor,r.floorColor,r.sideOpacity,r.floorMetalness,r.floorRoughness,r.floorEnvMapIntensity)},d=(e,t,a,n,o,r)=>{s.value?.scene&&s.value.scene.traverse(i=>{i instanceof Ye.Mesh&&i.material&&(i.name.includes("_")?(i.material.emissive.set(e),i.material.opacity=a):(i.material.color.set(t),i.material.metalness=n,i.material.roughness=o,i.material.envMapIntensity=r))})};return Xe(()=>[r.sideColor,r.floorColor,r.sideOpacity,r.floorMetalness,r.floorRoughness,r.floorEnvMapIntensity],([e,t,a,n,o,r])=>{d(e,t,a,n,o,r)}),Xe(()=>[r.speed],([e])=>{p.timeScale(e)},{immediate:!0}),(e,t)=>(Ge(),He("TresGroup",null,[Ne(s)?(Ge(),He("primitive",{key:0,object:Ne(s)?.scene,position:[0,-.1,0]},null,8,$e)):Qe("",!0)]))}}),{unref:Je,createElementVNode:qe,openBlock:Ke,createElementBlock:et}=await e("vue"),tt=["geometry"],at=["color","transparent","opacity","side"],nt=["geometry"],ot=["map","side"],{watch:rt}=await e("vue"),it=await e("three"),lt={__name:"ribbonArrow",props:{length:{default:20},width:{default:1},bendPosition:{default:.5},curvature:{default:.4},backgroundColor:{default:"#00aaff"},backgroundAlpha:{default:.25},segments:{default:240},arrowColor:{default:"#ffffff"},arrowWidth:{default:.3},arrowHeight:{default:.5},arrowSpacing:{default:.5},arrowOffset:{default:0},arrowLineWidth:{default:2},arrowStyle:{default:"chevron"},speed:{default:.5},pixelWorldScale:{default:.03}},setup(e){const t=e,n=()=>{const e=Math.max(1e-4,t.length),a=it.MathUtils.clamp(t.bendPosition,0,1),n=e*a,o=e-n,r=Math.min(n,o),i=t.curvature>0&&a>0&&a<1?Math.min(.9*r,.2*e*t.curvature):0,l=Math.max(0,n-i),s=i>0?Math.PI*i/2:0;return{fullLen:l+s+Math.max(0,o-i),L1val:n,radius:i,len1:l,arcLen:s}};let{fullLen:o,L1val:r,radius:i,len1:l,arcLen:s}=n();const c=e=>{if((e=it.MathUtils.clamp(e,0,o))<=l)return new it.Vector2(e,0);if(e<=l+s&&i>0){const t=(e-l)/s,a=-Math.PI/2+t*(Math.PI/2),n=r-i,o=i;return new it.Vector2(n+Math.cos(a)*i,o+Math.sin(a)*i)}{const t=e-(l+s);return new it.Vector2(r,i+t)}};let p=[],u=[],m=0;const d=()=>{p=[],u=[];const e=Math.max(8,Math.floor(t.segments));let a=c(0),n=0;p.push(a),u.push(0),m=0;for(let t=1;t<=e;t++){const r=c(o*(t/e));n+=r.clone().sub(a).length(),p.push(r),u.push(n),a=r}m=n};d();let v=null;const f=()=>{const e=2*p.length,a=new Float32Array(3*e),n=new Float32Array(3*e),o=new Float32Array(2*e),r=[],i=t.width/2;function l(e){return 0===e?p[1].clone().sub(p[0]).normalize():e===p.length-1?p[e].clone().sub(p[e-1]).normalize():p[e+1].clone().sub(p[e-1]).normalize()}for(let s=0;s<p.length;s++){const e=p[s],r=l(s),c=new it.Vector2(-r.y,r.x).normalize(),m=e.x-c.x*i,d=e.y-c.y*i,v=e.x+c.x*i,f=e.y+c.y*i;a[3*(2*s+0)+0]=m,a[3*(2*s+0)+1]=d,a[3*(2*s+0)+2]=0,a[3*(2*s+1)+0]=v,a[3*(2*s+1)+1]=f,a[3*(2*s+1)+2]=0,n[3*(2*s+0)+0]=0,n[3*(2*s+0)+1]=0,n[3*(2*s+0)+2]=1,n[3*(2*s+1)+0]=0,n[3*(2*s+1)+1]=0,n[3*(2*s+1)+2]=1;const h=u[s]/(t.arrowWidth+t.arrowSpacing);o[2*(2*s+0)+0]=h,o[2*(2*s+0)+1]=0,o[2*(2*s+1)+0]=h,o[2*(2*s+1)+1]=1}for(let t=0;t<p.length-1;t++){const e=2*t,a=2*t+1,n=2*(t+1),o=2*(t+1)+1;r.push(e,n,a),r.push(a,n,o)}v&&v.dispose(),v=new it.BufferGeometry,v.setAttribute("position",new it.BufferAttribute(a,3)),v.setAttribute("normal",new it.BufferAttribute(n,3)),v.setAttribute("uv",new it.BufferAttribute(o,2)),v.setIndex(r),v.computeBoundingBox(),v.computeBoundingSphere()};f();let h=null;const w=()=>{h&&h.dispose(),h=(({arrowWidthPx:e,arrowHeightPx:a,spacingPx:n,style:o,color:r,lineWidth:i,offset:l})=>{const s=n,c=e+2*s,p=a+2*s,u=Math.max(1,window.devicePixelRatio||1),d=document.createElement("canvas");d.width=c*u,d.height=p*u,d.style.width=c+"px",d.style.height=p+"px";const v=d.getContext("2d");v.scale(u,u),v.clearRect(0,0,c,p),v.strokeStyle=r,v.fillStyle=r,v.lineWidth=i,v.lineJoin="round",v.lineCap="round";const f=s,h=e,w=a,g=f+h/2,x=s+w/2+l;"chevron"===o?(v.beginPath(),v.moveTo(f,x-w/2),v.lineTo(f+h,x),v.lineTo(f,x+w/2),v.stroke()):"double"===o?(v.beginPath(),v.moveTo(f,x-w/2),v.lineTo(f+.7*h,x),v.lineTo(f,x+w/2),v.stroke(),v.beginPath(),v.moveTo(f+.8*h,x-w/2),v.lineTo(f+1.5*h,x),v.lineTo(f+.8*h,x+w/2),v.stroke()):"triangle"===o?(v.beginPath(),v.moveTo(f,x-w/2),v.lineTo(f+h,x),v.lineTo(f,x+w/2),v.closePath(),v.fill()):"diamond"===o?(v.beginPath(),v.moveTo(g,x-w/2),v.lineTo(g+h/2,x),v.lineTo(g,x+w/2),v.lineTo(g-h/2,x),v.closePath(),v.fill()):(v.beginPath(),v.moveTo(f,x-w/2),v.lineTo(f+h,x),v.lineTo(f,x+w/2),v.stroke());const y=new it.CanvasTexture(d);return y.generateMipmaps=!1,y.minFilter=it.LinearFilter,y.magFilter=it.LinearFilter,y.wrapS=it.RepeatWrapping,y.wrapT=it.ClampToEdgeWrapping,y.repeat.set(m/(t.arrowWidth+t.arrowSpacing),1),y.needsUpdate=!0,y})({arrowWidthPx:t.arrowWidth/t.pixelWorldScale,arrowHeightPx:t.arrowHeight/t.pixelWorldScale,spacingPx:t.arrowSpacing/t.pixelWorldScale,style:t.arrowStyle,color:t.arrowColor,lineWidth:t.arrowLineWidth,offset:t.arrowOffset})};w(),rt(()=>[t.length,t.width,t.bendPosition,t.curvature,t.segments,t.arrowColor,t.arrowWidth,t.arrowHeight,t.arrowSpacing,t.arrowOffset,t.arrowLineWidth,t.arrowStyle,t.pixelWorldScale],()=>{({fullLen:o,L1val:r,radius:i,len1:l,arcLen:s}=n()),d(),f(),w()});const{onBeforeRender:g}=a();return g(()=>{if(h){const e=.01*t.speed;h.offset.x=(h.offset.x-e)%1,h.offset.x>1&&(h.offset.x-=1),h.needsUpdate=!0}}),(t,a)=>(Ke(),et("TresGroup",null,[qe("TresMesh",{geometry:Je(v)},[qe("TresMeshBasicMaterial",{color:e.backgroundColor,transparent:e.backgroundAlpha<1,opacity:e.backgroundAlpha,side:it.DoubleSide,depthWrite:""},null,8,at)],8,tt),qe("TresMesh",{geometry:Je(v)},[qe("TresMeshBasicMaterial",{map:Je(h),transparent:"",side:it.DoubleSide,depthWrite:"",renderOrder:1},null,8,ot)],8,nt)]))}},{defineComponent:st}=await e("vue"),{createElementVNode:ct,mergeProps:pt,openBlock:ut,createElementBlock:mt}=await e("vue"),dt=["rotation-x"],vt=await e("three"),{reactive:ft,watch:ht,ref:wt}=await e("vue"),gt=st({__name:"shaderCircleWave",props:{color:{default:"#ffffff"},colorDark:{default:"#000000"},speed:{default:1}},setup(e){const t=e,n=ft({side:vt.DoubleSide,transparent:!0,blending:vt.AdditiveBlending,flatShading:!0,depthTest:!0,depthWrite:!1,uniforms:{uTime:{type:"f",value:0},uScanTex:{type:"t",value:null},uScanColor:{type:"v3",value:new vt.Color(t.color)},uScanColorDark:{type:"v3",value:new vt.Color(t.colorDark)}},vertexShader:"\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvoid main(){\n\tvUv=uv;\n\tvPosition=position;\n\tgl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\n}\n",fragmentShader:"\n#define uScanOrigin vec3(0.,0.,0.)\n#define uScanWaveRatio1 3.2\n#define uScanWaveRatio2 2.8\n\nuniform float uTime;\nuniform sampler2D uScanTex;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform vec3 uScanColor;\nuniform vec3 uScanColorDark;\n\nfloat circleWave(vec3 p,vec3 origin,float distRatio){\n    float t=uTime;\n    float dist=distance(p,origin)*distRatio;\n    float radialMove=fract(dist-t);\n    float fadeOutMask=1.-smoothstep(1.,3.,dist);\n    radialMove*=fadeOutMask;\n    float cutInitialMask=1.-step(t,dist);\n    radialMove*=cutInitialMask;\n    return radialMove;\n}\n\nvec3 getScanColor(vec3 worldPos,vec2 uv,vec3 col){\n    // mask\n    float scanMask=texture(uScanTex,uv).r;\n    // waves\n    float cw=circleWave(worldPos,uScanOrigin,uScanWaveRatio1);\n    float cw2=circleWave(worldPos,uScanOrigin,uScanWaveRatio2);\n    // scan\n    float mask1=smoothstep(.3,0.,1.-cw);\n    mask1*=(1.+scanMask*.7);\n    \n    float mask2=smoothstep(.07,0.,1.-cw2)*.8;\n    mask1+=mask2;\n    \n    float mask3=smoothstep(.09,0.,1.-cw)*1.5;\n    mask1+=mask3;\n\n    // color\n    vec3 scanCol=mix(uScanColorDark,uScanColor,mask1);\n    col=mix(col,scanCol,mask1);\n    \n    return col;\n\t\t// return vec3(cw);\n\t\t// return vec3(scanMask);\n\t\t// return worldPos;\n\t\t// return vec3(mask1);\n\t\t// return scanCol;\n}\n\nvoid main()\n{\n    vec3 col=vec3(0.);\n    col=getScanColor(vPosition,vUv*10.0,col);\n    gl_FragColor=vec4(col,1.);\n}\n"}),o=wt(null),{state:r}=i("./plugins/floor/image/scan.png");ht(()=>r.value,e=>{e&&(e.wrapS=vt.RepeatWrapping,e.wrapT=vt.RepeatWrapping,n.uniforms.uScanTex.value=e,o.value.needsUpdate=!0,o.value.uniformsNeedUpdate=!0)}),ht(()=>[t.color,t.colorDark],([e,t])=>{n.uniforms.uScanColor.value=new vt.Color(e),n.uniforms.uScanColorDark.value=new vt.Color(t)});const{onBeforeRender:l}=a();return l(()=>{n.uniforms.uTime.value+=.01*t.speed}),(e,t)=>(ut(),mt("TresGroup",null,[ct("TresMesh",{"rotation-x":-Math.PI/2},[t[0]||(t[0]=ct("TresPlaneGeometry",{args:[1,1]},null,-1)),ct("TresShaderMaterial",pt({ref_key:"tsmRef",ref:o},n),null,16)],8,dt)]))}}),{defineComponent:xt}=await e("vue"),{unref:yt,createElementVNode:St,openBlock:Mt,createElementBlock:Pt}=await e("vue"),_t=["object"],bt=await e("three"),{watch:zt,onUnmounted:Tt}=await e("vue"),Ct=xt({__name:"cartoonMagic",props:{color:{default:"#00ffff"},speed:{default:1}},setup(e){const t=e,n=e=>{const a=new bt.Color(t.color),n=new bt.Vector4(a.r,a.g,a.b,e);return new x(n)},o=new h,r=new w;r.setCrossOrigin("");const{scene:i}=l(),s=new bt.Group;i.value.add(s),Tt(()=>{i.value.remove(s)}),r.load("./plugins/floor/json/CartoonMagicZone2.json",e=>{e.traverse(e=>{if("ParticleEmitter"===e.type){"BasicZoneRedEmitter"===e.name&&e.rotation.set(Math.PI/2,0,0);const t=e.system;-.25===t.startSpeed.value&&(t.startSpeed=new g(-.5)),t.startColor=n(t.startColor.color.w),o.addSystem(t)}}),"ParticleEmitter"===e.type&&o.addSystem(e.system),s.add(e)});const{onBeforeRender:c}=a();return c(()=>{o.update(.01*t.speed)}),zt(()=>[t.color],()=>{o.systemToBatchIndex.forEach((e,t)=>{t.startColor=n(t.startColor.color.w)})}),(e,t)=>(Mt(),Pt("TresGroup",null,[St("primitive",{object:yt(o)},null,8,_t)]))}}),{defineComponent:Et}=await e("vue"),{createElementVNode:kt,normalizeProps:Rt,guardReactiveProps:At,openBlock:Lt,createElementBlock:Vt}=await e("vue"),Wt=await e("three"),{watch:Ut,reactive:Dt,ref:Bt}=await e("vue"),It=Et({__name:"dynamicRotatingBase",props:{type:{default:"imgA"},color:{default:"#fff"},opacity:{default:.95},rotationZ:{default:.01},videoLoop:{type:Boolean,default:!1}},setup(e){const t=Bt(),{onBeforeRender:n}=a();n(()=>{t.value&&(t.value.rotation.z+=r.rotationZ)});const o={imgA:{type:"img",path:"./plugins/floor/image/imgFloor1.png"},imgB:{type:"img",path:"./plugins/floor/image/imgFloor2.png"},imgC:{type:"img",path:"./plugins/floor/image/imgFloor3.png"},videoA:{type:"video",path:"https://opensource.cdn.icegl.cn/video/floor/floorV1.mp4"},videoB:{type:"video",path:"https://opensource.cdn.icegl.cn/video/floor/floorV2.mp4"},videoC:{type:"video",path:"https://opensource.cdn.icegl.cn/video/floor/floorV3.mp4"}},r=e,i=Dt({color:r.color,map:null,side:Wt.DoubleSide,transparent:!0,opacity:r.opacity,blending:Wt.AdditiveBlending,depthTest:!0,depthWrite:!1}),l=document.createElement("video");return Ut(()=>r.type,async e=>{if(i.map?.dispose(),"img"===o[e].type){const t=await c(o[e].path);t.colorSpace=Wt.SRGBColorSpace,t.wrapS=Wt.RepeatWrapping,t.wrapT=Wt.RepeatWrapping,t.repeat.set(1,1),i.map=t}else if("video"===o[e].type){l.src=o[e].path,l.crossOrigin="anonymous",l.loop=r.videoLoop,l.muted=!0,l.play();const t=new Wt.VideoTexture(l);t.colorSpace=Wt.SRGBColorSpace,t.wrapS=Wt.RepeatWrapping,t.wrapT=Wt.RepeatWrapping,t.repeat.set(1,1),i.map=t}},{immediate:!0}),Ut(()=>[r.color,r.opacity,r.videoLoop],([e,t,a])=>{i.color=new Wt.Color(e),i.opacity=t,l.loop=a}),(e,a)=>(Lt(),Vt("TresMesh",{ref_key:"tmRef",ref:t},[a[0]||(a[0]=kt("TresPlaneGeometry",{args:[10,10]},null,-1)),kt("TresMeshBasicMaterial",Rt(At(i)),null,16)],512))}});export{Ct as _sfc_main,gt as _sfc_main$1,It as _sfc_main$2,Ze as _sfc_main$3,ze as _sfc_main$4,Oe as _sfc_main$5,lt as _sfc_main$6,se as _sfc_main$7,we as _sfc_main$8,J as _sfc_main$9};
