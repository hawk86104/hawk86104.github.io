import{af as t,bg as e,ag as a,k as o,aE as r,a6 as n}from"./three.F31Lz30M1764662849723.js";import{n as s}from"./@tresjs.DeDzA3xI1764662849723.js";import{d as l,a as i,w as u,G as d,o as m,I as v,a9 as f,aa as g}from"./@vue.D9fSGD371764662849723.js";const h=["rotation-x"],p=["args"],w=l({__name:"whiteFloorMesh",props:{size:{default:[20,20]},color:{default:"#990"},shadowColor:{default:"#999"},edge:{default:.35}},setup(l){const w=l,c=i(),{state:x}=s("./plugins/floor/image/whiteFloor.jpg"),_={uniforms:e.merge([a.lights,{uColor:{value:new o(w.color)},uShadowColor:{value:new o(w.shadowColor)},fEdge:{value:w.edge},uTexture:{value:null}}]),side:n,vertexShader:`\n       varying vec2 vUv;\n\t\t\t \t${t.common}\n      \t${t.bsdfs}\n      \t${t.shadowmap_pars_vertex}\n       void main() {\n\t\t\t\t\t${t.beginnormal_vertex}\n          ${t.defaultnormal_vertex}\n          ${t.begin_vertex}\n          ${t.project_vertex}\n          ${t.worldpos_vertex}\n          ${t.shadowmap_vertex}\n\n           gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    \n           vUv = uv;\n       }`,fragmentShader:`\n\tvarying vec2 vUv;\n\tuniform sampler2D uTexture;\n\tuniform vec3 uShadowColor;\n\tuniform vec3 uColor;\n\tuniform float fEdge;\n\t// ShaderMaterial 下的 纹理参数重复无效 要在着色器中增加\n\tfloat repeatTime = 100.0;\n\n\tfloat smoothsteps(float t) {\n\t\t\treturn t * t * (3.0 - 2.0 * t);\n\t}\n\n\t ${t.common}\n\t ${t.packing}\n\t ${t.bsdfs}\n\t ${t.lights_pars_begin}\n\t ${t.shadowmap_pars_fragment}\n\t ${t.shadowmask_pars_fragment}\n\n\tvoid main() {\n\t\t\tvec4 col = texture2D(uTexture, vUv * repeatTime);\n\t\t\tcol.rgb = mix( uColor , col.rgb ,0.5);\n\t\t\t\n\t\t\tfloat alpha = 1.0;\n\t\t\tfloat d = length(vUv - vec2(0.5));\n\t\t\tif(d > 0.35) {\n\t\t\t\t\talpha = 1.0 - smoothsteps( clamp( (d - 0.35) / (fEdge-0.2), 0.0, 1.0) );\n\t\t\t}\n\n\t\t vec3 addShadow = mix( uShadowColor , col.rgb ,getShadowMask());\n\n\t\t\tgl_FragColor = vec4(addShadow, alpha);  \n\t}`,lights:!0,transparent:!0};return u(x,t=>{t&&(t.wrapS=r,t.wrapT=r,t.repeat.set(6,3),c.value.material.uniforms.uTexture.value=t)}),u(()=>w.edge,t=>{_.uniforms.fEdge.value=t}),u(()=>w.color,t=>{_.uniforms.uColor.value=new o(w.color)}),u(()=>w.shadowColor,t=>{_.uniforms.uShadowColor.value=new o(w.shadowColor)}),(t,e)=>(m(),d("TresMesh",{ref_key:"tmRef",ref:c,"rotation-x":-Math.PI/2},[v("TresPlaneGeometry",{args:w.size},null,8,p),v("TresShaderMaterial",f(g(_)),null,16)],8,h))}});export{w as _};
