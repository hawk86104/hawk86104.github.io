import{q as e,bG as t,k as n,Z as r,d as o,O as a,r as i,b5 as s,H as c,n as l,bn as d,l as h}from"./three.eXhPIzTa1723718122052.js";class m extends e{constructor(e,a){var i,s;const c=(l=e)&&l.isCubeTexture;var l;const d=(null!=(s=c?null==(i=e.image[0])?void 0:i.width:e.image.width)?s:1024)/4,h=Math.floor(Math.log2(d)),m=Math.pow(2,h),u=3*Math.max(m,112),f=4*m,p=[c?"#define ENVMAP_TYPE_CUBE":"","#define CUBEUV_TEXEL_WIDTH ".concat(1/u),"#define CUBEUV_TEXEL_HEIGHT ".concat(1/f),"#define CUBEUV_MAX_MIP ".concat(h,".0")].join("\n")+"\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <".concat(parseInt(o.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment",">\n        }\n        "),v={map:{value:e},height:{value:(null==a?void 0:a.height)||15},radius:{value:(null==a?void 0:a.radius)||100}};super(new t(1,16),new n({uniforms:v,fragmentShader:p,vertexShader:"\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        ",side:r}))}set radius(e){this.material.uniforms.radius.value=e}get radius(){return this.material.uniforms.radius.value}set height(e){this.material.uniforms.height.value=e}get height(){return this.material.uniforms.height.value}}var u=Object.defineProperty,f=(e,t,n)=>(((e,t,n)=>{t in e?u(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n})(e,"symbol"!=typeof t?t+"":t,n),n);class p{constructor(t){f(this,"camera",new a(-1,1,1,-1,0,1)),f(this,"geometry",new i(2,2)),f(this,"mesh"),this.mesh=new e(this.geometry,t)}get material(){return this.mesh.material}set material(e){this.mesh.material=e}dispose(){this.mesh.geometry.dispose()}render(e){e.render(this.mesh,this.camera)}}const v={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","\tvec4 texel = texture2D( tDiffuse, vUv );","\tgl_FragColor = opacity * texel;","}"].join("\n")};class g extends s{constructor(e){super(e),this.type=c}parse(e){const t=function(e,t){switch(e){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(t||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(t||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(t||""));default:throw new Error("THREE.RGBELoader: Memory Error: "+(t||""))}},n=function(e,t,n){t=t||1024;let r=e.pos,o=-1,a=0,i="",s=String.fromCharCode.apply(null,new Uint16Array(e.subarray(r,r+128)));for(;0>(o=s.indexOf("\n"))&&a<t&&r<e.byteLength;)i+=s,a+=s.length,r+=128,s+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(r,r+128)));return-1<o&&(!1!==n&&(e.pos+=a+o+1),i+s.slice(0,o))},r=function(e,t,n,r){const o=e[t+3],a=Math.pow(2,o-128)/255;n[r+0]=e[t+0]*a,n[r+1]=e[t+1]*a,n[r+2]=e[t+2]*a,n[r+3]=1},o=function(e,t,n,r){const o=e[t+3],a=Math.pow(2,o-128)/255;n[r+0]=d.toHalfFloat(Math.min(e[t+0]*a,65504)),n[r+1]=d.toHalfFloat(Math.min(e[t+1]*a,65504)),n[r+2]=d.toHalfFloat(Math.min(e[t+2]*a,65504)),n[r+3]=d.toHalfFloat(1)},a=new Uint8Array(e);a.pos=0;const i=function(e){const r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,o=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*FORMAT=(\S+)\s*$/,i=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,s={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let c,l;for((e.pos>=e.byteLength||!(c=n(e)))&&t(1,"no header found"),(l=c.match(/^#\?(\S+)/))||t(3,"bad initial token"),s.valid|=1,s.programtype=l[1],s.string+=c+"\n";c=n(e),!1!==c;)if(s.string+=c+"\n","#"!==c.charAt(0)){if((l=c.match(r))&&(s.gamma=parseFloat(l[1])),(l=c.match(o))&&(s.exposure=parseFloat(l[1])),(l=c.match(a))&&(s.valid|=2,s.format=l[1]),(l=c.match(i))&&(s.valid|=4,s.height=parseInt(l[1],10),s.width=parseInt(l[2],10)),2&s.valid&&4&s.valid)break}else s.comments+=c+"\n";return 2&s.valid||t(3,"missing format specifier"),4&s.valid||t(3,"missing image size specifier"),s}(a),s=i.width,h=i.height,m=function(e,n,r){const o=n;if(o<8||o>32767||2!==e[0]||2!==e[1]||128&e[2])return new Uint8Array(e);o!==(e[2]<<8|e[3])&&t(3,"wrong scanline width");const a=new Uint8Array(4*n*r);a.length||t(4,"unable to allocate buffer space");let i=0,s=0;const c=4*o,l=new Uint8Array(4),d=new Uint8Array(c);let h=r;for(;h>0&&s<e.byteLength;){s+4>e.byteLength&&t(1),l[0]=e[s++],l[1]=e[s++],l[2]=e[s++],l[3]=e[s++],2==l[0]&&2==l[1]&&(l[2]<<8|l[3])==o||t(3,"bad rgbe scanline format");let n,r=0;for(;r<c&&s<e.byteLength;){n=e[s++];const o=n>128;if(o&&(n-=128),(0===n||r+n>c)&&t(3,"bad scanline data"),o){const t=e[s++];for(let e=0;e<n;e++)d[r++]=t}else d.set(e.subarray(s,s+n),r),r+=n,s+=n}const m=o;for(let e=0;e<m;e++){let t=0;a[i]=d[e+t],t+=o,a[i+1]=d[e+t],t+=o,a[i+2]=d[e+t],t+=o,a[i+3]=d[e+t],i+=4}h--}return a}(a.subarray(a.pos),s,h);let u,f,p;switch(this.type){case l:p=m.length/4;const e=new Float32Array(4*p);for(let n=0;n<p;n++)r(m,4*n,e,4*n);u=e,f=l;break;case c:p=m.length/4;const t=new Uint16Array(4*p);for(let n=0;n<p;n++)o(m,4*n,t,4*n);u=t,f=c;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:s,height:h,data:u,header:i.string,gamma:i.gamma,exposure:i.exposure,type:f}}setDataType(e){return this.type=e,this}load(e,t,n,r){return super.load(e,(function(e,n){switch(e.type){case l:case c:"colorSpace"in e?e.colorSpace="srgb-linear":e.encoding=3e3,e.minFilter=h,e.magFilter=h,e.generateMipmaps=!1,e.flipY=!0}t&&t(e,n)}),n,r)}}export{v as C,p as F,m as G,g as R};
