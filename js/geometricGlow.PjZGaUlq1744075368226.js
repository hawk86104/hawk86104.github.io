import{a as e}from"./@tresjs.DYJWvbJh1744075368226.js";import{P as o}from"./tweakpane.C0HtAJSg1744075368226.js";import{d as r,w as n,H as t,o as i,J as a,m as s,u as l,r as c,h as u,e as f,f as m,j as p}from"./@vue.DK6ok9LJ1744075368226.js";import{V as d,C as v,bq as g,a4 as w,ct as y}from"./three.Cqu7jvck1744075368226.js";import"./postprocessing.BQUpsS8o1744075368226.js";import"./@vueuse.3dpzNfMJ1744075368226.js";!function(){const e=T,o=C();for(;;)try{if(617989===-parseInt(e(473))/1*(-parseInt(e(481))/2)+parseInt(e(457))/3*(-parseInt(e(467))/4)+-parseInt(e(480))/5+parseInt(e(491))/6*(parseInt(e(482))/7)+-parseInt(e(471))/8+parseInt(e(460))/9+parseInt(e(495))/10)break;o.push(o.shift())}catch(r){o.push(o.shift())}}();const h=function(){let e=!0;return function(o,r){const n=e?function(){if(r){const e=r.apply(o,arguments);return r=null,e}}:function(){};return e=!1,n}}();function C(){const e=["gger","count","chain","4snZvxT","table","attributes","init","8411368harwOb","constructor","110813VSrwQk","toString","trace","normal","counter","while (true) {}","function *\\( *\\)","373410QLSqtx","4zxDiGQ","21623uOfMur","bind","isBufferGeometry","__proto__","length","computeVertexNormals","error","array","warn","2022TmEjoM","console","call","input","6800210ipOOck","log","action","test","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","2636142jBcKFu","needsUpdate","debu","6121494edBiIf","exception","apply","stateObject"];return(C=function(){return e})()}!function(){h(this,(function(){const e=T,o=new RegExp(e(479)),r=new RegExp(e(499),"i"),n=b(e(470));o.test(n+e(466))&&r[e(498)](n+e(494))?b():n("0")}))()}();const x=function(){let e=!0;return function(o,r){const n=e?function(){if(r){const e=r[T(462)](o,arguments);return r=null,e}}:function(){};return e=!1,n}}();function M(e,o){const r=T;if(!e[r(484)])return void console[r(488)]("The geometry must be a BufferGeometry.");!e[r(469)][r(476)]&&e[r(487)]();const n=e[r(469)].position,t=e[r(469)].normal,i=n[r(489)],a=t.array;for(let s=0;s<n[r(465)];s++){const e=3*s;i[e]+=a[e]*o,i[e+1]+=a[e+1]*o,i[e+2]+=a[e+2]*o}n[r(458)]=!0}function T(e,o){const r=C();return T=function(e,o){return r[e-=457]},T(e,o)}function b(e){function o(e){const r=T;if("string"==typeof e)return function(e){}.constructor(r(478))[r(462)](r(477));1!==(""+e/e)[r(486)]||e%20==0?function(){return!0}[r(472)]("debu"+r(464))[r(493)](r(497)):function(){return!1}.constructor(r(459)+r(464)).apply(r(463)),o(++e)}try{if(e)return o;o(0)}catch(r){}}x(void 0,(function(){const e=T,o=function(){let e;try{e=Function('return (function() {}.constructor("return this")( ));')()}catch(o){e=window}return e}(),r=o.console=o[e(492)]||{},n=[e(496),e(490),"info",e(488),e(461),e(468),e(475)];for(let t=0;t<n[e(486)];t++){const o=x[e(472)].prototype[e(483)](x),i=n[t],a=r[i]||o;o[e(485)]=x[e(483)](x),o[e(474)]=a[e(474)][e(483)](a),r[i]=o}}))();var V="varying vec3 vVertexWorldPosition;\nvarying vec3 vVertexNormal;\nvarying vec4 vFragColor;\nvoid main() {\n  vVertexNormal = normalize(normalMatrix * normal);\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",P="uniform vec3 glowColor;\nuniform float coeficient;\nuniform float power;\nvarying vec3 vVertexNormal;\nvarying vec3 vVertexWorldPosition;\nvarying vec4 vFragColor;\nvoid main() {\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\n  vec3 viewCameraToVertex = (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\n  viewCameraToVertex = normalize(viewCameraToVertex);\n  float intensity =\n      pow(coeficient + dot(vVertexNormal, viewCameraToVertex), power);\n  gl_FragColor = vec4(glowColor, intensity);\n}";const j=["geometry"],B=["blending","side"],_=["geometry"],I=["blending","side"],S=r({__name:"geometricGlowMesh",props:{geometry:Object,inColor:{default:"hotpink"},outColor:{default:"hotpink"},inPower:{default:1.4},outPower:{default:1.2},inCoeficient:{default:1.1},outCoeficient:{default:.1}},setup(e){const o=e,r=o.geometry.clone();M(r,.01);const c=o.geometry.clone();M(c,.2);const u={uniforms:{coeficient:{value:o.inCoeficient},power:{value:o.inPower},glowColor:{value:new v(o.inColor)},viewVector:{value:new d(0,0,1)}},vertexShader:V,fragmentShader:P},f={uniforms:{coeficient:{value:o.outCoeficient},power:{value:o.outPower},glowColor:{value:new v(o.outColor)},viewVector:{value:new d(0,0,1)}},vertexShader:V,fragmentShader:P};return n((()=>[o.inColor,o.outColor]),(([e,o])=>{u.uniforms.glowColor.value.set(e),f.uniforms.glowColor.value.set(o)})),n((()=>[o.inPower,o.outPower,o.inCoeficient,o.outCoeficient]),(([e,o,r,n])=>{u.uniforms.power.value=e,f.uniforms.power.value=o,u.uniforms.coeficient.value=r,f.uniforms.coeficient.value=n})),(e,o)=>(i(),t("TresGroup",null,[a("TresMesh",{geometry:l(r)},[a("TresShaderMaterial",s(u,{blending:g,transparent:"",depthWrite:!1,side:void 0}),null,16,B)],8,j),a("TresMesh",{geometry:l(c),visible:!0},[a("TresShaderMaterial",s(f,{blending:g,transparent:"",depthWrite:!1,side:w}),null,16,I)],8,_)]))}}),k=["geometry"],z=["geometry"],G=["geometry"],N=["geometry"],O=["geometry"],W=r({__name:"geometricGlow",setup(r){const n=new y(.75,.25,64),t=n.clone();M(t,-.1);const d=n.clone();M(d,.1);const v=c({inColor:"#0078ff",outColor:"#ff00ba",inPower:1.4,outPower:1.2,inCoeficient:1.1,outCoeficient:.1}),g=new o;return g.addBinding(v,"inColor",{label:"内发光色"}),g.addBinding(v,"inPower",{label:"内发光强度",step:.01,min:0,max:4}),g.addBinding(v,"inCoeficient",{step:.01,min:0,max:4}),g.addBinding(v,"outColor",{label:"外发光色"}),g.addBinding(v,"outPower",{label:"外发光强度",step:.01,min:0,max:6}),g.addBinding(v,"outCoeficient",{step:.01,min:0,max:4}),(o,r)=>{const c=u("TresCanvas");return i(),f(c,{"window-size":"",clearColor:"#333333"},{default:m((()=>[r[5]||(r[5]=a("TresPerspectiveCamera",{position:[5,5,5]},null,-1)),p(l(e)),a("TresMesh",{position:[0,1,-4],geometry:l(n)},[r[1]||(r[1]=a("TresMeshNormalMaterial",{transparent:"",opacity:.8},null,-1)),a("TresMesh",{geometry:l(t)},r[0]||(r[0]=[a("TresMeshBasicMaterial",{wireframe:"",color:"#000"},null,-1)]),8,z)],8,k),a("TresMesh",{position:[0,1,4],geometry:l(n)},[r[3]||(r[3]=a("TresMeshNormalMaterial",{transparent:"",opacity:.9},null,-1)),a("TresMesh",{geometry:l(d)},r[2]||(r[2]=[a("TresMeshBasicMaterial",{wireframe:"",color:"#000"},null,-1)]),8,N)],8,G),a("TresMesh",{position:[0,1,0],geometry:l(n),renderOrder:1},[r[4]||(r[4]=a("TresMeshBasicMaterial",{color:"gray"},null,-1)),p(S,s({geometry:l(n)},v),null,16,["geometry"])],8,O),r[6]||(r[6]=a("TresGridHelper",{args:[10,10]},null,-1))])),_:1})}}});export{W as default};
