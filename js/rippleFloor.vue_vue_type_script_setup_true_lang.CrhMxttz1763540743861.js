import{_ as o}from"./@tresjs.BCHtwiaC1763540743861.js";import{d as l,r as e,q as n,w as t,H as i,o as a,J as r}from"./@vue.Co_gxueH1763540743861.js";import{l as f}from"./three.rXKzP9fQ1763540743861.js";const d=["rotation-x"],s=["uniforms"],v=l({__name:"rippleFloor",props:{color:{default:"#ffed00"},flySpeed:{default:3},flyIntensity:{default:.3},dotSize:{default:.03},lineColor:{default:"#66f5ff"},floorColor1:{default:"#4c6480"},floorColor2:{default:"#acb4c0"},gridSize:{default:50},lineWidth:{default:.02},paused:{type:Boolean,default:!1}},setup(l){const v=l,c=e({time:{value:0},color1:{value:new f(v.floorColor1)},color2:{value:new f(v.floorColor2)},lineColor:{value:new f(v.lineColor)},flyLineColor:{value:new f(v.lineColor)},gridSize:{value:v.gridSize},lineWidth:{value:v.lineWidth},flySpeed:{value:v.flySpeed},flyIntensity:{value:v.flyIntensity},dotSize:{value:v.dotSize}}),{onBeforeRender:y}=o();let u=0;y(({delta:o})=>{v.paused||(u+=o,c.time.value=u)});const m=()=>{c.color1.value=new f(v.floorColor1),c.color2.value=new f(v.floorColor2),c.lineColor.value=new f(v.lineColor),c.flyLineColor.value=new f(v.lineColor),c.gridSize.value=v.gridSize,c.lineWidth.value=v.lineWidth,c.flySpeed.value=v.flySpeed,c.flyIntensity.value=v.flyIntensity,c.dotSize.value=v.dotSize};return n(()=>{m()}),t(()=>[v.flySpeed,v.flyIntensity,v.dotSize,v.lineColor,v.floorColor1,v.floorColor2,v.gridSize,v.lineWidth],m),(o,l)=>(a(),i("TresMesh",{"rotation-x":-Math.PI/2},[l[0]||(l[0]=r("TresPlaneGeometry",{args:[10,10]},null,-1)),r("TresShaderMaterial",{uniforms:c,"vertex-shader":"\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n","fragment-shader":"\n    uniform float time;\n    uniform vec3 color1;\n    uniform vec3 color2;\n    uniform vec3 lineColor;\n    uniform vec3 flyLineColor;\n    uniform float gridSize;\n    uniform float lineWidth;\n    uniform float flySpeed;\n    uniform float flyIntensity;\n    uniform float dotSize;\n    varying vec2 vUv;\n    \n    void main() {\n        // 缩放UV以创建网格\n        vec2 scaledUv = vUv * gridSize;\n        \n        // 创建棋盘格图案\n        vec2 cellIndex = floor(scaledUv);\n        float checkValue = mod(cellIndex.x + cellIndex.y, 2.0);\n        vec3 baseColor = (checkValue < 1.0) ? color1 : color2;\n        \n        // 创建基础网格线\n        vec2 gridUv = fract(scaledUv);\n        \n        // 基础垂直线\n        float verticalLine = abs(gridUv.x - 0.5) / fwidth(gridUv.x);\n        float verticalMask = 1.0 - smoothstep(0.0, lineWidth, verticalLine);\n        \n        // 基础水平线\n        float horizontalLine = abs(gridUv.y - 0.5) / fwidth(gridUv.y);\n        float horizontalMask = 1.0 - smoothstep(0.0, lineWidth, horizontalLine);\n        \n        // 组合基础线条\n        float baseLineMask = max(verticalMask, horizontalMask);\n        vec3 colorWithLines = mix(baseColor, lineColor, baseLineMask);\n        \n        // 创建飞线效果\n        // 垂直线飞线\n        float flyVertical = sin(gridUv.y * 6.28 + time * flySpeed) * flyIntensity;\n        float flyVerticalLine = abs(gridUv.x - 0.5 + flyVertical) / fwidth(gridUv.x);\n        float flyVerticalMask = 1.0 - smoothstep(0.0, lineWidth * 0.5, flyVerticalLine);\n        \n        // 水平线飞线\n        float flyHorizontal = sin(gridUv.x * 6.28 + time * flySpeed * 0.7) * flyIntensity;\n        float flyHorizontalLine = abs(gridUv.y - 0.5 + flyHorizontal) / fwidth(gridUv.y);\n        float flyHorizontalMask = 1.0 - smoothstep(0.0, lineWidth * 0.5, flyHorizontalLine);\n        \n        // 组合飞线\n        float flyLineMask = max(flyVerticalMask, flyHorizontalMask);\n        \n        // 添加飞线的发光效果\n        float glowVertical = exp(-flyVerticalLine * 2.0) * 0.3;\n        float glowHorizontal = exp(-flyHorizontalLine * 2.0) * 0.3;\n        float glowMask = max(glowVertical, glowHorizontal);\n        \n        // 创建节点效果 - 在网格正方形的四个顶点\n        float dotRadius = dotSize;\n        float dotFeather = dotSize * 0.3;\n        \n        // 计算到四个顶点的距离\n        vec2 topLeft = vec2(0.0, 0.0);\n        vec2 topRight = vec2(1.0, 0.0);\n        vec2 bottomLeft = vec2(0.0, 1.0);\n        vec2 bottomRight = vec2(1.0, 1.0);\n        \n        float distTopLeft = length(gridUv - topLeft);\n        float distTopRight = length(gridUv - topRight);\n        float distBottomLeft = length(gridUv - bottomLeft);\n        float distBottomRight = length(gridUv - bottomRight);\n        \n        // 找到最近顶点的距离\n        float minDist = min(min(distTopLeft, distTopRight), min(distBottomLeft, distBottomRight));\n        \n        // 在最近顶点附近绘制节点\n        float dotMask = 1.0 - smoothstep(dotRadius - dotFeather, dotRadius + dotFeather, minDist);\n        \n        // 飞线经过节点时的增强效果\n        float nodeGlow = dotMask * flyLineMask * 3.0;\n        \n        // 组合所有效果\n        vec3 finalColor = colorWithLines;\n        \n        // 添加飞线颜色\n        finalColor = mix(finalColor, flyLineColor, flyLineMask);\n        \n        // 添加发光效果\n        finalColor += flyLineColor * glowMask;\n        finalColor += flyLineColor * nodeGlow;\n        \n        // 添加节点 - 使用飞线颜色而不是白色\n        finalColor = mix(finalColor, flyLineColor, dotMask);\n        \n        gl_FragColor = vec4(finalColor, 1.0);\n    }\n",side:2},null,8,s)],8,d))}});export{v as _};
