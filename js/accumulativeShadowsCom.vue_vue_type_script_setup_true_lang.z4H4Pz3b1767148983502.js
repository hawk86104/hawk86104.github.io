import{importShared as g}from"./3d-tiles-renderer.DZNovkLO1767148983502.js";import{Fs as C}from"./index.DTe2qqjO1767148983502.js";import{shaderMaterial as P}from"./shaderMaterial.CBuQXryg1767148983502.js";import{MeshDiscardMaterial as T}from"./customShaderMaterial.vue_vue_type_script_setup_true_lang.B7dQ_CiZ1767148983502.js";const n=await g("three");function L(h){return h.isLight}function _(h){return!!h.geometry}const z=P({color:new n.Color(0),blend:2,alphaTest:.75,opacity:0,map:null},`varying vec2 vUv;
   void main() {
     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
     vUv = uv;
   }`,`varying vec2 vUv;
   uniform sampler2D map;
   uniform vec3 color;
   uniform float opacity;
   uniform float alphaTest;
   uniform float blend;
   void main() {
     vec4 sampledDiffuseColor = texture2D(map, vUv);
     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);
     #include <tonemapping_fragment>
     #include <${parseInt(n.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>
   }`);class E{constructor(e,s,d=1024){this.renderer=e,this.res=d,this.scene=s,this.buffer1Active=!1,this.lights=[],this.meshes=[],this.object=null,this.clearColor=new n.Color,this.clearAlpha=0;const o=/(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent)?n.HalfFloatType:n.FloatType;this.progressiveLightMap1=new n.WebGLRenderTarget(this.res,this.res,{type:o}),this.progressiveLightMap2=new n.WebGLRenderTarget(this.res,this.res,{type:o}),this.discardMat=new T,this.targetMat=new n.MeshLambertMaterial({fog:!1}),this.previousShadowMap={value:this.progressiveLightMap1.texture},this.averagingWindow={value:100},this.targetMat.onBeforeCompile=r=>{r.vertexShader=`varying vec2 vUv;
`+r.vertexShader.slice(0,-1)+"vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";const m=r.fragmentShader.indexOf("void main() {");r.fragmentShader=`varying vec2 vUv;
`+r.fragmentShader.slice(0,m)+`uniform sampler2D previousShadowMap;
	uniform float averagingWindow;
`+r.fragmentShader.slice(m-1,-1)+`
vec3 texelOld = texture2D(previousShadowMap, vUv).rgb;
        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);
      }`,r.uniforms.previousShadowMap=this.previousShadowMap,r.uniforms.averagingWindow=this.averagingWindow}}clear(){this.renderer.getClearColor(this.clearColor),this.clearAlpha=this.renderer.getClearAlpha(),this.renderer.setClearColor("black",1),this.renderer.setRenderTarget(this.progressiveLightMap1),this.renderer.clear(),this.renderer.setRenderTarget(this.progressiveLightMap2),this.renderer.clear(),this.renderer.setRenderTarget(null),this.renderer.setClearColor(this.clearColor,this.clearAlpha),this.lights=[],this.meshes=[],this.scene.traverse(e=>{_(e)?this.meshes.push({object:e,material:e.material}):L(e)&&this.lights.push({object:e,intensity:e.intensity})})}prepare(){this.lights.forEach(e=>e.object.intensity=0),this.meshes.forEach(e=>e.object.material=this.discardMat)}finish(){this.lights.forEach(e=>e.object.intensity=e.intensity),this.meshes.forEach(e=>e.object.material=e.material)}configure(e){this.object=e}update(e,s=100){if(!this.object)return;this.averagingWindow.value=s,this.object.material=this.targetMat;const d=this.buffer1Active?this.progressiveLightMap1:this.progressiveLightMap2,o=this.buffer1Active?this.progressiveLightMap2:this.progressiveLightMap1,r=this.scene.background;this.scene.background=null,this.renderer.setRenderTarget(d),this.previousShadowMap.value=o.texture,this.buffer1Active=!this.buffer1Active,this.renderer.render(this.scene,e),this.renderer.setRenderTarget(null),this.scene.background=r}}const{defineComponent:R}=await g("vue"),{createElementVNode:y,normalizeProps:D,guardReactiveProps:W,openBlock:A,createElementBlock:U}=await g("vue"),k=["rotate-x"],c=await g("three"),{ref:F,watch:u,watchEffect:I,toRaw:B}=await g("vue"),H=R({__name:"accumulativeShadowsCom",props:{opacity:{default:.8},alphaTest:{default:.9},color:{default:"#000000"},blend:{default:2},lightPosition:{default:{x:3,y:5,z:3}},frames:{default:60},blendWindow:{default:100},ambient:{default:.5}},setup(h){const e=h;let s=F();const{extend:d,scene:o,renderer:r,camera:m}=C();d({SoftShadowMaterial:z});const a={position:new c.Vector3().set(e.lightPosition.x,e.lightPosition.y,e.lightPosition.z),radius:1,amount:8,intensity:Math.PI,bias:.001,mapSize:1024,size:8,near:.5,far:200},l=new E(r,o.value,a.mapSize),S={map:l.progressiveLightMap2.texture,transparent:!0,depthWrite:!1,toneMapped:!0,blend:e.blend,alphaTest:e.alphaTest,opacity:e.opacity,color:e.color},p=new c.Group;for(let i=0;i<a.amount;i++){const t=new c.DirectionalLight(16777215,a.intensity/a.amount);t.castShadow=!0,t.shadow.bias=a.bias,t.shadow.camera.near=a.near,t.shadow.camera.far=a.far,t.shadow.camera.right=a.size/2,t.shadow.camera.left=-8/2,t.shadow.camera.top=a.size/2,t.shadow.camera.bottom=-8/2,t.shadow.mapSize.width=a.mapSize,t.shadow.mapSize.height=a.mapSize,p.add(t)}const x=()=>{const i=a.position.length();for(let t=0;t<p.children.length;t++){const M=p.children[t];if(Math.random()>e.ambient)M.position.set(a.position.x+c.MathUtils.randFloatSpread(a.radius),a.position.y+c.MathUtils.randFloatSpread(a.radius),a.position.z+c.MathUtils.randFloatSpread(a.radius));else{let f=Math.acos(2*Math.random()-1)-Math.PI/2,b=2*Math.PI*Math.random();M.position.set(Math.cos(f)*Math.cos(b)*i,Math.abs(Math.cos(f)*Math.sin(b)*i),Math.sin(f)*i)}}},v=(i=1)=>{o.value.add(p),l.prepare();for(let t=0;t<i;t++)x(),l.update(m.value,e.blendWindow),console.log("shadows plm update",t);o.value.remove(p),l.finish()};u(()=>s.value,i=>{i&&(l.configure(B(i)),l.clear(),console.log("shadows render start"),v(e.frames),console.log("shadows render end"))});const w=()=>{l.clear(),v(e.frames)};return I(()=>{s.value&&(e.opacity&&(s.value.material.opacity=e.opacity),e.alphaTest&&(s.value.material.alphaTest=e.alphaTest),e.color&&s.value.material.color.set(e.color),e.blend&&(s.value.material.blend=e.blend))}),u(()=>e.lightPosition,i=>{i&&(console.log(e.lightPosition),a.position.set(i.x,i.y,i.z),w())},{deep:!0}),u(()=>[e.frames,e.blendWindow,e.ambient],()=>{w()}),(i,t)=>(A(),U("TresMesh",{"receive-shadow":"",ref_key:"gPlane",ref:s,scale:10,"rotate-x":-Math.PI/2},[t[0]||(t[0]=y("TresPlaneGeometry",{args:[1,1]},null,-1)),y("TresSoftShadowMaterial",D(W(S)),null,16)],8,k))}});export{H as _sfc_main};
