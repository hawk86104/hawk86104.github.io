import{importShared as e}from"./3d-tiles-renderer.6uaxtGOi1769565599278.js";import{useTextures as r}from"./index.CG-C7MIu1769565599278.js";import{Reflector as t}from"./OimoPhysicsController.5f1-mCmx1769565599278.js";const{withAsyncContext:o,defineComponent:n}=await e("vue"),{unref:a,createElementVNode:l,mergeProps:i,openBlock:m,createElementBlock:f,createCommentVNode:c}=await e("vue"),s={key:0},u=["rotation-x"],v=["object","visible"],{Vector2:p,RepeatWrapping:d,Color:x,GridHelper:g}=await e("three"),{watchEffect:h,ref:C,watch:y,nextTick:M}=await e("vue"),w=n({__name:"reflectorDiffuse",props:{mirror:{default:1},mixStrength:{default:10},showGridHelper:{type:Boolean,default:!0},color:{default:"#ffffff"}},async setup(e){let n,w;const S=e,_=new g(9.5,10),b=C(),j=C(),T=C(),E=new t,k={mirror:{value:S.mirror},mixStrength:{value:S.mixStrength}},{textures:z,isLoading:B}=([n,w]=o(()=>r(["./plugins/floor/image/polished_concrete_basecolor.jpg","./plugins/floor/image/polished_concrete_normal.jpg","./plugins/floor/image/polished_concrete_orm.jpg"])),n=await n,w(),n);let G={};y([B,z],([e,r])=>{if(r&&!e){for(var t=0;t<3;t++)r[t].wrapS=d,r[t].wrapT=d,r[t].repeat.set(16,16);G={color:new x("#444"),metalness:1,roughness:1,map:r[0],metalnessMap:r[2],roughnessMap:r[2],aoMap:r[2],aoMapIntensity:1,normalMap:r[1],normalScale:new p(3,3)},M(()=>{b.value.attributes.uv1=b.value.attributes.uv,T.value.aoMap.channel=1,T.value.onBeforeCompile=N,j.value.add(E),j.value.onBeforeRender=(e,r,t)=>{E.update(e,r,t)}})}});const N=e=>{e.uniforms.reflectMap=E.renderTargetUniform,e.uniforms.textureMatrix=E.textureMatrixUniform,e.uniforms=Object.assign(e.uniforms,k),(e=>{e.vertexShader=e.vertexShader.replace("void main() {","\n\t\tuniform mat4 textureMatrix;\n\t\tout vec4 vCoord;\n\t\tout vec3 vToEye;\n\n\t\tvoid main() {\n\t\t"),e.vertexShader=e.vertexShader.replace("#include <project_vertex>","\n\t\t#include <project_vertex>\n\n\t\tvCoord = textureMatrix * vec4(transformed, 1.0);\n\t\tvToEye = cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz;\n\t\t")})(e),(e=>{e.fragmentShader=e.fragmentShader.replace("void main() {","\n\t\tuniform sampler2D reflectMap;\n\t\tuniform float mirror;\n\t\tuniform float mixStrength;\n\t\tin vec4 vCoord;\n\t\tin vec3 vToEye;\n\n\t\tvoid main() {\n\t\t"),e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>","\n\t\t#include <emissivemap_fragment>\n\n\t\tvec4 normalColor = texture2D(normalMap, vNormalMapUv * normalScale);\n\t\tvec3 reflectNormal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));\n\t\tvec3 reflectCoord = vCoord.xyz / vCoord.w;\n\t\tvec2 reflectUv = reflectCoord.xy + reflectCoord.z * reflectNormal.xz * 0.05;\n\t\tvec4 reflectColor = texture2D(reflectMap, reflectUv);\n\n\t\t// Fresnel term\n\t\tvec3 toEye = normalize(vToEye);\n\t\tfloat theta = max(dot(toEye, normal), 0.0);\n\t\tfloat reflectance = pow((1.0 - theta), 5.0);\n\n\t\treflectColor = mix(vec4(0), reflectColor, reflectance);\n\n\t\tdiffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectColor.rgb * mixStrength);\n\t\t")})(e)};return h(()=>{S.color&&T.value&&(T.value.color=new x(S.color))}),(e,r)=>a(B)?c("",!0):(m(),f("TresGroup",s,[l("TresMesh",{ref_key:"tmRef",ref:j,"rotation-x":-Math.PI/2,"position-y":-.1},[l("TresPlaneGeometry",{ref_key:"tpgRef",ref:b,args:[10,10]},null,512),l("TresMeshStandardMaterial",i({ref_key:"tmsmRef",ref:T},a(G)),null,16)],8,u),l("primitive",{object:a(_),visible:e.showGridHelper},null,8,v)]))}});export{w as _sfc_main};
