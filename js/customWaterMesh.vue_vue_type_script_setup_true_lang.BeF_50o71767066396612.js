import{i as e}from"./3d-tiles-renderer.CbgZh8zU1767066396612.js";import{_ as n}from"./@tresjs.B1f7s3pS1767066396612.js";import{p as t}from"./gl-noise.DADvM2fE1767066396612.js";import{n as a}from"./customShaderMaterial.vue_vue_type_script_setup_true_lang.DS9PWjZT1767066396612.js";import"./index.vue_vue_type_script_setup_true_lang.iYOGhvYh1767066396612.js";const{defineComponent:r}=await e("vue"),{createElementVNode:s,unref:o,createVNode:i,openBlock:l,createElementBlock:g}=await e("vue"),v=["rotation-x"],u=["args"],{watchEffect:c}=await e("vue"),f=await e("three"),h=r({__name:"customWaterMesh",props:{height:{default:.2},Flatshading:{type:Boolean,default:!1},waterColor:{default:"#52a7f7"},waterHighlight:{default:"#b3ffff"},brightness:{default:1},baseMaterial:{default:"MeshPhysicalMaterial"},roughness:{default:.2},metalness:{default:.1},speed:{default:1}},setup(e){const r=e,h={vertex:"\nuniform float uTime;\nuniform float uHeight;\nvarying float vHeight;\n\nvec3 displace(vec3 point) {\n  vec3 p = point;\n  p.y += uTime * 2.0;\n  gln_tFBMOpts fbmOpts = gln_tFBMOpts(1.0, 0.4, 2.3, 0.4, 1.0, 5, false, false);\n  gln_tGerstnerWaveOpts A = gln_tGerstnerWaveOpts(vec2(0.0, -1.0), 0.5, 2.0);\n  gln_tGerstnerWaveOpts B = gln_tGerstnerWaveOpts(vec2(0.0, 1.0), 0.25, 4.0);\n  gln_tGerstnerWaveOpts C = gln_tGerstnerWaveOpts(vec2(1.0, 1.0), 0.15, 6.0);\n  gln_tGerstnerWaveOpts D = gln_tGerstnerWaveOpts(vec2(1.0, 1.0), 0.4, 2.0);\n  vec3 n = vec3(0.0);\n  if(p.z >= uHeight / 2.0) {\n      n.z += gln_normalize(gln_pfbm(p.xy + (uTime * 0.5), fbmOpts));\n      n += gln_GerstnerWave(p, A, uTime).xzy;\n      n += gln_GerstnerWave(p, B, uTime).xzy * 0.5;\n      n += gln_GerstnerWave(p, C, uTime).xzy * 0.25;\n      n += gln_GerstnerWave(p, D, uTime).xzy * 0.2;\n  }\n  vHeight = n.z;\n  return point + n;\n}\n\nvec3 orthogonal(vec3 v) {\n  return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n  : vec3(0.0, -v.z, v.y));\n}\n\nvec3 recalcNormals(vec3 newPos) {\n  float offset = 0.001;\n  vec3 tangent = orthogonal(normal);\n  vec3 bitangent = normalize(cross(normal, tangent));\n  vec3 neighbour1 = position + tangent * offset;\n  vec3 neighbour2 = position + bitangent * offset;\n\n  vec3 displacedNeighbour1 = displace(neighbour1);\n  vec3 displacedNeighbour2 = displace(neighbour2);\n\n  vec3 displacedTangent = displacedNeighbour1 - newPos;\n  vec3 displacedBitangent = displacedNeighbour2 - newPos;\n\n  return normalize(cross(displacedTangent, displacedBitangent));\n}\n\nvoid main() {\n  csm_Position = displace(position);\n  csm_Normal = recalcNormals(csm_Position);\n}\n\t",fragment:"\nvarying float vHeight;\nuniform vec3 waterColor;\nuniform vec3 waterHighlight;\nuniform float offset;\nuniform float contrast;\nuniform float brightness;\n\nvec3 calcColor() {\n  float mask = (pow(vHeight, 2.) - offset) * contrast;\n  vec3 diffuseColor = mix(waterColor, waterHighlight, mask);\n  diffuseColor *= brightness;\n  return diffuseColor;\n}\n\nvoid main() {\n  csm_DiffuseColor = vec4(calcColor(), 1.0);\n}\n\t"},m={uTime:{value:0},waterColor:{value:new f.Color(r.waterColor).convertLinearToSRGB()},waterHighlight:{value:new f.Color(r.waterHighlight).convertLinearToSRGB()},offset:{value:.4},contrast:{value:3.1},brightness:{value:r.brightness},uHeight:{value:r.height}},{onBeforeRender:p}=n();return p(()=>{m.uTime.value-=.002*r.speed}),c(()=>{m.uHeight.value=r.height,m.brightness.value=r.brightness,m.waterColor.value.set(r.waterColor).convertLinearToSRGB(),m.waterHighlight.value.set(r.waterHighlight).convertLinearToSRGB()}),(e,n)=>(l(),g("TresMesh",{"rotation-x":-Math.PI/2},[s("TresBoxGeometry",{args:[5,5,e.height,64,64,1]},null,8,u),i(o(a),{baseMaterial:e.baseMaterial,vertexShader:o(t)(h.vertex),fragmentShader:h.fragment,uniforms:m,side:f.DoubleSide,roughness:e.roughness,metalness:e.metalness,flatShading:e.Flatshading,silent:""},null,8,["baseMaterial","vertexShader","fragmentShader","side","roughness","metalness","flatShading"])],8,v))}});export{h as _};
