import{importShared as e}from"./3d-tiles-renderer.de6b_qgz1767149344623.js";import{Kk as n}from"./index.Btae5S5d1767149344623.js";import{It as o,Kt as a}from"./tresleches.s_Gy9ggt1767149344623.js";const{defineComponent:t}=await e("vue"),{unref:r,createVNode:s,createElementVNode:i,normalizeProps:l,guardReactiveProps:d,resolveComponent:u,mergeProps:m,withCtx:c,Fragment:v,openBlock:h,createElementBlock:p}=await e("vue"),w=["position","a-scale","color","a-randomness"],{BasicShadowMap:f,SRGBColorSpace:g,NoToneMapping:P,Color:C,AdditiveBlending:M,BufferAttribute:b}=await e("three"),{ref:x,watch:y}=await e("vue"),z=t({__name:"galaxy",setup(e){const t={clearColor:"black",shadows:!0,alpha:!1,shadowMapType:f,outputColorSpace:g,toneMapping:P,windowSize:!0},z={count:3e4,size:20,radius:5,branches:5,spin:4,randomness:.13,randomnessPower:7.5,insideColor:"#b5f28d",outsideColor:"#1b3984"},S=new C(z.insideColor),T=new C(z.outsideColor),A=new Float32Array(3*z.count),F=new Float32Array(3*z.count),_=new Float32Array(z.count),j=new Float32Array(3*z.count);for(let n=0;n<z.count;n++){const e=3*n,o=Math.random()*z.radius,a=n%z.branches*Math.PI*2/z.branches;A[e]=Math.cos(a)*o,A[e+1]=0,A[e+2]=Math.sin(a)*o;const t=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),r=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),s=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1);j[e]=t,j[e+1]=r,j[e+2]=s;const i=S.clone();i.lerp(T,o/z.radius),F[e+0]=i.r,F[e+1]=i.g,F[e+2]=i.b,_[n]=Math.random()}const B={transparent:!0,depthWrite:!1,blending:M,vertexColors:!0,vertexShader:"uniform float uSize;\nuniform float uTime;\n\nattribute float aScale;\nattribute vec3 aRandomness;\n\nvarying vec3 vColor;\n\nvoid main() {\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n\n    \n    float angle = atan(modelPosition.x, modelPosition.z);\n    float distanceToCenter = length(modelPosition.xz);\n    float angleOffset = (1.0 / distanceToCenter) * uTime * 0.2;\n    angle += angleOffset;\n\n    modelPosition.x = distanceToCenter * cos(angle);\n    modelPosition.z = distanceToCenter * sin(angle);\n\n    \n    modelPosition.xyz += aRandomness;\n\n    vec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectedPosition = projectionMatrix * viewPosition;\n    gl_Position = projectedPosition;\n\n    gl_PointSize = uSize * aScale;\n\n    \n    gl_PointSize *= ( 1.0 / - viewPosition.z);\n\n    \n    vColor = color;\n\n}",fragmentShader:"varying vec3 vColor;\n\nvoid main()\n{\n    \n    float strength = distance(gl_PointCoord, vec2(0.5));\n    strength = 1.0 - strength;\n    strength = pow(strength, 5.0);\n\n    \n    vec3 color = mix(vec3(0.0), vColor, strength);\n    gl_FragColor = vec4(color, 1.0);\n}",uniforms:{uTime:{value:0},uSize:{value:z.size}}};const R=x(null),k=({elapsed:e})=>{R.value&&(R.value.material.uniforms.uTime.value=e)},{count:E,size:N,radius:O,branches:G,spin:I,randomness:V,randomnessPower:L,insideColor:W,outsideColor:q}=o({count:{value:3e4,min:0,max:1e5,step:1},size:{value:20,min:.01,max:40,step:1},radius:{value:5,min:.1,max:20,step:.01},branches:{value:5,min:2,max:10,step:1},spin:{value:4,min:-5,max:5,step:.01},randomness:{value:.13,min:.1,max:.2,step:.01},randomnessPower:{value:7.5,min:1,max:10,step:.001},insideColor:"#b5f28d",outsideColor:"#1b3984"});return y([E.value,N.value,O.value,G.value,I.value,V.value,L.value,W.value,q.value],e=>{e.forEach((e,n)=>{z[Object.keys(z)[n]]=e.value}),function(){if(R.value){const e=new C(z.insideColor),n=new C(z.outsideColor),o=new Float32Array(3*z.count),a=new Float32Array(3*z.count),t=new Float32Array(z.count),r=new Float32Array(3*z.count);for(let s=0;s<z.count;s++){const i=3*s,l=Math.random()*z.radius,d=s%z.branches*Math.PI*2/z.branches;o[i]=Math.cos(d)*l,o[i+1]=0,o[i+2]=Math.sin(d)*l;const u=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),m=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),c=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1);r[i]=u,r[i+1]=m,r[i+2]=c;const v=e.clone();v.lerp(n,l/z.radius),a[i+0]=v.r,a[i+1]=v.g,a[i+2]=v.b,t[s]=Math.random()}R.value.geometry.setAttribute("position",new b(o,3)),R.value.geometry.setAttribute("aRandomness",new b(r,3)),R.value.geometry.setAttribute("color",new b(a,3)),R.value.geometry.setAttribute("aScale",new b(t,1))}}()}),(e,o)=>{const f=u("TresCanvas");return h(),p(v,null,[s(r(a)),s(f,m(t,{onLoop:k}),{default:c(()=>[o[0]||(o[0]=i("TresPerspectiveCamera",{position:[3,3,3]},null,-1)),i("TresPoints",{ref_key:"bufferRef",ref:R},[i("TresBufferGeometry",{position:[r(A),3],"a-scale":[r(_),1],color:[r(F),3],"a-randomness":[r(j),3]},null,8,w),i("TresShaderMaterial",l(d(B)),null,16)],512),s(r(n))]),_:1},16)],64)}}});export{z as default};
