import{bS as o,q as n,l as e,ae as t,ba as r,n as a,cX as s,cY as i,cZ as l}from"./three.rXKzP9fQ1763540743861.js";import{r as c}from"./utils.DhJ-cORL1763540743861.js";import{d as v,a6 as p,H as m,o as d,J as u,u as f}from"./@vue.Co_gxueH1763540743861.js";const w=["object","rotation-x"],x=["object","rotation-x"],h=v({__name:"regionGlow",props:{positionSrc:{default:[[0,0],[1,1]]},color:{default:"#ffff00"}},setup(v){const h=v,g=new o;h.positionSrc.forEach((o,n)=>{0===n?g.moveTo(o[0],o[1]):g.lineTo(o[0],o[1])});const j=new n({vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    varying vec2 vUv;\n\t\tuniform vec3 color;\n    void main() {\n\t\t\t// 计算距离四条边的最小距离\n        float distance = max(max(vUv.x, -vUv.x), max(vUv.y, -vUv.y));\n\n        // 将距离映射到透明度（从边缘到中心逐渐变透明）\n        float alpha = smoothstep(0.1, 0.9, distance*1.1);\n\n        // 设置最终颜色和透明度\n        gl_FragColor = vec4(color, alpha);\n    }\n  ",transparent:!0,side:t,depthWrite:!1,depthTest:!0,uniforms:{color:{type:"uvs",value:new e(h.color)}}});let U=new r(g);c(U,!0);const b=new a(U,j),y=g.getPoints(),M=new s;M.setPositions(y.flatMap(o=>[o.x,o.y,0]));var P=new i({color:new e(h.color),linewidth:2});const S=new l(M,P);return p(()=>{j.uniforms.color.value=new e(h.color),P.color=new e(h.color)}),(o,n)=>(d(),m("TresGroup",null,[u("primitive",{object:f(b),renderOrder:9999,"rotation-x":Math.PI/2},null,8,w),u("primitive",{object:f(S),renderOrder:9999,"rotation-x":Math.PI/2},null,8,x)]))}});export{h as _};
