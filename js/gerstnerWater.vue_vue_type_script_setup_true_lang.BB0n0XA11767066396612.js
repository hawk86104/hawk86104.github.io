import{i as e}from"./3d-tiles-renderer.CbgZh8zU1767066396612.js";import{ah as t}from"./three.BD1hRFgo1767066396612.js";import{F as n,_ as o}from"./@tresjs.B1f7s3pS1767066396612.js";const{defineComponent:a}=await e("vue"),{unref:r,createElementVNode:i,openBlock:s,createElementBlock:l}=await e("vue"),c=["object","rotation-x"],{watch:u,ref:f}=await e("vue"),v=await e("three"),m=a({__name:"gerstnerWater",props:{distortionScale:{default:3.7},size:{default:1},wireframe:{default:!1},sunDirection:{default:{x:0,y:0,z:0}},sunColor:{default:"#ffffff"},waterColor:{default:"#001e0f"},waves:{type:Object,default:{A:{direction:0,steepness:.4,wavelength:60},B:{direction:30,steepness:.4,wavelength:30},C:{direction:60,steepness:.4,wavelength:15}}},meshUUIDList:{default:()=>[]}},setup(e){const a=e,{scene:m}=n(),d=new v.PlaneGeometry(1024,1024,256,256),p=new t(d,{textureWidth:256,textureHeight:256,waterNormals:(new v.TextureLoader).load("./plugins/water/images/waternormals.jpg",function(e){e.wrapS=e.wrapT=v.RepeatWrapping}),sunDirection:(new v.Vector3).fromArray([a.sunDirection.x,a.sunDirection.y,a.sunDirection.z]),sunColor:a.sunColor,waterColor:a.waterColor,distortionScale:a.distortionScale,fog:void 0!==m.value.fog}),h=f(null);Object.defineProperty(m.value,"environment",{get:()=>h.value,set(e){h.value=e}}),u(h,e=>{console.log("环境贴图变化 :",e),m.value.background=m.value.environment}),p.material.onBeforeCompile=function(e){e.uniforms.waveA={value:[Math.sin(a.waves.A.direction*Math.PI/180),Math.cos(a.waves.A.direction*Math.PI/180),a.waves.A.steepness,a.waves.A.wavelength]},e.uniforms.waveB={value:[Math.sin(a.waves.B.direction*Math.PI/180),Math.cos(a.waves.B.direction*Math.PI/180),a.waves.B.steepness,a.waves.B.wavelength]},e.uniforms.waveC={value:[Math.sin(a.waves.C.direction*Math.PI/180),Math.cos(a.waves.C.direction*Math.PI/180),a.waves.C.steepness,a.waves.C.wavelength]},e.vertexShader="uniform mat4 textureMatrix;\n            uniform float time;\n\n            varying vec4 mirrorCoord;\n            varying vec4 worldPosition;\n\n            #include <common>\n            #include <fog_pars_vertex>\n            #include <shadowmap_pars_vertex>\n            #include <logdepthbuf_pars_vertex>\n\n            uniform vec4 waveA;\n            uniform vec4 waveB;\n            uniform vec4 waveC;\n\n            vec3 GerstnerWave (vec4 wave, vec3 p) {\n            \tfloat steepness = wave.z;\n            \tfloat wavelength = wave.w;\n            \tfloat k = 2.0 * PI / wavelength;\n            \tfloat c = sqrt(9.8 / k);\n            \tvec2 d = normalize(wave.xy);\n            \tfloat f = k * (dot(d, p.xy) - c * time);\n            \tfloat a = steepness / k;\n\n            \treturn vec3(\n            \t\td.x * (a * cos(f)),\n            \t\td.y * (a * cos(f)),\n            \t\ta * sin(f)\n            \t);\n            }\n\n            void main() {\n            \tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n            \tworldPosition = mirrorCoord.xyzw;\n            \tmirrorCoord = textureMatrix * mirrorCoord;\n\n            \tvec3 p = position.xyz;\n            \tp += GerstnerWave(waveA, position.xyz);\n            \tp += GerstnerWave(waveB, position.xyz);\n            \tp += GerstnerWave(waveC, position.xyz);\n            \tgl_Position = projectionMatrix * modelViewMatrix * vec4( p.x, p.y, p.z, 1.0);\n\n            \t#include <beginnormal_vertex>\n            \t#include <defaultnormal_vertex>\n            \t#include <logdepthbuf_vertex>\n            \t#include <fog_vertex>\n            \t#include <shadowmap_vertex>\n            }",e.fragmentShader="uniform sampler2D mirrorSampler;\n            uniform float alpha;\n            uniform float time;\n            uniform float size;\n            uniform float distortionScale;\n            uniform sampler2D normalSampler;\n            uniform vec3 sunColor;\n            uniform vec3 sunDirection;\n            uniform vec3 eye;\n            uniform vec3 waterColor;\n\n            varying vec4 mirrorCoord;\n            varying vec4 worldPosition;\n\n            vec4 getNoise( vec2 uv ) {\n                vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n                vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n                vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n                vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n                vec4 noise = texture2D( normalSampler, uv0 ) +\n                    texture2D( normalSampler, uv1 ) +\n                    texture2D( normalSampler, uv2 ) +\n                    texture2D( normalSampler, uv3 );\n                return noise * 0.5 - 1.0;\n            }\n\n            void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n                vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n                float direction = max( 0.0, dot( eyeDirection, reflection ) );\n                specularColor += pow( direction, shiny ) * sunColor * spec;\n                diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n            }\n\n            #include <common>\n            #include <packing>\n            #include <bsdfs>\n            #include <fog_pars_fragment>\n            #include <logdepthbuf_pars_fragment>\n            #include <lights_pars_begin>\n            #include <shadowmap_pars_fragment>\n            #include <shadowmask_pars_fragment>\n\n            void main() {\n\n                #include <logdepthbuf_fragment>\n                vec4 noise = getNoise( worldPosition.xz * size );\n                vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n                vec3 diffuseLight = vec3(0.0);\n                vec3 specularLight = vec3(0.0);\n\n                vec3 worldToEye = eye-worldPosition.xyz;\n                vec3 eyeDirection = normalize( worldToEye );\n                sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n                float distance = length(worldToEye);\n\n                vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n                vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n                float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n                float rf0 = 0.3;\n                float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n                vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n                vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n                vec3 outgoingLight = albedo;\n                gl_FragColor = vec4( outgoingLight, alpha );\n\n                #include <tonemapping_fragment>\n                #include <fog_fragment>\n            }"},u(()=>[a.size,a.waterColor],([e,t])=>{p.material.uniforms.size.value=e,p.material.uniforms.waterColor.value.set(t)},{immediate:!0}),u(()=>a.wireframe,e=>{p.material.wireframe=e},{immediate:!0}),u(()=>a.waves,e=>{p.material.uniforms.waveA.value=[Math.sin(e.A.direction*Math.PI/180),Math.cos(e.A.direction*Math.PI/180),e.A.steepness,e.A.wavelength],p.material.uniforms.waveB.value=[Math.sin(e.B.direction*Math.PI/180),Math.cos(e.B.direction*Math.PI/180),e.B.steepness,e.B.wavelength],p.material.uniforms.waveC.value=[Math.sin(e.C.direction*Math.PI/180),Math.cos(e.C.direction*Math.PI/180),e.C.steepness,e.C.wavelength]},{deep:!0});const w=[];window.globalTvtFun=window.globalTvtFun||{},window.globalTvtFun.gerstnerWater_updateMeshList=(e=!1)=>{!e&&w.length>0&&a.meshUUIDList.forEach(e=>{const t=m.value.getObjectByProperty("uuid",e.uuid);if(t){const n=w.find(t=>t.mesh.uuid===e.uuid);n&&(t.position.copy(n.defaultPosition),t.quaternion.copy(n.defaultQuaternion))}}),w.length=0,a.meshUUIDList.forEach(e=>{const t=m.value.getObjectByProperty("uuid",e.uuid);if(t){let n=1,o=1;null!=e.floatScale&&""!==e.floatScale&&(n=e.floatScale),null!=e.yOffsetScale&&""!==e.yOffsetScale&&(o=e.yOffsetScale),w.push({mesh:t,floatScale:n,yOffsetScale:o,defaultPosition:t.position.clone(),defaultQuaternion:t.quaternion.clone()})}})},u(()=>a.meshUUIDList,()=>{window.globalTvtFun.gerstnerWater_updateMeshList()},{immediate:!0,deep:!0});const g=new v.Vector3(0,1,0),{onBeforeRender:x}=o();return x(()=>{p.material.uniforms.time.value+=.01,w.forEach(e=>{const t=e.mesh,n=e.floatScale,o=function(e,t,n){const o=new v.Vector3,r=new v.Vector3(1,0,0),i=new v.Vector3(0,0,1);Object.keys(a.waves).forEach(s=>{const l=a.waves[s],c=2*Math.PI/l.wavelength,u=Math.sqrt(9.8/c),f=new v.Vector2(Math.sin(l.direction*Math.PI/180),-Math.cos(l.direction*Math.PI/180)),m=c*(f.dot(new v.Vector2(e,t))-u*n),d=l.steepness/c;o.x+=f.y*(d*Math.cos(m)),o.y+=d*Math.sin(m),o.z+=f.x*(d*Math.cos(m)),r.x+=-f.x*f.x*(l.steepness*Math.sin(m)),r.y+=f.x*(l.steepness*Math.cos(m)),r.z+=-f.x*f.y*(l.steepness*Math.sin(m)),i.x+=-f.x*f.y*(l.steepness*Math.sin(m)),i.y+=f.y*(l.steepness*Math.cos(m)),i.z+=-f.y*f.y*(l.steepness*Math.sin(m))});const s=i.cross(r).normalize();return{position:o,normal:s}}(t.position.x,t.position.z,p.material.uniforms.time.value);t.position.y=o.position.y*e.yOffsetScale;const r=o.normal.clone().normalize(),i=(new v.Quaternion).setFromUnitVectors(g,r);if(1!==n){const e=t.quaternion.clone();i.slerp(e,1-n)}t.quaternion.slerp(i,.01*e.floatScale)})}),(e,t)=>(s(),l("TresGroup",null,[i("primitive",{object:r(p),"rotation-x":-Math.PI/2},null,8,c)]))}});export{m as _};
