import{importShared as e}from"./3d-tiles-renderer.HXNTGnH81769411460564.js";import"./vanilla-BEVDQrzM.DgQsv1MD1769411460564.js";import"./three-custom-shader-material.es.CqetooVN1769411460564.js";import"./skyBoxAmesh.vue_vue_type_script_setup_true_lang.Dng8MRvD1769411460564.js";import"./skyBoxBmesh.vue_vue_type_script_setup_true_lang.D180uWQe1769411460564.js";import"./skyBoxDmesh.vue_vue_type_script_setup_true_lang.yT4Qp36q1769411460564.js";import{version as t,useTresContext as n,useTres as o}from"./index.KfH1904l1769411460564.js";import{unzlibSync as r}from"./Resource.Blvw6ekq1769411460564.js";import{loadHDR as i}from"./utils.DNtVK_2l1769411460564.js";const{Mesh:a,IcosahedronGeometry:s,ShaderMaterial:l,DoubleSide:c}=await e("three");class u extends a{constructor(e,n){var o,r;const i=(a=e)&&a.isCubeTexture;var a;const u=(null!=(r=i?null==(o=e.image[0])?void 0:o.width:e.image.width)?r:1024)/4,f=Math.floor(Math.log2(u)),h=Math.pow(2,f),d=[i?"#define ENVMAP_TYPE_CUBE":"","#define CUBEUV_TEXEL_WIDTH "+1/(3*Math.max(h,112)),"#define CUBEUV_TEXEL_HEIGHT "+1/(4*h),`#define CUBEUV_MAX_MIP ${f}.0`].join("\n")+`\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${t>=154?"colorspace_fragment":"encodings_fragment"}>\n        }\n        `,p={map:{value:e},height:{value:(null==n?void 0:n.height)||15},radius:{value:(null==n?void 0:n.radius)||100}};super(new s(1,16),new l({uniforms:p,fragmentShader:d,vertexShader:"\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        ",side:c}))}set radius(e){this.material.uniforms.radius.value=e}get radius(){return this.material.uniforms.radius.value}set height(e){this.material.uniforms.height.value=e}get height(){return this.material.uniforms.height.value}}const{DataTextureLoader:f,DataUtils:h,FloatType:d,HalfFloatType:p,LinearFilter:m,LinearSRGBColorSpace:w,RedFormat:v,RGFormat:y,RGBAFormat:g}=await e("three");class E extends f{constructor(e){super(e),this.type=p,this.outputFormat=g}parse(e){const t=65536,n=14,o=65537,i=16384,a=Math.pow(2.7182818,2.2);const s={l:0,c:0,lc:0};function l(e,t,n,o,r){for(;n<e;)t=t<<8|$(o,r),n+=8;n-=e,s.l=t>>n&(1<<e)-1,s.c=t,s.lc=n}const c=new Array(59);function u(e,t,n,r,i,a){const u=t;let f=0,h=0;for(;r<=i;r++){if(u.value-t.value>n)return!1;l(6,f,h,e,u);const o=s.l;if(f=s.c,h=s.lc,a[r]=o,63==o){if(u.value-t.value>n)throw new Error("Something wrong with hufUnpackEncTable");l(8,f,h,e,u);let o=s.l+6;if(f=s.c,h=s.lc,r+o>i+1)throw new Error("Something wrong with hufUnpackEncTable");for(;o--;)a[r++]=0;r--}else if(o>=59){let e=o-59+2;if(r+e>i+1)throw new Error("Something wrong with hufUnpackEncTable");for(;e--;)a[r++]=0;r--}}!function(e){for(let n=0;n<=58;++n)c[n]=0;for(let n=0;n<o;++n)c[e[n]]+=1;let t=0;for(let n=58;n>0;--n){const e=t+c[n]>>1;c[n]=t,t=e}for(let n=0;n<o;++n){const t=e[n];t>0&&(e[n]=t|c[t]++<<6)}}(a)}function f(e){return 63&e}function m(e){return e>>6}const E={c:0,lc:0};function b(e,t,n,o){e=e<<8|$(n,o),t+=8,E.c=e,E.lc=t}const _={c:0,lc:0};function C(e,t,n,o,r,i,a,s,l){if(e==t){o<8&&(b(n,o,r,i),n=E.c,o=E.lc);let e=n>>(o-=8);if(e=new Uint8Array([e])[0],s.value+e>l)return!1;const t=a[s.value-1];for(;e-- >0;)a[s.value++]=t}else{if(!(s.value<l))return!1;a[s.value++]=e}_.c=n,_.lc=o}function A(e){return 65535&e}function S(e){const t=A(e);return t>32767?t-65536:t}const M={a:0,b:0};function k(e,t){const n=S(e),o=S(t),r=n+(1&o)+(o>>1),i=r,a=r-o;M.a=i,M.b=a}function U(e,t){const n=A(e),o=A(t),r=n-(o>>1)&65535,i=o+r-32768&65535;M.a=i,M.b=r}function x(e,t,n,o,r,i,a){const s=a<16384,l=n>r?r:n;let c,u,f=1;for(;f<=l;)f<<=1;for(f>>=1,c=f,f>>=1;f>=1;){u=0;const a=u+i*(r-c),l=i*f,h=i*c,d=o*f,p=o*c;let m,w,v,y;for(;u<=a;u+=h){let r=u;const i=u+o*(n-c);for(;r<=i;r+=p){const n=r+d,o=r+l,i=o+d;s?(k(e[r+t],e[o+t]),m=M.a,v=M.b,k(e[n+t],e[i+t]),w=M.a,y=M.b,k(m,w),e[r+t]=M.a,e[n+t]=M.b,k(v,y),e[o+t]=M.a,e[i+t]=M.b):(U(e[r+t],e[o+t]),m=M.a,v=M.b,U(e[n+t],e[i+t]),w=M.a,y=M.b,U(m,w),e[r+t]=M.a,e[n+t]=M.b,U(v,y),e[o+t]=M.a,e[i+t]=M.b)}if(n&f){const n=r+l;s?k(e[r+t],e[n+t]):U(e[r+t],e[n+t]),m=M.a,e[n+t]=M.b,e[r+t]=m}}if(r&f){let r=u;const i=u+o*(n-c);for(;r<=i;r+=p){const n=r+d;s?k(e[r+t],e[n+t]):U(e[r+t],e[n+t]),m=M.a,e[n+t]=M.b,e[r+t]=m}}c=f,f>>=1}return u}function P(e,t,r,a,s,l){const c=r.value,h=q(t,r),d=q(t,r);r.value+=4;const p=q(t,r);if(r.value+=4,h<0||h>=o||d<0||d>=o)throw new Error("Something wrong with HUF_ENCSIZE");const w=new Array(o),v=new Array(i);!function(e){for(let t=0;t<i;t++)e[t]={},e[t].len=0,e[t].lit=0,e[t].p=null}(v);if(u(e,r,a-(r.value-c),h,d,w),p>8*(a-(r.value-c)))throw new Error("Something wrong with hufUncompress");!function(e,t,o,r){for(;t<=o;t++){const o=m(e[t]),i=f(e[t]);if(o>>i)throw new Error("Invalid table entry");if(i>n){const e=r[o>>i-n];if(e.len)throw new Error("Invalid table entry");if(e.lit++,e.p){const t=e.p;e.p=new Array(e.lit);for(let n=0;n<e.lit-1;++n)e.p[n]=t[n]}else e.p=new Array(1);e.p[e.lit-1]=t}else if(i){let e=0;for(let a=1<<n-i;a>0;a--){const a=r[(o<<n-i)+e];if(a.len||a.p)throw new Error("Invalid table entry");a.len=i,a.lit=t,e++}}}}(w,h,d,v),function(e,t,o,r,i,a,s,l,c){let u=0,h=0;const d=s,p=Math.trunc(r.value+(i+7)/8);for(;r.value<p;)for(b(u,h,o,r),u=E.c,h=E.lc;h>=n;){const i=t[u>>h-n&16383];if(i.len)h-=i.len,C(i.lit,a,u,h,o,r,l,c,d),u=_.c,h=_.lc;else{if(!i.p)throw new Error("hufDecode issues");let t;for(t=0;t<i.lit;t++){const n=f(e[i.p[t]]);for(;h<n&&r.value<p;)b(u,h,o,r),u=E.c,h=E.lc;if(h>=n&&m(e[i.p[t]])==(u>>h-n&(1<<n)-1)){h-=n,C(i.p[t],a,u,h,o,r,l,c,d),u=_.c,h=_.lc;break}}if(t==i.lit)throw new Error("hufDecode issues")}}const w=8-i&7;for(u>>=w,h-=w;h>0;){const e=t[u<<n-h&16383];if(!e.len)throw new Error("hufDecode issues");h-=e.len,C(e.lit,a,u,h,o,r,l,c,d),u=_.c,h=_.lc}}(w,v,e,r,p,d,l,s,{value:0})}function R(e){for(let t=1;t<e.length;t++){const n=e[t-1]+e[t]-128;e[t]=n}}function O(e,t){let n=0,o=Math.floor((e.length+1)/2),r=0;const i=e.length-1;for(;!(r>i||(t[r++]=e[n++],r>i));)t[r++]=e[o++]}function I(e){let t=e.byteLength;const n=new Array;let o=0;const r=new DataView(e);for(;t>0;){const e=r.getInt8(o++);if(e<0){const i=-e;t-=i+1;for(let e=0;e<i;e++)n.push(r.getUint8(o++))}else{const i=e;t-=2;const a=r.getUint8(o++);for(let e=0;e<i+1;e++)n.push(a)}}return n}function B(e,t,n,o,r,i){const a=new DataView(i.buffer),s=n[e],l=s.width,c=s.height,u=Math.ceil(l/8),f=Math.ceil(c/8),h=Math.floor(l/8),d=l-8*(u-1),p=c-8*(f-1),m={value:0};let w=0;const v=new Float32Array(64),y=new Uint16Array(64),g=new Uint16Array(64*u);for(let E=0;E<f;++E){let n=8;E==f-1&&(n=p);for(let e=0;e<u;++e)y.fill(0),y[0]=r[w++],z(m,o,y),N(y,v),L(v),T(v,g,64*e);for(let o=8*E;o<8*E+n;++o){let n=t[e][o];for(let e=0;e<h;++e){const t=64*e+8*(7&o);for(let e=0;e<8;++e)a.setUint16(n+2*e*s.type,g[t+e],!0);n+=16*s.type}if(u!=h){const e=64*h+8*(7&o);for(let t=0;t<d;++t)a.setUint16(n+2*t*s.type,g[e+t],!0)}}}s.decoded=!0}function z(e,t,n){let o,r=1;for(;r<64;)o=t[e.value],65280==o?r=64:o>>8==255?r+=255&o:(n[r]=o,r++),e.value++}function N(e,t){t[0]=te(e[0]),t[1]=te(e[1]),t[2]=te(e[5]),t[3]=te(e[6]),t[4]=te(e[14]),t[5]=te(e[15]),t[6]=te(e[27]),t[7]=te(e[28]),t[8]=te(e[2]),t[9]=te(e[4]),t[10]=te(e[7]),t[11]=te(e[13]),t[12]=te(e[16]),t[13]=te(e[26]),t[14]=te(e[29]),t[15]=te(e[42]),t[16]=te(e[3]),t[17]=te(e[8]),t[18]=te(e[12]),t[19]=te(e[17]),t[20]=te(e[25]),t[21]=te(e[30]),t[22]=te(e[41]),t[23]=te(e[43]),t[24]=te(e[9]),t[25]=te(e[11]),t[26]=te(e[18]),t[27]=te(e[24]),t[28]=te(e[31]),t[29]=te(e[40]),t[30]=te(e[44]),t[31]=te(e[53]),t[32]=te(e[10]),t[33]=te(e[19]),t[34]=te(e[23]),t[35]=te(e[32]),t[36]=te(e[39]),t[37]=te(e[45]),t[38]=te(e[52]),t[39]=te(e[54]),t[40]=te(e[20]),t[41]=te(e[22]),t[42]=te(e[33]),t[43]=te(e[38]),t[44]=te(e[46]),t[45]=te(e[51]),t[46]=te(e[55]),t[47]=te(e[60]),t[48]=te(e[21]),t[49]=te(e[34]),t[50]=te(e[37]),t[51]=te(e[47]),t[52]=te(e[50]),t[53]=te(e[56]),t[54]=te(e[59]),t[55]=te(e[61]),t[56]=te(e[35]),t[57]=te(e[36]),t[58]=te(e[48]),t[59]=te(e[49]),t[60]=te(e[57]),t[61]=te(e[58]),t[62]=te(e[62]),t[63]=te(e[63])}function L(e){const t=.5*Math.cos(.7853975),n=.5*Math.cos(3.14159/16),o=.5*Math.cos(3.14159/8),r=.5*Math.cos(3*3.14159/16),i=.5*Math.cos(.981746875),a=.5*Math.cos(3*3.14159/8),s=.5*Math.cos(1.374445625),l=new Array(4),c=new Array(4),u=new Array(4),f=new Array(4);for(let h=0;h<8;++h){const d=8*h;l[0]=o*e[d+2],l[1]=a*e[d+2],l[2]=o*e[d+6],l[3]=a*e[d+6],c[0]=n*e[d+1]+r*e[d+3]+i*e[d+5]+s*e[d+7],c[1]=r*e[d+1]-s*e[d+3]-n*e[d+5]-i*e[d+7],c[2]=i*e[d+1]-n*e[d+3]+s*e[d+5]+r*e[d+7],c[3]=s*e[d+1]-i*e[d+3]+r*e[d+5]-n*e[d+7],u[0]=t*(e[d+0]+e[d+4]),u[3]=t*(e[d+0]-e[d+4]),u[1]=l[0]+l[3],u[2]=l[1]-l[2],f[0]=u[0]+u[1],f[1]=u[3]+u[2],f[2]=u[3]-u[2],f[3]=u[0]-u[1],e[d+0]=f[0]+c[0],e[d+1]=f[1]+c[1],e[d+2]=f[2]+c[2],e[d+3]=f[3]+c[3],e[d+4]=f[3]-c[3],e[d+5]=f[2]-c[2],e[d+6]=f[1]-c[1],e[d+7]=f[0]-c[0]}for(let h=0;h<8;++h)l[0]=o*e[16+h],l[1]=a*e[16+h],l[2]=o*e[48+h],l[3]=a*e[48+h],c[0]=n*e[8+h]+r*e[24+h]+i*e[40+h]+s*e[56+h],c[1]=r*e[8+h]-s*e[24+h]-n*e[40+h]-i*e[56+h],c[2]=i*e[8+h]-n*e[24+h]+s*e[40+h]+r*e[56+h],c[3]=s*e[8+h]-i*e[24+h]+r*e[40+h]-n*e[56+h],u[0]=t*(e[h]+e[32+h]),u[3]=t*(e[h]-e[32+h]),u[1]=l[0]+l[3],u[2]=l[1]-l[2],f[0]=u[0]+u[1],f[1]=u[3]+u[2],f[2]=u[3]-u[2],f[3]=u[0]-u[1],e[0+h]=f[0]+c[0],e[8+h]=f[1]+c[1],e[16+h]=f[2]+c[2],e[24+h]=f[3]+c[3],e[32+h]=f[3]-c[3],e[40+h]=f[2]-c[2],e[48+h]=f[1]-c[1],e[56+h]=f[0]-c[0]}function D(e){for(let t=0;t<64;++t){const n=e[0][t],o=e[1][t],r=e[2][t];e[0][t]=n+1.5747*r,e[1][t]=n-.1873*o-.4682*r,e[2][t]=n+1.8556*o}}function T(e,t,n){for(let o=0;o<64;++o)t[n+o]=h.toHalfFloat(H(e[o]))}function H(e){return e<=1?Math.sign(e)*Math.pow(Math.abs(e),2.2):Math.sign(e)*Math.pow(a,Math.abs(e)-1)}function V(e){return new DataView(e.array.buffer,e.offset.value,e.size)}function W(e){const t=e.viewer.buffer.slice(e.offset.value,e.offset.value+e.size),n=new Uint8Array(I(t)),o=new Uint8Array(n.length);return R(n),O(n,o),new DataView(o.buffer)}function F(e){const t=e.array.slice(e.offset.value,e.offset.value+e.size),n=r(t),o=new Uint8Array(n.length);return R(n),O(n,o),new DataView(o.buffer)}function X(e){const n=e.viewer,o={value:e.offset.value},r=new Uint16Array(e.columns*e.lines*(e.inputChannels.length*e.type)),i=new Uint8Array(8192);let a=0;const s=new Array(e.inputChannels.length);for(let t=0,m=e.inputChannels.length;t<m;t++)s[t]={},s[t].start=a,s[t].end=s[t].start,s[t].nx=e.columns,s[t].ny=e.lines,s[t].size=e.type,a+=s[t].nx*s[t].ny*s[t].size;const l=ne(n,o),c=ne(n,o);if(c>=8192)throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");if(l<=c)for(let t=0;t<c-l+1;t++)i[t+l]=Q(n,o);const u=new Uint16Array(t),f=function(e,n){let o=0;for(let i=0;i<t;++i)(0==i||e[i>>3]&1<<(7&i))&&(n[o++]=i);const r=o-1;for(;o<t;)n[o++]=0;return r}(i,u),h=q(n,o);P(e.array,n,o,h,r,a);for(let t=0;t<e.inputChannels.length;++t){const e=s[t];for(let n=0;n<s[t].size;++n)x(r,e.start+n,e.nx,e.size,e.ny,e.nx*e.size,f)}!function(e,t,n){for(let o=0;o<n;++o)t[o]=e[t[o]]}(u,r,a);let d=0;const p=new Uint8Array(r.buffer.byteLength);for(let t=0;t<e.lines;t++)for(let n=0;n<e.inputChannels.length;n++){const e=s[n],t=e.nx*e.size,o=new Uint8Array(r.buffer,2*e.end,2*t);p.set(o,d),d+=2*t,e.end+=t}return new DataView(p.buffer)}function j(e){const t=e.array.slice(e.offset.value,e.offset.value+e.size),n=r(t),o=e.inputChannels.length*e.lines*e.columns*e.totalBytes,i=new ArrayBuffer(o),a=new DataView(i);let s=0,l=0;const c=new Array(4);for(let r=0;r<e.lines;r++)for(let t=0;t<e.inputChannels.length;t++){let o=0;switch(e.inputChannels[t].pixelType){case 1:c[0]=s,c[1]=c[0]+e.columns,s=c[1]+e.columns;for(let t=0;t<e.columns;++t){o+=n[c[0]++]<<8|n[c[1]++],a.setUint16(l,o,!0),l+=2}break;case 2:c[0]=s,c[1]=c[0]+e.columns,c[2]=c[1]+e.columns,s=c[2]+e.columns;for(let t=0;t<e.columns;++t){o+=n[c[0]++]<<24|n[c[1]++]<<16|n[c[2]++]<<8,a.setUint32(l,o,!0),l+=4}}}return a}function Y(e){const t=e.viewer,n={value:e.offset.value},o=new Uint8Array(e.columns*e.lines*(e.inputChannels.length*e.type*2)),i={version:J(t,n),unknownUncompressedSize:J(t,n),unknownCompressedSize:J(t,n),acCompressedSize:J(t,n),dcCompressedSize:J(t,n),rleCompressedSize:J(t,n),rleUncompressedSize:J(t,n),rleRawSize:J(t,n),totalAcUncompressedCount:J(t,n),totalDcUncompressedCount:J(t,n),acCompression:J(t,n)};if(i.version<2)throw new Error("EXRLoader.parse: "+he.compression+" version "+i.version+" is unsupported");const a=new Array;let s=ne(t,n)-2;for(;s>0;){const e=G(t.buffer,n),o=Q(t,n),r=o>>2&3,i=new Int8Array([(o>>4)-1])[0],l=Q(t,n);a.push({name:e,index:i,type:l,compression:r}),s-=e.length+3}const l=he.channels,c=new Array(e.inputChannels.length);for(let r=0;r<e.inputChannels.length;++r){const t=c[r]={},n=l[r];t.name=n.name,t.compression=0,t.decoded=!1,t.type=n.pixelType,t.pLinear=n.pLinear,t.width=e.columns,t.height=e.lines}const u={idx:new Array(3)};for(let r=0;r<e.inputChannels.length;++r){const e=c[r];for(let t=0;t<a.length;++t){const n=a[t];e.name==n.name&&(e.compression=n.compression,n.index>=0&&(u.idx[n.index]=r),e.offset=r)}}let f,h,d;if(i.acCompressedSize>0)switch(i.acCompression){case 0:f=new Uint16Array(i.totalAcUncompressedCount),P(e.array,t,n,i.acCompressedSize,f,i.totalAcUncompressedCount);break;case 1:const o=e.array.slice(n.value,n.value+i.totalAcUncompressedCount),a=r(o);f=new Uint16Array(a.buffer),n.value+=i.totalAcUncompressedCount}if(i.dcCompressedSize>0){const t={array:e.array,offset:n,size:i.dcCompressedSize};h=new Uint16Array(F(t).buffer),n.value+=i.dcCompressedSize}if(i.rleRawSize>0){const t=e.array.slice(n.value,n.value+i.rleCompressedSize);d=I(r(t).buffer),n.value+=i.rleCompressedSize}let p=0;const m=new Array(c.length);for(let r=0;r<m.length;++r)m[r]=new Array;for(let r=0;r<e.lines;++r)for(let t=0;t<c.length;++t)m[t].push(p),p+=c[t].width*e.type*2;void 0!==u.idx[0]&&c[u.idx[0]]&&function(e,t,n,o,r,i){let a=new DataView(i.buffer);const s=n[e.idx[0]].width,l=n[e.idx[0]].height,c=Math.floor(s/8),u=Math.ceil(s/8),f=Math.ceil(l/8),h=s-8*(u-1),d=l-8*(f-1),p={value:0},m=new Array(3),w=new Array(3),v=new Array(3),y=new Array(3),g=new Array(3);for(let b=0;b<3;++b)g[b]=t[e.idx[b]],m[b]=b<1?0:m[b-1]+u*f,w[b]=new Float32Array(64),v[b]=new Uint16Array(64),y[b]=new Uint16Array(64*u);for(let b=0;b<f;++b){let t=8;b==f-1&&(t=d);let i=8;for(let e=0;e<u;++e){e==u-1&&(i=h);for(let e=0;e<3;++e)v[e].fill(0),v[e][0]=r[m[e]++],z(p,o,v[e]),N(v[e],w[e]),L(w[e]);D(w);for(let t=0;t<3;++t)T(w[t],y[t],64*e)}let s=0;for(let o=0;o<3;++o){const r=n[e.idx[o]].type;for(let e=8*b;e<8*b+t;++e){s=g[o][e];for(let t=0;t<c;++t){const n=64*t+8*(7&e);a.setUint16(s+0*r,y[o][n+0],!0),a.setUint16(s+2*r,y[o][n+1],!0),a.setUint16(s+4*r,y[o][n+2],!0),a.setUint16(s+6*r,y[o][n+3],!0),a.setUint16(s+8*r,y[o][n+4],!0),a.setUint16(s+10*r,y[o][n+5],!0),a.setUint16(s+12*r,y[o][n+6],!0),a.setUint16(s+14*r,y[o][n+7],!0),s+=16*r}}if(c!=u)for(let e=8*b;e<8*b+t;++e){const t=g[o][e]+8*c*2*r,n=64*c+8*(7&e);for(let e=0;e<i;++e)a.setUint16(t+2*e*r,y[o][n+e],!0)}}}const E=new Uint16Array(s);a=new DataView(i.buffer);for(let b=0;b<3;++b){n[e.idx[b]].decoded=!0;const t=n[e.idx[b]].type;if(2==n[b].type)for(let e=0;e<l;++e){const n=g[b][e];for(let e=0;e<s;++e)E[e]=a.getUint16(n+2*e*t,!0);for(let e=0;e<s;++e)a.setFloat32(n+2*e*t,te(E[e]),!0)}}}(u,m,c,f,h,o);for(let r=0;r<c.length;++r){const t=c[r];if(!t.decoded)switch(t.compression){case 2:let n=0,i=0;for(let a=0;a<e.lines;++a){let e=m[r][n];for(let n=0;n<t.width;++n){for(let n=0;n<2*t.type;++n)o[e++]=d[i+n*t.width*t.height];i++}n++}break;case 1:B(r,m,c,f,h,o);break;default:throw new Error("EXRLoader.parse: unsupported channel compression")}}return new DataView(o.buffer)}function G(e,t){const n=new Uint8Array(e);let o=0;for(;0!=n[t.value+o];)o+=1;const r=(new TextDecoder).decode(n.slice(t.value,t.value+o));return t.value=t.value+o+1,r}function Z(e,t){const n=e.getInt32(t.value,!0);return t.value=t.value+4,n}function q(e,t){const n=e.getUint32(t.value,!0);return t.value=t.value+4,n}function $(e,t){const n=e[t.value];return t.value=t.value+1,n}function Q(e,t){const n=e.getUint8(t.value);return t.value=t.value+1,n}const J=function(e,t){let n;return n="getBigInt64"in DataView.prototype?Number(e.getBigInt64(t.value,!0)):e.getUint32(t.value+4,!0)+Number(e.getUint32(t.value,!0)<<32),t.value+=8,n};function K(e,t){const n=e.getFloat32(t.value,!0);return t.value+=4,n}function ee(e,t){return h.toHalfFloat(K(e,t))}function te(e){const t=(31744&e)>>10,n=1023&e;return(e>>15?-1:1)*(t?31===t?n?NaN:1/0:Math.pow(2,t-15)*(1+n/1024):n/1024*6103515625e-14)}function ne(e,t){const n=e.getUint16(t.value,!0);return t.value+=2,n}function oe(e,t){return te(ne(e,t))}function re(e,t,n,o,r){return"string"===o||"stringvector"===o||"iccProfile"===o?function(e,t,n){const o=(new TextDecoder).decode(new Uint8Array(e).slice(t.value,t.value+n));return t.value=t.value+n,o}(t,n,r):"chlist"===o?function(e,t,n,o){const r=n.value,i=[];for(;n.value<r+o-1;){const o=G(t,n),r=Z(e,n),a=Q(e,n);n.value+=3;const s=Z(e,n),l=Z(e,n);i.push({name:o,pixelType:r,pLinear:a,xSampling:s,ySampling:l})}return n.value+=1,i}(e,t,n,r):"chromaticities"===o?function(e,t){return{redX:K(e,t),redY:K(e,t),greenX:K(e,t),greenY:K(e,t),blueX:K(e,t),blueY:K(e,t),whiteX:K(e,t),whiteY:K(e,t)}}(e,n):"compression"===o?function(e,t){return["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"][Q(e,t)]}(e,n):"box2i"===o?function(e,t){return{xMin:Z(e,t),yMin:Z(e,t),xMax:Z(e,t),yMax:Z(e,t)}}(e,n):"envmap"===o?function(e,t){return["ENVMAP_LATLONG","ENVMAP_CUBE"][Q(e,t)]}(e,n):"tiledesc"===o?function(e,t){const n=q(e,t),o=q(e,t),r=Q(e,t);return{xSize:n,ySize:o,levelMode:["ONE_LEVEL","MIPMAP_LEVELS","RIPMAP_LEVELS"][15&r],roundingMode:["ROUND_DOWN","ROUND_UP"][r>>4]}}(e,n):"lineOrder"===o?function(e,t){return["INCREASING_Y","DECREASING_Y","RANDOM_Y"][Q(e,t)]}(e,n):"float"===o?K(e,n):"v2f"===o?function(e,t){return[K(e,t),K(e,t)]}(e,n):"v3f"===o?function(e,t){return[K(e,t),K(e,t),K(e,t)]}(e,n):"int"===o?Z(e,n):"rational"===o?function(e,t){return[Z(e,t),q(e,t)]}(e,n):"timecode"===o?function(e,t){return[q(e,t),q(e,t)]}(e,n):"preview"===o?(n.value+=r,"skipped"):void(n.value+=r)}function ie(e,t,n){let o=0;switch(e.levelMode){case"ONE_LEVEL":o=1;break;case"MIPMAP_LEVELS":o=function(e,t){const n=Math.log2(e);return"ROUND_DOWN"==t?Math.floor(n):Math.ceil(n)}(Math.max(t,n),e.roundingMode)+1;break;case"RIPMAP_LEVELS":throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.")}return o}function ae(e,t,n,o){const r=new Array(e);for(let i=0;i<e;i++){const e=1<<i;let a=t/e|0;"ROUND_UP"==o&&a*e<t&&(a+=1);const s=Math.max(a,1);r[i]=(s+n-1)/n|0}return r}function se(){const e=this,t=e.offset,n={value:0};for(let o=0;o<e.tileCount;o++){const o=Z(e.viewer,t),r=Z(e.viewer,t);t.value+=8,e.size=q(e.viewer,t);const i=o*e.blockWidth,a=r*e.blockHeight;e.columns=i+e.blockWidth>e.width?e.width-i:e.blockWidth,e.lines=a+e.blockHeight>e.height?e.height-a:e.blockHeight;const s=e.columns*e.totalBytes,l=e.size<e.lines*s?e.uncompress(e):V(e);t.value+=e.size;for(let t=0;t<e.lines;t++){const o=t*e.columns*e.totalBytes;for(let r=0;r<e.inputChannels.length;r++){const s=he.channels[r].name,c=e.channelByteOffsets[s]*e.columns,u=e.decodeChannels[s];if(void 0===u)continue;n.value=o+c;const f=(e.height-(1+a+t))*e.outLineWidth;for(let t=0;t<e.columns;t++){const o=f+(t+i)*e.outputChannels+u;e.byteArray[o]=e.getter(l,n)}}}}}function le(){const e=this,t=e.offset,n={value:0};for(let o=0;o<e.height/e.blockHeight;o++){const r=Z(e.viewer,t)-he.dataWindow.yMin;e.size=q(e.viewer,t),e.lines=r+e.blockHeight>e.height?e.height-r:e.blockHeight;const i=e.columns*e.totalBytes,a=e.size<e.lines*i?e.uncompress(e):V(e);t.value+=e.size;for(let t=0;t<e.blockHeight;t++){const r=o*e.blockHeight,s=t+e.scanOrder(r);if(s>=e.height)continue;const l=t*i,c=(e.height-1-s)*e.outLineWidth;for(let t=0;t<e.inputChannels.length;t++){const o=he.channels[t].name,r=e.channelByteOffsets[o]*e.columns,i=e.decodeChannels[o];if(void 0!==i){n.value=l+r;for(let t=0;t<e.columns;t++){const o=c+t*e.outputChannels+i;e.byteArray[o]=e.getter(a,n)}}}}}}const ce={value:0},ue=new DataView(e),fe=new Uint8Array(e),he=function(e,t,n){const o={};if(20000630!=e.getUint32(0,!0))throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");o.version=e.getUint8(4);const r=e.getUint8(5);o.spec={singleTile:!!(2&r),longName:!!(4&r),deepFormat:!!(8&r),multiPart:!!(16&r)},n.value=8;let i=!0;for(;i;){const r=G(t,n);if(""===r)i=!1;else{const i=G(t,n),a=re(e,t,n,i,q(e,n));void 0===a?console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${i}'.`):o[r]=a}}if(-7&r)throw console.error("THREE.EXRHeader:",o),new Error("THREE.EXRLoader: Provided file is currently unsupported.");return o}(ue,e,ce),de=function(e,t,n,o,r,i){const a={size:0,viewer:t,array:n,offset:o,width:e.dataWindow.xMax-e.dataWindow.xMin+1,height:e.dataWindow.yMax-e.dataWindow.yMin+1,inputChannels:e.channels,channelByteOffsets:{},shouldExpand:!1,scanOrder:null,totalBytes:null,columns:null,lines:null,type:null,uncompress:null,getter:null,format:null,colorSpace:w};switch(e.compression){case"NO_COMPRESSION":a.blockHeight=1,a.uncompress=V;break;case"RLE_COMPRESSION":a.blockHeight=1,a.uncompress=W;break;case"ZIPS_COMPRESSION":a.blockHeight=1,a.uncompress=F;break;case"ZIP_COMPRESSION":a.blockHeight=16,a.uncompress=F;break;case"PIZ_COMPRESSION":a.blockHeight=32,a.uncompress=X;break;case"PXR24_COMPRESSION":a.blockHeight=16,a.uncompress=j;break;case"DWAA_COMPRESSION":a.blockHeight=32,a.uncompress=Y;break;case"DWAB_COMPRESSION":a.blockHeight=256,a.uncompress=Y;break;default:throw new Error("EXRLoader.parse: "+e.compression+" is unsupported")}const s={};for(const h of e.channels)switch(h.name){case"Y":case"R":case"G":case"B":case"A":s[h.name]=!0,a.type=h.pixelType}let l=!1,c=!1;if(s.R&&s.G&&s.B)a.outputChannels=4;else{if(!s.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");a.outputChannels=1}switch(a.outputChannels){case 4:i==g?(l=!s.A,a.format=g,a.colorSpace=w,a.outputChannels=4,a.decodeChannels={R:0,G:1,B:2,A:3}):i==y?(a.format=y,a.colorSpace=w,a.outputChannels=2,a.decodeChannels={R:0,G:1}):i==v?(a.format=v,a.colorSpace=w,a.outputChannels=1,a.decodeChannels={R:0}):c=!0;break;case 1:i==g?(l=!0,a.format=g,a.colorSpace=w,a.outputChannels=4,a.shouldExpand=!0,a.decodeChannels={Y:0}):i==y?(a.format=y,a.colorSpace=w,a.outputChannels=2,a.shouldExpand=!0,a.decodeChannels={Y:0}):i==v?(a.format=v,a.colorSpace=w,a.outputChannels=1,a.decodeChannels={Y:0}):c=!0;break;default:c=!0}if(c)throw new Error("EXRLoader.parse: invalid output format for specified file.");if(1==a.type)switch(r){case d:a.getter=oe;break;case p:a.getter=ne}else{if(2!=a.type)throw new Error("EXRLoader.parse: unsupported pixelType "+a.type+" for "+e.compression+".");switch(r){case d:a.getter=K;break;case p:a.getter=ee}}a.columns=a.width;const u=a.width*a.height*a.outputChannels;switch(r){case d:a.byteArray=new Float32Array(u),l&&a.byteArray.fill(1,0,u);break;case p:a.byteArray=new Uint16Array(u),l&&a.byteArray.fill(15360,0,u);break;default:console.error("THREE.EXRLoader: unsupported type: ",r)}let f=0;for(const h of e.channels)void 0!==a.decodeChannels[h.name]&&(a.channelByteOffsets[h.name]=f),f+=2*h.pixelType;if(a.totalBytes=f,a.outLineWidth=a.width*a.outputChannels,"INCREASING_Y"===e.lineOrder?a.scanOrder=e=>e:a.scanOrder=e=>a.height-1-e,e.spec.singleTile){a.blockHeight=e.tiles.ySize,a.blockWidth=e.tiles.xSize;const n=ie(e.tiles,a.width,a.height),r=ae(n,a.width,e.tiles.xSize,e.tiles.roundingMode),i=ae(n,a.height,e.tiles.ySize,e.tiles.roundingMode);a.tileCount=r[0]*i[0];for(let e=0;e<n;e++)for(let n=0;n<i[e];n++)for(let i=0;i<r[e];i++)J(t,o);a.decode=se.bind(a)}else{a.blockWidth=a.width;const e=Math.ceil(a.height/a.blockHeight);for(let n=0;n<e;n++)J(t,o);a.decode=le.bind(a)}return a}(he,ue,fe,ce,this.type,this.outputFormat);if(de.decode(),de.shouldExpand){const e=de.byteArray;if(this.outputFormat==g)for(let t=0;t<e.length;t+=4)e[t+2]=e[t+1]=e[t];else if(this.outputFormat==y)for(let t=0;t<e.length;t+=2)e[t+1]=e[t]}return{header:he,width:de.width,height:de.height,data:de.byteArray,format:de.format,colorSpace:de.colorSpace,type:this.type}}setDataType(e){return this.type=e,this}setOutputFormat(e){return this.outputFormat=e,this}load(e,t,n,o){return super.load(e,function(e,n){e.colorSpace=n.colorSpace,e.minFilter=m,e.magFilter=m,e.generateMipmaps=!1,e.flipY=!1,t&&t(e,n)},n,o)}}await e("three");const{defineComponent:b}=await e("vue"),{watchEffect:_}=await e("vue");await e("three");const{withAsyncContext:C,defineComponent:A}=await e("vue"),{unref:S,openBlock:M,createElementBlock:k}=await e("vue"),U=["object","scale"],x=await e("three"),P=A({__name:"groundProjectedEnvCom",props:{texture:{default:"https://opensource.cdn.icegl.cn/images/skyBox/round_platform_1k.exr"},size:{default:100}},async setup(e){let t,o;const r=e,i=new E,a=([t,o]=C(()=>i.loadAsync(r.texture)),t=await t,o(),t);a.mapping=x.EquirectangularReflectionMapping;const{scene:s}=n();s.value.environment=a;const l=new u(a);return(e,t)=>(M(),k("primitive",{object:S(l),scale:r.size},null,8,U))}}),{defineComponent:R}=await e("vue"),{ref:O,watch:I}=await e("vue"),B=await e("three"),z=R({__name:"basiceEnv",props:{on:{default:!0},type:{default:"sunset"},environmentIntensity:{default:1},environmentRotations:{default:{x:0,y:0,z:0}}},setup(e){const t=e;const{scene:n}=o(),r=O(null);return I(()=>[t.on,r.value],([e,t])=>{n.value&&(e&&r.value?n.value.environment=r.value:n.value.environment=null)},{immediate:!0}),I(()=>t.type,async e=>{n.value&&N[e]&&(r.value=await i(L+N[e]),t.on&&(n.value.environment=r.value))},{immediate:!0}),I(()=>t.environmentIntensity,e=>{n.value&&(n.value.environmentIntensity=e)},{immediate:!0}),I(()=>t.environmentRotations,e=>{if(n.value){const t=function(e){return e instanceof B.Euler?e:Array.isArray(e)?new B.Euler(e[0],e[1],e[2]):"number"==typeof e?new B.Euler(e,e,e):e instanceof B.Vector3||"object"==typeof e&&"x"in e&&"y"in e&&"z"in e?new B.Euler(e.x,e.y,e.z):null}(e);t&&n.value.environmentRotation.copy(t)}},{immediate:!0,deep:!0}),(e,t)=>null}}),N={sunset:"/images/water/belfast_sunset_puresky_1k.hdr",desert:"/images/skyBox/desert_1k.hdr",room:"/images/skyBox/newConvert/abandoned_games_room_02_1k.hdr",canary:"/images/skyBox/newConvert/canary_wharf_1k.hdr",outdoor:"/images/skyBox/newConvert/outdoor_umbrellas_1k.hdr",haven:"/images/skyBox/newConvert/poly_haven_studio_1k.hdr",shanghai:"/images/skyBox/newConvert/shanghai_bund_1k.hdr",hangar:"/images/skyBox/newConvert/small_hangar_01_1k.hdr",snowy:"/images/skyBox/newConvert/snowy_forest_path_01_1k.hdr"},L="https://opensource.cdn.icegl.cn";export{N as HDRfileList,P as _sfc_main,z as _sfc_main$1};
