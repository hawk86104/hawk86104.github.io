import{importShared as e}from"./3d-tiles-renderer.HXNTGnH81769411460564.js";import{useTres as t}from"./index.KfH1904l1769411460564.js";import{shaderMaterial as a}from"./shaderMaterial.DvUaJtX11769411460564.js";import{MeshDiscardMaterial as r}from"./customShaderMaterial.vue_vue_type_script_setup_true_lang.CHEF56Mi1769411460564.js";const i=await e("three");const s=a({color:new i.Color(0),blend:2,alphaTest:.75,opacity:0,map:null},"varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vUv = uv;\n   }",`varying vec2 vUv;\n   uniform sampler2D map;\n   uniform vec3 color;\n   uniform float opacity;\n   uniform float alphaTest;\n   uniform float blend;\n   void main() {\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\n     #include <tonemapping_fragment>\n     #include <${parseInt(i.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n   }`);class o{constructor(e,t,a=1024){this.renderer=e,this.res=a,this.scene=t,this.buffer1Active=!1,this.lights=[],this.meshes=[],this.object=null,this.clearColor=new i.Color,this.clearAlpha=0;const s=/(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent)?i.HalfFloatType:i.FloatType;this.progressiveLightMap1=new i.WebGLRenderTarget(this.res,this.res,{type:s}),this.progressiveLightMap2=new i.WebGLRenderTarget(this.res,this.res,{type:s}),this.discardMat=new r,this.targetMat=new i.MeshLambertMaterial({fog:!1}),this.previousShadowMap={value:this.progressiveLightMap1.texture},this.averagingWindow={value:100},this.targetMat.onBeforeCompile=e=>{e.vertexShader="varying vec2 vUv;\n"+e.vertexShader.slice(0,-1)+"vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";const t=e.fragmentShader.indexOf("void main() {");e.fragmentShader="varying vec2 vUv;\n"+e.fragmentShader.slice(0,t)+"uniform sampler2D previousShadowMap;\n\tuniform float averagingWindow;\n"+e.fragmentShader.slice(t-1,-1)+"\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\n      }",e.uniforms.previousShadowMap=this.previousShadowMap,e.uniforms.averagingWindow=this.averagingWindow}}clear(){this.renderer.getClearColor(this.clearColor),this.clearAlpha=this.renderer.getClearAlpha(),this.renderer.setClearColor("black",1),this.renderer.setRenderTarget(this.progressiveLightMap1),this.renderer.clear(),this.renderer.setRenderTarget(this.progressiveLightMap2),this.renderer.clear(),this.renderer.setRenderTarget(null),this.renderer.setClearColor(this.clearColor,this.clearAlpha),this.lights=[],this.meshes=[],this.scene.traverse(e=>{!function(e){return!!e.geometry}(e)?function(e){return e.isLight}(e)&&this.lights.push({object:e,intensity:e.intensity}):this.meshes.push({object:e,material:e.material})})}prepare(){this.lights.forEach(e=>e.object.intensity=0),this.meshes.forEach(e=>e.object.material=this.discardMat)}finish(){this.lights.forEach(e=>e.object.intensity=e.intensity),this.meshes.forEach(e=>e.object.material=e.material)}configure(e){this.object=e}update(e,t=100){if(!this.object)return;this.averagingWindow.value=t,this.object.material=this.targetMat;const a=this.buffer1Active?this.progressiveLightMap1:this.progressiveLightMap2,r=this.buffer1Active?this.progressiveLightMap2:this.progressiveLightMap1,i=this.scene.background;this.scene.background=null,this.renderer.setRenderTarget(a),this.previousShadowMap.value=r.texture,this.buffer1Active=!this.buffer1Active,this.renderer.render(this.scene,e),this.renderer.setRenderTarget(null),this.scene.background=i}}const{defineComponent:n}=await e("vue"),{createElementVNode:l,normalizeProps:h,guardReactiveProps:d,openBlock:c,createElementBlock:p}=await e("vue"),g=["rotate-x"],u=await e("three"),{ref:m,watch:v,watchEffect:f,toRaw:w}=await e("vue"),M=n({__name:"accumulativeShadowsCom",props:{opacity:{default:.8},alphaTest:{default:.9},color:{default:"#000000"},blend:{default:2},lightPosition:{default:{x:3,y:5,z:3}},frames:{default:60},blendWindow:{default:100},ambient:{default:.5}},setup(e){const a=e;let r=m();const{extend:i,scene:n,renderer:M,camera:b}=t();i({SoftShadowMaterial:s});const y={position:(new u.Vector3).set(a.lightPosition.x,a.lightPosition.y,a.lightPosition.z),radius:1,amount:8,intensity:Math.PI,bias:.001,mapSize:1024,size:8,near:.5,far:200},S=new o(M,n.value,y.mapSize),x={map:S.progressiveLightMap2.texture,transparent:!0,depthWrite:!1,toneMapped:!0,blend:a.blend,alphaTest:a.alphaTest,opacity:a.opacity,color:a.color},C=new u.Group;for(let t=0;t<y.amount;t++){const e=new u.DirectionalLight(16777215,y.intensity/y.amount);e.castShadow=!0,e.shadow.bias=y.bias,e.shadow.camera.near=y.near,e.shadow.camera.far=y.far,e.shadow.camera.right=y.size/2,e.shadow.camera.left=-4,e.shadow.camera.top=y.size/2,e.shadow.camera.bottom=-4,e.shadow.mapSize.width=y.mapSize,e.shadow.mapSize.height=y.mapSize,C.add(e)}const T=()=>{const e=y.position.length();for(let t=0;t<C.children.length;t++){const r=C.children[t];if(Math.random()>a.ambient)r.position.set(y.position.x+u.MathUtils.randFloatSpread(y.radius),y.position.y+u.MathUtils.randFloatSpread(y.radius),y.position.z+u.MathUtils.randFloatSpread(y.radius));else{let t=Math.acos(2*Math.random()-1)-Math.PI/2,a=2*Math.PI*Math.random();r.position.set(Math.cos(t)*Math.cos(a)*e,Math.abs(Math.cos(t)*Math.sin(a)*e),Math.sin(t)*e)}}},P=(e=1)=>{n.value.add(C),S.prepare();for(let t=0;t<e;t++)T(),S.update(b.value,a.blendWindow),console.log("shadows plm update",t);n.value.remove(C),S.finish()};v(()=>r.value,e=>{e&&(S.configure(w(e)),S.clear(),console.log("shadows render start"),P(a.frames),console.log("shadows render end"))});const _=()=>{S.clear(),P(a.frames)};return f(()=>{r.value&&(a.opacity&&(r.value.material.opacity=a.opacity),a.alphaTest&&(r.value.material.alphaTest=a.alphaTest),a.color&&r.value.material.color.set(a.color),a.blend&&(r.value.material.blend=a.blend))}),v(()=>a.lightPosition,e=>{e&&(console.log(a.lightPosition),y.position.set(e.x,e.y,e.z),_())},{deep:!0}),v(()=>[a.frames,a.blendWindow,a.ambient],()=>{_()}),(e,t)=>(c(),p("TresMesh",{"receive-shadow":"",ref_key:"gPlane",ref:r,scale:10,"rotate-x":-Math.PI/2},[t[0]||(t[0]=l("TresPlaneGeometry",{args:[1,1]},null,-1)),l("TresSoftShadowMaterial",h(d(x)),null,16)],8,g))}});export{M as _sfc_main};
