import{importShared as t}from"./3d-tiles-renderer.HXNTGnH81769411460564.js";import{_sfc_main as e}from"./pagesShow.vue_vue_type_script_setup_true_lang.Wss_Syvt1769411460564.js";import{useTres as i,useLoop as s}from"./index.KfH1904l1769411460564.js";const a=await t("three");class r{static Time=new r("Time");static Sequence=new r("Sequence");constructor(t){this.name=t}}class n{constructor(){this.init()}init(){this.progressType=r.Time,this.lifetime=1,this.age=0,this.sequenceElement=new a.Vector4,this.position=new a.Vector3,this.velocity=new a.Vector3,this.acceleration=new a.Vector3,this.normal=new a.Vector3,this.rotation=0,this.rotationalSpeed=0,this.size=new a.Vector2,this.color=new a.Color,this.alpha=1,this.initialSize=new a.Vector2,this.initialColor=new a.Color,this.initialAlpha=1}setAll(t,e,i,s,a,r,n,o,l,c,h,u,m,p,d,f){this.progressType=t,this.lifetime=e,this.age=i,this.sequenceElement.copy(s),this.position.copy(a),this.velocity.copy(r),this.acceleration.copy(n),this.normal.copy(o),this.rotation=l,this.rotationalSpeed=c,this.size=h,this.color.copy(u),this.alpha=m,this.initialSize.copy(p),this.initialColor.copy(d),this.initialAlpha=f}copyTo(t){t.setAll(this.progressType,this.lifetime,this.age,this.sequenceElement,this.position,this.velocity,this.acceleration,this.normal,this.rotation,this.rotationalSpeed,this.size,this.color,this.alpha,this.initialSize,this.initialColor,this.initialAlpha)}copy(t){this.setAll(t.progressType,t.lifetime,t.age,t.sequenceElement,t.position,t.velocity,t.acceleration,t.normal,t.rotation,t.rotationalSpeed,t.size,t.color,t.alpha,t.initialSize,t.initialColor,t.initialAlpha)}}class o{constructor(){this.particleCount=0,this.activeParticleCount=0,this.particleStates=[]}init(t){this.setParticleCount(t)}setParticleCount(t){this.particleCount!=t&&(this.dispose(),this.allocate(t)),this.particleCount=t}setActiveParticleCount(t){this.activeParticleCount=t}allocate(t){this.particleStates=[],this.particleCount=t;for(let e=0;e<t;e++)this.particleStates[e]=new n}dispose(){}getParticleCount(){return this.particleCount}flushParticleStateToBuffers(){}copyState(t,e){if(t>=this.particleCount)throw new Error('ParticleStateArray::copyState() -> "srcIndex" is out of range.');if(e>=this.particleCount)throw new Error('ParticleStateArray::copyState() -> "destIndex" is out of range.');const i=this.particleStates[t],s=this.particleStates[e];i.copyTo(s)}setState(t,e){if(t>=this.particleCount)throw new Error('ParticleStateArray::setState() -> "index" is out of range.');return this.particleStates[t].copy(e)}getState(t){if(t>=this.particleCount)throw new Error('ParticleStateArray::getState() -> "index" is out of range.');return this.particleStates[t]}computeBoundingBox=function(){const t=new a.Vector3;return function(e=new a.Box3,i=null){const s=e.min,r=e.max;for(let a=0;a<this.activeParticleCount;a++){const e=this.getState(a);let n=e.position;i&&(t.copy(n),t.applyMatrix4(i),n=t);const o=Math.max(e.size.x,e.size.y),l=n.x-o,c=n.x+o,h=n.y-o,u=n.y+o,m=n.z-o,p=n.z+o;(0==a||n.x<s.x)&&(s.x=l),(0==a||n.x>r.x)&&(r.x=c),(0==a||n.y<s.y)&&(s.y=h),(0==a||n.y>r.y)&&(r.y=u),(0==a||n.z<s.z)&&(s.z=m),(0==a||n.z>r.z)&&(r.z=p)}return e}}();computeBoundingSphere=function(){const t=new a.Vector3,e=new a.Vector3,i=new a.Vector3;return function(s=new a.Sphere,r=null){let n=0;for(let a=0;a<this.activeParticleCount;a++){const s=this.getState(a);let o=s.position;r&&(i.copy(o),i.applyMatrix4(r),o=i);const l=Math.max(s.size.x,s.size.y);if(0==a)t.copy(o),n=l;else{e.copy(o).sub(t);const i=e.length()+l;if(i>n){const s=(i-n)/2;e.normalize().multiplyScalar(s),t.add(e),n+=s}}}return s.center.copy(t),s.radius=n,s}}()}class l{constructor(t,e,i=0){this.start=t,this.length=e,this.id=i}}class c{constructor(){this.sequences={},this.ids=[]}addSequence(t,e,i){if(this.hasID(i))throw new Error("ParticleSequenceGroup::addParticleSequence -> Tried to add sequence with duplicate ID.");const s=new l(t,e,i);return this.sequences[i]=s,this.ids.push(i),s}getSequence(t){if(!this.hasID(t))throw new Error("ParticleSequenceGroup::getSequence -> Invalid ID.");return this.sequences[t]}getSequenceIDs(){return this.ids}hasID(t){return!!this.sequences[t]}}class h{constructor(){}initializeState(t){t.initialColor.set(1,1,1),t.initialSize.set(1,1),t.initialAlpha=1,t.progressType=r.Time,t.lifetime=0,t.age=0,t.sequenceElement.set(0,0,0,0),t.position.set(0,0,0),t.velocity.set(0,0,0),t.acceleration.set(0,0,0),t.normal.set(0,0,1),t.rotation=0,t.rotationalSpeed=0,t.size.copy(t.initialSize),t.color.copy(t.initialColor),t.alpha=1}}class u extends h{constructor(){super()}initializeState(t){super.initializeState(t)}}class m{constructor(){}updateState(){}}class p extends m{constructor(){super(),this.timeScaledVelocity=new a.Vector3,this.timeScaledAcceleration=new a.Vector3,this.stateAcceleration=new a.Vector3,this.stateVelocity=new a.Vector3}updateState(t,e){return super.updateState(t,e),this.stateAcceleration.copy(t.acceleration),this.timeScaledAcceleration.copy(this.stateAcceleration),this.timeScaledAcceleration.multiplyScalar(e),t.velocity.add(this.timeScaledAcceleration),this.stateVelocity.copy(t.velocity),this.timeScaledVelocity.copy(this.stateVelocity),this.timeScaledVelocity.multiplyScalar(e),t.position.add(this.timeScaledVelocity),t.age=t.age+e,t.rotation=t.rotation+e*t.rotationalSpeed,!0}}class d{static clamp(t,e,i){return Math.min(Math.max(t,e),i)}static currentTime(){return performance.now()/1e3}}class f{constructor(){this.components=[]}addComponent(t){this.components.push(t)}update(t,e){for(const i of this.components)i.update(t,e)}getComponent(t){if(t>=this.components.length)throw new Error('ComponentContainer::getComponent() -> "index" is out of range.');return this.components[t]}}class g{static NotStarted=new g("NotStarted");static Running=new g("Running");static Paused=new g("Paused");static Done=new g("Done");constructor(t){this.name=t}}class S{constructor(t,e){this.owner=t,this.owner.visible=!1,this.visible=!0,this.particleSystemRenderer=e,this.initialized=!1,this.maximumActiveParticles=0,this.activeParticleCount=0,this.simulateInWorldSpace=!0,this.emitterInitialized=!1,this.particleEmitter=null,this.componentContainer=new f,this.particleStateInitializers=[],this.particleStateOperators=[],this.particleStates=null,this.systemState=g.NotStarted,this.particleSequences=new c,this.onUpdateCallback=null,this.transformInitialDirectionInWorldSpace=!0,this.boundingBox=new a.Box3,this.boundingSphere=new a.Sphere}init(t){if(this.initialized)throw new Error("ParticleSystem::init() -> trying to intialize more than once.");this.maximumActiveParticles=t,this.particleSystemRenderer?(this.particleSystemRenderer.setOwner(this.owner),this.particleSystemRenderer.init(this.maximumActiveParticles,this.simulateInWorldSpace),this.particleSystemRenderer.setSimulateInWorldSpace(this.simulateInWorldSpace),this.particleStates=this.particleSystemRenderer.getParticleStateArray()):(this.particleStates=new o,this.particleStates.init(this.maximumActiveParticles)),this.addParticleStateInitializer(new u),this.addParticleStateOperator(new p),this.initialized=!0}getVisible(){return this.visible}setVisibile(t){return this.visible=t}onUpdate(t){this.onUpdateCallback=t}update(t,e){if(this.systemState==g.Running){if(this.owner.updateWorldMatrix(!0),t=null==t||null==t?d.currentTime():t,e=null==e||null==e?t-this.lastUpdateTime:e,this.emitterInitialized&&this.systemState==g.Running){const t=this.particleEmitter.update(e);t>0&&this.activateParticles(t),this.advanceActiveParticles(e),this.onUpdateCallback&&this.onUpdateCallback(this.activeParticleCount),this.updateBounds()}this.componentContainer.update(t,e),this.lastUpdateTime=t}}render(t,e){if(this.getVisible()&&this.particleSystemRenderer){const i=t.autoClear;t.autoClear=!1,this.owner.visible=!0,this.owner.matrixWorldNeedsUpdate=!0,this.particleSystemRenderer.render(this.owner,t,e),this.owner.visible=!1,t.autoClear=i}}start(){this.systemState!=g.NotStarted&&this.systemState!=g.Paused||(this.systemState=g.Running,this.startTime=d.currentTime(),this.lastUpdateTime=this.startTime)}pause(){this.systemState==g.Running&&(this.systemState=g.Paused)}stop(){}getSystemState(){return this.systemState}setEmitter(t){return this.particleEmitter=t,this.particleEmitter.maximumActiveParticles=this.maximumActiveParticles,this.emitterInitialized=!0,this.particleEmitter}addComponent(t){this.componentContainer.addComponent(t)}getComponent(t){return this.componentContainer.getComponent(t)}addParticleStateInitializer(t){return this.particleStateInitializers.push(t),t}getParticleStateInitializerCount(){return this.particleStateInitializers.length}getParticleStateInitializer(t){if(t>=this.particleStateInitializers.length)throw new Error('ParticleSystem::getParticleStateInitializer() -> "index" is out of range.');return this.particleStateInitializers[t]}addParticleStateOperator(t){return this.particleStateOperators.push(t),t}getParticleStateOperatorCount(){return this.particleStateOperators.length}getParticleStateOperator(t){if(t>=this.particleStateOperators.length)throw new Error('ParticleSystem::getParticleStateOperator() -> "index" is out of range.');return this.particleStateOperators[t]}getMaximumActiveParticles(){return this.maximumActiveParticles}getActiveParticleCount(){return this.activeParticleCount}getParticleState(t){if(t>=this.activeParticleCount)throw new Error('ParticleSystem::getParticleState() -> "index" is out of range.');return this.particleStates.getState(t)}getParticleStates(){return this.particleStates}getParticleSystemRenderer(){return this.particleSystemRenderer}getSimulateInWorldSpace(){return this.simulateInWorldSpace}setSimulateInWorldSpace(t){this.simulateInWorldSpace=t,this.particleSystemRenderer&&this.particleSystemRenderer.setSimulateInWorldSpace(this.simulateInWorldSpace)}setTransformInitialDirectionInWorldSpace(t){this.transformInitialDirectionInWorldSpace=t}addParticleSequence(t,e,i=0){this.particleSequences.addSequence(t,e,i)}getParticleSequences(){return this.particleSequences}getEmitter(){return this.particleEmitter}updateBounds=function(){const t=new a.Matrix4;return function(){let e=null;this.transformInitialDirectionInWorldSpace&&(e=t,e.copy(this.owner.matrixWorld).invert()),this.particleSystemRenderer.calculatingBoundingSphereFromBox()?(this.particleStates.computeBoundingBox(this.boundingBox,e),this.particleSystemRenderer.setBoundingBox(this.boundingBox)):(this.particleStates.computeBoundingSphere(this.boundingSphere,e),this.particleSystemRenderer.setBoundingSphere(this.boundingSphere))}}();activateParticles(t){if(this.systemState==g.Running){const e=d.clamp(this.activeParticleCount+t,0,this.maximumActiveParticles);for(let t=this.activeParticleCount;t<e;t++)this.activateParticle(t);this.activeParticleCount=e,this.particleStates.setActiveParticleCount(this.activeParticleCount)}}activateParticle(t){if(this.systemState==g.Running){const e=this.particleStates.getState(t);e.age=0;for(let t=0;t<this.particleStateInitializers.length;t++){this.particleStateInitializers[t].initializeState(e)}if(this.simulateInWorldSpace){e.position.applyMatrix4(this.owner.matrixWorld);const t=e.velocity.length();if(this.transformInitialDirectionInWorldSpace){e.velocity.transformDirection(this.owner.matrixWorld).multiplyScalar(t);const i=e.acceleration.length();e.acceleration.transformDirection(this.owner.matrixWorld).multiplyScalar(i)}}this.particleStates.flushParticleStateToBuffers(t)}}advanceActiveParticles(t){if(this.systemState==g.Running){let e=0;for(;e<this.activeParticleCount;){this.advanceActiveParticle(e,t)?e++:(e<this.activeParticleCount-1&&this.copyParticleInArray(this.activeParticleCount-1,e),this.activeParticleCount--)}this.particleStates.setActiveParticleCount(this.activeParticleCount)}}advanceActiveParticle(t,e){if(this.systemState==g.Running){const i=this.particleStates.getState(t);for(let t=0;t<this.particleStateOperators.length;t++){const s=this.particleStateOperators[t].updateState(i,e),a=i.lifetime;if(!s||0!=a&&i.age>=a)return!1}return this.particleStates.flushParticleStateToBuffers(t),!0}return!1}copyParticleInArray(t,e){this.particleStates.copyState(t,e),this.particleStates.flushParticleStateToBuffers(e)}static fromJSON(t,e,i){const s=(t,e,i)=>{e(t);for(const a in t)if(t.hasOwnProperty(a)){const i=t[a];"object"==typeof i&&s(i,e)}};s(t,t=>{t.type&&(t.type=e.parseTypeString(t.type))});const r=t.maxParticleCount,n=t.simulateInWorldSpace,o=t.renderer,l=o.type.fromJSON(o.params),c=new a.Object3D,h=new S(c,l,i);h.init(r),h.setSimulateInWorldSpace(n);const u=t.emitter,m=u.type.fromJSON(u.params);if(h.setEmitter(m),t.sequences)for(const a of t.sequences)h.addParticleSequence(a.start,a.length,a.id);if(t.initializers)for(const a of t.initializers)h.addParticleStateInitializer(a.type.fromJSON(h,a.params));if(t.operators)for(const a of t.operators){const t=h.addParticleStateOperator(a.type.fromJSON(h,a.params));a.elements&&t.addElementsFromParameters(a.elements)}return[h,c]}toJSON(t){const e=this.getParticleSystemRenderer(),i=this.getEmitter(),s=this.getParticleSequences(),a=s.getSequenceIDs().map(t=>{const e=s.getSequence(t);return{id:t,start:e.start,length:e.length}}),r=[],n=this.getParticleStateInitializerCount();for(let c=0;c<n;c++){const e=this.getParticleStateInitializer(c);e.constructor!==u&&r.push({type:t.getTypePath(e.constructor),params:e.toJSON(t)})}const o=[],l=this.getParticleStateOperatorCount();for(let c=0;c<l;c++){const e=this.getParticleStateOperator(c);if(e.constructor!==p){const i=e.toJSON(t),s=i.params||i,a=i.params?i.elements:null,r={type:t.getTypePath(e.constructor),params:s};a&&(r.elements=a),o.push(r)}}return{maxParticleCount:this.getMaximumActiveParticles(),simulateInWorldSpace:this.getSimulateInWorldSpace(),renderer:{type:t.getTypePath(e.constructor),params:e.toJSON()},emitter:{type:t.getTypePath(i.constructor),params:i.toJSON()},sequences:a,initializers:r,operators:o}}}class y{constructor(){this.particleSystems=[],this.startupTime=performance.now()/1e3,this.lastUpdateTime=this.startupTime,this.componentContainer=new f}update(){const t=d.currentTime(),e=t-this.lastUpdateTime;for(const i of this.particleSystems)i.update(t,e);this.componentContainer.update(t,e),this.lastUpdateTime=t}render(t,e){for(const i of this.particleSystems)i.render(t,e)}addParticleSystem(t){this.particleSystems.push(t)}addComponent(t){this.componentContainer.addComponent(t)}getComponent(t){return this.componentContainer.getComponent(t)}}class w{constructor(){this.initialized=!1,this.particleCount=0,this.owner=null,this.simulateInWorldSpace=!1}setSimulateInWorldSpace(t){this.simulateInWorldSpace=t}getParticleStateArray(){}setOwner(t){this.owner=t}init(t){if(this.particleCount=t,!this.initialized)return this.initialized=!0,!0;throw new Error("Renderer::init() -> trying to intialize more than once.")}render(){}}class v extends o{constructor(){super(),this.geometry=null,this.progressTypes=null,this.lifetimes=null,this.ages=null,this.sequenceElements=null,this.positions=null,this.velocities=null,this.accelerations=null,this.normals=null,this.rotations=null,this.rotationalSpeeds=null,this.sizes=null,this.colors=null,this.initialSizes=null,this.initialColors=null,this.instanced=!1,this.verticesPerParticle=6}init(t,e=!1){this.instanced=e,this.instanced?this.verticesPerParticle=1:this.verticesPerParticle=6,super.init(t),this.allocate(t)}setParticleCount(t){super.setParticleCount(t)}setActiveParticleCount(t){super.setActiveParticleCount(t),t>0?this.instanced?this.geometry.instanceCount=t:this.geometry.setDrawRange(0,this.verticesPerParticle*t):this.instanced?this.geometry.instanceCount=0:this.geometry.setDrawRange(0,0)}flushParticleStateToBuffers(t){if(t>=this.particleCount)throw new Error('ParticleStateAttributeArray::flushParticleStateToBuffers() -> "index" is out of range.');const e=this.getState(t),i=t*this.verticesPerParticle;for(let s=0;s<this.verticesPerParticle;s++)this.lifetimes.setX(i+s,e.lifetime),this.lifetimes.needsUpdate=!0,this.ages.setX(i+s,e.age),this.ages.needsUpdate=!0,this.sequenceElements.setXYZW(i+s,e.sequenceElement.x,e.sequenceElement.y,e.sequenceElement.z,e.sequenceElement.w),this.sequenceElements.needsUpdate=!0,this.positions.setXYZ(i+s,e.position.x,e.position.y,e.position.z),this.positions.needsUpdate=!0,this.velocities.setXYZ(i+s,e.velocity.x,e.velocity.y,e.velocity.z),this.velocities.needsUpdate=!0,this.accelerations.setXYZ(i+s,e.acceleration.x,e.acceleration.y,e.acceleration.z),this.accelerations.needsUpdate=!0,this.normals.setXYZ(i+s,e.normal.x,e.normal.y,e.normal.z),this.normals.needsUpdate=!0,this.rotations.setX(i+s,e.rotation),this.rotations.needsUpdate=!0,this.rotationalSpeeds.setX(i+s,e.rotationalSpeed),this.rotationalSpeeds.needsUpdate=!0,this.sizes.setXY(i+s,e.size.x,e.size.y),this.sizes.needsUpdate=!0,this.colors.setXYZ(i+s,e.color.r,e.color.g,e.color.b),this.colors.needsUpdate=!0,this.alphas.setX(i+s,e.alpha),this.alphas.needsUpdate=!0,this.initialSizes.setXY(i+s,e.initialSize.x,e.initialSize.y),this.initialSizes.needsUpdate=!0,this.initialAlphas.setX(i+s,e.initialAlpha),this.initialAlphas.needsUpdate=!0}copyState(t,e){super.copyState(t,e),this.flushParticleStateToBuffers(e)}setState(t,e){if(t>=this.particleCount)throw new Error('ParticleStateAttributeArray::setState() -> "index" is out of range.');super.setState(t,e),this.flushParticleStateToBuffers(t)}getPositions(){return this.positions}getSizes(){return this.sizes}getRotations(){return this.rotations}getSequenceElements(){return this.sequenceElements}getColors(){return this.colors}getGeometry(){return this.geometry}allocate(t){super.allocate(t);const e=(t,e)=>this.instanced?new a.InstancedBufferAttribute(t,e):new a.BufferAttribute(t,e),i=this.verticesPerParticle*this.particleCount;if(this.instanced){const t=new a.BufferGeometry,e=new Float32Array(18);this.basePositions=new a.BufferAttribute(e,3),t.setAttribute("position",this.basePositions),this.basePositions.needsUpdate=!0,this.basePositions.setXYZ(0,-1,1,0),this.basePositions.setXYZ(1,-1,-1,0),this.basePositions.setXYZ(2,1,1,0),this.basePositions.setXYZ(3,-1,-1,0),this.basePositions.setXYZ(4,1,-1,0),this.basePositions.setXYZ(5,1,1,0);const i=new Float32Array(12);this.baseUVs=new a.BufferAttribute(i,2),t.setAttribute("baseUV",this.baseUVs),this.baseUVs.needsUpdate=!0,this.baseUVs.setXY(0,0,1),this.baseUVs.setXY(1,0,0),this.baseUVs.setXY(2,1,1),this.baseUVs.setXY(3,0,0),this.baseUVs.setXY(4,1,0),this.baseUVs.setXY(5,1,1);const s=new Float32Array(6);this.customIndexes=new a.BufferAttribute(s,1),t.setAttribute("customIndex",this.customIndexes),this.customIndexes.needsUpdate=!0,this.customIndexes.setX(0,0),this.customIndexes.setX(1,1),this.customIndexes.setX(2,3),this.customIndexes.setX(3,1),this.customIndexes.setX(4,2),this.customIndexes.setX(5,3),this.geometry=(new a.InstancedBufferGeometry).copy(t),this.geometry.instanceCount=0}else{this.geometry=new a.BufferGeometry;const t=new Float32Array(i);this.customIndexes=new a.BufferAttribute(t,1),this.geometry.setAttribute("customIndex",this.customIndexes),this.customIndexes.needsUpdate=!0;for(let e=0;e<this.particleCount;e++){const t=e*this.verticesPerParticle;this.customIndexes.setX(t,0),this.customIndexes.setX(t+1,1),this.customIndexes.setX(t+2,3),this.customIndexes.setX(t+3,1),this.customIndexes.setX(t+4,2),this.customIndexes.setX(t+5,3)}}const s=new Float32Array(i),r=new Float32Array(i),n=new Float32Array(4*i),o=new Float32Array(3*i),l=new Float32Array(3*i),c=new Float32Array(3*i),h=new Float32Array(3*i),u=new Float32Array(i),m=new Float32Array(i),p=new Float32Array(2*i),d=new Float32Array(3*i),f=new Float32Array(i),g=new Float32Array(2*i),S=new Float32Array(3*i),y=new Float32Array(i);this.positions=e(o,3),this.positions.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("particlePosition",this.positions),this.lifetimes=e(s,1),this.lifetimes.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("lifetime",this.lifetimes),this.ages=e(r,1),this.ages.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("age",this.ages),this.sequenceElements=e(n,4),this.sequenceElements.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("sequenceElement",this.sequenceElements),this.velocities=e(l,3),this.velocities.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("velocity",this.velocities),this.accelerations=e(c,3),this.accelerations.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("acceleration",this.accelerations),this.normals=e(h,3),this.normals.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("normal",this.normals),this.rotations=e(u,1),this.rotations.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("rotation",this.rotations),this.rotationalSpeeds=e(m,1),this.rotationalSpeeds.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("rotationalSpeed",this.rotationalSpeeds),this.sizes=e(p,2),this.sizes.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("size",this.sizes),this.colors=e(d,3),this.colors.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("color",this.colors),this.alphas=e(f,1),this.alphas.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("alpha",this.alphas),this.initialSizes=e(g,2),this.initialSizes.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("initialSize",this.initialSizes),this.initialColors=e(S,3),this.initialColors.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("initialColor",this.initialColors),this.initialAlphas=e(y,1),this.initialAlphas.setUsage(a.DynamicDrawUsage),this.geometry.setAttribute("initialAlpha",this.initialAlphas)}dispose(){super.dispose(),this.geometry&&(this.geometry.dispose(),this.geometry=null)}}class P{constructor(t,e,i,s,a){this.length=t,this.x=e,this.y=i,this.width=s,this.height=a}}class x{constructor(t,e){this.texture=t,this.texturePath=e,this.frameSets=[]}getTexture(){return this.texture}getTexturePath(){return this.texturePath}getFrameSetCount(){return this.frameSets.length}addFrameSet(t,e,i,s,a){this.frameSets.push(new P(t,e,i,s,a))}getFrameSet(t){if(t>=this.frameSets.length)throw new Error('Atlas::getFrameSet -> "index" is out of range.');return this.frameSets[t]}}class I extends w{constructor(t,e,i=!1,s=a.NormalBlending,r=!0,n){super(),this.instanced=t,this.particleStateArray=null,this.material=null,this.mesh=null,this.atlas=e,this.interpolateAtlasFrames=i,this.blending=s,this.boundingBox=new a.Box3,this.boundingSphere=new a.Sphere,this.calculateBoundingSphereFromBox=r,this.renderOrder=n}setOwner(t){super.setOwner(t)}getParticleStateArray(){return this.particleStateArray}setSimulateInWorldSpace(t){super.setSimulateInWorldSpace(t),this.material&&(this.material.uniforms.simulateInWorldSpace.value=t?1:0,this.material.uniformsNeedUpdate=!0)}calculatingBoundingSphereFromBox(){return this.calculateBoundingSphereFromBox}setBoundingBox(t){this.boundingBox.copy(t),this.mesh&&this.updateMeshBounds()}setBoundingSphere(t){this.boundingSphere.copy(t),this.mesh&&this.updateMeshBounds()}render(t,e,i){e.render(t,i)}updateMeshBounds=function(){const t=new a.Vector3;return function(){const e=this.particleStateArray.getGeometry();if(this.calculateBoundingSphereFromBox){e.boundingBox||(e.boundingBox=new a.Box3),e.boundingBox.copy(this.boundingBox),e.boundingSphere||(e.boundingSphere=new a.Sphere),t.x=(this.boundingBox.min.x+this.boundingBox.max.x)/2,t.y=(this.boundingBox.min.y+this.boundingBox.max.y)/2,t.z=(this.boundingBox.min.z+this.boundingBox.max.z)/2;const i=this.boundingBox.max.x-t.x,s=this.boundingBox.max.y-t.y,r=this.boundingBox.max.z-t.z,n=Math.max(Math.max(i,s),r);e.boundingSphere.center.copy(t),e.boundingSphere.radius=Math.sqrt(2*n*n)}else e.boundingSphere||(e.boundingSphere=new a.Sphere),e.boundingSphere.copy(this.boundingSphere)}}();init(t){super.init(t)&&(this.particleStateArray=new v,this.particleStateArray.init(t,this.instanced),this.material=this.createMaterial(null,null,null,!0,!1),this.material.blending=this.blending,this.mesh=new a.Mesh(this.particleStateArray.getGeometry(),this.material),this.mesh.frustumCulled=!0,void 0!==this.renderOrder&&(this.mesh.renderOrder=this.renderOrder),this.updateMeshBounds(),this.owner.add(this.mesh))}dispose(){this.particleStateArray.dispose()}createMaterial(t,e,i,s,r){const n=[...Array(16).keys()].map(t=>new a.Vector4);if(this.atlas)for(let m=0;m<this.atlas.getFrameSetCount();m++){const t=this.atlas.getFrameSet(m);n[m]=new a.Vector4(t.x,t.y,t.width,t.height)}const o=this.atlas?this.atlas.getTexture():null,l=this.interpolateAtlasFrames,c=this.simulateInWorldSpace,h=this.instanced?1:0,u={atlasFrameSet:{type:"v4v",value:n},atlasTexture:{type:"t",value:o},interpolateAtlasFrames:{value:l},uvOffset:{type:"v2",value:new a.Vector2},simulateInWorldSpace:{value:c},instanced:{value:h}};return i=i||{},Object.assign(i,u),t=t||I.Shader.getVertexShader(r),e=e||I.Shader.getFragmentShader(s,r),new a.ShaderMaterial({uniforms:i,vertexShader:t,fragmentShader:e,transparent:!0,alphaTest:1,blending:a.NormalBlending,blendDstAlpha:a.OneMinusSrcAlphaFactor,blendSrcAlpha:a.SrcAlphaFactor,depthTest:!0,depthWrite:!1})}static Shader={get VertexVars(){return["const int MAX_ATLAS_FRAME_SETS = 16; \n","uniform vec4 atlasFrameSet[MAX_ATLAS_FRAME_SETS]; \n","uniform int interpolateAtlasFrames; \n","uniform int simulateInWorldSpace; \n","uniform int instanced; \n","attribute vec2 baseUV;\n","attribute float customIndex;\n","attribute vec4 particlePosition;\n","attribute float rotation;\n","attribute vec2 size;\n","attribute vec4 sequenceElement;\n","attribute vec3 color;\n","attribute float alpha;\n","varying vec2 vUV1;\n","varying vec2 vUV2;\n","varying vec3 vFragColor;\n","varying float vFragAlpha;\n","varying float vSequenceElementT; \n"].join("\n")},get FragmentVars(){return["uniform int interpolateAtlasFrames; \n","uniform sampler2D atlasTexture;\n","uniform vec2 uvOffset;\n","varying vec2 vUV1;\n","varying vec2 vUV2;\n","varying vec3 vFragColor;\n","varying float vFragAlpha;\n","varying float vSequenceElementT;\n"].join("\n")},getVertexShader(t){let e=["#include <common>",this.VertexVars].join("\n");return t&&(e+="  \n #include <logdepthbuf_pars_vertex> \n"),e+=["void getUV(in int sequenceElement, in int sequenceNumber, in vec4 atlasFrames, out vec2 uv) { \n","   float atlasFrameWidth = atlasFrames.z; \n","   float atlasFrameHeight = atlasFrames.w; \n","   float atlasFrameX = atlasFrames.x; \n","   float atlasFrameY = atlasFrames.y; \n","   int firstRowSections = int((1.0 - atlasFrameX) / atlasFrameWidth); \n","   int maxRowSections = int(1.0 / atlasFrameWidth); \n","   float firstRowX = atlasFrameX + atlasFrameWidth * float(sequenceElement); \n","   float firstRowY = 1.0 - (atlasFrameY + atlasFrameHeight); \n","   int nRowSequenceElement = sequenceElement - firstRowSections; \n","   float SNOverHS = float(nRowSequenceElement) / float(maxRowSections);\n","   int nRowYTile = int(SNOverHS);\n","   int nRowXTile = int((SNOverHS - float(nRowYTile)) * float(maxRowSections));\n","   float nRowX = float(nRowXTile) * atlasFrameWidth;\n","   float nRowY = 1.0 - ((float(nRowYTile) + 1.0) * (atlasFrameHeight) + atlasFrameY + atlasFrameHeight);\n","   float nRow = step(float(firstRowSections), float(sequenceElement)); \n","   uv.x = nRow * nRowX + (1.0 - nRow) * firstRowX; \n","   uv.y = nRow * nRowY + (1.0 - nRow) * firstRowY; \n","} \n","void main()\n","{\n","   const vec2 right = vec2(1.0, 0.0);\n","   const vec2 up = vec2(0.0, 1.0);\n","   const vec2 left = vec2(-1.0, 0.0);\n","   const vec2 down = vec2(0.0, -1.0);\n","   const vec2 uRight = vec2(1.0, 1.0);\n","   const vec2 uLeft = vec2(-1.0, 1.0);\n","   const vec2 dLeft = vec2(-1.0, -1.0);\n","   const vec2 dRight = vec2(1.0, -1.0);\n","   vec4 viewPosition; \n","   if (simulateInWorldSpace == 1) { \n","       viewPosition = viewMatrix * particlePosition;\n","   } else { \n","       viewPosition = viewMatrix * modelMatrix * particlePosition;\n","   } \n","   float sequenceElementF = sequenceElement.x;\n","   int sequenceNumber = int(sequenceElement.y);\n","   int sequenceStart = int(sequenceElement.z);\n","   int sequenceLength = int(sequenceElement.w);\n","   vec4 atlasFrames = atlasFrameSet[sequenceNumber]; \n","   vec2 uv1; \n","   vec2 uv2; \n","   vSequenceElementT = sequenceElementF - float(int(sequenceElementF)); \n","   int firstSequenceElement = int(sequenceElementF); \n","   int secondSequenceElement = clamp(firstSequenceElement + 1, sequenceStart, sequenceStart + sequenceLength - 1); \n","   getUV(firstSequenceElement, sequenceNumber, atlasFrames, uv1); \n","   if (interpolateAtlasFrames == 1 && firstSequenceElement != secondSequenceElement) { \n ","       getUV(secondSequenceElement, sequenceNumber, atlasFrames, uv2); \n","   } \n","   float atlasFrameWidth = atlasFrames.z; \n","   float atlasFrameHeight = atlasFrames.w; \n","   float rotMag = rotation; \n","   mat2 rotMat = mat2(cos(rotMag), -sin(rotMag), sin(rotMag), cos(rotMag)) * mat2(size.x, 0.0, 0.0, size.y);\n","   float rightSide; \n","   float upperSide; \n","   if (instanced != 1) { \n","       rightSide = step(2.0, customIndex); \n","       vec2 upperSideStep = step(vec2(customIndex, 3.0), vec2(0.0, customIndex));\n","       upperSide = upperSideStep.x + upperSideStep.y;\n","   }  else { \n","       rightSide = baseUV.x; \n","       upperSide = baseUV.y; \n","   } \n","   float uvXOffset = atlasFrameWidth * rightSide; \n","   float uvYOffset = atlasFrameHeight * upperSide; \n","   vec2 rotVec; \n","   if (instanced != 1) { \n","       vec4 rotVecStep = step(vec4(customIndex, customIndex, 3.0, 2.0), vec4(0.0, 1.0, customIndex, customIndex)); \n","       float uLeftV = rotVecStep.x; \n","       float dLeftV = rotVecStep.y - rotVecStep.x; \n","       float uRightV = rotVecStep.z; \n","       float dRightV = rotVecStep.w - rotVecStep.z; \n","       rotVec = uLeft * uLeftV + dLeft * dLeftV + dRight * dRightV + uRight * uRightV; \n","   }  else { \n","       rotVec = position.xy; \n ","   } \n","   gl_Position = projectionMatrix * (vec4(rotMat * rotVec, 0.0, 0.0) + viewPosition);\n","   vUV1 = vec2(uv1.x + uvXOffset, uv1.y + uvYOffset);\n","   vUV2 = vec2(uv2.x + uvXOffset, uv2.y + uvYOffset);\n","   vFragColor = color; \n","   vFragAlpha = alpha; \n"].join("\n"),t&&(e+="   \n  #include <logdepthbuf_vertex> \n"),e+="} \n",e},getFragmentShader(t,e){let i=`#include <common> \n${this.FragmentVars}\n`;return e&&(i+="  \n #include <logdepthbuf_pars_fragment> \n"),i+="void main() { \n",e&&(i+="    \n  #include <logdepthbuf_fragment> \n"),i+=t?["   vec4 color1 = texture(atlasTexture, vUV1 + uvOffset) * vec4(vFragColor, 1.0);\n","   vec4 color2 = color1; \n","   if (interpolateAtlasFrames == 1) color2 = texture(atlasTexture, vUV2 + uvOffset) * vec4(vFragColor, 1.0);\n","   gl_FragColor = mix(color1, color2, vSequenceElementT);\n","   gl_FragColor.a *= vFragAlpha; \n"].join("\n"):["   vec4 color1 = texture2D(atlasTexture, vUV1 + uvOffset) * vec4(vFragColor, 1.0);\n","   vec4 color2 = color1; \n","   if (interpolateAtlasFrames == 1) color2 = texture(atlasTexture, vUV2 + uvOffset) * vec4(vFragColor, 1.0);\n","   gl_FragColor = mix(color1, color2, vSequenceElementT);\n","   gl_FragColor.a *= vFragAlpha; \n"].join("\n"),i+="}\n",i}};static fromJSON(t){const e=t.atlas,i=(new a.TextureLoader).load(e.texturePath),s=new x(i,e.texturePath),r=e.framesets;for(const a of r)s.addFrameSet(a.length,a.x,a.y,a.width,a.height);const n=new I(t.instanced,s,e.interpolateFrames);return"Additive"==t.blending?n.blending=a.AdditiveBlending:n.blending=a.NormalBlending,n}toJSON(t){t=t||(t=>{if(t.texturePath)return t.texturePath;const e=t.getTexture().source;if(e){const t=e.data;if(t){const e=t.baseURI,i=t.currentSrc;return i.indexOf(e)>=0?i.substr(e.length,i.length-e.length):i}}});const e=[];for(let s=0;s<this.atlas.getFrameSetCount();s++){const t=this.atlas.getFrameSet(s);e.push(t)}let i="Normal";this.material.blending===a.AdditiveBlending&&(i="Additive");return{instanced:this.instanced,blending:i,atlas:{interpolateFrames:this.interpolateAtlasFrames,texturePath:t(this.atlas),framesets:e}}}}class A{constructor(){this.emissionRelativeStartTime=0,this.emissionDuration=0,this.emitCount=0,this.age=0,this.timeActive=0,this.activeCount=0,this.maximumActiveParticles=0}update(t){return this.internalUpdate(t),0}internalUpdate(t){return this.age+=t,this.timeActive=Math.max(this.age-this.emissionRelativeStartTime,0),this.age>=this.emissionRelativeStartTime&&(0==this.emissionDuration||this.timeActive<=emissionDuration)}updateEmitCount(t){this.emitCount+=t}}class V extends A{constructor(){super(),this.emissionMinimum=0,this.emissionMaximum=0}}class T extends V{constructor(t=0){super(),this.emissionRate=t}update(t){if(this.internalUpdate(t)){const t=this.emissionRate*this.timeActive-this.emitCount;if(t>=1){const e=Math.floor(t);return this.updateEmitCount(e),e}}return 0}static fromJSON(t){const e=new T;return e.emissionRate=t.emissionRate||0,e}toJSON(){return{emissionRate:this.emissionRate}}}class z{static Default=new z("Default");static Vector2=new z("Vector2");static Vector3=new z("Vector3");static Vector4=new z("Vector4");static Color=new z("Color");constructor(t){this.name=t}static getTypeID(t){let e=z.Default;return t===a.Vector2?e=z.Vector2:t===a.Vector3?e=z.Vector3:t===a.Vector4?e=z.Vector4:t===a.Color&&(e=z.Color),e}static loadJSONParameter(t,e){switch(e){case a.Vector2:return(new a.Vector2).fromArray(t);case a.Vector3:return(new a.Vector3).fromArray(t);case a.Vector4:return(new a.Vector4).fromArray(t);case a.Color:return(new a.Color).fromArray(t)}return t}}class F{constructor(t){this.outType=t,this.outTypeID=z.getTypeID(t)}}class b extends F{constructor(t,e,i,s,a,r){super(t),this.range=e,this.offset=i,this.uniformRange=s,this.uniformOffset=a,this.normalize=r}generate(t){const e=Math.random()*this.uniformRange;switch(this.outTypeID){case z.Default:t=Math.random()*this.range+this.offset,this.normalize&&(t=t<0?-1:1);break;case z.Vector2:t.set(this.generateForElement(e,"x"),this.generateForElement(e,"y"));break;case z.Vector3:t.set(this.generateForElement(e,"x"),this.generateForElement(e,"y"),this.generateForElement(e,"z"));break;case z.Vector4:t.set(this.generateForElement(e,"x"),this.generateForElement(e,"y"),this.generateForElement(e,"z"),this.generateForElement(e,"w"))}return this.normalize&&t.normalize(),t}generateForElement(t,e){return t+Math.random()*this.range[e]+this.offset[e]+this.uniformOffset}clone(){return new b(this.outType,this.range,this.offset,this.uniformRange,this.uniformOffset,this.normalize)}static getParameterJSON(t){return t instanceof a.Vector2||t instanceof a.Vector3||t instanceof a.Vector4||t instanceof a.Color?t.toArray():t}static fromJSON(t){return new b(t.type,z.loadJSONParameter(t.range,t.type),z.loadJSONParameter(t.offset,t.type),t.uniformRange||0,t.uniformOffset||0,t.normalize)}toJSON(t){const e={range:b.getParameterJSON(this.range),offset:b.getParameterJSON(this.offset),uniformRange:this.uniformRange,uniformOffset:this.uniformOffset},i=t.getTypePath(this.range.constructor);return null!=i&&(e.type=i),{type:t.getTypePath(b),params:e}}}class C extends h{constructor(t,e,i,s,a){super(),this.range=t,this.offset=e,this.uniformRange=i,this.uniformOffset=s,this.normalize=a,this.generator=new b(0,this.range,this.offset,this.uniformRange,this.uniformOffset,this.normalize)}initializeState(t){t.lifetime=this.generator.generate()}static fromJSON(t,e){return new C(e.range,e.offset,e.uniformRange,e.uniformOffset,e.normalize)}toJSON(){return{range:this.range,offset:this.offset,uniformRange:this.uniformRange,uniformOffset:this.uniformOffset,normalize:this.normalize}}}class O extends h{constructor(t){super(),this.generator=t.clone()}initializeState(t){t.rotation=this.generator.generate(t.rotation)}static fromJSON(t,e){const i=e.generator.type.fromJSON(e.generator.params);return new O(i)}toJSON(t){return{generator:this.generator.toJSON(t)}}}class E extends h{constructor(t,e,i,s,a){super(),this.range=t,this.offset=e,this.uniformRange=i,this.uniformOffset=s,this.normalize=a,this.generator=new b(0,this.range,this.offset,this.uniformRange,this.uniformOffset,this.normalize)}initializeState(t){t.rotationalSpeed=this.generator.generate()}static fromJSON(t,e){return new E(e.range,e.offset,e.uniformRange,e.uniformOffset,e.normalize)}toJSON(){return{range:this.range,offset:this.offset,uniformRange:this.uniformRange,uniformOffset:this.uniformOffset,normalize:this.normalize}}}class R extends h{constructor(t,e){super(),this.randomGenerator=new b(a.Vector3,t,e,0,0,!1)}initializeState(t){this.randomGenerator.generate(t.position)}static fromJSON(t,e){return new R((new a.Vector3).fromArray(e.range),(new a.Vector3).fromArray(e.offset))}toJSON(){return{range:this.randomGenerator.range.toArray(),offset:this.randomGenerator.offset.toArray()}}}class q extends h{constructor(t){super(),this.generator=t.clone()}initializeState(t){this.generator.generate(t.size),t.initialSize.copy(t.size)}static fromJSON(t,e){const i=e.generator.type.fromJSON(e.generator.params);return new q(i)}toJSON(t){return{generator:this.generator.toJSON(t)}}}class N extends h{constructor(t,e,i,s,r=!0){super(),this.directionGenerator=new b(a.Vector3,t,e,0,0,!0),this.speedGenerator=new b(0,i,s,0,0,!1),this.normalizeDirection=r}initializeState(t){this.directionGenerator.generate(t.velocity),this.normalizeDirection&&t.velocity.normalize(),t.velocity.multiplyScalar(this.speedGenerator.generate())}static fromJSON(t,e){return new N((new a.Vector3).fromArray(e.range),(new a.Vector3).fromArray(e.offset),e.speedRange,e.speedOffset)}toJSON(){return{range:this.directionGenerator.range.toArray(),offset:this.directionGenerator.offset.toArray(),speedRange:this.speedGenerator.range,speedOffset:this.speedGenerator.offset}}}class U extends h{constructor(t,e=!1){super(),this.setParticleSequences(t),this.reverse=e}setParticleSequences(t){this.particleSequences=t}initializeState(t){const e=this.particleSequences.getSequenceIDs(),i=e.length*Math.random(),s=e[Math.floor(i)],a=this.particleSequences.getSequence(s),n=t.sequenceElement;this.reverse?n.x=a.length-1:n.x=a.start,n.y=a.id,n.z=a.start,n.w=a.length,t.progressType=r.Sequence}static fromJSON(t,e){return new U(t.getParticleSequences(),e.reverse)}toJSON(){return{reverse:this.reverse}}}class D extends m{constructor(t,e,i=!1,s=!1){super(),this.particleSequences=t,this.speed=e,this.loop=i,this.reverse=s}updateState(t,e){const i=t.sequenceElement,s=this.particleSequences.getSequence(i.y),a=e/this.speed;if(this.reverse){if(i.x-=a,i.x<s.start&&(i.x=s.start+s.length,!this.loop))return!1}else if(i.x+=a,i.x>=s.start+s.length&&(i.x=s.start,!this.loop))return!1;return!0}static fromJSON(t,e){return new D(t.getParticleSequences(),e.speed,e.loop,e.reverse)}toJSON(){return{speed:this.speed,loop:this.loop,reverse:this.reverse}}}class B{constructor(t,e){this.elements=[],this.tValues=[],this.elementTypeID=z.getTypeID(t),this.interpolator=e||this.getInterpolatorForTypeID(this.elementTypeID)}*[Symbol.iterator](){let t=0;for(;t<this.getElementCount();)yield{element:this.elements[t],tValue:this.tValues[t]},t++}getElementCount(){return this.elements.length}getElement(t){if(t>=this.getElementCount())throw new Error('ContinuousArray::getElement() -> "index" is out of bounds.');return this.elements[t]}getTValue(t){if(t>=this.getElementCount())throw new Error('ContinuousArray::getTValue() -> "index" is out of bounds.');return this.tValues[t]}addElement(t,e){this.elements.push(t),this.tValues.push(e)}getInterpolatedElement(t,e){return this.interpolator(t,this.elements,this.tValues,e)}getInterpolatorForTypeID=function(){const t={lowerIndex:0,upperIndex:0,localT:0},e=new a.Vector2,i=new a.Vector3,s=new a.Vector4,r=new a.Color,n=e=>(i,s,a,r)=>{B.getInterpolationValuesForTValue(a,i,t),e.copy(s[t.upperIndex]).multiplyScalar(t.localT),r.copy(s[t.lowerIndex]).multiplyScalar(1-t.localT).add(e)};return function(a){switch(a){case z.Default:return(e,i,s)=>(B.getInterpolationValuesForTValue(s,e,t),(1-t.localT)*i[t.lowerIndex]+t.localT*i[t.upperIndex]);case z.Vector2:return n(e);case z.Vector3:return n(i);case z.Vector4:return n(s);case z.Color:return n(r)}}}();static getInterpolationValuesForTValue(t,e,i){const s=t.length;if(0===s)return i.lowerIndex=-1,i.upperIndex=-1,void(i.localT=-1);let a=0,r=-1,n=0;for(let c=0;c<s&&(a=t[c],!(a>e));c++)r++,n++;i.lowerIndex=d.clamp(r,0,s-1),i.upperIndex=d.clamp(n,0,s-1);const o=t[r],l=t[n];i.localT=(e-o)/(l-o)}}class M extends m{constructor(t,e=!1){super(),this.relativeToInitialValue=e,this.interpolationElements=new B(t)}addElement(t,e){this.interpolationElements.addElement(t,e)}addElements(t){for(const e of t)this.interpolationElements.addElement(e[0],e[1])}addElementsFromElementClassAndParameters(t,e){for(const i of e){const[...e]=i[0];this.interpolationElements.addElement(new t(...e),i[1])}}getInterpolatedValue(t,e){let i=0;switch(t.progressType){case r.Time:i=0!=t.lifetime?t.age/t.lifetime:t.age;break;case r.Sequence:i=t.sequenceElement.x/t.sequenceElement.w}return this.interpolationElements.getInterpolatedElement(i,e)}}class X extends M{constructor(t=!1){super(0,t)}addElementsFromParameters(t){super.addElements(t)}updateState(t){return this.relativeToInitialValue?t.alpha=t.initialAlpha*this.getInterpolatedValue(t,t.alpha):t.alpha=this.getInterpolatedValue(t,t.alpha),!0}static fromJSON(t,e){return new X(e.relativeToInitialValue)}toJSON(){return{params:{relativeToInitialValue:this.relativeToInitialValue},elements:[...this.interpolationElements].map(t=>[t.element,t.tValue])}}}class J extends M{constructor(t=!1){super(a.Vector2,t)}addElementsFromParameters(t){super.addElementsFromElementClassAndParameters(a.Vector2,t)}updateState=function(){const t=new a.Vector2;return function(e){return this.getInterpolatedValue(e,t),this.relativeToInitialValue?e.size.set(e.initialSize.x*t.x,e.initialSize.y*t.y):e.size.copy(t),!0}}();static fromJSON(t,e){return new J(e.relativeToInitialValue)}toJSON(){return{params:{relativeToInitialValue:this.relativeToInitialValue},elements:[...this.interpolationElements].map(t=>[t.element.toArray(),t.tValue])}}}class j extends M{constructor(t=!1){super(a.Color,t)}addElementsFromParameters(t){super.addElementsFromElementClassAndParameters(a.Color,t)}updateState=function(){const t=new a.Color;return function(e){return this.getInterpolatedValue(e,t),this.relativeToInitialValue?e.color.setRGB(e.initialColor.r*t.r,e.initialColor.g*t.g,e.initialColor.b*t.b):e.color.copy(t),!0}}();static fromJSON(t,e){return new j(e.relativeToInitialValue)}toJSON(){return{params:{relativeToInitialValue:this.relativeToInitialValue},elements:[...this.interpolationElements].map(t=>[t.element.toArray(),t.tValue])}}}class W extends m{constructor(t){super(),this.generator=t.clone()}addElementsFromParameters(t){super.addElementsFromElementClassAndParameters(THREE.Vector3,t)}updateState(t){return this.generator.generate(t.acceleration),!0}static fromJSON(t,e){const i=e.generator.type.fromJSON(e.generator.params);return new W(i)}toJSON(t){return{generator:this.generator.toJSON(t)}}}class Y extends F{constructor(t,e,i,s,r,n,o,l,c,h,u,m){super(a.Vector3),this.rangeTheta=t,this.offsetTheta=e,this.rangePhi=i,this.offsetPhi=s,this.rangeRadius=r,this.offsetRadius=n,this.scaleX=o,this.scaleY=l,this.scaleZ=c,this.offsetX=h,this.offsetY=u,this.offsetZ=m,this.tempUp=(new a.Vector3).set(0,1,0)}generate(t){this.tempUp.set(0,1,0);const e=Math.random()*this.rangeTheta+this.offsetTheta,i=Math.random()*this.rangePhi+this.offsetPhi,s=Math.cos(e),a=Math.sin(e),r=Math.cos(i),n=Math.sin(i);t.set(s,0,-a),t.multiplyScalar(r),this.tempUp.multiplyScalar(n),t.add(this.tempUp),t.normalize();const o=Math.random()*this.rangeRadius+this.offsetRadius;t.multiplyScalar(o),t.x*=this.scaleX,t.y*=this.scaleY,t.z*=this.scaleZ,t.x+=this.offsetX,t.y+=this.offsetY,t.z+=this.offsetZ}clone(){return new Y(this.rangeTheta,this.offsetTheta,this.rangePhi,this.offsetPhi,this.rangeRadius,this.offsetRadius,this.scaleX,this.scaleY,this.scaleZ,this.offsetX,this.offsetY,this.offsetZ)}static fromJSON(t){return new Y(t.rangeTheta,t.offsetTheta,t.rangePhi,t.offsetPhi,t.rangeRadius,t.offsetRadius,t.scaleX,t.scaleY,t.scaleZ,t.offsetX,t.offsetY,t.offsetZ)}toJSON(t){return{type:t.getTypePath(Y),params:{rangeTheta:this.rangeTheta,offsetTheta:this.offsetTheta,rangePhi:this.rangePhi,offsetPhi:this.offsetPhi,rangeRadius:this.rangeRadius,offsetRadius:this.offsetRadius,scaleX:this.scaleX,scaleY:this.scaleY,scaleZ:this.scaleZ,offsetX:this.offsetX,offsetY:this.offsetY,offsetZ:this.offsetZ}}}}class _{constructor(){}}class G extends _{constructor(t,e,i,s,r,n,o=void 0){super(),this.owner=null,this.light=null,this.lastUpdateTime=performance.now()/1e3,this.lastIntensityFlickerTime=this.lastUpdateTime,this.lastPositionFlickerTime=this.lastUpdateTime,this.lastIntensityAdjuster=1,this.nextIntensityAdjuster=1,this.lastPositionAdjuster=new a.Vector3,this.positionAdjuster=new a.Vector3,this.intensity=1,this.intensityFlux=2,this.parent=t,this.init(t,e,i,s,r,n,o)}init(t,e,i,s,r,n,o=void 0){this.owner=new a.Object3D,t.add(this.owner),s=s||new a.Color,r=r||0,null!=n&&null!=n||(n=2);const l=!!o;return this.light=new a.PointLight(16777215,2,0,1),this.light.color.copy(s),this.light.distance=r,this.light.decay=n,this.light.castShadow=l,l&&(this.light.shadow.mapSize.width=o.mapSize||512,this.light.shadow.mapSize.height=o.mapSize||512,this.light.shadow.camera.near=o.cameraNear||.5,this.light.shadow.camera.far=o.cameraFar||500,this.light.shadow.bias=o.bias||1e-4,this.light.shadow.radius=o.edgeRadius||1),this.owner.add(this.light),this.intensity=e,this.intensityFlux=i,this.light}dispose(){this.parent.remove(this.owner)}getLight(){return this.light}setIntensity(t){this.intensity=t}update(t){const e=t-this.lastIntensityFlickerTime,i=1/8,s=this.intensityFlux;if(e>i){this.lastIntensityFlickerTime=t;let e=1+2*(Math.random()-.5)*s*i;const a=e-this.lastIntensityAdjuster;e=this.lastIntensityAdjuster+a,this.lastIntensityAdjuster=this.nextIntensityAdjuster,this.nextIntensityAdjuster=d.clamp(e,.25,1.5)}else{const t=e/i,s=(1-t)*this.lastIntensityAdjuster+t*this.nextIntensityAdjuster;this.light.intensity=s*this.intensity}if(t-this.lastPositionFlickerTime>.0625){this.lastPositionFlickerTime=t;const e=t-this.lastUpdateTime;this.positionAdjuster.set(Math.random()-.5,Math.random()-.5,Math.random()-.5),this.positionAdjuster.multiplyScalar(e),this.positionAdjuster.add(this.lastPositionAdjuster),this.positionAdjuster.multiplyScalar(.5),this.owner.position.copy(this.positionAdjuster),this.lastPositionAdjuster.copy(this.positionAdjuster),this.lastUpdateTime=t}}}class Z{constructor(){this.jsonTypes={default:{}},this.jsonTypeNames={},this.typeIDGen=0}addType(t,e){this.addTypeToNamespace("default",t,e)}addTypeToNamespace(t,e,i){if(!this.jsonTypes[t])throw new Error("JSONTypeStore::addTypeToNamespace() -> namespace does not exist");if(this.jsonTypes[t][e])throw new Error("JSONTypeStore::addTypeToNamespace() -> typeName already exists");this.checkAndAddTypeName(i,e,t)&&(this.jsonTypes[t][e]=i)}addNamespace(t,e){if(this.jsonTypes[t])throw new Error("JSONTypeStore::addNamespace() -> namespace already exists");this.jsonTypes[t]=e;for(const i in e)if(!e.hasOwnProperty||e.hasOwnProperty(i)){const s=e[i];this.checkAndAddTypeName(s,i,t)}}checkAndAddTypeName(t,e,i){if("function"==typeof t){const s=this.typeIDGen++;t.___photonsTypeID=s,this.jsonTypeNames[s]={namespace:i,typeName:e}}}getType(t,e){if(!this.jsonTypes[t])throw new Error("JSONTypeStore::getType() -> namespace does not exist");if(!this.jsonTypes[t][e])throw new Error("JSONTypeStore::getType() -> typeName does not exist");return this.jsonTypes[t][e]}getTypeNames(t){return this.jsonTypeNames[t.___photonsTypeID]}getTypePath(t){const e=this.getTypeNames(t);if(e)return`${e.namespace}.${e.typeName}`}parseNamespaceAndTypename(t){const e=t.split("."),i=e[0];e.splice(0,1);return{namespace:i,typeName:e.join(".")}}parseTypeString(t){const{namespace:e,typeName:i}=this.parseNamespaceAndTypename(t);return this.getType(e,i)}}const k=Object.freeze(Object.defineProperty({__proto__:null,AccelerationOperator:W,AnimatedSpriteRenderer:I,Atlas:x,BaseParticleStateInitializer:u,BaseParticleStateOperator:p,BoxPositionInitializer:R,ColorInterpolatorOperator:j,ConstantParticleEmitter:T,FlickerLight:G,JSONTypeStore:Z,LifetimeInitializer:C,Manager:y,OpacityInterpolatorOperator:X,ParticleStateArray:o,ParticleSystem:S,ParticleSystemState:g,RandomGenerator:b,RandomVelocityInitializer:N,Renderer:w,RotationInitializer:O,RotationalSpeedInitializer:E,SequenceInitializer:U,SequenceOperator:D,SizeInitializer:q,SizeInterpolatorOperator:J,SphereRandomGenerator:Y},Symbol.toStringTag,{value:"Module"})),{defineComponent:L}=await t("vue"),H=await t("three"),$=L({__name:"fireF",props:{position:{default:[0,0,0]},scale:{default:1}},setup(t){const e=t,a=new y,r=new Z;r.addNamespace("THREE",H),r.addNamespace("Photons",k);const{renderer:n,camera:o,scene:l}=i(),c=new H.Vector3(...e.position);a.addParticleSystem(((t,e)=>{const i=new H.Object3D;i.position.copy(e);const s="./plugins/digitalCity/image/fireF/ember.png",a=(new H.TextureLoader).load(s),r=new x(a,s);r.addFrameSet(1,0,0,1,1);const o=new I(!0,r,!0,H.AdditiveBlending),l=new S(i,o,n);l.init(150),l.setEmitter(new T(6));const c=new b(H.Vector2,new H.Vector2(0,0),new H.Vector2(.15*t,.15*t),0,0,!1);l.addParticleStateInitializer(new C(3,1,0,0,!1)),l.addParticleStateInitializer(new q(c)),l.addParticleStateInitializer(new R(new H.Vector3(.05*t,0,.05*t),new H.Vector3(-.025*t,0,-.025*t))),l.addParticleStateInitializer(new N(new H.Vector3(.4*t,.5*t,.4*t),new H.Vector3(-.2*t,.8*t,-.2*t),.6*t,.8*t,!1));l.addParticleStateOperator(new X).addElements([[0,0],[.7,.25],[.9,.75],[0,1]]);l.addParticleStateOperator(new j(!0)).addElementsFromParameters([[[1,.7,0],0],[[1,.6,0],.5],[[1,.4,0],1]]);const h=new Y(2*Math.PI,0,Math.PI,-Math.PI/2,20,-8,t,t,t,0,0,0);return l.addParticleStateOperator(new W(h)),l.setSimulateInWorldSpace(!0),l.start(),l})(e.scale,c)),a.addParticleSystem(((t,e)=>{const i=new H.Object3D;i.position.copy(e);const s="./plugins/digitalCity/image/fireF/base_flame.png",a=(new H.TextureLoader).load(s),r=new x(a,s);r.addFrameSet(18,0,0,.125,.25);const o=new I(!0,r,!0),l=new S(i,o,n);l.init(50),l.setEmitter(new T(10)),l.addParticleSequence(0,18);const c=l.getParticleSequences();l.addParticleStateInitializer(new C(0,0,0,0,!1)),l.addParticleStateInitializer(new O(new b(0,Math.PI/2,-Math.PI/2,0,0,!1))),l.addParticleStateInitializer(new E(1,-1,0,0,!1)),l.addParticleStateInitializer(new q(new b(H.Vector2,new H.Vector2(.25*t,.25*t),new H.Vector2(.5*t,.5*t),0,0,!1))),l.addParticleStateInitializer(new R(new H.Vector3(.05*t,0,.05*t),new H.Vector3(-.025*t,0,-.025*t))),l.addParticleStateInitializer(new N(new H.Vector3(.05*t,.4*t,.05*t),new H.Vector3(-.025*t,.8*t,-.025*t),.35*t,.5*t,!1)),l.addParticleStateInitializer(new U(c)),l.addParticleStateOperator(new D(c,.07,!1));l.addParticleStateOperator(new X).addElements([[0,0],[.3,.25],[.3,.5],[0,1]]);l.addParticleStateOperator(new J(!0)).addElementsFromParameters([[[.6,.6],0],[[1,1],.4],[[1,1],1]]);return l.addParticleStateOperator(new j(!0)).addElementsFromParameters([[[1,1,1],0],[[1.5,1.5,1.5],.5],[[1,1,1],1]]),l.addParticleStateOperator(new W(new b(H.Vector3,new H.Vector3(0,0,0),new H.Vector3(0,1.5*t,0),0,0,!1))),l.setSimulateInWorldSpace(!0),l.start(),l})(e.scale,c)),a.addParticleSystem(((t,e)=>{const i=new H.Object3D;i.position.copy(e);const s="./plugins/digitalCity/image/fireF/bright_flame.png",a=(new H.TextureLoader).load(s),r=new x(a,s);r.addFrameSet(16,0,0,212/1024,.25);const o=new I(!0,r,!0),l=new S(i,o,n);l.init(20),l.setEmitter(new T(5)),l.addParticleSequence(0,16);const c=l.getParticleSequences();l.addParticleStateInitializer(new C(0,0,0,0,!1)),l.addParticleStateInitializer(new O(new b(0,Math.PI,-Math.PI/2,0,0,!1))),l.addParticleStateInitializer(new E(Math.PI/2,-Math.PI/4,0,0,!1)),l.addParticleStateInitializer(new q(new b(H.Vector2,new H.Vector2(0,0),new H.Vector2(0,0),.2*t,.65*t,!1))),l.addParticleStateInitializer(new R(new H.Vector3(.1*t,0,.1*t),new H.Vector3(-.05*t,0,-.05*t))),l.addParticleStateInitializer(new N(new H.Vector3(.02*t,.4*t,.02*t),new H.Vector3(-.01*t,.4*t,-.01*t),.1*t,.2*t,!1)),l.addParticleStateInitializer(new U(c)),l.addParticleStateOperator(new D(c,.1,!1));l.addParticleStateOperator(new X).addElements([[0,0],[.6,.2],[.5,.75],[0,1]]);l.addParticleStateOperator(new J(!0)).addElementsFromParameters([[[.3,.3],0],[[1,1],.4],[[1,1],.55],[[.65,.65],.75],[[.1,.1],1]]);return l.addParticleStateOperator(new j(!0)).addElementsFromParameters([[[1,1,1],0],[[2,2,2],.3],[[2,2,2],.4],[[.9,.6,.3],.65],[[.75,0,0],1]]),l.addParticleStateOperator(new W(new b(H.Vector3,new H.Vector3(0,0,0),new H.Vector3(0,1.5*t,0),0,0,!1))),l.setSimulateInWorldSpace(!0),l.start(),l})(e.scale,c)),a.addComponent(((t,e=10)=>{const i=new H.Object3D;l.value.add(i),i.position.copy(t);return new G(i,e,2,(new H.Color).setRGB(1,.8,.4),0,1,{mapSize:1024,cameraNear:.1,cameraFar:5e3,bias:9e-6,edgeRadius:3})})(c,100));const{onRender:h}=s();return h(()=>{a.update(),a.render(n,o.value)}),(t,e)=>null}}),{defineComponent:K}=await t("vue"),{createVNode:Q,withCtx:tt,openBlock:et,createBlock:it}=await t("vue"),{ref:st,watch:at}=await t("vue"),rt=K({__name:"fireF",setup(t){const i=st();return at(()=>i.value?.contextReady,t=>{t&&i.value.context.context.camera.activeCamera.value.position.set(580,360,500)}),(t,s)=>(et(),it(e,{ref_key:"pagesShowRef",ref:i},{ability:tt(()=>[Q($,{position:[0,20,10],scale:40})]),_:1},512))}});export{rt as default};
