import{importShared as e}from"./3d-tiles-renderer.DoRCwQO21769048796101.js";import{useTexture as t,useLoop as o}from"./index.DY1Qq3wV1769048796101.js";const{defineComponent:n}=await e("vue"),{unref:a,mergeProps:r,createElementVNode:i,openBlock:l,createElementBlock:u}=await e("vue"),s=["map"],{reactive:f,shallowRef:c,watchEffect:d}=await e("vue"),g=n({__name:"buildingsMarkA",props:{color:{default:"#fff"},img:{},offset:{default:[.344,.394]},foremost:{type:Boolean,default:!0},sizeAttenuation:{type:Boolean,default:!1}},setup(e){const o=e,{state:n}=t(o.img),g=f({color:o.color,transparent:!0,depthWrite:!1,sizeAttenuation:o.sizeAttenuation,toneMapped:!1,depthTest:!o.foremost}),p=c(null);return d(()=>{p.value&&(p.value.geometry=p.value.geometry.clone(),p.value.geometry.translate(o.offset[0],o.offset[1],0))}),(e,t)=>(l(),u("TresSprite",{ref_key:"tsRef",ref:p,scale:.1,renderOrder:"99999"},[i("TresSpriteMaterial",r(g,{map:a(n)}),null,16,s)],512))}}),{defineComponent:p}=await e("vue"),{createElementVNode:v,unref:m,mergeProps:h,openBlock:y,createElementBlock:w}=await e("vue"),x=["args"],_=["side"],{nextTick:P,ref:M,watch:T,watchEffect:A}=await e("vue"),{Matrix4:C,DoubleSide:F,Color:R}=await e("three"),k=p({__name:"radraA",props:{size:{default:300},radius:{default:240},color:{default:"#ffff00"},opacity:{default:.9},speed:{default:1},followWidth:{default:220}},setup(e){const t=e,{onBeforeRender:n}=o(),a={value:0},r=M();n(()=>{a.value+=.02*t.speed});const i={transparent:!0,depthWrite:!1,depthTest:!0,vertexShader:"\n\tvarying vec3 vPosition;\n\tvoid main() {\n\t\tvPosition = position;\n\t\tvec4 modelPosition = modelMatrix * vec4(position, 1.0);\n\t\tvec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectionPosition = projectionMatrix * viewPosition;\n    gl_Position = projectionPosition;\n  }\n  ",fragmentShader:"\n\tuniform float uRadius;     \n  uniform float uTime;      \n  uniform float uFollowWidth; \n  varying vec3 vPosition;\n\tuniform float uOpacity;\n\tuniform vec3 ncolor;\n  float calcAngle(vec3 oFrag){\n    float fragAngle;\n    const vec3 ox = vec3(1,0,0);\n    float dianji = oFrag.x * ox.x + oFrag.z*ox.z;\n    float oFrag_length = length(oFrag); // length是内置函数\n    float ox_length = length(ox); // length是内置函数\n    float yuxian = dianji / (oFrag_length * ox_length);\n    fragAngle = acos(yuxian);\n    fragAngle = degrees(fragAngle);\n    if(oFrag.z > 0.0) {\n      fragAngle = -fragAngle + 360.0;\n    }\n    float scanAngle = uTime * 100.0 - floor(uTime * 100.0 / 360.0) * 360.0;\n    float angle = scanAngle - fragAngle;\n    if(angle < 0.0){\n      angle = angle + 360.0;\n    }\n    return angle;\n  }\n  void main() {\n\t\t\t// length内置函数，取向量的长度\n\t\tif(length(vPosition) == 0.0 || length(vPosition) > uRadius-2.0){\n\t\t\tgl_FragColor = vec4( ncolor, uOpacity );\n\t\t} else {\n\t\t\tfloat angle = calcAngle(vPosition);\n\t\t\tif(angle < uFollowWidth){\n\t\t\t\t// 尾焰区域\n\t\t\t\tfloat opacity =  1.0 - angle / uFollowWidth; \n\t\t\t\tgl_FragColor = vec4( ncolor, uOpacity * opacity );  \n\t\t\t} else {\n\t\t\t\t// 其他位置的像素均为透明\n\t\t\t\tgl_FragColor = vec4( ncolor, 0.0 ); \n\t\t\t}\n\t\t}\n\t}\n  ",uniforms:{uRadius:{value:t.radius},uTime:a,uFollowWidth:{value:t.followWidth},ncolor:{value:new R(t.color)},uOpacity:{value:t.opacity}}};return T(r,(e,t)=>{e&&void 0===t&&r.value.applyMatrix4((new C).makeRotationX(-Math.PI/2))}),T(()=>t.size,()=>{P(()=>{r.value.applyMatrix4((new C).makeRotationX(Math.PI/2))})}),A(()=>{t.color&&(i.uniforms.ncolor.value=new R(t.color)),t.opacity&&(i.uniforms.uOpacity.value=t.opacity),t.radius&&(i.uniforms.uRadius.value=t.radius),t.followWidth&&(i.uniforms.uFollowWidth.value=t.followWidth)}),(e,o)=>(y(),w("TresMesh",null,[v("TresCircleGeometry",{ref_key:"TresCircleGeometryRef",ref:r,args:[t.size,64]},null,8,x),v("TresShaderMaterial",h(i,{side:m(F)}),null,16,_)]))}}),{defineComponent:S}=await e("vue"),{createElementVNode:W,normalizeProps:z,guardReactiveProps:B,openBlock:O,createElementBlock:E}=await e("vue"),j=["args"],{ref:V,watchEffect:b}=await e("vue"),{DoubleSide:H,Color:Y,LineCurve3:G,Vector3:N}=await e("three"),D=S({__name:"radraB",props:{radius:{default:1},maxRadius:{default:20},color:{default:"#ffff00"},opacity:{default:1},speed:{default:.3},height:{default:100}},setup(e,{expose:t}){const n=e,a=V(),r=V(1),i={transparent:!0,depthWrite:!1,side:H,uniforms:{uColor:{value:new Y(n.color)},uOpacity:{value:n.opacity},uHeight:{value:n.height},uScale:r},vertexShader:"\n    uniform float uScale;\n    varying float vY;\n\n    void main() {\n      vec3 p = position;\n      p.xz *= uScale;\n      vY = position.y;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);\n    }\n  ",fragmentShader:"\n    uniform vec3 uColor;\n    uniform float uOpacity;\n    uniform float uHeight;\n    varying float vY;\n\n    void main() {\n      float alpha = (1.0 - vY / uHeight) * uOpacity;\n      gl_FragColor = vec4(uColor, alpha);\n    }\n  "};b(()=>{i.uniforms.uColor.value.set(n.color),i.uniforms.uOpacity.value=n.opacity,i.uniforms.uHeight.value=n.height});const{onBeforeRender:l}=o();let u=0;l(()=>{u+=.02*n.speed;const e=u%1,t=n.radius+e*(n.maxRadius-n.radius);r.value=t/n.radius});const s=V(new G(new N(0,0,0),new N(0,10,0)));return t({MeshRef:a}),(e,t)=>(O(),E("TresMesh",{ref_key:"MeshRef",ref:a,renderOrder:2e3},[W("TresTubeGeometry",{args:[s.value,20,n.radius,64,!1]},null,8,j),W("TresShaderMaterial",z(B(i)),null,16)],512))}});export{g as _sfc_main,k as _sfc_main$1,D as _sfc_main$2};
