import{m as n,e,a as t,o as r,f as o}from"./@tresjs.nk0nhZ9a1742205305014.js";import{P as i}from"./tweakpane.yDiyAAkA1742205305014.js";import{_ as c,C as a,o as l,aW as s,r as u,V as f,s as p}from"./three.LxxvsMJG1742205305014.js";import{d as v,a3 as g,b as d,o as x,f as h,u as m,g as y,j as w,al as b,r as C,N as R,aj as I,ak as _}from"./@vue.NRI7TcgI1742205305014.js";import"./postprocessing.lrLv6HE21742205305014.js";import"./@vueuse.w6JAmAgA1742205305014.js";var M="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const z=L;!function(n,e){const t=L,r=A();for(;;)try{if(156030===-parseInt(t(362))/1+-parseInt(t(393))/2+-parseInt(t(373))/3*(-parseInt(t(388))/4)+parseInt(t(361))/5+parseInt(t(398))/6+parseInt(t(404))/7+-parseInt(t(382))/8*(parseInt(t(365))/9))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const D=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){D(this,(function(){const n=L,e=new RegExp(n(371)),t=new RegExp(n(395),"i"),r=O(n(376));e[n(408)](r+"chain")&&t[n(408)](r+n(397))?O():r("0")}))()}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[L(366)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function A(){const n=["length","render","pool","104BEwZCb","BufferGeometry",'{}.constructor("return this")( )',"Mesh","uniforms","setAttribute","43960bbETCm","waterTexture","error","water","table","459094zxkWZl","causticsTexture","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","position","input","1697958cbXwls","call","string","gger","action","causticTex","2106888vDwGjm","constructor","tiles","prototype","test","value","return (function() ","303005GcCERz","43743oIwIMq","BufferAttribute","RawShaderMaterial","202284xCvQTn","apply","console","bind","info","log","function *\\( *\\)","debu","21VQzRWN","exception","FrontSide","init","toString","light"];return(A=function(){return n})()}function L(n,e){const t=A();return(L=function(n,e){return t[n-=359]})(n,e)}T(void 0,(function(){const n=L,e=function(){const n=L;let e;try{e=Function(n(360)+n(384)+");")()}catch(t){e=window}return e}(),t=e[n(367)]=e.console||{},r=[n(370),"warn",n(369),n(390),n(374),n(392),"trace"];for(let o=0;o<r[n(379)];o++){const e=T[n(405)][n(407)][n(368)](T),i=r[o],c=t[i]||e;e.__proto__=T[n(368)](T),e[n(377)]=c[n(377)][n(368)](c),t[i]=e}}))();const F=v({__name:z(381),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=z,o=t,i=new(c[r(383)]),a=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),l=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(387)](r(396),new(c[r(363)])(a,3)),i.setIndex(new(c[r(363)])(l,1));const s=new(c[r(364)])({uniforms:{light:{value:o[r(378)]},tiles:{value:o[r(406)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(375)]}),u=new(c[r(385)])(i,s),{renderer:f,camera:p}=n(),{onAfterLoop:v}=e();return v((()=>{const n=r;((n,e)=>{const t=r;s[t(386)][t(391)][t(359)]=n,s[t(386)][t(403)].value=e,f[t(359)][t(380)](u,p[t(359)])})(o[n(389)],o[n(394)])})),(n,e)=>null}});function O(n){function e(n){const t=L;if(typeof n===t(400))return function(n){}[t(405)]("while (true) {}").apply("counter");1!==(""+n/n)[t(379)]||n%20==0?function(){return!0}[t(405)](t(372)+"gger")[t(399)](t(402)):function(){return!1}[t(405)](t(372)+t(401)).apply("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const E=S;!function(n,e){const t=S,r=P();for(;;)try{if(819406===parseInt(t(257))/1*(parseInt(t(249))/2)+parseInt(t(262))/3*(parseInt(t(274))/4)+-parseInt(t(292))/5*(-parseInt(t(281))/6)+parseInt(t(261))/7*(parseInt(t(248))/8)+parseInt(t(256))/9+parseInt(t(287))/10+-parseInt(t(239))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[S(259)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function S(n,e){const t=P();return(S=function(n,e){return t[n-=238]})(n,e)}!function(){j(this,(function(){const n=S,e=new RegExp(n(275)),t=new RegExp(n(241),"i"),r=k(n(276));e[n(291)](r+n(294))&&t[n(291)](r+n(267))?k():r("0")}))()}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[S(259)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function P(){const n=["function *\\( *\\)","init","table","neg-x.jpg","/images/skyBox/6jpg/","debu","6zYKYtW","BackSide","resource.cos","light","__proto__","trace","7748270AnSUJB","gger","water","pos-z.jpg","test","5181305tEVEvA","side","chain","length","load","pooRef","value","action","console","string","tiles","neg-z.jpg","59792656gDaFhz","RawShaderMaterial","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","clear","while (true) {}","pos-x.jpg","FrontSide","uniforms","waterTexture","10840ubKGJK","252118LnQbro","info","stateObject","CubeTextureLoader","render","Mesh","setRenderTarget","14454531jVUcxD","9ZeboJr","warn","apply","constructor","5138oDhhxd","45246avJNcG","toString","call","causticsTexture","pos-y.jpg","input","bind","return (function() ","setPath","error","setClearColor","exception","188TiaosS"];return(P=function(){return n})()}W(void 0,(function(){const n=S,e=function(){const n=S;let e;try{e=Function(n(269)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(300)]=e[n(300)]||{},r=["log",n(258),n(250),n(271),n(273),n(277),n(286)];for(let o=0;o<r.length;o++){const e=W[n(260)].prototype.bind(W),i=r[o],c=t[i]||e;e[n(285)]=W[n(268)](W),e[n(263)]=c[n(263)][n(268)](c),t[i]=e}}))();const V=v({__name:E(289),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=E;let i,l;const s=r,u=s.geometry,f=(new(c[o(252)]))[o(270)]("https://opensource-1314935952.cos.ap-nanjing.myqcloud.com"+o(279))[o(296)]([o(244),o(278),o(266),"neg-y.jpg",o(290),o(238)]),p=([i,l]=g((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,l(),i),v=new(c[o(240)])({uniforms:{light:{value:s[o(284)]},tiles:{value:p},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new(c[o(254)])(u,v),w=d(null),b=new a("white"),{renderer:C,camera:R}=n(),{onLoop:I}=e();return I((()=>{const n=o;C.value[n(255)](null),C.value[n(272)](b,1),C[n(298)][n(242)](),v.uniforms.water[n(298)]=s[n(247)],v[n(246)].causticTex[n(298)]=s.causticsTexture,v.side=c[n(245)],v[n(246)].underwater.value=!0,C.value[n(253)](y,R.value),v[n(293)]=c[n(282)],v[n(246)].underwater[n(298)]=!1,C[n(298)].render(y,R[n(298)])})),(n,e)=>{const t=o;return x(),h(F,{tiles:m(p),light:n[t(284)],waterTexture:n[t(247)],causticsTexture:n.causticsTexture,ref_key:t(297),ref:w},null,8,[t(302),t(284),t(247),t(265)])}}});function k(n){function e(n){const t=S;if(typeof n===t(301))return function(n){}.constructor(t(243)).apply("counter");1!==(""+n/n)[t(295)]||n%20==0?function(){return!0}[t(260)](t(280)+t(288))[t(264)](t(299)):function(){return!1}[t(260)]("debu"+t(288))[t(259)](t(251)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const H=B;function B(n,e){const t=G();return(B=function(n,e){return t[n-=180]})(n,e)}!function(n,e){const t=B,r=G();for(;;)try{if(659974===-parseInt(t(223))/1*(-parseInt(t(195))/2)+-parseInt(t(180))/3+parseInt(t(188))/4+parseInt(t(230))/5+parseInt(t(189))/6+parseInt(t(197))/7*(-parseInt(t(204))/8)+parseInt(t(187))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Z(this,(function(){const n=B,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(212),"i"),r=K(n(229));e.test(r+n(209))&&t[n(183)](r+n(193))?K():r("0")}))()}();const N=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[B(185)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function G(){const n=["black","1387284CfJHQp","geometry","call","test","stateObject","apply","light","1699434IvmPJk","773704CTcHbP","2784144pBGfOJ","ShaderMaterial","warn","WebGLRenderTarget","input","texture","223634raiszR","table","1120bKCIaF","while (true) {}","length","value","clear","bind","Mesh","7024PTfChk","console","__proto__","caustics","info","chain","waterTexture","trace","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","prototype","setClearColor","uniforms","OrthographicCamera","constructor","log","render","counter","debu","toString","3RQNtqW","PlaneGeometry","action","material","string","causticsTexture","init","405775vFKVvJ","Color","setRenderTarget","return (function() "];return(G=function(){return n})()}N(void 0,(function(){const n=B;let e;try{e=Function(n(233)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(205)]=e[n(205)]||{},r=[n(218),n(191),n(208),"error","exception",n(196),n(211)];for(let i=0;i<r[n(199)];i++){const e=N[n(217)][n(213)][n(202)](N),o=r[i],c=t[o]||e;e[n(206)]=N[n(202)](N),e[n(222)]=c[n(222)][n(202)](c),t[o]=e}}))();const J=v({__name:H(207),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=H,o=t,i=new(c[r(216)])(0,1,1,0,0,2e3),a=new(c[r(224)])(2,2,200,200),l=new(c[r(192)])(1024,1024),s=new(c[r(190)])({uniforms:{light:{value:o[r(186)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),u=new(c[r(203)])(a,s),f=new(c[r(231)])(r(234)),{renderer:p}=n(),{onBeforeLoop:v}=e();return v((()=>{const n=r;u[n(226)][n(215)].water[n(200)]=o.waterTexture,p.value[n(232)](l),p[n(200)][n(214)](f,0),p[n(200)][n(201)](),p.value[n(219)](u,i)})),(n,e)=>{const t=r;return x(),h(b,null,{default:y((()=>[w(V,{waterTexture:n[t(210)],causticsTexture:m(l)[t(194)],light:n[t(186)],geometry:m(a)},null,8,[t(210),t(228),t(186),t(181)])])),_:1})}}});function K(n){function e(n){const t=B;if(typeof n===t(227))return function(n){}[t(217)](t(198))[t(185)](t(220));1!==(""+n/n)[t(199)]||n%20==0?function(){return!0}[t(217)](t(221)+"gger")[t(182)](t(225)):function(){return!1}[t(217)]("debugger")[t(185)](t(184)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function $(n,e){const t=Y();return($=function(n,e){return t[n-=410]})(n,e)}!function(n,e){const t=$,r=Y();for(;;)try{if(374523===-parseInt(t(471))/1+-parseInt(t(458))/2+-parseInt(t(432))/3*(parseInt(t(443))/4)+parseInt(t(481))/5+parseInt(t(423))/6*(parseInt(t(457))/7)+-parseInt(t(477))/8+parseInt(t(472))/9*(parseInt(t(473))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){q(this,(function(){const n=$,e=new RegExp(n(453)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=X(n(460));e[n(428)](r+n(426))&&t[n(428)](r+n(480))?X():r("0")}))()}();const Q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Y(){const n=["49chfMYr","29668rBSvqj","material","init","intersectObject","debu","center","value","gger","setFromCamera",'{}.constructor("return this")( )',"stateObject","toString","PlaneGeometry","539704FAKIeK","3535173idJtxc","30TcHSed","position","bind","domElement","3887784WNBmXR","OrthographicCamera","getY","input","1866580btyZEq","constructor","clientY","width","height","point","getBoundingClientRect","warn","WebGLRenderTarget","counter","RawShaderMaterial","top","removeEventListener","string","302658nDkRBM","radius","setRenderTarget","chain","mousemove","test","apply","clientX","FloatType","244887emJwnZ","exception","Mesh","uniforms","action","texture","while (true) {}","length","info","strength","console","24VvXlCD","autoClear","return (function() ","light","setY","call","error","needsUpdate","setZ","table","function *\\( *\\)","addEventListener","attributes","log"];return(Y=function(){return n})()}Q(void 0,(function(){const n=$;let e;try{e=Function(n(445)+n(467)+");")()}catch(o){e=window}const t=e[n(442)]=e[n(442)]||{},r=[n(456),n(416),n(440),n(449),n(433),n(452),"trace"];for(let i=0;i<r.length;i++){const e=Q[n(410)].prototype.bind(Q),o=r[i],c=t[o]||e;e.__proto__=Q[n(475)](Q),e[n(469)]=c[n(469)].bind(c),t[o]=e}}))();const U=v({__name:"waterSimulation",props:{light:{}},setup(t,{expose:r}){const o=$,i=new(c[o(478)])(0,1,1,0,0,2e3),a=new(c[o(470)])(2,2),v=new(c[o(417)])(256,256,{type:l}),g=new(c[o(417)])(256,256,{type:c[o(431)]}),d=new s({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),y=new(c[o(419)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),w=new(c[o(419)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),b=new(c[o(434)])(a,d),C=new u(a,y),R=new u(a,w);let I=v;const _=(n,e)=>{const t=o,r=I,c=I===v?g:v;e[t(459)][t(435)][t(437)][t(464)]=r[t(437)],n[t(425)](c),n.render(e,i),I=c},{renderer:z,camera:D,raycaster:T}=n();z[o(464)][o(444)]=!1;const{onBeforeLoop:A}=e();A((()=>{const n=o;var e,t;t=z[n(464)],_(t,R),e=z[n(464)],_(e,C)}));const L=(n,e,t,r)=>{const i=o;b[i(459)].uniforms[i(463)][i(464)]=[n,e],b[i(459)][i(435)][i(424)].value=t,b[i(459)][i(435)][i(441)].value=r,_(z.value,b)},F=new f,O=new p(2,2),E=O[o(455)][o(474)];for(let n=0;n<E.count;n++){const e=-E[o(479)](n);E[o(447)](n,0),E[o(451)](n,e)}E[o(450)]=!0;const j=new(c[o(434)])(O),S={handleEvent:n=>{const e=o,t=z.value[e(476)][e(415)](),r=t[e(412)],i=t[e(413)];F.x=2*(n[e(430)]-t.left)/r-1,F.y=2*-(n[e(411)]-t[e(420)])/i+1,T[e(464)][e(466)](F,D[e(464)]);const c=T[e(464)][e(461)](j);for(let o of c)L(o[e(414)].x,o.point.z,.03,.04)}};return r({addDrop:L,mouseEvent:n=>{const e=o;n?z[e(464)][e(476)][e(454)](e(427),S):z[e(464)][e(476)][e(421)](e(427),S)}}),(n,e)=>{const t=o;return x(),h(J,{lightFrontGeometry:m(a),waterTexture:m(I).texture,light:n[t(446)]},null,8,["lightFrontGeometry","waterTexture",t(446)])}}});function X(n){function e(n){const t=$;if(typeof n===t(422))return function(n){}[t(410)](t(438))[t(429)](t(418));1!==(""+n/n)[t(439)]||n%20==0?function(){return!0}[t(410)](t(462)+t(465))[t(448)](t(436)):function(){return!1}.constructor(t(462)+"gger")[t(429)](t(468)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const nn=on;!function(n,e){const t=on,r=tn();for(;;)try{if(876468===-parseInt(t(491))/1*(-parseInt(t(482))/2)+-parseInt(t(464))/3*(parseInt(t(476))/4)+parseInt(t(499))/5+parseInt(t(475))/6+-parseInt(t(501))/7+-parseInt(t(489))/8+-parseInt(t(498))/9*(-parseInt(t(493))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(458)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function tn(){const n=["click","gger","exception","点击按钮","error","debu",'{}.constructor("return this")( )',"TresPerspectiveCamera","7733916WCNLQU","9956KWsopP","random","addBinding","__proto__","console","toString","376fCYHnn","bind","value","waterSimulationRef","length","info","call","2216120HZQucP","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","2114ewogRE","return (function() ","860mKaBxM","mouseEvent","prototype","input","function *\\( *\\)","22482BKtGMi","5605505IidnnU","constructor","9980754pzgmvq","realWater","addButton","counter","apply","addDrop","test","table","chain","string","534QrCMoa","while (true) {}","stateObject"];return(tn=function(){return n})()}!function(){en(this,(function(){const n=on,e=new RegExp(n(497)),t=new RegExp(n(490),"i"),r=an("init");e[n(460)](r+n(462))&&t[n(460)](r+n(496))?an():r("0")}))()}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(458)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function on(n,e){const t=tn();return(on=function(n,e){return t[n-=455]})(n,e)}rn(void 0,(function(){const n=on,e=function(){const n=on;let e;try{e=Function(n(492)+n(473)+");")()}catch(t){e=window}return e}(),t=e[n(480)]=e.console||{},r=["log","warn",n(487),n(471),n(469),n(461),"trace"];for(let o=0;o<r[n(486)];o++){const e=rn[n(500)][n(495)][n(483)](rn),i=r[o],c=t[i]||e;e[n(479)]=rn[n(483)](rn),e.toString=c[n(481)][n(483)](c),t[i]=e}}))();const cn=v({__name:nn(455),setup(n){const e=nn,t=C({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:"manual"}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=d(null),l=new i;l[e(456)]({label:e(470),title:"随机增加波纹"}).on(e(467),(()=>{const n=e;for(var t=0;t<10;t++)a[n(484)][n(459)](2*Math.random()-1,2*Math[n(477)]()-1,.03,1&t?.02:-.02)}));const s=d(!1);return l[e(478)](s,e(484),{label:"鼠标波纹"}).on("change",(n=>{const t=e;a[t(484)][t(494)](n[t(484)])})),(n,i)=>{const l=e;return x(),h(m(o),I(_(t)),{default:y((()=>[i[0]||(i[0]=R(l(474),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),w(m(r)),w(U,{light:c,ref_key:l(485),ref:a},null,512)])),_:1},16)}}});function an(n){function e(n){const t=on;if(typeof n===t(463))return function(n){}[t(500)](t(465))[t(458)](t(457));1!==(""+n/n).length||n%20==0?function(){return!0}[t(500)]("debu"+t(468))[t(488)]("action"):function(){return!1}.constructor(t(472)+t(468))[t(458)](t(466)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{cn as default};
