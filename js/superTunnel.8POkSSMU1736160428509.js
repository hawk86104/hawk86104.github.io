import{e as t}from"./@tresjs.8MtVPQyb1736160428509.js";import{a0 as n,az as e}from"./three.rmsIv-u_1736160428509.js";import{_ as r}from"./argestCircle.iQbYZf4A1736160428509.js";import{d as o,e as s,o as a,f as c,g as i,m as p,J as v,aj as u,ak as l}from"./@vue.4u_eOGex1736160428509.js";import"./@vueuse.GObPVvIB1736160428509.js";const f=y;!function(t,n){const e=y,r=m();for(;;)try{if(604276===-parseInt(e(441))/1*(parseInt(e(444))/2)+-parseInt(e(427))/3*(-parseInt(e(414))/4)+-parseInt(e(451))/5*(-parseInt(e(403))/6)+-parseInt(e(437))/7+parseInt(e(401))/8*(parseInt(e(411))/9)+parseInt(e(446))/10*(-parseInt(e(433))/11)+parseInt(e(452))/12*(parseInt(e(419))/13))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const d=function(){let t=!0;return function(n,e){const r=t?function(){if(e){const t=e.apply(n,arguments);return e=null,t}}:function(){};return t=!1,r}}();function m(){const t=["length","8VVGvAz","log","6vhggli","#000000","TresPerspectiveCamera","info","function *\\( *\\)","TresDirectionalLight","gger","input","5517081oxihpD","quanMeshRef","call","2692oFAPGW","#ffffff","TresPlaneGeometry","warn","rotation-x","13606463pOpyKE","error","counter","constructor","chain","superTunnel","TresAmbientLight","debu","1101oWkAwh",'{}.constructor("return this")( )',"return (function() ","trace","__proto__","console","630927ShQDQN","action","value","apply","5018314Wmwmei","prototype","TresMesh","while (true) {}","1100023STTkMl","TresShaderMaterial","bind","2hFhySZ","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","90zWMDJw","toString","string","test","table","5153815jVTGYU","12ERfJjk","uTime","stateObject","uniforms"];return(m=function(){return t})()}!function(){d(this,(function(){const t=y,n=new RegExp(t(407)),e=new RegExp(t(445),"i"),r=b("init");n.test(r+t(423))&&e[t(449)](r+t(410))?b():r("0")}))()}();const x=function(){let t=!0;return function(n,e){const r=t?function(){if(e){const t=e[y(436)](n,arguments);return e=null,t}}:function(){};return t=!1,r}}();function y(t,n){const e=m();return(y=function(t,n){return e[t-=399]})(t,n)}x(void 0,(function(){const t=y,n=function(){const t=y;let n;try{n=Function(t(429)+t(428)+");")()}catch(e){n=window}return n}(),e=n.console=n[t(432)]||{},r=[t(402),t(417),t(406),t(420),"exception",t(450),t(430)];for(let o=0;o<r[t(400)];o++){const n=x[t(422)][t(438)][t(443)](x),s=r[o],a=e[s]||n;n[t(431)]=x[t(443)](x),n[t(447)]=a[t(447)][t(443)](a),e[s]=n}}))();const h={ref:"perspectiveCameraRef",position:[0,0,1800],fov:45,near:1,far:1e4},g=[f(418)],z=o({__name:f(424),setup(o){const d=f,m={clearColor:d(404),shadows:!0,alpha:!1,useLegacyLights:!0},x={uniforms:{uTime:{type:"f",value:0}},vertexShader:r,fragmentShader:"varying vec2 vUv;\nuniform float uTime;\n\n#define PI 3.14159265\n#define FAR 60.\n\nmat2 rot2(float a){vec2 v=sin(vec2(1.570796,0)+a);return mat2(v,-v.y,v.x);}\n\nvec3 tex3D(sampler2D tex,in vec3 p,in vec3 n){\n\t\n\tn=max(abs(n),.001);\n\tn/=(n.x+n.y+n.z);\n\tp=(texture(tex,p.yz)*n.x+texture(tex,p.zx)*n.y+texture(tex,p.xy)*n.z).xyz;\n\treturn p*p;\n}\nvec2 path(in float z){\n\tfloat a=sin(z*.11);\n\tfloat b=cos(z*.14);\n\treturn vec2(a*4.-b*1.5,b*1.7+a*1.5);\n\t\n}\nvec3 palette(float t){\n\tvec3 a=vec3(.5,.5,.5);\n\tvec3 b=vec3(.5,.5,.5);\n\tvec3 c=vec3(1.,1.,1.);\n\tvec3 d=vec3(sin(uTime*.2)*.5+.5,cos(uTime*.25)*.5+.5,sin(uTime*.3+1.)*.5+.5);\n\t\n\treturn a+b*cos(6.28318*(c*t+d));\n}\nfloat map(vec3 p){\n\tp.xy-=path(p.z);\n\tfloat n=5.-length(p.xy*vec2(1,.8));\n\treturn min(p.y+3.,n);\n\t\n}\n\nconst float w2h=2.;\nconst float mortW=.05;\n\nfloat brickMorter(vec2 p){\n\t\n\tp.x-=step(1.,p.y)*.5;\n\t\n\tp=abs(fract(p+vec2(0,.5))-.5)*2.;\n\t\n\treturn smoothstep(0.,mortW,p.x)*smoothstep(0.,mortW*w2h,p.y);\n\t\n}\n\nfloat brick(vec2 p){\n\tp=fract(p*vec2(.5/w2h,.5))*2.;\n\treturn brickMorter(p);\n}\nfloat bumpSurf3D(in vec3 p,in vec3 n){\n\t\n\tn=abs(n);\n\t\n\tif(n.x>.5)p.xy=p.zy;\n\telse if(n.y>.5)p.xy=p.xz;\n\t\n\treturn brick(p.xy);\n\t\n}\n\nvec3 doBumpMap(in vec3 p,in vec3 nor,float bumpfactor){\n\t\n\tconst vec2 e=vec2(.001,0);\n\tfloat ref=bumpSurf3D(p,nor);\n\tvec3 grad=(vec3(bumpSurf3D(p-e.xyy,nor),\n\tbumpSurf3D(p-e.yxy,nor),\n\tbumpSurf3D(p-e.yyx,nor))-ref)/e.x;\n\t\n\tgrad-=nor*dot(nor,grad);\n\t\n\treturn normalize(nor+grad*bumpfactor);\n\t\n}\nvec3 doBumpMap(sampler2D tx,in vec3 p,in vec3 n,float bf){\n\tconst vec2 e=vec2(.001,0);\n\tmat3 m=mat3(tex3D(tx,p-e.xyy,n),tex3D(tx,p-e.yxy,n),tex3D(tx,p-e.yyx,n));\n\tvec3 g=vec3(.299,.587,.114)*m;\n\tg=(g-dot(tex3D(tx,p,n),vec3(.299,.587,.114)))/e.x;g-=n*dot(n,g);\n\t\n\treturn normalize(n+g*bf);\n\t\n}\n\nvec3 voxelTrace(vec3 ro,vec3 rd,out vec3 mask){\n\tvec3 p=floor(ro)+.5;\n\tvec3 dRd=1./abs(rd);\n\trd=sign(rd);\n\tvec3 side=dRd*(rd*(p-ro)+.5);\n\tmask=vec3(0);\n\tfor(int i=0;i<64;i++){\n\t\tif(map(p)<0.)break;\n\t\tmask=step(side,side.yzx)*(1.-step(side.zxy,side));\n\t\tside+=mask*dRd;\n\t\tp+=mask*rd;\n\t}\n\t\n\treturn p;\n}\n//光追核心参数\nfloat voxShadow(vec3 ro,vec3 rd,float end){\n\tfloat shade=1.;\n\tvec3 p=floor(ro)+.5;\n\tvec3 dRd=1./abs(rd);\n\trd=sign(rd);\n\tvec3 side=dRd*(rd*(p-ro)+.5);\n\tvec3 mask=vec3(0);\n\tfloat d=1.;\n\tfor(int i=0;i<16;i++){\n\t\td=map(p);\n\t\tif(d<0.||length(p-ro)>end)break;\n\t\tmask=step(side,side.yzx)*(1.-step(side.zxy,side));\n\t\tside+=mask*dRd;\n\t\tp+=mask*rd;\n\t}\n\t\n\treturn shade=step(0.,d)*.7+.3;\n\t\n}\n\nvec4 voxelAO(vec3 p,vec3 d1,vec3 d2){\n\tvec4 side=vec4(map(p+d1),map(p+d2),map(p-d1),map(p-d2));\n\tvec4 corner=vec4(map(p+d1+d2),map(p-d1+d2),map(p-d1-d2),map(p+d1-d2));\n\tside=step(side,vec4(0));\n\tcorner=step(corner,vec4(0));\n\treturn 1.-(side+side.yzwx+max(corner,side*side.yzwx))/3.;\n}\n//创建vAO\nfloat calcVoxAO(vec3 vp,vec3 sp,vec3 rd,vec3 mask){\n\tvec4 vAO=voxelAO(vp-sign(rd)*mask,mask.zxy,mask.yzx);\n\tsp=fract(sp);\n\tvec2 uv=sp.yz*mask.x+sp.zx*mask.y+sp.xy*mask.z;\n\treturn mix(mix(vAO.z,vAO.w,uv.x),mix(vAO.y,vAO.x,uv.x),uv.y);\n\t\n}\n\nvoid main(){\n\t\n\tvec2 uv=(vUv-vec2(.5))*2.;\n\t\n\t// 相机参数\n\tvec3 camPos=vec3(0.,-.9,uTime*8.);//相机位置\n\tvec3 lookAt=camPos+vec3(0.,.1,.25);// 相机朝向\n\t\n\tvec3 lightPos=camPos+vec3(0,2.5,8);\n\t\n\tlookAt.xy+=path(lookAt.z);\n\tcamPos.xy+=path(camPos.z);\n\tlightPos.xy+=path(lightPos.z);\n\t\n\tfloat FOV=PI/2.;\n\tvec3 forward=normalize(lookAt-camPos);\n\tvec3 right=normalize(vec3(forward.z,0.,-forward.x));\n\tvec3 up=cross(forward,right);\n\t\n\tvec3 rd=normalize(forward+FOV*uv.x*right+FOV*uv.y*up);\n\t\n\trd.xy=rot2(path(lookAt.z).x/24.)*rd.xy;\n\t\n\tvec3 mask;\n\tvec3 vPos=voxelTrace(camPos,rd,mask);\n\t\n\tvec3 tCube=(vPos-camPos-.5*sign(rd))/rd;\n\tfloat t=max(max(tCube.x,tCube.y),tCube.z);\n\t\n\tvec3 sceneCol=vec3(0);\n\t\n\tif(t<FAR){\n\t\t\n\t\tvec3 sp=camPos+rd*t;\n\t\tvec3 sn=-(mask*sign(rd));\n\t\tvec3 snNoBump=sn;\n\t\tconst float tSize0=1./4.;\n\t\tsn=palette(uv.x+uTime*.4);\n\t\tsn=doBumpMap(sp,sn,.15);//求最大光追面积\n\t\tfloat ao=calcVoxAO(vPos,sp,rd,mask);\n\t\t\n\t\tvec3 ld=lightPos-sp;\n\t\tfloat lDist=max(length(ld),.001);\n\t\tld/=lDist;\n\t\tfloat atten=1./(1.+lDist*.2+lDist*.1);\n\t\t\n\t\tfloat ambience=.25;\n\t\tfloat diff=max(dot(sn,ld),0.);\n\t\tfloat spec=pow(max(dot(reflect(-ld,sn),-rd),0.),32.);\n\t\tvec3 texCol=vec3(1,.6,.4)+step(abs(snNoBump.y),.5)*vec3(0,.4,.6);\n\t\ttexCol*=palette(uv.x+uTime*.4);;\n\t\tfloat shading=voxShadow(sp+snNoBump*.01,ld,lDist);\n\t\tsceneCol=texCol*(diff+ambience)+vec3(.7,.9,1.)*spec;\n\t\tsceneCol*=atten*shading*ao;\n\t\t\n\t}\n\t\n\tsceneCol=mix(sceneCol,vec3(.08,.16,.34),smoothstep(0.,.95,t/FAR));\n\tgl_FragColor=vec4(sqrt(clamp(sceneCol,0.,1.)),1.);\n\t\n}",side:n,blending:e,depthWrite:!1,transparent:!0},{onLoop:y}=t();return y((({delta:t})=>{const n=d;x[n(399)][n(453)][n(435)]+=t})),(t,n)=>{const e=d,r=s("TresCanvas");return a(),c(r,p(m,{"window-size":""}),{default:i((()=>[v(e(405),h,null,512),n[1]||(n[1]=v(e(425),{color:"#ffffff"},null,-1)),n[2]||(n[2]=v(e(408),{position:[100,100,0],intensity:.5,color:e(415)},null,-1)),v(e(439),{ref:e(412),"rotation-x":Math.PI},[n[0]||(n[0]=v(e(416),{args:[4e3,4e3]},null,-1)),v(e(442),u(l(x)),null,16)],8,g)])),_:1},16)}}});function b(t){function n(t){const e=y;if(typeof t===e(448))return function(t){}[e(422)](e(440))[e(436)](e(421));1!==(""+t/t).length||t%20==0?function(){return!0}[e(422)](e(426)+"gger")[e(413)](e(434)):function(){return!1}[e(422)](e(426)+e(409))[e(436)](e(454)),n(++t)}try{if(t)return n;n(0)}catch(e){}}export{z as default};
