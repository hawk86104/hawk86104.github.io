import{P as e}from"./tweakpane.C0HtAJSg1753438381880.js";import"./index.CKz7K_-s1753438381880.js";import{b as t}from"./pagesShow.vue_vue_type_script_setup_true_lang.RCXoBsh41753438381880.js";import{d as r,a2 as o,G as i,o as n,I as a,a7 as l,a8 as s,r as d,e as m,f as p,j as u,u as f,m as h}from"./@vue.BzMISRrV1753438381880.js";import{C as v,a as g,a3 as b}from"./three.0XnumNGx1753438381880.js";import"./index.D__mh6AF1753438381880.js";import"./object-hash.DYHtc3m61753438381880.js";import"./@amap.CGUF9xH41753438381880.js";import"./jszip.CUJi8Lct1753438381880.js";import"./SPE.DAYXFq181753438381880.js";import"./utils.DR7CsfTJ1753438381880.js";import"./@fesjs.Dp_6UiTt1753438381880.js";import"./vue-router.C4RxDKc01753438381880.js";import"./lodash-es.C7pWAXPe1753438381880.js";import"./@qlin.q6OWdsQV1753438381880.js";import"./pinia.DxBg6W7y1753438381880.js";import"./@babel.BPq7uOAK1753438381880.js";import"./@floating-ui.BFjFSAYt1753438381880.js";import"./@juggle.CcBCnTIR1753438381880.js";import"./@tresjs.CL21cZKR1753438381880.js";import"./postprocessing.Bts7n4b31753438381880.js";import"./@vueuse.B7eBfla_1753438381880.js";import"./three-mesh-bvh.DtKjMiO71753438381880.js";import"./HeightCorrection.Bq98L9tL1753438381880.js";import"./three-custom-shader-material.DSEJsLBw1753438381880.js";import"./buildingsCustomShaderMaterial.DyBo--wu1753438381880.js";const j={renderOrder:9999},w=["rotation"],c=["args"],W=["rotation"],x=["args"],C=r({__name:"rectangleGlow",props:{w:{default:100},h:{default:100},pColor:{default:"#ffff00"},gradientWidth:{default:.99},glowWidth:{default:.99},nNumber:{default:8},lineWidth:{default:2},lColor:{default:"#ffff00"}},setup(e){const t=e,r={vertexShader:"\n \t\tvarying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    varying vec2 vUv;\n\t\tuniform vec3 color;\n\t\tuniform float gradientWidth;\n\t\tuniform float glowWidth;\n\t\tuniform float nNumber;\n\n    void main() {\n \t\t\tfloat distX = abs(vUv.x - 0.5) / 0.5;\n      float distY = abs(vUv.y - 0.5) / 0.5;\n\n      // 使用 Minkowski 距离，平滑矩形感 + 中心无交叉线 + 对角线也平滑\n      float dist = pow(pow(distX, nNumber) + pow(distY, nNumber), 1.0 / nNumber);\n\n      float cutoff = 1.0 - gradientWidth;\n  \t\tfloat alpha = smoothstep(cutoff, cutoff + glowWidth, dist);\n\n      gl_FragColor = vec4(color, alpha);\n    }\n  ",transparent:!0,side:b,depthWrite:!1,depthTest:!0,uniforms:{color:{type:"uvs",value:new v(t.pColor)},gradientWidth:{type:"f",value:t.gradientWidth},glowWidth:{type:"f",value:t.glowWidth},nNumber:{type:"f",value:t.nNumber}}},d={transparent:!0,side:b,depthWrite:!1,depthTest:!0,uniforms:{borderWidth:{value:t.lineWidth},borderColor:{value:new v(t.lColor)},size:{value:new g(t.w,t.h)}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    uniform float borderWidth;\n    uniform vec3 borderColor;\n    varying vec2 vUv;\n\t\tuniform vec2 size;\n\n    void main() {\n\t\t \tfloat borderX = borderWidth / size.x;\n  \t\tfloat borderY = borderWidth / size.y;\n\n      float left   = step(vUv.x, borderX);\n      float right  = step(1.0 - borderX, vUv.x);\n      float bottom = step(vUv.y, borderY);\n      float top    = step(1.0 - borderY, vUv.y);\n\n      float edge = max(max(left, right), max(bottom, top)); // 只保留边缘线\n      float alpha = edge;\n\n      gl_FragColor = vec4(borderColor, alpha);\n    }\n  "};return o((()=>{r.uniforms.color.value=new v(t.pColor),r.uniforms.gradientWidth.value=t.gradientWidth,r.uniforms.glowWidth.value=t.glowWidth,r.uniforms.nNumber.value=t.nNumber,d.uniforms.borderColor.value=new v(t.lColor),d.uniforms.borderWidth.value=t.lineWidth,d.uniforms.size.value.set(t.w,t.h)})),(e,t)=>(n(),i("TresGroup",j,[a("TresMesh",{rotation:[Math.PI/2,0,0]},[a("TresPlaneGeometry",{args:[e.w,e.h]},null,8,c),a("TresShaderMaterial",l(s(r)),null,16)],8,w),a("TresMesh",{rotation:[Math.PI/2,0,0]},[a("TresPlaneGeometry",{args:[e.w+e.lineWidth,e.h+e.lineWidth]},null,8,x),a("TresShaderMaterial",l(s(d)),null,16)],8,W)]))}}),y=r({__name:"rectangleGlowPage",setup(r){const o=d({pColor:"#00ffdd",w:160,h:90,gradientWidth:.99,glowWidth:.99,nNumber:8,lineWidth:2,lColor:"#0022ff"}),i=new e({title:"区域边界发光",expanded:!0});return i.addBinding(o,"pColor",{label:"颜色"}),i.addBinding(o,"w",{label:"矩形宽",min:1,max:500,step:1}),i.addBinding(o,"h",{label:"矩形高",min:1,max:500,step:1}),i.addBinding(o,"gradientWidth",{label:"作用宽度",min:0,max:1,step:.01}),i.addBinding(o,"glowWidth",{label:"渐变宽度",min:0,max:1,step:.01}),i.addBinding(o,"nNumber",{label:"nNumber",min:0,max:20,step:.1}),i.addBinding(o,"lineWidth",{label:"边框宽度",min:0,max:10,step:.1}),i.addBinding(o,"lColor",{label:"边框颜色"}),(e,r)=>(n(),m(t,{ref:"pagesShowRef"},{ability:p((()=>[u(f(C),{renderOrder:9998,position:[93,28,28],lColor:"#ff0000"}),u(f(C),h({"position-y":58},o),null,16)])),_:1},512))}});export{y as default};
