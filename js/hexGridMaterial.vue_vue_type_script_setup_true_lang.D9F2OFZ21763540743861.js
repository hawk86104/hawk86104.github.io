import{n as e,_ as i,l as n}from"./@tresjs.BCHtwiaC1763540743861.js";import{d as a,w as o,b as s,o as t,u as r}from"./@vue.Co_gxueH1763540743861.js";import{x as v,ae as d}from"./three.rXKzP9fQ1763540743861.js";const l=a({__name:"hexGridMaterial",props:{baseMaterial:{default:v},speed:{default:1},gridWeight:{default:.03},raisedBottom:{default:.05},waveFrequency:{default:.2},wavePow:{default:4},division:{default:32},divisionScaleX:{default:1},direction:{default:4},isReversed:{default:!1},hasMaskTexture:{default:!1},maskTexture:{default:""}},setup(a){const v=a,l={gridWeight:{value:v.gridWeight},raisedBottom:{value:v.raisedBottom},waveFrequency:{value:v.waveFrequency},wavePow:{value:v.wavePow},direction:{value:v.direction},isReversed:{value:v.isReversed},hasMaskTexture:{value:v.hasMaskTexture},maskTexture:{value:null},division:{value:v.division},divisionScaleX:{value:v.divisionScaleX},time:{value:0}};if(v.maskTexture){const{state:i}=e(v.maskTexture);l.maskTexture=i}o(()=>[v.gridWeight,v.raisedBottom,v.waveFrequency,v.wavePow,v.division,v.divisionScaleX,v.direction,v.isReversed,v.hasMaskTexture],([e,i,n,a,o,s,t,r,v])=>{l.gridWeight.value=e,l.raisedBottom.value=i,l.waveFrequency.value=n,l.wavePow.value=a,l.division.value=o,l.divisionScaleX.value=s,l.direction.value=t,l.isReversed.value=r,l.hasMaskTexture.value=v});const{onBeforeRender:u}=i();return u(({delta:e})=>{l.time.value+=e*v.speed}),(e,i)=>(t(),s(r(n),{baseMaterial:a.baseMaterial,vertexShader:"\nvarying vec2 uvPosition;\nvoid main() {\n    uvPosition = uv;\n}\n",side:d,transparent:"",fragmentShader:r("varying vec2 uvPosition;\n\nuniform float time;\n\nuniform float raisedBottom;\nuniform float waveFrequency;\nuniform float wavePow;\nuniform int direction;\n\nuniform float division;\nuniform float divisionScaleX;\n\nuniform bool hasMaskTexture;\nuniform sampler2D maskTexture;\n\nuniform bool isReversed;\n\nuniform float gridWeight;\n\nfloat hexDist(vec2 p) {\n  p = abs(p);\n  float d = dot(p, normalize(vec2(1.0, 1.73)));\n  return max(d, p.x);\n}\nvec4 hexCoords(vec2 uv) {\n  vec2 r = vec2(1.0, 1.73);\n  vec2 h = r * 0.5;\n  vec2 a = mod(uv, r) - h;\n  vec2 b = mod(uv - h, r) - h;\n\n  vec2 gv = length(a) < length(b) ? a : b;\n  vec2 id = uv - gv;\n\n  float x = atan(gv.x, gv.y);\n  float y = 0.5 - hexDist(gv);\n\n  return vec4(x, y, id);\n}\n\nvoid main() {\n  vec2 uv = uvPosition * vec2(division * divisionScaleX, division);\n  vec4 hc = hexCoords(uv);\n  vec2 id = hc.zw;\n  float distance = id.y;\n  if (direction == 3) {\n    distance = id.x;\n  } else if (direction == 5) {\n    distance = length(id.xy);\n  } else if (direction == 6) {\n    vec2 center = vec2(0.5 * division * divisionScaleX, 0.5 * division);\n    distance = length(uv - center);\n  }\n  float wavy =\n      pow(sin((distance * waveFrequency - time)), wavePow) + raisedBottom;\n\n  float diffuseColorA = csm_DiffuseColor.a;\n  diffuseColorA *= wavy;\n\n  float mask = 1.0;\n  if (hasMaskTexture) {\n    vec2 uVm = id / vec2(division * divisionScaleX, division);\n    mask = texture2D(maskTexture, uVm).g;\n  }\n\n  float w = gridWeight + (1.0 - mask);\n  w = clamp(w, 0.0, 1.0);\n\n  float margin = clamp(w * 0.33, 0.00, 0.02);\n  float stepMax = w + margin;\n\n  float gridLine = smoothstep(w, stepMax, hc.y);\n  gridLine = isReversed ? 1.0 - gridLine : gridLine;\n  diffuseColorA *= gridLine;\n\n  \n  \n  csm_DiffuseColor.rgb *= diffuseColorA;\n\nfloat brightness = length(csm_DiffuseColor.rgb);\n\nfloat alphaBlend = smoothstep(0.0, 1.0, brightness);\n\ncsm_DiffuseColor.a *= alphaBlend;\n\ncsm_FragColor = vec4(csm_DiffuseColor.rgb, csm_DiffuseColor.a);\n}"),uniforms:l},null,8,["baseMaterial","side","fragmentShader"]))}});export{l as _};
