import{m as n,e,a as t,o as r,f as o}from"./@tresjs.8axf5yqM1738810638719.js";import{P as i}from"./tweakpane.yDiyAAkA1738810638719.js";import{_ as c,c as a,r as l,K as s,s as u,O as f,W as p,aW as v,V as g}from"./three.6w8Allze1738810638719.js";import{d,a3 as x,b as h,o as m,f as y,u as w,g as b,j as R,al as C,r as I,N as _,aj as M,ak as z}from"./@vue.NRI7TcgI1738810638719.js";import"./@vueuse.hJpps2zM1738810638719.js";var D="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const T=O;!function(n,e){const t=O,r=F();for(;;)try{if(345568===parseInt(t(326))/1+parseInt(t(330))/2*(-parseInt(t(327))/3)+parseInt(t(339))/4*(parseInt(t(323))/5)+-parseInt(t(310))/6+-parseInt(t(337))/7*(parseInt(t(313))/8)+parseInt(t(299))/9*(-parseInt(t(298))/10)+parseInt(t(334))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[O(297)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){A(this,(function(){const n=O,e=new RegExp(n(336)),t=new RegExp(n(316),"i"),r=E(n(318));e[n(338)](r+n(332))&&t.test(r+n(303))?E():r("0")}))()}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[O(297)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function F(){const n=["length","exception","15836RZmncF","water","chain","call","5882272MICPdS","console","function *\\( *\\)","805777ZitXNX","test","124OuwbsH","info","pool","tiles","value","position","constructor","toString","trace","return (function() ","apply","140440AaGsub","27eUnoWR","RawShaderMaterial","FrontSide","bind","input","waterTexture","while (true) {}","causticTex","uniforms","setAttribute","warn","1528824VHWmtJ","debu","causticsTexture","8FHCuLy","setIndex","BufferGeometry","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","gger","init","BufferAttribute","render",'{}.constructor("return this")( )',"counter","54255LJfNUf","error","action","409070NZqXCO","198JBnbFB"];return(F=function(){return n})()}function O(n,e){const t=F();return(O=function(n,e){return t[n-=297]})(n,e)}L(void 0,(function(){const n=O,e=function(){const n=O;let e;try{e=Function(n(348)+n(321)+");")()}catch(t){e=window}return e}(),t=e[n(335)]=e[n(335)]||{},r=["log",n(309),n(340),n(324),n(329),"table",n(347)];for(let o=0;o<r.length;o++){const e=L[n(345)].prototype[n(302)](L),i=r[o],c=t[i]||e;e.__proto__=L.bind(L),e[n(346)]=c[n(346)][n(302)](c),t[i]=e}}))();const j=d({__name:T(341),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=T,o=t,i=new(c[r(315)]),s=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),u=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(308)](r(344),new a(s,3)),i[r(314)](new(c[r(319)])(u,1));const f=new(c[r(300)])({uniforms:{light:{value:o.light},tiles:{value:o[r(342)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(301)]}),p=new l(i,f),{renderer:v,camera:g}=n(),{onAfterLoop:d}=e();return d((()=>{const n=r;((n,e)=>{const t=r;f[t(307)][t(331)][t(343)]=n,f.uniforms[t(306)][t(343)]=e,v[t(343)][t(320)](p,g[t(343)])})(o[n(304)],o[n(312)])})),(n,e)=>null}});function E(n){function e(n){const t=O;if("string"==typeof n)return function(n){}.constructor(t(305))[t(297)](t(322));1!==(""+n/n)[t(328)]||n%20==0?function(){return!0}.constructor(t(311)+t(317))[t(333)](t(325)):function(){return!1}[t(345)](t(311)+"gger").apply("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=W,r=H();for(;;)try{if(997974===parseInt(t(355))/1+-parseInt(t(345))/2+parseInt(t(336))/3*(-parseInt(t(325))/4)+parseInt(t(308))/5+parseInt(t(326))/6*(-parseInt(t(319))/7)+parseInt(t(340))/8*(-parseInt(t(362))/9)+parseInt(t(331))/10*(parseInt(t(315))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[W(327)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function W(n,e){const t=H();return(W=function(n,e){return t[n-=303]})(n,e)}!function(){S(this,(function(){const n=W,e=new RegExp("function *\\( *\\)"),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=N(n(353));e[n(359)](r+n(339))&&t[n(359)](r+"input")?N():r("0")}))()}();const P=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[W(327)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function H(){const n=["uniforms","test","tiles","stateObject","131787yTyogk","RawShaderMaterial","Mesh","FrontSide","console","while (true) {}","action","1191135EKNlCO","return (function() ","exception","counter","table","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","causticTex","4149772xsjstR","constructor","debu","geometry","7574357FinjhW","Color","light","prototype","error","length","6874548MDFHNc","6ECVGGH","apply","setPath","value","pooRef","170aByFDf","bind","clear","CubeTextureLoader","neg-x.jpg","3OffdAT","log","trace","chain","984deUmtx","side","neg-z.jpg","causticsTexture","underwater","3680460tPSAcd","pos-x.jpg","setRenderTarget","gger","white","toString","setClearColor","load","init","pos-z.jpg","788470XuWkiw","waterTexture","render"];return(H=function(){return n})()}P(void 0,(function(){const n=W;let e;try{e=Function(n(309)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(305)]=e.console||{},r=[n(337),"warn","info",n(323),n(310),n(312),n(338)];for(let i=0;i<r[n(324)];i++){const e=P[n(316)][n(322)][n(332)](P),o=r[i],c=t[o]||e;e.__proto__=P[n(332)](P),e[n(350)]=c[n(350)].bind(c),t[o]=e}}))();const V=d({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=W;let i,a;const l=r,u=l[o(318)],f=(new(c[o(334)]))[o(328)](o(313))[o(352)]([o(346),o(335),"pos-y.jpg","neg-y.jpg",o(354),o(342)]),p=([i,a]=x((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),v=new(c[o(363)])({uniforms:{light:{value:l[o(321)]},tiles:{value:p},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),g=new(c[o(303)])(u,v),d=h(null),b=new(c[o(320)])(o(349)),{renderer:R,camera:C}=n(),{onLoop:I}=e();return I((()=>{const n=o;R[n(329)][n(347)](null),R[n(329)][n(351)](b,1),R.value[n(333)](),v[n(358)].water.value=l[n(356)],v[n(358)][n(314)].value=l[n(343)],v.side=c[n(304)],v[n(358)][n(344)][n(329)]=!0,R[n(329)][n(357)](g,C.value),v[n(341)]=s,v.uniforms[n(344)].value=!1,R[n(329)][n(357)](g,C.value)})),(n,e)=>{const t=o;return m(),y(j,{tiles:w(p),light:n[t(321)],waterTexture:n.waterTexture,causticsTexture:n[t(343)],ref_key:t(330),ref:d},null,8,[t(360),t(321),"waterTexture",t(343)])}}});function N(n){function e(n){const t=W;if("string"==typeof n)return function(n){}[t(316)](t(306))[t(327)](t(311));1!==(""+n/n).length||n%20==0?function(){return!0}.constructor(t(317)+t(348)).call(t(307)):function(){return!1}[t(316)](t(317)+t(348))[t(327)](t(361)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=G,r=B();for(;;)try{if(878116===-parseInt(t(166))/1+parseInt(t(171))/2*(parseInt(t(156))/3)+-parseInt(t(168))/4+parseInt(t(185))/5*(parseInt(t(181))/6)+parseInt(t(160))/7+-parseInt(t(187))/8*(parseInt(t(178))/9)+parseInt(t(155))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[G(182)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Z(this,(function(){const n=G,e=new RegExp(n(179)),t=new RegExp(n(142),"i"),r=X(n(191));e.test(r+n(174))&&t[n(141)](r+n(140))?X():r("0")}))()}();const k=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function B(){const n=["info","table","log","call","constructor","render","geometry","Color","31843740FuXacR","3oRYJfT","OrthographicCamera","texture","debu","3608626HAKRRR","while (true) {}","setClearColor","setRenderTarget","exception","water","1728130Nrrtar","counter","5059744ampFUz","value","black","958206fqJESQ","ShaderMaterial","material","chain","WebGLRenderTarget","waterTexture","prototype","333jaMteN","function *\\( *\\)","gger","18SPAUYj","apply","return (function() ","bind","1737935ZKeyWH","string","292016thIXcn","stateObject","error","toString","init","light","input","test","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","uniforms","causticsTexture","console","Mesh"];return(B=function(){return n})()}function G(n,e){const t=B();return(G=function(n,e){return t[n-=140]})(n,e)}k(void 0,(function(){const n=G;let e;try{e=Function(n(183)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(145)]=e.console||{},r=[n(149),"warn",n(147),n(189),n(164),n(148),"trace"];for(let i=0;i<r.length;i++){const e=k[n(151)][n(177)][n(184)](k),o=r[i],c=t[o]||e;e.__proto__=k[n(184)](k),e[n(190)]=c.toString[n(184)](c),t[o]=e}}))();const U=d({__name:"caustics",props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=G,o=t,i=new(c[r(157)])(0,1,1,0,0,2e3),a=new u(2,2,200,200),l=new(c[r(175)])(1024,1024),s=new(c[r(172)])({uniforms:{light:{value:o.light},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),f=new(c[r(146)])(a,s),p=new(c[r(154)])(r(170)),{renderer:v}=n(),{onBeforeLoop:g}=e();return g((()=>{const n=r;f[n(173)][n(143)][n(165)][n(169)]=o[n(176)],v.value[n(163)](l),v[n(169)][n(162)](p,0),v[n(169)].clear(),v[n(169)][n(152)](f,i)})),(n,e)=>{const t=r;return m(),y(C,null,{default:b((()=>[R(V,{waterTexture:n[t(176)],causticsTexture:w(l)[t(158)],light:n[t(192)],geometry:w(a)},null,8,[t(176),t(144),t(192),t(153)])])),_:1})}}});function X(n){function e(n){const t=G;if(typeof n===t(186))return function(n){}[t(151)](t(161))[t(182)](t(167));1!==(""+n/n).length||n%20==0?function(){return!0}[t(151)](t(159)+t(180))[t(150)]("action"):function(){return!1}[t(151)](t(159)+"gger")[t(182)](t(188)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const $=q;function q(n,e){const t=Y();return(q=function(n,e){return t[n-=303]})(n,e)}!function(n,e){const t=q,r=Y();for(;;)try{if(528369===parseInt(t(335))/1*(-parseInt(t(318))/2)+-parseInt(t(367))/3+parseInt(t(313))/4+parseInt(t(320))/5+-parseInt(t(306))/6+parseInt(t(352))/7*(parseInt(t(354))/8)+-parseInt(t(362))/9*(-parseInt(t(359))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const J=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(338)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){J(this,(function(){const n=q,e=new RegExp(n(355)),t=new RegExp(n(361),"i"),r=nn(n(315));e[n(371)](r+"chain")&&t[n(371)](r+n(368))?nn():r("0")}))()}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(338)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Y(){const n=["input","texture","error","test","action","count","FloatType","setZ","point","2562330YBvRxb",'{}.constructor("return this")( )',"toString","clientY","value","autoClear","log","2126632ZbWsKP","width","init","call","removeEventListener","1198JrhhnR","getBoundingClientRect","2719685UJXmmr","setRenderTarget","lightFrontGeometry","warn","uniforms","bind","table","stateObject","waterTexture","__proto__","domElement","height","setY","constructor","counter","1277LENPhg","waterSimulation","string","apply","getY","debu","material","Mesh","return (function() ","center","length","left","attributes","needsUpdate","radius","gger","mousemove","49497qslTlG","console","456DvDHvX","function *\\( *\\)","RawShaderMaterial","exception","render","155080VxAFjz","clientX","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","747hbcRFH","prototype","PlaneGeometry","position","strength","3136377dMIuEZ"];return(Y=function(){return n})()}K(void 0,(function(){const n=q;let e;try{e=Function(n(343)+n(307)+");")()}catch(o){e=window}const t=e[n(353)]=e[n(353)]||{},r=[n(312),n(323),"info",n(370),n(357),n(326),"trace"];for(let i=0;i<r[n(345)];i++){const e=K[n(333)][n(363)].bind(K),o=r[i],c=t[o]||e;e[n(329)]=K.bind(K),e[n(308)]=c[n(308)][n(325)](c),t[o]=e}}))();const Q=d({__name:$(336),props:{light:{}},setup(t,{expose:r}){const o=$,i=new f(0,1,1,0,0,2e3),a=new(c[o(364)])(2,2),s=new p(256,256,{type:c[o(303)]}),u=new p(256,256,{type:c[o(303)]}),d=new v({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),x=new v({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),h=new(c[o(356)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),b=new l(a,d),R=new(c[o(342)])(a,x),C=new(c[o(342)])(a,h);let I=s;const _=(n,e)=>{const t=o,r=I,c=I===s?u:s;e[t(341)].uniforms[t(369)].value=r[t(369)],n[t(321)](c),n[t(358)](e,i),I=c},{renderer:M,camera:z,raycaster:T}=n();M[o(310)][o(311)]=!1;const{onBeforeLoop:A}=e();A((()=>{var n,e;e=M[o(310)],_(e,C),n=M.value,_(n,R)}));const L=(n,e,t,r)=>{const i=o;b[i(341)][i(324)][i(344)][i(310)]=[n,e],b[i(341)][i(324)][i(349)].value=t,b[i(341)][i(324)][i(366)][i(310)]=r,_(M[i(310)],b)},F=new g,O=new(c[o(364)])(2,2),j=O[o(347)][o(365)];for(let n=0;n<j[o(373)];n++){const e=-j[o(339)](n);j[o(332)](n,0),j[o(304)](n,e)}j[o(348)]=!0;const E=new l(O),S={handleEvent:n=>{const e=o,t=M[e(310)].domElement[e(319)](),r=t[e(314)],i=t[e(331)];F.x=2*(n[e(360)]-t[e(346)])/r-1,F.y=2*-(n[e(309)]-t.top)/i+1,T.value.setFromCamera(F,z[e(310)]);const c=T[e(310)].intersectObject(E);for(let o of c)L(o[e(305)].x,o[e(305)].z,.03,.04)}};return r({addDrop:L,mouseEvent:n=>{const e=o;n?M[e(310)][e(330)].addEventListener(e(351),S):M[e(310)][e(330)][e(317)](e(351),S)}}),(n,e)=>{const t=o;return m(),y(U,{lightFrontGeometry:w(a),waterTexture:w(I).texture,light:n.light},null,8,[t(322),t(328),"light"])}}});function nn(n){function e(n){const t=q;if(typeof n===t(337))return function(n){}[t(333)]("while (true) {}").apply(t(334));1!==(""+n/n)[t(345)]||n%20==0?function(){return!0}[t(333)](t(340)+t(350))[t(316)](t(372)):function(){return!1}[t(333)](t(340)+t(350))[t(338)](t(327)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const en=on;!function(n,e){const t=on,r=cn();for(;;)try{if(942478===parseInt(t(515))/1*(parseInt(t(503))/2)+-parseInt(t(547))/3*(parseInt(t(506))/4)+-parseInt(t(541))/5+parseInt(t(499))/6*(-parseInt(t(500))/7)+-parseInt(t(514))/8*(-parseInt(t(498))/9)+-parseInt(t(504))/10+-parseInt(t(534))/11*(-parseInt(t(522))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const tn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){tn(this,(function(){const n=on,e=new RegExp(n(530)),t=new RegExp(n(535),"i"),r=ln(n(542));e[n(519)](r+n(512))&&t.test(r+n(509))?ln():r("0")}))()}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(520)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function on(n,e){const t=cn();return(on=function(n,e){return t[n-=498]})(n,e)}function cn(){const n=["12RmFAmS",'{}.constructor("return this")( )',"table","action","string","addBinding","length","error","function *\\( *\\)","stateObject","addDrop","while (true) {}","21804409sEOhAs","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","TresPerspectiveCamera","return (function() ","console","realWater","value","356890Dzbbjy","init","addButton","exception","constructor","__proto__","3NETIPe","1839051eqKfPo","18GZMxCJ","2434943UbJLlU","click","mouseEvent","382XrCWTz","3492030GWDzPL","gger","3534964dSMAvR","info","waterSimulationRef","input","change","toString","chain","random","8VbgVhF","5779Qcqsqt","bind","trace","log","test","apply","debu"];return(cn=function(){return n})()}rn(void 0,(function(){const n=on,e=function(){const n=on;let e;try{e=Function(n(537)+n(523)+");")()}catch(t){e=window}return e}(),t=e[n(538)]=e.console||{},r=[n(518),"warn",n(507),n(529),n(544),n(524),n(517)];for(let o=0;o<r.length;o++){const e=rn[n(545)].prototype.bind(rn),i=r[o],c=t[i]||e;e[n(546)]=rn.bind(rn),e[n(511)]=c[n(511)][n(516)](c),t[i]=e}}))();const an=d({__name:en(539),setup(n){const e=en,t=I({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:"manual"}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=h(null),l=new i;l[e(543)]({label:"点击按钮",title:"随机增加波纹"}).on(e(501),(()=>{const n=e;for(var t=0;t<10;t++)a[n(540)][n(532)](2*Math[n(513)]()-1,2*Math[n(513)]()-1,.03,1&t?.02:-.02)}));const s=h(!1);return l[e(527)](s,"value",{label:"鼠标波纹"}).on(e(510),(n=>{const t=e;a.value[t(502)](n[t(540)])})),(n,i)=>{const l=e;return m(),y(w(o),M(z(t)),{default:b((()=>[i[0]||(i[0]=_(l(536),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),R(w(r)),R(Q,{light:c,ref_key:l(508),ref:a},null,512)])),_:1},16)}}});function ln(n){function e(n){const t=on;if(typeof n===t(526))return function(n){}[t(545)](t(533)).apply("counter");1!==(""+n/n)[t(528)]||n%20==0?function(){return!0}.constructor(t(521)+t(505)).call(t(525)):function(){return!1}.constructor(t(521)+"gger")[t(520)](t(531)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{an as default};
