import{importShared as e}from"./3d-tiles-renderer.HXNTGnH81769411460564.js";import{useTexture as a,useLoop as t,component_default$18 as o}from"./index.KfH1904l1769411460564.js";const{defineComponent:l}=await e("vue"),{unref:n,createElementVNode:r,openBlock:u,createElementBlock:s}=await e("vue"),i=["size","color","alpha-map","map","opacity","alpha-test","depth-write","transparent","size-attenuation"],p=["position","velocity"],{shallowRef:d,toRefs:c,watch:f,watchEffect:v}=await e("vue"),m=l({__name:"index",props:{size:{default:.1},area:{default:()=>[10,10,20]},color:{default:16777215},map:{},alphaMap:{},alphaTest:{default:.01},opacity:{default:.8},count:{default:5e3},speed:{default:.1},randomness:{default:.5},depthWrite:{type:Boolean,default:!1},transparent:{type:Boolean,default:!0},sizeAttenuation:{type:Boolean,default:!0}},setup(e,{expose:o}){const l=e,{size:m,area:y,color:h,alphaMap:w,map:z,opacity:B,alphaTest:M,depthWrite:g,transparent:_,sizeAttenuation:k,count:T,speed:b,randomness:x}=c(l),R=d();let A=[],C=[];const E=()=>{A=new Float32Array(3*T.value);for(let e=0;e<T.value;e++){const a=3*e;A[a]=(Math.random()-.5)*y.value[0],A[a+1]=(Math.random()-.5)*y.value[1],A[a+2]=(Math.random()-.5)*y.value[2]}},Y=()=>{C=new Float32Array(2*T.value);for(let e=0;e<2*T.value;e+=2)C[e]=(Math.random()-.5)/5*b.value*x.value,C[e+1]=Math.random()/5*b.value};Y(),E(),f(b,()=>{Y()}),v(()=>{b.value||E()}),f(()=>l.area,()=>{E()});const W=d(null),X=d(null);v(async()=>{if("string"==typeof w.value){const{state:e}=a(w.value);W.value=e.value}else W.value=w.value??null;if("string"==typeof z.value){const{state:e}=a(z.value);X.value=e.value}else X.value=z.value??null});const{onBeforeRender:Z}=t();Z(()=>{if(R.value?.attributes.position.array&&R.value?.attributes.position.count){const e=R.value.attributes.position.array;for(let a=0;a<R.value.attributes.position.count;a++){const t=C[2*a],o=C[2*a+1];e[3*a]+=t,e[3*a+1]-=o,(e[3*a]<=-y.value[0]/2||e[3*a]>=y.value[0]/2)&&(e[3*a]=-1*e[3*a]),(e[3*a+1]<=-y.value[1]/2||e[3*a+1]>=y.value[1]/2)&&(e[3*a+1]=-1*e[3*a+1])}R.value.attributes.position.needsUpdate=!0}});const j=d();return o({instance:j}),(e,a)=>(u(),s("TresPoints",{ref_key:"pointsRef",ref:j},[r("TresPointsMaterial",{size:n(m),color:n(h),"alpha-map":W.value,map:X.value,opacity:n(B),"alpha-test":n(M),"depth-write":n(g),transparent:n(_),"size-attenuation":n(k)},null,8,i),r("TresBufferGeometry",{ref_key:"geometryRef",ref:R,position:[n(A),3],velocity:[n(C)]},null,8,p)],512))}}),{defineComponent:y}=await e("vue"),{createVNode:h,unref:w,withCtx:z,openBlock:B,createElementBlock:M}=await e("vue"),{ref:g,watch:_}=await e("vue"),k=y({__name:"particleBase",props:{speed:{default:.1},randomness:{default:1},count:{default:100},size:{default:.1},areaX:{default:5},areaY:{default:2},areaZ:{default:5},color:{default:"#fff"},opacity:{default:1}},setup(e){const a=e,t=g([a.areaX,a.areaY,a.areaZ]);return _(()=>[a.areaX,a.areaY,a.areaZ],([e,a,o])=>{t.value=[e,a,o]}),(e,a)=>(B(),M("TresGroup",null,[h(w(o),{path:"./plugins/digitalCity/image/cilcle.png"},{default:z(({state:a})=>[h(m,{renderOrder:2001,position:[0,e.areaY/2,0],speed:e.speed,color:e.color,area:t.value,count:e.count,depthWrite:!1,randomness:e.randomness,size:e.size,transparent:"",opacity:e.opacity,map:a},null,8,["position","speed","color","area","count","randomness","size","opacity","map"])]),_:1})]))}});export{k as _sfc_main};
