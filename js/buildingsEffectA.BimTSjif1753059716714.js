import{P as t}from"./tweakpane.C0HtAJSg1753059716714.js";import{b as o,l as e}from"./pagesShow.vue_vue_type_script_setup_true_lang.BHRKXqU_1753059716714.js";import{e as i}from"./@tresjs.oHLVlBVa1753059716714.js";import{z as a}from"./three-custom-shader-material.1_PCtt5y1753059716714.js";import{d as l,a2 as r,w as n,G as u,o as s,u as d,aa as m,r as c,e as f,f as v,j as p,m as C}from"./@vue.DwSifnVs1753059716714.js";import{A as g,a3 as y,C as w,az as _,n as h,ax as x}from"./three.DR_5uK8e1753059716714.js";import"./buildingsCustomShaderMaterial.DyBo--wu1753059716714.js";import"./postprocessing.BrgFZ9pj1753059716714.js";import"./@vueuse.mXirru381753059716714.js";const b=["object"],M=l({__name:"bModel",props:{model:{},bulidingsColor:{default:"#e523ff"},landColor:{default:"#112233"},topColor:{default:"#ffff00"},opacity:{default:.9},gradient:{type:Boolean,default:!0}},setup(t){const o=t,e=o.model.city;o.model.model.children[0].material=new g({color:"#ffff00"}),e.renderOrder=1001;const l=o.model.land;(()=>{const{geometry:t}=e;t.computeBoundingBox(),t.computeBoundingSphere();const{max:i,min:l}=t.boundingBox;if(e.material.__csm)return;const r=new a({baseMaterial:e.material,vertexShader:"\n\t\tvarying vec4 vPosition;\n\t\tvoid main() {\n\t\t\tvPosition = modelMatrix * vec4(position,1.0);\n\t\t\tcsm_Position = position * vec3(1.0);\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform mat4 modelMatrix;\n\t\tvarying vec4 vPosition;\n\t\tuniform vec3 uMax; \n\t\tuniform vec3 uMin; \n\t\tuniform float uOpacity;  \n\t\tuniform float uBorderWidth; \n\t\tuniform vec3 uLightColor;\n\t\tuniform vec3 uColor;\n\t\tuniform float uCircleTime; \n\t\tuniform float uTime; \n\t\tuniform vec3 uTopColor;\t\t\t\t\t//顶部颜色\n\t\tuniform bool uGradient;\n\t\tvec4 uMax_world;\n\t\tvec4 uMin_world;\n\t\tvoid main() {\n\t\t\t// 转世界坐标\n\t\t\tuMax_world =  modelMatrix * vec4(uMax,1.0);\n\t\t\tuMin_world =  modelMatrix * vec4(uMin,1.0);\n\t\t\tvec3 distColor = uColor;\n\t\t\tfloat residue = uTime - floor(uTime / uCircleTime) * uCircleTime;\n\t\t\tfloat rate = residue / uCircleTime;\n\t\t\tfloat lightOffset = rate * (uMax_world.y - uMin_world.y);\n\n\t\t\tif (uMin_world.y + lightOffset < vPosition.y && uMin_world.y + lightOffset + uBorderWidth > vPosition.y) {\n\t\t\t\tcsm_DiffuseColor = vec4(uLightColor, uOpacity);\n\t\t\t} else {\n\t\t\t\tcsm_DiffuseColor = vec4(distColor, uOpacity);\n\t\t\t}\n\n\t\t\t//根据高度计算颜色\n\t\t\tif(uGradient){\n\t\t\t\tfloat rateHight = (vPosition.y - uMin_world.y) / (uMax_world.y - uMin_world.y); \n\t\t\t\tvec3 outColor = mix(csm_DiffuseColor.xyz, uTopColor, rateHight*2.0);\n\t\t\t\tcsm_DiffuseColor = vec4(outColor, uOpacity);\n\t\t\t}\n    }\n\t\t",silent:!0,uniforms:{uMax:{value:i},uMin:{value:l},uBorderWidth:{value:5},uCircleTime:{value:5},uColor:{value:new w(o.bulidingsColor)},uOpacity:{value:o.opacity},uLightColor:{value:new w("#ffffff")},uTopColor:{value:new w(o.topColor)},uTime:{value:0},uGradient:{value:o.gradient}},depthWrite:!0,depthTest:!0,transparent:!0,side:y});e.material.dispose(),e.material=r})();const{onLoop:m}=i();m((({delta:t})=>{e.material.uniforms.uTime.value+=t})),r((()=>{o.bulidingsColor&&e.material.uniforms.uColor.value.setStyle(o.bulidingsColor),o.landColor&&((t,e)=>{let i;i=Array.isArray(l.material)?l.material:[l.material],i.forEach((t=>{t[e].setStyle(o.landColor),t.side=y}))})(0,"color"),o.opacity&&(e.material.uniforms.uOpacity.value=o.opacity)})),n(o,((t,o)=>{e.material.uniforms.uGradient.value=t.gradient}));const c=o.model.model.clone();return(t,o)=>(s(),u("primitive",{object:d(c)},null,8,b))}}),T=["object"],S=l({__name:"bLine",props:{builds:{},color:{default:"#FFF"},srcColor:{default:"#000"},scale:{default:2e3},gradual:{default:10},speed:{default:.5}},setup(t){const o=t;let e=null;const a={transparent:!0,uniforms:{uColor:{value:new w(o.color)},uSrcColor:{value:new w(o.srcColor)},uScale:{value:o.scale},uTime:{value:0},uGradual:{value:o.gradual}},vertexShader:"varying vec3 vPosition;\nvoid main(){\n\tvPosition=position;\n\tvec4 viewPosition=modelViewMatrix*vec4(position,1.);\n\tgl_Position=projectionMatrix*viewPosition;\n}",fragmentShader:"uniform float uScale;//最大扩散\nuniform float uGradual;//建变系数\nuniform float uTime;\nuniform vec3 uColor;//扩散颜色\nuniform vec3 uSrcColor;//原始颜色\nvarying vec3 vPosition;\n\nvoid main(){\n\tfloat dis=distance(vPosition.xz,vec2(.0,.0));\n\tif(dis>uScale){\n\t\tdiscard;\n\t}\n\tfloat opacity=smoothstep(uScale/uGradual*uTime,uScale*uTime,dis);\n\topacity*=step(dis,uScale*uTime);\n\t\n\tif(opacity<.3){\n\t\tgl_FragColor=vec4(uSrcColor,1.-opacity);\n\t}else{\n\t\tgl_FragColor=vec4(uColor,opacity);\n\t}\n\t// gl_FragColor=vec4(uColor,opacity);\n}\n"};let l=new _(o.builds.geometry).clone();l=l.applyMatrix4(o.builds.matrix);const n=new h(a);e=new x(l,n),e.material.linewidth=o.width,e.renderOrder=1e3,r((()=>{o.color&&(a.uniforms.uColor.value=new w(o.color)),o.srcColor&&(a.uniforms.uSrcColor.value=new w(o.srcColor)),o.scale&&(a.uniforms.uScale.value=o.scale),o.gradual&&(a.uniforms.uGradual.value=o.gradual)}));const{onLoop:m}=i();return m((({delta:t})=>{a.uniforms.uTime.value+=t*o.speed,a.uniforms.uTime.value%=1})),(t,o)=>(s(),u("primitive",{object:d(e)},null,8,T))}}),j=l({__name:"buildingsEffectA",async setup(i){let a,l;const r=([a,l]=m((()=>e())),a=await a,l(),a),n=c({color:"#FFF",srcColor:"#000",scale:2e3,gradual:6.6,speed:.3}),u=new t({title:"效果参数",expanded:!0});return u.addBinding(n,"srcColor",{label:"线原颜色"}),u.addBinding(n,"color",{label:"线扫颜色"}),u.addBinding(n,"speed",{label:"速度",min:.1,max:1,step:.1}),u.addBinding(n,"scale",{label:"最大扩散",min:10,max:2e3,step:10}),u.addBinding(n,"gradual",{label:"扩散系数",min:1.1,max:10,step:.1}),(t,e)=>(s(),f(o,{showAxesHelper:!1,autoRotate:!1,showBuildings:!1},{ability:v((()=>[p(M,{model:d(r),bulidingsColor:"#000000",landColor:"#112233",topColor:"#999"},null,8,["model"]),p(S,C({builds:d(r).city},n),null,16,["builds"])])),_:1}))}});export{j as default};
