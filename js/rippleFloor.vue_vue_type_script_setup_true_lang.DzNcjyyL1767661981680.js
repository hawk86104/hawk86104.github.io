import{importShared as o}from"./3d-tiles-renderer.COLnOnaF1767661981680.js";import{useLoop as e}from"./index.DJAV0vsW1767661981680.js";const{defineComponent:l}=await o("vue"),{createElementVNode:n,openBlock:t,createElementBlock:i}=await o("vue"),a=["rotation-x"],r=["uniforms"],{onMounted:f,watch:d,reactive:s}=await o("vue"),v=await o("three"),c=l({__name:"rippleFloor",props:{color:{default:"#ffed00"},flySpeed:{default:3},flyIntensity:{default:.3},dotSize:{default:.03},lineColor:{default:"#66f5ff"},floorColor1:{default:"#4c6480"},floorColor2:{default:"#acb4c0"},gridSize:{default:50},lineWidth:{default:.02},paused:{type:Boolean,default:!1}},setup(o){const l=o,c=s({time:{value:0},color1:{value:new v.Color(l.floorColor1)},color2:{value:new v.Color(l.floorColor2)},lineColor:{value:new v.Color(l.lineColor)},flyLineColor:{value:new v.Color(l.lineColor)},gridSize:{value:l.gridSize},lineWidth:{value:l.lineWidth},flySpeed:{value:l.flySpeed},flyIntensity:{value:l.flyIntensity},dotSize:{value:l.dotSize}}),{onBeforeRender:y}=e();let u=0;y(({delta:o})=>{l.paused||(u+=o,c.time.value=u)});const m=()=>{c.color1.value=new v.Color(l.floorColor1),c.color2.value=new v.Color(l.floorColor2),c.lineColor.value=new v.Color(l.lineColor),c.flyLineColor.value=new v.Color(l.lineColor),c.gridSize.value=l.gridSize,c.lineWidth.value=l.lineWidth,c.flySpeed.value=l.flySpeed,c.flyIntensity.value=l.flyIntensity,c.dotSize.value=l.dotSize};return f(()=>{m()}),d(()=>[l.flySpeed,l.flyIntensity,l.dotSize,l.lineColor,l.floorColor1,l.floorColor2,l.gridSize,l.lineWidth],m),(o,e)=>(t(),i("TresMesh",{"rotation-x":-Math.PI/2,position:[0,0,0]},[e[0]||(e[0]=n("TresPlaneGeometry",{args:[10,10]},null,-1)),n("TresShaderMaterial",{uniforms:c,"vertex-shader":"\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n","fragment-shader":"\n    uniform float time;\n    uniform vec3 color1;\n    uniform vec3 color2;\n    uniform vec3 lineColor;\n    uniform vec3 flyLineColor;\n    uniform float gridSize;\n    uniform float lineWidth;\n    uniform float flySpeed;\n    uniform float flyIntensity;\n    uniform float dotSize;\n    varying vec2 vUv;\n    \n    void main() {\n        // 缩放UV以创建网格\n        vec2 scaledUv = vUv * gridSize;\n        \n        // 创建棋盘格图案\n        vec2 cellIndex = floor(scaledUv);\n        float checkValue = mod(cellIndex.x + cellIndex.y, 2.0);\n        vec3 baseColor = (checkValue < 1.0) ? color1 : color2;\n        \n        // 创建基础网格线\n        vec2 gridUv = fract(scaledUv);\n        \n        // 基础垂直线\n        float verticalLine = abs(gridUv.x - 0.5) / fwidth(gridUv.x);\n        float verticalMask = 1.0 - smoothstep(0.0, lineWidth, verticalLine);\n        \n        // 基础水平线\n        float horizontalLine = abs(gridUv.y - 0.5) / fwidth(gridUv.y);\n        float horizontalMask = 1.0 - smoothstep(0.0, lineWidth, horizontalLine);\n        \n        // 组合基础线条\n        float baseLineMask = max(verticalMask, horizontalMask);\n        vec3 colorWithLines = mix(baseColor, lineColor, baseLineMask);\n        \n        // 创建飞线效果\n        // 垂直线飞线\n        float flyVertical = sin(gridUv.y * 6.28 + time * flySpeed) * flyIntensity;\n        float flyVerticalLine = abs(gridUv.x - 0.5 + flyVertical) / fwidth(gridUv.x);\n        float flyVerticalMask = 1.0 - smoothstep(0.0, lineWidth * 0.5, flyVerticalLine);\n        \n        // 水平线飞线\n        float flyHorizontal = sin(gridUv.x * 6.28 + time * flySpeed * 0.7) * flyIntensity;\n        float flyHorizontalLine = abs(gridUv.y - 0.5 + flyHorizontal) / fwidth(gridUv.y);\n        float flyHorizontalMask = 1.0 - smoothstep(0.0, lineWidth * 0.5, flyHorizontalLine);\n        \n        // 组合飞线\n        float flyLineMask = max(flyVerticalMask, flyHorizontalMask);\n        \n        // 添加飞线的发光效果\n        float glowVertical = exp(-flyVerticalLine * 2.0) * 0.3;\n        float glowHorizontal = exp(-flyHorizontalLine * 2.0) * 0.3;\n        float glowMask = max(glowVertical, glowHorizontal);\n        \n        // 创建节点效果 - 在网格正方形的四个顶点\n        float dotRadius = dotSize;\n        float dotFeather = dotSize * 0.3;\n        \n        // 计算到四个顶点的距离\n        vec2 topLeft = vec2(0.0, 0.0);\n        vec2 topRight = vec2(1.0, 0.0);\n        vec2 bottomLeft = vec2(0.0, 1.0);\n        vec2 bottomRight = vec2(1.0, 1.0);\n        \n        float distTopLeft = length(gridUv - topLeft);\n        float distTopRight = length(gridUv - topRight);\n        float distBottomLeft = length(gridUv - bottomLeft);\n        float distBottomRight = length(gridUv - bottomRight);\n        \n        // 找到最近顶点的距离\n        float minDist = min(min(distTopLeft, distTopRight), min(distBottomLeft, distBottomRight));\n        \n        // 在最近顶点附近绘制节点\n        float dotMask = 1.0 - smoothstep(dotRadius - dotFeather, dotRadius + dotFeather, minDist);\n        \n        // 飞线经过节点时的增强效果\n        float nodeGlow = dotMask * flyLineMask * 3.0;\n        \n        // 组合所有效果\n        vec3 finalColor = colorWithLines;\n        \n        // 添加飞线颜色\n        finalColor = mix(finalColor, flyLineColor, flyLineMask);\n        \n        // 添加发光效果\n        finalColor += flyLineColor * glowMask;\n        finalColor += flyLineColor * nodeGlow;\n        \n        // 添加节点 - 使用飞线颜色而不是白色\n        finalColor = mix(finalColor, flyLineColor, dotMask);\n        \n        gl_FragColor = vec4(finalColor, 1.0);\n    }\n",side:2},null,8,r)],8,a))}});export{c as _sfc_main};
