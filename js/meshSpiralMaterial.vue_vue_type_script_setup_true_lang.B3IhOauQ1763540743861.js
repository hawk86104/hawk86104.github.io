import{_ as n}from"./@tresjs.BCHtwiaC1763540743861.js";import{i as o}from"./index.Crdf3MNx1763540743861.js";import{d as e,w as r,H as a,o as l,ac as t,ao as i}from"./@vue.Co_gxueH1763540743861.js";import{l as u,ae as f}from"./three.rXKzP9fQ1763540743861.js";const s=e({__name:"meshSpiralMaterial",props:{frontColor:{default:"#320564"},backColor:{default:"#ec22ff"},intensity:{default:1.5},powerOffset:{default:4},noiseCutOff:{default:.32},colorBoth:{type:Boolean,default:!1}},setup(e){const s=e,c=o.getItem("noiseVoronoi.png"),v={uniforms:{uTime:{value:0},uFrontColor:{value:new u(s.frontColor)},uBackColor:{value:new u(s.backColor).multiplyScalar(s.intensity)},uNoise:{value:c},uPowerOffset:{value:s.powerOffset},uNoiseCutOff:{value:s.noiseCutOff},uColorBoth:{value:s.colorBoth}},vertexShader:"out vec2 vUv;\n\nvoid main()\n{\n    \n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    vUv = uv;\n    \n}",fragmentShader:"uniform float uTime;\nuniform vec3 uFrontColor;\nuniform vec3 uBackColor;\nuniform sampler2D uNoise;\nuniform float uPowerOffset;\nuniform float uNoiseCutOff;\nuniform bool uColorBoth;\n\nin vec2 vUv;\n\nvoid clip( float clipValue, float alphaThreshold, int type )\n{\n    \n    switch( type )\n    {\n        case 0: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n\n        case 1: \n            if( clipValue > alphaThreshold ) discard;\n        break;\n\n        case 2: \n            if( clipValue <= alphaThreshold ) discard;\n        break;\n\n        case 3: \n            if( clipValue >= alphaThreshold ) discard;\n        break;\n\n        case 4: \n            if( clipValue == alphaThreshold ) discard;\n        break;\n\n        default: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n    }\n}\nvec2 tileOffset( vec2 uv , vec2 tiling, vec2 offset )\n{\n    return  uv * tiling + offset;\n}\n\nvoid main()\n{\n    vec2 uv = vUv;\n\n    vec2 timeOffset = vec2( uTime * 0.6, 0.0 );\n\n    \n\n    \n    vec3 noiseVoronoi = texture( uNoise, uv ).rgb;\n\n    float uvCutOff = uv.y;\n\n    uvCutOff = smoothstep( 0.02, 1.0, uvCutOff + 0.2  );\n\n    \n    float noiseCutOff = pow( noiseVoronoi.r, uPowerOffset );\n\n    \n\n    \n    vec3 colorFront = uFrontColor;\n    colorFront *= noiseCutOff;\n\n    vec3 colorBack = uBackColor;\n    colorBack *= noiseCutOff;\n\n    \n    vec3 colorFinal = colorFront;\n\n    if( uColorBoth )\n    {\n        colorFinal = ( ( gl_FrontFacing ) ? colorFront : colorBack );\n    }\n\n    \n    clip( noiseCutOff, uNoiseCutOff, 0 );\n\n    gl_FragColor = vec4( colorFinal, noiseCutOff * uvCutOff );\n    \n\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n\n}",transparent:!0,side:f,depthWrite:!0,depthTest:!0},{onBeforeRender:p}=n();return p(({delta:n})=>{v.uniforms.uTime.value+=n}),r(()=>[s.frontColor,s.backColor],([n,o])=>{v.uniforms.uFrontColor.value.setStyle(n),v.uniforms.uBackColor.value.setStyle(o).multiplyScalar(s.intensity)}),(n,o)=>(l(),a("TresShaderMaterial",t(i(v)),null,16))}});export{s as _};
