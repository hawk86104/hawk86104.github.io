import{m as n,e,a as t,o as r,f as o}from"./@tresjs.8SAr0PX_1741857949183.js";import{P as i}from"./tweakpane.yDiyAAkA1741857949183.js";import{B as c,_ as a,O as l,W as s,C as u,aW as f,r as p,V as v}from"./three.Gi_-4zeu1741857949183.js";import{d as g,a3 as d,b as x,o as h,f as m,u as y,g as w,j as b,al as R,r as C,N as I,aj as _,ak as M}from"./@vue.NRI7TcgI1741857949183.js";import"./postprocessing.D5IzAGSN1741857949183.js";import"./@vueuse.PrSwDteH1741857949183.js";var z="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const D=F;!function(n,e){const t=F,r=A();for(;;)try{if(324390===parseInt(t(487))/1+parseInt(t(494))/2*(-parseInt(t(480))/3)+-parseInt(t(512))/4+parseInt(t(481))/5*(parseInt(t(489))/6)+-parseInt(t(496))/7+-parseInt(t(472))/8*(-parseInt(t(506))/9)+parseInt(t(508))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[F(514)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function A(){const n=["table","RawShaderMaterial",'{}.constructor("return this")( )',"909888YKRVnf","bind","apply","error","water","counter","prototype","FrontSide","tiles","action","Mesh","length","uniforms","waterTexture","3612136QDuCxE","test","BufferAttribute","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","exception","pool","init","console","330OSsUwv","10umByxf","stateObject","string","toString","constructor","function *\\( *\\)","620600UatXKG","causticTex","48702iAZRdV","while (true) {}","info","input","log","9434QdBbQR","warn","3895416VYFYno","chain","gger","trace","render","debu","light","value","call","__proto__","9lQOPyU","setIndex","5388690DbxgJs"];return(A=function(){return n})()}!function(){T(this,(function(){const n=F,e=new RegExp(n(486)),t=new RegExp(n(475),"i"),r=O(n(478));e[n(473)](r+n(497))&&t.test(r+n(492))?O():r("0")}))()}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[F(514)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function F(n,e){const t=A();return(F=function(n,e){return t[n-=463]})(n,e)}L(void 0,(function(){const n=F;let e;try{e=Function("return (function() "+n(511)+");")()}catch(o){e=window}const t=e[n(479)]=e[n(479)]||{},r=[n(493),n(495),n(491),n(515),n(476),n(509),n(499)];for(let i=0;i<r[n(469)];i++){const e=L.constructor[n(464)].bind(L),o=r[i],c=t[o]||e;e[n(505)]=L[n(513)](L),e[n(484)]=c[n(484)][n(513)](c),t[o]=e}}))();const j=g({__name:D(477),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=D,o=t,i=new c,l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i.setAttribute("position",new(a[r(474)])(l,3)),i[r(507)](new(a[r(474)])(s,1));const u=new(a[r(510)])({uniforms:{light:{value:o[r(502)]},tiles:{value:o[r(466)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:a[r(465)]}),f=new(a[r(468)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{((n,e)=>{const t=r;u.uniforms[t(516)].value=n,u[t(470)][t(488)][t(503)]=e,p[t(503)][t(500)](f,v[t(503)])})(o[r(471)],o.causticsTexture)})),(n,e)=>null}});function O(n){function e(n){const t=F;if(typeof n===t(483))return function(n){}[t(485)](t(490))[t(514)](t(463));1!==(""+n/n)[t(469)]||n%20==0?function(){return!0}[t(485)](t(501)+t(498))[t(504)](t(467)):function(){return!1}[t(485)](t(501)+t(498)).apply(t(482)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=S,r=P();for(;;)try{if(977814===parseInt(t(144))/1*(-parseInt(t(131))/2)+parseInt(t(134))/3*(-parseInt(t(128))/4)+-parseInt(t(167))/5*(-parseInt(t(160))/6)+-parseInt(t(161))/7*(-parseInt(t(153))/8)+-parseInt(t(154))/9*(parseInt(t(162))/10)+-parseInt(t(157))/11*(parseInt(t(120))/12)+-parseInt(t(137))/13*(-parseInt(t(155))/14))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const E=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function S(n,e){const t=P();return(S=function(n,e){return t[n-=118]})(n,e)}!function(){E(this,(function(){const n=S,e=new RegExp("function *\\( *\\)"),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=H(n(171));e[n(147)](r+n(121))&&t[n(147)](r+n(177))?H():r("0")}))()}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[S(150)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function P(){const n=["call","counter","trace","60dpoeyc","chain","light","white","debu","neg-z.jpg","table","setClearColor","4IFcEnd","neg-x.jpg","water","10iXmKAG","CubeTextureLoader","BackSide","2723202unMOvQ","FrontSide","pos-y.jpg","22201829dcFaVZ","uniforms","waterTexture","prototype","Color","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","RawShaderMaterial","251617nYpQSx",'{}.constructor("return this")( )',"console","test","length","bind","apply","return (function() ","clear","24hTIVHt","3018555vHjDxy","14RVrJux","toString","22759TRtmWA","value","info","6NNBGqi","4325790ZJHHvt","40hATTnw","Mesh","stateObject","load","constructor","4669075ofGNRy","action","pooRef","setRenderTarget","init","gger","side","causticsTexture","pos-x.jpg","setPath","input","underwater","geometry","render"];return(P=function(){return n})()}W(void 0,(function(){const n=S,e=function(){const n=S;let e;try{e=Function(n(151)+n(145)+");")()}catch(t){e=window}return e}(),t=e[n(146)]=e[n(146)]||{},r=["log","warn",n(159),"error","exception",n(126),n(119)];for(let o=0;o<r.length;o++){const e=W.constructor[n(140)][n(149)](W),i=r[o],c=t[i]||e;e.__proto__=W.bind(W),e[n(156)]=c.toString[n(149)](c),t[i]=e}}))();const V=g({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=S;let i,c;const l=r,s=l[o(179)],u=(new(a[o(132)]))[o(176)](o(142))[o(165)]([o(175),o(129),o(136),"neg-y.jpg","pos-z.jpg",o(125)]),f=([i,c]=d((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,c(),i),p=new(a[o(143)])({uniforms:{light:{value:l[o(122)]},tiles:{value:f},sky:{value:u},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),v=new(a[o(163)])(s,p),g=x(null),w=new(a[o(141)])(o(123)),{renderer:b,camera:R}=n(),{onLoop:C}=e();return C((()=>{const n=o;b[n(158)][n(170)](null),b[n(158)][n(127)](w,1),b[n(158)][n(152)](),p[n(138)][n(130)].value=l[n(139)],p.uniforms.causticTex[n(158)]=l[n(174)],p[n(173)]=a[n(135)],p[n(138)][n(178)][n(158)]=!0,b[n(158)][n(180)](v,R.value),p[n(173)]=a[n(133)],p[n(138)][n(178)][n(158)]=!1,b[n(158)][n(180)](v,R.value)})),(n,e)=>{const t=o;return h(),m(j,{tiles:y(f),light:n[t(122)],waterTexture:n[t(139)],causticsTexture:n.causticsTexture,ref_key:t(169),ref:g},null,8,["tiles",t(122),"waterTexture","causticsTexture"])}}});function H(n){function e(n){const t=S;if("string"==typeof n)return function(n){}[t(166)]("while (true) {}")[t(150)](t(118));1!==(""+n/n)[t(148)]||n%20==0?function(){return!0}[t(166)]("debugger")[t(181)](t(168)):function(){return!1}[t(166)](t(124)+t(172)).apply(t(164)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const k=N;!function(n,e){const t=N,r=G();for(;;)try{if(740366===-parseInt(t(197))/1+parseInt(t(241))/2+parseInt(t(199))/3+-parseInt(t(237))/4+parseInt(t(233))/5+parseInt(t(204))/6+-parseInt(t(235))/7)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Z(this,(function(){const n=N,e=new RegExp(n(229)),t=new RegExp(n(208),"i"),r=$(n(200));e.test(r+n(226))&&t[n(206)](r+n(219))?$():r("0")}))()}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[N(203)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function N(n,e){const t=G();return(N=function(n,e){return t[n-=195]})(n,e)}function G(){const n=["input","render","Mesh","uniforms","black","texture","call","chain","ShaderMaterial","caustics","function *\\( *\\)","return (function() ","stateObject","length","1639855vEZMKb","PlaneGeometry","7007826jWyudk","warn","4511088swpHjH","log","toString","causticsTexture","2604490DmKdVP","debu","prototype","118427IoFFjP","string","288966tVWWMk","init","exception","table","apply","7566870tnQKfQ","setClearColor","test","waterTexture","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","constructor","counter","gger","value","light","setRenderTarget","info",'{}.constructor("return this")( )',"bind","error"];return(G=function(){return n})()}B(void 0,(function(){const n=N,e=function(){const n=N;let e;try{e=Function(n(230)+n(216)+");")()}catch(t){e=window}return e}(),t=e.console=e.console||{},r=[n(238),n(236),n(215),n(218),n(201),n(202),"trace"];for(let o=0;o<r.length;o++){const e=B.constructor[n(196)].bind(B),i=r[o],c=t[i]||e;e.__proto__=B[n(217)](B),e.toString=c[n(239)].bind(c),t[i]=e}}))();const Y=g({__name:k(228),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=k,o=t,i=new l(0,1,1,0,0,2e3),c=new(a[r(234)])(2,2,200,200),f=new s(1024,1024),p=new(a[r(227)])({uniforms:{light:{value:o[r(213)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),v=new(a[r(221)])(c,p),g=new u(r(223)),{renderer:d}=n(),{onBeforeLoop:x}=e();return x((()=>{const n=r;v.material[n(222)].water[n(212)]=o[n(207)],d.value[n(214)](f),d[n(212)][n(205)](g,0),d[n(212)].clear(),d[n(212)][n(220)](v,i)})),(n,e)=>{const t=r;return h(),m(R,null,{default:w((()=>[b(V,{waterTexture:n[t(207)],causticsTexture:y(f)[t(224)],light:n.light,geometry:y(c)},null,8,["waterTexture",t(240),"light","geometry"])])),_:1})}}});function $(n){function e(n){const t=N;if(typeof n===t(198))return function(n){}.constructor("while (true) {}")[t(203)](t(210));1!==(""+n/n)[t(232)]||n%20==0?function(){return!0}[t(209)](t(195)+t(211))[t(225)]("action"):function(){return!1}[t(209)](t(195)+t(211))[t(203)](t(231)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const Q=U;!function(n,e){const t=U,r=J();for(;;)try{if(641274===-parseInt(t(473))/1+-parseInt(t(524))/2+parseInt(t(464))/3+parseInt(t(520))/4+-parseInt(t(512))/5+-parseInt(t(528))/6+parseInt(t(510))/7)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[U(507)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function U(n,e){const t=J();return(U=function(n,e){return t[n-=463]})(n,e)}!function(){K(this,(function(){const n=U,e=new RegExp(n(514)),t=new RegExp(n(474),"i"),r=nn(n(469));e[n(496)](r+n(495))&&t[n(496)](r+n(489))?nn():r("0")}))()}();const q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[U(507)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function J(){const n=["clientY","render","2074692SZEvaB","call","waterTexture","radius","5224404jDuSsU","trace","uniforms","3583401zhVCuz","autoClear","center","RawShaderMaterial","action","init","stateObject","left","setFromCamera","1152569cniZLd","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","setZ","height","mousemove","length","toString","WebGLRenderTarget","waterSimulation","info","OrthographicCamera",'{}.constructor("return this")( )',"intersectObject","count","error","clientX","input","material","getBoundingClientRect","removeEventListener","constructor","Mesh","chain","test","bind","while (true) {}","PlaneGeometry","FloatType","log","gger","width","exception","warn","addEventListener","apply","return (function() ","texture","16427075YlPWBc","setRenderTarget","1947655lwGvTI","domElement","function *\\( *\\)","console","debu","value","__proto__","light","2201048FPJiJZ","setY"];return(J=function(){return n})()}q(void 0,(function(){const n=U;let e;try{e=Function(n(508)+n(484)+");")()}catch(o){e=window}const t=e[n(515)]=e.console||{},r=[n(501),n(505),n(482),n(487),n(504),"table",n(529)];for(let i=0;i<r[n(478)];i++){const e=q[n(493)].prototype.bind(q),o=r[i],c=t[o]||e;e[n(518)]=q[n(497)](q),e[n(479)]=c[n(479)][n(497)](c),t[o]=e}}))();const X=g({__name:Q(481),props:{light:{}},setup(t,{expose:r}){const o=Q,i=new(a[o(483)])(0,1,1,0,0,2e3),c=new(a[o(499)])(2,2),l=new(a[o(480)])(256,256,{type:a[o(500)]}),s=new(a[o(480)])(256,256,{type:a[o(500)]}),u=new(a[o(467)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),g=new f({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),d=new(a[o(467)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),x=new(a[o(494)])(c,u),w=new p(c,g),b=new(a[o(494)])(c,d);let R=l;const C=(n,e)=>{const t=o,r=R,c=R===l?s:l;e[t(490)][t(463)][t(509)][t(517)]=r[t(509)],n[t(511)](c),n[t(523)](e,i),R=c},{renderer:I,camera:_,raycaster:M}=n();I[o(517)][o(465)]=!1;const{onBeforeLoop:D}=e();D((()=>{const n=o;var e,t;t=I[n(517)],C(t,b),e=I[n(517)],C(e,w)}));const T=(n,e,t,r)=>{const i=o;x[i(490)][i(463)][i(466)][i(517)]=[n,e],x[i(490)][i(463)][i(527)][i(517)]=t,x[i(490)][i(463)].strength[i(517)]=r,C(I[i(517)],x)},A=new v,L=new(a[o(499)])(2,2),F=L.attributes.position;for(let n=0;n<F[o(486)];n++){const e=-F.getY(n);F[o(521)](n,0),F[o(475)](n,e)}F.needsUpdate=!0;const j=new(a[o(494)])(L),O={handleEvent:n=>{const e=o,t=I[e(517)][e(513)][e(491)](),r=t[e(503)],i=t[e(476)];A.x=2*(n[e(488)]-t[e(471)])/r-1,A.y=2*-(n[e(522)]-t.top)/i+1,M.value[e(472)](A,_[e(517)]);const c=M.value[e(485)](j);for(let o of c)T(o.point.x,o.point.z,.03,.04)}};return r({addDrop:T,mouseEvent:n=>{const e=o;n?I[e(517)].domElement[e(506)]("mousemove",O):I.value.domElement[e(492)](e(477),O)}}),(n,e)=>{const t=o;return h(),m(Y,{lightFrontGeometry:y(c),waterTexture:y(R)[t(509)],light:n[t(519)]},null,8,["lightFrontGeometry",t(526),t(519)])}}});function nn(n){function e(n){const t=U;if("string"==typeof n)return function(n){}[t(493)](t(498))[t(507)]("counter");1!==(""+n/n)[t(478)]||n%20==0?function(){return!0}[t(493)]("debu"+t(502))[t(525)](t(468)):function(){return!1}.constructor(t(516)+t(502))[t(507)](t(470)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const en=cn;!function(n,e){const t=cn,r=on();for(;;)try{if(676025===-parseInt(t(217))/1*(parseInt(t(232))/2)+-parseInt(t(234))/3+-parseInt(t(200))/4*(parseInt(t(212))/5)+-parseInt(t(222))/6*(-parseInt(t(215))/7)+-parseInt(t(229))/8+-parseInt(t(210))/9+parseInt(t(216))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const tn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[cn(236)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){tn(this,(function(){const n=cn,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(199),"i"),r=ln(n(225));e[n(227)](r+n(204))&&t[n(227)](r+"input")?ln():r("0")}))()}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[cn(236)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function on(){const n=["info","bind","string","24AQiEvg","realWater","debu","init","addButton","test","constructor","8670368KoUlCY","gger",'{}.constructor("return this")( )',"34ieyhvR","change","890484WcKjAe","warn","apply","addDrop","counter","manual","prototype","length","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","116jBMRpq","mouseEvent","value","点击按钮","chain","waterSimulationRef","toString","exception","console","log","4634523zHEYII","stateObject","215645iUguSX","随机增加波纹","table","1511321lknkwZ","31519640wrnari","11367YBzNMH","random"];return(on=function(){return n})()}function cn(n,e){const t=on();return(cn=function(n,e){return t[n-=198]})(n,e)}rn(void 0,(function(){const n=cn;let e;try{e=Function("return (function() "+n(231)+");")()}catch(o){e=window}const t=e[n(208)]=e.console||{},r=[n(209),n(235),n(219),"error",n(207),n(214),"trace"];for(let i=0;i<r[n(198)];i++){const e=rn[n(228)][n(240)][n(220)](rn),o=r[i],c=t[o]||e;e.__proto__=rn[n(220)](rn),e[n(206)]=c[n(206)].bind(c),t[o]=e}}))();const an=g({__name:en(223),setup(n){const e=en,t=C({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(239)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=x(null),l=new i;l[e(226)]({label:e(203),title:e(213)}).on("click",(()=>{const n=e;for(var t=0;t<10;t++)a.value[n(237)](2*Math[n(218)]()-1,2*Math[n(218)]()-1,.03,1&t?.02:-.02)}));const s=x(!1);return l.addBinding(s,e(202),{label:"鼠标波纹"}).on(e(233),(n=>{const t=e;a.value[t(201)](n.value)})),(n,i)=>{const l=e;return h(),m(y(o),_(M(t)),{default:w((()=>[i[0]||(i[0]=I("TresPerspectiveCamera",{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),b(y(r)),b(X,{light:c,ref_key:l(205),ref:a},null,512)])),_:1},16)}}});function ln(n){function e(n){const t=cn;if(typeof n===t(221))return function(n){}.constructor("while (true) {}").apply(t(238));1!==(""+n/n)[t(198)]||n%20==0?function(){return!0}[t(228)]("debu"+t(230)).call("action"):function(){return!1}[t(228)](t(224)+t(230))[t(236)](t(211)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{an as default};
