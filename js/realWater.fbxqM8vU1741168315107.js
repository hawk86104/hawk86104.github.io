import{m as n,e,a as t,o as r,f as o}from"./@tresjs.Ea5Oq_-I1741168315107.js";import{P as i}from"./tweakpane.yDiyAAkA1741168315107.js";import{_ as c,aW as a,l,o as s,r as u}from"./three.FxqAALWt1741168315107.js";import{d as f,a3 as p,b as v,o as g,f as d,u as x,g as h,j as m,al as y,r as w,N as b,aj as I,ak as R}from"./@vue.NRI7TcgI1741168315107.js";import"./postprocessing.hfy6Kqg11741168315107.js";import"./@vueuse.Z8xAfE_A1741168315107.js";var C="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";function _(){const n=["RawShaderMaterial","2853CnEgIN","4149620TAwDxO","24312unwDIe","9VdoPuj","debu","info","position","function *\\( *\\)","apply","toString","render","value","call","5177090AUmKKS","error","BufferAttribute","string","gger","constructor","exception","uniforms","warn","console","BufferGeometry","causticsTexture","17371959caMXgz","chain","478580vuMLvS","FrontSide","prototype","setAttribute","2111684EwWckK","action","return (function() ","bind","trace","1hjKAUp","stateObject","causticTex","7KFRiKz","tiles","580254FfzGti","setIndex","Mesh","water","init","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","test","counter","length","while (true) {}"];return(_=function(){return n})()}!function(n,e){const t=D,r=_();for(;;)try{if(554800===parseInt(t(353))/1*(-parseInt(t(348))/2)+parseInt(t(372))/3*(-parseInt(t(344))/4)+parseInt(t(382))/5+-parseInt(t(358))/6*(parseInt(t(356))/7)+parseInt(t(371))/8*(-parseInt(t(369))/9)+parseInt(t(370))/10+parseInt(t(342))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const M=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[D(377)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){M(this,(function(){const n=D,e=new RegExp(n(376)),t=new RegExp(n(363),"i"),r=L(n(362));e[n(364)](r+n(343))&&t[n(364)](r+"input")?L():r("0")}))()}();const z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[D(377)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function D(n,e){const t=_();return(D=function(n,e){return t[n-=336]})(n,e)}z(void 0,(function(){const n=D,e=function(){const n=D;let e;try{e=Function(n(350)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e.console=e[n(339)]||{},r=["log",n(338),n(374),n(383),n(336),"table",n(352)];for(let o=0;o<r[n(366)];o++){const e=z.constructor[n(346)][n(351)](z),i=r[o],c=t[i]||e;e.__proto__=z[n(351)](z),e[n(378)]=c[n(378)][n(351)](c),t[i]=e}}))();const T=f({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=D,o=t,i=new(c[r(340)]),a=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),l=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(347)](r(375),new(c[r(384)])(a,3)),i[r(359)](new(c[r(384)])(l,1));const s=new(c[r(368)])({uniforms:{light:{value:o.light},tiles:{value:o[r(357)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(345)]}),u=new(c[r(360)])(i,s),{renderer:f,camera:p}=n(),{onAfterLoop:v}=e();return v((()=>{const n=r;((n,e)=>{const t=r;s.uniforms[t(361)][t(380)]=n,s[t(337)][t(355)][t(380)]=e,f[t(380)][t(379)](u,p[t(380)])})(o.waterTexture,o[n(341)])})),(n,e)=>null}});function L(n){function e(n){const t=D;if(typeof n===t(385))return function(n){}[t(387)](t(367))[t(377)](t(365));1!==(""+n/n).length||n%20==0?function(){return!0}[t(387)](t(373)+t(386))[t(381)](t(349)):function(){return!1}[t(387)](t(373)+"gger")[t(377)](t(354)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=S,r=j();for(;;)try{if(270051===-parseInt(t(446))/1+parseInt(t(432))/2*(-parseInt(t(442))/3)+-parseInt(t(464))/4+-parseInt(t(455))/5*(parseInt(t(468))/6)+parseInt(t(444))/7*(parseInt(t(439))/8)+parseInt(t(467))/9*(parseInt(t(457))/10)+parseInt(t(458))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[S(436)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){A(this,(function(){const n=S,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(470),"i"),r=E("init");e.test(r+n(433))&&t.test(r+"input")?E():r("0")}))()}();const O=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function j(){const n=["neg-x.jpg","light","exception","tiles","length","43294qurLbk","chain","gger","water","apply","counter","console","448544tdGXFr","neg-z.jpg","debu","15rHHcSR","pos-z.jpg","7ScbuxU","neg-y.jpg","167558zPTBIG","causticTex","setRenderTarget","setClearColor","clear","bind","side","causticsTexture","underwater","765cLWqnv","warn","3030WjpjIn","11511731CiDVgE","pos-y.jpg","Color","return (function() ","BackSide","geometry","1831712LOZhso","waterTexture","pos-x.jpg","6822QpADSA","12882JOrfus","stateObject","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","trace","load",'{}.constructor("return this")( )',"value","toString","uniforms","CubeTextureLoader","__proto__","call","FrontSide","constructor","Mesh","render"];return(j=function(){return n})()}O(void 0,(function(){const n=S;let e;try{e=Function(n(461)+n(473)+");")()}catch(o){e=window}const t=e[n(438)]=e[n(438)]||{},r=["log",n(456),"info","error",n(429),"table",n(471)];for(let i=0;i<r[n(431)];i++){const e=O[n(481)].prototype[n(451)](O),o=r[i],c=t[o]||e;e[n(478)]=O[n(451)](O),e[n(475)]=c[n(475)][n(451)](c),t[o]=e}}))();const F=f({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=S;let i,l;const s=r,u=s[o(463)],f=(new(c[o(477)])).setPath("https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/")[o(472)]([o(466),o(427),o(459),o(445),o(443),o(440)]),h=([i,l]=p((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,l(),i),m=new a({uniforms:{light:{value:s[o(428)]},tiles:{value:h},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new(c[o(482)])(u,m),w=v(null),b=new(c[o(460)])("white"),{renderer:I,camera:R}=n(),{onLoop:C}=e();return C((()=>{const n=o;I[n(474)][n(448)](null),I[n(474)][n(449)](b,1),I[n(474)][n(450)](),m[n(476)][n(435)].value=s[n(465)],m[n(476)][n(447)][n(474)]=s[n(453)],m[n(452)]=c[n(480)],m[n(476)][n(454)][n(474)]=!0,I[n(474)][n(426)](y,R[n(474)]),m[n(452)]=c[n(462)],m[n(476)][n(454)].value=!1,I[n(474)][n(426)](y,R[n(474)])})),(n,e)=>{const t=o;return g(),d(T,{tiles:x(h),light:n.light,waterTexture:n[t(465)],causticsTexture:n.causticsTexture,ref_key:"pooRef",ref:w},null,8,[t(430),t(428),"waterTexture",t(453)])}}});function S(n,e){const t=j();return(S=function(n,e){return t[n-=426]})(n,e)}function E(n){function e(n){const t=S;if("string"==typeof n)return function(n){}[t(481)]("while (true) {}")[t(436)](t(437));1!==(""+n/n).length||n%20==0?function(){return!0}[t(481)](t(441)+"gger")[t(479)]("action"):function(){return!1}.constructor(t(441)+t(434))[t(436)](t(469)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const W=P;function P(n,e){const t=V();return(P=function(n,e){return t[n-=128]})(n,e)}!function(n,e){const t=P,r=V();for(;;)try{if(911257===-parseInt(t(174))/1+-parseInt(t(177))/2+parseInt(t(172))/3*(parseInt(t(164))/4)+-parseInt(t(143))/5*(-parseInt(t(170))/6)+-parseInt(t(161))/7*(parseInt(t(153))/8)+-parseInt(t(160))/9*(-parseInt(t(169))/10)+parseInt(t(145))/11*(parseInt(t(158))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const k=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(181)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function V(){const n=["error","1093635MTajWO","1876091ntbocN","log","geometry","13756xBbOXk","black","setClearColor","WebGLRenderTarget","info","100RaaTcW","71718hBqmHS","clear","126iBwyhI","__proto__","602294GBjVQk","action","return (function() ","2582336SpYkqu","setRenderTarget","input","test","apply","Color","value","length","PlaneGeometry","constructor","stateObject","string","caustics","Mesh","OrthographicCamera",'{}.constructor("return this")( )',"console","debu","toString","water","trace","function *\\( *\\)","while (true) {}","95HpkhuS","chain","77NPXqLy","material","warn","light","waterTexture","texture","bind","counter","8QuaFrp","causticsTexture","prototype","gger","init","2547492TqbsEE"];return(V=function(){return n})()}!function(){k(this,(function(){const n=P,e=new RegExp(n(141)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=B(n(157));e.test(r+n(144))&&t[n(180)](r+n(179))?B():r("0")}))()}();const H=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(181)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();H(void 0,(function(){const n=P,e=function(){const n=P;let e;try{e=Function(n(176)+n(135)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(136)]||{},r=[n(162),n(147),n(168),n(159),"exception","table",n(140)];for(let o=0;o<r[n(184)];o++){const e=H[n(129)][n(155)].bind(H),i=r[o],c=t[i]||e;e[n(173)]=H[n(151)](H),e[n(138)]=c.toString[n(151)](c),t[i]=e}}))();const Z=f({__name:W(132),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=W,o=t,i=new(c[r(134)])(0,1,1,0,0,2e3),a=new(c[r(128)])(2,2,200,200),s=new(c[r(167)])(1024,1024),u=new l({uniforms:{light:{value:o.light},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),f=new(c[r(133)])(a,u),p=new(c[r(182)])(r(165)),{renderer:v}=n(),{onBeforeLoop:w}=e();return w((()=>{const n=r;f[n(146)].uniforms[n(139)].value=o[n(149)],v.value[n(178)](s),v[n(183)][n(166)](p,0),v[n(183)][n(171)](),v[n(183)].render(f,i)})),(n,e)=>{const t=r;return g(),d(y,null,{default:h((()=>[m(F,{waterTexture:n[t(149)],causticsTexture:x(s)[t(150)],light:n.light,geometry:x(a)},null,8,[t(149),t(154),t(148),t(163)])])),_:1})}}});function B(n){function e(n){const t=P;if(typeof n===t(131))return function(n){}.constructor(t(142))[t(181)](t(152));1!==(""+n/n)[t(184)]||n%20==0?function(){return!0}[t(129)]("debu"+t(156)).call(t(175)):function(){return!1}[t(129)](t(137)+t(156))[t(181)](t(130)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const G=X;!function(n,e){const t=X,r=$();for(;;)try{if(138213===parseInt(t(380))/1*(parseInt(t(341))/2)+-parseInt(t(372))/3+-parseInt(t(384))/4+-parseInt(t(356))/5+-parseInt(t(379))/6*(-parseInt(t(358))/7)+-parseInt(t(378))/8*(parseInt(t(382))/9)+parseInt(t(386))/10*(parseInt(t(325))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const N=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[X(371)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){N(this,(function(){const n=X,e=new RegExp("function *\\( *\\)"),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=Y(n(376));e[n(362)](r+n(343))&&t[n(362)](r+"input")?Y():r("0")}))()}();const q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[X(371)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function X(n,e){const t=$();return(X=function(n,e){return t[n-=317]})(n,e)}function $(){const n=["attributes","setZ","texture","radius","action","warn","uniforms","info","WebGLRenderTarget","80840cTuxXC","Mesh","1031471mHODCG","Vector2","toString","gger","test","clientX","FloatType","while (true) {}","domElement","bind","length","prototype","console","apply","223587fzxKIx","OrthographicCamera","height","table","init","counter","856IJOuRF","6VSnuwQ","57ehLgep","addEventListener","22329EDhXBb","intersectObject","1012540XWasMp","constructor","60ZzRvsm","getY","RawShaderMaterial","strength","trace","value","error","getBoundingClientRect",'{}.constructor("return this")( )',"debu","waterSimulation","875721BhxRMi","material","point","__proto__","setY","light","render","position","clientY","call","autoClear","lightFrontGeometry","mousemove","count","string","removeEventListener","4298rAwjxW","stateObject","chain","center","width","PlaneGeometry"];return($=function(){return n})()}q(void 0,(function(){const n=X,e=function(){const n=X;let e;try{e=Function("return (function() "+n(322)+");")()}catch(t){e=window}return e}(),t=e[n(370)]=e[n(370)]||{},r=["log",n(352),n(354),n(320),"exception",n(375),n(318)];for(let o=0;o<r.length;o++){const e=q[n(385)][n(369)][n(367)](q),i=r[o],c=t[i]||e;e[n(328)]=q.bind(q),e[n(360)]=c[n(360)][n(367)](c),t[i]=e}}))();const K=f({__name:G(324),props:{light:{}},setup(t,{expose:r}){const o=G,i=new(c[o(373)])(0,1,1,0,0,2e3),a=new(c[o(346)])(2,2),l=new(c[o(355)])(256,256,{type:c[o(364)]}),f=new(c[o(355)])(256,256,{type:s}),p=new(c[o(388)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:C,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),v=new(c[o(388)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:C,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),h=new(c[o(388)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:C,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),m=new(c[o(357)])(a,p),y=new(c[o(357)])(a,v),w=new u(a,h);let b=l;const I=(n,e)=>{const t=o,r=b,c=b===l?f:l;e[t(326)][t(353)][t(349)][t(319)]=r[t(349)],n.setRenderTarget(c),n[t(331)](e,i),b=c},{renderer:R,camera:_,raycaster:M}=n();R[o(319)][o(335)]=!1;const{onBeforeLoop:z}=e();z((()=>{const n=o;var e,t;t=R[n(319)],I(t,w),e=R[n(319)],I(e,y)}));const D=(n,e,t,r)=>{const i=o;m[i(326)][i(353)][i(344)][i(319)]=[n,e],m[i(326)][i(353)][i(350)][i(319)]=t,m[i(326)][i(353)][i(317)].value=r,I(R[i(319)],m)},T=new(c[o(359)]),L=new(c[o(346)])(2,2),A=L[o(347)][o(332)];for(let n=0;n<A[o(338)];n++){const e=-A[o(387)](n);A[o(329)](n,0),A[o(348)](n,e)}A.needsUpdate=!0;const O=new(c[o(357)])(L),j={handleEvent:n=>{const e=o,t=R[e(319)][e(366)][e(321)](),r=t[e(345)],i=t[e(374)];T.x=2*(n[e(363)]-t.left)/r-1,T.y=2*-(n[e(333)]-t.top)/i+1,M[e(319)].setFromCamera(T,_.value);const c=M[e(319)][e(383)](O);for(let o of c)D(o[e(327)].x,o[e(327)].z,.03,.04)}};return r({addDrop:D,mouseEvent:n=>{const e=o;n?R[e(319)][e(366)][e(381)]("mousemove",j):R.value[e(366)][e(340)](e(337),j)}}),(n,e)=>{const t=o;return g(),d(Z,{lightFrontGeometry:x(a),waterTexture:x(b)[t(349)],light:n[t(330)]},null,8,[t(336),"waterTexture",t(330)])}}});function Y(n){function e(n){const t=X;if(typeof n===t(339))return function(n){}.constructor(t(365)).apply(t(377));1!==(""+n/n)[t(368)]||n%20==0?function(){return!0}[t(385)](t(323)+"gger")[t(334)](t(351)):function(){return!1}.constructor(t(323)+t(361))[t(371)](t(342)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const U=nn;!function(n,e){const t=nn,r=en();for(;;)try{if(462096===parseInt(t(314))/1*(-parseInt(t(342))/2)+-parseInt(t(312))/3+-parseInt(t(343))/4*(-parseInt(t(321))/5)+parseInt(t(344))/6*(parseInt(t(304))/7)+parseInt(t(341))/8*(-parseInt(t(335))/9)+parseInt(t(303))/10*(parseInt(t(338))/11)+-parseInt(t(309))/12)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[nn(310)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Q(this,(function(){const n=nn,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(308),"i"),r=rn(n(306));e[n(339)](r+n(337))&&t.test(r+n(305))?rn():r("0")}))()}();const J=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function nn(n,e){const t=en();return(nn=function(n,e){return t[n-=297]})(n,e)}function en(){const n=["8XAodlQ","gger","error","table","console","realWater","constructor","15YCbXdN","warn","counter","click","while (true) {}","addButton","prototype","waterSimulationRef","bind","info","addBinding","debu","toString","mouseEvent","177318PUDaPk","random","chain","451yLJCYt","test","manual","24eDZYuf","72454OMYqgD","715944VipOhw","12894EVwZGq","__proto__","trace","value","change","length","随机增加波纹","132820uEkdWP","2709vmKZcG","input","init","exception","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","6757584ZRxqKm","apply","TresPerspectiveCamera","1617099SdYOGj","log"];return(en=function(){return n})()}J(void 0,(function(){const n=nn;let e;try{e=Function('return (function() {}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(318)]=e[n(318)]||{},r=[n(313),n(322),n(330),n(316),n(307),n(317),n(298)];for(let i=0;i<r[n(301)];i++){const e=J[n(320)][n(327)][n(329)](J),o=r[i],c=t[o]||e;e[n(297)]=J[n(329)](J),e[n(333)]=c[n(333)][n(329)](c),t[o]=e}}))();const tn=f({__name:U(319),setup(n){const e=U,t=w({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(340)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=v(null),l=new i;l[e(326)]({label:"点击按钮",title:e(302)}).on(e(324),(()=>{const n=e;for(var t=0;t<10;t++)a.value.addDrop(2*Math.random()-1,2*Math[n(336)]()-1,.03,1&t?.02:-.02)}));const s=v(!1);return l[e(331)](s,e(299),{label:"鼠标波纹"}).on(e(300),(n=>{const t=e;a[t(299)][t(334)](n[t(299)])})),(n,i)=>{const l=e;return g(),d(x(o),I(R(t)),{default:h((()=>[i[0]||(i[0]=b(l(311),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),m(x(r)),m(K,{light:c,ref_key:l(328),ref:a},null,512)])),_:1},16)}}});function rn(n){function e(n){const t=nn;if("string"==typeof n)return function(n){}.constructor(t(325))[t(310)](t(323));1!==(""+n/n).length||n%20==0?function(){return!0}[t(320)](t(332)+t(315)).call("action"):function(){return!1}[t(320)](t(332)+t(315)).apply("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{tn as default};
