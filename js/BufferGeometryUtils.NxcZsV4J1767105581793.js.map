{"version":3,"file":"BufferGeometryUtils.NxcZsV4J1767105581793.js","sources":["../../node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\n/**\n * @module BufferGeometryUtils\n * @three_import import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n */\n\n/**\n * Computes vertex tangents using the MikkTSpace algorithm. MikkTSpace generates the same tangents consistently,\n * and is used in most modelling tools and normal map bakers. Use MikkTSpace for materials with normal maps,\n * because inconsistent tangents may lead to subtle visual issues in the normal map, particularly around mirrored\n * UV seams.\n *\n * In comparison to this method, {@link BufferGeometry#computeTangents} (a custom algorithm) generates tangents that\n * probably will not match the tangents in other software. The custom algorithm is sufficient for general use with a\n * custom material, and may be faster than MikkTSpace.\n *\n * Returns the original BufferGeometry. Indexed geometries will be de-indexed. Requires position, normal, and uv attributes.\n *\n * @param {BufferGeometry} geometry - The geometry to compute tangents for.\n * @param {Object} MikkTSpace - Instance of `examples/jsm/libs/mikktspace.module.js`, or `mikktspace` npm package.\n * Await `MikkTSpace.ready` before use.\n * @param {boolean} [negateSign=true] - Whether to negate the sign component (.w) of each tangent.\n * Required for normal map conventions in some formats, including glTF.\n * @return {BufferGeometry} The updated geometry.\n */\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * Merges a set of geometries into a single instance. All geometries must have compatible attributes.\n *\n * @param {Array<BufferGeometry>} geometries - The geometries to merge.\n * @param {boolean} [useGroups=false] - Whether to use groups or not.\n * @return {?BufferGeometry} The merged geometry. Returns `null` if the merge does not succeed.\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * Merges a set of attributes into a single instance. All attributes must have compatible properties and types.\n * Instances of {@link InterleavedBufferAttribute} are not supported.\n *\n * @param {Array<BufferAttribute>} attributes - The attributes to merge.\n * @return {?BufferAttribute} The merged attribute. Returns `null` if the merge does not succeed.\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.count * itemSize;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst tupleOffset = offset / itemSize;\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tarray.set( attribute.array, offset );\n\n\t\t}\n\n\t\toffset += attribute.count * itemSize;\n\n\t}\n\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * Performs a deep clone of the given buffer attribute.\n *\n * @param {BufferAttribute} attribute - The attribute to clone.\n * @return {BufferAttribute} The cloned attribute.\n */\nfunction deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * Interleaves a set of attributes and returns a new array of corresponding attributes that share a\n * single {@link InterleavedBuffer} instance. All attributes must have compatible types.\n *\n * @param {Array<BufferAttribute>} attributes - The attributes to interleave.\n * @return {?Array<InterleavedBufferAttribute>} An array of interleaved attributes. If interleave does not succeed, the method returns `null`.\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n/**\n * Returns a new, non-interleaved version of the given attribute.\n *\n * @param {InterleavedBufferAttribute} attribute - The interleaved attribute.\n * @return {BufferAttribute} The non-interleaved attribute.\n */\nfunction deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n/**\n * Deinterleaves all attributes on the given geometry.\n *\n * @param {BufferGeometry} geometry - The geometry to deinterleave.\n */\nfunction deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Returns the amount of bytes used by all attributes to represent the geometry.\n *\n * @param {BufferGeometry} geometry - The geometry.\n * @return {number} The estimate bytes used.\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * Returns a new geometry with vertices for which all similar vertex attributes (within tolerance) are merged.\n *\n * @param {BufferGeometry} geometry - The geometry to merge vertices for.\n * @param {number} [tolerance=1e-4] - The tolerance value.\n * @return {BufferGeometry} - The new geometry with merged vertices.\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new attr.constructor(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\tif ( morphAttributes ) {\n\n\t\t\tif ( ! tmpMorphAttributes[ name ] ) tmpMorphAttributes[ name ] = [];\n\t\t\tmorphAttributes.forEach( ( morphAttr, i ) => {\n\n\t\t\t\tconst array = new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize );\n\t\t\t\ttmpMorphAttributes[ name ][ i ] = new morphAttr.constructor( array, morphAttr.itemSize, morphAttr.normalized );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newArray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewArray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttributes ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttributes.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttributes[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new tmpAttribute.constructor(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new tmpMorphAttribute.constructor(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * Returns a new indexed geometry based on `TrianglesDrawMode` draw mode.\n * This mode corresponds to the `gl.TRIANGLES` primitive in WebGL.\n *\n * @param {BufferGeometry} geometry - The geometry to convert.\n * @param {number} drawMode - The current draw mode.\n * @return {BufferGeometry} The new geometry using `TrianglesDrawMode`.\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n *\n * Helpful for Raytracing or Decals (i.e. a `DecalGeometry` applied to a morphed Object with a `BufferGeometry`\n * will use the original `BufferGeometry`, not the morphed/skinned one, generating an incorrect result.\n * Using this function to create a shadow `Object3`D the `DecalGeometry` can be correctly generated).\n *\n * @param {Mesh|Line|Points} object - The 3D object to compute morph attributes for.\n * @return {Object} An object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\n/**\n * Merges the {@link BufferGeometry#groups} for the given geometry.\n *\n * @param {BufferGeometry} geometry - The geometry to modify.\n * @return {BufferGeometry} - The updated geometry\n */\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry - The geometry to modify.\n * @param {number} [creaseAngle=Math.PI/3] - The crease angle in radians.\n * @return {BufferGeometry} - The updated geometry\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeAttributes,\n\tdeepCloneAttribute,\n\tdeinterleaveAttribute,\n\tdeinterleaveGeometry,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}