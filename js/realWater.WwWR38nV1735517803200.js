import{m as n,e,b as t,U as r,c as o}from"./@tresjs.0qL_P2CE1735517803200.js";import{P as i}from"./tweakpane.yHWGBmom1735517803200.js";import{B as c,_ as a,aA as l,O as s,C as u,s as f,t as p}from"./three.-uH5I3Xp1735517803200.js";import{d as v,a6 as g,b as d,o as x,f as h,u as m,g as y,j as w,al as b,r as I,J as C,aj as R,ak as _}from"./@vue.-THQH3GC1735517803200.js";import"./@vueuse.oT9wchAS1735517803200.js";var z="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";function M(n,e){const t=D();return(M=function(n,e){return t[n-=405]})(n,e)}!function(n,e){const t=M,r=D();for(;;)try{if(541e3===parseInt(t(407))/1+parseInt(t(424))/2*(-parseInt(t(439))/3)+parseInt(t(449))/4+-parseInt(t(423))/5+-parseInt(t(415))/6*(parseInt(t(421))/7)+parseInt(t(420))/8*(-parseInt(t(440))/9)+-parseInt(t(429))/10*(-parseInt(t(435))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[M(414)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function D(){const n=["constructor","string","debu","__proto__","call","length","error","setIndex","181600FfkRcH","test","input","uniforms","921299RqBpTT","value","toString","counter","init","render","causticTex","apply","6429234FsWLTD","BufferAttribute","setAttribute","RawShaderMaterial","return (function() ","2059888estOLz","7IboIFz","waterTexture","2904790ycXQrO","12JKdcIv","causticsTexture","FrontSide","trace","prototype","18781180YdkdFM","water","gger","info","console","Mesh","11XwlfPS","tiles","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)",'{}.constructor("return this")( )',"196917dxmMLU","9HXADTQ"];return(D=function(){return n})()}!function(){T(this,(function(){const n=M,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(437),"i"),r=F(n(411));e[n(450)](r+"chain")&&t.test(r+n(405))?F():r("0")}))()}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();L(void 0,(function(){const n=M,e=function(){const n=M;let e;try{e=Function(n(419)+n(438)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(433)]||{},r=["log","warn",n(432),n(447),"exception","table",n(427)];for(let o=0;o<r[n(446)];o++){const e=L.constructor[n(428)].bind(L),i=r[o],c=t[i]||e;e[n(444)]=L.bind(L),e[n(409)]=c[n(409)].bind(c),t[i]=e}}))();const A=v({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=M,o=t,i=new c,l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(417)]("position",new(a[r(416)])(l,3)),i[r(448)](new(a[r(416)])(s,1));const u=new(a[r(418)])({uniforms:{light:{value:o.light},tiles:{value:o[r(436)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:a[r(426)]}),f=new(a[r(434)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{const n=r;((n,e)=>{const t=r;u[t(406)][t(430)].value=n,u[t(406)][t(413)][t(408)]=e,p[t(408)][t(412)](f,v[t(408)])})(o[n(422)],o[n(425)])})),(n,e)=>null}});function F(n){function e(n){const t=M;if(typeof n===t(442))return function(n){}[t(441)]("while (true) {}")[t(414)](t(410));1!==(""+n/n)[t(446)]||n%20==0?function(){return!0}.constructor(t(443)+t(431))[t(445)]("action"):function(){return!1}.constructor("debu"+t(431))[t(414)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const O=j;!function(n,e){const t=j,r=W();for(;;)try{if(794371===-parseInt(t(244))/1*(parseInt(t(225))/2)+-parseInt(t(243))/3+parseInt(t(258))/4*(-parseInt(t(236))/5)+-parseInt(t(230))/6+parseInt(t(257))/7*(-parseInt(t(218))/8)+-parseInt(t(264))/9+parseInt(t(251))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[j(262)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){S(this,(function(){const n=j,e=new RegExp(n(210)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=V("init");e[n(261)](r+"chain")&&t[n(261)](r+n(228))?V():r("0")}))()}();const E=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[j(262)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function j(n,e){const t=W();return(j=function(n,e){return t[n-=209]})(n,e)}function W(){const n=["pos-x.jpg","underwater","BackSide","__proto__","causticTex","trace","table","5536zcSpdx","info","light","Color","neg-y.jpg","pos-y.jpg","neg-z.jpg","2svxuHQ","warn","FrontSide","input","waterTexture","2511822wkbYIP","water","debu","Mesh","prototype","gger","6507965JAkQgl","pos-z.jpg",'{}.constructor("return this")( )',"render","constructor","console","setClearColor","3023007lFvfql","1412321aWmvlF","geometry","while (true) {}","return (function() ","pooRef","bind","side","61917770gxTOFx","action","uniforms","exception","CubeTextureLoader","length","2716iixtKC","4fBlkSl","value","causticsTexture","test","apply","neg-x.jpg","8898210AqwNlH","tiles","setPath","setRenderTarget","function *\\( *\\)"];return(W=function(){return n})()}E(void 0,(function(){const n=j;let e;try{e=Function(n(247)+n(238)+");")()}catch(o){e=window}const t=e[n(241)]=e[n(241)]||{},r=["log",n(226),n(219),"error",n(254),n(217),n(216)];for(let i=0;i<r.length;i++){const e=E[n(240)][n(234)][n(249)](E),o=r[i],c=t[o]||e;e[n(214)]=E[n(249)](E),e.toString=c.toString[n(249)](c),t[o]=e}}))();const P=v({__name:O(231),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=O;let i,c;const s=r,u=s[o(245)],f=(new(a[o(255)]))[o(266)]("https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/").load([o(211),o(263),o(223),o(222),o(237),o(224)]),p=([i,c]=g((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,c(),i),v=new l({uniforms:{light:{value:s[o(220)]},tiles:{value:p},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new(a[o(233)])(u,v),w=d(null),b=new(a[o(221)])("white"),{renderer:I,camera:C}=n(),{onLoop:R}=e();return R((()=>{const n=o;I[n(259)][n(209)](null),I.value[n(242)](b,1),I[n(259)].clear(),v[n(253)][n(231)].value=s[n(229)],v[n(253)][n(215)].value=s[n(260)],v[n(250)]=a[n(227)],v.uniforms[n(212)].value=!0,I.value.render(y,C[n(259)]),v.side=a[n(213)],v.uniforms[n(212)][n(259)]=!1,I[n(259)][n(239)](y,C.value)})),(n,e)=>{const t=o;return x(),h(A,{tiles:m(p),light:n[t(220)],waterTexture:n[t(229)],causticsTexture:n[t(260)],ref_key:t(248),ref:w},null,8,[t(265),t(220),"waterTexture",t(260)])}}});function V(n){function e(n){const t=j;if("string"==typeof n)return function(n){}[t(240)](t(246))[t(262)]("counter");1!==(""+n/n)[t(256)]||n%20==0?function(){return!0}[t(240)](t(232)+t(235)).call(t(252)):function(){return!1}[t(240)](t(232)+t(235))[t(262)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=N,r=Z();for(;;)try{if(151940===parseInt(t(412))/1*(parseInt(t(394))/2)+parseInt(t(419))/3+-parseInt(t(405))/4*(-parseInt(t(409))/5)+-parseInt(t(434))/6+parseInt(t(430))/7+-parseInt(t(397))/8*(-parseInt(t(437))/9)+-parseInt(t(404))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const k=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){k(this,(function(){const n=N,e=new RegExp(n(420)),t=new RegExp(n(415),"i"),r=B("init");e[n(425)](r+n(418))&&t[n(425)](r+"input")?B():r("0")}))()}();const H=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function N(n,e){const t=Z();return(N=function(n,e){return t[n-=394]})(n,e)}function Z(){const n=["debu","value","26469LGNocv","render","water","error","141224EJItDb","waterTexture","gger","328kPDorT","length","clear","PlaneGeometry","counter","warn","exception","2695840xHWuAf","877940PdGWCb","info","constructor","ShaderMaterial","5NVeQrj","string","toString","2pANVRG","__proto__","bind","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","light","prototype","chain","125673qHdRSG","function *\\( *\\)","call","causticsTexture",'{}.constructor("return this")( )',"setRenderTarget","test","log","Mesh","console","WebGLRenderTarget","961443SqGjZn","return (function() ","apply","texture","1434036MINKnK"];return(Z=function(){return n})()}H(void 0,(function(){const n=N,e=function(){const n=N;let e;try{e=Function(n(431)+n(423)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(428)]||{},r=[n(426),n(402),n(406),n(440),n(403),"table","trace"];for(let o=0;o<r[n(398)];o++){const e=H[n(407)][n(417)].bind(H),i=r[o],c=t[i]||e;e[n(413)]=H[n(414)](H),e[n(411)]=c[n(411)][n(414)](c),t[i]=e}}))();const G=v({__name:"caustics",props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=N,o=t,i=new s(0,1,1,0,0,2e3),c=new(a[r(400)])(2,2,200,200),l=new(a[r(429)])(1024,1024),f=new(a[r(408)])({uniforms:{light:{value:o[r(416)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new(a[r(427)])(c,f),v=new u("black"),{renderer:g}=n(),{onBeforeLoop:d}=e();return d((()=>{const n=r;p.material.uniforms[n(439)][n(436)]=o.waterTexture,g[n(436)][n(424)](l),g.value.setClearColor(v,0),g.value[n(399)](),g[n(436)][n(438)](p,i)})),(n,e)=>{const t=r;return x(),h(b,null,{default:y((()=>[w(P,{waterTexture:n[t(395)],causticsTexture:m(l)[t(433)],light:n.light,geometry:m(c)},null,8,[t(395),t(422),"light","geometry"])])),_:1})}}});function B(n){function e(n){const t=N;if(typeof n===t(410))return function(n){}[t(407)]("while (true) {}")[t(432)](t(401));1!==(""+n/n)[t(398)]||n%20==0?function(){return!0}[t(407)]("debu"+t(396))[t(421)]("action"):function(){return!1}.constructor(t(435)+"gger")[t(432)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const q=X;!function(n,e){const t=X,r=U();for(;;)try{if(809968===parseInt(t(319))/1+-parseInt(t(314))/2*(parseInt(t(353))/3)+parseInt(t(334))/4+-parseInt(t(329))/5*(-parseInt(t(350))/6)+-parseInt(t(339))/7+-parseInt(t(303))/8*(parseInt(t(306))/9)+parseInt(t(309))/10*(parseInt(t(356))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const $=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[X(295)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){$(this,(function(){const n=X,e=new RegExp(n(331)),t=new RegExp(n(344),"i"),r=Y("init");e[n(348)](r+n(312))&&t[n(348)](r+n(325))?Y():r("0")}))()}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[X(295)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function U(){const n=["clientX","WebGLRenderTarget","input","radius","return (function() ","length","17805ECuwok","point","function *\\( *\\)","PlaneGeometry","top","795132TJesVs","error","Mesh","prototype","RawShaderMaterial","9349592LucXCu","log","waterTexture","lightFrontGeometry","string","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","render","getY",'{}.constructor("return this")( )',"test","constructor","858DZMPls","domElement","exception","42SUCPhh","console","OrthographicCamera","385ZLKLHu","stateObject","needsUpdate","__proto__","while (true) {}","FloatType","table","apply","height","texture","call","attributes","debu","Vector2","intersectObject","16lxmlZz","warn","material","6048549xdEVAC","addEventListener","uniforms","1009150fvIvmn","waterSimulation","setRenderTarget","chain","mousemove","227182zIVUWJ","bind","removeEventListener","value","light","839989cTVxlH","left","clientY","info"];return(U=function(){return n})()}K(void 0,(function(){const n=X;let e;try{e=Function(n(327)+n(347)+");")()}catch(o){e=window}const t=e[n(354)]=e.console||{},r=[n(340),n(304),n(322),n(335),n(352),n(294),"trace"];for(let i=0;i<r[n(328)];i++){const e=K.constructor[n(337)][n(315)](K),o=r[i],c=t[o]||e;e[n(291)]=K[n(315)](K),e.toString=c.toString[n(315)](c),t[o]=e}}))();const J=v({__name:q(310),props:{light:{}},setup(t,{expose:r}){const o=q,i=new(a[o(355)])(0,1,1,0,0,2e3),c=new(a[o(332)])(2,2),l=new(a[o(324)])(256,256,{type:a[o(293)]}),s=new(a[o(324)])(256,256,{type:a[o(293)]}),u=new(a[o(338)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),v=new(a[o(338)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),g=new(a[o(338)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),d=new(a[o(336)])(c,u),y=new f(c,v),w=new(a[o(336)])(c,g);let b=l;const I=(n,e)=>{const t=o,r=b,c=b===l?s:l;e[t(305)][t(308)][t(297)][t(317)]=r[t(297)],n[t(311)](c),n[t(345)](e,i),b=c},{renderer:C,camera:R,raycaster:_}=n();C[o(317)].autoClear=!1;const{onBeforeLoop:M}=e();M((()=>{const n=o;var e,t;t=C.value,I(t,w),e=C[n(317)],I(e,y)}));const T=(n,e,t,r)=>{const i=o;d[i(305)].uniforms.center[i(317)]=[n,e],d[i(305)][i(308)][i(326)][i(317)]=t,d[i(305)][i(308)].strength.value=r,I(C[i(317)],d)},D=new(a[o(301)]),L=new p(2,2),A=L[o(299)].position;for(let n=0;n<A.count;n++){const e=-A[o(346)](n);A.setY(n,0),A.setZ(n,e)}A[o(290)]=!0;const F=new(a[o(336)])(L),O={handleEvent:n=>{const e=o,t=C[e(317)].domElement.getBoundingClientRect(),r=t.width,i=t[e(296)];D.x=2*(n[e(323)]-t[e(320)])/r-1,D.y=2*-(n[e(321)]-t[e(333)])/i+1,_.value.setFromCamera(D,R.value);const c=_.value[e(302)](F);for(let o of c)T(o[e(330)].x,o.point.z,.03,.04)}};return r({addDrop:T,mouseEvent:n=>{const e=o;n?C[e(317)][e(351)][e(307)](e(313),O):C[e(317)][e(351)][e(316)](e(313),O)}}),(n,e)=>{const t=o;return x(),h(G,{lightFrontGeometry:m(c),waterTexture:m(b).texture,light:n[t(318)]},null,8,[t(342),t(341),t(318)])}}});function X(n,e){const t=U();return(X=function(n,e){return t[n-=289]})(n,e)}function Y(n){function e(n){const t=X;if(typeof n===t(343))return function(n){}[t(349)](t(292))[t(295)]("counter");1!==(""+n/n)[t(328)]||n%20==0?function(){return!0}[t(349)](t(300)+"gger")[t(298)]("action"):function(){return!1}[t(349)](t(300)+"gger")[t(295)](t(289)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const Q=tn;!function(n,e){const t=tn,r=rn();for(;;)try{if(839002===-parseInt(t(190))/1*(-parseInt(t(213))/2)+parseInt(t(219))/3*(parseInt(t(197))/4)+-parseInt(t(193))/5*(parseInt(t(179))/6)+-parseInt(t(195))/7+-parseInt(t(173))/8+-parseInt(t(182))/9*(parseInt(t(206))/10)+parseInt(t(204))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){nn(this,(function(){const n=tn,e=new RegExp(n(205)),t=new RegExp(n(180),"i"),r=cn(n(177));e[n(198)](r+n(214))&&t[n(198)](r+n(199))?cn():r("0")}))()}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(215)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function tn(n,e){const t=rn();return(tn=function(n,e){return t[n-=173]})(n,e)}function rn(){const n=["function *\\( *\\)","1130IzsVvm","exception","click","mouseEvent","while (true) {}","waterSimulationRef","addButton","1116evTLzj","chain","apply","manual","log","random","177789vmXGPK","debu","warn","8071648vzWrfT","TresPerspectiveCamera","鼠标波纹","console","init","addDrop","50634FYRsVg","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","gger","20529MUNqjn","value","info","addBinding","length","action",'{}.constructor("return this")( )',"toString","2547KufVEf","prototype","call","410lkEnOr","error","6282458iWfgHC","constructor","92roRlyb","test","input","点击按钮","realWater","bind","stateObject","10020208uGwhfp"];return(rn=function(){return n})()}en(void 0,(function(){const n=tn,e=function(){const n=tn;let e;try{e=Function("return (function() "+n(188)+");")()}catch(t){e=window}return e}(),t=e[n(176)]=e[n(176)]||{},r=[n(217),n(221),n(184),n(194),n(207),"table","trace"];for(let o=0;o<r[n(186)];o++){const e=en[n(196)][n(191)][n(202)](en),i=r[o],c=t[i]||e;e.__proto__=en[n(202)](en),e[n(189)]=c.toString.bind(c),t[i]=e}}))();const on=v({__name:Q(201),setup(n){const e=Q,t=I({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(216)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=d(null),l=new i;l[e(212)]({label:e(200),title:"随机增加波纹"}).on(e(208),(()=>{const n=e;for(var t=0;t<10;t++)a[n(183)][n(178)](2*Math[n(218)]()-1,2*Math[n(218)]()-1,.03,1&t?.02:-.02)}));const s=d(!1);return l[e(185)](s,e(183),{label:e(175)}).on("change",(n=>{const t=e;a[t(183)][t(209)](n[t(183)])})),(n,i)=>{const l=e;return x(),h(m(o),R(_(t)),{default:y((()=>[i[0]||(i[0]=C(l(174),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),w(m(r)),w(J,{light:c,ref_key:l(211),ref:a},null,512)])),_:1},16)}}});function cn(n){function e(n){const t=tn;if("string"==typeof n)return function(n){}[t(196)](t(210))[t(215)]("counter");1!==(""+n/n).length||n%20==0?function(){return!0}[t(196)](t(220)+t(181))[t(192)](t(187)):function(){return!1}.constructor("debugger")[t(215)](t(203)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{on as default};
