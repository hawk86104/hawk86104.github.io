import{i as e}from"./3d-tiles-renderer.CbgZh8zU1767066396612.js";import{n as a,_ as t,s as o}from"./@tresjs.B1f7s3pS1767066396612.js";const{defineComponent:l}=await e("vue"),{unref:n,createElementVNode:r,openBlock:s,createElementBlock:u}=await e("vue"),i=["size","color","alpha-map","map","opacity","alpha-test","depth-write","transparent","size-attenuation"],p=["position","velocity"],{shallowRef:d,toRefs:c,watch:f,watchEffect:v}=await e("vue"),m=l({__name:"index",props:{size:{default:.1},area:{default:()=>[10,10,20]},color:{default:16777215},map:{},alphaMap:{},alphaTest:{default:.01},opacity:{default:.8},count:{default:5e3},speed:{default:.1},randomness:{default:.5},depthWrite:{type:Boolean,default:!1},transparent:{type:Boolean,default:!0},sizeAttenuation:{type:Boolean,default:!0}},setup(e,{expose:o}){const l=e,{size:m,area:y,color:h,alphaMap:w,map:z,opacity:B,alphaTest:_,depthWrite:M,transparent:g,sizeAttenuation:k,count:T,speed:b,randomness:R}=c(l),x=d();let A=[],C=[];const E=()=>{A=new Float32Array(3*T.value);for(let e=0;e<T.value;e++){const a=3*e;A[a]=(Math.random()-.5)*y.value[0],A[a+1]=(Math.random()-.5)*y.value[1],A[a+2]=(Math.random()-.5)*y.value[2]}},Y=()=>{C=new Float32Array(2*T.value);for(let e=0;e<2*T.value;e+=2)C[e]=(Math.random()-.5)/5*b.value*R.value,C[e+1]=Math.random()/5*b.value};Y(),E(),f(b,()=>{Y()}),v(()=>{b.value||E()}),f(()=>l.area,()=>{E()});const j=d(null),W=d(null);v(async()=>{if("string"==typeof w.value){const{state:e}=a(w.value);j.value=e.value}else j.value=w.value??null;if("string"==typeof z.value){const{state:e}=a(z.value);W.value=e.value}else W.value=z.value??null});const{onBeforeRender:X}=t();X(()=>{if(x.value?.attributes.position.array&&x.value?.attributes.position.count){const e=x.value.attributes.position.array;for(let a=0;a<x.value.attributes.position.count;a++){const t=C[2*a],o=C[2*a+1];e[3*a]+=t,e[3*a+1]-=o,(e[3*a]<=-y.value[0]/2||e[3*a]>=y.value[0]/2)&&(e[3*a]=-1*e[3*a]),(e[3*a+1]<=-y.value[1]/2||e[3*a+1]>=y.value[1]/2)&&(e[3*a+1]=-1*e[3*a+1])}x.value.attributes.position.needsUpdate=!0}});const Z=d();return o({instance:Z}),(e,a)=>(s(),u("TresPoints",{ref_key:"pointsRef",ref:Z},[r("TresPointsMaterial",{size:n(m),color:n(h),"alpha-map":j.value,map:W.value,opacity:n(B),"alpha-test":n(_),"depth-write":n(M),transparent:n(g),"size-attenuation":n(k)},null,8,i),r("TresBufferGeometry",{ref_key:"geometryRef",ref:x,position:[n(A),3],velocity:[n(C)]},null,8,p)],512))}}),{defineComponent:y}=await e("vue"),{createVNode:h,unref:w,withCtx:z,openBlock:B,createElementBlock:_}=await e("vue"),{ref:M,watch:g}=await e("vue"),k=y({__name:"particleBase",props:{speed:{default:.1},randomness:{default:1},count:{default:100},size:{default:.1},areaX:{default:5},areaY:{default:2},areaZ:{default:5},color:{default:"#fff"},opacity:{default:1}},setup(e){const a=e,t=M([a.areaX,a.areaY,a.areaZ]);return g(()=>[a.areaX,a.areaY,a.areaZ],([e,a,o])=>{t.value=[e,a,o]}),(e,a)=>(B(),_("TresGroup",null,[h(w(o),{path:"./plugins/digitalCity/image/cilcle.png"},{default:z(({state:a})=>[h(m,{renderOrder:2001,position:[0,e.areaY/2,0],speed:e.speed,color:e.color,area:t.value,count:e.count,depthWrite:!1,randomness:e.randomness,size:e.size,transparent:"",opacity:e.opacity,map:a},null,8,["position","speed","color","area","count","randomness","size","opacity","map"])]),_:1})]))}});export{k as _};
