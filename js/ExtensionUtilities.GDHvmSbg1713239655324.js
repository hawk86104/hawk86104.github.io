var Yn=Object.defineProperty,Wn=Object.defineProperties;var Kn=Object.getOwnPropertyDescriptors;var wn=Object.getOwnPropertySymbols;var Jn=Object.prototype.hasOwnProperty,Qn=Object.prototype.propertyIsEnumerable;var An=(s,n,t)=>n in s?Yn(s,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[n]=t,mt=(s,n)=>{for(var t in n||(n={}))Jn.call(n,t)&&An(s,t,n[t]);if(wn)for(var t of wn(n))Qn.call(n,t)&&An(s,t,n[t]);return s},Zt=(s,n)=>Wn(s,Kn(n));import{av as Nn,b3 as L,aH as yt,b2 as qn,bm as W,bn as gt,bo as Gn,be as tt,bp as Z,bq as On,ap as ts,br as Tn,aw as ns,bs as ss}from"./vendor.DUm4xHeP1713239655324.js";const $n=0,es=1,is=2,Pn=2,Yt=1.25,bn=1,Mt=6*4+4+4,Xt=65535,rs=Math.pow(2,-24),Wt=Symbol("SKIP_GENERATION");function os(s){return s.index?s.index.count:s.attributes.position.count}function dt(s){return os(s)/3}function cs(s,n=ArrayBuffer){return s>65535?new Uint32Array(new n(4*s)):new Uint16Array(new n(2*s))}function as(s,n){if(!s.index){const t=s.attributes.position.count,e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=cs(t,e);s.setIndex(new Nn(i,1));for(let a=0;a<t;a++)i[a]=a}}function kn(s){const n=dt(s),t=s.drawRange,e=t.start/3,i=(t.start+t.count)/3,a=Math.max(0,e),r=Math.min(n,i)-a;return[{offset:Math.floor(a),count:Math.floor(r)}]}function Hn(s){if(!s.groups||!s.groups.length)return kn(s);const n=[],t=new Set,e=s.drawRange,i=e.start/3,a=(e.start+e.count)/3;for(const o of s.groups){const c=o.start/3,u=(o.start+o.count)/3;t.add(Math.max(i,c)),t.add(Math.min(a,u))}const r=Array.from(t.values()).sort((o,c)=>o-c);for(let o=0;o<r.length-1;o++){const c=r[o],u=r[o+1];n.push({offset:Math.floor(c),count:Math.floor(u-c)})}return n}function ls(s){if(s.groups.length===0)return!1;const n=dt(s),t=Hn(s).sort((a,r)=>a.offset-r.offset),e=t[t.length-1];e.count=Math.min(n-e.offset,e.count);let i=0;return t.forEach(({count:a})=>i+=a),n!==i}function Kt(s,n,t,e,i){let a=1/0,r=1/0,o=1/0,c=-1/0,u=-1/0,f=-1/0,p=1/0,l=1/0,y=1/0,m=-1/0,B=-1/0,w=-1/0;for(let d=n*6,x=(n+t)*6;d<x;d+=6){const h=s[d+0],P=s[d+1],A=h-P,b=h+P;A<a&&(a=A),b>c&&(c=b),h<p&&(p=h),h>m&&(m=h);const T=s[d+2],_=s[d+3],g=T-_,S=T+_;g<r&&(r=g),S>u&&(u=S),T<l&&(l=T),T>B&&(B=T);const C=s[d+4],M=s[d+5],U=C-M,F=C+M;U<o&&(o=U),F>f&&(f=F),C<y&&(y=C),C>w&&(w=C)}e[0]=a,e[1]=r,e[2]=o,e[3]=c,e[4]=u,e[5]=f,i[0]=p,i[1]=l,i[2]=y,i[3]=m,i[4]=B,i[5]=w}function fs(s,n=null,t=null,e=null){const i=s.attributes.position,a=s.index?s.index.array:null,r=dt(s),o=i.normalized;let c;n===null?(c=new Float32Array(r*6*4),t=0,e=r):(c=n,t=t||0,e=e||r);const u=i.array,f=i.offset||0;let p=3;i.isInterleavedBufferAttribute&&(p=i.data.stride);const l=["getX","getY","getZ"];for(let y=t;y<t+e;y++){const m=y*3,B=y*6;let w=m+0,d=m+1,x=m+2;a&&(w=a[w],d=a[d],x=a[x]),o||(w=w*p+f,d=d*p+f,x=x*p+f);for(let h=0;h<3;h++){let P,A,b;o?(P=i[l[h]](w),A=i[l[h]](d),b=i[l[h]](x)):(P=u[w+h],A=u[d+h],b=u[x+h]);let T=P;A<T&&(T=A),b<T&&(T=b);let _=P;A>_&&(_=A),b>_&&(_=b);const g=(_-T)/2,S=h*2;c[B+S+0]=T+g,c[B+S+1]=g+(Math.abs(T)+g)*rs}}return c}function E(s,n,t){return t.min.x=n[s],t.min.y=n[s+1],t.min.z=n[s+2],t.max.x=n[s+3],t.max.y=n[s+4],t.max.z=n[s+5],t}function Bn(s){let n=-1,t=-1/0;for(let e=0;e<3;e++){const i=s[e+3]-s[e];i>t&&(t=i,n=e)}return n}function gn(s,n){n.set(s)}function _n(s,n,t){let e,i;for(let a=0;a<3;a++){const r=a+3;e=s[a],i=n[a],t[a]=e<i?e:i,e=s[r],i=n[r],t[r]=e>i?e:i}}function Ct(s,n,t){for(let e=0;e<3;e++){const i=n[s+2*e],a=n[s+2*e+1],r=i-a,o=i+a;r<t[e]&&(t[e]=r),o>t[e+3]&&(t[e+3]=o)}}function wt(s){const n=s[3]-s[0],t=s[4]-s[1],e=s[5]-s[2];return 2*(n*t+t*e+e*n)}const Y=32,us=(s,n)=>s.candidate-n.candidate,Q=new Array(Y).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ut=new Float32Array(6);function ps(s,n,t,e,i,a){let r=-1,o=0;if(a===$n)r=Bn(n),r!==-1&&(o=(n[r]+n[r+3])/2);else if(a===es)r=Bn(s),r!==-1&&(o=ys(t,e,i,r));else if(a===is){const c=wt(s);let u=Yt*i;const f=e*6,p=(e+i)*6;for(let l=0;l<3;l++){const y=n[l],w=(n[l+3]-y)/Y;if(i<Y/4){const d=[...Q];d.length=i;let x=0;for(let P=f;P<p;P+=6,x++){const A=d[x];A.candidate=t[P+2*l],A.count=0;const{bounds:b,leftCacheBounds:T,rightCacheBounds:_}=A;for(let g=0;g<3;g++)_[g]=1/0,_[g+3]=-1/0,T[g]=1/0,T[g+3]=-1/0,b[g]=1/0,b[g+3]=-1/0;Ct(P,t,b)}d.sort(us);let h=i;for(let P=0;P<h;P++){const A=d[P];for(;P+1<h&&d[P+1].candidate===A.candidate;)d.splice(P+1,1),h--}for(let P=f;P<p;P+=6){const A=t[P+2*l];for(let b=0;b<h;b++){const T=d[b];A>=T.candidate?Ct(P,t,T.rightCacheBounds):(Ct(P,t,T.leftCacheBounds),T.count++)}}for(let P=0;P<h;P++){const A=d[P],b=A.count,T=i-A.count,_=A.leftCacheBounds,g=A.rightCacheBounds;let S=0;b!==0&&(S=wt(_)/c);let C=0;T!==0&&(C=wt(g)/c);const M=bn+Yt*(S*b+C*T);M<u&&(r=l,u=M,o=A.candidate)}}else{for(let h=0;h<Y;h++){const P=Q[h];P.count=0,P.candidate=y+w+h*w;const A=P.bounds;for(let b=0;b<3;b++)A[b]=1/0,A[b+3]=-1/0}for(let h=f;h<p;h+=6){let b=~~((t[h+2*l]-y)/w);b>=Y&&(b=Y-1);const T=Q[b];T.count++,Ct(h,t,T.bounds)}const d=Q[Y-1];gn(d.bounds,d.rightCacheBounds);for(let h=Y-2;h>=0;h--){const P=Q[h],A=Q[h+1];_n(P.bounds,A.rightCacheBounds,P.rightCacheBounds)}let x=0;for(let h=0;h<Y-1;h++){const P=Q[h],A=P.count,b=P.bounds,_=Q[h+1].rightCacheBounds;A!==0&&(x===0?gn(b,Ut):_n(b,Ut,Ut)),x+=A;let g=0,S=0;x!==0&&(g=wt(Ut)/c);const C=i-x;C!==0&&(S=wt(_)/c);const M=bn+Yt*(g*x+S*C);M<u&&(r=l,u=M,o=P.candidate)}}}}else console.warn("MeshBVH: Invalid build strategy value ".concat(a," used."));return{axis:r,pos:o}}function ys(s,n,t,e){let i=0;for(let a=n,r=n+t;a<r;a++)i+=s[a*6+e*2];return i/t}class Jt{constructor(){this.boundingData=new Float32Array(6)}}function ds(s,n,t,e,i,a){let r=e,o=e+i-1;const c=a.pos,u=a.axis*2;for(;;){for(;r<=o&&t[r*6+u]<c;)r++;for(;r<=o&&t[o*6+u]>=c;)o--;if(r<o){for(let f=0;f<3;f++){let p=n[r*3+f];n[r*3+f]=n[o*3+f],n[o*3+f]=p}for(let f=0;f<6;f++){let p=t[r*6+f];t[r*6+f]=t[o*6+f],t[o*6+f]=p}r++,o--}else return r}}function xs(s,n,t,e,i,a){let r=e,o=e+i-1;const c=a.pos,u=a.axis*2;for(;;){for(;r<=o&&t[r*6+u]<c;)r++;for(;r<=o&&t[o*6+u]>=c;)o--;if(r<o){let f=s[r];s[r]=s[o],s[o]=f;for(let p=0;p<6;p++){let l=t[r*6+p];t[r*6+p]=t[o*6+p],t[o*6+p]=l}r++,o--}else return r}}function I(s,n){return n[s+15]===65535}function N(s,n){return n[s+6]}function q(s,n){return n[s+14]}function $(s){return s+8}function k(s,n){return n[s+6]}function Xn(s,n){return n[s+7]}let jn,_t,kt,Zn;const hs=Math.pow(2,32);function on(s){return"count"in s?1:1+on(s.left)+on(s.right)}function ms(s,n,t){return jn=new Float32Array(t),_t=new Uint32Array(t),kt=new Uint16Array(t),Zn=new Uint8Array(t),cn(s,n)}function cn(s,n){const t=s/4,e=s/2,i="count"in n,a=n.boundingData;for(let r=0;r<6;r++)jn[t+r]=a[r];if(i)if(n.buffer){const r=n.buffer;Zn.set(new Uint8Array(r),s);for(let o=s,c=s+r.byteLength;o<c;o+=Mt){const u=o/2;I(u,kt)||(_t[o/4+6]+=t)}return s+r.byteLength}else{const r=n.offset,o=n.count;return _t[t+6]=r,kt[e+14]=o,kt[e+15]=Xt,s+Mt}else{const r=n.left,o=n.right,c=n.splitAxis;let u;if(u=cn(s+Mt,r),u/4>hs)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return _t[t+6]=u/4,u=cn(u,o),_t[t+7]=c,u}}function ws(s,n){const t=(s.index?s.index.count:s.attributes.position.count)/3,e=t>2**16,i=e?4:2,a=n?new SharedArrayBuffer(t*i):new ArrayBuffer(t*i),r=e?new Uint32Array(a):new Uint16Array(a);for(let o=0,c=r.length;o<c;o++)r[o]=o;return r}function As(s,n,t,e,i){const{maxDepth:a,verbose:r,maxLeafTris:o,strategy:c,onProgress:u,indirect:f}=i,p=s._indirectBuffer,l=s.geometry,y=l.index?l.index.array:null,m=f?xs:ds,B=dt(l),w=new Float32Array(6);let d=!1;const x=new Jt;return Kt(n,t,e,x.boundingData,w),P(x,t,e,w),x;function h(A){u&&u(A/B)}function P(A,b,T,_=null,g=0){if(!d&&g>=a&&(d=!0,r&&(console.warn("MeshBVH: Max depth of ".concat(a," reached when generating BVH. Consider increasing maxDepth.")),console.warn(l))),T<=o||g>=a)return h(b+T),A.offset=b,A.count=T,A;const S=ps(A.boundingData,_,n,b,T,c);if(S.axis===-1)return h(b+T),A.offset=b,A.count=T,A;const C=m(p,y,n,b,T,S);if(C===b||C===b+T)h(b+T),A.offset=b,A.count=T;else{A.splitAxis=S.axis;const M=new Jt,U=b,F=C-b;A.left=M,Kt(n,U,F,M.boundingData,w),P(M,U,F,w,g+1);const v=new Jt,R=C,J=T-F;A.right=v,Kt(n,R,J,v.boundingData,w),P(v,R,J,w,g+1)}return A}}function Ts(s,n){const t=s.geometry;n.indirect&&(s._indirectBuffer=ws(t,n.useSharedArrayBuffer),ls(t)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),s._indirectBuffer||as(t,n);const e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=fs(t),a=n.indirect?kn(t):Hn(t);s._roots=a.map(r=>{const o=As(s,i,r.offset,r.count,n),c=on(o),u=new e(Mt*c);return ms(0,o,u),u})}class K{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(n,t){let e=1/0,i=-1/0;for(let a=0,r=n.length;a<r;a++){const c=n[a][t];e=c<e?c:e,i=c>i?c:i}this.min=e,this.max=i}setFromPoints(n,t){let e=1/0,i=-1/0;for(let a=0,r=t.length;a<r;a++){const o=t[a],c=n.dot(o);e=c<e?c:e,i=c>i?c:i}this.min=e,this.max=i}isSeparated(n){return this.min>n.max||n.min>this.max}}K.prototype.setFromBox=function(){const s=new L;return function(t,e){const i=e.min,a=e.max;let r=1/0,o=-1/0;for(let c=0;c<=1;c++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){s.x=i.x*c+a.x*(1-c),s.y=i.y*u+a.y*(1-u),s.z=i.z*f+a.z*(1-f);const p=t.dot(s);r=Math.min(p,r),o=Math.max(p,o)}this.min=r,this.max=o}}();const Ps=function(){const s=new L,n=new L,t=new L;return function(i,a,r){const o=i.start,c=s,u=a.start,f=n;t.subVectors(o,u),s.subVectors(i.end,i.start),n.subVectors(a.end,a.start);const p=t.dot(f),l=f.dot(c),y=f.dot(f),m=t.dot(c),w=c.dot(c)*y-l*l;let d,x;w!==0?d=(p*l-m*y)/w:d=0,x=(p+d*l)/y,r.x=d,r.y=x}}(),xn=function(){const s=new yt,n=new L,t=new L;return function(i,a,r,o){Ps(i,a,s);let c=s.x,u=s.y;if(c>=0&&c<=1&&u>=0&&u<=1){i.at(c,r),a.at(u,o);return}else if(c>=0&&c<=1){u<0?a.at(0,o):a.at(1,o),i.closestPointToPoint(o,!0,r);return}else if(u>=0&&u<=1){c<0?i.at(0,r):i.at(1,r),a.closestPointToPoint(r,!0,o);return}else{let f;c<0?f=i.start:f=i.end;let p;u<0?p=a.start:p=a.end;const l=n,y=t;if(i.closestPointToPoint(p,!0,n),a.closestPointToPoint(f,!0,t),l.distanceToSquared(p)<=y.distanceToSquared(f)){r.copy(l),o.copy(p);return}else{r.copy(f),o.copy(y);return}}}}(),bs=function(){const s=new L,n=new L,t=new qn,e=new W;return function(a,r){const{radius:o,center:c}=a,{a:u,b:f,c:p}=r;if(e.start=u,e.end=f,e.closestPointToPoint(c,!0,s).distanceTo(c)<=o||(e.start=u,e.end=p,e.closestPointToPoint(c,!0,s).distanceTo(c)<=o)||(e.start=f,e.end=p,e.closestPointToPoint(c,!0,s).distanceTo(c)<=o))return!0;const B=r.getPlane(t);if(Math.abs(B.distanceToPoint(c))<=o){const d=B.projectPoint(c,n);if(r.containsPoint(d))return!0}return!1}}(),Bs=1e-15;function Qt(s){return Math.abs(s)<Bs}class j extends gt{constructor(...n){super(...n),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new L),this.satBounds=new Array(4).fill().map(()=>new K),this.points=[this.a,this.b,this.c],this.sphere=new Gn,this.plane=new qn,this.needsUpdate=!0}intersectsSphere(n){return bs(n,this)}update(){const n=this.a,t=this.b,e=this.c,i=this.points,a=this.satAxes,r=this.satBounds,o=a[0],c=r[0];this.getNormal(o),c.setFromPoints(o,i);const u=a[1],f=r[1];u.subVectors(n,t),f.setFromPoints(u,i);const p=a[2],l=r[2];p.subVectors(t,e),l.setFromPoints(p,i);const y=a[3],m=r[3];y.subVectors(e,n),m.setFromPoints(y,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,n),this.needsUpdate=!1}}j.prototype.closestPointToSegment=function(){const s=new L,n=new L,t=new W;return function(i,a=null,r=null){const{start:o,end:c}=i,u=this.points;let f,p=1/0;for(let l=0;l<3;l++){const y=(l+1)%3;t.start.copy(u[l]),t.end.copy(u[y]),xn(t,i,s,n),f=s.distanceToSquared(n),f<p&&(p=f,a&&a.copy(s),r&&r.copy(n))}return this.closestPointToPoint(o,s),f=o.distanceToSquared(s),f<p&&(p=f,a&&a.copy(s),r&&r.copy(o)),this.closestPointToPoint(c,s),f=c.distanceToSquared(s),f<p&&(p=f,a&&a.copy(s),r&&r.copy(c)),Math.sqrt(p)}}();j.prototype.intersectsTriangle=function(){const s=new j,n=new Array(3),t=new Array(3),e=new K,i=new K,a=new L,r=new L,o=new L,c=new L,u=new L,f=new W,p=new W,l=new W,y=new L;function m(B,w,d){const x=B.points;let h=0,P=-1;for(let A=0;A<3;A++){const{start:b,end:T}=f;b.copy(x[A]),T.copy(x[(A+1)%3]),f.delta(r);const _=Qt(w.distanceToPoint(b));if(Qt(w.normal.dot(r))&&_){d.copy(f),h=2;break}const g=w.intersectLine(f,y);if(!g&&_&&y.copy(b),(g||_)&&!Qt(y.distanceTo(T))){if(h<=1)(h===1?d.start:d.end).copy(y),_&&(P=h);else if(h>=2){(P===1?d.start:d.end).copy(y),h=2;break}if(h++,h===2&&P===-1)break}}return h}return function(w,d=null,x=!1){this.needsUpdate&&this.update(),w.isExtendedTriangle?w.needsUpdate&&w.update():(s.copy(w),s.update(),w=s);const h=this.plane,P=w.plane;if(Math.abs(h.normal.dot(P.normal))>1-1e-10){const A=this.satBounds,b=this.satAxes;t[0]=w.a,t[1]=w.b,t[2]=w.c;for(let g=0;g<4;g++){const S=A[g],C=b[g];if(e.setFromPoints(C,t),S.isSeparated(e))return!1}const T=w.satBounds,_=w.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let g=0;g<4;g++){const S=T[g],C=_[g];if(e.setFromPoints(C,n),S.isSeparated(e))return!1}for(let g=0;g<4;g++){const S=b[g];for(let C=0;C<4;C++){const M=_[C];if(a.crossVectors(S,M),e.setFromPoints(a,n),i.setFromPoints(a,t),e.isSeparated(i))return!1}}return d&&(x||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const A=m(this,P,p);if(A===1&&w.containsPoint(p.end))return d&&(d.start.copy(p.end),d.end.copy(p.end)),!0;if(A!==2)return!1;const b=m(w,h,l);if(b===1&&this.containsPoint(l.end))return d&&(d.start.copy(l.end),d.end.copy(l.end)),!0;if(b!==2)return!1;if(p.delta(o),l.delta(c),o.dot(c)<0){let U=l.start;l.start=l.end,l.end=U}const T=p.start.dot(o),_=p.end.dot(o),g=l.start.dot(o),S=l.end.dot(o),C=_<g,M=T<S;return T!==S&&g!==_&&C===M?!1:(d&&(u.subVectors(p.start,l.start),u.dot(o)>0?d.start.copy(p.start):d.start.copy(l.start),u.subVectors(p.end,l.end),u.dot(o)<0?d.end.copy(p.end):d.end.copy(l.end)),!0)}}}();j.prototype.distanceToPoint=function(){const s=new L;return function(t){return this.closestPointToPoint(t,s),t.distanceTo(s)}}();j.prototype.distanceToTriangle=function(){const s=new L,n=new L,t=["a","b","c"],e=new W,i=new W;return function(r,o=null,c=null){const u=o||c?e:null;if(this.intersectsTriangle(r,u))return(o||c)&&(o&&u.getCenter(o),c&&u.getCenter(c)),0;let f=1/0;for(let p=0;p<3;p++){let l;const y=t[p],m=r[y];this.closestPointToPoint(m,s),l=m.distanceToSquared(s),l<f&&(f=l,o&&o.copy(s),c&&c.copy(m));const B=this[y];r.closestPointToPoint(B,s),l=B.distanceToSquared(s),l<f&&(f=l,o&&o.copy(B),c&&c.copy(s))}for(let p=0;p<3;p++){const l=t[p],y=t[(p+1)%3];e.set(this[l],this[y]);for(let m=0;m<3;m++){const B=t[m],w=t[(m+1)%3];i.set(r[B],r[w]),xn(e,i,s,n);const d=s.distanceToSquared(n);d<f&&(f=d,o&&o.copy(s),c&&c.copy(n))}}return Math.sqrt(f)}}();class V{constructor(n,t,e){this.isOrientedBox=!0,this.min=new L,this.max=new L,this.matrix=new tt,this.invMatrix=new tt,this.points=new Array(8).fill().map(()=>new L),this.satAxes=new Array(3).fill().map(()=>new L),this.satBounds=new Array(3).fill().map(()=>new K),this.alignedSatBounds=new Array(3).fill().map(()=>new K),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),e&&this.matrix.copy(e)}set(n,t,e){this.min.copy(n),this.max.copy(t),this.matrix.copy(e),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}V.prototype.update=function(){return function(){const n=this.matrix,t=this.min,e=this.max,i=this.points;for(let u=0;u<=1;u++)for(let f=0;f<=1;f++)for(let p=0;p<=1;p++){const l=1*u|2*f|4*p,y=i[l];y.x=u?e.x:t.x,y.y=f?e.y:t.y,y.z=p?e.z:t.z,y.applyMatrix4(n)}const a=this.satBounds,r=this.satAxes,o=i[0];for(let u=0;u<3;u++){const f=r[u],p=a[u],l=1<<u,y=i[l];f.subVectors(o,y),p.setFromPoints(f,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();V.prototype.intersectsBox=function(){const s=new K;return function(t){this.needsUpdate&&this.update();const e=t.min,i=t.max,a=this.satBounds,r=this.satAxes,o=this.alignedSatBounds;if(s.min=e.x,s.max=i.x,o[0].isSeparated(s)||(s.min=e.y,s.max=i.y,o[1].isSeparated(s))||(s.min=e.z,s.max=i.z,o[2].isSeparated(s)))return!1;for(let c=0;c<3;c++){const u=r[c],f=a[c];if(s.setFromBox(u,t),f.isSeparated(s))return!1}return!0}}();V.prototype.intersectsTriangle=function(){const s=new j,n=new Array(3),t=new K,e=new K,i=new L;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(s.copy(r),s.update(),r=s);const o=this.satBounds,c=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let l=0;l<3;l++){const y=o[l],m=c[l];if(t.setFromPoints(m,n),y.isSeparated(t))return!1}const u=r.satBounds,f=r.satAxes,p=this.points;for(let l=0;l<3;l++){const y=u[l],m=f[l];if(t.setFromPoints(m,p),y.isSeparated(t))return!1}for(let l=0;l<3;l++){const y=c[l];for(let m=0;m<4;m++){const B=f[m];if(i.crossVectors(y,B),t.setFromPoints(i,n),e.setFromPoints(i,p),t.isSeparated(e))return!1}}return!0}}();V.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();V.prototype.distanceToPoint=function(){const s=new L;return function(t){return this.closestPointToPoint(t,s),t.distanceTo(s)}}();V.prototype.distanceToBox=function(){const s=["x","y","z"],n=new Array(12).fill().map(()=>new W),t=new Array(12).fill().map(()=>new W),e=new L,i=new L;return function(r,o=0,c=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(c||u)&&(r.getCenter(i),this.closestPointToPoint(i,e),r.closestPointToPoint(e,i),c&&c.copy(e),u&&u.copy(i)),0;const f=o*o,p=r.min,l=r.max,y=this.points;let m=1/0;for(let w=0;w<8;w++){const d=y[w];i.copy(d).clamp(p,l);const x=d.distanceToSquared(i);if(x<m&&(m=x,c&&c.copy(d),u&&u.copy(i),x<f))return Math.sqrt(x)}let B=0;for(let w=0;w<3;w++)for(let d=0;d<=1;d++)for(let x=0;x<=1;x++){const h=(w+1)%3,P=(w+2)%3,A=d<<h|x<<P,b=1<<w|d<<h|x<<P,T=y[A],_=y[b];n[B].set(T,_);const S=s[w],C=s[h],M=s[P],U=t[B],F=U.start,v=U.end;F[S]=p[S],F[C]=d?p[C]:l[C],F[M]=x?p[M]:l[C],v[S]=l[S],v[C]=d?p[C]:l[C],v[M]=x?p[M]:l[C],B++}for(let w=0;w<=1;w++)for(let d=0;d<=1;d++)for(let x=0;x<=1;x++){i.x=w?l.x:p.x,i.y=d?l.y:p.y,i.z=x?l.z:p.z,this.closestPointToPoint(i,e);const h=i.distanceToSquared(e);if(h<m&&(m=h,c&&c.copy(e),u&&u.copy(i),h<f))return Math.sqrt(h)}for(let w=0;w<12;w++){const d=n[w];for(let x=0;x<12;x++){const h=t[x];xn(d,h,e,i);const P=e.distanceToSquared(i);if(P<m&&(m=P,c&&c.copy(e),u&&u.copy(i),P<f))return Math.sqrt(P)}}return Math.sqrt(m)}}();class hn{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class gs extends hn{constructor(){super(()=>new j)}}const H=new gs;class _s{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=e=>{t&&n.push(t),t=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const z=new _s;let O,pt;const st=[],Lt=new hn(()=>new Z);function Ms(s,n,t,e,i,a){O=Lt.getPrimitive(),pt=Lt.getPrimitive(),st.push(O,pt),z.setBuffer(s._roots[n]);const r=an(0,s.geometry,t,e,i,a);z.clearBuffer(),Lt.releasePrimitive(O),Lt.releasePrimitive(pt),st.pop(),st.pop();const o=st.length;return o>0&&(pt=st[o-1],O=st[o-2]),r}function an(s,n,t,e,i=null,a=0,r=0){const{float32Array:o,uint16Array:c,uint32Array:u}=z;let f=s*2;if(I(f,c)){const l=N(s,u),y=q(f,c);return E(s,o,O),e(l,y,!1,r,a+s,O)}else{let S=function(M){const{uint16Array:U,uint32Array:F}=z;let v=M*2;for(;!I(v,U);)M=$(M),v=M*2;return N(M,F)},C=function(M){const{uint16Array:U,uint32Array:F}=z;let v=M*2;for(;!I(v,U);)M=k(M,F),v=M*2;return N(M,F)+q(v,U)};const l=$(s),y=k(s,u);let m=l,B=y,w,d,x,h;if(i&&(x=O,h=pt,E(m,o,x),E(B,o,h),w=i(x),d=i(h),d<w)){m=y,B=l;const M=w;w=d,d=M,x=h}x||(x=O,E(m,o,x));const P=I(m*2,c),A=t(x,P,w,r+1,a+m);let b;if(A===Pn){const M=S(m),F=C(m)-M;b=e(M,F,!0,r+1,a+m,x)}else b=A&&an(m,n,t,e,i,a,r+1);if(b)return!0;h=pt,E(B,o,h);const T=I(B*2,c),_=t(h,T,d,r+1,a+B);let g;if(_===Pn){const M=S(B),F=C(B)-M;g=e(M,F,!0,r+1,a+B,h)}else g=_&&an(B,n,t,e,i,a,r+1);return!!g}}const At=new L,Gt=new L;function Ss(s,n,t={},e=0,i=1/0){const a=e*e,r=i*i;let o=1/0,c=null;if(s.shapecast({boundsTraverseOrder:f=>(At.copy(n).clamp(f.min,f.max),At.distanceToSquared(n)),intersectsBounds:(f,p,l)=>l<o&&l<r,intersectsTriangle:(f,p)=>{f.closestPointToPoint(n,At);const l=n.distanceToSquared(At);return l<o&&(Gt.copy(At),o=l,c=p),l<a}}),o===1/0)return null;const u=Math.sqrt(o);return t.point?t.point.copy(Gt):t.point=Gt.clone(),t.distance=u,t.faceIndex=c,t}const et=new L,it=new L,rt=new L,Ft=new yt,vt=new yt,zt=new yt,Mn=new L,Sn=new L,Cn=new L,Et=new L;function Cs(s,n,t,e,i,a){let r;return a===On?r=s.intersectTriangle(e,t,n,!0,i):r=s.intersectTriangle(n,t,e,a!==ts,i),r===null?null:{distance:s.origin.distanceTo(i),point:i.clone()}}function Us(s,n,t,e,i,a,r,o,c){et.fromBufferAttribute(n,a),it.fromBufferAttribute(n,r),rt.fromBufferAttribute(n,o);const u=Cs(s,et,it,rt,Et,c);if(u){e&&(Ft.fromBufferAttribute(e,a),vt.fromBufferAttribute(e,r),zt.fromBufferAttribute(e,o),u.uv=gt.getInterpolation(Et,et,it,rt,Ft,vt,zt,new yt)),i&&(Ft.fromBufferAttribute(i,a),vt.fromBufferAttribute(i,r),zt.fromBufferAttribute(i,o),u.uv1=gt.getInterpolation(Et,et,it,rt,Ft,vt,zt,new yt)),t&&(Mn.fromBufferAttribute(t,a),Sn.fromBufferAttribute(t,r),Cn.fromBufferAttribute(t,o),u.normal=gt.getInterpolation(Et,et,it,rt,Mn,Sn,Cn,new L),u.normal.dot(s.direction)>0&&u.normal.multiplyScalar(-1));const f={a,b:r,c:o,normal:new L,materialIndex:0};gt.getNormal(et,it,rt,f.normal),u.face=f,u.faceIndex=a}return u}function jt(s,n,t,e,i){const a=e*3;let r=a+0,o=a+1,c=a+2;const u=s.index;s.index&&(r=u.getX(r),o=u.getX(o),c=u.getX(c));const{position:f,normal:p,uv:l,uv1:y}=s.attributes,m=Us(t,f,p,l,y,r,o,c,n);return m?(m.faceIndex=e,i&&i.push(m),m):null}function D(s,n,t,e){const i=s.a,a=s.b,r=s.c;let o=n,c=n+1,u=n+2;t&&(o=t.getX(o),c=t.getX(c),u=t.getX(u)),i.x=e.getX(o),i.y=e.getY(o),i.z=e.getZ(o),a.x=e.getX(c),a.y=e.getY(c),a.z=e.getZ(c),r.x=e.getX(u),r.y=e.getY(u),r.z=e.getZ(u)}function Ls(s,n,t,e,i,a){const{geometry:r,_indirectBuffer:o}=s;for(let c=e,u=e+i;c<u;c++)jt(r,n,t,c,a)}function Fs(s,n,t,e,i){const{geometry:a,_indirectBuffer:r}=s;let o=1/0,c=null;for(let u=e,f=e+i;u<f;u++){let p;p=jt(a,n,t,u),p&&p.distance<o&&(c=p,o=p.distance)}return c}function vs(s,n,t,e,i,a,r){const{geometry:o}=t,{index:c}=o,u=o.attributes.position;for(let f=s,p=n+s;f<p;f++){let l;if(l=f,D(r,l*3,c,u),r.needsUpdate=!0,e(r,l,i,a))return!0}return!1}function zs(s,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=s.geometry,e=t.index?t.index.array:null,i=t.attributes.position;let a,r,o,c,u=0;const f=s._roots;for(let l=0,y=f.length;l<y;l++)a=f[l],r=new Uint32Array(a),o=new Uint16Array(a),c=new Float32Array(a),p(0,u),u+=a.byteLength;function p(l,y,m=!1){const B=l*2;if(o[B+15]===Xt){const d=r[l+6],x=o[B+14];let h=1/0,P=1/0,A=1/0,b=-1/0,T=-1/0,_=-1/0;for(let g=3*d,S=3*(d+x);g<S;g++){let C=e[g];const M=i.getX(C),U=i.getY(C),F=i.getZ(C);M<h&&(h=M),M>b&&(b=M),U<P&&(P=U),U>T&&(T=U),F<A&&(A=F),F>_&&(_=F)}return c[l+0]!==h||c[l+1]!==P||c[l+2]!==A||c[l+3]!==b||c[l+4]!==T||c[l+5]!==_?(c[l+0]=h,c[l+1]=P,c[l+2]=A,c[l+3]=b,c[l+4]=T,c[l+5]=_,!0):!1}else{const d=l+8,x=r[l+6],h=d+y,P=x+y;let A=m,b=!1,T=!1;n?A||(b=n.has(h),T=n.has(P),A=!b&&!T):(b=!0,T=!0);const _=A||b,g=A||T;let S=!1;_&&(S=p(d,y,A));let C=!1;g&&(C=p(x,y,A));const M=S||C;if(M)for(let U=0;U<3;U++){const F=d+U,v=x+U,R=c[F],J=c[F+3],xt=c[v],ht=c[v+3];c[l+U]=R<xt?R:xt,c[l+U+3]=J>ht?J:ht}return M}}}const Un=new Z;function nt(s,n,t,e){return E(s,n,Un),t.intersectBox(Un,e)}function Es(s,n,t,e,i,a){const{geometry:r,_indirectBuffer:o}=s;for(let c=e,u=e+i;c<u;c++){let f=o?o[c]:c;jt(r,n,t,f,a)}}function Rs(s,n,t,e,i){const{geometry:a,_indirectBuffer:r}=s;let o=1/0,c=null;for(let u=e,f=e+i;u<f;u++){let p;p=jt(a,n,t,r?r[u]:u),p&&p.distance<o&&(c=p,o=p.distance)}return c}function Ds(s,n,t,e,i,a,r){const{geometry:o}=t,{index:c}=o,u=o.attributes.position;for(let f=s,p=n+s;f<p;f++){let l;if(l=t.resolveTriangleIndex(f),D(r,l*3,c,u),r.needsUpdate=!0,e(r,l,i,a))return!0}return!1}const Ln=new L;function Vs(s,n,t,e,i){z.setBuffer(s._roots[n]),ln(0,s,t,e,i),z.clearBuffer()}function ln(s,n,t,e,i){const{float32Array:a,uint16Array:r,uint32Array:o}=z,c=s*2;if(I(c,r)){const f=N(s,o),p=q(c,r);Ls(n,t,e,f,p,i)}else{const f=$(s);nt(f,a,e,Ln)&&ln(f,n,t,e,i);const p=k(s,o);nt(p,a,e,Ln)&&ln(p,n,t,e,i)}}const Fn=new L,Is=["x","y","z"];function Ns(s,n,t,e){z.setBuffer(s._roots[n]);const i=fn(0,s,t,e);return z.clearBuffer(),i}function fn(s,n,t,e){const{float32Array:i,uint16Array:a,uint32Array:r}=z;let o=s*2;if(I(o,a)){const u=N(s,r),f=q(o,a);return Fs(n,t,e,u,f)}else{const u=Xn(s,r),f=Is[u],l=e.direction[f]>=0;let y,m;l?(y=$(s),m=k(s,r)):(y=k(s,r),m=$(s));const w=nt(y,i,e,Fn)?fn(y,n,t,e):null;if(w){const h=w.point[f];if(l?h<=i[m+u]:h>=i[m+u+3])return w}const x=nt(m,i,e,Fn)?fn(m,n,t,e):null;return w&&x?w.distance<=x.distance?w:x:w||x||null}}const Rt=new Z,ot=new j,ct=new j,Tt=new tt,vn=new V,Dt=new V;function qs(s,n,t,e){z.setBuffer(s._roots[n]);const i=un(0,s,t,e);return z.clearBuffer(),i}function un(s,n,t,e,i=null){const{float32Array:a,uint16Array:r,uint32Array:o}=z;let c=s*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),vn.set(t.boundingBox.min,t.boundingBox.max,e),i=vn),I(c,r)){const f=n.geometry,p=f.index,l=f.attributes.position,y=t.index,m=t.attributes.position,B=N(s,o),w=q(c,r);if(Tt.copy(e).invert(),t.boundsTree)return E(s,a,Dt),Dt.matrix.copy(Tt),Dt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>Dt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(e),x.b.applyMatrix4(e),x.c.applyMatrix4(e),x.needsUpdate=!0;for(let h=B*3,P=(w+B)*3;h<P;h+=3)if(D(ct,h,p,l),ct.needsUpdate=!0,x.intersectsTriangle(ct))return!0;return!1}});for(let d=B*3,x=(w+B)*3;d<x;d+=3){D(ot,d,p,l),ot.a.applyMatrix4(Tt),ot.b.applyMatrix4(Tt),ot.c.applyMatrix4(Tt),ot.needsUpdate=!0;for(let h=0,P=y.count;h<P;h+=3)if(D(ct,h,y,m),ct.needsUpdate=!0,ot.intersectsTriangle(ct))return!0}}else{const f=s+8,p=o[s+6];return E(f,a,Rt),!!(i.intersectsBox(Rt)&&un(f,n,t,e,i)||(E(p,a,Rt),i.intersectsBox(Rt)&&un(p,n,t,e,i)))}}const Vt=new tt,Ot=new V,Pt=new V,$s=new L,ks=new L,Hs=new L,Xs=new L;function js(s,n,t,e={},i={},a=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Ot.set(n.boundingBox.min,n.boundingBox.max,t),Ot.needsUpdate=!0;const o=s.geometry,c=o.attributes.position,u=o.index,f=n.attributes.position,p=n.index,l=H.getPrimitive(),y=H.getPrimitive();let m=$s,B=ks,w=null,d=null;i&&(w=Hs,d=Xs);let x=1/0,h=null,P=null;return Vt.copy(t).invert(),Pt.matrix.copy(Vt),s.shapecast({boundsTraverseOrder:A=>Ot.distanceToBox(A),intersectsBounds:(A,b,T)=>T<x&&T<r?(b&&(Pt.min.copy(A.min),Pt.max.copy(A.max),Pt.needsUpdate=!0),!0):!1,intersectsRange:(A,b)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:_=>Pt.distanceToBox(_),intersectsBounds:(_,g,S)=>S<x&&S<r,intersectsRange:(_,g)=>{for(let S=_,C=_+g;S<C;S++){D(y,3*S,p,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let M=A,U=A+b;M<U;M++){D(l,3*M,u,c),l.needsUpdate=!0;const F=l.distanceToTriangle(y,m,w);if(F<x&&(B.copy(m),d&&d.copy(w),x=F,h=M,P=S),F<a)return!0}}}});{const T=dt(n);for(let _=0,g=T;_<g;_++){D(y,3*_,p,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let S=A,C=A+b;S<C;S++){D(l,3*S,u,c),l.needsUpdate=!0;const M=l.distanceToTriangle(y,m,w);if(M<x&&(B.copy(m),d&&d.copy(w),x=M,h=S,P=_),M<a)return!0}}}}}),H.releasePrimitive(l),H.releasePrimitive(y),x===1/0?null:(e.point?e.point.copy(B):e.point=B.clone(),e.distance=x,e.faceIndex=h,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(Vt),B.applyMatrix4(Vt),i.distance=B.sub(i.point).length(),i.faceIndex=P),e)}function Zs(s,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=s.geometry,e=t.index?t.index.array:null,i=t.attributes.position;let a,r,o,c,u=0;const f=s._roots;for(let l=0,y=f.length;l<y;l++)a=f[l],r=new Uint32Array(a),o=new Uint16Array(a),c=new Float32Array(a),p(0,u),u+=a.byteLength;function p(l,y,m=!1){const B=l*2;if(o[B+15]===Xt){const d=r[l+6],x=o[B+14];let h=1/0,P=1/0,A=1/0,b=-1/0,T=-1/0,_=-1/0;for(let g=d,S=d+x;g<S;g++){const C=3*s.resolveTriangleIndex(g);for(let M=0;M<3;M++){let U=C+M;U=e?e[U]:U;const F=i.getX(U),v=i.getY(U),R=i.getZ(U);F<h&&(h=F),F>b&&(b=F),v<P&&(P=v),v>T&&(T=v),R<A&&(A=R),R>_&&(_=R)}}return c[l+0]!==h||c[l+1]!==P||c[l+2]!==A||c[l+3]!==b||c[l+4]!==T||c[l+5]!==_?(c[l+0]=h,c[l+1]=P,c[l+2]=A,c[l+3]=b,c[l+4]=T,c[l+5]=_,!0):!1}else{const d=l+8,x=r[l+6],h=d+y,P=x+y;let A=m,b=!1,T=!1;n?A||(b=n.has(h),T=n.has(P),A=!b&&!T):(b=!0,T=!0);const _=A||b,g=A||T;let S=!1;_&&(S=p(d,y,A));let C=!1;g&&(C=p(x,y,A));const M=S||C;if(M)for(let U=0;U<3;U++){const F=d+U,v=x+U,R=c[F],J=c[F+3],xt=c[v],ht=c[v+3];c[l+U]=R<xt?R:xt,c[l+U+3]=J>ht?J:ht}return M}}}const zn=new L;function Ys(s,n,t,e,i){z.setBuffer(s._roots[n]),pn(0,s,t,e,i),z.clearBuffer()}function pn(s,n,t,e,i){const{float32Array:a,uint16Array:r,uint32Array:o}=z,c=s*2;if(I(c,r)){const f=N(s,o),p=q(c,r);Es(n,t,e,f,p,i)}else{const f=$(s);nt(f,a,e,zn)&&pn(f,n,t,e,i);const p=k(s,o);nt(p,a,e,zn)&&pn(p,n,t,e,i)}}const En=new L,Ws=["x","y","z"];function Ks(s,n,t,e){z.setBuffer(s._roots[n]);const i=yn(0,s,t,e);return z.clearBuffer(),i}function yn(s,n,t,e){const{float32Array:i,uint16Array:a,uint32Array:r}=z;let o=s*2;if(I(o,a)){const u=N(s,r),f=q(o,a);return Rs(n,t,e,u,f)}else{const u=Xn(s,r),f=Ws[u],l=e.direction[f]>=0;let y,m;l?(y=$(s),m=k(s,r)):(y=k(s,r),m=$(s));const w=nt(y,i,e,En)?yn(y,n,t,e):null;if(w){const h=w.point[f];if(l?h<=i[m+u]:h>=i[m+u+3])return w}const x=nt(m,i,e,En)?yn(m,n,t,e):null;return w&&x?w.distance<=x.distance?w:x:w||x||null}}const It=new Z,at=new j,lt=new j,bt=new tt,Rn=new V,Nt=new V;function Js(s,n,t,e){z.setBuffer(s._roots[n]);const i=dn(0,s,t,e);return z.clearBuffer(),i}function dn(s,n,t,e,i=null){const{float32Array:a,uint16Array:r,uint32Array:o}=z;let c=s*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),Rn.set(t.boundingBox.min,t.boundingBox.max,e),i=Rn),I(c,r)){const f=n.geometry,p=f.index,l=f.attributes.position,y=t.index,m=t.attributes.position,B=N(s,o),w=q(c,r);if(bt.copy(e).invert(),t.boundsTree)return E(s,a,Nt),Nt.matrix.copy(bt),Nt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>Nt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(e),x.b.applyMatrix4(e),x.c.applyMatrix4(e),x.needsUpdate=!0;for(let h=B,P=w+B;h<P;h++)if(D(lt,3*n.resolveTriangleIndex(h),p,l),lt.needsUpdate=!0,x.intersectsTriangle(lt))return!0;return!1}});for(let d=B,x=w+B;d<x;d++){const h=n.resolveTriangleIndex(d);D(at,3*h,p,l),at.a.applyMatrix4(bt),at.b.applyMatrix4(bt),at.c.applyMatrix4(bt),at.needsUpdate=!0;for(let P=0,A=y.count;P<A;P+=3)if(D(lt,P,y,m),lt.needsUpdate=!0,at.intersectsTriangle(lt))return!0}}else{const f=s+8,p=o[s+6];return E(f,a,It),!!(i.intersectsBox(It)&&dn(f,n,t,e,i)||(E(p,a,It),i.intersectsBox(It)&&dn(p,n,t,e,i)))}}const qt=new tt,tn=new V,Bt=new V,Qs=new L,Gs=new L,Os=new L,te=new L;function ne(s,n,t,e={},i={},a=0,r=1/0){n.boundingBox||n.computeBoundingBox(),tn.set(n.boundingBox.min,n.boundingBox.max,t),tn.needsUpdate=!0;const o=s.geometry,c=o.attributes.position,u=o.index,f=n.attributes.position,p=n.index,l=H.getPrimitive(),y=H.getPrimitive();let m=Qs,B=Gs,w=null,d=null;i&&(w=Os,d=te);let x=1/0,h=null,P=null;return qt.copy(t).invert(),Bt.matrix.copy(qt),s.shapecast({boundsTraverseOrder:A=>tn.distanceToBox(A),intersectsBounds:(A,b,T)=>T<x&&T<r?(b&&(Bt.min.copy(A.min),Bt.max.copy(A.max),Bt.needsUpdate=!0),!0):!1,intersectsRange:(A,b)=>{if(n.boundsTree){const T=n.boundsTree;return T.shapecast({boundsTraverseOrder:_=>Bt.distanceToBox(_),intersectsBounds:(_,g,S)=>S<x&&S<r,intersectsRange:(_,g)=>{for(let S=_,C=_+g;S<C;S++){const M=T.resolveTriangleIndex(S);D(y,3*M,p,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let U=A,F=A+b;U<F;U++){const v=s.resolveTriangleIndex(U);D(l,3*v,u,c),l.needsUpdate=!0;const R=l.distanceToTriangle(y,m,w);if(R<x&&(B.copy(m),d&&d.copy(w),x=R,h=U,P=S),R<a)return!0}}}})}else{const T=dt(n);for(let _=0,g=T;_<g;_++){D(y,3*_,p,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let S=A,C=A+b;S<C;S++){const M=s.resolveTriangleIndex(S);D(l,3*M,u,c),l.needsUpdate=!0;const U=l.distanceToTriangle(y,m,w);if(U<x&&(B.copy(m),d&&d.copy(w),x=U,h=S,P=_),U<a)return!0}}}}}),H.releasePrimitive(l),H.releasePrimitive(y),x===1/0?null:(e.point?e.point.copy(B):e.point=B.clone(),e.distance=x,e.faceIndex=h,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(qt),B.applyMatrix4(qt),i.distance=B.sub(i.point).length(),i.faceIndex=P),e)}function se(){return typeof SharedArrayBuffer<"u"}const St=new z.constructor,Ht=new z.constructor,G=new hn(()=>new Z),ft=new Z,ut=new Z,nn=new Z,sn=new Z;let en=!1;function ee(s,n,t,e){if(en)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");en=!0;const i=s._roots,a=n._roots;let r,o=0,c=0;const u=new tt().copy(t).invert();for(let f=0,p=i.length;f<p;f++){St.setBuffer(i[f]),c=0;const l=G.getPrimitive();E(0,St.float32Array,l),l.applyMatrix4(u);for(let y=0,m=a.length;y<m&&(Ht.setBuffer(a[f]),r=X(0,0,t,u,e,o,c,0,0,l),Ht.clearBuffer(),c+=a[y].length,!r);y++);if(G.releasePrimitive(l),St.clearBuffer(),o+=i[f].length,r)break}return en=!1,r}function X(s,n,t,e,i,a=0,r=0,o=0,c=0,u=null,f=!1){let p,l;f?(p=Ht,l=St):(p=St,l=Ht);const y=p.float32Array,m=p.uint32Array,B=p.uint16Array,w=l.float32Array,d=l.uint32Array,x=l.uint16Array,h=s*2,P=n*2,A=I(h,B),b=I(P,x);let T=!1;if(b&&A)f?T=i(N(n,d),q(n*2,x),N(s,m),q(s*2,B),c,r+n,o,a+s):T=i(N(s,m),q(s*2,B),N(n,d),q(n*2,x),o,a+s,c,r+n);else if(b){const _=G.getPrimitive();E(n,w,_),_.applyMatrix4(t);const g=$(s),S=k(s,m);E(g,y,ft),E(S,y,ut);const C=_.intersectsBox(ft),M=_.intersectsBox(ut);T=C&&X(n,g,e,t,i,r,a,c,o+1,_,!f)||M&&X(n,S,e,t,i,r,a,c,o+1,_,!f),G.releasePrimitive(_)}else{const _=$(n),g=k(n,d);E(_,w,nn),E(g,w,sn);const S=u.intersectsBox(nn),C=u.intersectsBox(sn);if(S&&C)T=X(s,_,t,e,i,a,r,o,c+1,u,f)||X(s,g,t,e,i,a,r,o,c+1,u,f);else if(S)if(A)T=X(s,_,t,e,i,a,r,o,c+1,u,f);else{const M=G.getPrimitive();M.copy(nn).applyMatrix4(t);const U=$(s),F=k(s,m);E(U,y,ft),E(F,y,ut);const v=M.intersectsBox(ft),R=M.intersectsBox(ut);T=v&&X(_,U,e,t,i,r,a,c,o+1,M,!f)||R&&X(_,F,e,t,i,r,a,c,o+1,M,!f),G.releasePrimitive(M)}else if(C)if(A)T=X(s,g,t,e,i,a,r,o,c+1,u,f);else{const M=G.getPrimitive();M.copy(sn).applyMatrix4(t);const U=$(s),F=k(s,m);E(U,y,ft),E(F,y,ut);const v=M.intersectsBox(ft),R=M.intersectsBox(ut);T=v&&X(g,U,e,t,i,r,a,c,o+1,M,!f)||R&&X(g,F,e,t,i,r,a,c,o+1,M,!f),G.releasePrimitive(M)}}return T}const $t=new V,Dn=new Z,ie={strategy:$n,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class mn{static serialize(n,t={}){t=mt({cloneBuffers:!0},t);const e=n.geometry,i=n._roots,a=n._indirectBuffer,r=e.getIndex();let o;return t.cloneBuffers?o={roots:i.map(c=>c.slice()),index:r.array.slice(),indirectBuffer:a?a.slice():null}:o={roots:i,index:r.array,indirectBuffer:a},o}static deserialize(n,t,e={}){e=mt({setIndex:!0,indirect:!!n.indirectBuffer},e);const{index:i,roots:a,indirectBuffer:r}=n,o=new mn(t,Zt(mt({},e),{[Wt]:!0}));if(o._roots=a,o._indirectBuffer=r||null,e.setIndex){const c=t.getIndex();if(c===null){const u=new Nn(n.index,1,!1);t.setIndex(u)}else c.array!==i&&(c.array.set(i),c.needsUpdate=!0)}return o}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign(Zt(mt({},ie),{[Wt]:!1}),t),t.useSharedArrayBuffer&&!se())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[Wt]||(Ts(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new Z)));const{_indirectBuffer:e}=this;this.resolveTriangleIndex=t.indirect?i=>e[i]:i=>i}refit(n=null){return(this.indirect?Zs:zs)(this,n)}traverse(n,t=0){const e=this._roots[t],i=new Uint32Array(e),a=new Uint16Array(e);r(0);function r(o,c=0){const u=o*2,f=a[u+15]===Xt;if(f){const p=i[o+6],l=a[u+14];n(c,f,new Float32Array(e,o*4,6),p,l)}else{const p=o+Mt/4,l=i[o+6],y=i[o+7];n(c,f,new Float32Array(e,o*4,6),y)||(r(p,c+1),r(l,c+1))}}}raycast(n,t=Tn){const e=this._roots,i=this.geometry,a=[],r=t.isMaterial,o=Array.isArray(t),c=i.groups,u=r?t.side:t,f=this.indirect?Ys:Vs;for(let p=0,l=e.length;p<l;p++){const y=o?t[c[p].materialIndex].side:u,m=a.length;if(f(this,p,y,n,a),o){const B=c[p].materialIndex;for(let w=m,d=a.length;w<d;w++)a[w].face.materialIndex=B}}return a}raycastFirst(n,t=Tn){const e=this._roots,i=this.geometry,a=t.isMaterial,r=Array.isArray(t);let o=null;const c=i.groups,u=a?t.side:t,f=this.indirect?Ks:Ns;for(let p=0,l=e.length;p<l;p++){const y=r?t[c[p].materialIndex].side:u,m=f(this,p,y,n);m!=null&&(o==null||m.distance<o.distance)&&(o=m,r&&(m.face.materialIndex=c[p].materialIndex))}return o}intersectsGeometry(n,t){let e=!1;const i=this._roots,a=this.indirect?Js:qs;for(let r=0,o=i.length;r<o&&(e=a(this,r,n,t),!e);r++);return e}shapecast(n){const t=H.getPrimitive(),e=this.indirect?Ds:vs;let{boundsTraverseOrder:i,intersectsBounds:a,intersectsRange:r,intersectsTriangle:o}=n;if(r&&o){const p=r;r=(l,y,m,B,w)=>p(l,y,m,B,w)?!0:e(l,y,this,o,m,B,t)}else r||(o?r=(p,l,y,m)=>e(p,l,this,o,y,m,t):r=(p,l,y)=>y);let c=!1,u=0;const f=this._roots;for(let p=0,l=f.length;p<l;p++){const y=f[p];if(c=Ms(this,p,a,r,i,u),c)break;u+=y.byteLength}return H.releasePrimitive(t),c}bvhcast(n,t,e){let{intersectsRanges:i,intersectsTriangles:a}=e;const r=H.getPrimitive(),o=this.geometry.index,c=this.geometry.attributes.position,u=this.indirect?m=>{const B=this.resolveTriangleIndex(m);D(r,B*3,o,c)}:m=>{D(r,m*3,o,c)},f=H.getPrimitive(),p=n.geometry.index,l=n.geometry.attributes.position,y=n.indirect?m=>{const B=n.resolveTriangleIndex(m);D(f,B*3,p,l)}:m=>{D(f,m*3,p,l)};if(a){const m=(B,w,d,x,h,P,A,b)=>{for(let T=d,_=d+x;T<_;T++){y(T),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let g=B,S=B+w;g<S;g++)if(u(g),r.needsUpdate=!0,a(r,f,g,T,h,P,A,b))return!0}return!1};if(i){const B=i;i=function(w,d,x,h,P,A,b,T){return B(w,d,x,h,P,A,b,T)?!0:m(w,d,x,h,P,A,b,T)}}else i=m}return ee(this,n,t,i)}intersectsBox(n,t){return $t.set(n.min,n.max,t),$t.needsUpdate=!0,this.shapecast({intersectsBounds:e=>$t.intersectsBox(e),intersectsTriangle:e=>$t.intersectsTriangle(e)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,e={},i={},a=0,r=1/0){return(this.indirect?ne:js)(this,n,t,e,i,a,r)}closestPointToPoint(n,t={},e=0,i=1/0){return Ss(this,n,t,e,i)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(e=>{E(0,new Float32Array(e),Dn),n.union(Dn)}),n}}function Vn(s,n,t){return s===null||(s.point.applyMatrix4(n.matrixWorld),s.distance=s.point.distanceTo(t.ray.origin),s.object=n,s.distance<t.near||s.distance>t.far)?null:s}const rn=new ss,In=new tt,re=ns.prototype.raycast;function ae(s,n){if(this.geometry.boundsTree){if(this.material===void 0)return;In.copy(this.matrixWorld).invert(),rn.copy(s.ray).applyMatrix4(In);const t=this.geometry.boundsTree;if(s.firstHitOnly===!0){const e=Vn(t.raycastFirst(rn,this.material),this,s);e&&n.push(e)}else{const e=t.raycast(rn,this.material);for(let i=0,a=e.length;i<a;i++){const r=Vn(e[i],this,s);r&&n.push(r)}}}else re.call(this,s,n)}function le(s){return this.boundsTree=new mn(this,s),this.boundsTree}function fe(){this.boundsTree=null}export{ae as a,le as c,fe as d};
