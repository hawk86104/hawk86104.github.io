import{importShared as e}from"./3d-tiles-renderer.de6b_qgz1767149344623.js";import{Pane as o}from"./tweakpane.BbuIEN141767149344623.js";import{instance as n}from"./Resource.CAbpDFqA1767149344623.js";import{loading$2 as t}from"./generalFont.vue_vue_type_script_setup_true_lang.HBTMxPpG1767149344623.js";import"./default.vue_vue_type_script_setup_true_lang.Ci1f-gQB1767149344623.js";import"./three-mesh-ui.module.HfSEvVD61767149344623.js";import"./domPanel.vue_vue_type_style_index_0_lang.Copj1fnF1767149344623.js";import{_sfc_main as a}from"./pagesShow.vue_vue_type_script_setup_true_lang.CrL9_aV81767149344623.js";import{_l as l}from"./index.Btae5S5d1767149344623.js";const{defineComponent:r}=await e("vue"),{normalizeProps:i,guardReactiveProps:f,openBlock:u,createElementBlock:c}=await e("vue"),{watch:s}=await e("vue"),d=await e("three"),v=r({__name:"meshSpiralMaterial",props:{frontColor:{default:"#320564"},backColor:{default:"#ec22ff"},intensity:{default:1.5},powerOffset:{default:4},noiseCutOff:{default:.32},colorBoth:{type:Boolean,default:!1}},setup(e){const o=e,t=n.getItem("noiseVoronoi.png"),a={uniforms:{uTime:{value:0},uFrontColor:{value:new d.Color(o.frontColor)},uBackColor:{value:new d.Color(o.backColor).multiplyScalar(o.intensity)},uNoise:{value:t},uPowerOffset:{value:o.powerOffset},uNoiseCutOff:{value:o.noiseCutOff},uColorBoth:{value:o.colorBoth}},vertexShader:"out vec2 vUv;\n\nvoid main()\n{\n    \n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    vUv = uv;\n    \n}",fragmentShader:"uniform float uTime;\nuniform vec3 uFrontColor;\nuniform vec3 uBackColor;\nuniform sampler2D uNoise;\nuniform float uPowerOffset;\nuniform float uNoiseCutOff;\nuniform bool uColorBoth;\n\nin vec2 vUv;\n\nvoid clip( float clipValue, float alphaThreshold, int type )\n{\n    \n    switch( type )\n    {\n        case 0: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n\n        case 1: \n            if( clipValue > alphaThreshold ) discard;\n        break;\n\n        case 2: \n            if( clipValue <= alphaThreshold ) discard;\n        break;\n\n        case 3: \n            if( clipValue >= alphaThreshold ) discard;\n        break;\n\n        case 4: \n            if( clipValue == alphaThreshold ) discard;\n        break;\n\n        default: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n    }\n}\nvec2 tileOffset( vec2 uv , vec2 tiling, vec2 offset )\n{\n    return  uv * tiling + offset;\n}\n\nvoid main()\n{\n    vec2 uv = vUv;\n\n    vec2 timeOffset = vec2( uTime * 0.6, 0.0 );\n\n    \n\n    \n    vec3 noiseVoronoi = texture( uNoise, uv ).rgb;\n\n    float uvCutOff = uv.y;\n\n    uvCutOff = smoothstep( 0.02, 1.0, uvCutOff + 0.2  );\n\n    \n    float noiseCutOff = pow( noiseVoronoi.r, uPowerOffset );\n\n    \n\n    \n    vec3 colorFront = uFrontColor;\n    colorFront *= noiseCutOff;\n\n    vec3 colorBack = uBackColor;\n    colorBack *= noiseCutOff;\n\n    \n    vec3 colorFinal = colorFront;\n\n    if( uColorBoth )\n    {\n        colorFinal = ( ( gl_FrontFacing ) ? colorFront : colorBack );\n    }\n\n    \n    clip( noiseCutOff, uNoiseCutOff, 0 );\n\n    gl_FragColor = vec4( colorFinal, noiseCutOff * uvCutOff );\n    \n\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n\n}",transparent:!0,side:d.DoubleSide,depthWrite:!0,depthTest:!0},{onBeforeRender:r}=l();return r(({delta:e})=>{a.uniforms.uTime.value+=e}),s(()=>[o.frontColor,o.backColor],([e,n])=>{a.uniforms.uFrontColor.value.setStyle(e),a.uniforms.uBackColor.value.setStyle(n).multiplyScalar(o.intensity)}),(e,o)=>(u(),c("TresShaderMaterial",i(f(a)),null,16))}}),{defineComponent:p}=await e("vue"),{unref:m,createVNode:h,createElementVNode:w,openBlock:g,createElementBlock:C}=await e("vue"),y=["geometry"],{ref:O}=await e("vue"),T=p({__name:"highlightMiddle",props:{frontColor:{default:"#111111"},backColor:{default:"#ff810c"}},setup(e){const o=O(null),{nodes:t}=n.getItem("spiral-middle.glb"),{onBeforeRender:a}=l();return a(({delta:e,elapsed:n})=>{if(o.value){const t=3.4*n,a=.2*Math.sin(t)+.8;o.value.rotation.y+=6*e,o.value.scale.set(a,a,a)}}),(e,n)=>(g(),C("TresGroup",null,[w("TresMesh",{ref_key:"meshRef",ref:o,geometry:m(t).Cylinder.geometry,renderOrder:999991},[h(v,{frontColor:e.frontColor,backColor:e.backColor,intensity:2.7,powerOffset:12,colorBoth:""},null,8,["frontColor","backColor"])],8,y)]))}});const{defineComponent:_}=await e("vue"),{normalizeProps:B,guardReactiveProps:V,openBlock:k,createElementBlock:S}=await e("vue"),{watch:b}=await e("vue"),x=await e("three"),N=_({__name:"meshTornadoMaterial",props:{colorBase:{default:"#ff821c"},colorIntensity:{default:12},twirlAmount:{default:8},radialShearAmount:{default:new x.Vector2(5,5)},twirlOffset:{default:new x.Vector2(0,.5)},radialOffset:{default:new x.Vector2(0,.5)},twirlCenter:{default:new x.Vector2(.5,-.5)},radialCenter:{default:new x.Vector2(.5,.5)},noisePower:{default:1},alphaThreshold:{default:.17},showEdge:{type:Boolean,default:!1}},setup(e){const o=e,n={uniforms:{uTime:{value:0},uColor:{value:new x.Color(o.colorBase).multiplyScalar(o.colorIntensity)},uTwirl:{value:o.twirlAmount},uRadialShear:{value:o.radialShearAmount},uTwirlOffset:{value:o.twirlOffset},uRadialOffset:{value:o.radialOffset},uTwirlCenter:{value:o.twirlCenter},uRadialCenter:{value:o.radialCenter},uNoisePower:{value:o.noisePower},uAlphaThreshold:{value:o.alphaThreshold},uEdge:{value:o.showEdge}},vertexShader:"out vec2 vUv;\n\nvoid main()\n{\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    vUv = uv;\n}",fragmentShader:"uniform float uTime;\nuniform vec3 uColor;\nuniform float uTwirl;\nuniform vec2 uRadialShear;\nuniform vec2 uTwirlOffset;\nuniform vec2 uRadialOffset;\nuniform vec2 uTwirlCenter;\nuniform vec2 uRadialCenter;\nuniform float uNoisePower;\nuniform float uAlphaThreshold;\nuniform bool uEdge;\n\nin vec2 vUv;\n\nvoid clip( float clipValue, float alphaThreshold, int type )\n{\n    \n    switch( type )\n    {\n        case 0: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n\n        case 1: \n            if( clipValue > alphaThreshold ) discard;\n        break;\n\n        case 2: \n            if( clipValue <= alphaThreshold ) discard;\n        break;\n\n        case 3: \n            if( clipValue >= alphaThreshold ) discard;\n        break;\n\n        case 4: \n            if( clipValue == alphaThreshold ) discard;\n        break;\n\n        default: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n    }\n}\nvec2 twirl(vec2 uv, vec2 center, float strength, vec2 offset)\n{\n    vec2 delta = uv - center;\n    float angle = strength * length(delta);\n    float x = cos(angle) * delta.x - sin(angle) * delta.y;\n    float y = sin(angle) * delta.x + cos(angle) * delta.y;\n    return vec2(x + center.x + offset.x, y + center.y + offset.y);\n}\nvec2 radialShear( vec2 uv, vec2 center, float strength, vec2 offset )\n{\n    vec2 delta = uv - center;\n    float delta2 = dot( delta.xy, delta.xy );\n\n    float deltaOffset = delta2 * strength;\n\n    return uv + vec2( delta.y, -delta.x) * deltaOffset + offset;\n}\n\nvec2 radialShear( vec2 uv, vec2 center, vec2 strength, vec2 offset )\n{\n    vec2 delta = uv - center;\n    vec2 delta2 =  vec2( dot( delta.xy, delta.xy ) );\n\n    vec2 deltaOffset = delta2 * strength;\n\n    return uv + vec2( delta.y, -delta.x) * deltaOffset + offset;\n}\nfloat randomSimple(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat interpolate( float a, float b, float t )\n{\n    return ( 1.0 - t ) * a + ( t * b );\n}\n\nfloat valueNoise( vec2 uv )\n{\n    vec2 i = floor( uv );\n    vec2 f = fract( uv );\n    f = f * f * ( 3.0 - 2.0 * f );\n\n    uv = abs( fract( uv ) - 0.5 );\n    vec2 c0 = i + vec2(0.0, 0.0);\n    vec2 c1 = i + vec2(1.0, 0.0);\n    vec2 c2 = i + vec2(0.0, 1.0);\n    vec2 c3 = i + vec2(1.0, 1.0);\n    float r0 = randomSimple(c0);\n    float r1 = randomSimple(c1);\n    float r2 = randomSimple(c2);\n    float r3 = randomSimple(c3);\n\n    float bottomOfGrid = interpolate(r0, r1, f.x);\n    float topOfGrid = interpolate(r2, r3, f.x);\n    float t = interpolate(bottomOfGrid, topOfGrid, f.y);\n    return t;\n}\n\nfloat noiseSimple( vec2 UV, float Scale )\n{\n    float t = 0.0;\n\n    float freq = pow(2.0, float(0));\n    float amp = pow(0.5, float(3-0));\n    t += valueNoise(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    freq = pow(2.0, float(1));\n    amp = pow(0.5, float(3-1));\n    t += valueNoise(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    freq = pow(2.0, float(2));\n    amp = pow(0.5, float(3-2));\n    t += valueNoise(vec2(UV.x * Scale / freq, UV.y * Scale / freq ) ) * amp;\n\n    return t;\n}\nfloat remap( float value, float min1, float max1, float min2, float max2 ) \n{\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main()\n{\n\n    vec2 uv = vUv;\n    float time = uTime;\n\n    vec2 twirlOffset = vec2( time * uTwirlOffset.x, time * uTwirlOffset.y );\n    vec2 radialOffset = vec2( time * uRadialOffset.x, time * uRadialOffset.y );\n\n    float uvCutOff = uv.y;\n    uvCutOff = smoothstep( 0.2, 1.0, uvCutOff + 0.2 );\n\n    vec2 uvRadial = radialShear( uv, uRadialCenter, uRadialShear, radialOffset );\n    vec2 uvTwirl = twirl( uv, uTwirlCenter, uTwirl, twirlOffset );\n\n    float noiseRadial = noiseSimple( uvRadial, 20.0 );\n    float noiseTwirl = noiseSimple( uvTwirl, 20.0 );\n\n    float noise = noiseRadial * noiseTwirl;\n\n    noise = pow( noise, uNoisePower );\n\n    float dissolve = remap( noise, 0.0, 1.0, 1.0, 0.0 );\n\n    vec3 colorFinal = uColor;\n    colorFinal *= noise;\n\n    clip( noise, uAlphaThreshold, 0 );\n\n    vec4 color = vec4( colorFinal, dissolve );\n\n    if( uEdge )\n    {\n        color.a *= uvCutOff;\n    }\n\n    gl_FragColor = color;\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n\n}",transparent:!0,side:x.DoubleSide,depthWrite:!0,depthTest:!0},{onBeforeRender:t}=l();return t(({delta:e})=>{n.uniforms.uTime.value+=e}),b(()=>o.colorBase,e=>{n.uniforms.uColor.value.setStyle(e).multiplyScalar(o.colorIntensity)}),(e,o)=>(k(),S("TresShaderMaterial",B(V(n)),null,16))}}),{defineComponent:F}=await e("vue"),{unref:R,createVNode:A,openBlock:E,createElementBlock:P}=await e("vue"),M=["geometry"],U=await e("three"),I=F({__name:"tornadoOutter",props:{color:{default:"#ff5400"}},setup(e){const{nodes:o}=n.getItem("tornado.glb");return(e,n)=>(E(),P("TresMesh",{geometry:R(o).tornado.geometry},[A(N,{colorBase:e.color,colorIntensity:2,twirlAmount:6,radialShearAmount:new U.Vector2(.9,.9),twirlCenter:new U.Vector2(.5,-.52),twirlOffset:new U.Vector2(-.5,-.25),radialOffset:new U.Vector2(-.5,.5),alphaThreshold:.18,showEdge:!1},null,8,["colorBase","radialShearAmount","twirlCenter","twirlOffset","radialOffset"])],8,M))}}),{defineComponent:j}=await e("vue"),{unref:q,createVNode:G,openBlock:L,createElementBlock:z}=await e("vue"),D=["geometry"],W=await e("three"),H=j({__name:"tornado",props:{color:{default:"#ff5400"}},setup(e){const{nodes:o}=n.getItem("tornado.glb");return(e,n)=>(L(),z("TresMesh",{geometry:q(o).tornado.geometry},[G(N,{colorBase:e.color,colorIntensity:13,twirlAmount:8,radialShearAmount:new W.Vector2(.7,.7),twirlCenter:new W.Vector2(.5,-.52),twirlOffset:new W.Vector2(-1,-.5),radialOffset:new W.Vector2(-1,.5),alphaThreshold:.23,showEdge:!1},null,8,["colorBase","radialShearAmount","twirlCenter","twirlOffset","radialOffset"])],8,D))}}),{defineComponent:$}=await e("vue"),{unref:J,createVNode:K,openBlock:Q,createElementBlock:X}=await e("vue"),Y=["geometry"],Z=await e("three"),ee=$({__name:"tornadoInner",props:{color:{default:"#ff5400"}},setup(e){const{nodes:o}=n.getItem("tornado.glb");return(e,n)=>(Q(),X("TresMesh",{geometry:J(o).tornado.geometry},[K(N,{colorBase:e.color,colorIntensity:8,radialShearAmount:new Z.Vector2(.7,.7),alphaThreshold:.17,showEdge:!0},null,8,["colorBase","radialShearAmount"])],8,Y))}}),{defineComponent:oe}=await e("vue"),{createVNode:ne,openBlock:te,createElementBlock:ae}=await e("vue"),le=oe({__name:"experience",props:{color0:{default:"#111111"},color1:{default:"#ff810c"},color2:{default:"#3a3a3a"},color3:{default:"#ff821c"},color4:{default:"#ff5400"}},setup:e=>(e,o)=>(te(),ae("TresGroup",null,[ne(T,{scale:[1.1,4.6,1.1],position:[0,-2,0],frontColor:e.color0,backColor:e.color1},null,8,["frontColor","backColor"]),ne(I,{scale:[.6,.4,.6],position:[0,-2.5,0],renderOrder:999992,color:e.color2},null,8,["color"]),ne(H,{scale:[.44,.4,.44],position:[0,-2.5,0],renderOrder:999993,color:e.color3},null,8,["color"]),ne(ee,{scale:.4,position:[0,-2.5,0],renderOrder:999994,color:e.color4},null,8,["color"])]))}),{defineComponent:re}=await e("vue"),{unref:ie,createVNode:fe,mergeProps:ue,openBlock:ce,createBlock:se,createCommentVNode:de,withCtx:ve,Fragment:pe,createElementBlock:me}=await e("vue"),{reactive:he}=await e("vue"),we=re({__name:"stylizedTornado",setup(e){n.loadResources([{functionName:"GLTFLoader",url:"./plugins/digitalCity/model/spiral-middle.glb"},{functionName:"GLTFLoader",url:"./plugins/digitalCity/model/tornado.glb"},{functionName:"TextureLoader",url:"./plugins/digitalCity/image/noise/noiseVoronoi.png"}]);const l=new o({title:"龙卷风参数",expanded:!0}),r=he({color0:"#111111",color1:"#ff810c",color2:"#3a3a3a",color3:"#ff821c",color4:"#ff1800"});return l.addBinding(r,"color0",{label:"颜色0"}),l.addBinding(r,"color1",{label:"颜色1"}),l.addBinding(r,"color2",{label:"颜色2"}),l.addBinding(r,"color3",{label:"颜色3"}),l.addBinding(r,"color4",{label:"颜色4"}),(e,o)=>(ce(),me(pe,null,[fe(ie(t),{useResourceManager:""}),fe(a,{showAxesHelper:!1},{ability:ve(()=>[ie(n).hasAllFinished.value?(ce(),se(le,ue({key:0,position:[10,280,0],scale:100},r),null,16)):de("",!0)]),_:1})],64))}});export{we as default};
