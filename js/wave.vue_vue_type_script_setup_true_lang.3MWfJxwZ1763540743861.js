import{_ as e}from"./@tresjs.BCHtwiaC1763540743861.js";import{g as t}from"./utils.DhJ-cORL1763540743861.js";import{d as n,a as o,a6 as a,w as r,H as u,o as i,J as s,u as l,ac as y,ao as f}from"./@vue.Co_gxueH1763540743861.js";import{l as p,ae as v}from"./three.rXKzP9fQ1763540743861.js";const c=["position","uv"],m=n({__name:"wave",props:{positionSrc:{default:[{x:0,y:0},{x:10,y:10}]},color:{default:"#ffff00"},opacity:{default:.8},height:{default:100},frequencyNum:{default:8},speed:{default:1}},setup(n){const m=n,d=o(),x={side:v,transparent:!0,depthWrite:!1,depthTest:!0,vertexShader:"\nvarying vec2 vUv; \nvoid main(){\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n}\n",fragmentShader:"\n\tuniform float uTime;\n\tvarying vec2 vUv;\n\t#define PI 3.14159265\n  uniform float speed;\n  uniform vec3 color;\n  uniform float opacity;\n  uniform float frequencyNum;\n\tvoid main(){\n\t\t\t\n\tfloat amplitude = 1.;\n\n\tfloat x = vUv.x;\n\tfloat y = sin(x * frequencyNum) ;\n\tfloat t = 0.01*(-uTime*130.0*speed);\n\ty += sin(x*frequencyNum*2.1 + t)*4.5;\n\ty += sin(x*frequencyNum*1.72 + t*1.121)*4.0;\n\ty += sin(x*frequencyNum*2.221 + t*0.437)*5.0;\n\ty += sin(x*frequencyNum*3.1122+ t*4.269)*2.5;\n\ty *= amplitude*0.06;\n\ty /= 3.;\n\ty += 0.55;\n\n\tfloat ap = step(vUv.y,y) * (y-vUv.y)/y;\n\n\tgl_FragColor = vec4(color,ap*opacity);\n}\n\t",uniforms:{uTime:{type:"pv2",value:0},color:{type:"uvs",value:new p(m.color)},opacity:{type:"pv2",value:m.opacity},frequencyNum:{type:"pv2",value:m.frequencyNum},speed:{type:"pv2",value:m.speed}}};let h=null,g=null;function q(e=[],t){const n=[],o=[];for(let a=0,r=n.length,u=o.length;a<e.length-1;a++){let i=1,s=e[a],l=e[a+1];n[r++]=s.x,n[r++]=0,n[r++]=s.y,o[u++]=0,o[u++]=0,n[r++]=l.x,n[r++]=0,n[r++]=l.y,o[u++]=1,o[u++]=0,n[r++]=s.x,n[r++]=t,n[r++]=s.y,o[u++]=0,o[u++]=i,n[r++]=s.x,n[r++]=t,n[r++]=s.y,o[u++]=0,o[u++]=i,n[r++]=l.x,n[r++]=0,n[r++]=l.y,o[u++]=1,o[u++]=0,n[r++]=l.x,n[r++]=t,n[r++]=l.y,o[u++]=1,o[u++]=i}h=new Float32Array(n),g=new Float32Array(o)}const{centerPoint:N,points:T}=t(m.positionSrc);q(T,m.height);const{onBeforeRender:w}=e();return w(({delta:e})=>{x.uniforms.uTime.value+=e}),a(()=>{m.color&&(x.uniforms.color.value=new p(m.color)),m.opacity&&(x.uniforms.opacity.value=m.opacity),m.frequencyNum&&(x.uniforms.frequencyNum.value=m.frequencyNum),m.speed&&(x.uniforms.speed.value=m.speed),d.value&&d.value.position.set(N.x,d.value.position.y,N.y)}),r(()=>m.height,e=>{q(T,m.height),d.value&&d.value.position.set(N.x,d.value.position.y,N.y)}),(e,t)=>(i(),u("TresMesh",{renderOrder:2200,ref_key:"tresMeshRef",ref:d},[s("TresBufferGeometry",{position:[l(h),3],uv:[l(g),2]},null,8,c),s("TresShaderMaterial",y(f(x)),null,16)],512))}});export{m as _};
