import{_ as e,l as t}from"./@tresjs.BCHtwiaC1763540743861.js";import{d as n}from"./index.Crdf3MNx1763540743861.js";import{d as o,a7 as a,a8 as i,w as r,H as s,o as l,J as m,h as d,u as f}from"./@vue.Co_gxueH1763540743861.js";import{dv as h,j as u,l as v,b8 as g,i as p}from"./three.rXKzP9fQ1763540743861.js";const x=["rotateX"],c=["position","aIndex","aNormal"],I=o({__name:"lineMagicZone",props:{height:{default:1.6},speed:{default:1},color:{default:"#90ee90"}},async setup(o){let I,S;const w=a(),T=o,N=([I,S]=i(()=>n(["./plugins/basic/shine/image/round.png","./plugins/digitalCity/image/noise/noisePerlin.png"])),I=await I,S(),I),U=new h(0,0,8,8,0,2*Math.PI,!1,0),y=[];for(let e=0;e<5;e++)y.push(...U.getPoints(719)),U.xRadius+=.2,U.yRadius+=.2;const P=new Float32Array(y.map((e,t)=>t)),b=(new u).setFromPoints(y).getAttribute("position").array,W=new Float32Array(b.length);for(let e=0;e<b.length/3;e++){const t=3*e;b[t+1]+=.15*Math.floor(e/720);const n=e%720*3,o=3*(e%720+2880);W[t]=b[o]-b[n],W[t+1]=b[o+1]-b[n+1],W[t+2]=b[o+2]-b[n+2]}const C={uTime:{value:0},uScale:{value:w.scale?w.scale:1},uHeight:{value:T.height},uPerlinTexture:{value:N[1]},baseColor:{value:new v(T.color)}},{onRender:M}=e();return M(()=>{C.uTime.value+=.01*T.speed}),r(()=>[T.color,w.scale,T.height],([e,t,n])=>{C.baseColor.value.set(e),C.uScale.value=t,C.uHeight.value=n}),(e,n)=>(l(),s("TresGroup",null,[m("TresPoints",{rotateX:-Math.PI/2,scale:.1},[m("TresBufferGeometry",{position:[f(b),3],aIndex:[f(P),1],aNormal:[f(W),3]},null,8,c),d(f(t),{baseMaterial:p,vertexShader:"\nvarying vec2 vMapUv;\nattribute float aIndex;\nattribute vec3 aNormal;\nuniform float uTime;\nuniform float uScale;\nuniform float uHeight;\nuniform sampler2D uPerlinTexture;\nvarying float vIndex;\nvarying float vSelfIndex;\nvarying float vCircleNum;\nfloat getStrength(float aIndex, float uTime, vec3 aNormal) {\n    float selfIndex = mod(aIndex, 720.0);\n    float circleNum = (aIndex - selfIndex) / 720.0;\n    vec3 pDir = normalize(aNormal);\n    float waveWidth = 90.0;\n    float totalLength = 720.0;\n    float modUtime = mod(uTime * 50.0, 720.0);\n    float dw = waveWidth * 0.5;\n    float smoothStart = smoothstep(modUtime, modUtime + dw, selfIndex);\n    float smoothEnd = 1.0 - smoothstep(modUtime + waveWidth - dw, modUtime + waveWidth, selfIndex);\n    float strength = min(smoothStart, smoothEnd);\n    float isOver = step(720.0, modUtime + waveWidth);\n    float over = (modUtime + waveWidth - 720.0);\n    float isOverStep1 = (1.0 - step(dw, over)) * isOver;\n    float isOverStep2 = step(dw, over);\n    float overStep1Left = min(smoothstep(modUtime, modUtime + dw, selfIndex), (1.0 - smoothstep(modUtime + waveWidth - dw, modUtime + waveWidth, selfIndex)));\n    float overStep1Right = 1.0 - smoothstep(modUtime + waveWidth - dw, modUtime + waveWidth, selfIndex + 720.0);\n    float overStep1 = max(overStep1Left, overStep1Right);\n    float overStep2Left = smoothstep(modUtime, modUtime + dw, selfIndex);\n    float overStep2Right = min(smoothstep(modUtime, modUtime + dw, selfIndex + 720.0), (1.0 - smoothstep(modUtime + waveWidth - dw, modUtime + waveWidth, selfIndex + 720.0)));\n    float overStep2 = max(overStep2Left, overStep2Right);\n    float os = isOverStep1 * overStep1 + overStep2 * isOverStep2;\n    strength = (1.0 - isOver) * strength + isOver * os;\n    return strength;\n}\nvoid main() {\n\tvMapUv = uv;\n\tfloat selfIndex = mod(aIndex, 720.0);\n\tfloat circleNum = (aIndex - selfIndex) / 720.0;\n\tvec3 pDir = normalize(aNormal);\n\tfloat noise = texture(uPerlinTexture, vec2((selfIndex / 720.0), mod(uTime * 0.1, 1.0))).r;\n\tfloat strength = getStrength(aIndex, uTime, aNormal);\n\tstrength += getStrength(aIndex, uTime + 10.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 20.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 30.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 40.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 50.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 60.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 70.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 80.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 90.0 + noise, aNormal);\n\tcsm_Position.x += pDir.x * strength * 0.5;\n\tcsm_Position.z += strength * circleNum * noise * uHeight;\n\tcsm_Position.y += pDir.z * strength * 0.5;\n\tvIndex = aIndex;\n\tcsm_PointSize = 0.01*uScale;\n}\n",fragmentShader:"\nvarying vec2 vMapUv;\nvarying float vIndex;\nuniform float uTime;\nuniform vec3 baseColor;\nuniform sampler2D uPerlinTexture;\nvoid main() {\n\tvec3 whiteColor = vec3( 1.0,1.0,1.0);\n\tfloat selfIndex=mod(vIndex,720.0);\n\tfloat circleNum=(vIndex - selfIndex)/720.0;\n\tvec3 finalColor=mix(baseColor,diffuse,circleNum/5.0);\n\tfinalColor*=1.0;\n\tcsm_DiffuseColor = vec4( finalColor, opacity );\n}\n",uniforms:C,map:f(N)[0],alphaMap:f(N)[0],transparent:"",depthWrite:!1,blending:g,color:"#409eff",size:.1},null,8,["baseMaterial","map","alphaMap","blending"])],8,x)]))}});export{I as _};
