import{m as n,e,a as t,o as r,f as o}from"./@tresjs.yaBKiR-I1741309500666.js";import{P as i}from"./tweakpane.yDiyAAkA1741309500666.js";import{B as c,_ as a,l,s,r as u,V as f}from"./three.8tDGqmLF1741309500666.js";import{d as p,a3 as v,b as g,o as d,f as x,u as h,g as m,j as y,al as w,r as b,N as R,aj as C,ak as I}from"./@vue.NRI7TcgI1741309500666.js";import"./postprocessing.5pHDeDVF1741309500666.js";import"./@vueuse.7Aa9Vkmy1741309500666.js";var _="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";!function(n,e){const t=T,r=D();for(;;)try{if(417143===parseInt(t(444))/1+parseInt(t(453))/2+-parseInt(t(427))/3+parseInt(t(463))/4+parseInt(t(449))/5*(parseInt(t(423))/6)+-parseInt(t(455))/7*(parseInt(t(432))/8)+parseInt(t(458))/9*(-parseInt(t(443))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const M=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[T(417)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){M(this,(function(){const n=T,e=new RegExp(n(418)),t=new RegExp(n(451),"i"),r=A(n(461));e.test(r+n(416))&&t[n(456)](r+"input")?A():r("0")}))()}();const z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[T(417)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function D(){const n=["stateObject","warn","tiles","waterTexture",'{}.constructor("return this")( )',"setIndex","BufferAttribute","render","value","6753730nhkkan","274371LrYrti","debu","Mesh","causticTex","constructor","711640KVUClA","bind","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","toString","694422aZwazM","causticsTexture","21WXtFlY","test","log","9UrCIGU","counter","RawShaderMaterial","init","water","2669300fnHfpE","table","chain","apply","function *\\( *\\)","trace","uniforms","console","FrontSide","18RsqJgd","length","action","string","1811148wbOUIQ","setAttribute","light","gger","error","52424JbKpEL","while (true) {}"];return(D=function(){return n})()}function T(n,e){const t=D();return(T=function(n,e){return t[n-=416]})(n,e)}z(void 0,(function(){const n=T,e=function(){const n=T;let e;try{e=Function("return (function() "+n(438)+");")()}catch(t){e=window}return e}(),t=e[n(421)]=e[n(421)]||{},r=[n(457),n(435),"info",n(431),"exception",n(464),n(419)];for(let o=0;o<r[n(424)];o++){const e=z[n(448)].prototype.bind(z),i=r[o],c=t[i]||e;e.__proto__=z.bind(z),e[n(452)]=c[n(452)][n(450)](c),t[i]=e}}))();const L=p({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=T,o=t,i=new c,l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(428)]("position",new(a[r(440)])(l,3)),i[r(439)](new(a[r(440)])(s,1));const u=new(a[r(460)])({uniforms:{light:{value:o[r(429)]},tiles:{value:o[r(436)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:a[r(422)]}),f=new(a[r(446)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{const n=r;((n,e)=>{const t=r;u.uniforms[t(462)][t(442)]=n,u[t(420)][t(447)].value=e,p[t(442)][t(441)](f,v[t(442)])})(o[n(437)],o[n(454)])})),(n,e)=>null}});function A(n){function e(n){const t=T;if(typeof n===t(426))return function(n){}[t(448)](t(433))[t(417)](t(459));1!==(""+n/n)[t(424)]||n%20==0?function(){return!0}[t(448)](t(445)+t(430)).call(t(425)):function(){return!1}.constructor("debu"+t(430))[t(417)](t(434)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=j,r=O();for(;;)try{if(915342===-parseInt(t(205))/1+-parseInt(t(209))/2*(parseInt(t(201))/3)+parseInt(t(193))/4+-parseInt(t(163))/5+-parseInt(t(188))/6+parseInt(t(219))/7*(parseInt(t(214))/8)+parseInt(t(167))/9*(parseInt(t(218))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){F(this,(function(){const n=j,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(168),"i"),r=W(n(173));e[n(164)](r+"chain")&&t.test(r+"input")?W():r("0")}))()}();const E=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[j(187)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function j(n,e){const t=O();return(j=function(n,e){return t[n-=163]})(n,e)}function O(){const n=["1508235ZsjomR","test","info","uniforms","32109813zSUaHT","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","constructor","light","table","return (function() ","init","Mesh","BackSide","log","value","underwater","clear","while (true) {}","water","console","FrontSide","waterTexture","RawShaderMaterial","trace","apply","6102420YqjSwA","bind","pooRef","neg-y.jpg","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","3695312kLzTtZ","toString","pos-x.jpg","pos-z.jpg","gger","pos-y.jpg",'{}.constructor("return this")( )',"setRenderTarget","2010EEDIBv","prototype","length","stateObject","1203672qHLqxL","error","CubeTextureLoader","Color","3702yZlvpl","causticTex","__proto__","tiles","counter","372632SSegNj","setPath","causticsTexture","debu","10VQDIYm","28sUoAHi","render"];return(O=function(){return n})()}E(void 0,(function(){const n=j;let e;try{e=Function(n(172)+n(199)+");")()}catch(o){e=window}const t=e.console=e[n(182)]||{},r=[n(176),"warn",n(165),n(206),"exception",n(171),n(186)];for(let i=0;i<r[n(203)];i++){const e=E[n(169)][n(202)][n(189)](E),o=r[i],c=t[o]||e;e[n(211)]=E[n(189)](E),e[n(194)]=c[n(194)][n(189)](c),t[o]=e}}))();const S=p({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=j;let i,c;const l=r,s=l.geometry,u=(new(a[o(207)]))[o(215)](o(192)).load([o(195),"neg-x.jpg",o(198),o(191),o(196),"neg-z.jpg"]),f=([i,c]=v((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,c(),i),p=new(a[o(185)])({uniforms:{light:{value:l[o(170)]},tiles:{value:f},sky:{value:u},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),m=new(a[o(174)])(s,p),y=g(null),w=new(a[o(208)])("white"),{renderer:b,camera:R}=n(),{onLoop:C}=e();return C((()=>{const n=o;b[n(177)][n(200)](null),b[n(177)].setClearColor(w,1),b.value[n(179)](),p[n(166)][n(181)][n(177)]=l[n(184)],p[n(166)][n(210)][n(177)]=l.causticsTexture,p.side=a[n(183)],p[n(166)][n(178)][n(177)]=!0,b[n(177)][n(220)](m,R[n(177)]),p.side=a[n(175)],p[n(166)][n(178)].value=!1,b[n(177)].render(m,R[n(177)])})),(n,e)=>{const t=o;return d(),x(L,{tiles:h(f),light:n.light,waterTexture:n[t(184)],causticsTexture:n[t(216)],ref_key:t(190),ref:y},null,8,[t(212),t(170),t(184),"causticsTexture"])}}});function W(n){function e(n){const t=j;if("string"==typeof n)return function(n){}[t(169)](t(180)).apply(t(213));1!==(""+n/n)[t(203)]||n%20==0?function(){return!0}[t(169)]("debu"+t(197)).call("action"):function(){return!1}.constructor(t(217)+t(197)).apply(t(204)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=H,r=N();for(;;)try{if(824023===parseInt(t(143))/1+-parseInt(t(136))/2+-parseInt(t(137))/3+-parseInt(t(148))/4*(-parseInt(t(168))/5)+-parseInt(t(166))/6*(parseInt(t(129))/7)+-parseInt(t(152))/8+parseInt(t(142))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const P=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){P(this,(function(){const n=H,e=new RegExp(n(160)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=Z(n(154));e[n(134)](r+n(174))&&t[n(134)](r+n(172))?Z():r("0")}))()}();const k=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[H(128)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function H(n,e){const t=N();return(H=function(n,e){return t[n-=126]})(n,e)}k(void 0,(function(){const n=H,e=function(){const n=H;let e;try{e=Function(n(146)+n(158)+");")()}catch(t){e=window}return e}(),t=e[n(151)]=e[n(151)]||{},r=[n(177),"warn","info","error",n(156),n(164),n(173)];for(let o=0;o<r[n(165)];o++){const e=k[n(149)][n(150)].bind(k),i=r[o],c=t[i]||e;e[n(153)]=k.bind(k),e.toString=c[n(167)].bind(c),t[i]=e}}))();const V=p({__name:"caustics",props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=H,o=t,i=new(a[r(141)])(0,1,1,0,0,2e3),c=new(a[r(161)])(2,2,200,200),s=new(a[r(135)])(1024,1024),u=new l({uniforms:{light:{value:o.light},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),f=new(a[r(133)])(c,u),p=new(a[r(144)])(r(163)),{renderer:v}=n(),{onBeforeLoop:g}=e();return g((()=>{const n=r;f[n(169)][n(157)][n(155)][n(130)]=o[n(145)],v[n(130)][n(159)](s),v[n(130)].setClearColor(p,0),v.value.clear(),v[n(130)][n(139)](f,i)})),(n,e)=>{const t=r;return d(),x(w,null,{default:m((()=>[y(S,{waterTexture:n[t(145)],causticsTexture:h(s)[t(171)],light:n[t(138)],geometry:h(c)},null,8,[t(145),t(176),t(138),t(140)])])),_:1})}}});function Z(n){function e(n){const t=H;if(typeof n===t(170))return function(n){}[t(149)](t(127))[t(128)](t(162));1!==(""+n/n)[t(165)]||n%20==0?function(){return!0}[t(149)](t(147)+t(126))[t(175)](t(132)):function(){return!1}[t(149)](t(147)+t(126))[t(128)](t(131)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function N(){const n=["geometry","OrthographicCamera","47366676IElGDI","102580aSuFxL","Color","waterTexture","return (function() ","debu","4HpItsF","constructor","prototype","console","9186312uuNaIm","__proto__","init","water","exception","uniforms",'{}.constructor("return this")( )',"setRenderTarget","function *\\( *\\)","PlaneGeometry","counter","black","table","length","103494tAQgDs","toString","247190RhBQRR","material","string","texture","input","trace","chain","call","causticsTexture","log","gger","while (true) {}","apply","651GrQptN","value","stateObject","action","Mesh","test","WebGLRenderTarget","655146kMkKgJ","4532820xZuvnv","light","render"];return(N=function(){return n})()}const B=Y;!function(n,e){const t=Y,r=$();for(;;)try{if(458280===parseInt(t(168))/1+parseInt(t(129))/2+-parseInt(t(176))/3*(parseInt(t(157))/4)+parseInt(t(139))/5+parseInt(t(156))/6*(parseInt(t(126))/7)+-parseInt(t(145))/8+-parseInt(t(160))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const G=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Y(138)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){G(this,(function(){const n=Y,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(127),"i"),r=Q("init");e[n(175)](r+"chain")&&t[n(175)](r+n(167))?Q():r("0")}))()}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Y(138)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Y(n,e){const t=$();return(Y=function(n,e){return t[n-=125]})(n,e)}function $(){const n=["render","setY","radius","warn","trace","call","stateObject","13769YdgmvZ","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","Mesh","1518092CopESF","removeEventListener","value","toString","bind","setZ","error","texture","domElement","apply","3825145FdUZIQ","getBoundingClientRect","return (function() ","__proto__","WebGLRenderTarget","table","836272NuJOfQ","top","waterTexture","console","addEventListener","clientY","string","prototype","exception","constructor","FloatType","234KjmzCu","66088qWJUCg","light","length","11337858pyqQWu","lightFrontGeometry","waterSimulation","counter","count","log","width","input","353964ZjErrN","action","info","uniforms","intersectObject","RawShaderMaterial","height","test","24roVTmI","needsUpdate","gger","attributes","while (true) {}","OrthographicCamera","point","debu","material","getY"];return($=function(){return n})()}U(void 0,(function(){const n=Y,e=function(){const n=Y;let e;try{e=Function(n(141)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(148)]=e[n(148)]||{},r=[n(165),n(189),n(170),n(135),n(153),n(144),n(190)];for(let o=0;o<r[n(159)];o++){const e=U[n(154)][n(152)][n(133)](U),i=r[o],c=t[i]||e;e[n(142)]=U[n(133)](U),e[n(132)]=c[n(132)][n(133)](c),t[i]=e}}))();const q=p({__name:B(162),props:{light:{}},setup(t,{expose:r}){const o=B,i=new(a[o(181)])(0,1,1,0,0,2e3),c=new s(2,2),l=new(a[o(143)])(256,256,{type:a[o(155)]}),p=new(a[o(143)])(256,256,{type:a[o(155)]}),v=new(a[o(173)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),g=new(a[o(173)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),m=new(a[o(173)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),y=new(a[o(128)])(c,v),w=new(a[o(128)])(c,g),b=new u(c,m);let R=l;const C=(n,e)=>{const t=o,r=R,c=R===l?p:l;e[t(184)][t(171)][t(136)][t(131)]=r.texture,n.setRenderTarget(c),n[t(186)](e,i),R=c},{renderer:I,camera:M,raycaster:z}=n();I[o(131)].autoClear=!1;const{onBeforeLoop:D}=e();D((()=>{const n=o;var e,t;t=I[n(131)],C(t,b),e=I[n(131)],C(e,w)}));const T=(n,e,t,r)=>{const i=o;y[i(184)][i(171)].center[i(131)]=[n,e],y[i(184)][i(171)][i(188)][i(131)]=t,y[i(184)][i(171)].strength.value=r,C(I[i(131)],y)},L=new f,A=new s(2,2),F=A[o(179)].position;for(let n=0;n<F[o(164)];n++){const e=-F[o(185)](n);F[o(187)](n,0),F[o(134)](n,e)}F[o(177)]=!0;const E=new(a[o(128)])(A),j={handleEvent:n=>{const e=o,t=I[e(131)].domElement[e(140)](),r=t[e(166)],i=t[e(174)];L.x=2*(n.clientX-t.left)/r-1,L.y=2*-(n[e(150)]-t[e(146)])/i+1,z[e(131)].setFromCamera(L,M[e(131)]);const c=z[e(131)][e(172)](E);for(let o of c)T(o[e(182)].x,o[e(182)].z,.03,.04)}};return r({addDrop:T,mouseEvent:n=>{const e=o;n?I[e(131)].domElement[e(149)]("mousemove",j):I[e(131)][e(137)][e(130)]("mousemove",j)}}),(n,e)=>{const t=o;return d(),x(V,{lightFrontGeometry:h(c),waterTexture:h(R)[t(136)],light:n.light},null,8,[t(161),t(147),t(158)])}}});function Q(n){function e(n){const t=Y;if(typeof n===t(151))return function(n){}[t(154)](t(180))[t(138)](t(163));1!==(""+n/n)[t(159)]||n%20==0?function(){return!0}[t(154)](t(183)+"gger")[t(191)](t(169)):function(){return!1}[t(154)](t(183)+t(178))[t(138)](t(125)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const J=nn;!function(n,e){const t=nn,r=rn();for(;;)try{if(954181===parseInt(t(497))/1+parseInt(t(515))/2*(-parseInt(t(508))/3)+parseInt(t(519))/4+parseInt(t(486))/5*(parseInt(t(521))/6)+parseInt(t(489))/7*(parseInt(t(509))/8)+-parseInt(t(484))/9+-parseInt(t(494))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[nn(503)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){K(this,(function(){const n=nn,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(491),"i"),r=tn("init");e[n(511)](r+"chain")&&t[n(511)](r+n(504))?tn():r("0")}))()}();const X=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function nn(n,e){const t=rn();return(nn=function(n,e){return t[n-=481]})(n,e)}X(void 0,(function(){const n=nn;let e;try{e=Function(n(525)+n(487)+");")()}catch(o){e=window}const t=e.console=e.console||{},r=[n(522),n(485),"info",n(481),n(510),n(505),n(496)];for(let i=0;i<r[n(490)];i++){const e=X[n(517)].prototype[n(492)](X),o=r[i],c=t[o]||e;e[n(520)]=X[n(492)](X),e[n(524)]=c[n(524)][n(492)](c),t[o]=e}}))();const en=p({__name:J(499),setup(n){const e=J,t=b({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(493)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=g(null),l=new i;l[e(516)]({label:e(483),title:e(495)}).on(e(500),(()=>{const n=e;for(var t=0;t<10;t++)a[n(488)][n(482)](2*Math[n(512)]()-1,2*Math[n(512)]()-1,.03,1&t?.02:-.02)}));const s=g(!1);return l[e(502)](s,e(488),{label:"鼠标波纹"}).on(e(513),(n=>{const t=e;a.value[t(518)](n.value)})),(n,i)=>{const l=e;return d(),x(h(o),C(I(t)),{default:m((()=>[i[0]||(i[0]=R("TresPerspectiveCamera",{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),y(h(r)),y(q,{light:c,ref_key:l(498),ref:a},null,512)])),_:1},16)}}});function tn(n){function e(n){const t=nn;if(typeof n===t(501))return function(n){}[t(517)](t(507)).apply(t(506));1!==(""+n/n)[t(490)]||n%20==0?function(){return!0}[t(517)](t(514)+"gger").call(t(523)):function(){return!1}.constructor(t(514)+"gger")[t(503)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}function rn(){const n=["454378LPdVUf","addButton","constructor","mouseEvent","6232980FJcYDR","__proto__","156678XHhpim","log","action","toString","return (function() ","error","addDrop","点击按钮","6526332ETjyyk","warn","205eGKSMm",'{}.constructor("return this")( )',"value","5411189sWtLQo","length","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","bind","manual","15198700koRDil","随机增加波纹","trace","1387617FwYPhh","waterSimulationRef","realWater","click","string","addBinding","apply","input","table","counter","while (true) {}","21GueSej","8uNdbwE","exception","test","random","change","debu"];return(rn=function(){return n})()}export{en as default};
