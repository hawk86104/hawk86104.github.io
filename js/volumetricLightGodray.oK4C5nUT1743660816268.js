import{m as e,e as t,B as r,f as a,o as n}from"./@tresjs.zc7faK4J1743660816268.js";import"./index.wgv4wbeG1743660816268.js";import{n as i,b1 as l,V as o,bs as s,a3 as u,u as h,r as v,N as m,_ as d,aq as f,B as p,c,l as x,aT as g,g as _,b as T,M as D,t as M,q as B,X as S,ci as w,cj as U,aE as y,aF as b,ar as P,A as R,aJ as C}from"./three.2wx8FU0g1743660816268.js";import{d as F,y as E,v as j,a as k,a2 as A,a3 as z,B as W,o as O,H as I,m as N,u as L,b as $,w as G,N as H,J as q,a4 as V,j as J,g as X,F as Z,a7 as K,r as Q,f as Y,aj as ee,ak as te,al as re,M as ae,s as ne}from"./@vue.B5PFBfKs1743660816268.js";import{E as ie,R as le,B as oe,G as se,a as ue}from"./postprocessing.ApTwx-211743660816268.js";import"./@vueuse.jtbb8I7w1743660816268.js";import"./object-hash.6N1Uf8kA1743660816268.js";import"./@amap.c8pGcSIC1743660816268.js";import"./jszip.rGR265Ak1743660816268.js";const he=parseInt(u.replace(/\D+/g,""));class ve extends i{constructor(e=new o){super({uniforms:{inputBuffer:new l(null),depthBuffer:new l(null),resolution:new l(new o),texelSize:new l(new o),halfTexelSize:new l(new o),kernel:new l(0),scale:new l(1),cameraNear:new l(0),cameraFar:new l(1),minDepthThreshold:new l(0),maxDepthThreshold:new l(1),depthScale:new l(0),depthToBlurRatioBias:new l(.25)},fragmentShader:`#include <common>\n        #include <dithering_pars_fragment>      \n        uniform sampler2D inputBuffer;\n        uniform sampler2D depthBuffer;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          float depthFactor = 0.0;\n          \n          #ifdef USE_DEPTH\n            vec4 depth = texture2D(depthBuffer, vUv);\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n            depthFactor *= depthScale;\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\n          #endif\n          \n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\n          gl_FragColor = sum * 0.25 ;\n\n          #include <dithering_fragment>\n          #include <tonemapping_fragment>\n          #include <${he>=154?"colorspace_fragment":"encodings_fragment"}>\n        }`,vertexShader:"uniform vec2 texelSize;\n        uniform vec2 halfTexelSize;\n        uniform float kernel;\n        uniform float scale;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          vec2 uv = position.xy * 0.5 + 0.5;\n          vUv = uv;\n\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0);\n        }",blending:s,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}class me{constructor({resolution:e,width:t=500,height:r=500,minDepthThreshold:a=0,maxDepthThreshold:n=1,depthScale:i=0,depthToBlurRatioBias:l=.25}){this.renderToScreen=!1,this.renderTargetA=new h(e,e,{minFilter:v,magFilter:v,stencilBuffer:!1,depthBuffer:!1,type:m}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new ve,this.convolutionMaterial.setTexelSize(1/t,1/r),this.convolutionMaterial.setResolution(new o(t,r)),this.scene=new d,this.camera=new f,this.convolutionMaterial.uniforms.minDepthThreshold.value=a,this.convolutionMaterial.uniforms.maxDepthThreshold.value=n,this.convolutionMaterial.uniforms.depthScale.value=i,this.convolutionMaterial.uniforms.depthToBlurRatioBias.value=l,this.convolutionMaterial.defines.USE_DEPTH=i>0;const s=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),u=new Float32Array([0,0,2,0,0,2]),g=new p;g.setAttribute("position",new c(s,3)),g.setAttribute("uv",new c(u,2)),this.screen=new x(g,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,r){const a=this.scene,n=this.camera,i=this.renderTargetA,l=this.renderTargetB,o=this.convolutionMaterial,s=o.uniforms;s.depthBuffer.value=t.depthTexture;const u=o.kernel;let h,v,m,d=t;for(v=0,m=u.length-1;v<m;++v)h=0==(1&v)?i:l,s.kernel.value=u[v],s.inputBuffer.value=d.texture,e.setRenderTarget(h),e.render(a,n),d=h;s.kernel.value=u[v],s.inputBuffer.value=d.texture,e.setRenderTarget(this.renderToScreen?null:r),e.render(a,n)}}class de extends g{constructor(e={}){super(e),this._tDepth={value:null},this._distortionMap={value:null},this._tDiffuse={value:null},this._tDiffuseBlur={value:null},this._textureMatrix={value:null},this._hasBlur={value:!1},this._mirror={value:0},this._mixBlur={value:0},this._blurStrength={value:.5},this._minDepthThreshold={value:.9},this._maxDepthThreshold={value:1},this._depthScale={value:0},this._depthToBlurRatioBias={value:.25},this._distortion={value:1},this._mixContrast={value:1},this.setValues(e)}onBeforeCompile(e){e.defines?.USE_UV||(e.defines.USE_UV=""),e.uniforms.hasBlur=this._hasBlur,e.uniforms.tDiffuse=this._tDiffuse,e.uniforms.tDepth=this._tDepth,e.uniforms.distortionMap=this._distortionMap,e.uniforms.tDiffuseBlur=this._tDiffuseBlur,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mirror=this._mirror,e.uniforms.mixBlur=this._mixBlur,e.uniforms.mixStrength=this._blurStrength,e.uniforms.minDepthThreshold=this._minDepthThreshold,e.uniforms.maxDepthThreshold=this._maxDepthThreshold,e.uniforms.depthScale=this._depthScale,e.uniforms.depthToBlurRatioBias=this._depthToBlurRatioBias,e.uniforms.distortion=this._distortion,e.uniforms.mixContrast=this._mixContrast,e.vertexShader=`\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;\n      ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace("#include <project_vertex>","#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );"),e.fragmentShader=`\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDiffuseBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n\t\t\t  uniform float cameraFar;\n        uniform bool hasBlur;\n        uniform float mixBlur;\n        uniform float mirror;\n        uniform float mixStrength;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float mixContrast;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec4 my_vUv;\n        ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>","#include <emissivemap_fragment>\n\n      float distortionFactor = 0.0;\n      #ifdef USE_DISTORTION\n        distortionFactor = texture2D(distortionMap, vUv).r * distortion;\n      #endif\n\n      vec4 new_vUv = my_vUv;\n      new_vUv.x += distortionFactor;\n      new_vUv.y += distortionFactor;\n\n      vec4 base = texture2DProj(tDiffuse, new_vUv);\n      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\n\n      vec4 merge = base;\n\n      #ifdef USE_NORMALMAP\n        vec2 normal_uv = vec2(0.0);\n        vec4 normalColor = texture2D(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n        vec4 base_normal = texture2D(tDiffuse, normal_uv);\n        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\n        merge = base_normal;\n        blur = blur_normal;\n      #endif\n\n      float depthFactor = 0.0001;\n      float blurFactor = 0.0;\n\n      #ifdef USE_DEPTH\n        vec4 depth = texture2DProj(tDepth, new_vUv);\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n        depthFactor *= depthScale;\n        depthFactor = max(0.0001, min(1.0, depthFactor));\n\n        #ifdef USE_BLUR\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\n          merge = merge * min(1.0, depthFactor + 0.5);\n        #else\n          merge = merge * depthFactor;\n        #endif\n\n      #endif\n\n      float reflectorRoughnessFactor = roughness;\n      #ifdef USE_ROUGHNESSMAP\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n      #endif\n\n      #ifdef USE_BLUR\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n        merge = mix(merge, blur, blurFactor);\n      #endif\n\n      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);\n      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;\n      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;\n      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;\n\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);\n      ")}get tDiffuse(){return this._tDiffuse.value}set tDiffuse(e){this._tDiffuse.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tDiffuseBlur(){return this._tDiffuseBlur.value}set tDiffuseBlur(e){this._tDiffuseBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get hasBlur(){return this._hasBlur.value}set hasBlur(e){this._hasBlur.value=e}get mirror(){return this._mirror.value}set mirror(e){this._mirror.value=e}get mixBlur(){return this._mixBlur.value}set mixBlur(e){this._mixBlur.value=e}get mixStrength(){return this._blurStrength.value}set mixStrength(e){this._blurStrength.value=e}get minDepthThreshold(){return this._minDepthThreshold.value}set minDepthThreshold(e){this._minDepthThreshold.value=e}get maxDepthThreshold(){return this._maxDepthThreshold.value}set maxDepthThreshold(e){this._maxDepthThreshold.value=e}get depthScale(){return this._depthScale.value}set depthScale(e){this._depthScale.value=e}get depthToBlurRatioBias(){return this._depthToBlurRatioBias.value}set depthToBlurRatioBias(e){this._depthToBlurRatioBias.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}get mixContrast(){return this._mixContrast.value}set mixContrast(e){this._mixContrast.value=e}}const fe=["texture-matrix","mirror","t-diffuse","t-depth","t-diffuse-blur","has-blur","mix-strength","min-depth-threshold","max-depth-threshold","depth-scale","depth-to-blur-ratio-bias","distortion","distortionMap","mix-contrast","defines-USE_BLUR","defines-USE_DEPTH","defines-USE_DISTORTION"],pe=F({__name:"index",props:{resolution:{default:256},mixBlur:{default:0},mixStrength:{default:1},blur:{default:()=>[0,0]},mirror:{default:0},minDepthThreshold:{default:.9},maxDepthThreshold:{default:1},depthScale:{default:0},depthToBlurRatioBias:{default:.25},distortionMap:{},distortion:{default:1},mixContrast:{default:1},reflectorOffset:{default:0}},setup(r){const a=r;const{resolution:n,minDepthThreshold:i,maxDepthThreshold:l,depthScale:o,depthToBlurRatioBias:s,blur:u,mirror:d,mixBlur:f,mixStrength:p,distortion:c,distortionMap:x,mixContrast:g}=E(a),{camera:y,scene:b,renderer:P,extend:R}=e();R({MeshReflectorMaterial:de});const C=j(),F=j(),$=j(),G=j(),H=k((()=>"number"==typeof u.value?[u.value,u.value]:u.value)),q=k((()=>H.value[0]>0||H.value[1]>0)),V={reflectorPlane:new _,normal:new T,reflectorWorldPosition:new T,cameraWorldPosition:new T,rotationMatrix:new D,lookAtPosition:new T(0,0,-1),clipPlane:new M,view:new T,target:new T,q:new M,virtualCamera:new B,textureMatrix:new D};A((()=>{C.value?.texture.dispose();const e={minFilter:v,magFilter:v,type:m};C.value=new h(n.value,n.value,{...e,depthBuffer:!0,depthTexture:new S(n.value,n.value,w,U)}),F.value=new h(n.value,n.value,e),$.value=new me({resolution:n.value,width:H.value[0],height:H.value[1],minDepthThreshold:i.value,maxDepthThreshold:l.value,depthScale:o.value,depthToBlurRatioBias:s.value}),G.value={mirror:d,textureMatrix:V.textureMatrix,mixBlur:f,tDiffuse:C.value.texture,tDepth:C.value.depthTexture,tDiffuseBlur:C.value.texture,hasBlur:q,mixStrength:p,minDepthThreshold:i,maxDepthThreshold:l,depthScale:o,depthToBlurRatioBias:s,distortion:c,distortionMap:x.value,mixContrast:g,"defines-USE_BLUR":q.value?"":void 0,"defines-USE_DEPTH":o.value>0?"":void 0,"defines-USE_DISTORTION":x.value?"":void 0}}));const J=j(),{onLoop:X}=t();X((()=>{if(!(J.value&&P.value&&C.value&&y.value))return;const e=function(e,t){let r;return e.traverse((e=>{e.isMesh&&e.material&&e.material.uuid===t&&(r=e)})),r}(b.value,J.value.uuid);if(!e)return;e.visible=!1;const t=P.value.xr.enabled,r=P.value.shadowMap.autoUpdate;!function(e){if(V.reflectorWorldPosition.setFromMatrixPosition(e.matrixWorld),V.cameraWorldPosition.setFromMatrixPosition(y.value?.matrixWorld),V.rotationMatrix.extractRotation(e.matrixWorld),V.normal.set(0,0,1),V.normal.applyMatrix4(V.rotationMatrix),V.reflectorWorldPosition.addScaledVector(V.normal,a.reflectorOffset),V.view.subVectors(V.reflectorWorldPosition,V.cameraWorldPosition),V.view.dot(V.normal)>0)return;V.view.reflect(V.normal).negate(),V.view.add(V.reflectorWorldPosition),V.rotationMatrix.extractRotation(y.value?.matrixWorld),V.lookAtPosition.set(0,0,-1),V.lookAtPosition.applyMatrix4(V.rotationMatrix),V.lookAtPosition.add(V.cameraWorldPosition),V.target.subVectors(V.reflectorWorldPosition,V.lookAtPosition),V.target.reflect(V.normal).negate(),V.target.add(V.reflectorWorldPosition),V.virtualCamera.position.copy(V.view),V.virtualCamera.up.set(0,1,0),V.virtualCamera.up.applyMatrix4(V.rotationMatrix),V.virtualCamera.up.reflect(V.normal),V.virtualCamera.lookAt(V.target),V.virtualCamera.far=(y?.value).far,V.virtualCamera.updateMatrixWorld(),V.virtualCamera.projectionMatrix.copy((y?.value).projectionMatrix),V.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),V.textureMatrix.multiply(V.virtualCamera.projectionMatrix),V.textureMatrix.multiply(V.virtualCamera.matrixWorldInverse),V.textureMatrix.multiply(e.matrixWorld),V.reflectorPlane.setFromNormalAndCoplanarPoint(V.normal,V.reflectorWorldPosition),V.reflectorPlane.applyMatrix4(V.virtualCamera.matrixWorldInverse),V.clipPlane.set(V.reflectorPlane.normal.x,V.reflectorPlane.normal.y,V.reflectorPlane.normal.z,V.reflectorPlane.constant);const t=V.virtualCamera.projectionMatrix;V.q.x=(Math.sign(V.clipPlane.x)+t.elements[8])/t.elements[0],V.q.y=(Math.sign(V.clipPlane.y)+t.elements[9])/t.elements[5],V.q.z=-1,V.q.w=(1+t.elements[10])/t.elements[14],V.clipPlane.multiplyScalar(2/V.clipPlane.dot(V.q)),t.elements[2]=V.clipPlane.x,t.elements[6]=V.clipPlane.y,t.elements[10]=V.clipPlane.z+1,t.elements[14]=V.clipPlane.w}(e),P.value.shadowMap.autoUpdate=!1,P.value.setRenderTarget(C.value),P.value.autoClear||P.value.clear(),P.value.render(b.value,V.virtualCamera),$?.value?.render(P.value,C.value,F.value),P.value.xr.enabled=t,P.value.shadowMap.autoUpdate=r,e.visible=!0,P.value.setRenderTarget(null)}));const Z=z(),K=k((()=>{const e={};return Object.assign(e,a),Object.assign(e,Z.value),e}));return W((()=>{C?.value?.dispose(),F?.value?.dispose()})),(e,t)=>(O(),I("TresMeshReflectorMaterial",N({key:`key${G.value["defines-USE_BLUR"]}${G.value["defines-USE_DEPTH"]}${G.value["defines-USE_DISTORTION"]}`,ref_key:"materialRef",ref:J},K.value,{"texture-matrix":V.textureMatrix,mirror:L(d),"t-diffuse":C.value?.texture,"t-depth":C.value?.depthTexture,"t-diffuse-blur":F.value?.texture,"has-blur":q.value,"mix-strength":L(p),"min-depth-threshold":L(i),"max-depth-threshold":L(l),"depth-scale":L(o),"depth-to-blur-ratio-bias":L(s),distortion:L(c),distortionMap:L(x),"mix-contrast":L(g),"defines-USE_BLUR":q.value?"":void 0,"defines-USE_DEPTH":L(o)>0?"":void 0,"defines-USE_DISTORTION":L(x)?"":void 0}),null,16,fe))}});const ce=["object"],xe=F({__name:"index",props:{resolution:{default:256},near:{default:.1},far:{default:1e3},envMap:{default:null},fog:{default:null},frames:{default:1/0}},setup(r,{expose:a}){const n=r,{fbo:i,camera:l,update:o}=function({resolution:t=256,near:r=.1,far:a=1e3,envMap:n,fog:i}={}){const{renderer:l,scene:o}=e(),s=$(null),u=$(t),h=$(r),v=$(a),d=$(null);let f,p;return G((()=>u),(e=>{s.value?.dispose(),s.value=new y(e.value),s.value.texture.type=m}),{immediate:!0}),G([h,v,s],(([e,t,r])=>{r&&(d.value=new b(e,t,r))}),{immediate:!0}),W((()=>{s.value?.dispose()})),{fbo:s,camera:d,update:()=>{f=o.value.fog,p=o.value.background,o.value.background=n||p,o.value.fog=i||f,d.value?.update(l.value,o.value),o.value.fog=f,o.value.background=p}}}({resolution:n.resolution,near:n.near,far:n.far,envMap:n.envMap,fog:n.fog}),{onBeforeLoop:s}=t();let u=0;const h=$(null);return s((()=>{h.value&&(n.frames===1/0||u<n.frames)&&(h.value.visible=!1,o(),h.value.visible=!0,u++)})),a({texture:i.value?.texture}),(e,t)=>(O(),I("TresGroup",null,[H("primitive",{object:L(l)},null,8,ce),H("TresGroup",{ref_key:"rgRef",ref:h},[q(e.$slots,"default")],512)]))}}),ge=["map"],_e=["envMap"],Te=F({__name:"screen",async setup(e){let t,a;const n=$();n.value=([t,a]=V((()=>r("./plugins/visualArts/video/vlg.mp4",{loop:!0}))),t=await t,a(),t),n.value.colorSpace=P;const i=$(),l=$();G(i,(e=>{l.value=e.texture}));const o=$();return(e,t)=>(O(),I(Z,null,[H("TresMesh",{ref_key:"tmSceen",ref:o,position:[0,0,-16]},[t[0]||(t[0]=H("TresPlaneGeometry",{args:[16,10]},null,-1)),H("TresMeshBasicMaterial",{map:n.value},null,8,ge),t[1]||(t[1]=H("TresMesh",{scale:[16.05,10.05,1],position:[0,0,-.01]},[H("TresPlaneGeometry"),H("TresMeshBasicMaterial",{color:"black"})],-1))],512),J(L(xe),{ref_key:"cubeCameraRef",ref:i,position:[-3,-1,-5],resolution:256},{default:X((()=>[H("TresMesh",null,[t[2]||(t[2]=H("TresSphereGeometry",{args:[2,32,32]},null,-1)),H("TresMeshStandardMaterial",{metalness:1,roughness:.1,envMap:l.value},null,8,_e)])])),_:1},512)],64))}}),De=F({__name:"effectComposer",props:{screen:{}},setup(r){const a=r,{camera:n,renderer:i,scene:l,sizes:o}=e();let s=null,u=null;const h=[];A((()=>{if(o.width.value){const e=n.value;((e,t,r,a,n)=>{s=new ie(r,{frameBufferType:m,multisampling:8});const i=new le(e,t);s.addPass(i)})(l.value,e,i.value,o.width.value,o.height.value),(e=>{const t=new R({color:16768426,transparent:!0,fog:!1}),r=new C(.75,32,32),n=new x(r,t);n.frustumCulled=!1,n.matrixAutoUpdate=!1;const i=new se(e,K(a.screen),{blur:!0,decay:.8,exposure:.34});h.push(i)})(e),h.push(new oe({luminanceThreshold:0,mipmapBlur:!0,luminanceSmoothing:0,intensity:1})),u=new ue(e,...h),s.addPass(u)}}));const{onAfterLoop:v}=t();return v((()=>{s&&s.render()})),(e,t)=>null}}),Me=["rotation"],Be=F({__name:"volumetricLightGodray",setup(e){const t=Q({clearColor:"#050505",antialias:!1,renderMode:"manual"}),r=Q({enableDamping:!0}),i=$(null),l=$(null);return G((()=>i),(e=>{ne((()=>{e&&void 0!==e.value.$refs.tmSceen&&(l.value=e.value.$refs.tmSceen)}))}),{deep:!0}),(e,o)=>(O(),Y(L(a),N(t,{"window-size":""}),{default:X((()=>[o[1]||(o[1]=H("TresPerspectiveCamera",{position:[0,0,30],fov:45,near:.1,far:1e3},null,-1)),J(L(n),ee(te(r)),null,16),o[2]||(o[2]=H("TresAmbientLight",{intensity:.5},null,-1)),(O(),Y(re,null,{default:X((()=>[J(Te,{ref_key:"screenRef",ref:i},null,512)])),_:1})),H("TresMesh",{position:[0,-5.02,0],receiveShadow:"",rotation:[-Math.PI/2,0,0]},[o[0]||(o[0]=H("TresPlaneGeometry",{args:[50,50]},null,-1)),J(L(pe),{blur:[300,50],resolution:1024,mixBlur:1,mixStrength:100,roughness:1,depthScale:1.2,minDepthThreshold:.4,maxDepthThreshold:1.4,color:"#202020",metalness:.8})],8,Me),l.value?(O(),Y(De,{key:0,screen:l.value},null,8,["screen"])):ae("",!0)])),_:1},16))}});export{Be as default};
