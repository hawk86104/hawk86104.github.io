import{V as t,ad as e,B as o,a as r}from"./three.BsQyBKrV1719803971187.js";
/**
 * @description Loop Subdivision Surface
 * @about       Smooth subdivision surface modifier for use with three.js BufferGeometry.
 * @author      Stephens Nunnally <@stevinz>
 * @license     MIT - Copyright (c) 2022 Stephens Nunnally
 * @source      https://github.com/stevinz/three-subdivide
 */const i=new t,n=new t,c=new t,a=new t,s=new t,u=new t,f=new t,d=new t,l=new t,p=new t,m=new t,h=[new t,new t,new t],b=[new t,new t,new t],v=new e;class g{static modify(t,e=1,o={}){if(arguments.length>3&&console.warn("LoopSubdivision.modify() now uses a parameter object. See readme for more info!"),"object"!=typeof o&&(o={}),void 0===o.split&&(o.split=!0),void 0===o.uvSmooth&&(o.uvSmooth=!1),void 0===o.preserveEdges&&(o.preserveEdges=!1),void 0===o.flatOnly&&(o.flatOnly=!1),void 0===o.maxTriangles&&(o.maxTriangles=1/0),void 0===o.weight&&(o.weight=1),!isNaN(o.weight)&&isFinite(o.weight)||(o.weight=1),o.weight=Math.max(0,Math.min(1,o.weight)),!E(t))return t;let r=t.clone();if(o.split){const t=g.edgeSplit(r);r.dispose(),r=t}for(let i=0;i<e;i++){if(r.attributes.position.count/3<o.maxTriangles){let t;t=o.flatOnly?g.flat(r,o):g.smooth(r,o),r.groups.forEach((e=>{t.addGroup(4*e.start,4*e.count,e.materialIndex)})),r.dispose(),r=t}}return r}static edgeSplit(t){if(!E(t))return t;const e=null!==t.index?t.toNonIndexed():t.clone(),i=new o,s=x(e),l=e.attributes.position.count,p=e.getAttribute("position"),m=e.getAttribute("normal"),h={},b=[],g={},w=[];for(let o=0;o<l;o+=3){u.fromBufferAttribute(p,o+0),f.fromBufferAttribute(p,o+1),d.fromBufferAttribute(p,o+2),a.fromBufferAttribute(m,o);const t=A(u),e=A(f),r=A(d),i=v.set(u,f,d).getArea();if(w.push(!S(i,0)),!w[o/3]){b.push([]);continue}B(a,u,f,d);const n=A(a),c=["".concat(t,"_").concat(e,"_").concat(n),"".concat(e,"_").concat(t,"_").concat(n),"".concat(e,"_").concat(r,"_").concat(n),"".concat(r,"_").concat(e,"_").concat(n),"".concat(r,"_").concat(t,"_").concat(n),"".concat(t,"_").concat(r,"_").concat(n)],s=o/3;for(let o=0;o<c.length;o++)h[c[o]]||(h[c[o]]=[]),h[c[o]].push(s),g[c[o]]||(0!==o&&1!==o||(g[c[o]]=u.distanceTo(f)),2!==o&&3!==o||(g[c[o]]=f.distanceTo(d)),4!==o&&5!==o||(g[c[o]]=d.distanceTo(u)));b.push([c[0],c[2],c[4]])}s.forEach((t=>{const o=e.getAttribute(t);if(!o)return;const n=T(o,t);i.setAttribute(t,new r(n,o.itemSize))}));const y=e.morphAttributes;for(const o in y){const t=[],e=y[o];for(let i=0,n=e.length;i<n;i++){if(e[i].count!==l)continue;const n=T(e[i],o,!0);t.push(new r(n,e[i].itemSize))}i.morphAttributes[o]=t}return i.morphTargetsRelative=e.morphTargetsRelative,e.dispose(),i;function T(t,o,r=!1){const a=l*t.itemSize*4,s=new t.array.constructor(a),p="position"===o&&!r&&e.groups.length>0;let m,v,S=0,y=0,A=t.itemSize;for(let E=0;E<l;E+=3){if(!w[E/3]){y+=3;continue}u.fromBufferAttribute(t,E+0),f.fromBufferAttribute(t,E+1),d.fromBufferAttribute(t,E+2);const o=E/3,r=b[o][0],a=b[o][1],l=b[o][2],B=h[r].length,x=h[a].length,T=h[l].length,_=3*S/A/3;if(0===B+x+T-3)z(s,S,A,u,f,d),S+=3*A;else{const t=g[r],e=g[a],o=g[l];(t>e||x<=1)&&(t>o||T<=1)&&B>1?(n.copy(u).add(f).divideScalar(2),T>1?(c.copy(d).add(u).divideScalar(2),z(s,S,A,u,n,c),S+=3*A,z(s,S,A,n,d,c),S+=3*A):(z(s,S,A,u,n,d),S+=3*A),x>1?(c.copy(f).add(d).divideScalar(2),z(s,S,A,n,f,c),S+=3*A,z(s,S,A,c,d,n),S+=3*A):(z(s,S,A,f,d,n),S+=3*A)):(e>o||T<=1)&&x>1?(n.copy(f).add(d).divideScalar(2),B>1?(c.copy(u).add(f).divideScalar(2),z(s,S,A,n,c,f),S+=3*A,z(s,S,A,c,n,u),S+=3*A):(z(s,S,A,f,n,u),S+=3*A),T>1?(c.copy(d).add(u).divideScalar(2),z(s,S,A,n,d,c),S+=3*A,z(s,S,A,c,u,n),S+=3*A):(z(s,S,A,d,u,n),S+=3*A)):T>1?(n.copy(d).add(u).divideScalar(2),x>1?(c.copy(f).add(d).divideScalar(2),z(s,S,A,d,n,c),S+=3*A,z(s,S,A,n,f,c),S+=3*A):(z(s,S,A,d,n,f),S+=3*A),B>1?(c.copy(u).add(f).divideScalar(2),z(s,S,A,u,c,n),S+=3*A,z(s,S,A,c,f,n),S+=3*A):(z(s,S,A,u,f,n),S+=3*A)):(z(s,S,A,u,f,d),S+=3*A)}p&&e.groups.forEach((t=>{t.start===E-y&&(void 0!==m&&void 0!==v&&i.addGroup(m,_-m,v),m=_,v=t.materialIndex)})),y=0}const B=3*S/A,x=new t.array.constructor(B);for(let e=0;e<B;e++)x[e]=s[e];return p&&void 0!==m&&void 0!==v&&i.addGroup(m,3*S/A/3-m,v),x}}static flat(t,e={}){if(!E(t))return t;const r=null!==t.index?t.toNonIndexed():t.clone(),i=new o,n=x(r),c=r.attributes.position.count;n.forEach((t=>{const o=r.getAttribute(t);o&&i.setAttribute(t,g.flatAttribute(o,c,e))}));const a=r.morphAttributes;for(const o in a){const t=[],r=a[o];for(let o=0,i=r.length;o<i;o++)r[o].count===c&&t.push(g.flatAttribute(r[o],c,e));i.morphAttributes[o]=t}return i.morphTargetsRelative=r.morphTargetsRelative,r.dispose(),i}static flatAttribute(t,e,o={}){const i=e*t.itemSize*4,n=new t.array.constructor(i);let c=0,a=t.itemSize;for(let r=0;r<e;r+=3)u.fromBufferAttribute(t,r+0),f.fromBufferAttribute(t,r+1),d.fromBufferAttribute(t,r+2),l.copy(u).add(f).divideScalar(2),p.copy(f).add(d).divideScalar(2),m.copy(d).add(u).divideScalar(2),z(n,c,a,u,l,m),c+=3*a,z(n,c,a,f,p,l),c+=3*a,z(n,c,a,d,m,p),c+=3*a,z(n,c,a,l,p,m),c+=3*a;return new r(n,t.itemSize)}static smooth(t,e={}){if("object"!=typeof e&&(e={}),void 0===e.uvSmooth&&(e.uvSmooth=!1),void 0===e.preserveEdges&&(e.preserveEdges=!1),!E(t))return t;const n=null!==t.index?t.toNonIndexed():t.clone(),c=g.flat(n,e),a=new o,u=x(n),f=n.attributes.position.count,d=n.getAttribute("position"),v=c.getAttribute("position"),w={},S={},y={},B={};function T(t,e,o){S[t]||(S[t]={}),S[t][e]||(S[t][e]=[]),S[t][e].push(o)}function _(t,e){y[t]||(y[t]=[]),y[t].push(e)}function G(t,e){B[t]||(B[t]=new Set),B[t].add(e)}for(let o=0;o<f;o+=3){const t=A(b[0].fromBufferAttribute(d,o+0)),e=A(b[1].fromBufferAttribute(d,o+1)),r=A(b[2].fromBufferAttribute(d,o+2));T(t,e,o+1),T(t,r,o+2),T(e,t,o+0),T(e,r,o+2),T(r,t,o+0),T(r,e,o+1),l.copy(b[0]).add(b[1]).divideScalar(2),p.copy(b[1]).add(b[2]).divideScalar(2),m.copy(b[2]).add(b[0]).divideScalar(2);const i=A(l),n=A(p),c=A(m);_(i,o+2),_(n,o+0),_(c,o+1),G(t,i),G(t,c),G(e,i),G(e,n),G(r,n),G(r,c)}for(let o=0;o<c.attributes.position.count;o++){const t=A(s.fromBufferAttribute(v,o));w[t]||(w[t]=[]),w[t].push(o)}u.forEach((t=>{const e=n.getAttribute(t),o=c.getAttribute(t);if(void 0===e||void 0===o)return;const i=I(t,e,o);a.setAttribute(t,new r(i,o.itemSize))}));const j=n.morphAttributes;for(const o in j){const t=[],i=j[o];for(let n=0,c=i.length;n<c;n++){if(i[n].count!==f)continue;const c=i[n],a=g.flatAttribute(i[n],i[n].count,e),s=I(o,c,a);t.push(new r(s,a.itemSize))}a.morphAttributes[o]=t}return a.morphTargetsRelative=n.morphTargetsRelative,c.dispose(),n.dispose(),a;function I(t,o,r){const n=c.attributes.position.count*r.itemSize,a=new o.array.constructor(n);let u=0;for(let p=0;p<c.attributes.position.count;p+=3){for(let n=0;n<3;n++)if("uv"!==t||e.uvSmooth)if("normal"===t){h[n].fromBufferAttribute(v,p+n);const t=A(h[n]),e=w[t],o=Object.keys(e).length,c=.75/o,a=1-c*o;b[n].fromBufferAttribute(r,p+n),b[n].multiplyScalar(a),e.forEach((t=>{i.fromBufferAttribute(r,t),i.multiplyScalar(c),b[n].add(i)}))}else{b[n].fromBufferAttribute(r,p+n),h[n].fromBufferAttribute(v,p+n);const t=A(h[n]),c=S[t],a=y[t];if(c){if(e.preserveEdges){const e=B[t];let o=!0;for(const t of e)y[t].length%2!=0&&(o=!1);if(!o)continue}const r=Object.keys(c).length,a=1/r*(5/8-Math.pow(3/8+1/4*Math.cos(2*Math.PI/r),2)),u=(f=1/r/r,d=a,(1-(l=e.weight))*f+l*d),p=1-u*r;b[n].multiplyScalar(p);for(let t in c){const e=c[t];i.set(0,0,0);for(let t=0;t<e.length;t++)i.add(s.fromBufferAttribute(o,e[t]));i.divideScalar(e.length),i.multiplyScalar(u),b[n].add(i)}}else if(a&&2===a.length){const t=a.length,e=.125,r=1-e*t;b[n].multiplyScalar(r),a.forEach((t=>{i.fromBufferAttribute(o,t),i.multiplyScalar(e),b[n].add(i)}))}}else b[n].fromBufferAttribute(r,p+n);z(a,u,r.itemSize,b[0],b[1],b[2]),u+=3*r.itemSize}var f,d,l;return a}}}const w=Math.pow(10,2);function S(t,e,o=1e-5){return t<e+o&&t>e-o}function y(t,e=w){let o=(r=t*e)+(r>0?.5:-.5)<<0;var r;return 0==o&&(o=0),"".concat(o)}function A(t,e=w){return"".concat(y(t.x,e),",").concat(y(t.y,e),",").concat(y(t.z,e))}function B(t,e,o,r){s.subVectors(e,o),t.subVectors(o,r),t.cross(s).normalize()}function x(t){const e=Object.keys(t.attributes);return Array.from(new Set(["position","normal","uv"].concat(e)))}function z(t,e,o,r,i,n){o>=1&&(t[e+0+0*o]=r.x,t[e+0+1*o]=i.x,t[e+0+2*o]=n.x),o>=2&&(t[e+1+0*o]=r.y,t[e+1+1*o]=i.y,t[e+1+2*o]=n.y),o>=3&&(t[e+2+0*o]=r.z,t[e+2+1*o]=i.z,t[e+2+2*o]=n.z),o>=4&&(t[e+3+0*o]=r.w,t[e+3+1*o]=i.w,t[e+3+2*o]=n.w)}function E(t){return void 0===t?(console.warn("LoopSubdivision: Geometry provided is undefined"),!1):t.isBufferGeometry?void 0===t.attributes.position?(console.warn("LoopSubdivision: Geometry provided missing required 'position' attribute"),!1):(void 0===t.attributes.normal&&t.computeVertexNormals(),!0):(console.warn("LoopSubdivision: Geometry provided is not 'BufferGeometry' type"),!1)}export{g as L};
