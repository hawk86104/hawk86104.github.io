import{o as t}from"./index.Crdf3MNx1763540743861.js";import{u as e}from"./colorList.DbCLsRg71763540743861.js";import{P as o}from"./tweakpane.CqZAnw7f1763540743861.js";import{d as n,r,a8 as a,w as l,H as i,o as c,J as s,ac as d,ao as u}from"./@vue.Co_gxueH1763540743861.js";import{r as p,ag as m}from"./three.rXKzP9fQ1763540743861.js";const x=["rotate"],S=["args"],f=n({__name:"secondPass",props:{rtTexture:{default:{texture:null}},boxSize:{}},async setup(n){let f,h;const v=r({steps:156,alphaCorrection:7.7,ratio:1}),g=new o;g.addBinding(v,"steps",{label:"循环次数",min:1,max:300,step:1}),g.addBinding(v,"alphaCorrection",{label:"亮度",min:0,max:10,step:.1}),g.addBinding(v,"ratio",{label:"对比度",min:0,max:1,step:.1});const C=e(),b=n,P=([f,h]=a(()=>t("./plugins/tvtVolumeRendering/rawData/eyeResult256.png")),f=await f,h(),f);P.generateMipmaps=!1,P.minFilter=p,P.magFilter=p;const D={vertexShader:"varying vec3 worldSpaceCoords;\nvarying vec4 projectedCoords;\n\nuniform float boxWidth;\nuniform float boxHeight;\nuniform float boxDepth;\n\nvoid main()\n{\n\tworldSpaceCoords=(modelMatrix*vec4(position+vec3(boxWidth/2.,boxHeight/2.,boxDepth/2.),1.)).xyz;\n\tgl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\n\tprojectedCoords=projectionMatrix*modelViewMatrix*vec4(position,1.);\n}",fragmentShader:"varying vec3 worldSpaceCoords;\nvarying vec4 projectedCoords;\nuniform sampler2D tex,cubeTex,transferTex;\nuniform float steps;\nuniform float alphaCorrection;\nuniform float boxWidth;\nuniform float boxHeight;\nuniform float boxDepth;\nuniform float uRatio;\n\nconst int MAX_STEPS=887;\n\nfloat linearScale(float domainStart,float domainEnd,float rangeStart,float rangeEnd,float value){\n\treturn((rangeEnd-rangeStart)*(value-domainStart))/(domainEnd-domainStart)+rangeStart;\n}\n\nconst float slicesPerSide=16.;\nconst float zDepth=slicesPerSide*slicesPerSide-1.;\n\nvec4 sampleAs3DTexture(vec3 texCoord)\n{\n\ttexCoord.x=linearScale(0.,boxWidth,0.,1.,texCoord.x);\n\ttexCoord.y=linearScale(0.,boxHeight,0.,1.,texCoord.y);\n\t\n\tvec4 colorSlice1,colorSlice2;\n\tvec2 texCoordSlice1,texCoordSlice2;\n\t\n\t\n\t\n\tfloat zSliceNumber1=floor(texCoord.z*zDepth);\n\t\n\t\n\tfloat zSliceNumber2=min(zSliceNumber1+1.,zDepth);\n\t\n\t\n\t\n\ttexCoord.xy/=slicesPerSide;\n\t\n\ttexCoordSlice1=texCoordSlice2=texCoord.xy;\n\t\n\t\n\ttexCoordSlice1.x+=(mod(zSliceNumber1,slicesPerSide)/slicesPerSide);\n\ttexCoordSlice1.y+=floor((zDepth-zSliceNumber1)/slicesPerSide)/slicesPerSide;\n\t\n\ttexCoordSlice2.x+=(mod(zSliceNumber2,slicesPerSide)/slicesPerSide);\n\ttexCoordSlice2.y+=floor((zDepth-zSliceNumber2)/slicesPerSide)/slicesPerSide;\n\t\n\t\n\t\n\tcolorSlice1=texture2D(cubeTex,texCoordSlice1);\n\tcolorSlice2=texture2D(cubeTex,texCoordSlice2);\n\t\n\t\n\tcolorSlice1.rgb=texture2D(transferTex,vec2(colorSlice1.a,1.)).rgb;\n\tcolorSlice2.rgb=texture2D(transferTex,vec2(colorSlice2.a,1.)).rgb;\n\t\n\t\n\tfloat zDifference=mod(texCoord.z*zDepth,1.);\n\t\n\t\n\treturn mix(colorSlice1,colorSlice2,zDifference);\n}\n\nvoid main(void){\n\t\n\t\n\tvec2 texc=vec2(((projectedCoords.x/projectedCoords.w)+1.)/2.,\n\t((projectedCoords.y/projectedCoords.w)+1.)/2.);\n\t\n\t\n\tvec3 backPos=texture2D(tex,texc).xyz;\n\t\n\t\n\tvec3 frontPos=worldSpaceCoords;\n\t\n\t\n\t\n\tif((backPos.x==0.)&&(backPos.y==0.))\n\t{\n\t\tgl_FragColor=vec4(0.);\n\t\treturn;\n\t}\n\t\n\t\n\tvec3 dir=backPos-frontPos;\n\t\n\tfloat rayLength=length(dir);\n\t\n\t\n\tfloat delta=1./steps;\n\t\n\t\n\tvec3 deltaDirection=normalize(dir)*delta;\n\tfloat deltaDirectionLength=length(deltaDirection);\n\t\n\t\n\tvec3 currentPosition=frontPos;\n\t\n\t\n\tvec4 accumulatedColor=vec4(.0,.0,.0,uRatio);\n\t\n\t\n\tfloat accumulatedAlpha=0.;\n\t\n\t\n\tfloat accumulatedLength=0.;\n\t\n\t\n\t\n\tfloat alphaScaleFactor=25.6*delta;\n\t\n\tvec4 colorSample;\n\tfloat alphaSample;\n\t\n\t\n\tfor(int i=0;i<MAX_STEPS;i++)\n\t{\n\t\t\n\t\tcolorSample=sampleAs3DTexture(currentPosition);\n\t\t\n\t\t\n\t\talphaSample=colorSample.a*alphaCorrection;\n\t\t\n\t\t\n\t\talphaSample*=(1.-accumulatedAlpha);\n\t\t\n\t\t\n\t\talphaSample*=alphaScaleFactor;\n\t\t\n\t\t\n\t\taccumulatedColor+=colorSample*alphaSample;\n\t\t\n\t\t\n\t\taccumulatedAlpha+=alphaSample;\n\t\t\n\t\t\n\t\tcurrentPosition+=deltaDirection;\n\t\taccumulatedLength+=deltaDirectionLength;\n\t\t\n\t\t\n\t\tif(accumulatedLength>=rayLength||accumulatedAlpha>=1.)\n\t\tbreak;\n\t}\n\t\n\tgl_FragColor=accumulatedColor;\n\t\n}",side:m,uniforms:{tex:{value:b.rtTexture.texture},cubeTex:{value:P},transferTex:{value:null},steps:{value:v.steps},alphaCorrection:{value:v.alphaCorrection},boxWidth:{value:b.boxSize[0]},boxHeight:{value:b.boxSize[1]},boxDepth:{value:b.boxSize[2]},uRatio:{value:v.ratio}}};return l(()=>C.colorsStops,()=>{D.uniforms.transferTex.value=C.updateTransferFunction()},{deep:!0,immediate:!0}),l(()=>[v.steps,v.alphaCorrection,v.ratio],([t,e,o])=>{D.uniforms.steps.value=t,D.uniforms.alphaCorrection.value=e,D.uniforms.uRatio.value=o}),(t,e)=>(c(),i("TresMesh",{rotate:[0,Math.PI/2,0]},[s("TresBoxGeometry",{args:n.boxSize},null,8,S),s("TresShaderMaterial",d(u(D)),null,16)],8,x))}});export{f as _};
