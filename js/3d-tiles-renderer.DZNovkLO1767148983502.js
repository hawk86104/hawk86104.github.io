const Rs="[0-9A-Za-z-]+",Ts=`(?:\\+(${Rs}(?:\\.${Rs})*))`,st="0|[1-9]\\d*",Lt="[0-9]+",An="\\d*[a-zA-Z-][a-zA-Z0-9-]*",Cs=`(?:${Lt}|${An})`,_i=`(?:-?(${Cs}(?:\\.${Cs})*))`,vs=`(?:${st}|${An})`,Ln=`(?:-(${vs}(?:\\.${vs})*))`,zt=`${st}|x|X|\\*`,Ve=`[v=\\s]*(${zt})(?:\\.(${zt})(?:\\.(${zt})(?:${Ln})?${Ts}?)?)?`,bi=`^\\s*(${Ve})\\s+-\\s+(${Ve})\\s*$`,xi=`(${Lt})\\.(${Lt})\\.(${Lt})`,wi=`[v=\\s]*${xi}${_i}?${Ts}?`,_s="((?:<|>)?=?)",Mi=`(\\s*)${_s}\\s*(${wi}|${Ve})`,Dn="(?:~>?)",Si=`(\\s*)${Dn}\\s+`,In="(?:\\^)",Ei=`(\\s*)${In}\\s+`,Pi="(<|>)?=?\\s*\\*",Ri=`^${In}${Ve}$`,Ci=`(${st})\\.(${st})\\.(${st})`,vi=`v?${Ci}${Ln}?${Ts}?`,Ai=`^${Dn}${Ve}$`,Li=`^${_s}\\s*${Ve}$`,Di=`^${_s}\\s*(${vi})$|^$`,Ii="^\\s*>=\\s*0.0.0\\s*$";function ie(c){return new RegExp(c)}function V(c){return!c||c.toLowerCase()==="x"||c==="*"}function Fn(...c){return e=>c.reduce((t,s)=>s(t),e)}function As(c){return c.match(ie(Di))}function Ls(c,e,t,s){const n=`${c}.${e}.${t}`;return s?`${n}-${s}`:n}function Fi(c){return c.replace(ie(bi),(e,t,s,n,i,r,a,o,l,h,u,d)=>(V(s)?t="":V(n)?t=`>=${s}.0.0`:V(i)?t=`>=${s}.${n}.0`:t=`>=${t}`,V(l)?o="":V(h)?o=`<${+l+1}.0.0-0`:V(u)?o=`<${l}.${+h+1}.0-0`:d?o=`<=${l}.${h}.${u}-${d}`:o=`<=${o}`,`${t} ${o}`.trim()))}function Oi(c){return c.replace(ie(Mi),"$1$2$3")}function Ni(c){return c.replace(ie(Si),"$1~")}function Ui(c){return c.replace(ie(Ei),"$1^")}function ki(c){return c.trim().split(/\s+/).map(e=>e.replace(ie(Ri),(t,s,n,i,r)=>V(s)?"":V(n)?`>=${s}.0.0 <${+s+1}.0.0-0`:V(i)?s==="0"?`>=${s}.${n}.0 <${s}.${+n+1}.0-0`:`>=${s}.${n}.0 <${+s+1}.0.0-0`:r?s==="0"?n==="0"?`>=${s}.${n}.${i}-${r} <${s}.${n}.${+i+1}-0`:`>=${s}.${n}.${i}-${r} <${s}.${+n+1}.0-0`:`>=${s}.${n}.${i}-${r} <${+s+1}.0.0-0`:s==="0"?n==="0"?`>=${s}.${n}.${i} <${s}.${n}.${+i+1}-0`:`>=${s}.${n}.${i} <${s}.${+n+1}.0-0`:`>=${s}.${n}.${i} <${+s+1}.0.0-0`)).join(" ")}function zi(c){return c.trim().split(/\s+/).map(e=>e.replace(ie(Ai),(t,s,n,i,r)=>V(s)?"":V(n)?`>=${s}.0.0 <${+s+1}.0.0-0`:V(i)?`>=${s}.${n}.0 <${s}.${+n+1}.0-0`:r?`>=${s}.${n}.${i}-${r} <${s}.${+n+1}.0-0`:`>=${s}.${n}.${i} <${s}.${+n+1}.0-0`)).join(" ")}function $i(c){return c.split(/\s+/).map(e=>e.trim().replace(ie(Li),(t,s,n,i,r,a)=>{const o=V(n),l=o||V(i),h=l||V(r);return s==="="&&h&&(s=""),a="",o?s===">"||s==="<"?"<0.0.0-0":"*":s&&h?(l&&(i=0),r=0,s===">"?(s=">=",l?(n=+n+1,i=0,r=0):(i=+i+1,r=0)):s==="<="&&(s="<",l?n=+n+1:i=+i+1),s==="<"&&(a="-0"),`${s+n}.${i}.${r}${a}`):l?`>=${n}.0.0${a} <${+n+1}.0.0-0`:h?`>=${n}.${i}.0${a} <${n}.${+i+1}.0-0`:t})).join(" ")}function Bi(c){return c.trim().replace(ie(Pi),"")}function Vi(c){return c.trim().replace(ie(Ii),"")}function Dt(c,e){return c=+c||c,e=+e||e,c>e?1:c===e?0:-1}function Gi(c,e){const{preRelease:t}=c,{preRelease:s}=e;if(t===void 0&&s)return 1;if(t&&s===void 0)return-1;if(t===void 0&&s===void 0)return 0;for(let n=0,i=t.length;n<=i;n++){const r=t[n],a=s[n];if(r!==a)return r===void 0&&a===void 0?0:r?a?Dt(r,a):-1:1}return 0}function ht(c,e){return Dt(c.major,e.major)||Dt(c.minor,e.minor)||Dt(c.patch,e.patch)||Gi(c,e)}function $t(c,e){return c.version===e.version}function Hi(c,e){switch(c.operator){case"":case"=":return $t(c,e);case">":return ht(c,e)<0;case">=":return $t(c,e)||ht(c,e)<0;case"<":return ht(c,e)>0;case"<=":return $t(c,e)||ht(c,e)>0;case void 0:return!0;default:return!1}}function ji(c){return Fn(ki,zi,$i,Bi)(c)}function Wi(c){return Fn(Fi,Oi,Ni,Ui)(c.trim()).split(/\s+/).join(" ")}function Ki(c,e){if(!c)return!1;const n=Wi(e).split(" ").map(d=>ji(d)).join(" ").split(/\s+/).map(d=>Vi(d)),i=As(c);if(!i)return!1;const[,r,,a,o,l,h]=i,u={version:Ls(a,o,l,h),major:a,minor:o,patch:l,preRelease:h?.split(".")};for(const d of n){const p=As(d);if(!p)return!1;const[,f,,m,y,T,_]=p,M={operator:f,version:Ls(m,y,T,_),major:m,minor:y,patch:T,preRelease:_?.split(".")};if(!Hi(M,u))return!1}return!0}const Ds={},ds={vue:{get:()=>()=>Is(new URL("__federation_shared_vue.DSi1-QsC1767148983502.js",import.meta.url).href),import:!0},three:{get:()=>()=>Is(new URL("__federation_shared_three.Cy9ReItZ1767148983502.js",import.meta.url).href),import:!0}},It=Object.create(null);async function at(c,e="default"){return It[c]?new Promise(t=>t(It[c])):await qi(c,e)||Xi(c)}async function Is(c){return Ds[c]??=import(c),Ds[c]}async function qi(c,e){let t=null;if(globalThis?.__federation_shared__?.[e]?.[c]){const s=globalThis.__federation_shared__[e][c],n=ds[c]?.requiredVersion;if(!!n){const r=Object.keys(s).find(a=>Ki(a,n));r?t=await(await s[r].get())():console.log(`provider support ${c}(${r}) is not satisfied requiredVersion(\${moduleMap[name].requiredVersion})`)}else{const r=Object.keys(s)[0];t=await(await s[r].get())()}}if(t)return On(t,c)}async function Xi(c){if(ds[c]?.import){let e=await(await ds[c].get())();return On(e,c)}else console.error("consumer config import=false,so cant use callback shared module")}function On(c,e){return typeof c.default=="function"?(Object.keys(c).forEach(t=>{t!=="default"&&(c.default[t]=c[t])}),It[e]=c.default,c.default):(c.default&&(c=Object.assign({},c.default,c)),It[e]=c,c)}const{BufferAttribute:Nn,BufferGeometry:Zi,Float32BufferAttribute:Ca,InstancedBufferAttribute:va,InterleavedBuffer:Aa,InterleavedBufferAttribute:La,TriangleFanDrawMode:Fs,TriangleStripDrawMode:Yi,TrianglesDrawMode:Qi,Vector3:fe}=await at("three");function Da(c,e=!1){const t=c[0].index!==null,s=new Set(Object.keys(c[0].attributes)),n=new Set(Object.keys(c[0].morphAttributes)),i={},r={},a=c[0].morphTargetsRelative,o=new Zi;let l=0;for(let h=0;h<c.length;++h){const u=c[h];let d=0;if(t!==(u.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const p in u.attributes){if(!s.has(p))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+'. All geometries must have compatible attributes; make sure "'+p+'" attribute exists among all geometries, or in none of them.'),null;i[p]===void 0&&(i[p]=[]),i[p].push(u.attributes[p]),d++}if(d!==s.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". Make sure all geometries have the same number of attributes."),null;if(a!==u.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const p in u.morphAttributes){if(!n.has(p))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+".  .morphAttributes must be consistent throughout all geometries."),null;r[p]===void 0&&(r[p]=[]),r[p].push(u.morphAttributes[p])}if(e){let p;if(t)p=u.index.count;else if(u.attributes.position!==void 0)p=u.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". The geometry must have either an index or a position attribute"),null;o.addGroup(l,p,h),l+=p}}if(t){let h=0;const u=[];for(let d=0;d<c.length;++d){const p=c[d].index;for(let f=0;f<p.count;++f)u.push(p.getX(f)+h);h+=c[d].attributes.position.count}o.setIndex(u)}for(const h in i){const u=Os(i[h]);if(!u)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+h+" attribute."),null;o.setAttribute(h,u)}for(const h in r){const u=r[h][0].length;if(u===0)break;o.morphAttributes=o.morphAttributes||{},o.morphAttributes[h]=[];for(let d=0;d<u;++d){const p=[];for(let m=0;m<r[h].length;++m)p.push(r[h][m][d]);const f=Os(p);if(!f)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+h+" morphAttribute."),null;o.morphAttributes[h].push(f)}}return o}function Os(c){let e,t,s,n=-1,i=0;for(let l=0;l<c.length;++l){const h=c[l];if(e===void 0&&(e=h.array.constructor),e!==h.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(t===void 0&&(t=h.itemSize),t!==h.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(s===void 0&&(s=h.normalized),s!==h.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(n===-1&&(n=h.gpuType),n!==h.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;i+=h.count*t}const r=new e(i),a=new Nn(r,t,s);let o=0;for(let l=0;l<c.length;++l){const h=c[l];if(h.isInterleavedBufferAttribute){const u=o/t;for(let d=0,p=h.count;d<p;d++)for(let f=0;f<t;f++){const m=h.getComponent(d,f);a.setComponent(d+u,f,m)}}else r.set(h.array,o);o+=h.count*t}return n!==void 0&&(a.gpuType=n),a}function Ji(c){let e=0;for(const s in c.attributes){const n=c.getAttribute(s);e+=n.count*n.itemSize*n.array.BYTES_PER_ELEMENT}const t=c.getIndex();return e+=t?t.count*t.itemSize*t.array.BYTES_PER_ELEMENT:0,e}function Ia(c,e=1e-4){e=Math.max(e,Number.EPSILON);const t={},s=c.getIndex(),n=c.getAttribute("position"),i=s?s.count:n.count;let r=0;const a=Object.keys(c.attributes),o={},l={},h=[],u=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"];for(let _=0,M=a.length;_<M;_++){const g=a[_],w=c.attributes[g];o[g]=new w.constructor(new w.array.constructor(w.count*w.itemSize),w.itemSize,w.normalized);const S=c.morphAttributes[g];S&&(l[g]||(l[g]=[]),S.forEach((b,P)=>{const x=new b.array.constructor(b.count*b.itemSize);l[g][P]=new b.constructor(x,b.itemSize,b.normalized)}))}const p=e*.5,f=Math.log10(1/e),m=Math.pow(10,f),y=p*m;for(let _=0;_<i;_++){const M=s?s.getX(_):_;let g="";for(let w=0,S=a.length;w<S;w++){const b=a[w],P=c.getAttribute(b),x=P.itemSize;for(let v=0;v<x;v++)g+=`${~~(P[u[v]](M)*m+y)},`}if(g in t)h.push(t[g]);else{for(let w=0,S=a.length;w<S;w++){const b=a[w],P=c.getAttribute(b),x=c.morphAttributes[b],v=P.itemSize,F=o[b],W=l[b];for(let oe=0;oe<v;oe++){const ct=u[oe],Ps=d[oe];if(F[Ps](r,P[ct](M)),x)for(let lt=0,Ti=x.length;lt<Ti;lt++)W[lt][Ps](r,x[lt][ct](M))}}t[g]=r,h.push(r),r++}}const T=c.clone();for(const _ in c.attributes){const M=o[_];if(T.setAttribute(_,new M.constructor(M.array.slice(0,r*M.itemSize),M.itemSize,M.normalized)),_ in l)for(let g=0;g<l[_].length;g++){const w=l[_][g];T.morphAttributes[_][g]=new w.constructor(w.array.slice(0,r*w.itemSize),w.itemSize,w.normalized)}}return T.setIndex(h),T}function Ns(c,e){if(e===Qi)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),c;if(e===Fs||e===Yi){let t=c.getIndex();if(t===null){const r=[],a=c.getAttribute("position");if(a!==void 0){for(let o=0;o<a.count;o++)r.push(o);c.setIndex(r),t=c.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),c}const s=t.count-2,n=[];if(e===Fs)for(let r=1;r<=s;r++)n.push(t.getX(0)),n.push(t.getX(r)),n.push(t.getX(r+1));else for(let r=0;r<s;r++)r%2===0?(n.push(t.getX(r)),n.push(t.getX(r+1)),n.push(t.getX(r+2))):(n.push(t.getX(r+2)),n.push(t.getX(r+1)),n.push(t.getX(r)));n.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=c.clone();return i.setIndex(n),i.clearGroups(),i}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),c}function Fa(c,e=Math.PI/3){const t=Math.cos(e),s=(1+1e-10)*100,n=[new fe,new fe,new fe],i=new fe,r=new fe,a=new fe,o=new fe;function l(m){const y=~~(m.x*s),T=~~(m.y*s),_=~~(m.z*s);return`${y},${T},${_}`}const h=c.index?c.toNonIndexed():c,u=h.attributes.position,d={};for(let m=0,y=u.count/3;m<y;m++){const T=3*m,_=n[0].fromBufferAttribute(u,T+0),M=n[1].fromBufferAttribute(u,T+1),g=n[2].fromBufferAttribute(u,T+2);i.subVectors(g,M),r.subVectors(_,M);const w=new fe().crossVectors(i,r).normalize();for(let S=0;S<3;S++){const b=n[S],P=l(b);P in d||(d[P]=[]),d[P].push(w)}}const p=new Float32Array(u.count*3),f=new Nn(p,3,!1);for(let m=0,y=u.count/3;m<y;m++){const T=3*m,_=n[0].fromBufferAttribute(u,T+0),M=n[1].fromBufferAttribute(u,T+1),g=n[2].fromBufferAttribute(u,T+2);i.subVectors(g,M),r.subVectors(_,M),a.crossVectors(i,r).normalize();for(let w=0;w<3;w++){const S=n[w],b=l(S),P=d[b];o.set(0,0,0);for(let x=0,v=P.length;x<v;x++){const F=P[x];a.dot(F)>t&&o.add(F)}o.normalize(),f.setXYZ(T+w,o.x,o.y,o.z)}}return h.setAttribute("normal",f),h}const{AnimationClip:er,Bone:tr,Box3:sr,BufferAttribute:Bt,BufferGeometry:nr,ClampToEdgeWrapping:ir,Color:ve,ColorManagement:Us,DirectionalLight:rr,DoubleSide:or,FileLoader:Un,FrontSide:ar,Group:Vt,ImageBitmapLoader:cr,InstancedMesh:lr,InterleavedBuffer:hr,InterleavedBufferAttribute:ur,Interpolant:dr,InterpolateDiscrete:pr,InterpolateLinear:kn,Line:fr,LineBasicMaterial:mr,LineLoop:gr,LineSegments:yr,LinearFilter:ps,LinearMipmapLinearFilter:zn,LinearMipmapNearestFilter:Tr,LinearSRGBColorSpace:pe,Loader:_r,LoaderUtils:nt,Material:Gt,MathUtils:br,Matrix4:Ft,Mesh:xr,MeshBasicMaterial:et,MeshPhysicalMaterial:re,MeshStandardMaterial:$n,MirroredRepeatWrapping:wr,NearestFilter:Bn,NearestMipmapLinearFilter:Mr,NearestMipmapNearestFilter:Sr,NumberKeyframeTrack:ks,Object3D:Vn,OrthographicCamera:Er,PerspectiveCamera:Pr,PointLight:Rr,Points:Cr,PointsMaterial:vr,PropertyBinding:Ar,Quaternion:Gn,QuaternionKeyframeTrack:zs,RepeatWrapping:fs,Skeleton:Lr,SkinnedMesh:Dr,Sphere:Ir,SpotLight:Fr,Texture:$s,TextureLoader:Or,TriangleFanDrawMode:Nr,TriangleStripDrawMode:Ur,Vector2:Hn,Vector3:Ue,VectorKeyframeTrack:Bs,SRGBColorSpace:it,InstancedBufferAttribute:kr}=await at("three");class bs extends _r{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Gr(t)}),this.register(function(t){return new Hr(t)}),this.register(function(t){return new Jr(t)}),this.register(function(t){return new eo(t)}),this.register(function(t){return new to(t)}),this.register(function(t){return new Wr(t)}),this.register(function(t){return new Kr(t)}),this.register(function(t){return new qr(t)}),this.register(function(t){return new Xr(t)}),this.register(function(t){return new Vr(t)}),this.register(function(t){return new Zr(t)}),this.register(function(t){return new jr(t)}),this.register(function(t){return new Qr(t)}),this.register(function(t){return new Yr(t)}),this.register(function(t){return new $r(t)}),this.register(function(t){return new so(t)}),this.register(function(t){return new no(t)})}load(e,t,s,n){const i=this;let r;if(this.resourcePath!=="")r=this.resourcePath;else if(this.path!==""){const l=nt.extractUrlBase(e);r=nt.resolveURL(l,this.path)}else r=nt.extractUrlBase(e);this.manager.itemStart(e);const a=function(l){n?n(l):console.error(l),i.manager.itemError(e),i.manager.itemEnd(e)},o=new Un(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(l){try{i.parse(l,r,function(h){t(h),i.manager.itemEnd(e)},a)}catch(h){a(h)}},s,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){let i;const r={},a={},o=new TextDecoder;if(typeof e=="string")i=JSON.parse(e);else if(e instanceof ArrayBuffer)if(o.decode(new Uint8Array(e,0,4))===jn){try{r[C.KHR_BINARY_GLTF]=new io(e)}catch(u){n&&n(u);return}i=JSON.parse(r[C.KHR_BINARY_GLTF].content)}else i=JSON.parse(o.decode(e));else i=e;if(i.asset===void 0||i.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new To(i,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const u=this.pluginCallbacks[h](l);u.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),a[u.name]=u,r[u.name]=!0}if(i.extensionsUsed)for(let h=0;h<i.extensionsUsed.length;++h){const u=i.extensionsUsed[h],d=i.extensionsRequired||[];switch(u){case C.KHR_MATERIALS_UNLIT:r[u]=new Br;break;case C.KHR_DRACO_MESH_COMPRESSION:r[u]=new ro(i,this.dracoLoader);break;case C.KHR_TEXTURE_TRANSFORM:r[u]=new oo;break;case C.KHR_MESH_QUANTIZATION:r[u]=new ao;break;default:d.indexOf(u)>=0&&a[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}l.setExtensions(r),l.setPlugins(a),l.parse(s,n)}parseAsync(e,t){const s=this;return new Promise(function(n,i){s.parse(e,t,n,i)})}}function zr(){let c={};return{get:function(e){return c[e]},add:function(e,t){c[e]=t},remove:function(e){delete c[e]},removeAll:function(){c={}}}}const C={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class $r{constructor(e){this.parser=e,this.name=C.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,n=t.length;s<n;s++){const i=t[s];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let n=t.cache.get(s);if(n)return n;const i=t.json,o=((i.extensions&&i.extensions[this.name]||{}).lights||[])[e];let l;const h=new ve(16777215);o.color!==void 0&&h.setRGB(o.color[0],o.color[1],o.color[2],pe);const u=o.range!==void 0?o.range:0;switch(o.type){case"directional":l=new rr(h),l.target.position.set(0,0,-1),l.add(l.target);break;case"point":l=new Rr(h),l.distance=u;break;case"spot":l=new Fr(h),l.distance=u,o.spot=o.spot||{},o.spot.innerConeAngle=o.spot.innerConeAngle!==void 0?o.spot.innerConeAngle:0,o.spot.outerConeAngle=o.spot.outerConeAngle!==void 0?o.spot.outerConeAngle:Math.PI/4,l.angle=o.spot.outerConeAngle,l.penumbra=1-o.spot.innerConeAngle/o.spot.outerConeAngle,l.target.position.set(0,0,-1),l.add(l.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+o.type)}return l.position.set(0,0,0),ne(l,o),o.intensity!==void 0&&(l.intensity=o.intensity),l.name=t.createUniqueName(o.name||"light_"+e),n=Promise.resolve(l),t.cache.add(s,n),n}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,i=s.json.nodes[e],a=(i.extensions&&i.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(o){return s._getNodeRef(t.cache,a,o)})}}class Br{constructor(){this.name=C.KHR_MATERIALS_UNLIT}getMaterialType(){return et}extendParams(e,t,s){const n=[];e.color=new ve(1,1,1),e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const r=i.baseColorFactor;e.color.setRGB(r[0],r[1],r[2],pe),e.opacity=r[3]}i.baseColorTexture!==void 0&&n.push(s.assignTexture(e,"map",i.baseColorTexture,it))}return Promise.all(n)}}class Vr{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name].emissiveStrength;return i!==void 0&&(t.emissiveIntensity=i),Promise.resolve()}}class Gr{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];if(r.clearcoatFactor!==void 0&&(t.clearcoat=r.clearcoatFactor),r.clearcoatTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatMap",r.clearcoatTexture)),r.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=r.clearcoatRoughnessFactor),r.clearcoatRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),r.clearcoatNormalTexture!==void 0&&(i.push(s.assignTexture(t,"clearcoatNormalMap",r.clearcoatNormalTexture)),r.clearcoatNormalTexture.scale!==void 0)){const a=r.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Hn(a,a)}return Promise.all(i)}}class Hr{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_DISPERSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:re}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return t.dispersion=i.dispersion!==void 0?i.dispersion:0,Promise.resolve()}}class jr{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.iridescenceFactor!==void 0&&(t.iridescence=r.iridescenceFactor),r.iridescenceTexture!==void 0&&i.push(s.assignTexture(t,"iridescenceMap",r.iridescenceTexture)),r.iridescenceIor!==void 0&&(t.iridescenceIOR=r.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),r.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),r.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),r.iridescenceThicknessTexture!==void 0&&i.push(s.assignTexture(t,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(i)}}class Wr{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new ve(0,0,0),t.sheenRoughness=0,t.sheen=1;const r=n.extensions[this.name];if(r.sheenColorFactor!==void 0){const a=r.sheenColorFactor;t.sheenColor.setRGB(a[0],a[1],a[2],pe)}return r.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&i.push(s.assignTexture(t,"sheenColorMap",r.sheenColorTexture,it)),r.sheenRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(i)}}class Kr{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.transmissionFactor!==void 0&&(t.transmission=r.transmissionFactor),r.transmissionTexture!==void 0&&i.push(s.assignTexture(t,"transmissionMap",r.transmissionTexture)),Promise.all(i)}}class qr{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];t.thickness=r.thicknessFactor!==void 0?r.thicknessFactor:0,r.thicknessTexture!==void 0&&i.push(s.assignTexture(t,"thicknessMap",r.thicknessTexture)),t.attenuationDistance=r.attenuationDistance||1/0;const a=r.attenuationColor||[1,1,1];return t.attenuationColor=new ve().setRGB(a[0],a[1],a[2],pe),Promise.all(i)}}class Xr{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:re}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return t.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class Zr{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];t.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&i.push(s.assignTexture(t,"specularIntensityMap",r.specularTexture));const a=r.specularColorFactor||[1,1,1];return t.specularColor=new ve().setRGB(a[0],a[1],a[2],pe),r.specularColorTexture!==void 0&&i.push(s.assignTexture(t,"specularColorMap",r.specularColorTexture,it)),Promise.all(i)}}class Yr{constructor(e){this.parser=e,this.name=C.EXT_MATERIALS_BUMP}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return t.bumpScale=r.bumpFactor!==void 0?r.bumpFactor:1,r.bumpTexture!==void 0&&i.push(s.assignTexture(t,"bumpMap",r.bumpTexture)),Promise.all(i)}}class Qr{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.anisotropyStrength!==void 0&&(t.anisotropy=r.anisotropyStrength),r.anisotropyRotation!==void 0&&(t.anisotropyRotation=r.anisotropyRotation),r.anisotropyTexture!==void 0&&i.push(s.assignTexture(t,"anisotropyMap",r.anisotropyTexture)),Promise.all(i)}}class Jr{constructor(e){this.parser=e,this.name=C.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,n=s.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const i=n.extensions[this.name],r=t.options.ktx2Loader;if(!r){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,i.source,r)}}class eo{constructor(e){this.parser=e,this.name=C.EXT_TEXTURE_WEBP}loadTexture(e){const t=this.name,s=this.parser,n=s.json,i=n.textures[e];if(!i.extensions||!i.extensions[t])return null;const r=i.extensions[t],a=n.images[r.source];let o=s.textureLoader;if(a.uri){const l=s.options.manager.getHandler(a.uri);l!==null&&(o=l)}return s.loadTextureImage(e,r.source,o)}}class to{constructor(e){this.parser=e,this.name=C.EXT_TEXTURE_AVIF}loadTexture(e){const t=this.name,s=this.parser,n=s.json,i=n.textures[e];if(!i.extensions||!i.extensions[t])return null;const r=i.extensions[t],a=n.images[r.source];let o=s.textureLoader;if(a.uri){const l=s.options.manager.getHandler(a.uri);l!==null&&(o=l)}return s.loadTextureImage(e,r.source,o)}}class so{constructor(e){this.name=C.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const n=s.extensions[this.name],i=this.parser.getDependency("buffer",n.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then(function(a){const o=n.byteOffset||0,l=n.byteLength||0,h=n.count,u=n.byteStride,d=new Uint8Array(a,o,l);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(h,u,d,n.mode,n.filter).then(function(p){return p.buffer}):r.ready.then(function(){const p=new ArrayBuffer(h*u);return r.decodeGltfBuffer(new Uint8Array(p),h,u,d,n.mode,n.filter),p})})}else return null}}class no{constructor(e){this.name=C.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const n=t.meshes[s.mesh];for(const l of n.primitives)if(l.mode!==Q.TRIANGLES&&l.mode!==Q.TRIANGLE_STRIP&&l.mode!==Q.TRIANGLE_FAN&&l.mode!==void 0)return null;const r=s.extensions[this.name].attributes,a=[],o={};for(const l in r)a.push(this.parser.getDependency("accessor",r[l]).then(h=>(o[l]=h,o[l])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(l=>{const h=l.pop(),u=h.isGroup?h.children:[h],d=l[0].count,p=[];for(const f of u){const m=new Ft,y=new Ue,T=new Gn,_=new Ue(1,1,1),M=new lr(f.geometry,f.material,d);for(let g=0;g<d;g++)o.TRANSLATION&&y.fromBufferAttribute(o.TRANSLATION,g),o.ROTATION&&T.fromBufferAttribute(o.ROTATION,g),o.SCALE&&_.fromBufferAttribute(o.SCALE,g),M.setMatrixAt(g,m.compose(y,T,_));for(const g in o)if(g==="_COLOR_0"){const w=o[g];M.instanceColor=new kr(w.array,w.itemSize,w.normalized)}else g!=="TRANSLATION"&&g!=="ROTATION"&&g!=="SCALE"&&f.geometry.setAttribute(g,o[g]);Vn.prototype.copy.call(M,f),this.parser.assignFinalMaterial(M),p.push(M)}return h.isGroup?(h.clear(),h.add(...p),h):p[0]}))}}const jn="glTF",We=12,Vs={JSON:1313821514,BIN:5130562};class io{constructor(e){this.name=C.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,We),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==jn)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-We,i=new DataView(e,We);let r=0;for(;r<n;){const a=i.getUint32(r,!0);r+=4;const o=i.getUint32(r,!0);if(r+=4,o===Vs.JSON){const l=new Uint8Array(e,We+r,a);this.content=s.decode(l)}else if(o===Vs.BIN){const l=We+r;this.body=e.slice(l,l+a)}r+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class ro{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=C.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,n=this.dracoLoader,i=e.extensions[this.name].bufferView,r=e.extensions[this.name].attributes,a={},o={},l={};for(const h in r){const u=ms[h]||h.toLowerCase();a[u]=r[h]}for(const h in e.attributes){const u=ms[h]||h.toLowerCase();if(r[h]!==void 0){const d=s.accessors[e.attributes[h]],p=$e[d.componentType];l[u]=p.name,o[u]=d.normalized===!0}}return t.getDependency("bufferView",i).then(function(h){return new Promise(function(u,d){n.decodeDracoFile(h,function(p){for(const f in p.attributes){const m=p.attributes[f],y=o[f];y!==void 0&&(m.normalized=y)}u(p)},a,l,pe,d)})})}}class oo{constructor(){this.name=C.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class ao{constructor(){this.name=C.KHR_MESH_QUANTIZATION}}class Wn extends dr{constructor(e,t,s,n){super(e,t,s,n)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,n=this.valueSize,i=e*n*3+n;for(let r=0;r!==n;r++)t[r]=s[i+r];return t}interpolate_(e,t,s,n){const i=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=a*2,l=a*3,h=n-t,u=(s-t)/h,d=u*u,p=d*u,f=e*l,m=f-l,y=-2*p+3*d,T=p-d,_=1-y,M=T-d+u;for(let g=0;g!==a;g++){const w=r[m+g+a],S=r[m+g+o]*h,b=r[f+g+a],P=r[f+g]*h;i[g]=_*w+M*S+y*b+T*P}return i}}const co=new Gn;class lo extends Wn{interpolate_(e,t,s,n){const i=super.interpolate_(e,t,s,n);return co.fromArray(i).normalize().toArray(i),i}}const Q={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},$e={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Gs={9728:Bn,9729:ps,9984:Sr,9985:Tr,9986:Mr,9987:zn},Hs={33071:ir,33648:wr,10497:fs},Ht={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ms={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},me={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},ho={CUBICSPLINE:void 0,LINEAR:kn,STEP:pr},jt={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function uo(c){return c.DefaultMaterial===void 0&&(c.DefaultMaterial=new $n({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:ar})),c.DefaultMaterial}function Me(c,e,t){for(const s in t.extensions)c[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function ne(c,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(c.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function po(c,e,t){let s=!1,n=!1,i=!1;for(let l=0,h=e.length;l<h;l++){const u=e[l];if(u.POSITION!==void 0&&(s=!0),u.NORMAL!==void 0&&(n=!0),u.COLOR_0!==void 0&&(i=!0),s&&n&&i)break}if(!s&&!n&&!i)return Promise.resolve(c);const r=[],a=[],o=[];for(let l=0,h=e.length;l<h;l++){const u=e[l];if(s){const d=u.POSITION!==void 0?t.getDependency("accessor",u.POSITION):c.attributes.position;r.push(d)}if(n){const d=u.NORMAL!==void 0?t.getDependency("accessor",u.NORMAL):c.attributes.normal;a.push(d)}if(i){const d=u.COLOR_0!==void 0?t.getDependency("accessor",u.COLOR_0):c.attributes.color;o.push(d)}}return Promise.all([Promise.all(r),Promise.all(a),Promise.all(o)]).then(function(l){const h=l[0],u=l[1],d=l[2];return s&&(c.morphAttributes.position=h),n&&(c.morphAttributes.normal=u),i&&(c.morphAttributes.color=d),c.morphTargetsRelative=!0,c})}function fo(c,e){if(c.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)c.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(c.morphTargetInfluences.length===t.length){c.morphTargetDictionary={};for(let s=0,n=t.length;s<n;s++)c.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function mo(c){let e;const t=c.extensions&&c.extensions[C.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+Wt(t.attributes):e=c.indices+":"+Wt(c.attributes)+":"+c.mode,c.targets!==void 0)for(let s=0,n=c.targets.length;s<n;s++)e+=":"+Wt(c.targets[s]);return e}function Wt(c){let e="";const t=Object.keys(c).sort();for(let s=0,n=t.length;s<n;s++)e+=t[s]+":"+c[t[s]]+";";return e}function gs(c){switch(c){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function go(c){return c.search(/\.jpe?g($|\?)/i)>0||c.search(/^data\:image\/jpeg/)===0?"image/jpeg":c.search(/\.webp($|\?)/i)>0||c.search(/^data\:image\/webp/)===0?"image/webp":c.search(/\.ktx2($|\?)/i)>0||c.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const yo=new Ft;class To{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new zr,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,n=-1,i=!1,r=-1;if(typeof navigator<"u"){const a=navigator.userAgent;s=/^((?!chrome|android).)*safari/i.test(a)===!0;const o=a.match(/Version\/(\d+)/);n=s&&o?parseInt(o[1],10):-1,i=a.indexOf("Firefox")>-1,r=i?a.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||s&&n<17||i&&r<98?this.textureLoader=new Or(this.options.manager):this.textureLoader=new cr(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Un(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,n=this.json,i=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(r){const a={scene:r[0][n.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:n.asset,parser:s,userData:{}};return Me(i,a,n),ne(a,n),Promise.all(s._invokeAll(function(o){return o.afterRoot&&o.afterRoot(a)})).then(function(){for(const o of a.scenes)o.updateMatrixWorld();e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let n=0,i=t.length;n<i;n++){const r=t[n].joints;for(let a=0,o=r.length;a<o;a++)e[r[a]].isBone=!0}for(let n=0,i=e.length;n<i;n++){const r=e[n];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(s[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const n=s.clone(),i=(r,a)=>{const o=this.associations.get(r);o!=null&&this.associations.set(a,o);for(const[l,h]of r.children.entries())i(h,a.children[l])};return i(s,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let n=0;n<t.length;n++){const i=e(t[n]);i&&s.push(i)}return s}getDependency(e,t){const s=e+":"+t;let n=this.cache.get(s);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne(function(i){return i.loadNode&&i.loadNode(t)});break;case"mesh":n=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(t)});break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne(function(i){return i!=this&&i.getDependency&&i.getDependency(e,t)}),!n)throw new Error("Unknown type: "+e);break}this.cache.add(s,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,n=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(n.map(function(i,r){return s.getDependency(e,r)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[C.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(i,r){s.load(nt.resolveURL(t.uri,n.path),i,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const n=t.byteLength||0,i=t.byteOffset||0;return s.slice(i,i+n)})}loadAccessor(e){const t=this,s=this.json,n=this.json.accessors[e];if(n.bufferView===void 0&&n.sparse===void 0){const r=Ht[n.type],a=$e[n.componentType],o=n.normalized===!0,l=new a(n.count*r);return Promise.resolve(new Bt(l,r,o))}const i=[];return n.bufferView!==void 0?i.push(this.getDependency("bufferView",n.bufferView)):i.push(null),n.sparse!==void 0&&(i.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(i).then(function(r){const a=r[0],o=Ht[n.type],l=$e[n.componentType],h=l.BYTES_PER_ELEMENT,u=h*o,d=n.byteOffset||0,p=n.bufferView!==void 0?s.bufferViews[n.bufferView].byteStride:void 0,f=n.normalized===!0;let m,y;if(p&&p!==u){const T=Math.floor(d/p),_="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+T+":"+n.count;let M=t.cache.get(_);M||(m=new l(a,T*p,n.count*p/h),M=new hr(m,p/h),t.cache.add(_,M)),y=new ur(M,o,d%p/h,f)}else a===null?m=new l(n.count*o):m=new l(a,d,n.count*o),y=new Bt(m,o,f);if(n.sparse!==void 0){const T=Ht.SCALAR,_=$e[n.sparse.indices.componentType],M=n.sparse.indices.byteOffset||0,g=n.sparse.values.byteOffset||0,w=new _(r[1],M,n.sparse.count*T),S=new l(r[2],g,n.sparse.count*o);a!==null&&(y=new Bt(y.array.slice(),y.itemSize,y.normalized)),y.normalized=!1;for(let b=0,P=w.length;b<P;b++){const x=w[b];if(y.setX(x,S[b*o]),o>=2&&y.setY(x,S[b*o+1]),o>=3&&y.setZ(x,S[b*o+2]),o>=4&&y.setW(x,S[b*o+3]),o>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}y.normalized=f}return y})}loadTexture(e){const t=this.json,s=this.options,i=t.textures[e].source,r=t.images[i];let a=this.textureLoader;if(r.uri){const o=s.manager.getHandler(r.uri);o!==null&&(a=o)}return this.loadTextureImage(e,i,a)}loadTextureImage(e,t,s){const n=this,i=this.json,r=i.textures[e],a=i.images[t],o=(a.uri||a.bufferView)+":"+r.sampler;if(this.textureCache[o])return this.textureCache[o];const l=this.loadImageSource(t,s).then(function(h){h.flipY=!1,h.name=r.name||a.name||"",h.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(h.name=a.uri);const d=(i.samplers||{})[r.sampler]||{};return h.magFilter=Gs[d.magFilter]||ps,h.minFilter=Gs[d.minFilter]||zn,h.wrapS=Hs[d.wrapS]||fs,h.wrapT=Hs[d.wrapT]||fs,h.generateMipmaps=!h.isCompressedTexture&&h.minFilter!==Bn&&h.minFilter!==ps,n.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[o]=l,l}loadImageSource(e,t){const s=this,n=this.json,i=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(u=>u.clone());const r=n.images[e],a=self.URL||self.webkitURL;let o=r.uri||"",l=!1;if(r.bufferView!==void 0)o=s.getDependency("bufferView",r.bufferView).then(function(u){l=!0;const d=new Blob([u],{type:r.mimeType});return o=a.createObjectURL(d),o});else if(r.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(o).then(function(u){return new Promise(function(d,p){let f=d;t.isImageBitmapLoader===!0&&(f=function(m){const y=new $s(m);y.needsUpdate=!0,d(y)}),t.load(nt.resolveURL(u,i.path),f,void 0,p)})}).then(function(u){return l===!0&&a.revokeObjectURL(o),ne(u,r),u.userData.mimeType=r.mimeType||go(r.uri),u}).catch(function(u){throw console.error("THREE.GLTFLoader: Couldn't load texture",o),u});return this.sourceCache[e]=h,h}assignTexture(e,t,s,n){const i=this;return this.getDependency("texture",s.index).then(function(r){if(!r)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(r=r.clone(),r.channel=s.texCoord),i.extensions[C.KHR_TEXTURE_TRANSFORM]){const a=s.extensions!==void 0?s.extensions[C.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const o=i.associations.get(r);r=i.extensions[C.KHR_TEXTURE_TRANSFORM].extendTexture(r,a),i.associations.set(r,o)}}return n!==void 0&&(r.colorSpace=n),e[t]=r,r})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=t.attributes.tangent===void 0,i=t.attributes.color!==void 0,r=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+s.uuid;let o=this.cache.get(a);o||(o=new vr,Gt.prototype.copy.call(o,s),o.color.copy(s.color),o.map=s.map,o.sizeAttenuation=!1,this.cache.add(a,o)),s=o}else if(e.isLine){const a="LineBasicMaterial:"+s.uuid;let o=this.cache.get(a);o||(o=new mr,Gt.prototype.copy.call(o,s),o.color.copy(s.color),o.map=s.map,this.cache.add(a,o)),s=o}if(n||i||r){let a="ClonedMaterial:"+s.uuid+":";n&&(a+="derivative-tangents:"),i&&(a+="vertex-colors:"),r&&(a+="flat-shading:");let o=this.cache.get(a);o||(o=s.clone(),i&&(o.vertexColors=!0),r&&(o.flatShading=!0),n&&(o.normalScale&&(o.normalScale.y*=-1),o.clearcoatNormalScale&&(o.clearcoatNormalScale.y*=-1)),this.cache.add(a,o),this.associations.set(o,this.associations.get(s))),s=o}e.material=s}getMaterialType(){return $n}loadMaterial(e){const t=this,s=this.json,n=this.extensions,i=s.materials[e];let r;const a={},o=i.extensions||{},l=[];if(o[C.KHR_MATERIALS_UNLIT]){const u=n[C.KHR_MATERIALS_UNLIT];r=u.getMaterialType(),l.push(u.extendParams(a,i,t))}else{const u=i.pbrMetallicRoughness||{};if(a.color=new ve(1,1,1),a.opacity=1,Array.isArray(u.baseColorFactor)){const d=u.baseColorFactor;a.color.setRGB(d[0],d[1],d[2],pe),a.opacity=d[3]}u.baseColorTexture!==void 0&&l.push(t.assignTexture(a,"map",u.baseColorTexture,it)),a.metalness=u.metallicFactor!==void 0?u.metallicFactor:1,a.roughness=u.roughnessFactor!==void 0?u.roughnessFactor:1,u.metallicRoughnessTexture!==void 0&&(l.push(t.assignTexture(a,"metalnessMap",u.metallicRoughnessTexture)),l.push(t.assignTexture(a,"roughnessMap",u.metallicRoughnessTexture))),r=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),l.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,a)})))}i.doubleSided===!0&&(a.side=or);const h=i.alphaMode||jt.OPAQUE;if(h===jt.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,h===jt.MASK&&(a.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&r!==et&&(l.push(t.assignTexture(a,"normalMap",i.normalTexture)),a.normalScale=new Hn(1,1),i.normalTexture.scale!==void 0)){const u=i.normalTexture.scale;a.normalScale.set(u,u)}if(i.occlusionTexture!==void 0&&r!==et&&(l.push(t.assignTexture(a,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&r!==et){const u=i.emissiveFactor;a.emissive=new ve().setRGB(u[0],u[1],u[2],pe)}return i.emissiveTexture!==void 0&&r!==et&&l.push(t.assignTexture(a,"emissiveMap",i.emissiveTexture,it)),Promise.all(l).then(function(){const u=new r(a);return i.name&&(u.name=i.name),ne(u,i),t.associations.set(u,{materials:e}),i.extensions&&Me(n,u,i),u})}createUniqueName(e){const t=Ar.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,n=this.primitiveCache;function i(a){return s[C.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(o){return js(o,a,t)})}const r=[];for(let a=0,o=e.length;a<o;a++){const l=e[a],h=mo(l),u=n[h];if(u)r.push(u.promise);else{let d;l.extensions&&l.extensions[C.KHR_DRACO_MESH_COMPRESSION]?d=i(l):d=js(new nr,l,t),n[h]={primitive:l,promise:d},r.push(d)}}return Promise.all(r)}loadMesh(e){const t=this,s=this.json,n=this.extensions,i=s.meshes[e],r=i.primitives,a=[];for(let o=0,l=r.length;o<l;o++){const h=r[o].material===void 0?uo(this.cache):this.getDependency("material",r[o].material);a.push(h)}return a.push(t.loadGeometries(r)),Promise.all(a).then(function(o){const l=o.slice(0,o.length-1),h=o[o.length-1],u=[];for(let p=0,f=h.length;p<f;p++){const m=h[p],y=r[p];let T;const _=l[p];if(y.mode===Q.TRIANGLES||y.mode===Q.TRIANGLE_STRIP||y.mode===Q.TRIANGLE_FAN||y.mode===void 0)T=i.isSkinnedMesh===!0?new Dr(m,_):new xr(m,_),T.isSkinnedMesh===!0&&T.normalizeSkinWeights(),y.mode===Q.TRIANGLE_STRIP?T.geometry=Ns(T.geometry,Ur):y.mode===Q.TRIANGLE_FAN&&(T.geometry=Ns(T.geometry,Nr));else if(y.mode===Q.LINES)T=new yr(m,_);else if(y.mode===Q.LINE_STRIP)T=new fr(m,_);else if(y.mode===Q.LINE_LOOP)T=new gr(m,_);else if(y.mode===Q.POINTS)T=new Cr(m,_);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+y.mode);Object.keys(T.geometry.morphAttributes).length>0&&fo(T,i),T.name=t.createUniqueName(i.name||"mesh_"+e),ne(T,i),y.extensions&&Me(n,T,y),t.assignFinalMaterial(T),u.push(T)}for(let p=0,f=u.length;p<f;p++)t.associations.set(u[p],{meshes:e,primitives:p});if(u.length===1)return i.extensions&&Me(n,u[0],i),u[0];const d=new Vt;i.extensions&&Me(n,d,i),t.associations.set(d,{meshes:e});for(let p=0,f=u.length;p<f;p++)d.add(u[p]);return d})}loadCamera(e){let t;const s=this.json.cameras[e],n=s[s.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new Pr(br.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):s.type==="orthographic"&&(t=new Er(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),ne(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let n=0,i=t.joints.length;n<i;n++)s.push(this._loadNodeShallow(t.joints[n]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(n){const i=n.pop(),r=n,a=[],o=[];for(let l=0,h=r.length;l<h;l++){const u=r[l];if(u){a.push(u);const d=new Ft;i!==null&&d.fromArray(i.array,l*16),o.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[l])}return new Lr(a,o)})}loadAnimation(e){const t=this.json,s=this,n=t.animations[e],i=n.name?n.name:"animation_"+e,r=[],a=[],o=[],l=[],h=[];for(let u=0,d=n.channels.length;u<d;u++){const p=n.channels[u],f=n.samplers[p.sampler],m=p.target,y=m.node,T=n.parameters!==void 0?n.parameters[f.input]:f.input,_=n.parameters!==void 0?n.parameters[f.output]:f.output;m.node!==void 0&&(r.push(this.getDependency("node",y)),a.push(this.getDependency("accessor",T)),o.push(this.getDependency("accessor",_)),l.push(f),h.push(m))}return Promise.all([Promise.all(r),Promise.all(a),Promise.all(o),Promise.all(l),Promise.all(h)]).then(function(u){const d=u[0],p=u[1],f=u[2],m=u[3],y=u[4],T=[];for(let M=0,g=d.length;M<g;M++){const w=d[M],S=p[M],b=f[M],P=m[M],x=y[M];if(w===void 0)continue;w.updateMatrix&&w.updateMatrix();const v=s._createAnimationTracks(w,S,b,P,x);if(v)for(let F=0;F<v.length;F++)T.push(v[F])}const _=new er(i,void 0,T);return ne(_,n),_})}createNodeMesh(e){const t=this.json,s=this,n=t.nodes[e];return n.mesh===void 0?null:s.getDependency("mesh",n.mesh).then(function(i){const r=s._getNodeRef(s.meshCache,n.mesh,i);return n.weights!==void 0&&r.traverse(function(a){if(a.isMesh)for(let o=0,l=n.weights.length;o<l;o++)a.morphTargetInfluences[o]=n.weights[o]}),r})}loadNode(e){const t=this.json,s=this,n=t.nodes[e],i=s._loadNodeShallow(e),r=[],a=n.children||[];for(let l=0,h=a.length;l<h;l++)r.push(s.getDependency("node",a[l]));const o=n.skin===void 0?Promise.resolve(null):s.getDependency("skin",n.skin);return Promise.all([i,Promise.all(r),o]).then(function(l){const h=l[0],u=l[1],d=l[2];d!==null&&h.traverse(function(p){p.isSkinnedMesh&&p.bind(d,yo)});for(let p=0,f=u.length;p<f;p++)h.add(u[p]);return h})}_loadNodeShallow(e){const t=this.json,s=this.extensions,n=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const i=t.nodes[e],r=i.name?n.createUniqueName(i.name):"",a=[],o=n._invokeOne(function(l){return l.createNodeMesh&&l.createNodeMesh(e)});return o&&a.push(o),i.camera!==void 0&&a.push(n.getDependency("camera",i.camera).then(function(l){return n._getNodeRef(n.cameraCache,i.camera,l)})),n._invokeAll(function(l){return l.createNodeAttachment&&l.createNodeAttachment(e)}).forEach(function(l){a.push(l)}),this.nodeCache[e]=Promise.all(a).then(function(l){let h;if(i.isBone===!0?h=new tr:l.length>1?h=new Vt:l.length===1?h=l[0]:h=new Vn,h!==l[0])for(let u=0,d=l.length;u<d;u++)h.add(l[u]);if(i.name&&(h.userData.name=i.name,h.name=r),ne(h,i),i.extensions&&Me(s,h,i),i.matrix!==void 0){const u=new Ft;u.fromArray(i.matrix),h.applyMatrix4(u)}else i.translation!==void 0&&h.position.fromArray(i.translation),i.rotation!==void 0&&h.quaternion.fromArray(i.rotation),i.scale!==void 0&&h.scale.fromArray(i.scale);if(!n.associations.has(h))n.associations.set(h,{});else if(i.mesh!==void 0&&n.meshCache.refs[i.mesh]>1){const u=n.associations.get(h);n.associations.set(h,{...u})}return n.associations.get(h).nodes=e,h}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],n=this,i=new Vt;s.name&&(i.name=n.createUniqueName(s.name)),ne(i,s),s.extensions&&Me(t,i,s);const r=s.nodes||[],a=[];for(let o=0,l=r.length;o<l;o++)a.push(n.getDependency("node",r[o]));return Promise.all(a).then(function(o){for(let h=0,u=o.length;h<u;h++)i.add(o[h]);const l=h=>{const u=new Map;for(const[d,p]of n.associations)(d instanceof Gt||d instanceof $s)&&u.set(d,p);return h.traverse(d=>{const p=n.associations.get(d);p!=null&&u.set(d,p)}),u};return n.associations=l(i),i})}_createAnimationTracks(e,t,s,n,i){const r=[],a=e.name?e.name:e.uuid,o=[];me[i.path]===me.weights?e.traverse(function(d){d.morphTargetInfluences&&o.push(d.name?d.name:d.uuid)}):o.push(a);let l;switch(me[i.path]){case me.weights:l=ks;break;case me.rotation:l=zs;break;case me.translation:case me.scale:l=Bs;break;default:switch(s.itemSize){case 1:l=ks;break;case 2:case 3:default:l=Bs;break}break}const h=n.interpolation!==void 0?ho[n.interpolation]:kn,u=this._getArrayFromAccessor(s);for(let d=0,p=o.length;d<p;d++){const f=new l(o[d]+"."+me[i.path],t.array,u,h);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(f),r.push(f)}return r}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const s=gs(t.constructor),n=new Float32Array(t.length);for(let i=0,r=t.length;i<r;i++)n[i]=t[i]*s;t=n}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const n=this instanceof zs?lo:Wn;return new n(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function _o(c,e,t){const s=e.attributes,n=new sr;if(s.POSITION!==void 0){const a=t.json.accessors[s.POSITION],o=a.min,l=a.max;if(o!==void 0&&l!==void 0){if(n.set(new Ue(o[0],o[1],o[2]),new Ue(l[0],l[1],l[2])),a.normalized){const h=gs($e[a.componentType]);n.min.multiplyScalar(h),n.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=e.targets;if(i!==void 0){const a=new Ue,o=new Ue;for(let l=0,h=i.length;l<h;l++){const u=i[l];if(u.POSITION!==void 0){const d=t.json.accessors[u.POSITION],p=d.min,f=d.max;if(p!==void 0&&f!==void 0){if(o.setX(Math.max(Math.abs(p[0]),Math.abs(f[0]))),o.setY(Math.max(Math.abs(p[1]),Math.abs(f[1]))),o.setZ(Math.max(Math.abs(p[2]),Math.abs(f[2]))),d.normalized){const m=gs($e[d.componentType]);o.multiplyScalar(m)}a.max(o)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(a)}c.boundingBox=n;const r=new Ir;n.getCenter(r.center),r.radius=n.min.distanceTo(n.max)/2,c.boundingSphere=r}function js(c,e,t){const s=e.attributes,n=[];function i(r,a){return t.getDependency("accessor",r).then(function(o){c.setAttribute(a,o)})}for(const r in s){const a=ms[r]||r.toLowerCase();a in c.attributes||n.push(i(s[r],a))}if(e.indices!==void 0&&!c.index){const r=t.getDependency("accessor",e.indices).then(function(a){c.setIndex(a)});n.push(r)}return Us.workingColorSpace!==pe&&"COLOR_0"in s&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Us.workingColorSpace}" not supported.`),ne(c,e),_o(c,e,t),Promise.all(n).then(function(){return e.targets!==void 0?po(c,e.targets,t):c})}class bo{get unloadPriorityCallback(){return this._unloadPriorityCallback}set unloadPriorityCallback(e){e.length===1?(console.warn('LRUCache: "unloadPriorityCallback" function has been changed to take two arguments.'),this._unloadPriorityCallback=(t,s)=>{const n=e(t),i=e(s);return n<i?-1:n>i?1:0}):this._unloadPriorityCallback=e}constructor(){this.minSize=6e3,this.maxSize=8e3,this.minBytesSize=.3*1073741824,this.maxBytesSize=.4*1073741824,this.unloadPercent=.05,this.autoMarkUnused=!0,this.itemSet=new Map,this.itemList=[],this.usedSet=new Set,this.callbacks=new Map,this.unloadingHandle=-1,this.cachedBytes=0,this.bytesMap=new Map,this.loadedSet=new Set,this._unloadPriorityCallback=null;const e=this.itemSet;this.defaultPriorityCallback=t=>e.get(t)}isFull(){return this.itemSet.size>=this.maxSize||this.cachedBytes>=this.maxBytesSize}getMemoryUsage(e){return this.bytesMap.get(e)||0}setMemoryUsage(e,t){const{bytesMap:s,itemSet:n}=this;n.has(e)&&(this.cachedBytes-=s.get(e)||0,s.set(e,t),this.cachedBytes+=t)}add(e,t){const s=this.itemSet;if(s.has(e)||this.isFull())return!1;const n=this.usedSet,i=this.itemList,r=this.callbacks;return i.push(e),n.add(e),s.set(e,Date.now()),r.set(e,t),!0}has(e){return this.itemSet.has(e)}remove(e){const t=this.usedSet,s=this.itemSet,n=this.itemList,i=this.bytesMap,r=this.callbacks,a=this.loadedSet;if(s.has(e)){this.cachedBytes-=i.get(e)||0,i.delete(e),r.get(e)(e);const o=n.indexOf(e);return n.splice(o,1),t.delete(e),s.delete(e),r.delete(e),a.delete(e),!0}return!1}setLoaded(e,t){const{itemSet:s,loadedSet:n}=this;s.has(e)&&(t===!0?n.add(e):n.delete(e))}markUsed(e){const t=this.itemSet,s=this.usedSet;t.has(e)&&!s.has(e)&&(t.set(e,Date.now()),s.add(e))}markUnused(e){this.usedSet.delete(e)}markAllUnused(){this.usedSet.clear()}unloadUnusedContent(){const{unloadPercent:e,minSize:t,maxSize:s,itemList:n,itemSet:i,usedSet:r,loadedSet:a,callbacks:o,bytesMap:l,minBytesSize:h,maxBytesSize:u}=this,d=n.length-r.size,p=n.length-a.size,f=Math.max(Math.min(n.length-t,d),0),m=this.cachedBytes-h,y=this.unloadPriorityCallback||this.defaultPriorityCallback;let T=!1;const _=f>0&&d>0||p&&n.length>s;if(d&&this.cachedBytes>h||p&&this.cachedBytes>u||_){n.sort((x,v)=>{const F=r.has(x),W=r.has(v);if(F===W){const oe=a.has(x),ct=a.has(v);return oe===ct?-y(x,v):oe?1:-1}else return F?1:-1});const M=Math.max(t*e,f*e),g=Math.ceil(Math.min(M,d,f)),w=Math.max(e*m,e*h),S=Math.min(w,m);let b=0,P=0;for(;this.cachedBytes-P>u||n.length-b>s;){const x=n[b],v=l.get(x)||0;if(r.has(x)&&a.has(x)||this.cachedBytes-P-v<u&&n.length-b<=s)break;P+=v,b++}for(;P<S||b<g;){const x=n[b],v=l.get(x)||0;if(r.has(x)||this.cachedBytes-P-v<h&&b>=g)break;P+=v,b++}n.splice(0,b).forEach(x=>{this.cachedBytes-=l.get(x)||0,o.get(x)(x),l.delete(x),i.delete(x),o.delete(x),a.delete(x),r.delete(x)}),T=b<f||P<m&&b<d,T=T&&b>0}T&&(this.unloadingHandle=requestAnimationFrame(()=>this.scheduleUnload()))}scheduleUnload(){cancelAnimationFrame(this.unloadingHandle),this.scheduled||(this.scheduled=!0,queueMicrotask(()=>{this.scheduled=!1,this.unloadUnusedContent()}))}}let Kt=class{get running(){return this.items.length!==0||this.currJobs!==0}constructor(){this.maxJobs=6,this.items=[],this.callbacks=new Map,this.currJobs=0,this.scheduled=!1,this.autoUpdate=!0,this.priorityCallback=null,this.schedulingCallback=e=>{requestAnimationFrame(e)},this._runjobs=()=>{this.scheduled=!1,this.tryRunJobs()}}sort(){const e=this.priorityCallback,t=this.items;e!==null&&t.sort(e)}has(e){return this.callbacks.has(e)}add(e,t){const s={callback:t,reject:null,resolve:null,promise:null};return s.promise=new Promise((n,i)=>{const r=this.items,a=this.callbacks;s.resolve=n,s.reject=i,r.unshift(e),a.set(e,s),this.autoUpdate&&this.scheduleJobRun()}),s.promise}remove(e){const t=this.items,s=this.callbacks,n=t.indexOf(e);if(n!==-1){const i=s.get(e);i.promise.catch(()=>{}),i.reject(new Error("PriorityQueue: Item removed.")),t.splice(n,1),s.delete(e)}}removeByFilter(e){const{items:t}=this;for(let s=0;s<t.length;s++){const n=t[s];e(n)&&this.remove(n)}}tryRunJobs(){this.sort();const e=this.items,t=this.callbacks,s=this.maxJobs;let n=0;const i=()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()};for(;s>this.currJobs&&e.length>0&&n<s;){this.currJobs++,n++;const r=e.pop(),{callback:a,resolve:o,reject:l}=t.get(r);t.delete(r);let h;try{h=a(r)}catch(u){l(u),i()}h instanceof Promise?h.then(o).catch(l).finally(i):(o(h),i())}}scheduleJobRun(){this.scheduled||(this.schedulingCallback(this._runjobs),this.scheduled=!0)}};const ke=-1,ge=0,ut=1,qt=2,rt=3,Ws=6378137,xo=6356752314245179e-9;function wo(c,e=null,t=null){const s=[];for(s.push(c),s.push(null),s.push(0);s.length>0;){const n=s.pop(),i=s.pop(),r=s.pop();if(e&&e(r,i,n)){t&&t(r,i,n);return}const a=r.children;if(a)for(let o=a.length-1;o>=0;o--)s.push(a[o]),s.push(r),s.push(n+1);t&&t(r,i,n)}}function Ge(c){if(c===null||c.byteLength<4)return"";let e;if(c instanceof DataView?e=c:e=new DataView(c),String.fromCharCode(e.getUint8(0))==="{")return null;let t="";for(let s=0;s<4;s++)t+=String.fromCharCode(e.getUint8(s));return t}const Mo=new TextDecoder;function Kn(c){return Mo.decode(c)}function xs(c){return c.replace(/[\\/][^\\/]+$/,"")+"/"}let Ot=class{constructor(){this.fetchOptions={},this.workingPath=""}load(...e){return console.warn('Loader: "load" function has been deprecated in favor of "loadAsync".'),this.loadAsync(...e)}loadAsync(e){return fetch(e,this.fetchOptions).then(t=>{if(!t.ok)throw new Error(`Failed to load file "${e}" with status ${t.status} : ${t.statusText}`);return t.arrayBuffer()}).then(t=>(this.workingPath===""&&(this.workingPath=xs(e)),this.parse(t)))}resolveExternalURL(e){return new URL(e,this.workingPath).href}parse(e){throw new Error("LoaderBase: Parse not implemented.")}};function Ks(c){if(!c)return null;let e=c.length;const t=c.indexOf("?"),s=c.indexOf("#");t!==-1&&(e=Math.min(e,t)),s!==-1&&(e=Math.min(e,s));const n=c.lastIndexOf(".",e),i=c.lastIndexOf("/",e),r=c.indexOf("://");return r!==-1&&r+2===i||n===-1||n<i?null:c.substring(n+1,e)||null}const dt={inView:!1,error:1/0,distanceFromCamera:1/0},qn=!0;function Xn(c){return c===rt||c===ke}function xe(c,e){return c.__lastFrameVisited===e&&c.__used}function ws(c){return c.__childrenProcessed===c.children.length}function Ms(c,e){c.__lastFrameVisited!==e.frameCount&&(c.__lastFrameVisited=e.frameCount,c.__used=!1,c.__inFrustum=!1,c.__isLeaf=!1,c.__visible=!1,c.__active=!1,c.__error=1/0,c.__distanceFromCamera=1/0,c.__allChildrenLoaded=!1,e.calculateTileViewError(c,dt),c.__inFrustum=dt.inView,c.__error=dt.error,c.__distanceFromCamera=dt.distanceFromCamera)}function Zn(c,e){if(e.ensureChildrenArePreprocessed(c),Ms(c,e),ys(c,e),c.__hasUnrenderableContent&&ws(c)){const t=c.children;for(let s=0,n=t.length;s<n;s++)Zn(t[s],e)}}function Yn(c,e){if(e.ensureChildrenArePreprocessed(c),xe(c,e.frameCount)&&(c.__hasContent&&e.queueTileForDownload(c),ws(c))){const t=c.children;for(let s=0,n=t.length;s<n;s++)Yn(t[s],e)}}function ys(c,e){c.__used||(c.__used=!0,e.markTileUsed(c),e.stats.used++,c.__inFrustum===!0&&e.stats.inFrustum++)}function So(c,e){return!(c.__error<=e.errorTarget&&!c.__hasUnrenderableContent||e.maxDepth>0&&c.__depth+1>=e.maxDepth||!ws(c))}function Qn(c,e){if(e.ensureChildrenArePreprocessed(c),Ms(c,e),!c.__inFrustum)return;if(!So(c,e)){ys(c,e);return}let t=!1,s=!1;const n=c.children;for(let i=0,r=n.length;i<r;i++){const a=n[i];Qn(a,e),t=t||xe(a,e.frameCount),s=s||a.__inFrustum}if(ys(c,e),t&&c.refine==="REPLACE"&&(c.__depth!==0||qn))for(let i=0,r=n.length;i<r;i++){const a=n[i];Zn(a,e)}}function Jn(c,e){const t=e.frameCount;if(!xe(c,t))return;const s=c.children;let n=!1;for(let i=0,r=s.length;i<r;i++){const a=s[i];n=n||xe(a,t)}if(!n)c.__isLeaf=!0;else{let i=!0;for(let r=0,a=s.length;r<a;r++){const o=s[r];if(Jn(o,e),xe(o,t)){const l=o.__allChildrenLoaded||!o.__hasContent||o.__hasRenderableContent&&Xn(o.__loadingState)||o.__hasUnrenderableContent&&o.__loadingState===ke;i=i&&l}}c.__allChildrenLoaded=i}}function ei(c,e){const t=e.stats;if(!xe(c,e.frameCount))return;if(c.__isLeaf){c.__loadingState===rt?(c.__inFrustum&&(c.__visible=!0,t.visible++),c.__active=!0,t.active++):c.__hasContent&&e.queueTileForDownload(c);return}const s=c.children,n=c.__hasContent,i=Xn(c.__loadingState)&&n,r=(e.errorTarget+1)*e.errorThreshold,a=c.__error<=r,o=c.refine==="ADD",l=c.__allChildrenLoaded||c.__depth===0&&!qn;if(n&&(a||o)&&e.queueTileForDownload(c),(a&&i&&!l||i&&o)&&(c.__inFrustum&&(c.__visible=!0,t.visible++),c.__active=!0,t.active++),!o&&a&&!l)for(let h=0,u=s.length;h<u;h++){const d=s[h];xe(d,e.frameCount)&&Yn(d,e)}else for(let h=0,u=s.length;h<u;h++)ei(s[h],e)}function ti(c,e){const t=xe(c,e.frameCount);if(t||c.__usedLastFrame){let s=!1,n=!1;t?(s=c.__active,e.displayActiveTiles?n=c.__active||c.__visible:n=c.__visible):Ms(c,e),c.__hasRenderableContent&&c.__loadingState===rt&&(c.__wasSetActive!==s&&e.invokeOnePlugin(r=>r.setTileActive&&r.setTileActive(c,s)),c.__wasSetVisible!==n&&e.invokeOnePlugin(r=>r.setTileVisible&&r.setTileVisible(c,n))),c.__wasSetActive=s,c.__wasSetVisible=n,c.__usedLastFrame=t;const i=c.children;for(let r=0,a=i.length;r<a;r++){const o=i[r];ti(o,e)}}}function Eo(c){let e=null;return()=>{e===null&&(e=requestAnimationFrame(()=>{e=null,c()}))}}const qs=Symbol("PLUGIN_REGISTERED"),Xs=(c,e)=>{const t=c.priority||0,s=e.priority||0;return t!==s?t>s?1:-1:c.__used!==e.__used?c.__used?1:-1:c.__error!==e.__error?c.__error>e.__error?1:-1:c.__distanceFromCamera!==e.__distanceFromCamera?c.__distanceFromCamera>e.__distanceFromCamera?-1:1:c.__depthFromRenderedParent!==e.__depthFromRenderedParent?c.__depthFromRenderedParent>e.__depthFromRenderedParent?-1:1:0},Po=(c,e)=>{const t=c.priority||0,s=e.priority||0;return t!==s?t>s?1:-1:c.__lastFrameVisited!==e.__lastFrameVisited?c.__lastFrameVisited>e.__lastFrameVisited?-1:1:c.__depthFromRenderedParent!==e.__depthFromRenderedParent?c.__depthFromRenderedParent>e.__depthFromRenderedParent?1:-1:c.__loadingState!==e.__loadingState?c.__loadingState>e.__loadingState?-1:1:c.__hasUnrenderableContent!==e.__hasUnrenderableContent?c.__hasUnrenderableContent?-1:1:c.__error!==e.__error?c.__error>e.__error?-1:1:0};let Ro=class{get root(){const e=this.rootTileSet;return e?e.root:null}get loadProgress(){const{stats:e,isLoading:t}=this,s=e.downloading+e.parsing,n=e.inCacheSinceLoad+(t?1:0);return n===0?1:1-s/n}get errorThreshold(){return this._errorThreshold}set errorThreshold(e){console.warn('TilesRenderer: The "errorThreshold" option has been deprecated.'),this._errorThreshold=e}constructor(e=null){this.rootLoadingState=ge,this.rootTileSet=null,this.rootURL=e,this.fetchOptions={},this.plugins=[],this.queuedTiles=[],this.cachedSinceLoadComplete=new Set,this.isLoading=!1;const t=new bo;t.unloadPriorityCallback=Po;const s=new Kt;s.maxJobs=25,s.priorityCallback=Xs;const n=new Kt;n.maxJobs=5,n.priorityCallback=Xs;const i=new Kt;i.maxJobs=25,this.processedTiles=new WeakSet,this.visibleTiles=new Set,this.activeTiles=new Set,this.usedSet=new Set,this.lruCache=t,this.downloadQueue=s,this.parseQueue=n,this.processNodeQueue=i,this.stats={inCacheSinceLoad:0,inCache:0,parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0,this._dispatchNeedsUpdateEvent=Eo(()=>{this.dispatchEvent({type:"needs-update"})}),this.errorTarget=16,this._errorThreshold=1/0,this.displayActiveTiles=!1,this.maxDepth=1/0}registerPlugin(e){if(e[qs]===!0)throw new Error("TilesRendererBase: A plugin can only be registered to a single tile set");const t=this.plugins,s=e.priority||0;let n=t.length;for(let i=0;i<t.length;i++)if((t[i].priority||0)>s){n=i;break}t.splice(n,0,e),e[qs]=!0,e.init&&e.init(this)}unregisterPlugin(e){const t=this.plugins;if(typeof e=="string"&&(e=this.getPluginByName(name)),t.includes(e)){const s=t.indexOf(e);return t.splice(s,1),e.dispose&&e.dispose(),!0}return!1}getPluginByName(e){return this.plugins.find(t=>t.name===e)||null}traverse(e,t,s=!0){this.root&&wo(this.root,(n,...i)=>(s&&this.ensureChildrenArePreprocessed(n,!0),e?e(n,...i):!1),t)}queueTileForDownload(e){e.__loadingState!==ge||this.lruCache.isFull()||this.queuedTiles.push(e)}markTileUsed(e){this.usedSet.add(e),this.lruCache.markUsed(e)}update(){const{lruCache:e,usedSet:t,stats:s,root:n,downloadQueue:i,parseQueue:r,processNodeQueue:a}=this;if(this.rootLoadingState===ge&&(this.rootLoadingState=ut,this.invokeOnePlugin(l=>l.loadRootTileSet&&l.loadRootTileSet()).then(l=>{let h=this.rootURL;h!==null&&this.invokeAllPlugins(u=>h=u.preprocessURL?u.preprocessURL(h,null):h),this.rootLoadingState=rt,this.rootTileSet=l,this.dispatchEvent({type:"needs-update"}),this.dispatchEvent({type:"load-content"}),this.dispatchEvent({type:"load-tile-set",tileSet:l,url:h})}).catch(l=>{this.rootLoadingState=ke,console.error(l),this.rootTileSet=null,this.dispatchEvent({type:"load-error",tile:null,error:l,url:this.rootURL})})),!n)return;s.inFrustum=0,s.used=0,s.active=0,s.visible=0,this.frameCount++,t.forEach(l=>e.markUnused(l)),t.clear(),Qn(n,this),Jn(n,this),ei(n,this),ti(n,this);const o=this.queuedTiles;o.sort(e.unloadPriorityCallback);for(let l=0,h=o.length;l<h&&!e.isFull();l++)this.requestTileContents(o[l]);o.length=0,e.scheduleUnload(),(i.running||r.running||a.running)===!1&&this.isLoading===!0&&(this.cachedSinceLoadComplete.clear(),s.inCacheSinceLoad=0,this.dispatchEvent({type:"tiles-load-end"}),this.isLoading=!1)}resetFailedTiles(){this.rootLoadingState===ke&&(this.rootLoadingState=ge);const e=this.stats;e.failed!==0&&(this.traverse(t=>{t.__loadingState===ke&&(t.__loadingState=ge)},null,!1),e.failed=0)}dispose(){[...this.plugins].forEach(s=>{this.unregisterPlugin(s)});const e=this.lruCache,t=[];this.traverse(s=>(t.push(s),!1),null,!1);for(let s=0,n=t.length;s<n;s++)e.remove(t[s]);this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0}calculateBytesUsed(e,t){return 0}dispatchEvent(e){}fetchData(e,t){return fetch(e,t)}parseTile(e,t,s){return null}disposeTile(e){e.__visible&&(this.invokeOnePlugin(t=>t.setTileVisible&&t.setTileVisible(e,!1)),e.__visible=!1),e.__active&&(this.invokeOnePlugin(t=>t.setTileActive&&t.setTileActive(e,!1)),e.__active=!1)}preprocessNode(e,t,s=null){var n;if(this.processedTiles.add(e),e.content&&(!("uri"in e.content)&&"url"in e.content&&(e.content.uri=e.content.url,delete e.content.url),e.content.boundingVolume&&!("box"in e.content.boundingVolume||"sphere"in e.content.boundingVolume||"region"in e.content.boundingVolume)&&delete e.content.boundingVolume),e.parent=s,e.children=e.children||[],(n=e.content)!=null&&n.uri){const i=Ks(e.content.uri);e.__hasContent=!0,e.__hasUnrenderableContent=!!(i&&/json$/.test(i)),e.__hasRenderableContent=!e.__hasUnrenderableContent}else e.__hasContent=!1,e.__hasUnrenderableContent=!1,e.__hasRenderableContent=!1;e.__childrenProcessed=0,s&&s.__childrenProcessed++,e.__distanceFromCamera=1/0,e.__error=1/0,e.__inFrustum=!1,e.__isLeaf=!1,e.__usedLastFrame=!1,e.__used=!1,e.__wasSetVisible=!1,e.__visible=!1,e.__allChildrenLoaded=!1,e.__wasSetActive=!1,e.__active=!1,e.__loadingState=ge,s===null?(e.__depth=0,e.__depthFromRenderedParent=e.__hasRenderableContent?1:0,e.refine=e.refine||"REPLACE"):(e.__depth=s.__depth+1,e.__depthFromRenderedParent=s.__depthFromRenderedParent+(e.__hasRenderableContent?1:0),e.refine=e.refine||s.refine),e.__basePath=t,e.__lastFrameVisited=-1,this.invokeAllPlugins(i=>{i!==this&&i.preprocessNode&&i.preprocessNode(e,t,s)})}setTileActive(e,t){t?this.activeTiles.add(e):this.activeTiles.delete(e)}setTileVisible(e,t){t?this.visibleTiles.add(e):this.visibleTiles.delete(e)}calculateTileViewError(e,t){}ensureChildrenArePreprocessed(e,t=!1){const s=e.children;for(let n=0,i=s.length;n<i;n++){const r=s[n];if("__depth"in r)break;t?(this.processNodeQueue.remove(r),this.preprocessNode(r,e.__basePath,e)):this.processNodeQueue.has(r)||this.processNodeQueue.add(r,a=>{this.preprocessNode(a,e.__basePath,e),this._dispatchNeedsUpdateEvent()})}}getBytesUsed(e){let t=0;return this.invokeAllPlugins(s=>{s.calculateBytesUsed&&(t+=s.calculateBytesUsed(e,e.cached.scene)||0)}),t}recalculateBytesUsed(e=null){const{lruCache:t,processedTiles:s}=this;e===null?t.itemSet.forEach(n=>{s.has(n)&&t.setMemoryUsage(n,this.getBytesUsed(n))}):t.setMemoryUsage(e,this.getBytesUsed(e))}preprocessTileSet(e,t,s=null){const n=e.asset.version,[i,r]=n.split(".").map(o=>parseInt(o));console.assert(i<=1,"TilesRenderer: asset.version is expected to be a 1.x or a compatible version."),i===1&&r>0&&console.warn("TilesRenderer: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.");let a=t.replace(/\/[^/]*$/,"");a=new URL(a,window.location.href).toString(),this.preprocessNode(e.root,a,s)}loadRootTileSet(){let e=this.rootURL;return this.invokeAllPlugins(t=>e=t.preprocessURL?t.preprocessURL(e,null):e),this.invokeOnePlugin(t=>t.fetchData&&t.fetchData(e,this.fetchOptions)).then(t=>{if(t instanceof Response){if(t.ok)return t.json();throw new Error(`TilesRenderer: Failed to load tileset "${e}" with status ${t.status} : ${t.statusText}`)}else return t}).then(t=>(this.preprocessTileSet(t,e),t))}requestTileContents(e){if(e.__loadingState!==ge)return;let t=!1,s=null,n=new URL(e.content.uri,e.__basePath+"/").toString();this.invokeAllPlugins(d=>n=d.preprocessURL?d.preprocessURL(n,e):n);const i=this.stats,r=this.lruCache,a=this.downloadQueue,o=this.parseQueue,l=Ks(n),h=new AbortController,u=h.signal;if(r.add(e,d=>{h.abort(),t?(d.children.length=0,d.__childrenProcessed=0):this.invokeAllPlugins(p=>{p.disposeTile&&p.disposeTile(d)}),i.inCache--,this.cachedSinceLoadComplete.has(e)&&(this.cachedSinceLoadComplete.delete(e),i.inCacheSinceLoad--),d.__loadingState===ut?i.downloading--:d.__loadingState===qt&&i.parsing--,d.__loadingState=ge,o.remove(d),a.remove(d)}))return this.isLoading||(this.isLoading=!0,this.dispatchEvent({type:"tiles-load-start"})),r.setMemoryUsage(e,this.getBytesUsed(e)),this.cachedSinceLoadComplete.add(e),i.inCacheSinceLoad++,i.inCache++,i.downloading++,e.__loadingState=ut,a.add(e,d=>{if(u.aborted)return Promise.resolve();const p=this.invokeOnePlugin(f=>f.fetchData&&f.fetchData(n,{...this.fetchOptions,signal:u}));return this.dispatchEvent({type:"tile-download-start",tile:e}),p}).then(d=>{if(!u.aborted)if(d instanceof Response){if(d.ok)return l==="json"?d.json():d.arrayBuffer();throw new Error(`Failed to load model with error code ${d.status}`)}else return d}).then(d=>{if(!u.aborted)return i.downloading--,i.parsing++,e.__loadingState=qt,o.add(e,p=>u.aborted?Promise.resolve():l==="json"&&d.root?(this.preprocessTileSet(d,n,e),e.children.push(d.root),s=d,t=!0,Promise.resolve()):this.invokeOnePlugin(f=>f.parseTile&&f.parseTile(d,p,l,n,u)))}).then(()=>{if(u.aborted)return;i.parsing--,e.__loadingState=rt,r.setLoaded(e,!0);const d=this.getBytesUsed(e);if(r.getMemoryUsage(e)===0&&d>0&&r.isFull()){r.remove(e);return}r.setMemoryUsage(e,d),this.dispatchEvent({type:"needs-update"}),this.dispatchEvent({type:"load-content"}),t&&this.dispatchEvent({type:"load-tile-set",tileSet:s,url:n}),e.cached.scene&&this.dispatchEvent({type:"load-model",scene:e.cached.scene,tile:e})}).catch(d=>{u.aborted||(d.name!=="AbortError"?(o.remove(e),a.remove(e),e.__loadingState===qt?i.parsing--:e.__loadingState===ut&&i.downloading--,i.failed++,console.error(`TilesRenderer : Failed to load tile at url "${e.content.uri}".`),console.error(d),e.__loadingState=ke,r.setLoaded(e,!0),this.dispatchEvent({type:"load-error",tile:e,error:d,url:n})):r.remove(e))})}getAttributions(e=[]){return this.invokeAllPlugins(t=>t!==this&&t.getAttributions&&t.getAttributions(e)),e}invokeOnePlugin(e){const t=[...this.plugins,this];for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}invokeAllPlugins(e){const t=[...this.plugins,this],s=[];for(let n=0;n<t.length;n++){const i=e(t[n]);i&&s.push(i)}return s.length===0?null:Promise.all(s)}};function si(c,e,t,s,n,i){let r;switch(s){case"SCALAR":r=1;break;case"VEC2":r=2;break;case"VEC3":r=3;break;case"VEC4":r=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${i}".`)}let a;const o=t*r;switch(n){case"BYTE":a=new Int8Array(c,e,o);break;case"UNSIGNED_BYTE":a=new Uint8Array(c,e,o);break;case"SHORT":a=new Int16Array(c,e,o);break;case"UNSIGNED_SHORT":a=new Uint16Array(c,e,o);break;case"INT":a=new Int32Array(c,e,o);break;case"UNSIGNED_INT":a=new Uint32Array(c,e,o);break;case"FLOAT":a=new Float32Array(c,e,o);break;case"DOUBLE":a=new Float64Array(c,e,o);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${i}".`)}return a}class Nt{constructor(e,t,s,n){this.buffer=e,this.binOffset=t+s,this.binLength=n;let i=null;if(s!==0){const r=new Uint8Array(e,t,s);i=JSON.parse(Kn(r))}else i={};this.header=i}getKeys(){return Object.keys(this.header).filter(e=>e!=="extensions")}getData(e,t,s=null,n=null){const i=this.header;if(!(e in i))return null;const r=i[e];if(r instanceof Object){if(Array.isArray(r))return r;{const{buffer:a,binOffset:o,binLength:l}=this,h=r.byteOffset||0,u=r.type||n,d=r.componentType||s;if("type"in r&&n&&r.type!==n)throw new Error("FeatureTable: Specified type does not match expected type.");const p=o+h,f=si(a,p,t,u,d,e);if(p+f.byteLength>o+l)throw new Error("FeatureTable: Feature data read outside binary body length.");return f}}else return r}getBuffer(e,t){const{buffer:s,binOffset:n}=this;return s.slice(n+e,n+e+t)}}let Co=class{constructor(e){this.batchTable=e;const t=e.header.extensions["3DTILES_batch_table_hierarchy"];this.classes=t.classes;for(const n of this.classes){const i=n.instances;for(const r in i)n.instances[r]=this._parseProperty(i[r],n.length,r)}if(this.instancesLength=t.instancesLength,this.classIds=this._parseProperty(t.classIds,this.instancesLength,"classIds"),t.parentCounts?this.parentCounts=this._parseProperty(t.parentCounts,this.instancesLength,"parentCounts"):this.parentCounts=new Array(this.instancesLength).fill(1),t.parentIds){const n=this.parentCounts.reduce((i,r)=>i+r,0);this.parentIds=this._parseProperty(t.parentIds,n,"parentIds")}else this.parentIds=null;this.instancesIds=[];const s={};for(const n of this.classIds)s[n]=s[n]??0,this.instancesIds.push(s[n]),s[n]++}_parseProperty(e,t,s){if(Array.isArray(e))return e;{const{buffer:n,binOffset:i}=this.batchTable,r=e.byteOffset,a=e.componentType||"UNSIGNED_SHORT",o=i+r;return si(n,o,t,"SCALAR",a,s)}}getDataFromId(e,t={}){const s=this.parentCounts[e];if(this.parentIds&&s>0){let o=0;for(let l=0;l<e;l++)o+=this.parentCounts[l];for(let l=0;l<s;l++){const h=this.parentIds[o+l];h!==e&&this.getDataFromId(h,t)}}const n=this.classIds[e],i=this.classes[n].instances,r=this.classes[n].name,a=this.instancesIds[e];for(const o in i)t[r]=t[r]||{},t[r][o]=i[o][a];return t}},Ss=class extends Nt{get batchSize(){return console.warn("BatchTable.batchSize has been deprecated and replaced with BatchTable.count."),this.count}constructor(e,t,s,n,i){super(e,s,n,i),this.count=t,this.extensions={};const r=this.header.extensions;r&&r["3DTILES_batch_table_hierarchy"]&&(this.extensions["3DTILES_batch_table_hierarchy"]=new Co(this))}getData(e,t=null,s=null){return console.warn("BatchTable: BatchTable.getData is deprecated. Use BatchTable.getDataFromId to get allproperties for an id or BatchTable.getPropertyArray for getting an array of value for a property."),super.getData(e,this.count,t,s)}getDataFromId(e,t={}){if(e<0||e>=this.count)throw new Error(`BatchTable: id value "${e}" out of bounds for "${this.count}" features number.`);for(const s of this.getKeys())t[s]=super.getData(s,this.count)[e];for(const s in this.extensions){const n=this.extensions[s];n.getDataFromId instanceof Function&&(t[s]=t[s]||{},n.getDataFromId(e,t[s]))}return t}getPropertyArray(e){return super.getData(e,this.count)}},vo=class extends Ot{parse(e){const t=new DataView(e),s=Ge(t);console.assert(s==="b3dm");const n=t.getUint32(4,!0);console.assert(n===1);const i=t.getUint32(8,!0);console.assert(i===e.byteLength);const r=t.getUint32(12,!0),a=t.getUint32(16,!0),o=t.getUint32(20,!0),l=t.getUint32(24,!0),h=28,u=e.slice(h,h+r+a),d=new Nt(u,0,r,a),p=h+r+a,f=e.slice(p,p+o+l),m=new Ss(f,d.getData("BATCH_LENGTH"),0,o,l),y=p+o+l,T=new Uint8Array(e,y,i-y);return{version:n,featureTable:d,batchTable:m,glbBytes:T}}},Ao=class extends Ot{parse(e){const t=new DataView(e),s=Ge(t);console.assert(s==="i3dm");const n=t.getUint32(4,!0);console.assert(n===1);const i=t.getUint32(8,!0);console.assert(i===e.byteLength);const r=t.getUint32(12,!0),a=t.getUint32(16,!0),o=t.getUint32(20,!0),l=t.getUint32(24,!0),h=t.getUint32(28,!0),u=32,d=e.slice(u,u+r+a),p=new Nt(d,0,r,a),f=u+r+a,m=e.slice(f,f+o+l),y=new Ss(m,p.getData("INSTANCES_LENGTH"),0,o,l),T=f+o+l,_=new Uint8Array(e,T,i-T);let M=null,g=null,w=null;if(h)M=_,g=Promise.resolve();else{const S=this.resolveExternalURL(Kn(_));w=xs(S),g=fetch(S,this.fetchOptions).then(b=>{if(!b.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${S}" with status ${b.status} : ${b.statusText}`);return b.arrayBuffer()}).then(b=>{M=new Uint8Array(b)})}return g.then(()=>({version:n,featureTable:p,batchTable:y,glbBytes:M,gltfWorkingPath:w}))}},Lo=class extends Ot{parse(e){const t=new DataView(e),s=Ge(t);console.assert(s==="pnts");const n=t.getUint32(4,!0);console.assert(n===1);const i=t.getUint32(8,!0);console.assert(i===e.byteLength);const r=t.getUint32(12,!0),a=t.getUint32(16,!0),o=t.getUint32(20,!0),l=t.getUint32(24,!0),h=28,u=e.slice(h,h+r+a),d=new Nt(u,0,r,a),p=h+r+a,f=e.slice(p,p+o+l),m=new Ss(f,d.getData("BATCH_LENGTH")||d.getData("POINTS_LENGTH"),0,o,l);return Promise.resolve({version:n,featureTable:d,batchTable:m})}},Do=class extends Ot{parse(e){const t=new DataView(e),s=Ge(t);console.assert(s==="cmpt",'CMPTLoader: The magic bytes equal "cmpt".');const n=t.getUint32(4,!0);console.assert(n===1,'CMPTLoader: The version listed in the header is "1".');const i=t.getUint32(8,!0);console.assert(i===e.byteLength,"CMPTLoader: The contents buffer length listed in the header matches the file.");const r=t.getUint32(12,!0),a=[];let o=16;for(let l=0;l<r;l++){const h=new DataView(e,o,12),u=Ge(h),d=h.getUint32(4,!0),p=h.getUint32(8,!0),f=new Uint8Array(e,o,p);a.push({type:u,buffer:f,version:d}),o+=p}return{version:n,tiles:a}}};const Io=await at("three"),{MathUtils:Fe,Spherical:ni,Vector3:k,Matrix4:He,Sphere:Fo,Ray:ii,Euler:Oo,Box3:No,Plane:Uo}=await at("three");new ni;new k;function ko(c){const{x:e,y:t,z:s}=c;c.x=s,c.y=e,c.z=t}function zo(c){return-c+Math.PI/2}const Zs=new ni,ye=new k,G=new k,Xt=new k,Z=new He,se=new He,Ys=new He,Zt=new Fo,H=new Oo,Qs=new k,Js=new k,en=new k,Se=new k,pt=new ii,$o=1e-12,Bo=.1,ft=0,tn=1,mt=2;let Es=class{constructor(e=1,t=1,s=1){this.name="",this.radius=new k(e,t,s)}intersectRay(e,t){return Z.makeScale(...this.radius).invert(),Zt.center.set(0,0,0),Zt.radius=1,pt.copy(e).applyMatrix4(Z),pt.intersectSphere(Zt,t)?(Z.makeScale(...this.radius),t.applyMatrix4(Z),t):null}getEastNorthUpFrame(e,t,s,n){return s.isMatrix4&&(n=s,s=0,console.warn('Ellipsoid: The signature for "getEastNorthUpFrame" has changed.')),this.getEastNorthUpAxes(e,t,Qs,Js,en),this.getCartographicToPosition(e,t,s,Se),n.makeBasis(Qs,Js,en).setPosition(Se)}getOrientedEastNorthUpFrame(e,t,s,n,i,r,a){return this.getObjectFrame(e,t,s,n,i,r,a,ft)}getObjectFrame(e,t,s,n,i,r,a,o=mt){return this.getEastNorthUpFrame(e,t,s,Z),H.set(i,r,-n,"ZXY"),a.makeRotationFromEuler(H).premultiply(Z),o===tn?(H.set(Math.PI/2,0,0,"XYZ"),se.makeRotationFromEuler(H),a.multiply(se)):o===mt&&(H.set(-Math.PI/2,0,Math.PI,"XYZ"),se.makeRotationFromEuler(H),a.multiply(se)),a}getCartographicFromObjectFrame(e,t,s=mt){return s===tn?(H.set(-Math.PI/2,0,0,"XYZ"),se.makeRotationFromEuler(H).premultiply(e)):s===mt?(H.set(-Math.PI/2,0,Math.PI,"XYZ"),se.makeRotationFromEuler(H).premultiply(e)):se.copy(e),Se.setFromMatrixPosition(se),this.getPositionToCartographic(Se,t),this.getEastNorthUpFrame(t.lat,t.lon,0,Z).invert(),se.premultiply(Z),H.setFromRotationMatrix(se,"ZXY"),t.azimuth=-H.z,t.elevation=H.x,t.roll=H.y,t}getEastNorthUpAxes(e,t,s,n,i,r=Se){this.getCartographicToPosition(e,t,0,r),this.getCartographicToNormal(e,t,i),s.set(-r.y,r.x,0).normalize(),n.crossVectors(i,s).normalize()}getAzElRollFromRotationMatrix(e,t,s,n,i=ft){return console.warn('Ellipsoid: "getAzElRollFromRotationMatrix" is deprecated. Use "getCartographicFromObjectFrame", instead.'),this.getCartographicToPosition(e,t,0,Se),Ys.copy(s).setPosition(Se),this.getCartographicFromObjectFrame(Ys,n,i),delete n.height,delete n.lat,delete n.lon,n}getRotationMatrixFromAzElRoll(e,t,s,n,i,r,a=ft){return console.warn('Ellipsoid: "getRotationMatrixFromAzElRoll" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(e,t,0,s,n,i,r,a),r.setPosition(0,0,0),r}getFrame(e,t,s,n,i,r,a,o=ft){return console.warn('Ellipsoid: "getFrame" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(e,t,r,s,n,i,a,o)}getCartographicToPosition(e,t,s,n){this.getCartographicToNormal(e,t,ye);const i=this.radius;G.copy(ye),G.x*=i.x**2,G.y*=i.y**2,G.z*=i.z**2;const r=Math.sqrt(ye.dot(G));return G.divideScalar(r),n.copy(G).addScaledVector(ye,s)}getPositionToCartographic(e,t){this.getPositionToSurfacePoint(e,G),this.getPositionToNormal(e,ye);const s=Xt.subVectors(e,G);return t.lon=Math.atan2(ye.y,ye.x),t.lat=Math.asin(ye.z),t.height=Math.sign(s.dot(e))*s.length(),t}getCartographicToNormal(e,t,s){return Zs.set(1,zo(e),t),s.setFromSpherical(Zs).normalize(),ko(s),s}getPositionToNormal(e,t){const s=this.radius;return t.copy(e),t.x/=s.x**2,t.y/=s.y**2,t.z/=s.z**2,t.normalize(),t}getPositionToSurfacePoint(e,t){const s=this.radius,n=1/s.x**2,i=1/s.y**2,r=1/s.z**2,a=e.x*e.x*n,o=e.y*e.y*i,l=e.z*e.z*r,h=a+o+l,u=Math.sqrt(1/h),d=G.copy(e).multiplyScalar(u);if(h<Bo)return isFinite(u)?t.copy(d):null;const p=Xt.set(d.x*n*2,d.y*i*2,d.z*r*2);let f=(1-u)*e.length()/(.5*p.length()),m=0,y,T,_,M,g,w,S,b,P,x,v;do{f-=m,_=1/(1+f*n),M=1/(1+f*i),g=1/(1+f*r),w=_*_,S=M*M,b=g*g,P=w*_,x=S*M,v=b*g,y=a*w+o*S+l*b-1,T=a*P*n+o*x*i+l*v*r;const F=-2*T;m=y/F}while(Math.abs(y)>$o);return t.set(e.x*_,e.y*M,e.z*g)}calculateHorizonDistance(e,t){const s=this.calculateEffectiveRadius(e);return Math.sqrt(2*s*t+t**2)}calculateEffectiveRadius(e){const t=this.radius.x,s=1-this.radius.z**2/t**2,n=e*Fe.DEG2RAD,i=Math.sin(n)**2;return t/Math.sqrt(1-s*i)}getPositionElevation(e){this.getPositionToSurfacePoint(e,G);const t=Xt.subVectors(e,G);return Math.sign(t.dot(e))*t.length()}closestPointToRayEstimate(e,t){return this.intersectRay(e,t)?t:(Z.makeScale(...this.radius).invert(),pt.copy(e).applyMatrix4(Z),G.set(0,0,0),pt.closestPointToPoint(G,t).normalize(),Z.makeScale(...this.radius),t.applyMatrix4(Z))}copy(e){return this.radius.copy(e.radius),this}clone(){return new this.constructor().copy(this)}};const gt=new k,yt=new k,j=new k,Tt=new ii;let sn=class{constructor(e=new No,t=new He){this.box=e.clone(),this.transform=t.clone(),this.inverseTransform=new He,this.points=new Array(8).fill().map(()=>new k),this.planes=new Array(6).fill().map(()=>new Uo)}copy(e){return this.box.copy(e.box),this.transform.copy(e.transform),this.update(),this}clone(){return new this.constructor().copy(this)}clampPoint(e,t){return t.copy(e).applyMatrix4(this.inverseTransform).clamp(this.box.min,this.box.max).applyMatrix4(this.transform)}distanceToPoint(e){return this.clampPoint(e,j).distanceTo(e)}containsPoint(e){return j.copy(e).applyMatrix4(this.inverseTransform),this.box.containsPoint(j)}intersectsRay(e){return Tt.copy(e).applyMatrix4(this.inverseTransform),Tt.intersectsBox(this.box)}intersectRay(e,t){return Tt.copy(e).applyMatrix4(this.inverseTransform),Tt.intersectBox(this.box,t)?(t.applyMatrix4(this.transform),t):null}update(){const{points:e,inverseTransform:t,transform:s,box:n}=this;t.copy(s).invert();const{min:i,max:r}=n;let a=0;for(let o=-1;o<=1;o+=2)for(let l=-1;l<=1;l+=2)for(let h=-1;h<=1;h+=2)e[a].set(o<0?i.x:r.x,l<0?i.y:r.y,h<0?i.z:r.z).applyMatrix4(s),a++;this.updatePlanes()}updatePlanes(){gt.copy(this.box.min).applyMatrix4(this.transform),yt.copy(this.box.max).applyMatrix4(this.transform),j.set(0,0,1).transformDirection(this.transform),this.planes[0].setFromNormalAndCoplanarPoint(j,gt),this.planes[1].setFromNormalAndCoplanarPoint(j,yt).negate(),j.set(0,1,0).transformDirection(this.transform),this.planes[2].setFromNormalAndCoplanarPoint(j,gt),this.planes[3].setFromNormalAndCoplanarPoint(j,yt).negate(),j.set(1,0,0).transformDirection(this.transform),this.planes[4].setFromNormalAndCoplanarPoint(j,gt),this.planes[5].setFromNormalAndCoplanarPoint(j,yt).negate()}intersectsSphere(e){return this.clampPoint(e.center,j),j.distanceToSquared(e.center)<=e.radius*e.radius}intersectsFrustum(e){return this._intersectsPlaneShape(e.planes,e.points)}intersectsOBB(e){return this._intersectsPlaneShape(e.planes,e.points)}_intersectsPlaneShape(e,t){const s=this.points,n=this.planes;for(let i=0;i<6;i++){const r=e[i];let a=-1/0;for(let o=0;o<8;o++){const l=s[o],h=r.distanceToPoint(l);a=a<h?h:a}if(a<0)return!1}for(let i=0;i<6;i++){const r=n[i];let a=-1/0;for(let o=0;o<8;o++){const l=t[o],h=r.distanceToPoint(l);a=a<h?h:a}if(a<0)return!1}return!0}};const _e=Math.PI,_t=_e/2,Ke=new k,Ae=new k,Le=new k,nn=new He;let tt=0;const Yt=[];function Vo(c=!1){return c?(Yt[tt]||(Yt[tt]=new k),tt++,Yt[tt-1]):new k}function rn(){tt=0}let Go=class extends Es{constructor(e,t,s,n=-_t,i=_t,r=0,a=2*_e,o=0,l=0){super(e,t,s),this.latStart=n,this.latEnd=i,this.lonStart=r,this.lonEnd=a,this.heightStart=o,this.heightEnd=l}_getPoints(e=!1){const{latStart:t,latEnd:s,lonStart:n,lonEnd:i,heightStart:r,heightEnd:a}=this,o=Fe.mapLinear(.5,0,1,t,s),l=Fe.mapLinear(.5,0,1,n,i),h=Math.floor(n/_t)*_t,u=[[-_e/2,0],[_e/2,0],[0,h],[0,h+_e/2],[0,h+_e],[0,h+3*_e/2],[t,i],[s,i],[t,n],[s,n],[0,n],[0,i],[o,l],[t,l],[s,l],[o,n],[o,i]],d=[],p=u.length;for(let f=0;f<=1;f++){const m=Fe.mapLinear(f,0,1,r,a);for(let y=0,T=p;y<T;y++){const[_,M]=u[y];if(_>=t&&_<=s&&M>=n&&M<=i){const g=Vo(e);d.push(g),this.getCartographicToPosition(_,M,m,g)}}}return d}getBoundingBox(e,t){rn();const{latStart:s,latEnd:n,lonStart:i,lonEnd:r}=this;if(n-s<_e/2){const o=Fe.mapLinear(.5,0,1,s,n),l=Fe.mapLinear(.5,0,1,i,r);this.getCartographicToNormal(o,l,Le),Ae.set(0,0,1),Ke.crossVectors(Ae,Le),Ae.crossVectors(Ke,Le),t.makeBasis(Ke,Ae,Le)}else Ke.set(1,0,0),Ae.set(0,1,0),Le.set(0,0,1),t.makeBasis(Ke,Ae,Le);nn.copy(t).invert();const a=this._getPoints(!0);for(let o=0,l=a.length;o<l;o++)a[o].applyMatrix4(nn);e.makeEmpty(),e.setFromPoints(a)}getBoundingSphere(e,t){rn();const s=this._getPoints(!0);e.makeEmpty(),e.setFromPoints(s,t)}};function Ho(c){const{TextureUtils:e}=Io;if(!e||!c)return 0;const{format:t,type:s,image:n}=c,{width:i,height:r}=n;let a=e.getByteLength(i,r,t,s);return a*=c.generateMipmaps?4/3:1,a}function jo(c){const e=new Set;let t=0;return c.traverse(s=>{if(s.geometry&&!e.has(s.geometry)&&(t+=Ji(s.geometry),e.add(s.geometry)),s.material){const n=s.material;for(const i in n){const r=n[i];r&&r.isTexture&&!e.has(r)&&(t+=Ho(r),e.add(r))}}}),t}const{DefaultLoadingManager:Ut,Matrix4:N,Vector3:E,Vector2:$,MathUtils:L,PointsMaterial:Wo,BufferGeometry:Ko,BufferAttribute:Ee,Color:qo,Points:Xo,InstancedMesh:Zo,Quaternion:we,Group:ot,Ray:kt,Sphere:Yo,Frustum:Qo,Matrix3:Jo,LoadingManager:ea,EventDispatcher:ze,Euler:ta,Mesh:sa,PlaneGeometry:na,ShaderMaterial:ia,Plane:ri,Raycaster:ra,Clock:oi,PerspectiveCamera:on,OrthographicCamera:ai}=await at("three");class ci extends vo{constructor(e=Ut){super(),this.manager=e,this.adjustmentTransform=new N}parse(e){const t=super.parse(e),s=t.glbBytes.slice().buffer;return new Promise((n,i)=>{const r=this.manager,a=this.fetchOptions,o=r.getHandler("path.gltf")||new bs(r);a.credentials==="include"&&a.mode==="cors"&&o.setCrossOrigin("use-credentials"),"credentials"in a&&o.setWithCredentials(a.credentials==="include"),a.headers&&o.setRequestHeader(a.headers);let l=this.workingPath;!/[\\/]$/.test(l)&&l.length&&(l+="/");const h=this.adjustmentTransform;o.parse(s,l,u=>{const{batchTable:d,featureTable:p}=t,{scene:f}=u,m=p.getData("RTC_CENTER",1,"FLOAT","VEC3");m&&(f.position.x+=m[0],f.position.y+=m[1],f.position.z+=m[2]),u.scene.updateMatrix(),u.scene.matrix.multiply(h),u.scene.matrix.decompose(u.scene.position,u.scene.quaternion,u.scene.scale),u.batchTable=d,u.featureTable=p,f.batchTable=d,f.featureTable=p,n(u)},i)})}}function oa(c){const e=c>>11,t=c>>5&63,s=c&31,n=Math.round(e/31*255),i=Math.round(t/63*255),r=Math.round(s/31*255);return[n,i,r]}const qe=new $;function aa(c,e,t=new E){qe.set(c,e).divideScalar(256).multiplyScalar(2).subScalar(1),t.set(qe.x,qe.y,1-Math.abs(qe.x)-Math.abs(qe.y));const s=L.clamp(-t.z,0,1);return t.x>=0?t.setX(t.x-s):t.setX(t.x+s),t.y>=0?t.setY(t.y-s):t.setY(t.y+s),t.normalize(),t}const an={RGB:"color",POSITION:"position"};class li extends Lo{constructor(e=Ut){super(),this.manager=e}parse(e){return super.parse(e).then(async t=>{const{featureTable:s,batchTable:n}=t,i=new Wo,r=s.header.extensions,a=new E;let o;if(r&&r["3DTILES_draco_point_compression"]){const{byteOffset:u,byteLength:d,properties:p}=r["3DTILES_draco_point_compression"],f=this.manager.getHandler("draco.drc");if(f==null)throw new Error("PNTSLoader: dracoLoader not available.");const m={};for(const _ in p)if(_ in an&&_ in p){const M=an[_];m[M]=p[_]}const y={attributeIDs:m,attributeTypes:{position:"Float32Array",color:"Uint8Array"},useUniqueIDs:!0},T=s.getBuffer(u,d);o=await f.decodeGeometry(T,y),o.attributes.color&&(i.vertexColors=!0)}else{const u=s.getData("POINTS_LENGTH"),d=s.getData("POSITION",u,"FLOAT","VEC3"),p=s.getData("NORMAL",u,"FLOAT","VEC3"),f=s.getData("NORMAL",u,"UNSIGNED_BYTE","VEC2"),m=s.getData("RGB",u,"UNSIGNED_BYTE","VEC3"),y=s.getData("RGBA",u,"UNSIGNED_BYTE","VEC4"),T=s.getData("RGB565",u,"UNSIGNED_SHORT","SCALAR"),_=s.getData("CONSTANT_RGBA",u,"UNSIGNED_BYTE","VEC4"),M=s.getData("POSITION_QUANTIZED",u,"UNSIGNED_SHORT","VEC3"),g=s.getData("QUANTIZED_VOLUME_SCALE",u,"FLOAT","VEC3"),w=s.getData("QUANTIZED_VOLUME_OFFSET",u,"FLOAT","VEC3");if(o=new Ko,M){const S=new Float32Array(u*3);for(let b=0;b<u;b++)for(let P=0;P<3;P++){const x=3*b+P;S[x]=M[x]/65535*g[P]}a.x=w[0],a.y=w[1],a.z=w[2],o.setAttribute("position",new Ee(S,3,!1))}else o.setAttribute("position",new Ee(d,3,!1));if(p!==null)o.setAttribute("normal",new Ee(p,3,!1));else if(f!==null){const S=new Float32Array(u*3),b=new E;for(let P=0;P<u;P++){const x=f[P*2],v=f[P*2+1],F=aa(x,v,b);S[P*3]=F.x,S[P*3+1]=F.y,S[P*3+2]=F.z}o.setAttribute("normal",new Ee(S,3,!1))}if(y!==null)o.setAttribute("color",new Ee(y,4,!0)),i.vertexColors=!0,i.transparent=!0,i.depthWrite=!1;else if(m!==null)o.setAttribute("color",new Ee(m,3,!0)),i.vertexColors=!0;else if(T!==null){const S=new Uint8Array(u*3);for(let b=0;b<u;b++){const P=oa(T[b]);for(let x=0;x<3;x++){const v=3*b+x;S[v]=P[x]}}o.setAttribute("color",new Ee(S,3,!0)),i.vertexColors=!0}else if(_!==null){const S=new qo(_[0],_[1],_[2]);i.color=S;const b=_[3]/255;b<1&&(i.opacity=b,i.transparent=!0,i.depthWrite=!1)}}const l=new Xo(o,i);l.position.copy(a),t.scene=l,t.scene.featureTable=s,t.scene.batchTable=n;const h=s.getData("RTC_CENTER",1,"FLOAT","VEC3");return h&&(t.scene.position.x+=h[0],t.scene.position.y+=h[1],t.scene.position.z+=h[2]),t})}}const je=new Es(Ws,Ws,xo);je.name="WGS84 Earth";const cn=new E,Qt=new E,Jt=new E,es=new E,ts=new we,bt=new E,xt=new N,ln=new N,hn=new E,un=new N,ss=new we,ns={};class hi extends Ao{constructor(e=Ut){super(),this.manager=e,this.adjustmentTransform=new N,this.ellipsoid=je.clone()}resolveExternalURL(e){return this.manager.resolveURL(super.resolveExternalURL(e))}parse(e){return super.parse(e).then(t=>{const{featureTable:s,batchTable:n}=t,i=t.glbBytes.slice().buffer;return new Promise((r,a)=>{const o=this.fetchOptions,l=this.manager,h=l.getHandler("path.gltf")||new bs(l);o.credentials==="include"&&o.mode==="cors"&&h.setCrossOrigin("use-credentials"),"credentials"in o&&h.setWithCredentials(o.credentials==="include"),o.headers&&h.setRequestHeader(o.headers);let u=t.gltfWorkingPath??this.workingPath;/[\\/]$/.test(u)||(u+="/");const d=this.adjustmentTransform;h.parse(i,u,p=>{const f=s.getData("INSTANCES_LENGTH"),m=s.getData("POSITION",f,"FLOAT","VEC3"),y=s.getData("NORMAL_UP",f,"FLOAT","VEC3"),T=s.getData("NORMAL_RIGHT",f,"FLOAT","VEC3"),_=s.getData("SCALE_NON_UNIFORM",f,"FLOAT","VEC3"),M=s.getData("SCALE",f,"FLOAT","SCALAR"),g=s.getData("RTC_CENTER",1,"FLOAT","VEC3"),w=s.getData("EAST_NORTH_UP");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach(x=>{x in s.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${x}" detected.`)});const S=new E;for(let x=0;x<f;x++)S.x+=m[x*3+0]/f,S.y+=m[x*3+1]/f,S.z+=m[x*3+2]/f;const b=[],P=[];p.scene.updateMatrixWorld(),p.scene.traverse(x=>{if(x.isMesh){P.push(x);const{geometry:v,material:F}=x,W=new Zo(v,F,f);W.position.copy(S),g&&(W.position.x+=g[0],W.position.y+=g[1],W.position.z+=g[2]),b.push(W)}});for(let x=0;x<f;x++){es.set(m[x*3+0]-S.x,m[x*3+1]-S.y,m[x*3+2]-S.z),ts.identity(),y&&(Qt.set(y[x*3+0],y[x*3+1],y[x*3+2]),Jt.set(T[x*3+0],T[x*3+1],T[x*3+2]),cn.crossVectors(Jt,Qt).normalize(),xt.makeBasis(Jt,Qt,cn),ts.setFromRotationMatrix(xt)),bt.set(1,1,1),_&&bt.set(_[x*3+0],_[x*3+1],_[x*3+2]),M&&bt.multiplyScalar(M[x]);for(let v=0,F=b.length;v<F;v++){const W=b[v];ss.copy(ts),w&&(W.updateMatrixWorld(),hn.copy(es).applyMatrix4(W.matrixWorld),this.ellipsoid.getPositionToCartographic(hn,ns),this.ellipsoid.getEastNorthUpFrame(ns.lat,ns.lon,un),ss.setFromRotationMatrix(un)),xt.compose(es,ss,bt).multiply(d);const oe=P[v];ln.multiplyMatrices(xt,oe.matrixWorld),W.setMatrixAt(x,ln)}}p.scene.clear(),p.scene.add(...b),p.batchTable=n,p.featureTable=s,p.scene.batchTable=n,p.scene.featureTable=s,r(p)},a)})})}}class ca extends Do{constructor(e=Ut){super(),this.manager=e,this.adjustmentTransform=new N,this.ellipsoid=je.clone()}parse(e){const t=super.parse(e),{manager:s,ellipsoid:n,adjustmentTransform:i}=this,r=[];for(const a in t.tiles){const{type:o,buffer:l}=t.tiles[a];switch(o){case"b3dm":{const h=l.slice(),u=new ci(s);u.workingPath=this.workingPath,u.fetchOptions=this.fetchOptions,u.adjustmentTransform.copy(i);const d=u.parse(h.buffer);r.push(d);break}case"pnts":{const h=l.slice(),u=new li(s);u.workingPath=this.workingPath,u.fetchOptions=this.fetchOptions;const d=u.parse(h.buffer);r.push(d);break}case"i3dm":{const h=l.slice(),u=new hi(s);u.workingPath=this.workingPath,u.fetchOptions=this.fetchOptions,u.ellipsoid.copy(n),u.adjustmentTransform.copy(i);const d=u.parse(h.buffer);r.push(d);break}}}return Promise.all(r).then(a=>{const o=new ot;return a.forEach(l=>{o.add(l.scene)}),{tiles:a,scene:o}})}}const Xe=new N;class la extends ot{constructor(e){super(),this.isTilesGroup=!0,this.name="TilesRenderer.TilesGroup",this.tilesRenderer=e,this.matrixWorldInverse=new N}raycast(e,t){return this.tilesRenderer.optimizeRaycast?(this.tilesRenderer.raycast(e,t),!1):!0}updateMatrixWorld(e){if(this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldNeedsUpdate||e){this.parent===null?Xe.copy(this.matrix):Xe.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1;const t=Xe.elements,s=this.matrixWorld.elements;let n=!1;for(let i=0;i<16;i++){const r=t[i],a=s[i];if(Math.abs(r-a)>Number.EPSILON){n=!0;break}}if(n){this.matrixWorld.copy(Xe),this.matrixWorldInverse.copy(Xe).invert();const i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].updateMatrixWorld()}}}updateWorldMatrix(e,t){this.parent&&e&&this.parent.updateWorldMatrix(e,!1),this.updateMatrixWorld(!0)}}const ui=new kt,is=new E,wt=[];function di(c,e){return c.distance-e.distance}function pi(c,e,t,s){const{scene:n}=c.cached;t.invokeOnePlugin(i=>i.raycastTile&&i.raycastTile(c,n,e,s))||e.intersectObject(n,!0,s)}function ha(c,e,t){pi(c,e,t,wt),wt.sort(di);const s=wt[0]||null;return wt.length=0,s}function fi(c){return"__used"in c}function mi(c,e,t,s=null){const{group:n,activeTiles:i}=c;s===null&&(s=ui,s.copy(t.ray).applyMatrix4(n.matrixWorldInverse));const r=[],a=e.children;for(let h=0,u=a.length;h<u;h++){const d=a[h];!fi(d)||!d.__used||d.cached.boundingVolume.intersectRay(s,is)!==null&&(is.applyMatrix4(n.matrixWorld),r.push({distance:is.distanceToSquared(t.ray.origin),tile:d}))}r.sort(di);let o=null,l=1/0;if(i.has(e)){const h=ha(e,t,c);h&&(o=h,l=h.distance*h.distance)}for(let h=0,u=r.length;h<u;h++){const d=r[h],p=d.distance,f=d.tile;if(p>l)break;const m=mi(c,f,t,s);if(m){const y=m.distance*m.distance;y<l&&(o=m,l=y)}}return o}function gi(c,e,t,s,n=null){if(!fi(e))return;const{group:i,activeTiles:r}=c,{boundingVolume:a}=e.cached;if(n===null&&(n=ui,n.copy(t.ray).applyMatrix4(i.matrixWorldInverse)),!e.__used||!a.intersectsRay(n))return;r.has(e)&&pi(e,t,c,s);const o=e.children;for(let l=0,h=o.length;l<h;l++)gi(c,o[l],t,s,n)}const ae=new E,ce=new E,le=new E,dn=new E,pn=new E;class ua{constructor(){this.sphere=null,this.obb=null,this.region=null,this.regionObb=null}intersectsRay(e){const t=this.sphere,s=this.obb||this.regionObb;return!(t&&!e.intersectsSphere(t)||s&&!s.intersectsRay(e))}intersectRay(e,t=null){const s=this.sphere,n=this.obb||this.regionObb;let i=-1/0,r=-1/0;s&&e.intersectSphere(s,dn)&&(i=s.containsPoint(e.origin)?0:e.origin.distanceToSquared(dn)),n&&n.intersectRay(e,pn)&&(r=n.containsPoint(e.origin)?0:e.origin.distanceToSquared(pn));const a=Math.max(i,r);return a===-1/0?null:(e.at(Math.sqrt(a),t),t)}distanceToPoint(e){const t=this.sphere,s=this.obb||this.regionObb;let n=-1/0,i=-1/0;return t&&(n=Math.max(t.distanceToPoint(e),0)),s&&(i=s.distanceToPoint(e)),n>i?n:i}intersectsFrustum(e){const t=this.obb||this.regionObb,s=this.sphere;return s&&!e.intersectsSphere(s)||t&&!t.intersectsFrustum(e)?!1:!!(s||t)}intersectsSphere(e){const t=this.obb||this.regionObb,s=this.sphere;return s&&!s.intersectsSphere(e)||t&&!t.intersectsSphere(e)?!1:!!(s||t)}intersectsOBB(e){const t=this.obb||this.regionObb,s=this.sphere;return s&&!e.intersectsSphere(s)||t&&!t.intersectsOBB(e)?!1:!!(s||t)}getOBB(e,t){const s=this.obb||this.regionObb;s?(e.copy(s.box),t.copy(s.transform)):(this.getAABB(e),t.identity())}getAABB(e){if(this.sphere)this.sphere.getBoundingBox(e);else{const t=this.obb||this.regionObb;e.copy(t.box).applyMatrix4(t.transform)}}getSphere(e){if(this.sphere)e.copy(this.sphere);else if(this.region)this.region.getBoundingSphere(e);else{const t=this.obb||this.regionObb;t.box.getBoundingSphere(e),e.applyMatrix4(t.transform)}}setObbData(e,t){const s=new sn;ae.set(e[3],e[4],e[5]),ce.set(e[6],e[7],e[8]),le.set(e[9],e[10],e[11]);const n=ae.length(),i=ce.length(),r=le.length();ae.normalize(),ce.normalize(),le.normalize(),n===0&&ae.crossVectors(ce,le),i===0&&ce.crossVectors(ae,le),r===0&&le.crossVectors(ae,ce),s.transform.set(ae.x,ce.x,le.x,e[0],ae.y,ce.y,le.y,e[1],ae.z,ce.z,le.z,e[2],0,0,0,1).premultiply(t),s.box.min.set(-n,-i,-r),s.box.max.set(n,i,r),s.update(),this.obb=s}setSphereData(e,t,s,n,i){const r=new Yo;r.center.set(e,t,s),r.radius=n,r.applyMatrix4(i),this.sphere=r}setRegionData(e,t,s,n,i,r,a){const o=new Go(...e.radius,s,i,t,n,r,a),l=new sn;o.getBoundingBox(l.box,l.transform),l.update(),this.region=o,this.regionObb=l}}const da=new Jo;function pa(c,e,t,s){const n=da.set(c.normal.x,c.normal.y,c.normal.z,e.normal.x,e.normal.y,e.normal.z,t.normal.x,t.normal.y,t.normal.z);return s.set(-c.constant,-e.constant,-t.constant),s.applyMatrix3(n.invert()),s}class fa extends Qo{constructor(){super(),this.points=Array(8).fill().map(()=>new E)}setFromProjectionMatrix(e,t){return super.setFromProjectionMatrix(e,t),this.calculateFrustumPoints(),this}calculateFrustumPoints(){const{planes:e,points:t}=this;[[e[0],e[3],e[4]],[e[1],e[3],e[4]],[e[0],e[2],e[4]],[e[1],e[2],e[4]],[e[0],e[3],e[5]],[e[1],e[3],e[5]],[e[0],e[2],e[5]],[e[1],e[2],e[5]]].forEach((s,n)=>{pa(s[0],s[1],s[2],t[n])})}}const fn=new N,mn=new ta,yi=Symbol("INITIAL_FRUSTUM_CULLED"),Mt=new N,Ze=new E,rs=new $,St={inView:!1,error:1/0},ma=new E(1,0,0),ga=new E(0,1,0);function gn(c,e){c.traverse(t=>{t.frustumCulled=t[yi]&&e})}class Ka extends Ro{get autoDisableRendererCulling(){return this._autoDisableRendererCulling}set autoDisableRendererCulling(e){this._autoDisableRendererCulling!==e&&(super._autoDisableRendererCulling=e,this.forEachLoadedModel(t=>{gn(t,!e)}))}get optimizeRaycast(){return this._optimizeRaycast}set optimizeRaycast(e){console.warn('TilesRenderer: The "optimizeRaycast" option has been deprecated.'),this._optimizeRaycast=e}constructor(...e){super(...e),this.group=new la(this),this.ellipsoid=je.clone(),this.cameras=[],this.cameraMap=new Map,this.cameraInfo=[],this._optimizeRaycast=!0,this._upRotationMatrix=new N,this._bytesUsed=new WeakMap,this._autoDisableRendererCulling=!0;const t=new ea;t.setURLModifier(s=>this.preprocessURL?this.preprocessURL(s):s),this.manager=t,this._listeners={}}addEventListener(...e){ze.prototype.addEventListener.call(this,...e)}hasEventListener(...e){ze.prototype.hasEventListener.call(this,...e)}removeEventListener(...e){ze.prototype.removeEventListener.call(this,...e)}dispatchEvent(...e){ze.prototype.dispatchEvent.call(this,...e)}getBoundingBox(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return t?(t.getAABB(e),!0):!1}getOrientedBoundingBox(e,t){if(!this.root)return!1;const s=this.root.cached.boundingVolume;return s?(s.getOBB(e,t),!0):!1}getBoundingSphere(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return t?(t.getSphere(e),!0):!1}forEachLoadedModel(e){this.traverse(t=>{const s=t.cached&&t.cached.scene;s&&e(s,t)},null,!1)}raycast(e,t){if(this.root)if(e.firstHitOnly){const s=mi(this,this.root,e);s&&t.push(s)}else gi(this,this.root,e,t)}hasCamera(e){return this.cameraMap.has(e)}setCamera(e){const t=this.cameras,s=this.cameraMap;return s.has(e)?!1:(s.set(e,new $),t.push(e),this.dispatchEvent({type:"add-camera",camera:e}),!0)}setResolution(e,t,s){const n=this.cameraMap;if(!n.has(e))return!1;const i=t.isVector2?t.x:t,r=t.isVector2?t.y:s,a=n.get(e);return(a.width!==i||a.height!==r)&&(a.set(i,r),this.dispatchEvent({type:"camera-resolution-change"})),!0}setResolutionFromRenderer(e,t){return t.getSize(rs),this.setResolution(e,rs.x,rs.y)}deleteCamera(e){const t=this.cameras,s=this.cameraMap;if(s.has(e)){const n=t.indexOf(e);return t.splice(n,1),s.delete(e),this.dispatchEvent({type:"delete-camera",camera:e}),!0}return!1}loadRootTileSet(...e){return super.loadRootTileSet(...e).then(t=>{const{asset:s,extensions:n={}}=t;switch((s&&s.gltfUpAxis||"y").toLowerCase()){case"x":this._upRotationMatrix.makeRotationAxis(ga,-Math.PI/2);break;case"y":this._upRotationMatrix.makeRotationAxis(ma,Math.PI/2);break}if("3DTILES_ellipsoid"in n){const i=n["3DTILES_ellipsoid"],{ellipsoid:r}=this;r.name=i.body,i.radii?r.radius.set(...i.radii):r.radius.set(1,1,1)}return t})}update(){let e=null;if(this.invokeAllPlugins(r=>{if(r.doTilesNeedUpdate){const a=r.doTilesNeedUpdate();e===null?e=a:e=!!(e||a)}}),e===!1){this.dispatchEvent({type:"update-before"}),this.dispatchEvent({type:"update-after"});return}this.dispatchEvent({type:"update-before"});const t=this.group,s=this.cameras,n=this.cameraMap,i=this.cameraInfo;for(;i.length>s.length;)i.pop();for(;i.length<s.length;)i.push({frustum:new fa,isOrthographic:!1,sseDenominator:-1,position:new E,invScale:-1,pixelSize:0});Ze.setFromMatrixScale(t.matrixWorldInverse),Math.abs(Math.max(Ze.x-Ze.y,Ze.x-Ze.z))>1e-6&&console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.");for(let r=0,a=i.length;r<a;r++){const o=s[r],l=i[r],h=l.frustum,u=l.position,d=n.get(o);(d.width===0||d.height===0)&&console.warn("TilesRenderer: resolution for camera error calculation is not set.");const p=o.projectionMatrix.elements;if(l.isOrthographic=p[15]===1,l.isOrthographic){const f=2/p[0],m=2/p[5];l.pixelSize=Math.max(m/d.height,f/d.width)}else l.sseDenominator=2/p[5]/d.height;Mt.copy(t.matrixWorld),Mt.premultiply(o.matrixWorldInverse),Mt.premultiply(o.projectionMatrix),h.setFromProjectionMatrix(Mt),u.set(0,0,0),u.applyMatrix4(o.matrixWorld),u.applyMatrix4(t.matrixWorldInverse)}if(super.update(),this.dispatchEvent({type:"update-after"}),s.length===0&&this.root){let r=!1;this.invokeAllPlugins(a=>r=r||!!(a!==this&&a.calculateTileViewError)),r===!1&&console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles.")}}preprocessNode(e,t,s=null){super.preprocessNode(e,t,s);const n=new N;if(e.transform){const a=e.transform;for(let o=0;o<16;o++)n.elements[o]=a[o]}s&&n.premultiply(s.cached.transform);const i=new N().copy(n).invert(),r=new ua;"sphere"in e.boundingVolume&&r.setSphereData(...e.boundingVolume.sphere,n),"box"in e.boundingVolume&&r.setObbData(e.boundingVolume.box,n),"region"in e.boundingVolume&&r.setRegionData(this.ellipsoid,...e.boundingVolume.region),e.cached={transform:n,transformInverse:i,active:!1,boundingVolume:r,metadata:null,scene:null,geometry:null,materials:null,textures:null}}async parseTile(e,t,s,n,i){const r=t.cached,a=xs(n),o=this.fetchOptions,l=this.manager;let h=null;const u=r.transform,d=this._upRotationMatrix,p=(Ge(e)||s).toLowerCase();switch(p){case"b3dm":{const g=new ci(l);g.workingPath=a,g.fetchOptions=o,g.adjustmentTransform.copy(d),h=g.parse(e);break}case"pnts":{const g=new li(l);g.workingPath=a,g.fetchOptions=o,h=g.parse(e);break}case"i3dm":{const g=new hi(l);g.workingPath=a,g.fetchOptions=o,g.adjustmentTransform.copy(d),g.ellipsoid.copy(this.ellipsoid),h=g.parse(e);break}case"cmpt":{const g=new ca(l);g.workingPath=a,g.fetchOptions=o,g.adjustmentTransform.copy(d),g.ellipsoid.copy(this.ellipsoid),h=g.parse(e).then(w=>w.scene);break}case"gltf":case"glb":{const g=l.getHandler("path.gltf")||l.getHandler("path.glb")||new bs(l);g.setWithCredentials(o.credentials==="include"),g.setRequestHeader(o.headers||{}),o.credentials==="include"&&o.mode==="cors"&&g.setCrossOrigin("use-credentials");let w=g.resourcePath||g.path||a;!/[\\/]$/.test(w)&&w.length&&(w+="/"),h=g.parseAsync(e,w).then(S=>{S.scene=S.scene||new ot;const{scene:b}=S;return b.updateMatrix(),b.matrix.multiply(d).decompose(b.position,b.quaternion,b.scale),S});break}default:{h=this.invokeOnePlugin(g=>g.parseToMesh&&g.parseToMesh(e,t,s,n,i));break}}const f=await h;if(f===null)throw new Error(`TilesRenderer: Content type "${p}" not supported.`);let m,y;f.isObject3D?(m=f,y=null):(m=f.scene,y=f),m.updateMatrix(),m.matrix.premultiply(u),m.matrix.decompose(m.position,m.quaternion,m.scale),await this.invokeAllPlugins(g=>g.processTileModel&&g.processTileModel(m,t)),m.traverse(g=>{g[yi]=g.frustumCulled}),gn(m,!this.autoDisableRendererCulling);const T=[],_=[],M=[];if(m.traverse(g=>{if(g.geometry&&_.push(g.geometry),g.material){const w=g.material;T.push(g.material);for(const S in w){const b=w[S];b&&b.isTexture&&M.push(b)}}}),i.aborted){for(let g=0,w=M.length;g<w;g++){const S=M[g];S.image instanceof ImageBitmap&&S.image.close(),S.dispose()}return}r.materials=T,r.geometry=_,r.textures=M,r.scene=m,r.metadata=y}disposeTile(e){super.disposeTile(e);const t=e.cached;if(t.scene){const s=t.materials,n=t.geometry,i=t.textures,r=t.scene.parent;t.scene.traverse(a=>{a.userData.meshFeatures&&a.userData.meshFeatures.dispose(),a.userData.structuralMetadata&&a.userData.structuralMetadata.dispose()});for(let a=0,o=n.length;a<o;a++)n[a].dispose();for(let a=0,o=s.length;a<o;a++)s[a].dispose();for(let a=0,o=i.length;a<o;a++){const l=i[a];l.image instanceof ImageBitmap&&l.image.close(),l.dispose()}r&&r.remove(t.scene),this.dispatchEvent({type:"dispose-model",scene:t.scene,tile:e}),t.scene=null,t.materials=null,t.textures=null,t.geometry=null,t.metadata=null}}setTileVisible(e,t){const s=e.cached.scene,n=this.group;t?s&&(n.add(s),s.updateMatrixWorld(!0)):s&&n.remove(s),super.setTileVisible(e,t),this.dispatchEvent({type:"tile-visibility-change",scene:s,tile:e,visible:t})}calculateBytesUsed(e,t){const s=this._bytesUsed;return!s.has(e)&&t&&s.set(e,jo(t)),s.get(e)??null}calculateTileViewError(e,t){const s=e.cached,n=this.cameras,i=this.cameraInfo,r=s.boundingVolume;let a=!1,o=-1/0,l=1/0,h=-1/0,u=1/0;for(let d=0,p=n.length;d<p;d++){const f=i[d];let m,y;if(f.isOrthographic){const _=f.pixelSize;m=e.geometricError/_,y=1/0}else{const _=f.sseDenominator;y=r.distanceToPoint(f.position),m=y===0?1/0:e.geometricError/(y*_)}const T=i[d].frustum;r.intersectsFrustum(T)&&(a=!0,o=Math.max(o,m),l=Math.min(l,y)),h=Math.max(h,m),u=Math.min(u,y)}this.invokeAllPlugins(d=>{d!==this&&d.calculateTileViewError&&(d.calculateTileViewError(e,St),St.inView&&(a=!0,o=Math.max(o,St.error)),h=Math.max(h,St.error))}),a?(t.inView=!0,t.error=o,t.distanceFromCamera=l):(t.inView=!1,t.error=h,t.distanceFromCamera=u)}setLatLonToYUp(e,t){console.warn("TilesRenderer: setLatLonToYUp is deprecated. Use the ReorientationPlugin, instead.");const{ellipsoid:s,group:n}=this;mn.set(Math.PI/2,Math.PI/2,0),fn.makeRotationFromEuler(mn),s.getEastNorthUpFrame(e,t,0,n.matrix).multiply(fn).invert().decompose(n.position,n.quaternion,n.scale),n.updateMatrixWorld(!0)}dispose(){super.dispose(),this.group.removeFromParent()}}class ya extends sa{constructor(){super(new na(0,0),new Ta),this.renderOrder=1/0}onBeforeRender(e){const t=this.material.uniforms;e.getSize(t.resolution.value)}updateMatrixWorld(){this.matrixWorld.makeTranslation(this.position)}dispose(){this.geometry.dispose(),this.material.dispose()}}class Ta extends ia{constructor(){super({depthWrite:!1,depthTest:!1,transparent:!0,uniforms:{resolution:{value:new $},size:{value:15},thickness:{value:2},opacity:{value:1}},vertexShader:`

				uniform float pixelRatio;
				uniform float size;
				uniform float thickness;
				uniform vec2 resolution;
				varying vec2 vUv;

				void main() {

					vUv = uv;

					float aspect = resolution.x / resolution.y;
					vec2 offset = uv * 2.0 - vec2( 1.0 );
					offset.y *= aspect;

					vec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					screenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;

					gl_Position = screenPoint;

				}
			`,fragmentShader:`

				uniform float size;
				uniform float thickness;
				uniform float opacity;

				varying vec2 vUv;
				void main() {

					float ht = 0.5 * thickness;
					float planeDim = size + thickness;
					float offset = ( planeDim - ht - 2.0 ) / planeDim;
					float texelThickness = ht / planeDim;

					vec2 vec = vUv * 2.0 - vec2( 1.0 );
					float dist = abs( length( vec ) - offset );
					float fw = fwidth( dist ) * 0.5;
					float a = smoothstep( texelThickness - fw, texelThickness + fw, dist );

					gl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );

				}
			`})}}const yn=new $,Tn=new $;class _a{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new $,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new $,this.hoverSet=!1}updateFrame(){const{previousPositions:e,pointerPositions:t}=this;for(const s in t)e[s].copy(t[s])}setHoverEvent(e){(e.pointerType==="mouse"||e.type==="wheel")&&(this.getAdjustedPointer(e,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(e){return this.pointerType!==null?(this.getCenterPoint(e),e):this.hoverSet?(e.copy(this.hoverPosition),e):null}getAdjustedPointer(e,t){const s=(this.domElement?this.domElement:e.target).getBoundingClientRect(),n=e.clientX-s.left,i=e.clientY-s.top;t.set(n,i)}addPointer(e){const t=e.pointerId,s=new $;this.getAdjustedPointer(e,s),this.pointerOrder.push(t),this.pointerPositions[t]=s,this.previousPositions[t]=s.clone(),this.startPositions[t]=s.clone(),this.getPointerCount()===1&&(this.pointerType=e.pointerType,this.buttons=e.buttons)}updatePointer(e){const t=e.pointerId;return t in this.pointerPositions?(this.getAdjustedPointer(e,this.pointerPositions[t]),!0):!1}deletePointer(e){const t=e.pointerId,s=this.pointerOrder;s.splice(s.indexOf(t),1),delete this.pointerPositions[t],delete this.previousPositions[t],delete this.startPositions[t],this.getPointerCount.length===0&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(e,t=this.pointerPositions){const s=this.pointerOrder;if(this.getPointerCount()===1||this.getPointerType()==="mouse"){const n=s[0];return e.copy(t[n]),e}else if(this.getPointerCount()===2){const n=this.pointerOrder[0],i=this.pointerOrder[1],r=t[n],a=t[i];return e.addVectors(r,a).multiplyScalar(.5),e}return null}getPreviousCenterPoint(e){return this.getCenterPoint(e,this.previousPositions)}getStartCenterPoint(e){return this.getCenterPoint(e,this.startPositions)}getMoveDistance(){return this.getCenterPoint(yn),this.getPreviousCenterPoint(Tn),yn.sub(Tn).length()}getTouchPointerDistance(e=this.pointerPositions){if(this.getPointerCount()<=1||this.getPointerType()==="mouse")return 0;const{pointerOrder:t}=this,s=t[0],n=t[1],i=e[s],r=e[n];return i.distanceTo(r)}getPreviousTouchPointerDistance(){return this.getTouchPointerDistance(this.previousPositions)}getStartTouchPointerDistance(){return this.getTouchPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return this.getPointerType()==="touch"}getPointerButtons(){return this.buttons}isLeftClicked(){return!!(this.buttons&1)}isRightClicked(){return!!(this.buttons&2)}}const Et=new N;new E;function Be(c,e,t){return t.makeTranslation(-c.x,-c.y,-c.z),Et.makeRotationFromQuaternion(e),t.premultiply(Et),Et.makeTranslation(c.x,c.y,c.z),t.premultiply(Et),t}function Oe(c,e,t,s){s.x=(c-t.offsetLeft)/t.clientWidth*2-1,s.y=-((e-t.offsetTop)/t.clientHeight)*2+1,s.isVector3&&(s.z=0)}function J(c,e,t){const s=c instanceof kt?c:c.ray,{origin:n,direction:i}=s;n.set(e.x,e.y,-1).unproject(t),i.set(e.x,e.y,1).unproject(t).sub(n),c.isRay||(c.near=0,c.far=i.length(),c.camera=t),i.normalize()}const te=0,be=1,he=2,Ne=3,os=4,as=.05,cs=.025,Te=new N,Pt=new N,K=new E,R=new E,Rt=new E,Ct=new E,z=new E,Y=new E,ls=new E,vt=new E,ee=new we,_n=new ri,O=new E,At=new E,hs=new E,ba=new we,D=new kt,Ye=new $,U=new $,bn=new $,Qe=new $,us=new $,xn=new $,wn={type:"change"},Mn={type:"start"},Sn={type:"end"};class xa extends ze{get enabled(){return this._enabled}set enabled(e){e!==this.enabled&&(this._enabled=e,this.resetState(),this.pointerTracker.reset(),this.enabled||(this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0)))}constructor(e=null,t=null,s=null,n=null){super(),this.isEnvironmentControls=!0,this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.enableDamping=!1,this.dampingFactor=.15,this.fallbackPlane=new ri(new E(0,1,0),0),this.useFallbackPlane=!0,this.scaleZoomOrientationAtEdges=!1,this.autoAdjustCameraRotation=!0,this.state=te,this.pointerTracker=new _a,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new E,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new E,this.zoomPoint=new E,this.zoomDelta=0,this.rotationInertiaPivot=new E,this.rotationInertia=new $,this.dragInertia=new E,this.inertiaTargetDistance=1/0,this.inertiaStableFrames=0,this.pivotMesh=new ya,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new ra,this.raycaster.firstHitOnly=!0,this.up=new E(0,1,0),this.clock=new oi,this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=te,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,s&&this.attach(s),t&&this.setCamera(t),e&&this.setScene(e),n&&this.setTilesRenderer(n)}setScene(e){this.scene=e}setCamera(e){this.camera=e,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.raycaster.camera=e,this.resetState()}setTilesRenderer(e){console.warn('EnvironmentControls: "setTilesRenderer" has been deprecated. Use "setScene" and "setEllipsoid", instead.'),this.tilesRenderer=e,this.tilesRenderer!==null&&this.setScene(this.tilesRenderer.group)}attach(e){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=e,this.pointerTracker.domElement=e,e.style.touchAction="none";const t=h=>{this.enabled&&h.preventDefault()},s=h=>{if(!this.enabled)return;h.preventDefault();const{camera:u,raycaster:d,domElement:p,up:f,pivotMesh:m,pointerTracker:y,scene:T,pivotPoint:_,enabled:M}=this;if(y.addPointer(h),this.needsUpdate=!0,y.isPointerTouch()){if(m.visible=!1,y.getPointerCount()===0)p.setPointerCapture(h.pointerId);else if(y.getPointerCount()>2){this.resetState();return}}y.getCenterPoint(U),Oe(U.x,U.y,p,U),J(d,U,u);const g=Math.abs(d.ray.direction.dot(f));if(g<as||g<cs)return;const w=this._raycast(d);w&&(y.getPointerCount()===2||y.isRightClicked()||y.isLeftClicked()&&h.shiftKey?(this.setState(y.isPointerTouch()?os:he),_.copy(w.point),m.position.copy(w.point),m.visible=y.isPointerTouch()?!1:M,m.updateMatrixWorld(),T.add(m)):y.isLeftClicked()&&(this.setState(be),_.copy(w.point),m.position.copy(w.point),m.updateMatrixWorld(),T.add(m)))};let n=!1;const i=h=>{const{pointerTracker:u}=this;if(!this.enabled)return;h.preventDefault();const{pivotMesh:d,enabled:p}=this;this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.state!==te&&(this.needsUpdate=!0),u.setHoverEvent(h),u.updatePointer(h)&&(u.isPointerTouch()&&u.getPointerCount()===2&&(n||(n=!0,queueMicrotask(()=>{n=!1,u.getCenterPoint(us);const f=u.getStartTouchPointerDistance(),m=u.getTouchPointerDistance(),y=m-f;if(this.state===te||this.state===os){u.getCenterPoint(us),u.getStartCenterPoint(xn);const T=2*window.devicePixelRatio,_=us.distanceTo(xn);(Math.abs(y)>T||_>T)&&(Math.abs(y)>_?(this.setState(Ne),this.zoomDirectionSet=!1):this.setState(he))}if(this.state===Ne){const T=u.getPreviousTouchPointerDistance();this.zoomDelta+=m-T,d.visible=!1}else this.state===he&&(d.visible=p)}))),this.dispatchEvent(wn))},r=h=>{const{pointerTracker:u}=this;!this.enabled||u.getPointerCount()===0||(u.deletePointer(h),u.getPointerType()==="touch"&&u.getPointerCount()===0&&e.releasePointerCapture(h.pointerId),this.resetState(),this.needsUpdate=!0)},a=h=>{if(!this.enabled)return;h.preventDefault();const{pointerTracker:u}=this;u.setHoverEvent(h),u.updatePointer(h),this.dispatchEvent(Mn);let d;switch(h.deltaMode){case 2:d=h.deltaY*800;break;case 1:d=h.deltaY*40;break;case 0:d=h.deltaY;break}const p=Math.sign(d),f=Math.abs(d);this.zoomDelta-=.25*p*f,this.needsUpdate=!0,this._lastUsedState=Ne,this.dispatchEvent(Sn)},o=h=>{this.enabled&&this.resetState()};e.addEventListener("contextmenu",t),e.addEventListener("pointerdown",s),e.addEventListener("wheel",a,{passive:!1});const l=e.getRootNode();l.addEventListener("pointermove",i),l.addEventListener("pointerup",r),l.addEventListener("pointerleave",o),this._detachCallback=()=>{e.removeEventListener("contextmenu",t),e.removeEventListener("pointerdown",s),e.removeEventListener("wheel",a),l.removeEventListener("pointermove",i),l.removeEventListener("pointerup",r),l.removeEventListener("pointerleave",o)}}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}getUpDirection(e,t){t.copy(this.up)}getCameraUpDirection(e){this.getUpDirection(this.camera.position,e)}getPivotPoint(e){let t=null;this._lastUsedState===Ne?this._zoomPointWasSet&&(t=e.copy(this.zoomPoint)):(this._lastUsedState===he||this._lastUsedState===be)&&(t=e.copy(this.pivotPoint));const{camera:s,raycaster:n}=this;t!==null&&(R.copy(t).project(s),(R.x<-1||R.x>1||R.y<-1||R.y>1)&&(t=null)),J(n,{x:0,y:0},s);const i=this._raycast(n);return i&&(t===null||i.distance<t.distanceTo(n.ray.origin))&&(t=e.copy(i.point)),t}resetState(){this.state!==te&&this.dispatchEvent(Sn),this.state=te,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=this.enabled,this.actionHeightOffset=0,this.pointerTracker.reset()}setState(e=this.state,t=!0){this.state!==e&&(this.state===te&&t&&this.dispatchEvent(Mn),this.pivotMesh.visible=this.enabled,this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0),this.inertiaStableFrames=0,this.state=e,e!==te&&e!==os&&(this._lastUsedState=e))}update(e=Math.min(this.clock.getDelta(),64/1e3)){if(!this.enabled||!this.camera||e===0)return;const{camera:t,cameraRadius:s,pivotPoint:n,up:i,state:r,adjustHeight:a,autoAdjustCameraRotation:o}=this;t.updateMatrixWorld(),this.getCameraUpDirection(O),this._upInitialized||(this._upInitialized=!0,this.up.copy(O)),this.zoomPointSet=!1;const l=this._inertiaNeedsUpdate(),h=this.needsUpdate||l;if(this.needsUpdate||l){const d=this.zoomDelta;this._updateZoom(),this._updatePosition(e),this._updateRotation(e),r===be||r===he?(z.set(0,0,-1).transformDirection(t.matrixWorld),this.inertiaTargetDistance=R.copy(n).sub(t.position).dot(z)):r===te&&this._updateInertia(e),(r!==te||d!==0||l)&&this.dispatchEvent(wn),this.needsUpdate=!1}const u=t.isOrthographicCamera?null:a&&this._getPointBelowCamera()||null;if(this.getCameraUpDirection(O),this._setFrame(O),(this.state===be||this.state===he)&&this.actionHeightOffset!==0){const{actionHeightOffset:d}=this;t.position.addScaledVector(i,-d),n.addScaledVector(i,-d),u&&(u.distance-=d)}if(this.actionHeightOffset=0,u){const d=u.distance;if(d<s){const p=s-d;t.position.addScaledVector(i,p),n.addScaledVector(i,p),this.actionHeightOffset=p}}this.pointerTracker.updateFrame(),h&&o&&(this.getCameraUpDirection(O),this._alignCameraUp(O,1),this.getCameraUpDirection(O),this._clampRotation(O))}adjustCamera(e){const{adjustHeight:t,cameraRadius:s}=this;if(e.isPerspectiveCamera){this.getUpDirection(e.position,O);const n=t&&this._getPointBelowCamera(e.position,O)||null;if(n){const i=n.distance;i<s&&e.position.addScaledVector(O,s-i)}}}dispose(){this.detach()}_updateInertia(e){const{rotationInertia:t,pivotPoint:s,dragInertia:n,enableDamping:i,dampingFactor:r,camera:a,cameraRadius:o,minDistance:l,inertiaTargetDistance:h}=this;if(!this.enableDamping||this.inertiaStableFrames>1){n.set(0,0,0),t.set(0,0,0);return}const u=Math.pow(2,-e/r),d=Math.max(a.near,o,l,h),p=.25*(2/(2*1e3));if(t.lengthSq()>0){J(D,R.set(0,0,-1),a),D.applyMatrix4(a.matrixWorldInverse),D.direction.normalize(),D.recast(-D.direction.dot(D.origin)).at(d/D.direction.z,R),R.applyMatrix4(a.matrixWorld),J(D,K.set(p,p,-1),a),D.applyMatrix4(a.matrixWorldInverse),D.direction.normalize(),D.recast(-D.direction.dot(D.origin)).at(d/D.direction.z,K),K.applyMatrix4(a.matrixWorld),R.sub(s).normalize(),K.sub(s).normalize();const f=R.angleTo(K)/e;t.multiplyScalar(u),(t.lengthSq()<f**2||!i)&&t.set(0,0)}if(n.lengthSq()>0){J(D,R.set(0,0,-1),a),D.applyMatrix4(a.matrixWorldInverse),D.direction.normalize(),D.recast(-D.direction.dot(D.origin)).at(d/D.direction.z,R),R.applyMatrix4(a.matrixWorld),J(D,K.set(p,p,-1),a),D.applyMatrix4(a.matrixWorldInverse),D.direction.normalize(),D.recast(-D.direction.dot(D.origin)).at(d/D.direction.z,K),K.applyMatrix4(a.matrixWorld);const f=R.distanceTo(K)/e;n.multiplyScalar(u),(n.lengthSq()<f**2||!i)&&n.set(0,0,0)}t.lengthSq()>0&&this._applyRotation(t.x*e,t.y*e,s),n.lengthSq()>0&&(a.position.addScaledVector(n,e),a.updateMatrixWorld())}_inertiaNeedsUpdate(){const{rotationInertia:e,dragInertia:t}=this;return e.lengthSq()!==0||t.lengthSq()!==0}_updateZoom(){const{zoomPoint:e,zoomDirection:t,camera:s,minDistance:n,maxDistance:i,pointerTracker:r,domElement:a,minZoom:o,maxZoom:l,zoomSpeed:h,state:u}=this;let d=this.zoomDelta;if(this.zoomDelta=0,!(!r.getLatestPoint(U)||d===0&&u!==Ne))if(this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),s.isOrthographicCamera){this._updateZoomDirection();const p=this.zoomPointSet||this._updateZoomPoint();At.unproject(s);const f=Math.pow(.95,Math.abs(d*.05));let m=d>0?1/Math.abs(f):f;m*=h,m>1?l<s.zoom*m&&(m=1):o>s.zoom*m&&(m=1),s.zoom*=m,s.updateProjectionMatrix(),p&&(Oe(U.x,U.y,a,hs),hs.unproject(s),s.position.sub(hs).add(At),s.updateMatrixWorld())}else{this._updateZoomDirection();const p=R.copy(t);if(this.zoomPointSet||this._updateZoomPoint()){const f=e.distanceTo(s.position);if(d<0){const m=Math.min(0,f-i);d=d*f*h*.0025,d=Math.max(d,m)}else{const m=Math.max(0,f-n);d=d*Math.max(f-n,0)*h*.0025,d=Math.min(d,m)}s.position.addScaledVector(t,d),s.updateMatrixWorld()}else{const f=this._getPointBelowCamera();if(f){const m=f.distance;p.set(0,0,-1).transformDirection(s.matrixWorld),s.position.addScaledVector(p,d*m*.01),s.updateMatrixWorld()}}}}_updateZoomDirection(){if(this.zoomDirectionSet)return;const{domElement:e,raycaster:t,camera:s,zoomDirection:n,pointerTracker:i}=this;i.getLatestPoint(U),Oe(U.x,U.y,e,At),J(t,At,s),n.copy(t.ray.direction).normalize(),this.zoomDirectionSet=!0}_updateZoomPoint(){const{camera:e,zoomDirectionSet:t,zoomDirection:s,raycaster:n,zoomPoint:i,pointerTracker:r,domElement:a}=this;if(this._zoomPointWasSet=!1,!t)return!1;e.isOrthographicCamera&&r.getLatestPoint(Ye)?(Oe(Ye.x,Ye.y,a,Ye),J(n,Ye,e)):(n.ray.origin.copy(e.position),n.ray.direction.copy(s),n.near=0,n.far=1/0);const o=this._raycast(n);return o?(i.copy(o.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0):!1}_getPointBelowCamera(e=this.camera.position,t=this.up){const{raycaster:s}=this;s.ray.direction.copy(t).multiplyScalar(-1),s.ray.origin.copy(e).addScaledVector(t,1e5),s.near=0,s.far=1/0;const n=this._raycast(s);return n&&(n.distance-=1e5),n}_updatePosition(e){const{raycaster:t,camera:s,pivotPoint:n,up:i,pointerTracker:r,domElement:a,state:o,dragInertia:l}=this;if(o===be){if(r.getCenterPoint(U),Oe(U.x,U.y,a,U),_n.setFromNormalAndCoplanarPoint(i,n),J(t,U,s),Math.abs(t.ray.direction.dot(i))<as){const h=Math.acos(as);vt.crossVectors(t.ray.direction,i).normalize(),t.ray.direction.copy(i).applyAxisAngle(vt,h).multiplyScalar(-1)}if(this.getUpDirection(n,O),Math.abs(t.ray.direction.dot(O))<cs){const h=Math.acos(cs);vt.crossVectors(t.ray.direction,O).normalize(),t.ray.direction.copy(O).applyAxisAngle(vt,h).multiplyScalar(-1)}t.ray.intersectPlane(_n,R)&&(K.subVectors(n,R),s.position.add(K),s.updateMatrixWorld(),K.multiplyScalar(1/e),r.getMoveDistance()/e<2*window.devicePixelRatio?this.inertiaStableFrames++:(l.copy(K),this.inertiaStableFrames=0))}}_updateRotation(e){const{pivotPoint:t,pointerTracker:s,domElement:n,state:i,rotationInertia:r}=this;i===he&&(s.getCenterPoint(U),s.getPreviousCenterPoint(bn),Qe.subVectors(U,bn).multiplyScalar(2*Math.PI/n.clientHeight),this._applyRotation(Qe.x,Qe.y,t),Qe.multiplyScalar(1/e),s.getMoveDistance()/e<2*window.devicePixelRatio?this.inertiaStableFrames++:(r.copy(Qe),this.inertiaStableFrames=0))}_applyRotation(e,t,s){if(e===0&&t===0)return;const{camera:n,minAltitude:i,maxAltitude:r,rotationSpeed:a}=this,o=-e*a;let l=t*a;z.set(0,0,1).transformDirection(n.matrixWorld),Y.set(1,0,0).transformDirection(n.matrixWorld),this.getUpDirection(s,O);let h;O.dot(z)>1-1e-10?h=0:(R.crossVectors(O,z).normalize(),h=Math.sign(R.dot(Y))*O.angleTo(z)),l>0?(l=Math.min(h-i,l),l=Math.max(0,l)):(l=Math.max(h-r,l),l=Math.min(0,l)),ee.setFromAxisAngle(O,o),Be(s,ee,Te),n.matrixWorld.premultiply(Te),Y.set(1,0,0).transformDirection(n.matrixWorld),ee.setFromAxisAngle(Y,-l),Be(s,ee,Te),n.matrixWorld.premultiply(Te),n.matrixWorld.decompose(n.position,n.quaternion,R)}_setFrame(e){const{up:t,camera:s,zoomPoint:n,zoomDirectionSet:i,zoomPointSet:r,scaleZoomOrientationAtEdges:a}=this;if(i&&(r||this._updateZoomPoint())){if(ee.setFromUnitVectors(t,e),a){this.getUpDirection(n,R);let o=Math.max(R.dot(t)-.6,0)/.4;o=L.mapLinear(o,0,.5,0,1),o=Math.min(o,1),s.isOrthographicCamera&&(o*=.1),ee.slerp(ba,1-o)}Be(n,ee,Te),s.updateMatrixWorld(),s.matrixWorld.premultiply(Te),s.matrixWorld.decompose(s.position,s.quaternion,R),this.zoomDirectionSet=!1,this._updateZoomDirection()}t.copy(e),s.updateMatrixWorld()}_raycast(e){const{scene:t,useFallbackPlane:s,fallbackPlane:n}=this,i=e.intersectObject(t)[0]||null;if(i)return i;if(s){const r=n;if(e.ray.intersectPlane(r,R))return{point:R.clone(),distance:e.ray.origin.distanceTo(R)}}return null}_alignCameraUp(e,t=1){const{camera:s,state:n,pivotPoint:i,zoomPoint:r,zoomPointSet:a}=this;s.updateMatrixWorld(),z.set(0,0,-1).transformDirection(s.matrixWorld),Y.set(-1,0,0).transformDirection(s.matrixWorld);let o=L.mapLinear(1-Math.abs(z.dot(e)),0,.2,0,1);o=L.clamp(o,0,1),t*=o,ls.crossVectors(e,z),ls.lerp(Y,1-t).normalize(),ee.setFromUnitVectors(Y,ls),s.quaternion.premultiply(ee);let l=null;n===be||n===he?l=Rt.copy(i):a&&(l=Rt.copy(r)),l&&(Pt.copy(s.matrixWorld).invert(),R.copy(l).applyMatrix4(Pt),s.updateMatrixWorld(),R.applyMatrix4(s.matrixWorld),Ct.subVectors(l,R),s.position.add(Ct)),s.updateMatrixWorld()}_clampRotation(e){const{camera:t,minAltitude:s,maxAltitude:n,state:i,pivotPoint:r,zoomPoint:a,zoomPointSet:o}=this;t.updateMatrixWorld(),z.set(0,0,1).transformDirection(t.matrixWorld),Y.set(1,0,0).transformDirection(t.matrixWorld);let l;e.dot(z)>1-1e-10?l=0:(R.crossVectors(e,z),l=Math.sign(R.dot(Y))*e.angleTo(z));let h;if(l>n)h=n;else if(l<s)h=s;else return;z.copy(e),ee.setFromAxisAngle(Y,h),z.applyQuaternion(ee).normalize(),R.crossVectors(z,Y).normalize(),Te.makeBasis(Y,R,z),t.quaternion.setFromRotationMatrix(Te);let u=null;i===be||i===he?u=Rt.copy(r):o&&(u=Rt.copy(a)),u&&(Pt.copy(t.matrixWorld).invert(),R.copy(u).applyMatrix4(Pt),t.updateMatrixWorld(),R.applyMatrix4(t.matrixWorld),Ct.subVectors(u,R),t.position.add(Ct)),t.updateMatrixWorld()}}const En=new N,De=new N,q=new E,A=new E,ue=new E,X=new E,wa=new E,Ie=new E,de=new we,Pn=new E,Pe=new E,I=new kt,Rn=new Es,Je=new $,Cn={},Ma=2550;class qa extends xa{get tilesGroup(){return console.warn('GlobeControls: "tilesGroup" has been deprecated. Use "ellipsoidGroup", instead.'),this.ellipsoidFrame}get ellipsoidFrame(){return this.ellipsoidGroup.matrixWorld}get ellipsoidFrameInverse(){const{ellipsoidGroup:e,ellipsoidFrame:t,_ellipsoidFrameInverse:s}=this;return e.matrixWorldInverse?e.matrixWorldInverse:s.copy(t).invert()}constructor(e=null,t=null,s=null,n=null){super(e,t,s),this.isGlobeControls=!0,this._dragMode=0,this._rotationMode=0,this.maxZoom=.01,this.nearMargin=.25,this.farMargin=0,this.useFallbackPlane=!1,this.autoAdjustCameraRotation=!1,this.globeInertia=new we,this.globeInertiaFactor=0,this.ellipsoid=je.clone(),this.ellipsoidGroup=new ot,this._ellipsoidFrameInverse=new N,n!==null&&this.setTilesRenderer(n)}setTilesRenderer(e){super.setTilesRenderer(e),e!==null&&this.setEllipsoid(e.ellipsoid,e.group)}setEllipsoid(e,t){this.ellipsoid=e||je.clone(),this.ellipsoidGroup=t||new ot}getPivotPoint(e){const{camera:t,ellipsoidFrame:s,ellipsoidFrameInverse:n,ellipsoid:i}=this;return X.set(0,0,-1).transformDirection(t.matrixWorld),I.origin.copy(t.position),I.direction.copy(X),I.applyMatrix4(n),i.closestPointToRayEstimate(I,A).applyMatrix4(s),(super.getPivotPoint(e)===null||q.subVectors(e,I.origin).dot(I.direction)>q.subVectors(A,I.origin).dot(I.direction))&&e.copy(A),e}getVectorToCenter(e){const{ellipsoidFrame:t,camera:s}=this;return e.setFromMatrixPosition(t).sub(s.position)}getDistanceToCenter(){return this.getVectorToCenter(A).length()}getUpDirection(e,t){const{ellipsoidFrame:s,ellipsoidFrameInverse:n,ellipsoid:i}=this;A.copy(e).applyMatrix4(n),i.getPositionToNormal(A,t),t.transformDirection(s)}getCameraUpDirection(e){const{ellipsoidFrame:t,ellipsoidFrameInverse:s,ellipsoid:n,camera:i}=this;i.isOrthographicCamera?(this._getVirtualOrthoCameraPosition(A),A.applyMatrix4(s),n.getPositionToNormal(A,e),e.transformDirection(t)):this.getUpDirection(i.position,e)}update(e=Math.min(this.clock.getDelta(),64/1e3)){if(!this.enabled||!this.camera||e===0)return;const{camera:t,pivotMesh:s}=this;this._isNearControls()?this.scaleZoomOrientationAtEdges=this.zoomDelta<0:(this.state!==te&&this._dragMode!==1&&this._rotationMode!==1&&(s.visible=!1),this.scaleZoomOrientationAtEdges=!1);const n=this.needsUpdate||this._inertiaNeedsUpdate();super.update(e),this.adjustCamera(t),n&&this._isNearControls()&&(this.getCameraUpDirection(Ie),this._alignCameraUp(Ie,1),this.getCameraUpDirection(Ie),this._clampRotation(Ie))}adjustCamera(e){super.adjustCamera(e);const{ellipsoidFrame:t,ellipsoidFrameInverse:s,ellipsoid:n,nearMargin:i,farMargin:r}=this,a=Math.max(...n.radius);if(e.isPerspectiveCamera){const o=A.setFromMatrixPosition(t).sub(e.position).length(),l=i*a,h=L.clamp((o-a)/l,0,1),u=L.lerp(1,1e3,h);e.near=Math.max(u,o-a-l),q.copy(e.position).applyMatrix4(s),n.getPositionToCartographic(q,Cn);const d=Math.max(n.getPositionElevation(q),Ma),p=n.calculateHorizonDistance(Cn.lat,d);e.far=p+.1+a*r,e.updateProjectionMatrix()}else{this._getVirtualOrthoCameraPosition(e.position,e),e.updateMatrixWorld(),En.copy(e.matrixWorld).invert(),A.setFromMatrixPosition(t).applyMatrix4(En);const o=-A.z;e.near=o-a*(1+i),e.far=o+.1+a*r,e.position.addScaledVector(X,e.near),e.far-=e.near,e.near=0,e.updateProjectionMatrix(),e.updateMatrixWorld()}}setState(...e){super.setState(...e),this._dragMode=0,this._rotationMode=0}_updateInertia(e){super._updateInertia(e);const{globeInertia:t,enableDamping:s,dampingFactor:n,camera:i,cameraRadius:r,minDistance:a,inertiaTargetDistance:o,ellipsoidFrame:l}=this;if(!this.enableDamping||this.inertiaStableFrames>1){this.globeInertiaFactor=0,this.globeInertia.identity();return}const h=Math.pow(2,-e/n),u=Math.max(i.near,r,a,o),d=.25*(2/(2*1e3));if(ue.setFromMatrixPosition(l),this.globeInertiaFactor!==0){J(I,A.set(0,0,-1),i),I.applyMatrix4(i.matrixWorldInverse),I.direction.normalize(),I.recast(-I.direction.dot(I.origin)).at(u/I.direction.z,A),A.applyMatrix4(i.matrixWorld),J(I,q.set(d,d,-1),i),I.applyMatrix4(i.matrixWorldInverse),I.direction.normalize(),I.recast(-I.direction.dot(I.origin)).at(u/I.direction.z,q),q.applyMatrix4(i.matrixWorld),A.sub(ue).normalize(),q.sub(ue).normalize(),this.globeInertiaFactor*=h;const p=A.angleTo(q)/e;(2*Math.acos(t.w)*this.globeInertiaFactor<p||!s)&&(this.globeInertiaFactor=0,t.identity())}this.globeInertiaFactor!==0&&(t.w===1&&(t.x!==0||t.y!==0||t.z!==0)&&(t.w=Math.min(t.w,1-1e-9)),ue.setFromMatrixPosition(l),de.identity().slerp(t,this.globeInertiaFactor*e),Be(ue,de,De),i.matrixWorld.premultiply(De),i.matrixWorld.decompose(i.position,i.quaternion,A))}_inertiaNeedsUpdate(){return super._inertiaNeedsUpdate()||this.globeInertiaFactor!==0}_updatePosition(e){if(this.state===be){this._dragMode===0&&(this._dragMode=this._isNearControls()?1:-1);const{raycaster:t,camera:s,pivotPoint:n,pointerTracker:i,domElement:r,ellipsoidFrame:a,ellipsoidFrameInverse:o}=this,l=q,h=wa;i.getCenterPoint(Je),Oe(Je.x,Je.y,r,Je),J(t,Je,s),t.ray.applyMatrix4(o);const u=A.copy(n).applyMatrix4(o).length();if(Rn.radius.setScalar(u),!Rn.intersectRay(t.ray,A)){this.resetState(),this._updateInertia(e);return}A.applyMatrix4(a),ue.setFromMatrixPosition(a),l.subVectors(n,ue).normalize(),h.subVectors(A,ue).normalize(),de.setFromUnitVectors(h,l),Be(ue,de,De),s.matrixWorld.premultiply(De),s.matrixWorld.decompose(s.position,s.quaternion,A),i.getMoveDistance()/e<2*window.devicePixelRatio?this.inertiaStableFrames++:(this.globeInertia.copy(de),this.globeInertiaFactor=1/e,this.inertiaStableFrames=0)}}_updateRotation(...e){this._rotationMode===1||this._isNearControls()?(this._rotationMode=1,super._updateRotation(...e)):(this.pivotMesh.visible=!1,this._rotationMode=-1)}_updateZoom(){const{zoomDelta:e,ellipsoid:t,zoomSpeed:s,zoomPoint:n,camera:i,maxZoom:r,state:a}=this;if(a!==Ne&&e===0)return;this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),this.globeInertia.identity(),this.globeInertiaFactor=0;const o=L.clamp(L.mapLinear(Math.abs(e),0,20,0,1),0,1);if(this._isNearControls()||e>0){if(this._updateZoomDirection(),e<0&&(this.zoomPointSet||this._updateZoomPoint())){X.set(0,0,-1).transformDirection(i.matrixWorld).normalize(),Pe.copy(this.up).multiplyScalar(-1),this.getUpDirection(n,Pn);const l=L.clamp(L.mapLinear(-Pn.dot(Pe),1,.95,0,1),0,1),h=1-X.dot(Pe),u=i.isOrthographicCamera?.05:1,d=L.clamp(o*3,0,1),p=Math.min(l*h*u*d,.1);Pe.lerpVectors(X,Pe,p).normalize(),de.setFromUnitVectors(X,Pe),Be(n,de,De),i.matrixWorld.premultiply(De),i.matrixWorld.decompose(i.position,i.quaternion,Pe),this.zoomDirection.subVectors(n,i.position).normalize()}super._updateZoom()}else if(i.isPerspectiveCamera){const l=this._getPerspectiveTransitionDistance(),h=this._getMaxPerspectiveDistance(),u=L.mapLinear(this.getDistanceToCenter(),l,h,0,1);this._tiltTowardsCenter(L.lerp(0,.4,u*o)),this._alignCameraUpToNorth(L.lerp(0,.2,u*o));const d=this.getDistanceToCenter()-t.radius.x,p=e*d*s*.0025,f=Math.max(p,Math.min(this.getDistanceToCenter()-h,0));this.getVectorToCenter(A).normalize(),this.camera.position.addScaledVector(A,f),this.camera.updateMatrixWorld(),this.zoomDelta=0}else{const l=this._getOrthographicTransitionZoom(),h=this._getMinOrthographicZoom(),u=L.mapLinear(i.zoom,l,h,0,1);this._tiltTowardsCenter(L.lerp(0,.4,u*o)),this._alignCameraUpToNorth(L.lerp(0,.2,u*o));const d=this.zoomDelta,p=Math.pow(.95,Math.abs(d*.05)),f=d>0?1/Math.abs(p):p,m=h/i.zoom,y=Math.max(f*s,Math.min(m,1));i.zoom=Math.min(r,i.zoom*y),i.updateProjectionMatrix(),this.zoomDelta=0,this.zoomDirectionSet=!1}}_alignCameraUpToNorth(e){const{ellipsoidFrame:t}=this;Ie.set(0,0,1).transformDirection(t),this._alignCameraUp(Ie,e)}_tiltTowardsCenter(e){const{camera:t,ellipsoidFrame:s}=this;X.set(0,0,-1).transformDirection(t.matrixWorld).normalize(),A.setFromMatrixPosition(s).sub(t.position).normalize(),A.lerp(X,1-e).normalize(),de.setFromUnitVectors(X,A),t.quaternion.premultiply(de),t.updateMatrixWorld()}_getPerspectiveTransitionDistance(){const{camera:e,ellipsoid:t}=this;if(!e.isPerspectiveCamera)throw new Error;const s=Math.max(...t.radius),n=2*Math.atan(Math.tan(L.DEG2RAD*e.fov*.5)*e.aspect),i=s/Math.tan(L.DEG2RAD*e.fov*.5),r=s/Math.tan(n*.5);return Math.max(i,r)}_getMaxPerspectiveDistance(){const{camera:e,ellipsoid:t}=this;if(!e.isPerspectiveCamera)throw new Error;const s=Math.max(...t.radius),n=2*Math.atan(Math.tan(L.DEG2RAD*e.fov*.5)*e.aspect),i=s/Math.tan(L.DEG2RAD*e.fov*.5),r=s/Math.tan(n*.5);return 2*Math.max(i,r)}_getOrthographicTransitionZoom(){const{camera:e,ellipsoid:t}=this;if(!e.isOrthographicCamera)throw new Error;const s=e.top-e.bottom,n=e.right-e.left,i=Math.max(s,n),r=2*Math.max(...t.radius);return 2*i/r}_getMinOrthographicZoom(){const{camera:e,ellipsoid:t}=this;if(!e.isOrthographicCamera)throw new Error;const s=e.top-e.bottom,n=e.right-e.left,i=Math.min(s,n),r=2*Math.max(...t.radius);return .7*i/r}_getVirtualOrthoCameraPosition(e,t=this.camera){const{ellipsoidFrame:s,ellipsoidFrameInverse:n,ellipsoid:i}=this;if(!t.isOrthographicCamera)throw new Error;I.origin.copy(t.position),I.direction.set(0,0,-1).transformDirection(t.matrixWorld),I.applyMatrix4(n),i.closestPointToRayEstimate(I,q).applyMatrix4(s);const r=t.top-t.bottom,a=t.right-t.left,o=Math.max(r,a)/t.zoom;X.set(0,0,-1).transformDirection(t.matrixWorld);const l=q.sub(t.position).dot(X);e.copy(t.position).addScaledVector(X,l-o*4)}_isNearControls(){const{camera:e}=this;return e.isPerspectiveCamera?this.getDistanceToCenter()<this._getPerspectiveTransitionDistance():e.zoom>this._getOrthographicTransitionZoom()}_raycast(e){const t=super._raycast(e);if(t===null){const{ellipsoid:s,ellipsoidFrame:n,ellipsoidFrameInverse:i}=this;I.copy(e.ray).applyMatrix4(i);const r=s.intersectRay(I,A);return r!==null?(r.applyMatrix4(n),{point:r.clone(),distance:r.distanceTo(e.ray.origin)}):null}else return t}}const B=new E,Re=new E,Ce=new ai,Sa=new E,Ea=new E,Pa=new E,vn=new we,Ra=new we;class Xa extends ze{get animating(){return this._alpha!==0&&this._alpha!==1}get alpha(){return this._target===0?1-this._alpha:this._alpha}get camera(){return this._alpha===0?this.perspectiveCamera:this._alpha===1?this.orthographicCamera:this.transitionCamera}get mode(){return this._target===0?"perspective":"orthographic"}set mode(e){if(e===this.mode)return;const t=this.camera;e==="perspective"?(this._target=0,this._alpha=0):(this._target=1,this._alpha=1),this.dispatchEvent({type:"camera-change",camera:this.camera,prevCamera:t})}constructor(e=new on,t=new ai){super(),this.perspectiveCamera=e,this.orthographicCamera=t,this.transitionCamera=new on,this.orthographicPositionalZoom=!0,this.orthographicOffset=50,this.fixedPoint=new E,this.duration=200,this.autoSync=!0,this.easeFunction=s=>s,this._target=0,this._alpha=0,this._clock=new oi}toggle(){this._target=this._target===1?0:1,this._clock.getDelta(),this.dispatchEvent({type:"toggle"})}update(e=Math.min(this._clock.getDelta(),64/1e3)){this.autoSync&&this.syncCameras();const{perspectiveCamera:t,orthographicCamera:s,transitionCamera:n,camera:i}=this,r=e*1e3;if(this._alpha!==this._target){const l=Math.sign(this._target-this._alpha)*r/this.duration;this._alpha=L.clamp(this._alpha+l,0,1),this.dispatchEvent({type:"change",alpha:this.alpha})}const a=i;let o=null;this._alpha===0?o=t:this._alpha===1?o=s:(o=n,this._updateTransitionCamera()),a!==o&&(o===n&&this.dispatchEvent({type:"transition-start"}),this.dispatchEvent({type:"camera-change",camera:o,prevCamera:a}),a===n&&this.dispatchEvent({type:"transition-end"}))}syncCameras(){const e=this._getFromCamera(),{perspectiveCamera:t,orthographicCamera:s,transitionCamera:n,fixedPoint:i}=this;if(B.set(0,0,-1).transformDirection(e.matrixWorld).normalize(),e.isPerspectiveCamera){if(this.orthographicPositionalZoom)s.position.copy(t.position).addScaledVector(B,-this.orthographicOffset),s.rotation.copy(t.rotation),s.updateMatrixWorld();else{const l=Re.subVectors(i,s.position).dot(B),h=Re.subVectors(i,t.position).dot(B);Re.copy(t.position).addScaledVector(B,h),s.rotation.copy(t.rotation),s.position.copy(Re).addScaledVector(B,-l),s.updateMatrixWorld()}const r=Math.abs(Re.subVectors(t.position,i).dot(B)),a=2*Math.tan(L.DEG2RAD*t.fov*.5)*r,o=s.top-s.bottom;s.zoom=o/a,s.updateProjectionMatrix()}else{const r=Math.abs(Re.subVectors(s.position,i).dot(B)),a=(s.top-s.bottom)/s.zoom*.5/Math.tan(L.DEG2RAD*t.fov*.5);t.rotation.copy(s.rotation),t.position.copy(s.position).addScaledVector(B,r).addScaledVector(B,-a),t.updateMatrixWorld(),this.orthographicPositionalZoom&&(s.position.copy(t.position).addScaledVector(B,-this.orthographicOffset),s.updateMatrixWorld())}n.position.copy(t.position),n.rotation.copy(t.rotation)}_getTransitionDirection(){return Math.sign(this._target-this._alpha)}_getToCamera(){const e=this._getTransitionDirection();return e===0?this._target===0?this.perspectiveCamera:this.orthographicCamera:e>0?this.orthographicCamera:this.perspectiveCamera}_getFromCamera(){const e=this._getTransitionDirection();return e===0?this._target===0?this.perspectiveCamera:this.orthographicCamera:e>0?this.perspectiveCamera:this.orthographicCamera}_updateTransitionCamera(){const{perspectiveCamera:e,orthographicCamera:t,transitionCamera:s,fixedPoint:n}=this,i=this.easeFunction(this._alpha);B.set(0,0,-1).transformDirection(t.matrixWorld).normalize(),Ce.copy(t),Ce.position.addScaledVector(B,t.near),t.far-=t.near,t.near=0,B.set(0,0,-1).transformDirection(e.matrixWorld).normalize();const r=Math.abs(Re.subVectors(e.position,n).dot(B)),a=2*Math.tan(L.DEG2RAD*e.fov*.5)*r,o=Ra.slerpQuaternions(e.quaternion,Ce.quaternion,i),l=L.lerp(e.fov,1,i),h=a*.5/Math.tan(L.DEG2RAD*l*.5),u=Pa.copy(Ce.position).sub(n).applyQuaternion(vn.copy(Ce.quaternion).invert()),d=Ea.copy(e.position).sub(n).applyQuaternion(vn.copy(e.quaternion).invert()),p=Sa.lerpVectors(d,u,i);p.z-=Math.abs(p.z)-h;const f=-(d.z-p.z),m=-(u.z-p.z),y=L.lerp(f+e.near,m+Ce.near,i),T=L.lerp(f+e.far,m+Ce.far,i),_=Math.max(T,0)-Math.max(y,0);s.aspect=e.aspect,s.fov=l,s.near=Math.max(y,_*1e-5),s.far=T,s.position.copy(p).applyQuaternion(o).add(n),s.quaternion.copy(o),s.updateProjectionMatrix(),s.updateMatrixWorld()}}export{Ka as Ai,bo as E,qa as Fi,bs as GLTFLoader,Xa as Wi,wo as h,at as importShared,Da as mergeGeometries,Ia as mergeVertices,Fa as toCreasedNormals,Ot as y,Es as zt};
