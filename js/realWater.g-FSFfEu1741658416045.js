import{m as n,e,a as t,o as r,f as o}from"./@tresjs.W3PFJhMo1741658416045.js";import{P as i}from"./tweakpane.yDiyAAkA1741658416045.js";import{_ as c,aW as a,r as l,s}from"./three.FyUEtfsR1741658416045.js";import{d as u,a3 as f,b as p,o as v,f as g,u as d,g as x,j as h,al as m,r as y,N as w,aj as b,ak as I}from"./@vue.NRI7TcgI1741658416045.js";import"./postprocessing.llR5x4wQ1741658416045.js";import"./@vueuse.5uFvLf9q1741658416045.js";var C="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const R=D;function _(){const n=["uniforms","prototype","chain","bind","return (function() ","position","waterTexture","8GCNiHG","input","call","295662ahOPoJ","RawShaderMaterial","debu","16839AtiegC","1360936JWbAjZ","counter","toString","exception","gger","test","FrontSide","Mesh","action","pool","string","render","error","log","__proto__","value","table","stateObject","311385rAfgoy","warn","setIndex","BufferGeometry","causticTex","63ecxMvr","info","length","290346uuRtGS","init","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","constructor","while (true) {}","trace","apply","12947370UqZwxX","BufferAttribute","water","light",'{}.constructor("return this")( )',"2792KdyhDr","function *\\( *\\)","5162220ThjRmK","causticsTexture","console"];return(_=function(){return n})()}!function(n,e){const t=D,r=_();for(;;)try{if(749912===parseInt(t(467))/1+parseInt(t(506))/2+parseInt(t(502))/3*(-parseInt(t(499))/4)+parseInt(t(489))/5+parseInt(t(475))/6*(-parseInt(t(472))/7)+-parseInt(t(487))/8*(-parseInt(t(505))/9)+-parseInt(t(482))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const M=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){M(this,(function(){const n=D,e=new RegExp(n(488)),t=new RegExp(n(477),"i"),r=L(n(476));e[n(511)](r+n(494))&&t[n(511)](r+n(500))?L():r("0")}))()}();const z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[D(481)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();z(void 0,(function(){const n=D,e=function(){const n=D;let e;try{e=Function(n(496)+n(486)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(491)]||{},r=[n(462),n(468),n(473),n(461),n(509),n(465),n(480)];for(let o=0;o<r[n(474)];o++){const e=z[n(478)][n(493)][n(495)](z),i=r[o],c=t[i]||e;e[n(463)]=z.bind(z),e.toString=c[n(508)][n(495)](c),t[i]=e}}))();const T=u({__name:R(458),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=R,o=t,i=new(c[r(470)]),a=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),l=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i.setAttribute(r(497),new(c[r(483)])(a,3)),i[r(469)](new(c[r(483)])(l,1));const s=new(c[r(503)])({uniforms:{light:{value:o[r(485)]},tiles:{value:o.tiles},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(512)]}),u=new(c[r(456)])(i,s),{renderer:f,camera:p}=n(),{onAfterLoop:v}=e();return v((()=>{const n=r;((n,e)=>{const t=r;s.uniforms[t(484)].value=n,s[t(492)][t(471)][t(464)]=e,f[t(464)][t(460)](u,p.value)})(o[n(498)],o[n(490)])})),(n,e)=>null}});function D(n,e){const t=_();return(D=function(n,e){return t[n-=456]})(n,e)}function L(n){function e(n){const t=D;if(typeof n===t(459))return function(n){}[t(478)](t(479))[t(481)](t(507));1!==(""+n/n)[t(474)]||n%20==0?function(){return!0}[t(478)]("debu"+t(510))[t(501)](t(457)):function(){return!1}[t(478)](t(504)+t(510))[t(481)](t(466)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=j,r=O();for(;;)try{if(604721===parseInt(t(340))/1*(-parseInt(t(345))/2)+-parseInt(t(326))/3+parseInt(t(328))/4*(parseInt(t(329))/5)+parseInt(t(377))/6+-parseInt(t(352))/7*(parseInt(t(360))/8)+parseInt(t(350))/9+parseInt(t(336))/10*(parseInt(t(376))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[j(343)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){A(this,(function(){const n=j,e=new RegExp(n(347)),t=new RegExp(n(324),"i"),r=E(n(373));e.test(r+"chain")&&t[n(346)](r+n(372))?E():r("0")}))()}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[j(343)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function j(n,e){const t=O();return(j=function(n,e){return t[n-=320]})(n,e)}function O(){const n=["Mesh","underwater","BackSide","neg-y.jpg","setClearColor",'{}.constructor("return this")( )',"water","__proto__","setRenderTarget","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","light","3065190ZXVngT","string","3243884EMltux","5FJdTVC","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","length","render","setPath","call","info","3410JBuXoH","pos-y.jpg","causticsTexture","neg-z.jpg","3qmCzRw","pos-z.jpg","clear","apply","exception","433250HvshsL","test","function *\\( *\\)","debu","waterTexture","10379772ZgMkKo","prototype","21TNuJeV","side","white","while (true) {}","constructor","table","pos-x.jpg","geometry","2269288uPksIY","trace","value","pooRef","FrontSide","neg-x.jpg","log","CubeTextureLoader","uniforms","bind","toString","Color","input","init","action","return (function() ","6941zTGIjN","5687154feLieJ","error"];return(O=function(){return n})()}S(void 0,(function(){const n=j,e=function(){const n=j;let e;try{e=Function(n(375)+n(320)+");")()}catch(t){e=window}return e}(),t=e.console=e.console||{},r=[n(366),"warn",n(335),n(378),n(344),n(357),n(361)];for(let o=0;o<r[n(331)];o++){const e=S.constructor[n(351)][n(369)](S),i=r[o],c=t[i]||e;e[n(322)]=S[n(369)](S),e[n(370)]=c.toString[n(369)](c),t[i]=e}}))();const F=u({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=j;let i,l;const s=r,u=s[o(359)],x=(new(c[o(367)]))[o(333)](o(330)).load([o(358),o(365),o(337),o(382),o(341),o(339)]),h=([i,l]=f((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,l(),i),m=new a({uniforms:{light:{value:s[o(325)]},tiles:{value:h},sky:{value:x},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new(c[o(379)])(u,m),w=p(null),b=new(c[o(371)])(o(354)),{renderer:I,camera:C}=n(),{onLoop:R}=e();return R((()=>{const n=o;I[n(362)][n(323)](null),I[n(362)][n(383)](b,1),I[n(362)][n(342)](),m[n(368)][n(321)][n(362)]=s[n(349)],m[n(368)].causticTex.value=s[n(338)],m.side=c[n(364)],m[n(368)][n(380)].value=!0,I[n(362)][n(332)](y,C[n(362)]),m[n(353)]=c[n(381)],m[n(368)][n(380)][n(362)]=!1,I[n(362)][n(332)](y,C[n(362)])})),(n,e)=>{const t=o;return v(),g(T,{tiles:d(h),light:n[t(325)],waterTexture:n.waterTexture,causticsTexture:n[t(338)],ref_key:t(363),ref:w},null,8,["tiles",t(325),"waterTexture",t(338)])}}});function E(n){function e(n){const t=j;if(typeof n===t(327))return function(n){}[t(356)](t(355))[t(343)]("counter");1!==(""+n/n)[t(331)]||n%20==0?function(){return!0}.constructor(t(348)+"gger")[t(334)](t(374)):function(){return!1}[t(356)](t(348)+"gger")[t(343)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const P=W;function W(n,e){const t=H();return(W=function(n,e){return t[n-=156]})(n,e)}!function(n,e){const t=W,r=H();for(;;)try{if(474031===-parseInt(t(169))/1+-parseInt(t(193))/2*(-parseInt(t(162))/3)+parseInt(t(198))/4*(-parseInt(t(209))/5)+parseInt(t(178))/6+-parseInt(t(166))/7+parseInt(t(163))/8+parseInt(t(195))/9*(-parseInt(t(173))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const V=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[W(171)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){V(this,(function(){const n=W,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(175),"i"),r=Z(n(185));e[n(167)](r+n(159))&&t.test(r+n(164))?Z():r("0")}))()}();const k=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[W(171)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function H(){const n=["return (function() ","Mesh","water","prototype","34674VfyNVg","value","3254967vmGjgM","__proto__","texture","260ImydkS","geometry","stateObject","console","bind","action",'{}.constructor("return this")( )',"warn","setRenderTarget","length","ShaderMaterial","535BXrOKq","caustics","PlaneGeometry","log","chain","debu","table","141AdcfpX","7418552dmZSCW","input","black","1869343xKdUzS","test","gger","386590ZrepBX","Color","apply","info","20mAMMYK","uniforms","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","call","constructor","694758ujQeUs","waterTexture","light","OrthographicCamera","render","clear","WebGLRenderTarget","init","material","setClearColor","toString"];return(H=function(){return n})()}k(void 0,(function(){const n=W,e=function(){const n=W;let e;try{e=Function(n(189)+n(204)+");")()}catch(t){e=window}return e}(),t=e[n(201)]=e.console||{},r=[n(158),n(205),n(172),"error","exception",n(161),"trace"];for(let o=0;o<r.length;o++){const e=k.constructor[n(192)][n(202)](k),i=r[o],c=t[i]||e;e[n(196)]=k[n(202)](k),e[n(188)]=c[n(188)][n(202)](c),t[i]=e}}))();const N=u({__name:P(156),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=P,o=t,i=new(c[r(181)])(0,1,1,0,0,2e3),a=new(c[r(157)])(2,2,200,200),l=new(c[r(184)])(1024,1024),s=new(c[r(208)])({uniforms:{light:{value:o[r(180)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),u=new(c[r(190)])(a,s),f=new(c[r(170)])(r(165)),{renderer:p}=n(),{onBeforeLoop:y}=e();return y((()=>{const n=r;u[n(186)][n(174)][n(191)].value=o.waterTexture,p[n(194)][n(206)](l),p[n(194)][n(187)](f,0),p[n(194)][n(183)](),p[n(194)][n(182)](u,i)})),(n,e)=>{const t=r;return v(),g(m,null,{default:x((()=>[h(F,{waterTexture:n.waterTexture,causticsTexture:d(l)[t(197)],light:n[t(180)],geometry:d(a)},null,8,[t(179),"causticsTexture",t(180),t(199)])])),_:1})}}});function Z(n){function e(n){const t=W;if("string"==typeof n)return function(n){}.constructor("while (true) {}")[t(171)]("counter");1!==(""+n/n)[t(207)]||n%20==0?function(){return!0}[t(177)](t(160)+t(168))[t(176)](t(203)):function(){return!1}[t(177)](t(160)+"gger").apply(t(200)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const B=K;!function(n,e){const t=K,r=$();for(;;)try{if(632132===parseInt(t(267))/1*(-parseInt(t(301))/2)+-parseInt(t(327))/3*(parseInt(t(336))/4)+parseInt(t(280))/5*(-parseInt(t(283))/6)+-parseInt(t(322))/7*(parseInt(t(309))/8)+-parseInt(t(292))/9*(-parseInt(t(311))/10)+-parseInt(t(271))/11*(-parseInt(t(303))/12)+-parseInt(t(333))/13*(-parseInt(t(294))/14))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const G=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){G(this,(function(){const n=K,e=new RegExp(n(335)),t=new RegExp(n(312),"i"),r=q(n(277));e[n(326)](r+n(320))&&t[n(326)](r+n(269))?q():r("0")}))()}();const X=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function $(){const n=["error","3223uTMrGv","setFromCamera","counter","length","setY","OrthographicCamera","init","texture","call","5yupxEB","top","string","2810028eurKSJ","Vector2","bind","constructor","material","exception","autoClear","toString","getY","284463hPhZQL","clientX","14lTgmzf","clientY","uniforms","PlaneGeometry","position","value","lightFrontGeometry","72NLzHPi","gger","1140eYSoBa","waterSimulation","Mesh","__proto__","setZ","FloatType","8SSZprX","return (function() ","110Tksmfo","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","point","table","RawShaderMaterial","domElement","light","center","radius","chain","stateObject","8202257lcekMS","getBoundingClientRect","apply","prototype","test","3hTXfCz","warn","debu","while (true) {}","width","setRenderTarget","30872738RbrHbn","action","function *\\( *\\)","1407316LoBeyh","removeEventListener","log","strength","3508DAzIKr","WebGLRenderTarget","input"];return($=function(){return n})()}function K(n,e){const t=$();return(K=function(n,e){return t[n-=265]})(n,e)}X(void 0,(function(){const n=K;let e;try{e=Function(n(310)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e.console=e.console||{},r=[n(265),n(328),"info",n(270),n(288),n(314),"trace"];for(let i=0;i<r[n(274)];i++){const e=X[n(286)][n(325)].bind(X),o=r[i],c=t[o]||e;e[n(306)]=X.bind(X),e[n(290)]=c.toString[n(285)](c),t[o]=e}}))();const Y=u({__name:B(304),props:{light:{}},setup(t,{expose:r}){const o=B,i=new(c[o(276)])(0,1,1,0,0,2e3),u=new(c[o(297)])(2,2),f=new(c[o(268)])(256,256,{type:c[o(308)]}),p=new(c[o(268)])(256,256,{type:c[o(308)]}),x=new a({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:C,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),h=new(c[o(315)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:C,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),m=new(c[o(315)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:C,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),y=new l(u,x),w=new(c[o(305)])(u,h),b=new l(u,m);let I=f;const R=(n,e)=>{const t=o,r=I,c=I===f?p:f;e[t(287)][t(296)][t(278)][t(299)]=r[t(278)],n[t(332)](c),n.render(e,i),I=c},{renderer:_,camera:M,raycaster:z}=n();_[o(299)][o(289)]=!1;const{onBeforeLoop:T}=e();T((()=>{const n=o;var e,t;t=_.value,R(t,b),e=_[n(299)],R(e,w)}));const D=(n,e,t,r)=>{const i=o;y[i(287)][i(296)][i(318)].value=[n,e],y[i(287)][i(296)][i(319)][i(299)]=t,y[i(287)][i(296)][i(266)][i(299)]=r,R(_[i(299)],y)},L=new(c[o(284)]),A=new s(2,2),S=A.attributes[o(298)];for(let n=0;n<S.count;n++){const e=-S[o(291)](n);S[o(275)](n,0),S[o(307)](n,e)}S.needsUpdate=!0;const j=new l(A),O={handleEvent:n=>{const e=o,t=_[e(299)][e(316)][e(323)](),r=t[e(331)],i=t.height;L.x=2*(n[e(293)]-t.left)/r-1,L.y=2*-(n[e(295)]-t[e(281)])/i+1,z[e(299)][e(272)](L,M[e(299)]);const c=z[e(299)].intersectObject(j);for(let o of c)D(o[e(313)].x,o.point.z,.03,.04)}};return r({addDrop:D,mouseEvent:n=>{const e=o;n?_.value[e(316)].addEventListener("mousemove",O):_[e(299)][e(316)][e(337)]("mousemove",O)}}),(n,e)=>{const t=o;return v(),g(N,{lightFrontGeometry:d(u),waterTexture:d(I)[t(278)],light:n[t(317)]},null,8,[t(300),"waterTexture",t(317)])}}});function q(n){function e(n){const t=K;if(typeof n===t(282))return function(n){}.constructor(t(330))[t(324)](t(273));1!==(""+n/n)[t(274)]||n%20==0?function(){return!0}[t(286)](t(329)+t(302))[t(279)](t(334)):function(){return!1}[t(286)]("debu"+t(302)).apply(t(321)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=Q,r=U();for(;;)try{if(556834===parseInt(t(325))/1*(-parseInt(t(339))/2)+-parseInt(t(334))/3*(parseInt(t(359))/4)+parseInt(t(318))/5*(parseInt(t(330))/6)+-parseInt(t(337))/7*(parseInt(t(342))/8)+-parseInt(t(345))/9+-parseInt(t(352))/10*(-parseInt(t(361))/11)+parseInt(t(344))/12)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const J=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Q(341)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function U(){const n=["length","addDrop","return (function() ","console","function *\\( *\\)","48NHRfsG","log","11CAPTwu","table","change","manual","随机增加波纹","3405rLBPhz","error","toString","gger","mouseEvent","init","__proto__","1jDFCyl",'{}.constructor("return this")( )',"random","click","string","7026rNZzZC","debu","info","chain","56292zdGhMS","trace","constructor","693VLMTQR","value","761818ePpNRX","exception","apply","30472HbhEhY","input","9319908NIxNIY","5889249uKjqwT","waterSimulationRef","addBinding","call","点击按钮","addButton","test","6202530NIwhuD","stateObject"];return(U=function(){return n})()}function Q(n,e){const t=U();return(Q=function(n,e){return t[n-=316]})(n,e)}!function(){J(this,(function(){const n=Q,e=new RegExp(n(358)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=tn(n(323));e[n(351)](r+n(333))&&t[n(351)](r+n(343))?tn():r("0")}))()}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Q(341)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();nn(void 0,(function(){const n=Q,e=function(){const n=Q;let e;try{e=Function(n(356)+n(326)+");")()}catch(t){e=window}return e}(),t=e[n(357)]=e[n(357)]||{},r=[n(360),"warn",n(332),n(319),n(340),n(362),n(335)];for(let o=0;o<r[n(354)];o++){const e=nn[n(336)].prototype.bind(nn),i=r[o],c=t[i]||e;e[n(324)]=nn.bind(nn),e[n(320)]=c[n(320)].bind(c),t[i]=e}}))();const en=u({__name:"realWater",setup(n){const e=Q,t=y({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(316)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=p(null),l=new i;l[e(350)]({label:e(349),title:e(317)}).on(e(328),(()=>{const n=e;for(var t=0;t<10;t++)a[n(338)][n(355)](2*Math[n(327)]()-1,2*Math[n(327)]()-1,.03,1&t?.02:-.02)}));const s=p(!1);return l[e(347)](s,e(338),{label:"鼠标波纹"}).on(e(363),(n=>{const t=e;a[t(338)][t(322)](n[t(338)])})),(n,i)=>{const l=e;return v(),g(d(o),b(I(t)),{default:x((()=>[i[0]||(i[0]=w("TresPerspectiveCamera",{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),h(d(r)),h(Y,{light:c,ref_key:l(346),ref:a},null,512)])),_:1},16)}}});function tn(n){function e(n){const t=Q;if(typeof n===t(329))return function(n){}[t(336)]("while (true) {}")[t(341)]("counter");1!==(""+n/n)[t(354)]||n%20==0?function(){return!0}[t(336)](t(331)+t(321))[t(348)]("action"):function(){return!1}[t(336)]("debu"+t(321))[t(341)](t(353)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{en as default};
