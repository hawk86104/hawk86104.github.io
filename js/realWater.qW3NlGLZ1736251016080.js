import{m as n,e,b as t,U as r,c as o}from"./@tresjs.8C7OKmBm1736251016080.js";import{P as i}from"./tweakpane.yHWGBmom1736251016080.js";import{_ as c,a,ay as l,s,k as u}from"./three.RuuDeeIf1736251016080.js";import{d as f,a4 as p,b as v,o as g,f as d,u as x,g as h,j as m,al as y,r as w,J as b,aj as I,ak as C}from"./@vue.-Mz_IXfk1736251016080.js";import"./@vueuse.HhUha1mw1736251016080.js";var R="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const _=T;!function(n,e){const t=T,r=D();for(;;)try{if(311947===parseInt(t(360))/1+parseInt(t(335))/2*(-parseInt(t(323))/3)+-parseInt(t(351))/4+parseInt(t(356))/5*(parseInt(t(341))/6)+parseInt(t(354))/7*(parseInt(t(345))/8)+parseInt(t(322))/9*(-parseInt(t(315))/10)+parseInt(t(332))/11*(parseInt(t(355))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[T(321)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){z(this,(function(){const n=T,e=new RegExp(n(338)),t=new RegExp(n(339),"i"),r=A(n(313));e[n(350)](r+"chain")&&t[n(350)](r+n(314))?A():r("0")}))()}();const M=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function T(n,e){const t=D();return(T=function(n,e){return t[n-=308]})(n,e)}function D(){const n=["273582xieoZr","3sCQWpy","while (true) {}","error","render","toString","RawShaderMaterial","stateObject","debu","tiles","1672EScopX","table","gger","375894IGPyCj","log","Mesh","function *\\( *\\)","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","action","2074998jrZWNZ",'{}.constructor("return this")( )',"waterTexture","position","328gPaIHn","length","constructor","uniforms","call","test","2116040FxiPWn","water","return (function() ","4053YeTuIg","39024QXbZZQ","5leSZxf","console","info","value","195426UYdowR","setAttribute","pool","warn","light","FrontSide","init","input","10HzgPSu","exception","counter","BufferGeometry","bind","string","apply"];return(D=function(){return n})()}M(void 0,(function(){const n=T,e=function(){const n=T;let e;try{e=Function(n(353)+n(342)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(357)]||{},r=[n(336),n(310),n(358),n(325),n(316),n(333),"trace"];for(let o=0;o<r.length;o++){const e=M.constructor.prototype.bind(M),i=r[o],c=t[i]||e;e.__proto__=M[n(319)](M),e[n(327)]=c[n(327)][n(319)](c),t[i]=e}}))();const L=f({__name:_(309),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=_,o=t,i=new(c[r(318)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(308)](r(344),new a(l,3)),i.setIndex(new a(s,1));const u=new(c[r(328)])({uniforms:{light:{value:o[r(311)]},tiles:{value:o[r(331)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(312)]}),f=new(c[r(337)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{((n,e)=>{const t=r;u[t(348)][t(352)][t(359)]=n,u[t(348)].causticTex.value=e,p[t(359)][t(326)](f,v[t(359)])})(o[r(343)],o.causticsTexture)})),(n,e)=>null}});function A(n){function e(n){const t=T;if(typeof n===t(320))return function(n){}[t(347)](t(324))[t(321)](t(317));1!==(""+n/n)[t(346)]||n%20==0?function(){return!0}[t(347)](t(330)+t(334))[t(349)](t(340)):function(){return!1}[t(347)](t(330)+t(334))[t(321)](t(329)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function O(n,e){const t=E();return(O=function(n,e){return t[n-=405]})(n,e)}const F=O;!function(n,e){const t=O,r=E();for(;;)try{if(275977===-parseInt(t(439))/1*(parseInt(t(410))/2)+-parseInt(t(432))/3*(-parseInt(t(408))/4)+-parseInt(t(447))/5+parseInt(t(444))/6*(-parseInt(t(422))/7)+-parseInt(t(435))/8*(-parseInt(t(430))/9)+parseInt(t(429))/10+-parseInt(t(423))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[O(419)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){j(this,(function(){const n=O,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(462),"i"),r=P(n(409));e[n(458)](r+"chain")&&t[n(458)](r+n(450))?P():r("0")}))()}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function E(){const n=["return (function() ","uniforms","7atKzoL","load","side","neg-z.jpg","neg-x.jpg","2708574amRyzF","pos-z.jpg","pos-x.jpg","957160NZXWSD","toString","exception","input","pos-y.jpg","Color","counter","while (true) {}","causticsTexture","bind","action","test","value","white","clear","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","BackSide","render","light","debu","1890572zaFila","init","50702qHDlmo","CubeTextureLoader","setRenderTarget","FrontSide","tiles","gger","water","causticTex","underwater","apply","prototype","error","7hulTXB","1624700bHEOkc","stateObject","waterTexture","setPath","length","constructor","3291620vZSBbm","630HJIBQk","call","3JZONsA","__proto__","pooRef","50536grkQKp","console"];return(E=function(){return n})()}S(void 0,(function(){const n=O;let e;try{e=Function(n(437)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(436)]=e.console||{},r=["log","warn","info",n(421),n(449),"table","trace"];for(let i=0;i<r[n(427)];i++){const e=S[n(428)][n(420)][n(456)](S),o=r[i],c=t[o]||e;e[n(433)]=S.bind(S),e[n(448)]=c[n(448)][n(456)](c),t[o]=e}}))();const W=f({__name:F(416),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=F;let i,a;const u=r,f=u.geometry,h=(new(c[o(411)]))[o(426)]("https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/")[o(440)]([o(446),o(443),o(451),"neg-y.jpg",o(445),o(442)]),m=([i,a]=p((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),y=new l({uniforms:{light:{value:u[o(406)]},tiles:{value:m},sky:{value:h},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),w=new s(f,y),b=v(null),I=new(c[o(452)])(o(460)),{renderer:C,camera:R}=n(),{onLoop:_}=e();return _((()=>{const n=o;C.value[n(412)](null),C[n(459)].setClearColor(I,1),C.value[n(461)](),y[n(438)][n(416)][n(459)]=u.waterTexture,y[n(438)][n(417)][n(459)]=u[n(455)],y[n(441)]=c[n(413)],y.uniforms[n(418)][n(459)]=!0,C[n(459)][n(405)](w,R.value),y[n(441)]=c[n(463)],y[n(438)][n(418)].value=!1,C[n(459)][n(405)](w,R[n(459)])})),(n,e)=>{const t=o;return g(),d(L,{tiles:x(m),light:n.light,waterTexture:n[t(425)],causticsTexture:n.causticsTexture,ref_key:t(434),ref:b},null,8,[t(414),t(406),"waterTexture",t(455)])}}});function P(n){function e(n){const t=O;if("string"==typeof n)return function(n){}[t(428)](t(454)).apply(t(453));1!==(""+n/n)[t(427)]||n%20==0?function(){return!0}[t(428)](t(407)+t(415))[t(431)](t(457)):function(){return!1}[t(428)](t(407)+t(415))[t(419)](t(424)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const k=Z;!function(n,e){const t=Z,r=N();for(;;)try{if(474215===-parseInt(t(261))/1*(-parseInt(t(240))/2)+parseInt(t(247))/3+-parseInt(t(281))/4+-parseInt(t(234))/5+-parseInt(t(283))/6*(-parseInt(t(275))/7)+-parseInt(t(266))/8+parseInt(t(258))/9*(parseInt(t(237))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const H=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Z(254)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){H(this,(function(){const n=Z,e=new RegExp(n(284)),t=new RegExp(n(267),"i"),r=X(n(243));e[n(271)](r+n(236))&&t.test(r+"input")?X():r("0")}))()}();const V=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Z(254)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Z(n,e){const t=N();return(Z=function(n,e){return t[n-=232]})(n,e)}function N(){const n=["render","bind","406164FphXwv","constructor","prototype","toString","water","value","while (true) {}","apply","Mesh","setRenderTarget","exception","9oyslqJ","stateObject","call","981tXyDIT","material","gger","OrthographicCamera","waterTexture","3080464ZyJLiI","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","WebGLRenderTarget","causticsTexture","ShaderMaterial","test","PlaneGeometry","clear","console","15764xtSVtN","return (function() ","length","caustics","black","debu","3681884WpEQIj","error","1404vXXnVQ","function *\\( *\\)","trace","Color","698130dOBdyd","setClearColor","chain","12521090RyYDVj","info","__proto__","10oqKoTf","geometry","warn","init","light"];return(N=function(){return n})()}V(void 0,(function(){const n=Z;let e;try{e=Function(n(276)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(274)]=e[n(274)]||{},r=["log",n(242),n(238),n(282),n(257),"table",n(232)];for(let i=0;i<r[n(277)];i++){const e=V[n(248)][n(249)][n(246)](V),o=r[i],c=t[o]||e;e[n(239)]=V.bind(V),e[n(250)]=c[n(250)].bind(c),t[o]=e}}))();const G=f({__name:k(278),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=k,o=t,i=new(c[r(264)])(0,1,1,0,0,2e3),a=new(c[r(272)])(2,2,200,200),l=new(c[r(268)])(1024,1024),s=new(c[r(270)])({uniforms:{light:{value:o[r(244)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),u=new(c[r(255)])(a,s),f=new(c[r(233)])(r(279)),{renderer:p}=n(),{onBeforeLoop:v}=e();return v((()=>{const n=r;u[n(262)].uniforms[n(251)][n(252)]=o.waterTexture,p[n(252)][n(256)](l),p[n(252)][n(235)](f,0),p[n(252)][n(273)](),p[n(252)][n(245)](u,i)})),(n,e)=>{const t=r;return g(),d(y,null,{default:h((()=>[m(W,{waterTexture:n.waterTexture,causticsTexture:x(l).texture,light:n[t(244)],geometry:x(a)},null,8,[t(265),t(269),t(244),t(241)])])),_:1})}}});function X(n){function e(n){const t=Z;if("string"==typeof n)return function(n){}[t(248)](t(253)).apply("counter");1!==(""+n/n)[t(277)]||n%20==0?function(){return!0}[t(248)](t(280)+t(263))[t(260)]("action"):function(){return!1}[t(248)](t(280)+"gger")[t(254)](t(259)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=J,r=$();for(;;)try{if(363488===parseInt(t(409))/1+parseInt(t(416))/2+-parseInt(t(401))/3+-parseInt(t(448))/4+-parseInt(t(447))/5+parseInt(t(421))/6*(-parseInt(t(389))/7)+parseInt(t(400))/8)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function $(){const n=["texture","height","while (true) {}","mousemove","domElement","light","attributes","setZ","trace","setFromCamera","getBoundingClientRect","table","prototype","test","FloatType","651445gamgTT","1969016NeKKFr","log","addEventListener","__proto__","stateObject","OrthographicCamera","info","string","6769qCNXdJ","autoClear","radius","value","getY",'{}.constructor("return this")( )',"count","constructor","console","needsUpdate","apply","6370376ElOJhL","2021586eZXIGe","PlaneGeometry","bind","action","lightFrontGeometry","removeEventListener","point","uniforms","519971SEuydC","clientY","top","setY","exception","RawShaderMaterial","material","1309998wxJipm","toString","length","debu","waterTexture","1932ftosVQ","Mesh","call","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","function *\\( *\\)","return (function() ","render","chain","WebGLRenderTarget","left","input"];return($=function(){return n})()}function J(n,e){const t=$();return(J=function(n,e){return t[n-=382]})(n,e)}!function(){B(this,(function(){const n=J,e=new RegExp(n(425)),t=new RegExp(n(424),"i"),r=Y("init");e[n(445)](r+n(428))&&t[n(445)](r+n(431))?Y():r("0")}))()}();const Q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[J(399)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();Q(void 0,(function(){const n=J,e=function(){const n=J;let e;try{e=Function(n(426)+n(394)+");")()}catch(t){e=window}return e}(),t=e[n(397)]=e[n(397)]||{},r=[n(382),"warn",n(387),"error",n(413),n(443),n(440)];for(let o=0;o<r[n(418)];o++){const e=Q[n(396)][n(444)][n(403)](Q),i=r[o],c=t[i]||e;e[n(384)]=Q.bind(Q),e[n(417)]=c[n(417)].bind(c),t[i]=e}}))();const q=f({__name:"waterSimulation",props:{light:{}},setup(t,{expose:r}){const o=J,i=new(c[o(386)])(0,1,1,0,0,2e3),a=new(c[o(402)])(2,2),s=new(c[o(429)])(256,256,{type:c[o(446)]}),f=new(c[o(429)])(256,256,{type:c[o(446)]}),p=new l({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:R,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),v=new l({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:R,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),h=new(c[o(414)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:R,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),m=new(c[o(422)])(a,p),y=new(c[o(422)])(a,v),w=new(c[o(422)])(a,h);let b=s;const I=(n,e)=>{const t=o,r=b,c=b===s?f:s;e.material[t(408)][t(432)][t(392)]=r[t(432)],n.setRenderTarget(c),n[t(427)](e,i),b=c},{renderer:C,camera:_,raycaster:z}=n();C[o(392)][o(390)]=!1;const{onBeforeLoop:M}=e();M((()=>{const n=o;var e,t;t=C[n(392)],I(t,w),e=C[n(392)],I(e,y)}));const T=(n,e,t,r)=>{const i=o;m[i(415)][i(408)].center[i(392)]=[n,e],m[i(415)].uniforms[i(391)].value=t,m.material[i(408)].strength[i(392)]=r,I(C[i(392)],m)},D=new u,L=new(c[o(402)])(2,2),A=L[o(438)].position;for(let n=0;n<A[o(395)];n++){const e=-A[o(393)](n);A[o(412)](n,0),A[o(439)](n,e)}A[o(398)]=!0;const O=new(c[o(422)])(L),F={handleEvent:n=>{const e=o,t=C[e(392)][e(436)][e(442)](),r=t.width,i=t[e(433)];D.x=2*(n.clientX-t[e(430)])/r-1,D.y=2*-(n[e(410)]-t[e(411)])/i+1,z.value[e(441)](D,_[e(392)]);const c=z[e(392)].intersectObject(O);for(let o of c)T(o[e(407)].x,o[e(407)].z,.03,.04)}};return r({addDrop:T,mouseEvent:n=>{const e=o;n?C.value[e(436)][e(383)](e(435),F):C[e(392)].domElement[e(406)]("mousemove",F)}}),(n,e)=>{const t=o;return g(),d(G,{lightFrontGeometry:x(a),waterTexture:x(b)[t(432)],light:n[t(437)]},null,8,[t(405),t(420),t(437)])}}});function Y(n){function e(n){const t=J;if(typeof n===t(388))return function(n){}.constructor(t(434))[t(399)]("counter");1!==(""+n/n)[t(418)]||n%20==0?function(){return!0}[t(396)]("debugger")[t(423)](t(404)):function(){return!1}[t(396)](t(419)+"gger")[t(399)](t(385)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const K=tn;!function(n,e){const t=tn,r=nn();for(;;)try{if(792453===-parseInt(t(461))/1*(-parseInt(t(477))/2)+-parseInt(t(468))/3*(parseInt(t(503))/4)+parseInt(t(492))/5+-parseInt(t(499))/6+-parseInt(t(466))/7+-parseInt(t(480))/8*(-parseInt(t(476))/9)+-parseInt(t(463))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function nn(){const n=["random","while (true) {}","2252187jauHOj","info","45111ANIrVy","function *\\( *\\)","table","warn","鼠标波纹","input","apply","value","139473IHtdgQ","2XcGsKG","点击按钮","manual","504vjVYDG","exception","gger","addDrop","prototype","log","string","waterSimulationRef","bind","mouseEvent","test","init","6913145XfiozM","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","addButton","toString","realWater","addBinding","trace","9095562kfEULL","__proto__","constructor","debu","312nwkdGz","call","length","随机增加波纹","1536765ehJOWL","action","926980ThwLFg"];return(nn=function(){return n})()}!function(){U(this,(function(){const n=tn,e=new RegExp(n(469)),t=new RegExp(n(493),"i"),r=on(n(491));e[n(490)](r+"chain")&&t[n(490)](r+n(473))?on():r("0")}))()}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(474)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function tn(n,e){const t=nn();return(tn=function(n,e){return t[n-=458]})(n,e)}en(void 0,(function(){const n=tn,e=function(){let n;try{n=Function('return (function() {}.constructor("return this")( ));')()}catch(e){n=window}return n}(),t=e.console=e.console||{},r=[n(485),n(471),n(467),"error",n(481),n(470),n(498)];for(let o=0;o<r[n(459)];o++){const e=en[n(501)][n(484)][n(488)](en),i=r[o],c=t[i]||e;e[n(500)]=en[n(488)](en),e[n(495)]=c.toString[n(488)](c),t[i]=e}}))();const rn=f({__name:K(496),setup(n){const e=K,t=w({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(479)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=v(null),l=new i;l[e(494)]({label:e(478),title:e(460)}).on("click",(()=>{const n=e;for(var t=0;t<10;t++)a[n(475)][n(483)](2*Math.random()-1,2*Math[n(464)]()-1,.03,1&t?.02:-.02)}));const s=v(!1);return l[e(497)](s,"value",{label:e(472)}).on("change",(n=>{const t=e;a[t(475)][t(489)](n[t(475)])})),(n,i)=>{const l=e;return g(),d(x(o),I(C(t)),{default:h((()=>[i[0]||(i[0]=b("TresPerspectiveCamera",{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),m(x(r)),m(q,{light:c,ref_key:l(487),ref:a},null,512)])),_:1},16)}}});function on(n){function e(n){const t=tn;if(typeof n===t(486))return function(n){}[t(501)](t(465))[t(474)]("counter");1!==(""+n/n).length||n%20==0?function(){return!0}[t(501)]("debu"+t(482))[t(458)](t(462)):function(){return!1}.constructor(t(502)+t(482))[t(474)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{rn as default};
