import{_ as t}from"./three.Gi_-4zeu1741857949183.js";import{e as n}from"./@tresjs.8SAr0PX_1741857949183.js";import{g as o}from"./utils.AP-HdWts1741857949183.js";import{d as e,b as r,a2 as i,w as s,o as c,H as a,N as u,u as l,aj as f,ak as p}from"./@vue.NRI7TcgI1741857949183.js";function v(t,n){const o=g();return(v=function(t,n){return o[t-=193]})(t,n)}const m=v;!function(t,n){const o=v,e=g();for(;;)try{if(851988===parseInt(o(201))/1+parseInt(o(217))/2*(-parseInt(o(229))/3)+-parseInt(o(195))/4*(-parseInt(o(253))/5)+-parseInt(o(212))/6*(parseInt(o(232))/7)+-parseInt(o(208))/8+parseInt(o(220))/9+parseInt(o(225))/10)break;e.push(e.shift())}catch(r){e.push(e.shift())}}();const h=function(){let t=!0;return function(n,o){const e=t?function(){if(o){const t=o[v(211)](n,arguments);return o=null,t}}:function(){};return t=!1,e}}();!function(){h(this,(function(){const t=v,n=new RegExp("function *\\( *\\)"),o=new RegExp(t(227),"i"),e=w(t(251));n[t(200)](e+t(210))&&o[t(200)](e+t(236))?w():e("0")}))()}();const y=function(){let t=!0;return function(n,o){const e=t?function(){if(o){const t=o[v(211)](n,arguments);return o=null,t}}:function(){};return t=!1,e}}();y(void 0,(function(){const t=v,n=function(){const t=v;let n;try{n=Function(t(243)+t(231)+");")()}catch(o){n=window}return n}(),o=n.console=n[t(206)]||{},e=[t(230),"warn",t(222),"error",t(249),t(234),t(245)];for(let r=0;r<e.length;r++){const n=y[t(250)][t(218)][t(247)](y),i=e[r],s=o[i]||n;n[t(197)]=y[t(247)](y),n[t(241)]=s[t(241)][t(247)](s),o[i]=n}}))();const d=[m(239),"uv"];function g(){const t=["positionSrc","test","1411195FSWSLt","speed","action","stateObject","color","console","uniforms","10870424xPRJJn","length","chain","apply","6YcyYBz","\nprecision lowp float;\nprecision lowp int;\nuniform float time;\nuniform float opacity;\nuniform vec3 color;\nuniform float num;\nuniform float speed;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 fragColor = vec4(0.);\n\tfloat sin = sin((vUv.y - time * speed) * 10. * num);\n\tfloat high = 0.92;\n\tfloat medium = 0.4;\n\tif (sin > high) {\n\t\tfragColor = vec4(mix(vec3(.8, 1., 1.), color, (1. - sin) / (1. - high)), 1.);\n\t} else if(sin > medium) {\n\t\tfragColor = vec4(color, mix(1., 0., 1.-(sin - medium) / (high - medium)));\n\t} else {\n\t\tfragColor = vec4(color, 0.);\n\t}\n\tvec3 fade = mix(color, vec3(0., 0., 0.), vUv.y);\n\tfragColor = mix(fragColor, vec4(fade, 1.), 0.85);\n\tgl_FragColor = vec4(fragColor.rgb, fragColor.a * opacity * (1. - vUv.y));\n}\n","counter","rippleMesh","#ffff00","4KJoqJw","prototype","fog_vertex","5528898GXBTgj","while (true) {}","info","string","TresBufferGeometry","10562690CZSGMs","uvs","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","opacity","2132847WZChOg","log",'{}.constructor("return this")( )',"1763202hcPtvU","time","table","set","input","value","DoubleSide","position","Color","toString","TresShaderMaterial","return (function() ","debu","trace","height","bind","pv2","exception","constructor","init","gger","185lHuJYk","call","num","\nvarying vec2 vUv;\nvoid main() {\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t","86788LuYowt","fog_pars_vertex","__proto__","ShaderChunk"];return(g=function(){return t})()}const x=e({__name:m(215),props:{positionSrc:{default:[{x:0,y:0},{x:10,y:10}]},color:{default:m(216)},opacity:{default:.8},height:{default:100},num:{default:8},speed:{default:.15}},setup(e){const v=m,h=e,y=r(),g={side:t[v(238)],transparent:!0,depthWrite:!1,depthTest:!0,vertexShader:"\nprecision lowp float;\nprecision lowp int;\n"+t[v(198)][v(196)]+v(194)+t[v(198)][v(219)]+"\n}\n",fragmentShader:v(213),uniforms:{time:{type:v(248),value:0},color:{type:v(226),value:new(t[v(240)])(h[v(205)])},opacity:{type:v(248),value:h[v(228)]},num:{type:v(248),value:h[v(193)]},speed:{type:"pv2",value:h[v(202)]}}};let x=null,w=null;function _(t=[],n){const o=v,e=[],r=[];for(let i=0,s=e[o(209)],c=r[o(209)];i<t[o(209)]-1;i++){let o=1,a=t[i],u=t[i+1];e[s++]=a.x,e[s++]=0,e[s++]=a.y,r[c++]=0,r[c++]=0,e[s++]=u.x,e[s++]=0,e[s++]=u.y,r[c++]=1,r[c++]=0,e[s++]=a.x,e[s++]=n,e[s++]=a.y,r[c++]=0,r[c++]=o,e[s++]=a.x,e[s++]=n,e[s++]=a.y,r[c++]=0,r[c++]=o,e[s++]=u.x,e[s++]=0,e[s++]=u.y,r[c++]=1,r[c++]=0,e[s++]=u.x,e[s++]=n,e[s++]=u.y,r[c++]=1,r[c++]=o}x=new Float32Array(e),w=new Float32Array(r)}let{centerPoint:C,points:S}=o(h[v(199)]);_(S,h.height);const{onLoop:I}=n();return I((({delta:t})=>{const n=v;g[n(207)][n(233)][n(237)]+=t})),i((()=>{const n=v;h[n(205)]&&(g.uniforms[n(205)][n(237)]=new(t[n(240)])(h[n(205)])),h[n(228)]&&(g[n(207)].opacity[n(237)]=h[n(228)]),h[n(193)]&&(g[n(207)][n(193)][n(237)]=h[n(193)]),h[n(202)]&&(g[n(207)].speed[n(237)]=h[n(202)]),y.value&&y[n(237)].position[n(235)](C.x,y[n(237)].position.y,C.y)})),s((()=>h[v(199)]),(t=>{const n=v,{centerPoint:e,points:r}=o(t);C=e,S=r,_(S,h[n(246)]),y[n(237)]&&y[n(237)][n(239)].set(C.x,y[n(237)][n(239)].y,C.y)})),(t,n)=>{const o=v;return c(),a("TresMesh",{renderOrder:2200,ref_key:"tresMeshRef",ref:y},[u(o(224),{position:[l(x),3],uv:[l(w),2]},null,8,d),u(o(242),f(p(g)),null,16)],512)}}});function w(t){function n(t){const o=v;if(typeof t===o(223))return function(t){}[o(250)](o(221))[o(211)](o(214));1!==(""+t/t).length||t%20==0?function(){return!0}[o(250)](o(244)+o(252))[o(254)](o(203)):function(){return!1}[o(250)](o(244)+o(252))[o(211)](o(204)),n(++t)}try{if(t)return n;n(0)}catch(o){}}export{x as _};
