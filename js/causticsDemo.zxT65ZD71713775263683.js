import{aw as gn,cZ as vt,ax as ft,ap as dt,c5 as An,aB as wt,aI as Ae,bf as je,c0 as gt,at as qe,az as On,be as Fe,b3 as ae,bB as xt,aG as St,aF as yt,c_ as _t,bt as Et,c$ as Pt,d0 as It,d1 as Tt,d2 as Ct,b2 as bt,bp as Mt,ba as Ut,br as Dt,bq as Rt,cS as Nt,cm as Ft,cK as At,cX as Pn,as as Ot,b8 as zt,d3 as Bt,cL as In,a1 as xn,aD as kt,cr as Zt,ak as zn,o as sn,c as Bn,L as Ze,bR as Lt,bM as Wt,a6 as Ht,w as Tn,Y as ln,G as Gt,a9 as Xt,a2 as hn,cn as Yt,aq as jt,x as Cn,E as bn,a8 as qt,cY as $t,a as mn,aa as Mn,ab as Un,ac as Kt,ag as Vt}from"./vendor.KaB9nKOc1713775263683.js";import"./vanilla.eZtqaMJJ1713775263683.js";import{s as kn}from"./shaderMaterial.uJEA-W_Z1713775263683.js";import{F as Qt}from"./Pass.EMeC-ilU1713775263683.js";import"./vanilla.8mIZIIXT1713775263683.js";import"./_commonjsHelpers.5-cIlDoe1713775263683.js";const Jt=u=>u&&u.isCubeTexture;class er extends gn{constructor(a,m){var S,w;const R=Jt(a),k=((w=R?(S=a.image[0])==null?void 0:S.width:a.image.width)!=null?w:1024)/4,x=Math.floor(Math.log2(k)),C=Math.pow(2,x),q=3*Math.max(C,16*7),te=4*C,se=[R?"#define ENVMAP_TYPE_CUBE":"","#define CUBEUV_TEXEL_WIDTH ".concat(1/q),"#define CUBEUV_TEXEL_HEIGHT ".concat(1/te),"#define CUBEUV_MAX_MIP ".concat(x,".0")],O="\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        ",le=se.join("\n")+"\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <".concat(parseInt(An.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment",">\n        }\n        "),Ie={map:{value:a},height:{value:(m==null?void 0:m.height)||15},radius:{value:(m==null?void 0:m.radius)||100}},I=new vt(1,16),G=new ft({uniforms:Ie,fragmentShader:le,vertexShader:O,side:dt});super(I,G)}set radius(a){this.material.uniforms.radius.value=a}get radius(){return this.material.uniforms.radius.value}set height(a){this.material.uniforms.height.value=a}get height(){return this.material.uniforms.height.value}}function on(u=1024,a=1024,m={samples:0,depth:!1}){var S=u,w=a,R=m,P=R.samples||0,k=R.depth,x=Object.assign({},R);delete x.samples,delete x.depth;var C=new wt(S,w,Object.assign({minFilter:Ae,magFilter:Ae,type:je},x));return k&&(C.depthTexture=new gt(S,w,qe)),C.samples=P,C}const nr=u=>u==null?void 0:u.isVector3;function Dn(u=Dt){const a={value:new Fe};return Object.assign(new Ut({side:u}),{viewMatrix:a,onBeforeCompile:m=>{m.uniforms.viewMatrix=a,m.fragmentShader="vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n         }\n"+m.fragmentShader.replace("#include <normal_fragment_maps>","#include <normal_fragment_maps>\n           normal = inverseTransformDirection( normal, viewMatrix );\n")}})}const tr=kn({causticsTexture:null,causticsTextureB:null,color:new On,lightProjMatrix:new Fe,lightViewMatrix:new Fe},"varying vec3 vWorldPosition;   \n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\n     vWorldPosition = worldPosition.xyz;\n   }","varying vec3 vWorldPosition;\n  uniform vec3 color;\n  uniform sampler2D causticsTexture; \n  uniform sampler2D causticsTextureB; \n  uniform mat4 lightProjMatrix;\n  uniform mat4 lightViewMatrix;\n   void main() {\n    // Apply caustics  \n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\n    lightSpacePos.xyz /= lightSpacePos.w;\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\n    gl_FragColor = vec4((front + back) * color, 1.0);\n    #include <tonemapping_fragment>\n    #include <".concat(parseInt(An.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment",">\n   }")),rr=kn({cameraMatrixWorld:new Fe,cameraProjectionMatrixInv:new Fe,normalTexture:null,depthTexture:null,lightDir:new ae(0,1,0),lightPlaneNormal:new ae(0,1,0),lightPlaneConstant:0,near:.1,far:100,modelMatrix:new Fe,worldRadius:1/40,ior:1.1,bounces:0,resolution:1024,size:10,intensity:.5},"\n  varying vec2 vUv;\n  void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }","  \n  uniform mat4 cameraMatrixWorld;\n  uniform mat4 cameraProjectionMatrixInv;\n  uniform vec3 lightDir;\n  uniform vec3 lightPlaneNormal;\n  uniform float lightPlaneConstant;\n  uniform float near;\n  uniform float far;\n  uniform float time;\n  uniform float worldRadius;\n  uniform float resolution;\n  uniform float size;\n  uniform float intensity;\n  uniform float ior;\n  precision highp isampler2D;\n  precision highp usampler2D;\n  uniform sampler2D normalTexture;\n  uniform sampler2D depthTexture;\n  uniform float bounces;\n  varying vec2 vUv;\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\n    // Perspective division\n    viewSpacePosition /= viewSpacePosition.w;\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\n    return worldSpacePosition.xyz;\n  }                  \n  float sdPlane( vec3 p, vec3 n, float h ) {\n    // n must be normalized\n    return dot(p,n) + h;\n  }\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n  }\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\n    rayOrigin = ro;\n    rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = pos + rayDirection * 0.1;\n    return rayDirection;\n  }\n  void main() {\n    // Each sample consists of random offset in the x and y direction\n    float caustic = 0.0;\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\n    float texelsNeeded = worldRadius / causticTexelSize;\n    float sampleRadius = texelsNeeded / resolution;\n    float sum = 0.0;\n    if (texture2D(depthTexture, vUv).x == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 uv1 = vUv + offset1 * sampleRadius;\n    vec2 uv2 = vUv + offset2 * sampleRadius;\n    vec2 uv3 = vUv + offset3 * sampleRadius;\n    vec2 uv4 = vUv + offset4 * sampleRadius;\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\n    // Sanity check the depths\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\n    vec3 endPos1, endPos2, endPos3, endPos4;\n    vec3 endDir1, endDir2, endDir3, endDir4;\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\n    caustic += intensity * (lightPosArea / finalArea);\n    // Calculate the area of the triangle in light spaces\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\n  }"),Rn={depth:!0,minFilter:Ae,magFilter:Ae,type:Nt},Nn={minFilter:Ft,magFilter:Ae,type:qe,generateMipmaps:!0},or=(u,{frames:a=1,causticsOnly:m=!1,ior:S=1.1,backside:w=!1,backsideIOR:R=1.1,worldRadius:P=.3125,color:k=new On("white"),intensity:x=.05,resolution:C=2024,lightSource:q=new ae(1,1,1),near:te=.1,far:se=0}={})=>{const O={frames:a,ior:S,color:k,causticsOnly:m,backside:w,backsideIOR:R,worldRadius:P,intensity:x,resolution:C,lightSource:q,near:te,far:se},le=new xt;le.name="caustics_group";const Ie=le,I=new St,G=new yt;G.name="caustics_scene";const $=u,Ee=new _t(I);Ee.name="caustics_helper";const ce=O.resolution,Te=on(ce,ce,Rn),fe=on(ce,ce,Rn),Ce=on(ce,ce,Nn),Q=on(ce,ce,Nn),De=Dn(),Oe=Dn(Rt),Z=new rr,ne=new Qt(Z),K=new gn(new Et(1,1),new tr({transparent:!0,color:O.color,causticsTexture:Ce.texture,causticsTextureB:Q.texture,blending:Pt,blendSrc:It,blendDst:Tt,depthWrite:!1}));K.name="caustics_plane",K.rotation.x=-Math.PI/2,K.renderOrder=2,le.add(G,K),le.updateWorldMatrix(!1,!0);let ue=0;const Se=new ae,pe=new Ct,Re=new Fe,ze=new bt,re=new ae,Y=new ae,M=new Mt,X=new ae,W=[],de=[],we=[],N=[],ge=new ae;for(let Ne=0;Ne<8;Ne++)W.push(new ae),de.push(new ae),we.push(new ae),N.push(new ae);return{scene:G,group:le,helper:Ee,params:O,update:()=>{if(O.frames===1/0||ue++<O.frames){var Ne;nr(q)?re.copy(q).normalize():re.copy(Ie.worldToLocal(q.getWorldPosition(Se)).normalize()),Y.copy(re).multiplyScalar(-1),(Ne=G.parent)==null||Ne.matrixWorld.identity(),M.setFromObject(G,!0),W[0].set(M.min.x,M.min.y,M.min.z),W[1].set(M.min.x,M.min.y,M.max.z),W[2].set(M.min.x,M.max.y,M.min.z),W[3].set(M.min.x,M.max.y,M.max.z),W[4].set(M.max.x,M.min.y,M.min.z),W[5].set(M.max.x,M.min.y,M.max.z),W[6].set(M.max.x,M.max.y,M.min.z),W[7].set(M.max.x,M.max.y,M.max.z);for(let D=0;D<8;D++)de[D].copy(W[D]);M.getCenter(X),W.map(D=>D.sub(X));const cn=ze.set(Y,0);W.map((D,J)=>cn.projectPoint(D,we[J]));const Ve=we.reduce((D,J)=>D.add(J),Se.set(0,0,0)).divideScalar(we.length),be=we.map(D=>D.distanceTo(Ve)).reduce((D,J)=>Math.max(D,J)),Qe=W.map(D=>D.dot(re)).reduce((D,J)=>Math.max(D,J));I.position.copy(ge.copy(re).multiplyScalar(Qe).add(X)),I.lookAt(G.localToWorld(X));const Je=Re.lookAt(I.position,X,Se.set(0,1,0));if(I.left=-be,I.right=be,I.top=be,I.bottom=-be,I.near=O.near,O.far)I.far=O.far;else{const D=Se.set(0,be,0).applyMatrix4(Je),J=(I.position.y+D.y)/re.y;I.far=J}I.updateProjectionMatrix(),I.updateMatrixWorld();const Be=de.map((D,J)=>D.add(N[J].copy(re).multiplyScalar(-D.y/re.y))),Le=Be.reduce((D,J)=>D.add(J),Se.set(0,0,0)).divideScalar(Be.length),un=2*Be.map(D=>Math.hypot(D.x-Le.x,D.z-Le.z)).reduce((D,J)=>Math.max(D,J));K.scale.setScalar(un),K.position.copy(Le),Ee.parent&&Ee.update(),Oe.viewMatrix.value=De.viewMatrix.value=I.matrixWorldInverse;const en=pe.setFromProjectionMatrix(Re.multiplyMatrices(I.projectionMatrix,I.matrixWorldInverse)).planes[4];Z.cameraMatrixWorld=I.matrixWorld,Z.cameraProjectionMatrixInv=I.projectionMatrixInverse,Z.lightDir=Y,Z.lightPlaneNormal=en.normal,Z.lightPlaneConstant=en.constant,Z.near=I.near,Z.far=I.far,Z.resolution=O.resolution,Z.size=be,Z.intensity=O.intensity,Z.worldRadius=O.worldRadius,G.visible=!0,$.setRenderTarget(Te),$.clear(),G.overrideMaterial=De,$.render(G,I),$.setRenderTarget(fe),$.clear(),O.backside&&(G.overrideMaterial=Oe,$.render(G,I)),G.overrideMaterial=null,Z.ior=O.ior,K.material.lightProjMatrix=I.projectionMatrix,K.material.lightViewMatrix=I.matrixWorldInverse,Z.normalTexture=Te.texture,Z.depthTexture=Te.depthTexture,$.setRenderTarget(Ce),$.clear(),ne.render($),Z.ior=O.backsideIOR,Z.normalTexture=fe.texture,Z.depthTexture=fe.depthTexture,$.setRenderTarget(Q),$.clear(),O.backside&&ne.render($),$.setRenderTarget(null),O.causticsOnly&&(G.visible=!1)}},normalTarget:Te,normalTargetB:fe,causticsTarget:Ce,causticsTargetB:Q}};/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/var Fn=function(u){return URL.createObjectURL(new Blob([u],{type:"text/javascript"}))};try{URL.revokeObjectURL(Fn(""))}catch(u){Fn=function(a){return"data:application/javascript;charset=UTF-8,"+encodeURI(a)}}var ve=Uint8Array,Ue=Uint16Array,dn=Uint32Array,Zn=new ve([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Ln=new ve([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),ir=new ve([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Wn=function(u,a){for(var m=new Ue(31),S=0;S<31;++S)m[S]=a+=1<<u[S-1];for(var w=new dn(m[30]),S=1;S<30;++S)for(var R=m[S];R<m[S+1];++R)w[R]=R-m[S]<<5|S;return[m,w]},Hn=Wn(Zn,2),Gn=Hn[0],ar=Hn[1];Gn[28]=258,ar[258]=28;var sr=Wn(Ln,0),lr=sr[0],wn=new Ue(32768);for(var B=0;B<32768;++B){var Me=(B&43690)>>>1|(B&21845)<<1;Me=(Me&52428)>>>2|(Me&13107)<<2,Me=(Me&61680)>>>4|(Me&3855)<<4,wn[B]=((Me&65280)>>>8|(Me&255)<<8)>>>1}var $e=function(u,a,m){for(var S=u.length,w=0,R=new Ue(a);w<S;++w)++R[u[w]-1];var P=new Ue(a);for(w=0;w<a;++w)P[w]=P[w-1]+R[w-1]<<1;var k;if(m){k=new Ue(1<<a);var x=15-a;for(w=0;w<S;++w)if(u[w])for(var C=w<<4|u[w],q=a-u[w],te=P[u[w]-1]++<<q,se=te|(1<<q)-1;te<=se;++te)k[wn[te]>>>x]=C}else for(k=new Ue(S),w=0;w<S;++w)u[w]&&(k[w]=wn[P[u[w]-1]++]>>>15-u[w]);return k},Ke=new ve(288);for(var B=0;B<144;++B)Ke[B]=8;for(var B=144;B<256;++B)Ke[B]=9;for(var B=256;B<280;++B)Ke[B]=7;for(var B=280;B<288;++B)Ke[B]=8;var Xn=new ve(32);for(var B=0;B<32;++B)Xn[B]=5;var cr=$e(Ke,9,1),ur=$e(Xn,5,1),vn=function(u){for(var a=u[0],m=1;m<u.length;++m)u[m]>a&&(a=u[m]);return a},xe=function(u,a,m){var S=a/8|0;return(u[S]|u[S+1]<<8)>>(a&7)&m},fn=function(u,a){var m=a/8|0;return(u[m]|u[m+1]<<8|u[m+2]<<16)>>(a&7)},pr=function(u){return(u/8|0)+(u&7&&1)},hr=function(u,a,m){(a==null||a<0)&&(a=0),(m==null||m>u.length)&&(m=u.length);var S=new(u instanceof Ue?Ue:u instanceof dn?dn:ve)(m-a);return S.set(u.subarray(a,m)),S},mr=function(u,a,m){var S=u.length;if(!S||m&&!m.l&&S<5)return a||new ve(0);var w=!a||m,R=!m||m.i;m||(m={}),a||(a=new ve(S*3));var P=function(N){var ge=a.length;if(N>ge){var ye=new ve(Math.max(ge*2,N));ye.set(a),a=ye}},k=m.f||0,x=m.p||0,C=m.b||0,q=m.l,te=m.d,se=m.m,O=m.n,le=S*8;do{if(!q){m.f=k=xe(u,x,1);var Ie=xe(u,x+1,3);if(x+=3,Ie)if(Ie==1)q=cr,te=ur,se=9,O=5;else if(Ie==2){var Ee=xe(u,x,31)+257,ce=xe(u,x+10,15)+4,Te=Ee+xe(u,x+5,31)+1;x+=14;for(var fe=new ve(Te),Ce=new ve(19),Q=0;Q<ce;++Q)Ce[ir[Q]]=xe(u,x+Q*3,7);x+=ce*3;for(var De=vn(Ce),Oe=(1<<De)-1,Z=$e(Ce,De,1),Q=0;Q<Te;){var ne=Z[xe(u,x,Oe)];x+=ne&15;var I=ne>>>4;if(I<16)fe[Q++]=I;else{var K=0,ue=0;for(I==16?(ue=3+xe(u,x,3),x+=2,K=fe[Q-1]):I==17?(ue=3+xe(u,x,7),x+=3):I==18&&(ue=11+xe(u,x,127),x+=7);ue--;)fe[Q++]=K}}var Se=fe.subarray(0,Ee),pe=fe.subarray(Ee);se=vn(Se),O=vn(pe),q=$e(Se,se,1),te=$e(pe,O,1)}else throw"invalid block type";else{var I=pr(x)+4,G=u[I-4]|u[I-3]<<8,$=I+G;if($>S){if(R)throw"unexpected EOF";break}w&&P(C+G),a.set(u.subarray(I,$),C),m.b=C+=G,m.p=x=$*8;continue}if(x>le){if(R)throw"unexpected EOF";break}}w&&P(C+131072);for(var Re=(1<<se)-1,ze=(1<<O)-1,re=x;;re=x){var K=q[fn(u,x)&Re],Y=K>>>4;if(x+=K&15,x>le){if(R)throw"unexpected EOF";break}if(!K)throw"invalid length/literal";if(Y<256)a[C++]=Y;else if(Y==256){re=x,q=null;break}else{var M=Y-254;if(Y>264){var Q=Y-257,X=Zn[Q];M=xe(u,x,(1<<X)-1)+Gn[Q],x+=X}var W=te[fn(u,x)&ze],de=W>>>4;if(!W)throw"invalid distance";x+=W&15;var pe=lr[de];if(de>3){var X=Ln[de];pe+=fn(u,x)&(1<<X)-1,x+=X}if(x>le){if(R)throw"unexpected EOF";break}w&&P(C+131072);for(var we=C+M;C<we;C+=4)a[C]=a[C-pe],a[C+1]=a[C+1-pe],a[C+2]=a[C+2-pe],a[C+3]=a[C+3-pe];C=we}}m.l=q,m.p=re,m.b=C,q&&(k=1,m.m=se,m.d=te,m.n=O)}while(!k);return C==a.length?a:hr(a,0,C)},vr=new ve(0),fr=function(u){if((u[0]&15)!=8||u[0]>>>4>7||(u[0]<<8|u[1])%31)throw"invalid zlib data";if(u[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function an(u,a){return mr((fr(u),u.subarray(2,-4)),a)}var dr=typeof TextDecoder<"u"&&new TextDecoder,wr=0;try{dr.decode(vr,{stream:!0}),wr=1}catch(u){}class gr extends At{constructor(a){super(a),this.type=je}parse(a){const De=Math.pow(2.7182818,2.2);function Oe(e,n){let t=0;for(let i=0;i<65536;++i)(i==0||e[i>>3]&1<<(i&7))&&(n[t++]=i);const r=t-1;for(;t<65536;)n[t++]=0;return r}function Z(e){for(let n=0;n<16384;n++)e[n]={},e[n].len=0,e[n].lit=0,e[n].p=null}const ne={l:0,c:0,lc:0};function K(e,n,t,r,i){for(;t<e;)n=n<<8|_n(r,i),t+=8;t-=e,ne.l=n>>t&(1<<e)-1,ne.c=n,ne.lc=t}const ue=new Array(59);function Se(e){for(let t=0;t<=58;++t)ue[t]=0;for(let t=0;t<65537;++t)ue[e[t]]+=1;let n=0;for(let t=58;t>0;--t){const r=n+ue[t]>>1;ue[t]=n,n=r}for(let t=0;t<65537;++t){const r=e[t];r>0&&(e[t]=r|ue[r]++<<6)}}function pe(e,n,t,r,i,o){const l=n;let p=0,h=0;for(;r<=i;r++){if(l.value-n.value>t)return!1;K(6,p,h,e,l);const s=ne.l;if(p=ne.c,h=ne.lc,o[r]=s,s==63){if(l.value-n.value>t)throw new Error("Something wrong with hufUnpackEncTable");K(8,p,h,e,l);let c=ne.l+6;if(p=ne.c,h=ne.lc,r+c>i+1)throw new Error("Something wrong with hufUnpackEncTable");for(;c--;)o[r++]=0;r--}else if(s>=59){let c=s-59+2;if(r+c>i+1)throw new Error("Something wrong with hufUnpackEncTable");for(;c--;)o[r++]=0;r--}}Se(o)}function Re(e){return e&63}function ze(e){return e>>6}function re(e,n,t,r){for(;n<=t;n++){const i=ze(e[n]),o=Re(e[n]);if(i>>o)throw new Error("Invalid table entry");if(o>14){const l=r[i>>o-14];if(l.len)throw new Error("Invalid table entry");if(l.lit++,l.p){const p=l.p;l.p=new Array(l.lit);for(let h=0;h<l.lit-1;++h)l.p[h]=p[h]}else l.p=new Array(1);l.p[l.lit-1]=n}else if(o){let l=0;for(let p=1<<14-o;p>0;p--){const h=r[(i<<14-o)+l];if(h.len||h.p)throw new Error("Invalid table entry");h.len=o,h.lit=n,l++}}}return!0}const Y={c:0,lc:0};function M(e,n,t,r){e=e<<8|_n(t,r),n+=8,Y.c=e,Y.lc=n}const X={c:0,lc:0};function W(e,n,t,r,i,o,l,p,h){if(e==n){r<8&&(M(t,r,i,o),t=Y.c,r=Y.lc),r-=8;let s=t>>r;if(s=new Uint8Array([s])[0],p.value+s>h)return!1;const c=l[p.value-1];for(;s-- >0;)l[p.value++]=c}else if(p.value<h)l[p.value++]=e;else return!1;X.c=t,X.lc=r}function de(e){return e&65535}function we(e){const n=de(e);return n>32767?n-65536:n}const N={a:0,b:0};function ge(e,n){const t=we(e),i=we(n),o=t+(i&1)+(i>>1),l=o,p=o-i;N.a=l,N.b=p}function ye(e,n){const t=de(e),r=de(n),i=t-(r>>1)&65535,o=r+i-32768&65535;N.a=o,N.b=i}function Ne(e,n,t,r,i,o,l){const p=l<16384,h=t>i?i:t;let s=1,c,d;for(;s<=h;)s<<=1;for(s>>=1,c=s,s>>=1;s>=1;){d=0;const f=d+o*(i-c),_=o*s,E=o*c,g=r*s,y=r*c;let T,L,H,ie;for(;d<=f;d+=E){let z=d;const U=d+r*(t-c);for(;z<=U;z+=y){const j=z+g,me=z+_,V=me+g;p?(ge(e[z+n],e[me+n]),T=N.a,H=N.b,ge(e[j+n],e[V+n]),L=N.a,ie=N.b,ge(T,L),e[z+n]=N.a,e[j+n]=N.b,ge(H,ie),e[me+n]=N.a,e[V+n]=N.b):(ye(e[z+n],e[me+n]),T=N.a,H=N.b,ye(e[j+n],e[V+n]),L=N.a,ie=N.b,ye(T,L),e[z+n]=N.a,e[j+n]=N.b,ye(H,ie),e[me+n]=N.a,e[V+n]=N.b)}if(t&s){const j=z+_;p?ge(e[z+n],e[j+n]):ye(e[z+n],e[j+n]),T=N.a,e[j+n]=N.b,e[z+n]=T}}if(i&s){let z=d;const U=d+r*(t-c);for(;z<=U;z+=y){const j=z+g;p?ge(e[z+n],e[j+n]):ye(e[z+n],e[j+n]),T=N.a,e[j+n]=N.b,e[z+n]=T}}c=s,s>>=1}return d}function cn(e,n,t,r,i,o,l,p,h){let s=0,c=0;const d=l,f=Math.trunc(r.value+(i+7)/8);for(;r.value<f;)for(M(s,c,t,r),s=Y.c,c=Y.lc;c>=14;){const E=s>>c-14&16383,g=n[E];if(g.len)c-=g.len,W(g.lit,o,s,c,t,r,p,h,d),s=X.c,c=X.lc;else{if(!g.p)throw new Error("hufDecode issues");let y;for(y=0;y<g.lit;y++){const T=Re(e[g.p[y]]);for(;c<T&&r.value<f;)M(s,c,t,r),s=Y.c,c=Y.lc;if(c>=T&&ze(e[g.p[y]])==(s>>c-T&(1<<T)-1)){c-=T,W(g.p[y],o,s,c,t,r,p,h,d),s=X.c,c=X.lc;break}}if(y==g.lit)throw new Error("hufDecode issues")}}const _=8-i&7;for(s>>=_,c-=_;c>0;){const E=n[s<<14-c&16383];if(E.len)c-=E.len,W(E.lit,o,s,c,t,r,p,h,d),s=X.c,c=X.lc;else throw new Error("hufDecode issues")}return!0}function Ve(e,n,t,r,i,o){const l={value:0},p=t.value,h=oe(n,t),s=oe(n,t);t.value+=4;const c=oe(n,t);if(t.value+=4,h<0||h>=65537||s<0||s>=65537)throw new Error("Something wrong with HUF_ENCSIZE");const d=new Array(65537),f=new Array(16384);Z(f);const _=r-(t.value-p);if(pe(e,t,_,h,s,d),c>8*(r-(t.value-p)))throw new Error("Something wrong with hufUncompress");re(d,h,s,f),cn(d,f,e,t,c,s,o,i,l)}function be(e,n,t){for(let r=0;r<t;++r)n[r]=e[n[r]]}function Qe(e){for(let n=1;n<e.length;n++){const t=e[n-1]+e[n]-128;e[n]=t}}function Je(e,n){let t=0,r=Math.floor((e.length+1)/2),i=0;const o=e.length-1;for(;!(i>o||(n[i++]=e[t++],i>o));)n[i++]=e[r++]}function Be(e){let n=e.byteLength;const t=new Array;let r=0;const i=new DataView(e);for(;n>0;){const o=i.getInt8(r++);if(o<0){const l=-o;n-=l+1;for(let p=0;p<l;p++)t.push(i.getUint8(r++))}else{const l=o;n-=2;const p=i.getUint8(r++);for(let h=0;h<l+1;h++)t.push(p)}}return t}function Le(e,n,t,r,i,o){let l=new DataView(o.buffer);const p=t[e.idx[0]].width,h=t[e.idx[0]].height,s=3,c=Math.floor(p/8),d=Math.ceil(p/8),f=Math.ceil(h/8),_=p-(d-1)*8,E=h-(f-1)*8,g={value:0},y=new Array(s),T=new Array(s),L=new Array(s),H=new Array(s),ie=new Array(s);for(let U=0;U<s;++U)ie[U]=n[e.idx[U]],y[U]=U<1?0:y[U-1]+d*f,T[U]=new Float32Array(64),L[U]=new Uint16Array(64),H[U]=new Uint16Array(d*64);for(let U=0;U<f;++U){let j=8;U==f-1&&(j=E);let me=8;for(let F=0;F<d;++F){F==d-1&&(me=_);for(let A=0;A<s;++A)L[A].fill(0),L[A][0]=i[y[A]++],un(g,r,L[A]),en(L[A],T[A]),D(T[A]);J(T);for(let A=0;A<s;++A)Yn(T[A],H[A],F*64)}let V=0;for(let F=0;F<s;++F){const A=t[e.idx[F]].type;for(let Pe=8*U;Pe<8*U+j;++Pe){V=ie[F][Pe];for(let Ye=0;Ye<c;++Ye){const _e=Ye*64+(Pe&7)*8;l.setUint16(V+0*2*A,H[F][_e+0],!0),l.setUint16(V+1*2*A,H[F][_e+1],!0),l.setUint16(V+2*2*A,H[F][_e+2],!0),l.setUint16(V+3*2*A,H[F][_e+3],!0),l.setUint16(V+4*2*A,H[F][_e+4],!0),l.setUint16(V+5*2*A,H[F][_e+5],!0),l.setUint16(V+6*2*A,H[F][_e+6],!0),l.setUint16(V+7*2*A,H[F][_e+7],!0),V+=8*2*A}}if(c!=d)for(let Pe=8*U;Pe<8*U+j;++Pe){const Ye=ie[F][Pe]+8*c*2*A,_e=c*64+(Pe&7)*8;for(let rn=0;rn<me;++rn)l.setUint16(Ye+rn*2*A,H[F][_e+rn],!0)}}}const z=new Uint16Array(p);l=new DataView(o.buffer);for(let U=0;U<s;++U){t[e.idx[U]].decoded=!0;const j=t[e.idx[U]].type;if(t[U].type==2)for(let me=0;me<h;++me){const V=ie[U][me];for(let F=0;F<p;++F)z[F]=l.getUint16(V+F*2*j,!0);for(let F=0;F<p;++F)l.setFloat32(V+F*2*j,v(z[F]),!0)}}}function un(e,n,t){let r,i=1;for(;i<64;)r=n[e.value],r==65280?i=64:r>>8==255?i+=r&255:(t[i]=r,i++),e.value++}function en(e,n){n[0]=v(e[0]),n[1]=v(e[1]),n[2]=v(e[5]),n[3]=v(e[6]),n[4]=v(e[14]),n[5]=v(e[15]),n[6]=v(e[27]),n[7]=v(e[28]),n[8]=v(e[2]),n[9]=v(e[4]),n[10]=v(e[7]),n[11]=v(e[13]),n[12]=v(e[16]),n[13]=v(e[26]),n[14]=v(e[29]),n[15]=v(e[42]),n[16]=v(e[3]),n[17]=v(e[8]),n[18]=v(e[12]),n[19]=v(e[17]),n[20]=v(e[25]),n[21]=v(e[30]),n[22]=v(e[41]),n[23]=v(e[43]),n[24]=v(e[9]),n[25]=v(e[11]),n[26]=v(e[18]),n[27]=v(e[24]),n[28]=v(e[31]),n[29]=v(e[40]),n[30]=v(e[44]),n[31]=v(e[53]),n[32]=v(e[10]),n[33]=v(e[19]),n[34]=v(e[23]),n[35]=v(e[32]),n[36]=v(e[39]),n[37]=v(e[45]),n[38]=v(e[52]),n[39]=v(e[54]),n[40]=v(e[20]),n[41]=v(e[22]),n[42]=v(e[33]),n[43]=v(e[38]),n[44]=v(e[46]),n[45]=v(e[51]),n[46]=v(e[55]),n[47]=v(e[60]),n[48]=v(e[21]),n[49]=v(e[34]),n[50]=v(e[37]),n[51]=v(e[47]),n[52]=v(e[50]),n[53]=v(e[56]),n[54]=v(e[59]),n[55]=v(e[61]),n[56]=v(e[35]),n[57]=v(e[36]),n[58]=v(e[48]),n[59]=v(e[49]),n[60]=v(e[57]),n[61]=v(e[58]),n[62]=v(e[62]),n[63]=v(e[63])}function D(e){const n=.5*Math.cos(.7853975),t=.5*Math.cos(3.14159/16),r=.5*Math.cos(3.14159/8),i=.5*Math.cos(3*3.14159/16),o=.5*Math.cos(5*3.14159/16),l=.5*Math.cos(3*3.14159/8),p=.5*Math.cos(7*3.14159/16),h=new Array(4),s=new Array(4),c=new Array(4),d=new Array(4);for(let f=0;f<8;++f){const _=f*8;h[0]=r*e[_+2],h[1]=l*e[_+2],h[2]=r*e[_+6],h[3]=l*e[_+6],s[0]=t*e[_+1]+i*e[_+3]+o*e[_+5]+p*e[_+7],s[1]=i*e[_+1]-p*e[_+3]-t*e[_+5]-o*e[_+7],s[2]=o*e[_+1]-t*e[_+3]+p*e[_+5]+i*e[_+7],s[3]=p*e[_+1]-o*e[_+3]+i*e[_+5]-t*e[_+7],c[0]=n*(e[_+0]+e[_+4]),c[3]=n*(e[_+0]-e[_+4]),c[1]=h[0]+h[3],c[2]=h[1]-h[2],d[0]=c[0]+c[1],d[1]=c[3]+c[2],d[2]=c[3]-c[2],d[3]=c[0]-c[1],e[_+0]=d[0]+s[0],e[_+1]=d[1]+s[1],e[_+2]=d[2]+s[2],e[_+3]=d[3]+s[3],e[_+4]=d[3]-s[3],e[_+5]=d[2]-s[2],e[_+6]=d[1]-s[1],e[_+7]=d[0]-s[0]}for(let f=0;f<8;++f)h[0]=r*e[16+f],h[1]=l*e[16+f],h[2]=r*e[48+f],h[3]=l*e[48+f],s[0]=t*e[8+f]+i*e[24+f]+o*e[40+f]+p*e[56+f],s[1]=i*e[8+f]-p*e[24+f]-t*e[40+f]-o*e[56+f],s[2]=o*e[8+f]-t*e[24+f]+p*e[40+f]+i*e[56+f],s[3]=p*e[8+f]-o*e[24+f]+i*e[40+f]-t*e[56+f],c[0]=n*(e[f]+e[32+f]),c[3]=n*(e[f]-e[32+f]),c[1]=h[0]+h[3],c[2]=h[1]-h[2],d[0]=c[0]+c[1],d[1]=c[3]+c[2],d[2]=c[3]-c[2],d[3]=c[0]-c[1],e[0+f]=d[0]+s[0],e[8+f]=d[1]+s[1],e[16+f]=d[2]+s[2],e[24+f]=d[3]+s[3],e[32+f]=d[3]-s[3],e[40+f]=d[2]-s[2],e[48+f]=d[1]-s[1],e[56+f]=d[0]-s[0]}function J(e){for(let n=0;n<64;++n){const t=e[0][n],r=e[1][n],i=e[2][n];e[0][n]=t+1.5747*i,e[1][n]=t-.1873*r-.4682*i,e[2][n]=t+1.8556*r}}function Yn(e,n,t){for(let r=0;r<64;++r)n[t+r]=In.toHalfFloat(jn(e[r]))}function jn(e){return e<=1?Math.sign(e)*Math.pow(Math.abs(e),2.2):Math.sign(e)*Math.pow(De,Math.abs(e)-1)}function Sn(e){return new DataView(e.array.buffer,e.offset.value,e.size)}function qn(e){const n=e.viewer.buffer.slice(e.offset.value,e.offset.value+e.size),t=new Uint8Array(Be(n)),r=new Uint8Array(t.length);return Qe(t),Je(t,r),new DataView(r.buffer)}function pn(e){const n=e.array.slice(e.offset.value,e.offset.value+e.size),t=an(n),r=new Uint8Array(t.length);return Qe(t),Je(t,r),new DataView(r.buffer)}function $n(e){const n=e.viewer,t={value:e.offset.value},r=new Uint16Array(e.width*e.scanlineBlockSize*(e.channels*e.type)),i=new Uint8Array(8192);let o=0;const l=new Array(e.channels);for(let E=0;E<e.channels;E++)l[E]={},l[E].start=o,l[E].end=l[E].start,l[E].nx=e.width,l[E].ny=e.lines,l[E].size=e.type,o+=l[E].nx*l[E].ny*l[E].size;const p=He(n,t),h=He(n,t);if(h>=8192)throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");if(p<=h)for(let E=0;E<h-p+1;E++)i[E+p]=ke(n,t);const s=new Uint16Array(65536),c=Oe(i,s),d=oe(n,t);Ve(e.array,n,t,d,r,o);for(let E=0;E<e.channels;++E){const g=l[E];for(let y=0;y<l[E].size;++y)Ne(r,g.start+y,g.nx,g.size,g.ny,g.nx*g.size,c)}be(s,r,o);let f=0;const _=new Uint8Array(r.buffer.byteLength);for(let E=0;E<e.lines;E++)for(let g=0;g<e.channels;g++){const y=l[g],T=y.nx*y.size,L=new Uint8Array(r.buffer,y.end*2,T*2);_.set(L,f),f+=T*2,y.end+=T}return new DataView(_.buffer)}function Kn(e){const n=e.array.slice(e.offset.value,e.offset.value+e.size),t=an(n),r=e.lines*e.channels*e.width,i=e.type==1?new Uint16Array(r):new Uint32Array(r);let o=0,l=0;const p=new Array(4);for(let h=0;h<e.lines;h++)for(let s=0;s<e.channels;s++){let c=0;switch(e.type){case 1:p[0]=o,p[1]=p[0]+e.width,o=p[1]+e.width;for(let d=0;d<e.width;++d){const f=t[p[0]++]<<8|t[p[1]++];c+=f,i[l]=c,l++}break;case 2:p[0]=o,p[1]=p[0]+e.width,p[2]=p[1]+e.width,o=p[2]+e.width;for(let d=0;d<e.width;++d){const f=t[p[0]++]<<24|t[p[1]++]<<16|t[p[2]++]<<8;c+=f,i[l]=c,l++}break}}return new DataView(i.buffer)}function yn(e){const n=e.viewer,t={value:e.offset.value},r=new Uint8Array(e.width*e.lines*(e.channels*e.type*2)),i={version:he(n,t),unknownUncompressedSize:he(n,t),unknownCompressedSize:he(n,t),acCompressedSize:he(n,t),dcCompressedSize:he(n,t),rleCompressedSize:he(n,t),rleUncompressedSize:he(n,t),rleRawSize:he(n,t),totalAcUncompressedCount:he(n,t),totalDcUncompressedCount:he(n,t),acCompression:he(n,t)};if(i.version<2)throw new Error("EXRLoader.parse: "+Xe.compression+" version "+i.version+" is unsupported");const o=new Array;let l=He(n,t)-2;for(;l>0;){const g=nn(n.buffer,t),y=ke(n,t),T=y>>2&3,L=(y>>4)-1,H=new Int8Array([L])[0],ie=ke(n,t);o.push({name:g,index:H,type:ie,compression:T}),l-=g.length+3}const p=Xe.channels,h=new Array(e.channels);for(let g=0;g<e.channels;++g){const y=h[g]={},T=p[g];y.name=T.name,y.compression=0,y.decoded=!1,y.type=T.pixelType,y.pLinear=T.pLinear,y.width=e.width,y.height=e.lines}const s={idx:new Array(3)};for(let g=0;g<e.channels;++g){const y=h[g];for(let T=0;T<o.length;++T){const L=o[T];y.name==L.name&&(y.compression=L.compression,L.index>=0&&(s.idx[L.index]=g),y.offset=g)}}let c,d,f;if(i.acCompressedSize>0)switch(i.acCompression){case 0:c=new Uint16Array(i.totalAcUncompressedCount),Ve(e.array,n,t,i.acCompressedSize,c,i.totalAcUncompressedCount);break;case 1:const g=e.array.slice(t.value,t.value+i.totalAcUncompressedCount),y=an(g);c=new Uint16Array(y.buffer),t.value+=i.totalAcUncompressedCount;break}if(i.dcCompressedSize>0){const g={array:e.array,offset:t,size:i.dcCompressedSize};d=new Uint16Array(pn(g).buffer),t.value+=i.dcCompressedSize}if(i.rleRawSize>0){const g=e.array.slice(t.value,t.value+i.rleCompressedSize),y=an(g);f=Be(y.buffer),t.value+=i.rleCompressedSize}let _=0;const E=new Array(h.length);for(let g=0;g<E.length;++g)E[g]=new Array;for(let g=0;g<e.lines;++g)for(let y=0;y<h.length;++y)E[y].push(_),_+=h[y].width*e.type*2;Le(s,E,h,c,d,r);for(let g=0;g<h.length;++g){const y=h[g];if(!y.decoded)switch(y.compression){case 2:let T=0,L=0;for(let H=0;H<e.lines;++H){let ie=E[g][T];for(let z=0;z<y.width;++z){for(let U=0;U<2*y.type;++U)r[ie++]=f[L+U*y.width*y.height];L++}T++}break;case 1:default:throw new Error("EXRLoader.parse: unsupported channel compression")}}return new DataView(r.buffer)}function nn(e,n){const t=new Uint8Array(e);let r=0;for(;t[n.value+r]!=0;)r+=1;const i=new TextDecoder().decode(t.slice(n.value,n.value+r));return n.value=n.value+r+1,i}function Vn(e,n,t){const r=new TextDecoder().decode(new Uint8Array(e).slice(n.value,n.value+t));return n.value=n.value+t,r}function Qn(e,n){const t=We(e,n),r=oe(e,n);return[t,r]}function Jn(e,n){const t=oe(e,n),r=oe(e,n);return[t,r]}function We(e,n){const t=e.getInt32(n.value,!0);return n.value=n.value+4,t}function oe(e,n){const t=e.getUint32(n.value,!0);return n.value=n.value+4,t}function _n(e,n){const t=e[n.value];return n.value=n.value+1,t}function ke(e,n){const t=e.getUint8(n.value);return n.value=n.value+1,t}const he=function(e,n){let t;return"getBigInt64"in DataView.prototype?t=Number(e.getBigInt64(n.value,!0)):t=e.getUint32(n.value+4,!0)+Number(e.getUint32(n.value,!0)<<32),n.value+=8,t};function ee(e,n){const t=e.getFloat32(n.value,!0);return n.value+=4,t}function et(e,n){return In.toHalfFloat(ee(e,n))}function v(e){const n=(e&31744)>>10,t=e&1023;return(e>>15?-1:1)*(n?n===31?t?NaN:1/0:Math.pow(2,n-15)*(1+t/1024):6103515625e-14*(t/1024))}function He(e,n){const t=e.getUint16(n.value,!0);return n.value+=2,t}function nt(e,n){return v(He(e,n))}function tt(e,n,t,r){const i=t.value,o=[];for(;t.value<i+r-1;){const l=nn(n,t),p=We(e,t),h=ke(e,t);t.value+=3;const s=We(e,t),c=We(e,t);o.push({name:l,pixelType:p,pLinear:h,xSampling:s,ySampling:c})}return t.value+=1,o}function rt(e,n){const t=ee(e,n),r=ee(e,n),i=ee(e,n),o=ee(e,n),l=ee(e,n),p=ee(e,n),h=ee(e,n),s=ee(e,n);return{redX:t,redY:r,greenX:i,greenY:o,blueX:l,blueY:p,whiteX:h,whiteY:s}}function ot(e,n){const t=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],r=ke(e,n);return t[r]}function it(e,n){const t=oe(e,n),r=oe(e,n),i=oe(e,n),o=oe(e,n);return{xMin:t,yMin:r,xMax:i,yMax:o}}function at(e,n){const t=["INCREASING_Y"],r=ke(e,n);return t[r]}function st(e,n){const t=ee(e,n),r=ee(e,n);return[t,r]}function lt(e,n){const t=ee(e,n),r=ee(e,n),i=ee(e,n);return[t,r,i]}function ct(e,n,t,r,i){if(r==="string"||r==="stringvector"||r==="iccProfile")return Vn(n,t,i);if(r==="chlist")return tt(e,n,t,i);if(r==="chromaticities")return rt(e,t);if(r==="compression")return ot(e,t);if(r==="box2i")return it(e,t);if(r==="lineOrder")return at(e,t);if(r==="float")return ee(e,t);if(r==="v2f")return st(e,t);if(r==="v3f")return lt(e,t);if(r==="int")return We(e,t);if(r==="rational")return Qn(e,t);if(r==="timecode")return Jn(e,t);if(r==="preview")return t.value+=i,"skipped";t.value+=i}function ut(e,n,t){const r={};if(e.getUint32(0,!0)!=20000630)throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");r.version=e.getUint8(4);const i=e.getUint8(5);r.spec={singleTile:!!(i&2),longName:!!(i&4),deepFormat:!!(i&8),multiPart:!!(i&16)},t.value=8;let o=!0;for(;o;){const l=nn(n,t);if(l==0)o=!1;else{const p=nn(n,t),h=oe(e,t),s=ct(e,n,t,p,h);s===void 0?console.warn("THREE.EXRLoader: Skipped unknown header attribute type '".concat(p,"'.")):r[l]=s}}if(i&-5)throw console.error("THREE.EXRHeader:",r),new Error("THREE.EXRLoader: Provided file is currently unsupported.");return r}function pt(e,n,t,r,i){const o={size:0,viewer:n,array:t,offset:r,width:e.dataWindow.xMax-e.dataWindow.xMin+1,height:e.dataWindow.yMax-e.dataWindow.yMin+1,channels:e.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:e.channels[0].pixelType,uncompress:null,getter:null,format:null,colorSpace:Pn};switch(e.compression){case"NO_COMPRESSION":o.lines=1,o.uncompress=Sn;break;case"RLE_COMPRESSION":o.lines=1,o.uncompress=qn;break;case"ZIPS_COMPRESSION":o.lines=1,o.uncompress=pn;break;case"ZIP_COMPRESSION":o.lines=16,o.uncompress=pn;break;case"PIZ_COMPRESSION":o.lines=32,o.uncompress=$n;break;case"PXR24_COMPRESSION":o.lines=16,o.uncompress=Kn;break;case"DWAA_COMPRESSION":o.lines=32,o.uncompress=yn;break;case"DWAB_COMPRESSION":o.lines=256,o.uncompress=yn;break;default:throw new Error("EXRLoader.parse: "+e.compression+" is unsupported")}if(o.scanlineBlockSize=o.lines,o.type==1)switch(i){case qe:o.getter=nt,o.inputSize=2;break;case je:o.getter=He,o.inputSize=2;break}else if(o.type==2)switch(i){case qe:o.getter=ee,o.inputSize=4;break;case je:o.getter=et,o.inputSize=4}else throw new Error("EXRLoader.parse: unsupported pixelType "+o.type+" for "+e.compression+".");o.blockCount=(e.dataWindow.yMax+1)/o.scanlineBlockSize;for(let p=0;p<o.blockCount;p++)he(n,r);o.outputChannels=o.channels==3?4:o.channels;const l=o.width*o.height*o.outputChannels;switch(i){case qe:o.byteArray=new Float32Array(l),o.channels<o.outputChannels&&o.byteArray.fill(1,0,l);break;case je:o.byteArray=new Uint16Array(l),o.channels<o.outputChannels&&o.byteArray.fill(15360,0,l);break;default:console.error("THREE.EXRLoader: unsupported type: ",i);break}return o.bytesPerLine=o.width*o.inputSize*o.channels,o.outputChannels==4?(o.format=Ot,o.colorSpace=Pn):(o.format=zt,o.colorSpace=Bt),o}const tn=new DataView(a),ht=new Uint8Array(a),Ge={value:0},Xe=ut(tn,a,Ge),b=pt(Xe,tn,ht,Ge,this.type),En={value:0},mt={R:0,G:1,B:2,A:3,Y:0};for(let e=0;e<b.height/b.scanlineBlockSize;e++){const n=oe(tn,Ge);b.size=oe(tn,Ge),b.lines=n+b.scanlineBlockSize>b.height?b.height-n:b.scanlineBlockSize;const r=b.size<b.lines*b.bytesPerLine?b.uncompress(b):Sn(b);Ge.value+=b.size;for(let i=0;i<b.scanlineBlockSize;i++){const o=i+e*b.scanlineBlockSize;if(o>=b.height)break;for(let l=0;l<b.channels;l++){const p=mt[Xe.channels[l].name];for(let h=0;h<b.width;h++){En.value=(i*(b.channels*b.width)+l*b.width+h)*b.inputSize;const s=(b.height-1-o)*(b.width*b.outputChannels)+h*b.outputChannels+p;b.byteArray[s]=b.getter(r,En)}}}}return{header:Xe,width:b.width,height:b.height,data:b.byteArray,format:b.format,colorSpace:b.colorSpace,type:this.type}}setDataType(a){return this.type=a,this}load(a,m,S,w){function R(P,k){P.colorSpace=k.colorSpace,P.minFilter=Ae,P.magFilter=Ae,P.generateMipmaps=!1,P.flipY=!1,m&&m(P,k)}return super.load(a,R,S,w)}}const xr=["object","scale"],Sr=xn({__name:"groundProjectedEnvCom",props:{texture:{default:"https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/round_platform_1k.exr"},size:{default:100}},async setup(u){let a,m;const S=u,w=new gr,R=([a,m]=kt(()=>w.loadAsync(S.texture)),a=await a,m(),a);R.mapping=Zt;const{scene:P}=zn();P.value.environment=R;const k=new er(R);return(x,C)=>(sn(),Bn("primitive",{object:Ze(k),scale:S.size},null,8,xr))}}),yr=["object"],_r=["object"],Er=xn({__name:"causticsTorusMesh",props:{color:{default:"#ffffff"},ior:{default:1.1},backsideIOR:{default:1.1},far:{default:15},worldRadius:{default:.3},intensity:{default:.05},causticsOnly:{type:Boolean,default:!1},lightSource:{default:{x:1,y:1,z:1}}},setup(u){const a=u,m=new Lt(3,1,100,32),S=new Wt({transmission:1,roughness:0});S.color.setHSL(Math.random(),1,.5),S.thickness=2;const w=new gn(m,S);w.position.set(0,6,0);const{renderer:R}=zn(),P=or(R.value,{frames:1/0,resolution:1024,worldRadius:a.worldRadius});P.params.backside=!0,P.scene.add(w);const{onBeforeLoop:k}=Xt();return k(({elapsed:x})=>{w.rotation.x=x,w.rotation.y=x,P.update()}),Ht(()=>{a.color&&P.params.color.set(a.color),a.ior&&(P.params.ior=a.ior),a.backsideIOR&&(P.params.backsideIOR=a.backsideIOR),a.far&&(P.params.far=a.far),a.worldRadius&&(P.params.worldRadius=a.worldRadius),a.intensity&&(P.params.intensity=a.intensity)}),Tn(()=>a.causticsOnly,x=>{P.params.causticsOnly=x}),Tn(()=>a.lightSource,x=>{x&&P.params.lightSource instanceof ae&&P.params.lightSource.set(x.x,x.y,x.z)},{deep:!0}),(x,C)=>(sn(),Bn(Gt,null,[ln("primitive",{object:Ze(P).group,position:[0,.003,0]},null,8,yr),ln("primitive",{object:Ze(P).helper,visible:!1},null,8,_r)],64))}}),Pr=ln("TresPerspectiveCamera",{position:[-20,20,15],fov:45,near:1,far:1e3},null,-1),Ir=ln("TresDirectionalLight",{position:[10,2,4],intensity:1},null,-1),Rr=xn({__name:"causticsDemo",setup(u){const a=hn({alpha:!0,toneMapping:Yt,windowSize:!0,clearColor:10066329}),m=hn({enableDamping:!0,autoRotate:!1}),S=hn({color:"#ffffff",ior:1.1,backsideIOR:1.1,far:15,worldRadius:.3,intensity:.05,causticsOnly:!1,lightSource:{x:1,y:1,z:1}}),w=new jt({title:"参数"});return w.addBinding(S,"color",{label:"颜色"}),w.addBinding(S,"ior",{label:"折射系数",min:.6,max:1.3,step:.01}),w.addBinding(S,"backsideIOR",{label:"折射系数2",min:.6,max:1.3,step:.01}),w.addBinding(S,"far",{label:"可视距离",min:0,max:15,step:1}),w.addBinding(S,"worldRadius",{label:"材质大小",min:.001,max:.5,step:.001}),w.addBinding(S,"intensity",{label:"强度",min:0,max:1,step:.01}),w.addBinding(S,"causticsOnly",{label:"只显示投射"}),w.addBinding(S,"lightSource",{label:"光源位置",x:{min:-1,max:1},y:{min:-1,max:1},z:{min:-1,max:1}}),(R,P)=>(sn(),Cn(Ze($t),qt(a,{"window-size":""}),{default:bn(()=>[Pr,mn(Ze(Kt),Mn(Un(m)),null,16),Ir,mn(Er,Mn(Un(S)),null,16),(sn(),Cn(Vt,null,{default:bn(()=>[mn(Ze(Sr),{position:[0,-.1,0]})]),_:1}))]),_:1},16))}});export{Rr as default};
