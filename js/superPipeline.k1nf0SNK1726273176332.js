import{U as n}from"./@tresjs.BFyWuCYn1726273176332.js";import{a0 as t,aN as e}from"./three.874nNzAX1726273176332.js";import{_ as o}from"./argestCircle.iQbYZf4A1726273176332.js";import{d as r,e as a,o as c,f as i,g as f,L as l,aj as s,ak as d,m as p}from"./@vue.JNsx1iN61726273176332.js";import"./@vueuse.NxhkGURn1726273176332.js";function v(n,t){const e=g();return(v=function(n,t){return e[n-=289]})(n,t)}const u=v;!function(n,t){const e=v,o=g();for(;;)try{if(389921===parseInt(e(327))/1+-parseInt(e(289))/2+parseInt(e(322))/3+parseInt(e(316))/4+-parseInt(e(307))/5+-parseInt(e(313))/6+parseInt(e(331))/7)break;o.push(o.shift())}catch(r){o.push(o.shift())}}();const m=function(){let n=!0;return function(t,e){const o=n?function(){if(e){const n=e[v(317)](t,arguments);return e=null,n}}:function(){};return n=!1,o}}();!function(){m(this,(function(){const n=v,t=new RegExp(n(314)),e=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),o=T(n(290));t[n(320)](o+n(330))&&e[n(320)](o+n(303))?T():o("0")}))()}();const x=function(){let n=!0;return function(t,e){const o=n?function(){if(e){const n=e.apply(t,arguments);return e=null,n}}:function(){};return n=!1,o}}();x(void 0,(function(){const n=v,t=function(){const n=v;let t;try{t=Function(n(291)+'{}.constructor("return this")( ));')()}catch(e){t=window}return t}(),e=t[n(329)]=t[n(329)]||{},o=[n(297),"warn",n(325),n(312),n(301),n(328),n(302)];for(let r=0;r<o[n(299)];r++){const t=x.constructor[n(315)][n(326)](x),a=o[r],c=e[a]||t;t.__proto__=x.bind(x),t[n(321)]=c[n(321)][n(326)](c),e[a]=t}}))();const y={ref:u(292),position:[0,0,1800],fov:45,near:1,far:1e4},b=l("TresAmbientLight",{color:u(296)},null,-1),h=l(u(305),{position:[100,100,0],intensity:.5,color:u(296)},null,-1),j=[u(300)],D=l("TresPlaneGeometry",{args:[4e3,4e3]},null,-1);function g(){const n=["debu","info","bind","523222SUjjmz","table","console","chain","3534734OHdSbF","72096ORvoaA","init","return (function() ","perspectiveCameraRef","TresMesh","superPipeline","counter","#ffffff","log","TresPerspectiveCamera","length","rotation-x","exception","trace","input","call","TresDirectionalLight","while (true) {}","2044455Xkrtsx","action","string","quanMeshRef","constructor","error","3760524sPFsJx","function *\\( *\\)","prototype","439808qCRXGt","apply","uTime","#000000","test","toString","970434ulxwSi","gger"];return(g=function(){return n})()}const O=r({__name:u(294),setup(r){const v=u,m={clearColor:v(319),shadows:!0,alpha:!1,useLegacyLights:!0},x={uniforms:{uTime:{type:"f",value:0}},vertexShader:o,fragmentShader:"// 光线追踪实例，想学习每行代码的逻辑，请联系ICE社区-Jsonco\nvarying vec2 vUv;\nuniform float uTime;\n#define FAR 50.\nfloat svObjID,svObjID2;\nvec3 vObjID;\n#define TUN 0.\n#define ROD 1.\n#define BLT 2.\nmat2 rot(float th){vec2 a=sin(vec2(1.5707963,0)+th);return mat2(a,-a.y,a.x);}\nvec3 camPath(float t){\nfloat a=sin(t*3.14159265/16.+1.5707963);\nfloat b=cos(t*3.14159265/16.);\nreturn vec3(a,b*a*.5,t);\n}\n\nvec3 camPathPL(float t){\nfloat it=floor(t+1.);\nfloat ft=t-it;\nfloat a=sin(it*3.14159265/16.+1.5707963);\nfloat b=cos(it*3.14159265/16.);\nvec2 p0=vec2(a,b*a*.5);\na=sin((it+1.)*3.14159265/16.+1.5707963);\nb=cos((it+1.)*3.14159265/16.);\nvec2 p1=vec2(a,b*a*.5);\nvec2 p=mix(p0,p1,ft);\nreturn vec3(p,t);\n}\nvec2 objMin(vec2 a,vec2 b){\nreturn a.x<b.x?a:b;\n}\n\nfloat map(vec3 p){\nconst float depth=.25;\np.xy-=camPath(p.z).xy;\nfloat tun=(1.+depth)-length(p.xy);\nvec3 q=p;\nvec3 q2=p;\nfloat a=atan(q.y,q.x)/6.2831853;\nfloat ia=(floor(a*5.)+.5)/5.*6.2831853;\nfloat ia2=(floor(a*15.)+.5)/15.*6.2831853;\nq.xy*=rot(ia+sign(mod(q.z+1.,4.)-2.)*3.14159/15.);//\nq2.xy*=rot(ia2);\nq.x=mod(q.x,2.)-1.;\nq.z=mod(q.z,2.)-1.;\nq2.x=mod(q2.x,(2.+.25))-(2.+.25)/2.;\nq=abs(q);\nq2=abs(q2);\nfloat tunDetail=max(min(q.y,q.z)-.07,-(min(q.y,q.z)-.007));\ntun=min(tun,max(tunDetail,tun-depth));\nfloat blt=max(max(q2.x*.866025+q2.y*.5,q2.y)-.055,q.z-.16);\nfloat thread=max(sin(q.z*6.283*64.)*2.,0.)*.002;\nfloat rod=max(length(q2.xy)-.025+thread,q.z-.19);\nrod=min(rod,max(length(q2.xy)-.075,q.z-.09));\nvObjID=vec3(tun,blt,rod);\nreturn min(min(tun,blt),rod);\n}\nfloat refTrace(vec3 ro,vec3 rd){\nfloat t=0.;\nfor(int i=0;i<12;i++){\nfloat d=map(ro+rd*t);\nif(abs(d)<.005*(t*.25+1.)||t>FAR)break;\nt+=d;\n}\nreturn t;\n}\n\nfloat trace(vec3 ro,vec3 rd){\nfloat t=0.,d;\nfor(int i=0;i<96;i++){\nd=map(ro+rd*t);\nif(abs(d)<.001*(t*.125+1.)||t>FAR)break;\nt+=d;\n}\nreturn min(t,FAR);\n}\nvec3 nrHyb(vec3 p,inout float crv,float ef){\nvec2 e=vec2(-1.,1.)*.66*ef/450.;\nfloat d1=map(p+e.yxx),d2=map(p+e.xxy);\nfloat d3=map(p+e.xyx),d4=map(p+e.yyy);\nfloat d=map(p);\nfloat d5,d6;\ncrv=clamp((d1+d2+d3+d4-d*4.)*24.+.5,0.,1.);\ne=vec2(.005,0);\nd1=map(p+e.xyy),d2=map(p-e.xyy);\nd3=map(p+e.yxy),d4=map(p-e.yxy);\nd5=map(p+e.yyx),d6=map(p-e.yyx);\nreturn normalize(vec3(d1-d2,d3-d4,d5-d6));\n}\nvec3 nrRef(in vec3 p,inout float crv,in float ef){\nvec2 e=vec2(-1.,1.)*.66*ef/450.;\nfloat d1=map(p+e.yxx),d2=map(p+e.xxy);\nfloat d3=map(p+e.xyx),d4=map(p+e.yyy);\nfloat d=map(p);\ncrv=clamp((d1+d2+d3+d4-d*4.)*24.+.5,0.,1.);\ne=vec2(-1.,1.)*.002;\nd1=map(p+e.yxx),d2=map(p+e.xxy);\nd3=map(p+e.xyx),d4=map(p+e.yyy);\nreturn normalize(e.yxx*d1+e.xxy*d2+e.xyx*d3+e.yyy*d4);\n}\nfloat cao(in vec3 p,in vec3 n){\nfloat sca=1.,occ=0.;\nfor(float i=0.;i<5.;i++){\nfloat hr=.01+i*.5/4.;\nfloat dd=map(n*hr+p);\nocc+=(hr-dd)*sca;\nsca*=.7;\n}\nreturn clamp(1.-occ,0.,1.);\n}\nfloat softShadow(vec3 ro,vec3 lp,float k){\nconst int maxIterationsShad=20;\nvec3 rd=(lp-ro);\nfloat shade=1.;\nfloat dist=.05;\nfloat end=max(length(rd),.001);\nrd/=end;\nfor(int i=0;i<maxIterationsShad;i++){\nfloat h=map(ro+rd*dist);\nshade=min(shade,k*h/dist);\ndist+=clamp(h,.01,.25);\nif(h<.001||dist>end)break;\n}\nreturn min(max(shade,0.)+.2,1.);\n}\nvec3 palette(float t){\nvec3 a=vec3(.5,.5,.5);\nvec3 b=vec3(.5,.5,.5);\nvec3 c=vec3(1.,1.,1.);\nvec3 d=vec3(sin(uTime*.2)*.5+.5,cos(uTime*.25)*.5+.5,sin(uTime*.3+1.)*.5+.5);\nreturn a+b*cos(6.28318*(c*t+d));\n}\nvoid main(){\nvec2 u=(vUv-vec2(.5))*2.;\n#ifdef THREE_D\nfloat sg=sign(fragCoord.x-.5*iResolution.x);\nu.x-=sg*.25*iResolution.x/iResolution.y;\n#endif\nfloat speed=2.;\nvec3 ro=camPath(uTime*speed+.0);\nvec3 lk=camPath(uTime*speed+.5);\nvec3 lp=camPath(uTime*speed+2.);\nlp.y+=.5;\n#ifdef THREE_D\nro.x-=sg*.15;lk.x-=sg*.15;lp.x-=sg*.15;\n#endif\nfloat FOV=.75;\nvec3 fwd=normalize(lk-ro);\nvec3 rgt=normalize(vec3(fwd.z,0.,-fwd.x));\nvec3 up=cross(fwd,rgt);\nvec3 rd=fwd+FOV*(u.x*rgt+u.y*up);\nrd=normalize(vec3(rd.xy,(rd.z-length(rd.xy)*.25)*.75));\nfloat swivel=camPath(lk.z).x;\nrd.xy=rot(swivel/48.)*rd.xy;\nrd.xz=rot(swivel/32.)*rd.xz;\nfloat t=trace(ro,rd);\nvec2 vObj=objMin(vec2(vObjID.x,TUN),vec2(vObjID.y,BLT));\nvObj=objMin(vObj,vec2(vObjID.z,ROD));\nsvObjID=vObj.y;\nvec3 sp=ro+rd*t;\nfloat crv=1.,ef=8.;\nvec3 sn=nrHyb(sp,crv,ef);\nfloat sh=softShadow(sp,lp,16.);\nfloat ao=cao(sp,sn);\nvec3 ld=lp-sp;\nfloat lDist=max(length(ld),.0001);\nld/=lDist;\nfloat atten=1./(1.+lDist*.25+lDist*lDist*.025);\nconst float tSize0=1./1.;\nvec3 tx=palette(u.y+uTime*.4);\ntx=tx*.5+smoothstep(.02,.8,tx)*1.;\nfloat gr=dot(tx,vec3(.299,.587,.114));\nif(svObjID==TUN)tx*=vec3(1);\nelse if(svObjID==ROD)tx=(gr*.5+.5)*vec3(1);\nelse if(svObjID==BLT)tx=(tx*.5+.5)*vec3(1.4,.7,.05);\nfloat dif=max(dot(ld,sn),0.);\nfloat spe=pow(max(dot(reflect(rd,sn),ld),0.),64.);\nfloat Schlick=pow(1.-max(dot(rd,normalize(rd+ld)),0.),5.);\nSchlick=mix(.5,1.,Schlick);\nif(svObjID!=TUN)\ndif=(pow(dif,4.)*.5+pow(dif,8.)*.5)*3.;\nvec3 ref=reflect(rd,sn);\nfloat rt=refTrace(sp+ref*.1,ref);\nvObj=objMin(vec2(vObjID.x,TUN),vec2(vObjID.y,BLT));\nvObj=objMin(vObj,vec2(vObjID.z,ROD));\nsvObjID2=vObj.y;\nfloat crv2=1.;\nvec3 rsp=sp+ref*rt;\nvec3 rsn=nrRef(rsp,crv2,ef);\nvec3 rCol=palette(u.y+uTime*.4);\nrCol=smoothstep(.02,.8,rCol)*2.;\ngr=dot(rCol,vec3(.299,.587,.114));\nif(svObjID2==TUN)rCol*=vec3(1);\nelse if(svObjID2==ROD)rCol=(gr*.5+.5)*vec3(1);\nelse if(svObjID2==BLT)rCol=(rCol*.5+.5)*vec3(1.4,.7,.05);\nfloat rDiff=max(dot(rsn,normalize(lp-rsp)),0.);\nfloat rSpec=pow(max(dot(reflect(ref,rsn),normalize(lp-rsp)),0.),8.);\nfloat rlDist=length(lp-rsp);\nif(svObjID2!=TUN)rDiff=(pow(rDiff,4.)*.5+pow(rDiff,8.)*.5)*3.;\nrCol=rCol*(rDiff+.25)+vec3(1.,.6,.2)*rSpec*2.;\nrCol*=1./(1.+rlDist*.25+rlDist*rlDist*.025);\nrCol*=min(crv2*1.5,1.);\nvec3 fc=tx*(dif+ao*.3)+vec3(1,.6,.2)*spe*Schlick*2.;\nif(svObjID!=TUN)fc+=rCol*.5;\nelse fc+=rCol*.25;\nfc*=atten*sh*ao;\nfc*=clamp(crv*1.5,0.,1.);\nvec3 bg=vec3(1,.7,.4);\nfc=mix(fc,bg*2.,smoothstep(0.,.95,t/FAR));\ngl_FragColor=vec4(pow(clamp(fc,0.,1.),vec3(1./2.)),1.);// 1./2.2, etc.\n}\n",side:t,blending:e,depthWrite:!1,transparent:!0},{onLoop:g}=n();return g((({delta:n})=>{const t=v;x.uniforms[t(318)].value+=n})),(n,t)=>{const e=v,o=a("TresCanvas");return c(),i(o,p(m,{"window-size":""}),{default:f((()=>[l(e(298),y,null,512),b,h,l(e(293),{ref:e(310),"rotation-x":Math.PI},[D,l("TresShaderMaterial",s(d(x)),null,16)],8,j)])),_:1},16)}}});function T(n){function t(n){const e=v;if(typeof n===e(309))return function(n){}.constructor(e(306))[e(317)](e(295));1!==(""+n/n)[e(299)]||n%20==0?function(){return!0}[e(311)]("debu"+e(323))[e(304)](e(308)):function(){return!1}.constructor(e(324)+e(323))[e(317)]("stateObject"),t(++n)}try{if(n)return t;t(0)}catch(e){}}export{O as default};
