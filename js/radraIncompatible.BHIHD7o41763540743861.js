import{_ as e}from"./@tresjs.BCHtwiaC1763540743861.js";import{M as n}from"./three.rXKzP9fQ1763540743861.js";import{d as t,a,a6 as o,g as l,H as r,o as i,h as g}from"./@vue.Co_gxueH1763540743861.js";import"./postprocessing.51l5tmA-1763540743861.js";import"./@vueuse.CfFJ-iFV1763540743861.js";const s={position:[0,80,0]},f=t({__name:"radraIncompatible",setup(t){const{onBeforeRender:f}=e(),u={value:0},c=a(),d=a();f(({delta:e})=>{u.value+=e});const m=240,v=300,h=220;return o(()=>{if(d.value){const e=(new n).makeRotationX(-Math.PI/180*90);d.value.applyMatrix4(e)}c.value&&(c.value.onBeforeCompile=e=>{Object.assign(e.uniforms,{uSpeed:{value:v},uRadius:{value:m},uTime:u,uFollowWidth:{value:h}});e.vertexShader=e.vertexShader.replace("void main() {","\n\tvarying vec3 vPosition;\n\tvoid main() {\n\t\tvPosition = position;\n");e.fragmentShader=e.fragmentShader.replace("void main() {","\n\tuniform float uRadius;     \n        uniform float uTime;            \n        uniform float uSpeed; \n        uniform float uFollowWidth; \n        varying vec3 vPosition;\n        float calcAngle(vec3 oFrag){\n          float fragAngle;\n          const vec3 ox = vec3(1,0,0);\n          float dianji = oFrag.x * ox.x + oFrag.z*ox.z;\n          float oFrag_length = length(oFrag); // length是内置函数\n          float ox_length = length(ox); // length是内置函数\n          float yuxian = dianji / (oFrag_length * ox_length);\n          fragAngle = acos(yuxian);\n          fragAngle = degrees(fragAngle);\n          if(oFrag.z > 0.0) {\n            fragAngle = -fragAngle + 360.0;\n          }\n          float scanAngle = uTime * uSpeed - floor(uTime * uSpeed / 360.0) * 360.0;\n          float angle = scanAngle - fragAngle;\n          if(angle < 0.0){\n            angle = angle + 360.0;\n          }\n          return angle;\n        }\n        void main() {\n"),e.fragmentShader=e.fragmentShader.replace("#include <colorspace_fragment>\n\t","\n\t// length内置函数，取向量的长度\n\tif(length(vPosition) == 0.0 || length(vPosition) > uRadius-2.0){\n\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t} else {\n\t\tfloat angle = calcAngle(vPosition);\n\t\tif(angle < uFollowWidth){\n\t\t\t// 尾焰区域\n\t\t\tfloat opacity =  1.0 - angle / uFollowWidth; \n\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a * opacity );  \n\t\t} else {\n\t\t\t// 其他位置的像素均为透明\n\t\t\tgl_FragColor = vec4( outgoingLight, 0.0 ); \n\t\t}\n\t}\n\t#include <colorspace_fragment>\n\t\n")})}),(e,n)=>{const t=l("CircleGeometry"),a=l("MeshPhongMaterial");return i(),r("TresMesh",s,[g(t,{ref_key:"TresCircleGeometryRef",ref:d,args:[240,1e3]},null,512),g(a,{ref_key:"MeshPhongMaterialRef",ref:c,color:"#ffff00",opacity:"0.7",transparent:!0},null,512)])}}});export{f as default};
