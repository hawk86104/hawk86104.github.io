import{i as e}from"./3d-tiles-renderer.CbgZh8zU1767066396612.js";import{o as t}from"./oimophysics.CfVKSiAm1767066396612.js";const{Box2:i,BoxGeometry:r,BufferGeometry:n,Float32BufferAttribute:o,MathUtils:a,Vector3:l}=await e("three");const{GLSL3:s,RawShaderMaterial:c}=await e("three"),{Color:d,GLSL3:m,RawShaderMaterial:u}=await e("three"),{GLSL3:h,RawShaderMaterial:v}=await e("three"),{GLSL3:f,RawShaderMaterial:g}=await e("three"),{GLSL3:M,RawShaderMaterial:p}=await e("three"),{Color:y,GLSL3:x,RawShaderMaterial:w}=await e("three"),{GLSL3:S,NoBlending:C,RawShaderMaterial:R}=await e("three"),{GLSL3:L,NoBlending:G,RawShaderMaterial:b}=await e("three"),{GLSL3:P,NoBlending:T,RawShaderMaterial:B}=await e("three"),{GLSL3:N,NoBlending:j,RawShaderMaterial:F}=await e("three"),{GLSL3:U,NoBlending:J,RawShaderMaterial:W,Vector2:V}=await e("three"),{GLSL3:_,NoBlending:E,RawShaderMaterial:A,Vector2:D}=await e("three"),{GLSL3:O,NoBlending:z,RawShaderMaterial:k,Vector2:I}=await e("three"),{GLSL3:H,LinearFilter:q,NearestFilter:K,NoBlending:Q,RawShaderMaterial:$,TextureLoader:X,Vector2:Y}=await e("three"),{GLSL3:Z,NoBlending:ee,RawShaderMaterial:te}=await e("three"),{GLSL3:ie,NoBlending:re,RawShaderMaterial:ne}=await e("three"),{GLSL3:oe,NoBlending:ae,RawShaderMaterial:le,Vector2:se}=await e("three"),{GLSL3:ce,NoBlending:de,RawShaderMaterial:me,Vector2:ue}=await e("three"),{GLSL3:he,NoBlending:ve,RawShaderMaterial:fe}=await e("three"),{GLSL3:ge,NoBlending:Me,RawShaderMaterial:pe,Vector2:ye}=await e("three"),{GLSL3:xe,NoBlending:we,RawShaderMaterial:Se}=await e("three"),Ce="\n\nfloat random(vec2 co) {\n    float a = 12.9898;\n    float b = 78.233;\n    float c = 43758.5453;\n    float dt = dot(co.xy, vec2(a, b));\n    float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n\n\nvec3 dither(vec3 color) {\n    // Calculate grid position\n    float grid_position = random(gl_FragCoord.xy);\n\n    // Shift the individual colors differently, thus making it even harder to see the dithering pattern\n    vec3 dither_shift_RGB = vec3(0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0);\n\n    // Modify shift acording to grid position\n    dither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position);\n\n    // Shift the color by dither_shift\n    return color + dither_shift_RGB;\n}\n",{GLSL3:Re,NoBlending:Le,RawShaderMaterial:Ge}=await e("three"),{GLSL3:be,NoBlending:Pe,RawShaderMaterial:Te}=await e("three"),{GLSL3:Be,NearestFilter:Ne,NoBlending:je,RawShaderMaterial:Fe,RepeatWrapping:Ue,TextureLoader:Je,Vector2:We}=await e("three"),{GLSL3:Ve,Matrix4:_e,NoBlending:Ee,RawShaderMaterial:Ae,Vector3:De}=await e("three"),{GLSL3:Oe,NoBlending:ze,RawShaderMaterial:ke,Vector2:Ie}=await e("three"),{GLSL3:He,NoBlending:qe,RawShaderMaterial:Ke,Vector2:Qe}=await e("three"),{GLSL3:$e,NoBlending:Xe,RawShaderMaterial:Ye,Vector2:Ze}=await e("three"),{GLSL3:et,NoBlending:tt,RawShaderMaterial:it,Vector2:rt}=await e("three");class nt extends it{constructor(){super({glslVersion:et,uniforms:{tMap:{value:null},uDirection:{value:new rt(1,0)},uResolution:{value:new rt}},vertexShader:"\nin vec3 position;\nin vec2 uv;\n\nout vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n\n    gl_Position = vec4(position, 1.0);\n}\n",fragmentShader:"\nprecision highp float;\n\nuniform sampler2D tMap;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\n\nfloat smootherstep(float edge0, float edge1, float x) {\n    x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\n\nvec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.411764705882353) * direction;\n  vec2 off2 = vec2(3.2941176470588234) * direction;\n  vec2 off3 = vec2(5.176470588235294) * direction;\n  color += texture(image, uv) * 0.1964825501511404;\n  color += texture(image, uv + (off1 / resolution)) * 0.2969069646728344;\n  color += texture(image, uv - (off1 / resolution)) * 0.2969069646728344;\n  color += texture(image, uv + (off2 / resolution)) * 0.09447039785044732;\n  color += texture(image, uv - (off2 / resolution)) * 0.09447039785044732;\n  color += texture(image, uv + (off3 / resolution)) * 0.010381362401148057;\n  color += texture(image, uv - (off3 / resolution)) * 0.010381362401148057;\n  return color;\n}\n\n\nvoid main() {\n    FragColor = blur13(tMap, vUv, uResolution, smootherstep(1.0, 0.0, vUv.y) * uDirection);\n}\n",blending:tt,depthTest:!1,depthWrite:!1})}}const ot=`\nprecision highp float;\n\nuniform sampler2D tReflect;\nuniform vec3 uColor;\nuniform float uReflectivity;\nuniform float uMirror;\nuniform float uMixStrength;\n\n#ifdef USE_MAP\n    uniform sampler2D tMap;\n#endif\n\n#ifdef USE_NORMALMAP\n    uniform sampler2D tNormalMap;\n    uniform vec2 uNormalScale;\n#endif\n\n#ifdef USE_FOG\n    uniform vec3 uFogColor;\n    uniform float uFogNear;\n    uniform float uFogFar;\n#endif\n\nin vec2 vUv;\nin vec4 vCoord;\nin vec3 vNormal;\nin vec3 vToEye;\n\nout vec4 FragColor;\n\n${Ce}\n\nvoid main() {\n    #ifdef USE_MAP\n        vec4 color = texture(tMap, vUv);\n    #else\n        vec4 color = vec4(uColor, 1.0);\n    #endif\n\n    #ifdef USE_NORMALMAP\n        vec4 normalColor = texture(tNormalMap, vUv * uNormalScale);\n        vec3 normal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));\n        vec3 coord = vCoord.xyz / vCoord.w;\n        vec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n        vec4 reflectColor = texture(tReflect, uv);\n    #else\n        vec3 normal = vNormal;\n        vec4 reflectColor = textureProj(tReflect, vCoord);\n    #endif\n\n    // Fresnel term\n    vec3 toEye = normalize(vToEye);\n    float theta = max(dot(toEye, normal), 0.0);\n    float reflectance = uReflectivity + (1.0 - uReflectivity) * pow((1.0 - theta), 5.0);\n\n    reflectColor = mix(vec4(0), reflectColor, reflectance);\n\n    FragColor.rgb = color.rgb * ((1.0 - min(1.0, uMirror)) + reflectColor.rgb * uMixStrength);\n\n    #ifdef USE_FOG\n        float fogDepth = gl_FragCoord.z / gl_FragCoord.w;\n        float fogFactor = smoothstep(uFogNear, uFogFar, fogDepth);\n\n        FragColor.rgb = mix(FragColor.rgb, uFogColor, fogFactor);\n    #endif\n\n    #ifdef DITHERING\n        FragColor.rgb = dither(FragColor.rgb);\n    #endif\n\n    FragColor.a = 1.0;\n}\n`,{Color:at,GLSL3:lt,Matrix3:st,Matrix4:ct,NoBlending:dt,RawShaderMaterial:mt,Vector2:ut}=await e("three");class ht extends mt{constructor({color:e=new at(1052688),map:t=null,normalMap:i=null,normalScale:r=new ut(1,1),reflectivity:n=0,mirror:o=0,mixStrength:a=10,fog:l=null,dithering:s=!1}={}){const c={glslVersion:lt,defines:{},uniforms:{tMap:{value:null},tReflect:{value:null},uMapTransform:{value:new st},uMatrix:{value:new ct},uColor:{value:e instanceof at?e:new at(e)},uReflectivity:{value:n},uMirror:{value:o},uMixStrength:{value:a}},vertexShader:"\nin vec3 position;\nin vec3 normal;\nin vec2 uv;\n\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\nuniform mat3 uMapTransform;\nuniform mat4 uMatrix;\n\nout vec2 vUv;\nout vec4 vCoord;\nout vec3 vNormal;\nout vec3 vToEye;\n\nvoid main() {\n    vUv = (uMapTransform * vec3(uv, 1.0)).xy;\n    vCoord = uMatrix * vec4(position, 1.0);\n    vNormal = normalMatrix * normal;\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    vToEye = cameraPosition - worldPosition.xyz;\n\n    vec4 mvPosition = viewMatrix * worldPosition;\n    gl_Position = projectionMatrix * mvPosition;\n}\n",fragmentShader:ot,blending:dt};t&&(t.updateMatrix(),c.defines=Object.assign(c.defines,{USE_MAP:""}),c.uniforms=Object.assign(c.uniforms,{tMap:{value:t},uMapTransform:{value:t.matrix}})),i&&(c.defines=Object.assign(c.defines,{USE_NORMALMAP:""}),c.uniforms=Object.assign(c.uniforms,{tNormalMap:{value:i},uNormalScale:{value:r}}),t||(i.updateMatrix(),c.uniforms=Object.assign(c.uniforms,{uMapTransform:{value:i.matrix}}))),l&&(c.defines=Object.assign(c.defines,{USE_FOG:""}),c.uniforms=Object.assign(c.uniforms,{uFogColor:{value:l.color},uFogNear:{value:l.near},uFogFar:{value:l.far}})),s&&(c.defines=Object.assign(c.defines,{DITHERING:""})),super(c)}}const vt=`\nprecision highp float;\n\nuniform sampler2D tMap;\nuniform sampler2D tReflect;\nuniform sampler2D tReflectBlur;\nuniform float uReflectivity;\n\nin vec2 vUv;\nin vec4 vCoord;\nin vec3 vNormal;\nin vec3 vToEye;\n\nout vec4 FragColor;\n\n${Ce}\n\nvoid main() {\n    vec2 reflectionUv = vCoord.xy / vCoord.w;\n\n    vec4 dudv = texture(tMap, vUv);\n    vec4 color = texture(tReflect, reflectionUv);\n\n    vec4 blur;\n\n    blur = texture(tReflectBlur, reflectionUv + dudv.rg / 256.0);\n    color = mix(color, blur, smoothstep(1.0, 0.1, dudv.g));\n\n    blur = texture(tReflectBlur, reflectionUv);\n    color = mix(color, blur, smoothstep(0.5, 1.0, dudv.r));\n\n    FragColor = color * mix(0.6, 0.75, dudv.g);\n\n    // Fresnel term\n    vec3 toEye = normalize(vToEye);\n    float theta = max(dot(toEye, vNormal), 0.0);\n    float reflectance = uReflectivity + (1.0 - uReflectivity) * pow((1.0 - theta), 5.0);\n\n    FragColor = mix(vec4(0), FragColor, reflectance);\n\n    #ifdef DITHERING\n        FragColor.rgb = dither(FragColor.rgb);\n    #endif\n\n    FragColor.a = 1.0;\n}\n`,{GLSL3:ft,Matrix3:gt,Matrix4:Mt,NoBlending:pt,RawShaderMaterial:yt}=await e("three");class xt extends yt{constructor({map:e=null,reflectivity:t=0,dithering:i=!1}={}){const r={glslVersion:ft,defines:{DITHERING:i},uniforms:{tMap:{value:null},tReflect:{value:null},tReflectBlur:{value:null},uMapTransform:{value:new gt},uMatrix:{value:new Mt},uReflectivity:{value:t}},vertexShader:"\nin vec3 position;\nin vec3 normal;\nin vec2 uv;\n\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\nuniform mat3 uMapTransform;\nuniform mat4 uMatrix;\n\nout vec2 vUv;\nout vec4 vCoord;\nout vec3 vNormal;\nout vec3 vToEye;\n\nvoid main() {\n    vUv = (uMapTransform * vec3(uv, 1.0)).xy;\n    vCoord = uMatrix * vec4(position, 1.0);\n    vNormal = normalMatrix * normal;\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    vToEye = cameraPosition - worldPosition.xyz;\n\n    vec4 mvPosition = viewMatrix * worldPosition;\n    gl_Position = projectionMatrix * mvPosition;\n}\n",fragmentShader:vt,blending:pt};e&&(e.updateMatrix(),r.uniforms=Object.assign(r.uniforms,{tMap:{value:e},uMapTransform:{value:e.matrix}})),super(r)}}const{GLSL3:wt,NoBlending:St,RawShaderMaterial:Ct}=await e("three"),{GLSL3:Rt,NoBlending:Lt,RawShaderMaterial:Gt}=await e("three"),{GLSL3:bt,NoBlending:Pt,RawShaderMaterial:Tt}=await e("three"),{GLSL3:Bt,NoBlending:Nt,RawShaderMaterial:jt,Vector2:Ft}=await e("three"),{GLSL3:Ut,NoBlending:Jt,RawShaderMaterial:Wt,Vector2:Vt}=await e("three"),{AdditiveBlending:_t,GLSL3:Et,RawShaderMaterial:At,Vector2:Dt}=await e("three"),{GLSL3:Ot,NoBlending:zt,RawShaderMaterial:kt}=await e("three"),{GLSL3:It,NoBlending:Ht,RawShaderMaterial:qt}=await e("three"),{Color:Kt,GLSL3:Qt,RawShaderMaterial:$t}=await e("three"),{Vector3:Xt}=await e("three"),{GLSL3:Yt,HalfFloatType:Zt,Mesh:ei,NoBlending:ti,OrthographicCamera:ii,RawShaderMaterial:ri,Vector2:ni,WebGLRenderTarget:oi}=await e("three"),{Group:ai,Matrix4:li,Mesh:si,OrthographicCamera:ci,PerspectiveCamera:di,Plane:mi,Vector3:ui,Vector4:hi,WebGLRenderTarget:vi}=await e("three");class fi extends ai{constructor({width:e=512,height:t=512,clipBias:i=0,blurIterations:r=8}={}){super(),this.clipBias=i,this.blurIterations=r,this.reflectorPlane=new mi,this.normal=new ui,this.reflectorWorldPosition=new ui,this.cameraWorldPosition=new ui,this.rotationMatrix=new li,this.lookAtPosition=new ui(0,0,-1),this.clipPlane=new hi,this.view=new ui,this.target=new ui,this.q=new hi,this.textureMatrix=new li,this.virtualCamera=new di,this.textureMatrixUniform={value:this.textureMatrix},this.renderTarget=new vi(e,t,{depthBuffer:!1}),this.renderTargetRead=this.renderTarget.clone(),this.renderTargetWrite=this.renderTarget.clone(),this.renderTarget.depthBuffer=!0,this.renderTargetUniform={value:this.blurIterations>0?this.renderTargetRead.texture:this.renderTarget.texture},this.blurMaterial=new nt,this.blurMaterial.uniforms.uResolution.value.set(e,t),this.screenCamera=new ci(-1,1,1,-1,0,1),this.screenTriangle=function(){const e=new n;return e.setAttribute("position",new o([-1,3,0,-1,-1,0,3,-1,0],3)),e.setAttribute("uv",new o([0,2,0,0,2,0],2)),e}(),this.screen=new si(this.screenTriangle,this.blurMaterial),this.screen.frustumCulled=!1}setSize(e,t){this.renderTarget.setSize(e,t),this.renderTargetRead.setSize(e,t),this.renderTargetWrite.setSize(e,t),this.blurMaterial.uniforms.uResolution.value.set(e,t)}update(e,t,i){if(this.reflectorWorldPosition.setFromMatrixPosition(this.matrixWorld),this.cameraWorldPosition.setFromMatrixPosition(i.matrixWorld),this.rotationMatrix.extractRotation(this.matrixWorld),this.normal.set(0,0,1),this.normal.applyMatrix4(this.rotationMatrix),this.view.subVectors(this.reflectorWorldPosition,this.cameraWorldPosition),this.view.dot(this.normal)>0)return;this.view.reflect(this.normal).negate(),this.view.add(this.reflectorWorldPosition),this.rotationMatrix.extractRotation(i.matrixWorld),this.lookAtPosition.set(0,0,-1),this.lookAtPosition.applyMatrix4(this.rotationMatrix),this.lookAtPosition.add(this.cameraWorldPosition),this.target.subVectors(this.reflectorWorldPosition,this.lookAtPosition),this.target.reflect(this.normal).negate(),this.target.add(this.reflectorWorldPosition),this.virtualCamera.position.copy(this.view),this.virtualCamera.up.set(0,1,0),this.virtualCamera.up.applyMatrix4(this.rotationMatrix),this.virtualCamera.up.reflect(this.normal),this.virtualCamera.lookAt(this.target),this.virtualCamera.far=i.far,this.virtualCamera.updateMatrixWorld(),this.virtualCamera.projectionMatrix.copy(i.projectionMatrix),this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.virtualCamera.projectionMatrix),this.textureMatrix.multiply(this.virtualCamera.matrixWorldInverse),this.textureMatrix.multiply(this.matrixWorld),this.reflectorPlane.setFromNormalAndCoplanarPoint(this.normal,this.reflectorWorldPosition),this.reflectorPlane.applyMatrix4(this.virtualCamera.matrixWorldInverse),this.clipPlane.set(this.reflectorPlane.normal.x,this.reflectorPlane.normal.y,this.reflectorPlane.normal.z,this.reflectorPlane.constant);const r=this.virtualCamera.projectionMatrix;this.q.x=(Math.sign(this.clipPlane.x)+r.elements[8])/r.elements[0],this.q.y=(Math.sign(this.clipPlane.y)+r.elements[9])/r.elements[5],this.q.z=-1,this.q.w=(1+r.elements[10])/r.elements[14],this.clipPlane.multiplyScalar(2/this.clipPlane.dot(this.q)),r.elements[2]=this.clipPlane.x,r.elements[6]=this.clipPlane.y,r.elements[10]=this.clipPlane.z+1-this.clipBias,r.elements[14]=this.clipPlane.w;const n=e.getRenderTarget(),o=e.xr.enabled,a=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(this.renderTarget),e.state.buffers.depth.setMask(!0),!1===e.autoClear&&e.clear(),e.render(t,this.virtualCamera);const l=this.blurIterations;for(let s=0;s<l;s++){this.blurMaterial.uniforms.tMap.value=0===s?this.renderTarget.texture:this.renderTargetRead.texture;const t=.5*(l-s-1);this.blurMaterial.uniforms.uDirection.value.set(s%2==0?t:0,s%2==0?0:t),e.setRenderTarget(this.renderTargetWrite),!1===e.autoClear&&e.clear(),e.render(this.screen,this.screenCamera);const i=this.renderTargetRead;this.renderTargetRead=this.renderTargetWrite,this.renderTargetWrite=i,this.renderTargetUniform.value=this.renderTargetRead.texture}e.xr.enabled=o,e.shadowMap.autoUpdate=a,e.setRenderTarget(n)}destroy(){this.renderTargetWrite.dispose(),this.renderTargetRead.dispose(),this.renderTarget.dispose(),this.blurMaterial.dispose(),this.screenTriangle.dispose();for(const e in this)this[e]=null;return null}}const{ShaderChunk:gi}=await e("three"),{Group:Mi,Matrix4:pi,Vector3:yi}=await e("three");t.dynamics.World,t.dynamics.rigidbody.RigidBodyType,t.dynamics.rigidbody.RigidBodyConfig,t.dynamics.rigidbody.RigidBody,t.dynamics.rigidbody.ShapeConfig,t.dynamics.rigidbody.Shape,t.dynamics.constraint.joint.SphericalJointConfig,t.dynamics.constraint.joint.SphericalJoint,t.dynamics.constraint.joint.RevoluteJointConfig,t.dynamics.constraint.joint.RevoluteJoint,t.dynamics.constraint.joint.CylindricalJointConfig,t.dynamics.constraint.joint.CylindricalJoint,t.dynamics.constraint.joint.PrismaticJointConfig,t.dynamics.constraint.joint.PrismaticJoint,t.dynamics.constraint.joint.UniversalJointConfig,t.dynamics.constraint.joint.UniversalJoint,t.dynamics.constraint.joint.RagdollJointConfig,t.dynamics.constraint.joint.RagdollJoint,t.dynamics.constraint.joint.GenericJointConfig,t.dynamics.constraint.joint.GenericJoint,t.dynamics.constraint.joint.JointConfig,t.dynamics.constraint.joint.Joint,t.dynamics.constraint.joint.SpringDamper,t.dynamics.constraint.joint.TranslationalLimitMotor,t.dynamics.constraint.joint.RotationalLimitMotor,t.common.Vec3,t.common.Quat,t.common.Mat3,t.common.MathUtil,t.common.Transform;const xi=t.common.Setting;t.collision.geometry.BoxGeometry,t.collision.geometry.SphereGeometry,t.collision.geometry.ConeGeometry,t.collision.geometry.CylinderGeometry,t.collision.geometry.CapsuleGeometry,t.collision.geometry.ConvexHullGeometry,t.collision.geometry.Geometry,t.dynamics.callback.RayCastClosest,t.dynamics.callback.ContactCallback,xi.defaultGJKMargin=1e-4,t.dynamics.World,t.dynamics.rigidbody.RigidBodyType,t.dynamics.rigidbody.RigidBodyConfig,t.dynamics.rigidbody.RigidBody,t.dynamics.rigidbody.ShapeConfig,t.dynamics.rigidbody.Shape,t.dynamics.constraint.joint.SphericalJointConfig,t.dynamics.constraint.joint.SphericalJoint,t.dynamics.constraint.joint.RevoluteJointConfig,t.dynamics.constraint.joint.RevoluteJoint,t.dynamics.constraint.joint.CylindricalJointConfig,t.dynamics.constraint.joint.CylindricalJoint,t.dynamics.constraint.joint.PrismaticJointConfig,t.dynamics.constraint.joint.PrismaticJoint,t.dynamics.constraint.joint.UniversalJointConfig,t.dynamics.constraint.joint.UniversalJoint,t.dynamics.constraint.joint.RagdollJointConfig,t.dynamics.constraint.joint.RagdollJoint,t.dynamics.constraint.joint.GenericJointConfig,t.dynamics.constraint.joint.GenericJoint,t.dynamics.constraint.joint.Joint,t.common.Vec3,t.common.Quat;const wi=t.common.Setting;t.collision.geometry.BoxGeometry,t.collision.geometry.SphereGeometry,t.collision.geometry.ConeGeometry,t.collision.geometry.CylinderGeometry,t.collision.geometry.CapsuleGeometry,t.collision.geometry.ConvexHullGeometry,t.dynamics.callback.ContactCallback,wi.defaultGJKMargin=1e-4;const{Group:Si,MathUtils:Ci,Matrix4:Ri}=await e("three");export{fi as R,ht as a,xt as b};
