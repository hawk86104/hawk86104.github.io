import{mergeVertices as Y,importShared as g,toCreasedNormals as Z,mergeGeometries as ee}from"./3d-tiles-renderer.DZNovkLO1767148983502.js";import{Fs as te,NA as oe,ol as ne,Kk as ie}from"./index.DTe2qqjO1767148983502.js";import{Pane as se}from"./tweakpane.BQRZXf8M1767148983502.js";import{shaderMaterial as re}from"./shaderMaterial.CBuQXryg1767148983502.js";const{BufferGeometry:ae,Color:ce,Float32BufferAttribute:E,Vector2:le,Vector3:I,Vector4:fe}=await g("three"),$=new I,F=new I;class ue{modify(e,o){e=e.clone(),delete e.morphAttributes.position,delete e.morphAttributes.normal;const i=e.attributes;for(const r in i)r!=="position"&&r!=="uv"&&r!=="normal"&&r!=="tangent"&&r!=="color"&&e.deleteAttribute(r);e=Y(e);const s=[],n=[],u=e.getAttribute("position"),c=e.getAttribute("uv"),d=e.getAttribute("normal"),p=e.getAttribute("tangent"),w=e.getAttribute("color");let h=null,b=null,C=null,M=null;for(let r=0;r<u.count;r++){const a=new I().fromBufferAttribute(u,r);c&&(b=new le().fromBufferAttribute(c,r)),d&&(C=new I().fromBufferAttribute(d,r)),p&&(h=new fe().fromBufferAttribute(p,r)),w&&(M=new ce().fromBufferAttribute(w,r));const x=new be(a,b,C,h,M);s.push(x)}let m=e.getIndex();if(m!==null)for(let r=0;r<m.count;r+=3){const a=m.getX(r),x=m.getX(r+1),P=m.getX(r+2),G=new H(s[a],s[x],s[P],a,x,P);n.push(G)}else for(let r=0;r<u.count;r+=3){const a=r,x=r+1,P=r+2,G=new H(s[a],s[x],s[P],a,x,P);n.push(G)}for(let r=0,a=s.length;r<a;r++)Q(s[r]);let l,f=o;for(;f--;){if(l=ge(s),!l){console.log("THREE.SimplifyModifier: No next vertex");break}de(s,n,l,l.collapseNeighbor)}const N=new ae,S=[],y=[],V=[],A=[],B=[];m=[];for(let r=0;r<s.length;r++){const a=s[r];S.push(a.position.x,a.position.y,a.position.z),a.uv&&y.push(a.uv.x,a.uv.y),a.normal&&V.push(a.normal.x,a.normal.y,a.normal.z),a.tangent&&A.push(a.tangent.x,a.tangent.y,a.tangent.z,a.tangent.w),a.color&&B.push(a.color.r,a.color.g,a.color.b),a.id=r}for(let r=0;r<n.length;r++){const a=n[r];m.push(a.v1.id,a.v2.id,a.v3.id)}return N.setAttribute("position",new E(S,3)),y.length>0&&N.setAttribute("uv",new E(y,2)),V.length>0&&N.setAttribute("normal",new E(V,3)),A.length>0&&N.setAttribute("tangent",new E(A,4)),B.length>0&&N.setAttribute("color",new E(B,3)),N.setIndex(m),N}}function pe(t,e){t.indexOf(e)===-1&&t.push(e)}function k(t,e){const o=t.indexOf(e);o>-1&&t.splice(o,1)}function he(t,e){const o=e.position.distanceTo(t.position);let i=0;const s=[];for(let c=0,d=t.faces.length;c<d;c++){const p=t.faces[c];p.hasVertex(e)&&s.push(p)}for(let c=0,d=t.faces.length;c<d;c++){let p=1;const w=t.faces[c];for(let h=0;h<s.length;h++){const b=s[h],C=w.normal.dot(b.normal);p=Math.min(p,(1.001-C)/2)}i=Math.max(i,p)}const n=0;return s.length<2&&(i=1),o*i+n}function Q(t){if(t.neighbors.length===0){t.collapseNeighbor=null,t.collapseCost=-.01;return}t.collapseCost=1e5,t.collapseNeighbor=null;for(let e=0;e<t.neighbors.length;e++){const o=he(t,t.neighbors[e]);t.collapseNeighbor||(t.collapseNeighbor=t.neighbors[e],t.collapseCost=o,t.minCost=o,t.totalCost=0,t.costCount=0),t.costCount++,t.totalCost+=o,o<t.minCost&&(t.collapseNeighbor=t.neighbors[e],t.minCost=o)}t.collapseCost=t.totalCost/t.costCount}function R(t,e){for(console.assert(t.faces.length===0);t.neighbors.length;){const o=t.neighbors.pop();k(o.neighbors,t)}k(e,t)}function me(t,e){k(e,t),t.v1&&k(t.v1.faces,t),t.v2&&k(t.v2.faces,t),t.v3&&k(t.v3.faces,t);const o=[t.v1,t.v2,t.v3];for(let i=0;i<3;i++){const s=o[i],n=o[(i+1)%3];!s||!n||(s.removeIfNonNeighbor(n),n.removeIfNonNeighbor(s))}}function de(t,e,o,i){if(!i){R(o,t);return}i.uv&&o.uv.copy(i.uv),i.normal&&i.normal.add(o.normal).normalize(),i.tangent&&i.tangent.add(o.tangent).normalize();const s=[];for(let n=0;n<o.neighbors.length;n++)s.push(o.neighbors[n]);for(let n=o.faces.length-1;n>=0;n--)o.faces[n]&&o.faces[n].hasVertex(i)&&me(o.faces[n],e);for(let n=o.faces.length-1;n>=0;n--)o.faces[n].replaceVertex(o,i);R(o,t);for(let n=0;n<s.length;n++)Q(s[n])}function ge(t){let e=t[0];for(let o=0;o<t.length;o++)t[o].collapseCost<e.collapseCost&&(e=t[o]);return e}class H{constructor(e,o,i,s,n,u){this.a=s,this.b=n,this.c=u,this.v1=e,this.v2=o,this.v3=i,this.normal=new I,this.computeNormal(),e.faces.push(this),e.addUniqueNeighbor(o),e.addUniqueNeighbor(i),o.faces.push(this),o.addUniqueNeighbor(e),o.addUniqueNeighbor(i),i.faces.push(this),i.addUniqueNeighbor(e),i.addUniqueNeighbor(o)}computeNormal(){const e=this.v1.position,o=this.v2.position,i=this.v3.position;$.subVectors(i,o),F.subVectors(e,o),$.cross(F).normalize(),this.normal.copy($)}hasVertex(e){return e===this.v1||e===this.v2||e===this.v3}replaceVertex(e,o){e===this.v1?this.v1=o:e===this.v2?this.v2=o:e===this.v3&&(this.v3=o),k(e.faces,this),o.faces.push(this),e.removeIfNonNeighbor(this.v1),this.v1.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v2),this.v2.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v3),this.v3.removeIfNonNeighbor(e),this.v1.addUniqueNeighbor(this.v2),this.v1.addUniqueNeighbor(this.v3),this.v2.addUniqueNeighbor(this.v1),this.v2.addUniqueNeighbor(this.v3),this.v3.addUniqueNeighbor(this.v1),this.v3.addUniqueNeighbor(this.v2),this.computeNormal()}}class be{constructor(e,o,i,s,n){this.position=e,this.uv=o,this.normal=i,this.tangent=s,this.color=n,this.id=-1,this.faces=[],this.neighbors=[],this.collapseCost=0,this.collapseNeighbor=null}addUniqueNeighbor(e){pe(this.neighbors,e)}removeIfNonNeighbor(e){const o=this.neighbors,i=this.faces,s=o.indexOf(e);if(s!==-1){for(let n=0;n<i.length;n++)if(i[n].hasVertex(e))return;o.splice(s,1)}}}const _=await g("three"),Ne=re({screenspace:!1,color:new _.Color("black"),opacity:1,thickness:.05,size:new _.Vector2},`
   #include <common>
   #include <morphtarget_pars_vertex>
   #include <skinning_pars_vertex>
   uniform float thickness;
   uniform float screenspace;
   uniform vec2 size;
   void main() {
     #if defined (USE_SKINNING)
	   #include <beginnormal_vertex>
       #include <morphnormal_vertex>
       #include <skinbase_vertex>
       #include <skinnormal_vertex>
       #include <defaultnormal_vertex>
     #endif
     #include <begin_vertex>
	   #include <morphtarget_vertex>
	   #include <skinning_vertex>
     #include <project_vertex>
     vec4 tNormal = vec4(normal, 0.0);
     vec4 tPosition = vec4(transformed, 1.0);
     #ifdef USE_INSTANCING
       tNormal = instanceMatrix * tNormal;
       tPosition = instanceMatrix * tPosition;
     #endif
     if (screenspace == 0.0) {
       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;
       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); 
     } else {
       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;
       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;
       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;
       clipPosition.xy += offset;
       gl_Position = clipPosition;
     }
   }`,`
   uniform vec3 color;
   uniform float opacity;
   void main(){
     gl_FragColor = vec4(color, opacity);
     #include <tonemapping_fragment>
     #include <${parseInt(_.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>
   }`);function we({color:t=new _.Color("black"),opacity:e=1,transparent:o=!1,screenspace:i=!1,toneMapped:s=!0,polygonOffset:n=!1,polygonOffsetFactor:u=0,renderOrder:c=0,thickness:d=.05,angle:p=Math.PI,gl:w}={}){const h=new _.Group;let b={color:t,opacity:e,transparent:o,screenspace:i,toneMapped:s,polygonOffset:n,polygonOffsetFactor:u,renderOrder:c,thickness:d,angle:p};function C(m){const l=h.parent;if(h.clear(),l&&l.geometry){let f;const N=new Ne({side:_.BackSide});l.skeleton?(f=new _.SkinnedMesh,f.material=N,f.bind(l.skeleton,l.bindMatrix),h.add(f)):l.isInstancedMesh?(f=new _.InstancedMesh(l.geometry,N,l.count),f.instanceMatrix=l.instanceMatrix,h.add(f)):(f=new _.Mesh,f.material=N,h.add(f)),f.geometry=m?Z(l.geometry,m):l.geometry}}function M(m){b={...b,...m};const l=h.children[0];if(l){const{transparent:f,thickness:N,color:S,opacity:y,screenspace:V,toneMapped:A,polygonOffset:B,polygonOffsetFactor:r,renderOrder:a}=b,x=new _.Vector2;!w&&b.screenspace&&console.warn('Outlines: "screenspace" requires a WebGLRenderer instance to calculate the outline size'),w&&w.getSize(x),Object.assign(l.material,{transparent:f,thickness:N,color:S,opacity:y,size:x,screenspace:V,toneMapped:A,polygonOffset:B,polygonOffsetFactor:r}),a!==void 0&&(l.renderOrder=a)}}return{group:h,updateProps(m){var l;const f=(l=m.angle)!==null&&l!==void 0?l:b.angle;f!==b.angle&&C(f),M(m)},generate(){C(b.angle),M(b)}}}const{defineComponent:xe}=await g("vue"),{unref:_e,openBlock:ve,createElementBlock:Ce}=await g("vue"),ke=["object"],D=await g("three"),{onMounted:Me,watchEffect:ye}=await g("vue"),j=xe({__name:"outlineCom",props:{color:{default:"#ffffff"},thickness:{default:.1},screenspace:{type:Boolean,default:!1}},setup(t){const e=t,{renderer:o}=te(),i=we({color:new D.Color(e.color),thickness:e.thickness,screenspace:e.screenspace,gl:o});return Me(()=>{i.generate()}),ye(()=>{i.updateProps({color:new D.Color(e.color),thickness:e.thickness,screenspace:e.screenspace})}),(s,n)=>(ve(),Ce("primitive",{object:_e(i).group},null,8,ke))}}),{defineComponent:Ve}=await g("vue"),{unref:U,createElementVNode:K,createVNode:Ae,openBlock:Be,createElementBlock:Pe,createCommentVNode:Ee}=await g("vue"),Ie=["object"],Se=["geometry"],{watch:ze}=await g("vue"),Te=await g("three"),Ge=Ve({__name:"outlineModel",props:{color:{default:"#ffffff"},thickness:{default:.1},screenspace:{type:Boolean,default:!1}},setup(t){const{state:e}=oe("./plugins/basic/htmls/model/model.gltf",{draco:!0,decoderPath:"./draco/"});function o(n,u=.1){return new ue().modify(n,Math.floor(n.attributes.position.count*u))}function i(n){const u=[];return n.traverse(d=>{if(d.isMesh&&d.geometry.isBufferGeometry&&d.geometry.attributes.position.count<1e5){const p=d.geometry.clone(),w=new Te.Matrix4;w.copy(d.matrixWorld),p.applyMatrix4(w),p.isBufferGeometry&&(Object.keys(p.attributes).forEach(h=>{h!=="position"&&p.deleteAttribute(h)}),u.push(o(p,.1)))}}),ee(u)}let s=null;return ze(()=>e.value,n=>{n.scene&&(s=i(n.scene))}),(n,u)=>U(e)?(Be(),Pe("primitive",{key:0,object:U(e)?.scene,scale:1,position:[3,-1,-3]},[K("TresMesh",{geometry:U(s)},[u[0]||(u[0]=K("TresMeshBasicMaterial",{color:"#000000",transparent:"",opacity:0},null,-1)),Ae(j,{thickness:n.thickness,screenspace:n.screenspace,color:n.color},null,8,["thickness","screenspace","color"])],8,Se)],8,Ie)):Ee("",!0)}}),{defineComponent:$e}=await g("vue"),{createElementVNode:v,unref:L,normalizeProps:q,guardReactiveProps:O,createVNode:z,Suspense:Ue,withCtx:X,openBlock:W,createBlock:J,mergeProps:qe}=await g("vue"),Oe={position:[0,.9,0],name:"torus"},je={position:[-2.5,.5,2.5],"receive-shadow":"","cast-shadow":"",name:"cube"},{ACESFilmicToneMapping:Fe}=await g("three"),{reactive:T}=await g("vue"),Le=$e({__name:"outline",setup(t){const e=T({alpha:!0,toneMapping:Fe,windowSize:!0,clearColor:"#000000"}),o=T({enableDamping:!0,autoRotate:!1}),i=T({color:"#ff00ae",thickness:.1,screenspace:!1}),s=new se;s.addBinding(i,"color",{label:"颜色"}),s.addBinding(i,"thickness",{label:"thickness",min:0,max:2,step:.01}),s.addBinding(i,"screenspace",{label:"space"});const n=T({color:"#ffffff",thickness:.026,screenspace:!1});return s.addBinding(n,"color",{label:"模型边框颜色"}),s.addBinding(n,"thickness",{label:"模型边框粗细",min:0,max:.2,step:.001}),s.addBinding(n,"screenspace",{label:"模型边框类型"}),(u,c)=>(W(),J(L(ne),qe(e,{"window-size":""}),{default:X(()=>[c[4]||(c[4]=v("TresPerspectiveCamera",{position:[10,10,10],fov:45,near:1,far:1e3},null,-1)),z(L(ie),q(O(o)),null,16),c[5]||(c[5]=v("TresAmbientLight",{intensity:.5},null,-1)),c[6]||(c[6]=v("TresDirectionalLight",{position:[15,15,15],intensity:1},null,-1)),v("TresMesh",Oe,[c[0]||(c[0]=v("TresTorusKnotGeometry",{args:[1,.35,100,32]},null,-1)),c[1]||(c[1]=v("TresMeshStandardMaterial",{color:"#ff33ff",roughness:.3,metalness:.5},null,-1)),z(j,q(O(i)),null,16)]),v("TresMesh",je,[c[2]||(c[2]=v("TresCylinderGeometry",{args:[1.5,1.5,2]},null,-1)),c[3]||(c[3]=v("TresMeshStandardMaterial",{color:3407871,roughness:0,metalness:0},null,-1)),z(j)]),(W(),J(Ue,null,{default:X(()=>[z(Ge,q(O(n)),null,16)]),_:1}))]),_:1},16))}});export{Le as default};
