import{i as t}from"./3d-tiles-renderer.CbgZh8zU1767066396612.js";
/**
 * @description Loop Subdivision Surface
 * @about       Smooth subdivision surface modifier for use with three.js BufferGeometry.
 * @author      Stephens Nunnally <@stevinz>
 * @license     MIT - Copyright (c) 2022 Stephens Nunnally
 * @source      https://github.com/stevinz/three-subdivide
 */
const e=await t("three"),r=new e.Vector3,o=new e.Vector3,i=new e.Vector3,n=new e.Vector3,u=new e.Vector3,s=new e.Vector3,c=new e.Vector3,a=new e.Vector3,f=new e.Vector3,d=new e.Vector3,l=new e.Vector3,p=[new e.Vector3,new e.Vector3,new e.Vector3],m=[new e.Vector3,new e.Vector3,new e.Vector3],b=new e.Triangle;class h{static modify(t,e=1,r={}){if(arguments.length>3&&console.warn("LoopSubdivision.modify() now uses a parameter object. See readme for more info!"),"object"!=typeof r&&(r={}),void 0===r.split&&(r.split=!0),void 0===r.uvSmooth&&(r.uvSmooth=!1),void 0===r.preserveEdges&&(r.preserveEdges=!1),void 0===r.flatOnly&&(r.flatOnly=!1),void 0===r.maxTriangles&&(r.maxTriangles=1/0),void 0===r.weight&&(r.weight=1),!isNaN(r.weight)&&isFinite(r.weight)||(r.weight=1),r.weight=Math.max(0,Math.min(1,r.weight)),!V(t))return t;let o=t.clone();if(r.split){const t=h.edgeSplit(o);o.dispose(),o=t}for(let i=0;i<e;i++){if(o.attributes.position.count/3<r.maxTriangles){let t;t=r.flatOnly?h.flat(o,r):h.smooth(o,r),o.groups.forEach(e=>{t.addGroup(4*e.start,4*e.count,e.materialIndex)}),o.dispose(),o=t}}return o}static edgeSplit(t){if(!V(t))return t;const r=null!==t.index?t.toNonIndexed():t.clone(),u=new e.BufferGeometry,f=B(r),d=r.attributes.position.count,l=r.getAttribute("position"),p=r.getAttribute("normal"),m={},h=[],v={},w=[];for(let e=0;e<d;e+=3){s.fromBufferAttribute(l,e+0),c.fromBufferAttribute(l,e+1),a.fromBufferAttribute(l,e+2),n.fromBufferAttribute(p,e);const t=A(s),r=A(c),o=A(a),i=b.set(s,c,a).getArea();if(w.push(!g(i,0)),!w[e/3]){h.push([]);continue}S(n,s,c,a);const u=A(n),f=[`${t}_${r}_${u}`,`${r}_${t}_${u}`,`${r}_${o}_${u}`,`${o}_${r}_${u}`,`${o}_${t}_${u}`,`${t}_${o}_${u}`],d=e/3;for(let e=0;e<f.length;e++)m[f[e]]||(m[f[e]]=[]),m[f[e]].push(d),v[f[e]]||(0!==e&&1!==e||(v[f[e]]=s.distanceTo(c)),2!==e&&3!==e||(v[f[e]]=c.distanceTo(a)),4!==e&&5!==e||(v[f[e]]=a.distanceTo(s)));h.push([f[0],f[2],f[4]])}f.forEach(t=>{const o=r.getAttribute(t);if(!o)return;const i=x(o,t);u.setAttribute(t,new e.BufferAttribute(i,o.itemSize))});const y=r.morphAttributes;for(const o in y){const t=[],r=y[o];for(let i=0,n=r.length;i<n;i++){if(r[i].count!==d)continue;const n=x(r[i],o,!0);t.push(new e.BufferAttribute(n,r[i].itemSize))}u.morphAttributes[o]=t}return u.morphTargetsRelative=r.morphTargetsRelative,r.dispose(),u;function x(t,e,n=!1){const f=d*t.itemSize*4,l=new t.array.constructor(f),p="position"===e&&!n&&r.groups.length>0;let b,g,A=0,y=0,S=t.itemSize;for(let x=0;x<d;x+=3){if(!w[x/3]){y+=3;continue}s.fromBufferAttribute(t,x+0),c.fromBufferAttribute(t,x+1),a.fromBufferAttribute(t,x+2);const e=x/3,n=h[e][0],f=h[e][1],d=h[e][2],B=m[n].length,V=m[f].length,z=m[d].length,T=3*A/S/3;if(0===B+V+z-3)$(l,A,S,s,c,a),A+=3*S;else{const t=v[n],e=v[f],r=v[d];(t>e||V<=1)&&(t>r||z<=1)&&B>1?(o.copy(s).add(c).divideScalar(2),z>1?(i.copy(a).add(s).divideScalar(2),$(l,A,S,s,o,i),A+=3*S,$(l,A,S,o,a,i),A+=3*S):($(l,A,S,s,o,a),A+=3*S),V>1?(i.copy(c).add(a).divideScalar(2),$(l,A,S,o,c,i),A+=3*S,$(l,A,S,i,a,o),A+=3*S):($(l,A,S,c,a,o),A+=3*S)):(e>r||z<=1)&&V>1?(o.copy(c).add(a).divideScalar(2),B>1?(i.copy(s).add(c).divideScalar(2),$(l,A,S,o,i,c),A+=3*S,$(l,A,S,i,o,s),A+=3*S):($(l,A,S,c,o,s),A+=3*S),z>1?(i.copy(a).add(s).divideScalar(2),$(l,A,S,o,a,i),A+=3*S,$(l,A,S,i,s,o),A+=3*S):($(l,A,S,a,s,o),A+=3*S)):z>1?(o.copy(a).add(s).divideScalar(2),V>1?(i.copy(c).add(a).divideScalar(2),$(l,A,S,a,o,i),A+=3*S,$(l,A,S,o,c,i),A+=3*S):($(l,A,S,a,o,c),A+=3*S),B>1?(i.copy(s).add(c).divideScalar(2),$(l,A,S,s,i,o),A+=3*S,$(l,A,S,i,c,o),A+=3*S):($(l,A,S,s,c,o),A+=3*S)):($(l,A,S,s,c,a),A+=3*S)}p&&r.groups.forEach(t=>{t.start===x-y&&(void 0!==b&&void 0!==g&&u.addGroup(b,T-b,g),b=T,g=t.materialIndex)}),y=0}const B=3*A/S,V=new t.array.constructor(B);for(let r=0;r<B;r++)V[r]=l[r];return p&&void 0!==b&&void 0!==g&&u.addGroup(b,3*A/S/3-b,g),V}}static flat(t,r={}){if(!V(t))return t;const o=null!==t.index?t.toNonIndexed():t.clone(),i=new e.BufferGeometry,n=B(o),u=o.attributes.position.count;n.forEach(t=>{const e=o.getAttribute(t);e&&i.setAttribute(t,h.flatAttribute(e,u,r))});const s=o.morphAttributes;for(const e in s){const t=[],o=s[e];for(let e=0,i=o.length;e<i;e++)o[e].count===u&&t.push(h.flatAttribute(o[e],u,r));i.morphAttributes[e]=t}return i.morphTargetsRelative=o.morphTargetsRelative,o.dispose(),i}static flatAttribute(t,r,o={}){const i=r*t.itemSize*4,n=new t.array.constructor(i);let u=0,p=t.itemSize;for(let e=0;e<r;e+=3)s.fromBufferAttribute(t,e+0),c.fromBufferAttribute(t,e+1),a.fromBufferAttribute(t,e+2),f.copy(s).add(c).divideScalar(2),d.copy(c).add(a).divideScalar(2),l.copy(a).add(s).divideScalar(2),$(n,u,p,s,f,l),u+=3*p,$(n,u,p,c,d,f),u+=3*p,$(n,u,p,a,l,d),u+=3*p,$(n,u,p,f,d,l),u+=3*p;return new e.BufferAttribute(n,t.itemSize)}static smooth(t,o={}){if("object"!=typeof o&&(o={}),void 0===o.uvSmooth&&(o.uvSmooth=!1),void 0===o.preserveEdges&&(o.preserveEdges=!1),!V(t))return t;const i=null!==t.index?t.toNonIndexed():t.clone(),n=h.flat(i,o),s=new e.BufferGeometry,c=B(i),a=i.attributes.position.count,b=i.getAttribute("position"),v=n.getAttribute("position"),g={},w={},S={},x={};function z(t,e,r){w[t]||(w[t]={}),w[t][e]||(w[t][e]=[]),w[t][e].push(r)}function T(t,e){S[t]||(S[t]=[]),S[t].push(e)}function E(t,e){x[t]||(x[t]=new Set),x[t].add(e)}for(let e=0;e<a;e+=3){const t=A(m[0].fromBufferAttribute(b,e+0)),r=A(m[1].fromBufferAttribute(b,e+1)),o=A(m[2].fromBufferAttribute(b,e+2));z(t,r,e+1),z(t,o,e+2),z(r,t,e+0),z(r,o,e+2),z(o,t,e+0),z(o,r,e+1),f.copy(m[0]).add(m[1]).divideScalar(2),d.copy(m[1]).add(m[2]).divideScalar(2),l.copy(m[2]).add(m[0]).divideScalar(2);const i=A(f),n=A(d),u=A(l);T(i,e+2),T(n,e+0),T(u,e+1),E(t,i),E(t,u),E(r,i),E(r,n),E(o,n),E(o,u)}for(let e=0;e<n.attributes.position.count;e++){const t=A(u.fromBufferAttribute(v,e));g[t]||(g[t]=[]),g[t].push(e)}c.forEach(t=>{const r=i.getAttribute(t),o=n.getAttribute(t);if(void 0===r||void 0===o)return;const u=G(t,r,o);s.setAttribute(t,new e.BufferAttribute(u,o.itemSize))});const _=i.morphAttributes;for(const r in _){const t=[],i=_[r];for(let n=0,u=i.length;n<u;n++){if(i[n].count!==a)continue;const u=i[n],s=h.flatAttribute(i[n],i[n].count,o),c=G(r,u,s);t.push(new e.BufferAttribute(c,s.itemSize))}s.morphAttributes[r]=t}return s.morphTargetsRelative=i.morphTargetsRelative,n.dispose(),i.dispose(),s;function G(t,e,i){const s=n.attributes.position.count*i.itemSize,c=new e.array.constructor(s);let a=0;for(let f=0;f<n.attributes.position.count;f+=3){for(let n=0;n<3;n++)if("uv"!==t||o.uvSmooth)if("normal"===t){p[n].fromBufferAttribute(v,f+n);const t=A(p[n]),e=g[t],o=Object.keys(e).length,u=.75/o,s=1-u*o;m[n].fromBufferAttribute(i,f+n),m[n].multiplyScalar(s),e.forEach(t=>{r.fromBufferAttribute(i,t),r.multiplyScalar(u),m[n].add(r)})}else{m[n].fromBufferAttribute(i,f+n),p[n].fromBufferAttribute(v,f+n);const t=A(p[n]),s=w[t],c=S[t];if(s){if(o.preserveEdges){const e=x[t];let r=!0;for(const t of e)S[t].length%2!=0&&(r=!1);if(!r)continue}const i=Object.keys(s).length,c=y(1/i/i,1/i*(5/8-Math.pow(3/8+1/4*Math.cos(2*Math.PI/i),2)),o.weight),a=1-c*i;m[n].multiplyScalar(a);for(let t in s){const o=s[t];r.set(0,0,0);for(let t=0;t<o.length;t++)r.add(u.fromBufferAttribute(e,o[t]));r.divideScalar(o.length),r.multiplyScalar(c),m[n].add(r)}}else if(c&&2===c.length){const t=c.length,o=.125,i=1-o*t;m[n].multiplyScalar(i),c.forEach(t=>{r.fromBufferAttribute(e,t),r.multiplyScalar(o),m[n].add(r)})}}else m[n].fromBufferAttribute(i,f+n);$(c,a,i.itemSize,m[0],m[1],m[2]),a+=3*i.itemSize}return c}}}const v=Math.pow(10,2);function g(t,e,r=1e-5){return t<e+r&&t>e-r}function w(t,e=v){let r=(o=t*e)+(o>0?.5:-.5)|0;var o;return 0==r&&(r=0),`${r}`}function A(t,e=v){return`${w(t.x,e)},${w(t.y,e)},${w(t.z,e)}`}function y(t,e,r){return(1-r)*t+r*e}function S(t,e,r,o){u.subVectors(e,r),t.subVectors(r,o),t.cross(u).normalize()}function B(t){const e=Object.keys(t.attributes);return Array.from(new Set(["position","normal","uv"].concat(e)))}function $(t,e,r,o,i,n){r>=1&&(t[e+0+0*r]=o.x,t[e+0+1*r]=i.x,t[e+0+2*r]=n.x),r>=2&&(t[e+1+0*r]=o.y,t[e+1+1*r]=i.y,t[e+1+2*r]=n.y),r>=3&&(t[e+2+0*r]=o.z,t[e+2+1*r]=i.z,t[e+2+2*r]=n.z),r>=4&&(t[e+3+0*r]=o.w,t[e+3+1*r]=i.w,t[e+3+2*r]=n.w)}function V(t){return void 0===t?(console.warn("LoopSubdivision: Geometry provided is undefined"),!1):t.isBufferGeometry?void 0===t.attributes.position?(console.warn("LoopSubdivision: Geometry provided missing required 'position' attribute"),!1):(void 0===t.attributes.normal&&t.computeVertexNormals(),!0):(console.warn("LoopSubdivision: Geometry provided is not 'BufferGeometry' type"),!1)}export{h as L};
