import{m as n,e,b as t,U as r,c as o}from"./@tresjs.FlKhQDQ71735866388381.js";import{P as i}from"./tweakpane.yHWGBmom1735866388381.js";import{_ as c,W as a,p as l,aA as s,s as u,k as f,t as p}from"./three.Rja0AEnA1735866388381.js";import{d as v,a4 as g,b as d,o as x,f as h,u as m,g as y,j as w,al as b,r as C,J as R,aj as I,ak as _}from"./@vue.yG49nQHr1735866388381.js";import"./@vueuse.YI3Exu6_1735866388381.js";var M="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const z=D;function D(n,e){const t=L();return(D=function(n,e){return t[n-=409]})(n,e)}!function(n,e){const t=D,r=L();for(;;)try{if(508721===-parseInt(t(438))/1*(-parseInt(t(446))/2)+-parseInt(t(449))/3*(parseInt(t(442))/4)+parseInt(t(415))/5*(parseInt(t(414))/6)+-parseInt(t(454))/7+parseInt(t(435))/8+parseInt(t(417))/9*(-parseInt(t(456))/10)+parseInt(t(425))/11*(-parseInt(t(440))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[D(444)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){T(this,(function(){const n=D,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(411),"i"),r=j("init");e[n(460)](r+n(434))&&t[n(460)](r+n(445))?j():r("0")}))()}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[D(444)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function L(){const n=["7843272XlYeoD","counter","constructor","49681ZKLDCK","BufferAttribute","9981672uYJGbU","water","146936BdYnBA","stateObject","apply","input","34RbxhnD","warn","toString","36lwKKDx","log","console","pool","error","6080025CEBaZZ","trace","1108570BrGWQp","RawShaderMaterial","setIndex","__proto__","test","bind","FrontSide","length","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","uniforms","Mesh","170142ZVujqK","165nrBytl","render","9pZpukr","causticTex","table","light","exception","value","debu","setAttribute","11DRDcza","tiles","causticsTexture","gger","BufferGeometry",'{}.constructor("return this")( )',"call","action","prototype","chain"];return(L=function(){return n})()}A(void 0,(function(){const n=D,e=function(){const n=D;let e;try{e=Function("return (function() "+n(430)+");")()}catch(t){e=window}return e}(),t=e[n(451)]=e[n(451)]||{},r=[n(450),n(447),"info",n(453),n(421),n(419),n(455)];for(let o=0;o<r[n(410)];o++){const e=A[n(437)][n(433)][n(461)](A),i=r[o],c=t[i]||e;e[n(459)]=A[n(461)](A),e[n(448)]=c[n(448)][n(461)](c),t[i]=e}}))();const O=v({__name:z(452),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=z,o=t,i=new(c[r(429)]),a=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),l=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(424)]("position",new(c[r(439)])(a,3)),i[r(458)](new(c[r(439)])(l,1));const s=new(c[r(457)])({uniforms:{light:{value:o[r(420)]},tiles:{value:o[r(426)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(409)]}),u=new(c[r(413)])(i,s),{renderer:f,camera:p}=n(),{onAfterLoop:v}=e();return v((()=>{const n=r;((n,e)=>{const t=r;s[t(412)][t(441)][t(422)]=n,s[t(412)][t(418)][t(422)]=e,f.value[t(416)](u,p[t(422)])})(o.waterTexture,o[n(427)])})),(n,e)=>null}});function j(n){function e(n){const t=D;if("string"==typeof n)return function(n){}[t(437)]("while (true) {}")[t(444)](t(436));1!==(""+n/n)[t(410)]||n%20==0?function(){return!0}[t(437)](t(423)+t(428))[t(431)](t(432)):function(){return!1}[t(437)](t(423)+t(428)).apply(t(443)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const E=W;!function(n,e){const t=W,r=P();for(;;)try{if(240105===-parseInt(t(531))/1*(parseInt(t(525))/2)+parseInt(t(514))/3*(parseInt(t(496))/4)+-parseInt(t(501))/5+parseInt(t(551))/6*(-parseInt(t(539))/7)+-parseInt(t(555))/8+-parseInt(t(515))/9*(parseInt(t(535))/10)+parseInt(t(510))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[W(554)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){F(this,(function(){const n=W,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(498),"i"),r=k("init");e[n(541)](r+"chain")&&t[n(541)](r+n(519))?k():r("0")}))()}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[W(554)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function W(n,e){const t=P();return(W=function(n,e){return t[n-=493]})(n,e)}function P(){const n=["\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","Mesh","uniforms","1323765DUSakb","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","length","setClearColor","pos-y.jpg","return (function() ","underwater","CubeTextureLoader","pos-x.jpg","20873699CSDsJt","side","trace","render","3LUkZwR","376128GMVocE","call","warn","stateObject","input","toString","RawShaderMaterial","log","white","Color","490ndxaJr","water","causticsTexture","neg-x.jpg","error","constructor","1586joZpfs","action","exception","__proto__","70xFybhd","table","bind","waterTexture","961121wqsNtc","FrontSide","test","setPath","causticTex","light","tiles","counter",'{}.constructor("return this")( )',"setRenderTarget","clear","debu","12QljCGP","info","load","apply","3757424OBJRvp","BackSide","value","pooRef","130588qngBvT","console"];return(P=function(){return n})()}S(void 0,(function(){const n=W;let e;try{e=Function(n(506)+n(547)+");")()}catch(o){e=window}const t=e[n(497)]=e[n(497)]||{},r=[n(522),n(517),n(552),n(529),n(533),n(536),n(512)];for(let i=0;i<r.length;i++){const e=S[n(530)].prototype[n(537)](S),o=r[i],c=t[o]||e;e[n(534)]=S[n(537)](S),e[n(520)]=c.toString[n(537)](c),t[o]=e}}))();const Z=v({__name:E(526),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=E;let i,a;const l=r,s=l.geometry,u=(new(c[o(508)]))[o(542)](o(502))[o(553)]([o(509),o(528),o(505),"neg-y.jpg","pos-z.jpg","neg-z.jpg"]),f=([i,a]=g((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),p=new(c[o(521)])({uniforms:{light:{value:l.light},tiles:{value:f},sky:{value:u},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),v=new(c[o(499)])(s,p),y=d(null),w=new(c[o(524)])(o(523)),{renderer:b,camera:C}=n(),{onLoop:R}=e();return R((()=>{const n=o;b[n(494)][n(548)](null),b.value[n(504)](w,1),b.value[n(549)](),p[n(500)][n(526)].value=l[n(538)],p[n(500)][n(543)].value=l[n(527)],p[n(511)]=c[n(540)],p.uniforms[n(507)][n(494)]=!0,b[n(494)][n(513)](v,C.value),p[n(511)]=c[n(493)],p[n(500)][n(507)].value=!1,b[n(494)][n(513)](v,C[n(494)])})),(n,e)=>{const t=o;return x(),h(O,{tiles:m(f),light:n[t(544)],waterTexture:n[t(538)],causticsTexture:n[t(527)],ref_key:t(495),ref:y},null,8,[t(545),"light",t(538),t(527)])}}});function k(n){function e(n){const t=W;if("string"==typeof n)return function(n){}[t(530)]("while (true) {}").apply(t(546));1!==(""+n/n)[t(503)]||n%20==0?function(){return!0}.constructor(t(550)+"gger")[t(516)](t(532)):function(){return!1}[t(530)](t(550)+"gger")[t(554)](t(518)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function V(n,e){const t=J();return(V=function(n,e){return t[n-=167]})(n,e)}const B=V;!function(n,e){const t=V,r=J();for(;;)try{if(433028===parseInt(t(181))/1*(parseInt(t(192))/2)+-parseInt(t(198))/3+-parseInt(t(208))/4+parseInt(t(182))/5+parseInt(t(203))/6+parseInt(t(187))/7+parseInt(t(194))/8)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const H=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[V(174)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){H(this,(function(){const n=V,e=new RegExp(n(183)),t=new RegExp(n(178),"i"),r=q(n(199));e[n(191)](r+"chain")&&t[n(191)](r+n(168))?q():r("0")}))()}();const N=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[V(174)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function J(){const n=["1709220RbwBdz","function *\\( *\\)","toString","console","length","623707wNqaws","texture","action","gger","test","530VrnrON","Mesh","5666568ZEmdgO","causticsTexture","exception","waterTexture","2512782Znchef","init","Color","render","setClearColor","992040UJnhXl","warn","value","stateObject","prototype","2360876ovaKap","counter","call","while (true) {}","OrthographicCamera","setRenderTarget","water","caustics","constructor","ShaderMaterial","uniforms","input","bind","__proto__","trace","table","light","apply","return (function() ","material","debu","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","PlaneGeometry","geometry","2099AIqoEb"];return(J=function(){return n})()}N(void 0,(function(){const n=V;let e;try{e=Function(n(175)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(185)]=e.console||{},r=["log",n(204),"info","error",n(196),n(172),n(171)];for(let i=0;i<r[n(186)];i++){const e=N.constructor[n(207)][n(169)](N),o=r[i],c=t[o]||e;e[n(170)]=N.bind(N),e[n(184)]=c.toString[n(169)](c),t[o]=e}}))();const G=v({__name:B(215),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=B,o=t,i=new(c[r(212)])(0,1,1,0,0,2e3),l=new(c[r(179)])(2,2,200,200),s=new a(1024,1024),u=new(c[r(217)])({uniforms:{light:{value:o[r(173)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),f=new(c[r(193)])(l,u),p=new(c[r(200)])("black"),{renderer:v}=n(),{onBeforeLoop:g}=e();return g((()=>{const n=r;f[n(176)][n(167)][n(214)][n(205)]=o[n(197)],v[n(205)][n(213)](s),v.value[n(202)](p,0),v[n(205)].clear(),v[n(205)][n(201)](f,i)})),(n,e)=>{const t=r;return x(),h(b,null,{default:y((()=>[w(Z,{waterTexture:n[t(197)],causticsTexture:m(s)[t(188)],light:n.light,geometry:m(l)},null,8,[t(197),t(195),"light",t(180)])])),_:1})}}});function q(n){function e(n){const t=V;if("string"==typeof n)return function(n){}[t(216)](t(211))[t(174)](t(209));1!==(""+n/n)[t(186)]||n%20==0?function(){return!0}.constructor("debu"+t(190))[t(210)](t(189)):function(){return!1}.constructor(t(177)+t(190))[t(174)](t(206)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const $=U;function U(n,e){const t=Q();return(U=function(n,e){return t[n-=319]})(n,e)}!function(n,e){const t=U,r=Q();for(;;)try{if(736413===-parseInt(t(366))/1*(parseInt(t(357))/2)+-parseInt(t(378))/3+parseInt(t(356))/4*(parseInt(t(351))/5)+-parseInt(t(338))/6*(parseInt(t(380))/7)+-parseInt(t(349))/8+parseInt(t(377))/9+parseInt(t(373))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){K(this,(function(){const n=U,e=new RegExp(n(352)),t=new RegExp(n(343),"i"),r=nn(n(326));e[n(375)](r+n(329))&&t.test(r+n(327))?nn():r("0")}))()}();const Y=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[U(321)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Q(){const n=["7660053SpWZme","3632220kbsaJT","PlaneGeometry","84763pKtiVy","material",'{}.constructor("return this")( )',"OrthographicCamera","return (function() ","setRenderTarget","strength","FloatType","console","domElement","constructor","clientX","clientY","apply","gger","prototype","counter","radius","init","input","uniforms","chain","center","WebGLRenderTarget","height","Mesh","lightFrontGeometry","info","length","mousemove","414QHvqAO","render","setZ","stateObject","getBoundingClientRect","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","waterSimulation","toString","action","table","exception","8935928aPtUfu","trace","5447915TjrvIp","function *\\( *\\)","left","log","light","4mHasoJ","786TnBHwB","needsUpdate","texture","getY","setY","autoClear","intersectObject","string","attributes","3518ziJbqv","waterTexture","RawShaderMaterial","bind","warn","value","while (true) {}","33415390yVzdtm","setFromCamera","test","debu"];return(Q=function(){return n})()}Y(void 0,(function(){const n=U,e=function(){const n=U;let e;try{e=Function(n(384)+n(382)+");")()}catch(t){e=window}return e}(),t=e[n(388)]=e.console||{},r=[n(354),n(370),n(335),"error",n(348),n(347),n(350)];for(let o=0;o<r[n(336)];o++){const e=Y[n(390)][n(323)].bind(Y),i=r[o],c=t[i]||e;e.__proto__=Y.bind(Y),e[n(345)]=c[n(345)][n(369)](c),t[i]=e}}))();const X=v({__name:$(344),props:{light:{}},setup(t,{expose:r}){const o=$,i=new(c[o(383)])(0,1,1,0,0,2e3),a=new(c[o(379)])(2,2),v=new(c[o(331)])(256,256,{type:l}),g=new(c[o(331)])(256,256,{type:c[o(387)]}),d=new(c[o(368)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),y=new s({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),w=new(c[o(368)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),b=new u(a,d),C=new(c[o(333)])(a,y),R=new(c[o(333)])(a,w);let I=v;const _=(n,e)=>{const t=o,r=I,c=I===v?g:v;e[t(381)][t(328)][t(359)][t(371)]=r[t(359)],n[t(385)](c),n[t(339)](e,i),I=c},{renderer:z,camera:D,raycaster:T}=n();z[o(371)][o(362)]=!1;const{onBeforeLoop:A}=e();A((()=>{const n=o;var e,t;t=z[n(371)],_(t,R),e=z[n(371)],_(e,C)}));const L=(n,e,t,r)=>{const i=o;b[i(381)][i(328)][i(330)][i(371)]=[n,e],b[i(381)].uniforms[i(325)][i(371)]=t,b[i(381)][i(328)][i(386)][i(371)]=r,_(z[i(371)],b)},O=new f,j=new p(2,2),E=j[o(365)].position;for(let n=0;n<E.count;n++){const e=-E[o(360)](n);E[o(361)](n,0),E[o(340)](n,e)}E[o(358)]=!0;const F=new(c[o(333)])(j),S={handleEvent:n=>{const e=o,t=z[e(371)].domElement[e(342)](),r=t.width,i=t[e(332)];O.x=2*(n[e(319)]-t[e(353)])/r-1,O.y=2*-(n[e(320)]-t.top)/i+1,T.value[e(374)](O,D[e(371)]);const c=T[e(371)][e(363)](F);for(let o of c)L(o.point.x,o.point.z,.03,.04)}};return r({addDrop:L,mouseEvent:n=>{const e=o;n?z[e(371)][e(389)].addEventListener("mousemove",S):z[e(371)][e(389)].removeEventListener(e(337),S)}}),(n,e)=>{const t=o;return x(),h(G,{lightFrontGeometry:m(a),waterTexture:m(I)[t(359)],light:n[t(355)]},null,8,[t(334),t(367),t(355)])}}});function nn(n){function e(n){const t=U;if(typeof n===t(364))return function(n){}[t(390)](t(372))[t(321)](t(324));1!==(""+n/n).length||n%20==0?function(){return!0}[t(390)](t(376)+t(322)).call(t(346)):function(){return!1}[t(390)]("debu"+t(322))[t(321)](t(341)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=tn,r=on();for(;;)try{if(272105===-parseInt(t(427))/1+parseInt(t(451))/2*(-parseInt(t(424))/3)+parseInt(t(429))/4+-parseInt(t(440))/5*(-parseInt(t(450))/6)+-parseInt(t(423))/7*(parseInt(t(425))/8)+parseInt(t(417))/9*(parseInt(t(418))/10)+parseInt(t(456))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(446)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function tn(n,e){const t=on();return(tn=function(n,e){return t[n-=414]})(n,e)}!function(){en(this,(function(){const n=tn,e=new RegExp(n(449)),t=new RegExp(n(416),"i"),r=an("init");e[n(455)](r+"chain")&&t[n(455)](r+n(448))?an():r("0")}))()}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(446)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function on(){const n=["49164sydArT","42uXbMLm","exception","change","toString","test","2613215JMJCdu","随机增加波纹","value","gger","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","3069gZLnua","11430atdZPQ","call","waterSimulationRef",'{}.constructor("return this")( )',"点击按钮","2997533utgJpF","24987bzWsEB","8gAjeiZ","console","96454WvEKsu","constructor","853020MgMCyk","mouseEvent","counter","string","log","addDrop","bind","鼠标波纹","random","__proto__","warn","80YiajZU","error","action","debu","stateObject","TresPerspectiveCamera","apply","length","input","function *\\( *\\)"];return(on=function(){return n})()}rn(void 0,(function(){const n=tn,e=function(){const n=tn;let e;try{e=Function("return (function() "+n(421)+");")()}catch(t){e=window}return e}(),t=e[n(426)]=e[n(426)]||{},r=[n(433),n(439),"info",n(441),n(452),"table","trace"];for(let o=0;o<r[n(447)];o++){const e=rn.constructor.prototype[n(435)](rn),i=r[o],c=t[i]||e;e[n(438)]=rn[n(435)](rn),e[n(454)]=c[n(454)][n(435)](c),t[i]=e}}))();const cn=v({__name:"realWater",setup(n){const e=tn,t=C({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:"manual"}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=d(null),l=new i;l.addButton({label:e(422),title:e(457)}).on("click",(()=>{const n=e;for(var t=0;t<10;t++)a[n(414)][n(434)](2*Math[n(437)]()-1,2*Math[n(437)]()-1,.03,1&t?.02:-.02)}));const s=d(!1);return l.addBinding(s,e(414),{label:e(436)}).on(e(453),(n=>{const t=e;a[t(414)][t(430)](n[t(414)])})),(n,i)=>{const l=e;return x(),h(m(o),I(_(t)),{default:y((()=>[i[0]||(i[0]=R(l(445),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),w(m(r)),w(X,{light:c,ref_key:l(420),ref:a},null,512)])),_:1},16)}}});function an(n){function e(n){const t=tn;if(typeof n===t(432))return function(n){}[t(428)]("while (true) {}")[t(446)](t(431));1!==(""+n/n).length||n%20==0?function(){return!0}[t(428)](t(443)+t(415))[t(419)](t(442)):function(){return!1}[t(428)](t(443)+t(415)).apply(t(444)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{cn as default};
