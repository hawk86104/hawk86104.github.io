import{m as n,e,a as t,o as r,f as o}from"./@tresjs.4XV_x0mI1739442316051.js";import{P as i}from"./tweakpane.yDiyAAkA1739442316051.js";import{_ as c,c as a,aW as l,r as s,W as u,o as f}from"./three.OosFxi571739442316051.js";import{d as p,a3 as v,b as g,o as d,f as x,u as h,g as m,j as y,al as w,r as b,N as I,aj as R,ak as C}from"./@vue.NRI7TcgI1739442316051.js";import"./@vueuse.u4XqlOuT1739442316051.js";var _="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";!function(n,e){const t=A,r=D();for(;;)try{if(454153===parseInt(t(312))/1+-parseInt(t(310))/2+-parseInt(t(309))/3+parseInt(t(347))/4*(parseInt(t(300))/5)+-parseInt(t(336))/6*(-parseInt(t(317))/7)+-parseInt(t(321))/8*(parseInt(t(323))/9)+parseInt(t(304))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const M=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[A(322)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){M(this,(function(){const n=A,e=new RegExp(n(337)),t=new RegExp(n(344),"i"),r=T(n(320));e[n(313)](r+n(302))&&t[n(313)](r+n(349))?T():r("0")}))()}();const z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function D(){const n=["info","prototype","console","trace","position","causticsTexture","toString","error","causticTex","exception","312690cqEPei","function *\\( *\\)","constructor","while (true) {}","BufferGeometry","RawShaderMaterial","FrontSide","debu","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","table","setAttribute","100412qhCXOk","waterTexture","input","70HrFpxS","return (function() ","chain","warn","1375130zVlIYp","light","uniforms","call","log","267555VZOPSK","317802gQMRqq","length","306284umkLYd","test","render","value","string","35lfzmgg",'{}.constructor("return this")( )',"bind","init","40qQfDbm","apply","636435MiWlIv","gger","Mesh"];return(D=function(){return n})()}function A(n,e){const t=D();return(A=function(n,e){return t[n-=300]})(n,e)}z(void 0,(function(){const n=A;let e;try{e=Function(n(301)+n(318)+");")()}catch(o){e=window}const t=e[n(328)]=e[n(328)]||{},r=[n(308),n(303),n(326),n(333),n(335),n(345),n(329)];for(let i=0;i<r[n(311)];i++){const e=z[n(338)][n(327)][n(319)](z),o=r[i],c=t[o]||e;e.__proto__=z[n(319)](z),e.toString=c[n(332)][n(319)](c),t[o]=e}}))();const L=p({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=A,o=t,i=new(c[r(340)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(346)](r(330),new a(l,3)),i.setIndex(new a(s,1));const u=new(c[r(341)])({uniforms:{light:{value:o[r(305)]},tiles:{value:o.tiles},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(342)]}),f=new(c[r(325)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{const n=r;((n,e)=>{const t=r;u.uniforms.water[t(315)]=n,u[t(306)][t(334)][t(315)]=e,p.value[t(314)](f,v.value)})(o[n(348)],o[n(331)])})),(n,e)=>null}});function T(n){function e(n){const t=A;if(typeof n===t(316))return function(n){}[t(338)](t(339))[t(322)]("counter");1!==(""+n/n)[t(311)]||n%20==0?function(){return!0}[t(338)](t(343)+t(324))[t(307)]("action"):function(){return!1}.constructor(t(343)+t(324))[t(322)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=S,r=E();for(;;)try{if(699014===parseInt(t(378))/1*(-parseInt(t(345))/2)+-parseInt(t(362))/3*(parseInt(t(393))/4)+parseInt(t(347))/5*(-parseInt(t(363))/6)+-parseInt(t(374))/7+-parseInt(t(401))/8+-parseInt(t(359))/9*(parseInt(t(371))/10)+-parseInt(t(383))/11*(-parseInt(t(360))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const O=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[S(372)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function E(){const n=["counter","info","causticTex","geometry","pos-y.jpg","pooRef","load","5808736gnqHee","call","setClearColor","stateObject","toString",'{}.constructor("return this")( )',"CubeTextureLoader","450338zbixGy","underwater","6535ZERJjN","waterTexture","log","setRenderTarget","trace","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","causticsTexture","function *\\( *\\)","water","side","input","FrontSide","9182745XvmOrh","12SWdPxg","constructor","783777fVGwQx","2796WAdiQu","console","pos-x.jpg","white","BackSide","prototype","Color","neg-x.jpg","10NqLKAd","apply","length","8977059EGdmEO","value","warn","bind","1MnJQZJ","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","debu","light","gger","64552114NZXpsg","exception","return (function() ","__proto__","init","string","render","uniforms","while (true) {}","test","20NUDKMy"];return(E=function(){return n})()}!function(){O(this,(function(){const n=S,e=new RegExp(n(354)),t=new RegExp(n(352),"i"),r=W(n(387));e[n(392)](r+"chain")&&t[n(392)](r+n(357))?W():r("0")}))()}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[S(372)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function S(n,e){const t=E();return(S=function(n,e){return t[n-=339]})(n,e)}F(void 0,(function(){const n=S,e=function(){const n=S;let e;try{e=Function(n(385)+n(343)+");")()}catch(t){e=window}return e}(),t=e[n(364)]=e[n(364)]||{},r=[n(349),n(376),n(395),"error",n(384),"table",n(351)];for(let o=0;o<r[n(373)];o++){const e=F[n(361)][n(368)][n(377)](F),i=r[o],c=t[i]||e;e[n(386)]=F[n(377)](F),e[n(342)]=c[n(342)][n(377)](c),t[i]=e}}))();const j=p({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=S;let i,a;const u=r,f=u[o(397)],p=(new(c[o(344)])).setPath(o(379))[o(400)]([o(365),o(370),o(398),"neg-y.jpg","pos-z.jpg","neg-z.jpg"]),m=([i,a]=v((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),y=new l({uniforms:{light:{value:u.light},tiles:{value:m},sky:{value:p},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),w=new s(f,y),b=g(null),I=new(c[o(369)])(o(366)),{renderer:R,camera:C}=n(),{onLoop:_}=e();return _((()=>{const n=o;R[n(375)][n(350)](null),R[n(375)][n(340)](I,1),R[n(375)].clear(),y[n(390)][n(355)][n(375)]=u[n(348)],y[n(390)][n(396)][n(375)]=u[n(353)],y[n(356)]=c[n(358)],y[n(390)][n(346)][n(375)]=!0,R[n(375)][n(389)](w,C[n(375)]),y.side=c[n(367)],y[n(390)].underwater[n(375)]=!1,R[n(375)][n(389)](w,C[n(375)])})),(n,e)=>{const t=o;return d(),x(L,{tiles:h(m),light:n[t(381)],waterTexture:n[t(348)],causticsTexture:n[t(353)],ref_key:t(399),ref:b},null,8,["tiles",t(381),t(348),t(353)])}}});function W(n){function e(n){const t=S;if(typeof n===t(388))return function(n){}[t(361)](t(391))[t(372)](t(394));1!==(""+n/n).length||n%20==0?function(){return!0}[t(361)]("debu"+t(382))[t(339)]("action"):function(){return!1}[t(361)](t(380)+t(382))[t(372)](t(341)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const P=H;!function(n,e){const t=H,r=V();for(;;)try{if(846006===parseInt(t(490))/1+-parseInt(t(529))/2*(-parseInt(t(496))/3)+parseInt(t(506))/4*(parseInt(t(515))/5)+-parseInt(t(493))/6*(-parseInt(t(524))/7)+-parseInt(t(492))/8+parseInt(t(531))/9*(parseInt(t(522))/10)+-parseInt(t(527))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const k=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[H(501)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function V(){const n=["counter","stateObject","constructor","black","input","error","Color","debu","825383kOKQYk","OrthographicCamera","8618840nPlvlU","3757752UIvHmE","setClearColor","texture","30uvWhck","length","console","test","geometry","apply","light","caustics","WebGLRenderTarget","uniforms","4erZlZF","waterTexture","PlaneGeometry","string",'{}.constructor("return this")( )',"while (true) {}","causticsTexture","init","call","3799545fDkbOz","clear","return (function() ","water","ShaderMaterial","trace","setRenderTarget","10hlgROj","exception","7BfFIYf","table","warn","13363966AJtsFM","function *\\( *\\)","75042RXaShW","info","4963257wEXYnh","bind","toString","value"];return(V=function(){return n})()}!function(){k(this,(function(){const n=H,e=new RegExp(n(528)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=G(n(513));e[n(499)](r+"chain")&&t.test(r+n(539))?G():r("0")}))()}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function H(n,e){const t=V();return(H=function(n,e){return t[n-=488]})(n,e)}Z(void 0,(function(){const n=H,e=function(){const n=H;let e;try{e=Function(n(517)+n(510)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(498)]||{},r=["log",n(526),n(530),n(540),n(523),n(525),n(520)];for(let o=0;o<r[n(497)];o++){const e=Z[n(537)].prototype[n(532)](Z),i=r[o],c=t[i]||e;e.__proto__=Z[n(532)](Z),e.toString=c[n(533)][n(532)](c),t[i]=e}}))();const N=p({__name:P(503),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=P,o=t,i=new(c[r(491)])(0,1,1,0,0,2e3),a=new(c[r(508)])(2,2,200,200),l=new(c[r(504)])(1024,1024),u=new(c[r(519)])({uniforms:{light:{value:o[r(502)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),f=new s(a,u),p=new(c[r(488)])(r(538)),{renderer:v}=n(),{onBeforeLoop:g}=e();return g((()=>{const n=r;f.material[n(505)][n(518)][n(534)]=o[n(507)],v[n(534)][n(521)](l),v.value[n(494)](p,0),v[n(534)][n(516)](),v.value.render(f,i)})),(n,e)=>{const t=r;return d(),x(w,null,{default:m((()=>[y(j,{waterTexture:n[t(507)],causticsTexture:h(l)[t(495)],light:n[t(502)],geometry:h(a)},null,8,[t(507),t(512),t(502),t(500)])])),_:1})}}});function G(n){function e(n){const t=H;if(typeof n===t(509))return function(n){}.constructor(t(511))[t(501)](t(535));1!==(""+n/n)[t(497)]||n%20==0?function(){return!0}[t(537)](t(489)+"gger")[t(514)]("action"):function(){return!1}.constructor(t(489)+"gger")[t(501)](t(536)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const q=K;!function(n,e){const t=K,r=$();for(;;)try{if(216012===-parseInt(t(357))/1*(parseInt(t(361))/2)+parseInt(t(393))/3*(-parseInt(t(348))/4)+parseInt(t(337))/5*(parseInt(t(371))/6)+parseInt(t(329))/7+parseInt(t(340))/8+-parseInt(t(376))/9*(parseInt(t(326))/10)+parseInt(t(380))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[K(353)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){B(this,(function(){const n=K,e=new RegExp(n(349)),t=new RegExp(n(366),"i"),r=U(n(385));e[n(347)](r+n(331))&&t.test(r+"input")?U():r("0")}))()}();const Y=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[K(353)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function $(){const n=["return (function() ","domElement","10hNinBq","prototype","needsUpdate","310992rLjIpr","toString",'{}.constructor("return this")( )',"top","getY","count","PlaneGeometry","test","428644KVtgoG","function *\\( *\\)","Vector2","light","texture","apply","addEventListener","__proto__","material","1VYvaRe","trace","info","length","26846rmuQDM","console","WebGLRenderTarget","setFromCamera","OrthographicCamera","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","counter","constructor","waterSimulation","setZ","602682qVzdte","value","Mesh","error","attributes","9uBJPll","center","height","string","2748295KxZHzA","setRenderTarget","debu","clientX","gger","init","intersectObject","mousemove","FloatType","point","lightFrontGeometry","clientY","render","9fCZJRM","log","waterTexture","stateObject","bind","while (true) {}","table","875660GwUqQN","uniforms","removeEventListener","1042097fytPbq","warn","chain","left","exception","RawShaderMaterial"];return($=function(){return n})()}function K(n,e){const t=$();return(K=function(n,e){return t[n-=322]})(n,e)}Y(void 0,(function(){const n=K;let e;try{e=Function(n(335)+n(342)+");")()}catch(o){e=window}const t=e.console=e[n(362)]||{},r=[n(394),n(330),n(359),n(374),n(333),n(325),n(358)];for(let i=0;i<r[n(360)];i++){const e=Y[n(368)][n(338)][n(323)](Y),o=r[i],c=t[o]||e;e[n(355)]=Y[n(323)](Y),e[n(341)]=c[n(341)].bind(c),t[o]=e}}))();const Q=p({__name:q(369),props:{light:{}},setup(t,{expose:r}){const o=q,i=new(c[o(365)])(0,1,1,0,0,2e3),a=new(c[o(346)])(2,2),l=new u(256,256,{type:c[o(388)]}),p=new(c[o(363)])(256,256,{type:f}),v=new(c[o(334)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),g=new(c[o(334)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),m=new(c[o(334)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),y=new(c[o(373)])(a,v),w=new(c[o(373)])(a,g),b=new(c[o(373)])(a,m);let I=l;const R=(n,e)=>{const t=o,r=I,c=I===l?p:l;e[t(356)][t(327)].texture.value=r[t(352)],n[t(381)](c),n[t(392)](e,i),I=c},{renderer:C,camera:M,raycaster:z}=n();C[o(372)].autoClear=!1;const{onBeforeLoop:D}=e();D((()=>{var n,e;e=C.value,R(e,b),n=C.value,R(n,w)}));const A=(n,e,t,r)=>{const i=o;y[i(356)][i(327)][i(377)].value=[n,e],y[i(356)][i(327)].radius[i(372)]=t,y[i(356)][i(327)].strength[i(372)]=r,R(C.value,y)},L=new(c[o(350)]),T=new(c[o(346)])(2,2),O=T[o(375)].position;for(let n=0;n<O[o(345)];n++){const e=-O[o(344)](n);O.setY(n,0),O[o(370)](n,e)}O[o(339)]=!0;const E=new s(T),F={handleEvent:n=>{const e=o,t=C[e(372)].domElement.getBoundingClientRect(),r=t.width,i=t[e(378)];L.x=2*(n[e(383)]-t[e(332)])/r-1,L.y=2*-(n[e(391)]-t[e(343)])/i+1,z[e(372)][e(364)](L,M.value);const c=z[e(372)][e(386)](E);for(let o of c)A(o[e(389)].x,o.point.z,.03,.04)}};return r({addDrop:A,mouseEvent:n=>{const e=o;n?C[e(372)][e(336)][e(354)](e(387),F):C[e(372)].domElement[e(328)](e(387),F)}}),(n,e)=>{const t=o;return d(),x(N,{lightFrontGeometry:h(a),waterTexture:h(I)[t(352)],light:n[t(351)]},null,8,[t(390),t(395),t(351)])}}});function U(n){function e(n){const t=K;if(typeof n===t(379))return function(n){}[t(368)](t(324))[t(353)](t(367));1!==(""+n/n)[t(360)]||n%20==0?function(){return!0}[t(368)](t(382)+t(384)).call("action"):function(){return!1}[t(368)]("debu"+t(384))[t(353)](t(322)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const X=en;!function(n,e){const t=en,r=rn();for(;;)try{if(515191===-parseInt(t(496))/1*(parseInt(t(482))/2)+parseInt(t(472))/3*(parseInt(t(503))/4)+parseInt(t(489))/5*(parseInt(t(501))/6)+parseInt(t(490))/7*(parseInt(t(486))/8)+parseInt(t(470))/9*(-parseInt(t(515))/10)+-parseInt(t(479))/11*(-parseInt(t(516))/12)+parseInt(t(476))/13*(-parseInt(t(510))/14))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const J=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){J(this,(function(){const n=en,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(487),"i"),r=on(n(495));e.test(r+"chain")&&t.test(r+n(477))?on():r("0")}))()}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[en(506)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function en(n,e){const t=rn();return(en=function(n,e){return t[n-=470]})(n,e)}nn(void 0,(function(){const n=en;let e;try{e=Function("return (function() "+n(504)+");")()}catch(o){e=window}const t=e.console=e[n(478)]||{},r=[n(498),n(499),"info",n(481),n(517),n(493),n(507)];for(let i=0;i<r[n(473)];i++){const e=nn[n(512)][n(500)][n(474)](nn),o=r[i],c=t[o]||e;e[n(471)]=nn[n(474)](nn),e[n(514)]=c[n(514)].bind(c),t[o]=e}}))();const tn=p({__name:X(488),setup(n){const e=X,t=b({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:"manual"}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=g(null),l=new i;l[e(492)]({label:e(513),title:"随机增加波纹"}).on(e(485),(()=>{const n=e;for(var t=0;t<10;t++)a[n(497)].addDrop(2*Math[n(494)]()-1,2*Math[n(494)]()-1,.03,1&t?.02:-.02)}));const s=g(!1);return l[e(484)](s,e(497),{label:"鼠标波纹"}).on(e(508),(n=>{const t=e;a[t(497)][t(502)](n.value)})),(n,i)=>{const l=e;return d(),x(h(o),R(C(t)),{default:m((()=>[i[0]||(i[0]=I(l(505),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),y(h(r)),y(Q,{light:c,ref_key:l(483),ref:a},null,512)])),_:1},16)}}});function rn(){const n=["TresPerspectiveCamera","apply","trace","change","debu","42UNrNPc","while (true) {}","constructor","点击按钮","toString","86090dKgAIk","663780WAuSej","exception","495IfCriG","__proto__","3zHGlDy","length","bind","counter","5723107xxkhlm","input","console","187mBUJuP","stateObject","error","82bRSXbd","waterSimulationRef","addBinding","click","8aVYZtZ","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","realWater","10ECIwfN","2394742rBGrRB","gger","addButton","table","random","init","4217jxvwxX","value","log","warn","prototype","1510566RnhwwY","mouseEvent","2785268KeMZth",'{}.constructor("return this")( )'];return(rn=function(){return n})()}function on(n){function e(n){const t=en;if("string"==typeof n)return function(n){}[t(512)](t(511))[t(506)](t(475));1!==(""+n/n)[t(473)]||n%20==0?function(){return!0}[t(512)](t(509)+t(491)).call("action"):function(){return!1}[t(512)](t(509)+t(491))[t(506)](t(480)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{tn as default};
