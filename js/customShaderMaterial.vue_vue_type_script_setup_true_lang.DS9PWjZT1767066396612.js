const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./@tresjs.B1f7s3pS1767066396612.js","./3d-tiles-renderer.CbgZh8zU1767066396612.js","./three.BD1hRFgo1767066396612.js","./@originjs.DdrgKBO31767066396612.js","./postprocessing.c_btQLwf1767066396612.js","./@vueuse.BLRGmGj21767066396612.js","../css/@tresjs.8Vyyz-Qa1767066396612.css","./index.8btb0a2t1767066396612.js","./index.vue_vue_type_script_setup_true_lang.iYOGhvYh1767066396612.js","./utils.CNife3_q1767066396612.js","./index.Y8o_qofm1767066396612.js","./three-stdlib.Clo1XHat1767066396612.js","./useSeek.D1f6FARu1767066396612.js","./shapeConfigurator.C8LQhxHr1767066396612.js","./@fesjs.BK66sTPr1767066396612.js","./vue-router.B1C4up2Q1767066396612.js","./lodash-es.DWe8oqPO1767066396612.js","./pinia.CiNhMlOJ1767066396612.js","./vue-demi.teHgRfvT1767066396612.js","./@vue.Dg3dyR4l1767066396612.js","./@qlin.y-0Z8WnK1767066396612.js","./@babel.BPq7uOAK1767066396612.js","./@floating-ui.Bhq4ibgf1767066396612.js","./@juggle.Vc7cP4_P1767066396612.js","../css/@fesjs.C7wRTT0A1767066396612.css","./index.C8rw211p1767066396612.js","./flexiblePipe.vue_vue_type_script_setup_true_lang.CXwH_fIv1767066396612.js","./Resource.BqPJptsT1767066396612.js","./buildFlexiblePipe.4nO9hsJC1767066396612.js","./flexiblePipe2.vue_vue_type_script_setup_true_lang.DNdrLbhu1767066396612.js","./material.vue_vue_type_script_setup_true_lang.Bw44Rpmu1767066396612.js"])))=>i.map(i=>d[i]);
import{i as e}from"./3d-tiles-renderer.CbgZh8zU1767066396612.js";import{F as t,_ as a,R as n,V as r,$ as o,D as l,a0 as i,a1 as s,A as c,a2 as u,a3 as m,a4 as d,a5 as f,S as p,a6 as v,T as h}from"./@tresjs.B1f7s3pS1767066396612.js";import{M as g,e as y,f as _}from"./@pmndrs.Dko8Ps5C1767066396612.js";import"./index.vue_vue_type_script_setup_true_lang.iYOGhvYh1767066396612.js";import{o as b}from"./object-hash.NzceXOg01767066396612.js";import{i as S}from"./Resource.BqPJptsT1767066396612.js";import{ax as M}from"./three.BD1hRFgo1767066396612.js";import{b as x,g as w,k,c as P,d as E,m as R,n as I}from"./naive-ui.CmwCmbKm1767066396612.js";import{B as C}from"./three-custom-shader-material.DAA_4JPH1767066396612.js";import{R as A}from"./three-stdlib.Clo1XHat1767066396612.js";const{Scene:T,Object3D:O,Mesh:D}=await e("three");class z extends O{constructor(){super(),this.virtualScene=null,this.virtualScene=new T}add(...e){return this.virtualScene.add(...e),this}destructor(){this.virtualScene.traverse(e=>{e instanceof D&&(e.geometry.dispose(),e.material.dispose(),e.material.map&&e.material.map.dispose(),this.virtualScene.remove(e))}),this.virtualScene=null}}const B={sunset:"venice/venice_sunset_1k.hdr",studio:"studio/poly_haven_studio_1k.hdr",city:"city/canary_wharf_1k.hdr",umbrellas:"outdoor/outdoor_umbrellas_1k.hdr",night:"outdoor/satara_night_1k.hdr",forest:"outood/mossy_forest_1k.hdr",snow:"outdoor/snowy_forest_path_01_1k.hdr",dawn:"kiara/kiara_1_dawn_1k.hdr",hangar:"indoor/small_hangar_01_1k.hdr",urban:"indoor/abandoned_games_room_02_1k.hdr",modern:"city/modern_buildings_2_1k.hdr",shangai:"city/shanghai_bund_1k.hdr"},{CubeReflectionMapping:j,CubeTextureLoader:N,EquirectangularReflectionMapping:F}=await e("three"),{computed:L,ref:H,toRefs:U,unref:V,watch:G}=await e("vue");const{withAsyncContext:W,defineComponent:$}=await e("vue"),{unref:Y,renderSlot:q,openBlock:K,createElementBlock:Z,createCommentVNode:X}=await e("vue"),{ref:J,useSlots:Q,onUnmounted:ee,watch:te,toRaw:ae}=await e("vue"),{WebGLCubeRenderTarget:ne,CubeCamera:re,HalfFloatType:oe,UnsignedByteType:le,NearestFilter:ie}=await e("three"),se=$({__name:"component",props:{background:{type:[Boolean,String],default:!1},blur:{default:0},files:{default:[]},path:{default:""},preset:{default:void 0},resolution:{default:256},near:{default:1},far:{default:1e3},frames:{default:1/0},useDefaultScene:{type:Boolean,default:!1}},async setup(e,{expose:n}){let r,o;const l=e,i=J(null);n({texture:i});const{extend:s,renderer:c,scene:u}=t();let m=null,d=J(null),f=null;const p=J(null);ee(()=>{p.value?.destructor(),d.value?.dispose()});const{onBeforeRender:v}=a();let h=1;v(()=>{f&&p.value&&d.value&&(l.frames===1/0||h<l.frames)&&(l.useDefaultScene?f.update(c,u.value):f.update(c,ae(p.value.virtualScene)),h++)});const g=([r,o]=W(()=>async function(e,a){const{scene:n,invalidate:r}=t();G(e,()=>{r()});const{preset:o,blur:l,files:i=H([]),path:s=H(""),background:c}=U(e),u=H(null),m=L(()=>Array.isArray(i.value)),d=L(()=>m.value?N:A);return G([i,s],async([e,t])=>{if(e&&e.length>0&&!o?.value){try{u.value=await Va(d.value,m.value?[...V(e)]:V(e),e=>{t&&e.setPath(V(t))})}catch(a){throw new Error(`Failed to load environment map: ${a}`)}u.value&&(u.value.mapping=m.value?j:F),r()}},{immediate:!0}),G(u,e=>{n.value&&e&&(n.value.environment=e)},{immediate:!0}),G([c,u],([e,t])=>{if(n.value){let r=a?.value?a.value.texture:t,o=n.value.background;o?.isColor||(o=void 0),n.value.background=e?r:o}},{immediate:!0}),G(()=>l?.value,e=>{n.value&&e&&(n.value.backgroundBlurriness=e)},{immediate:!0}),G(()=>o?.value,async e=>{if(e&&e in B){const a="https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/",n=B[e];try{u.value=await Va(A,n,e=>{a&&e.setPath(a)})}catch(t){throw new Error(`Failed to load environment map: ${t}`)}u.value&&u.value&&(u.value.mapping=F),r()}else if(e&&!(e in B))throw new Error(`Preset must be one of: ${Object.keys(B).join(", ")}`)},{immediate:!0}),u}(l,d)),r=await r,o(),r),y=e=>{e?(u.value.environment=e.texture,l.background&&(u.value.background=e.texture)):(u.value.environment=g.value,l.background&&(u.value.background=g.value))};te(g,e=>{d.value&&y(d.value)},{immediate:!0,deep:!0}),s({EnvSence:z});const _=()=>{d.value?.dispose(),d.value=new ne(l.resolution),f=new re(l.near,l.far,d.value),l.useDefaultScene?(d.value.texture.type=le,d.value.texture.generateMipmaps=!1,d.value.texture.minFilter=ie,d.value.texture.magFilter=ie):d.value.texture.type=oe,y(d.value)};return te(()=>Q().default,e=>{e&&(!d.value||d.value.texture.type!==oe)&&(m=e(),Array.isArray(m)&&m.length>0&&"symbol"!=typeof m[0]?.type)?_():(d.value?.dispose(),d.value=null,y(null))},{immediate:!0,deep:!0}),i.value=g,te(()=>l.useDefaultScene,e=>{d.value&&_()}),(e,t)=>Y(d)?(K(),Z("TresEnvSence",{key:0,ref_key:"envSence",ref:p},[q(e.$slots,"default")],512)):X("",!0)}}),{defineComponent:ce}=await e("vue"),{openBlock:ue,createElementBlock:me,createBlock:de,unref:fe,createElementVNode:pe}=await e("vue"),ve={key:0,args:[0,1,64]},he={key:1,args:[.5,1,64]},ge={key:2},ye=["toneMapped","map","side","color"],{ref:_e,watchEffect:be,onMounted:Se,watch:Me}=await e("vue"),{Color:xe,DoubleSide:we}=await e("three"),ke=ce({__name:"index",props:{args:{default:null},from:{default:"rect"},toneMapped:{type:Boolean,default:!1},map:{default:null},intensity:{default:1},color:{default:new xe(16777215)}},setup(e){const t=e,a=_e();return be(()=>{a.value&&(a.value.color.multiplyScalar(t.intensity),a.value.needsUpdate=!0)}),Me(()=>t.color,e=>{a.value&&(a.value.color.set(e),a.value.color.multiplyScalar(t.intensity),a.value.needsUpdate=!0)}),Se(()=>{}),(e,n)=>(ue(),me("TresMesh",null,["circle"===t.from?(ue(),me("TresRingGeometry",ve)):"ring"===t.from?(ue(),me("TresRingGeometry",he)):"rect"===t.from?(ue(),me("TresPlaneGeometry",ge)):(ue(),de(t.from,{key:3,args:t})),pe("TresMeshBasicMaterial",{ref_key:"material",ref:a,toneMapped:e.toneMapped,map:e.map,side:fe(we),color:e.color},null,8,ye)]))}}),{DepthTexture:Pe,DepthFormat:Ee,UnsignedShortType:Re,HalfFloatType:Ie,LinearFilter:Ce,WebGLRenderTarget:Ae}=await e("three"),{isReactive:Te,onBeforeUnmount:Oe,reactive:De,ref:ze,toRefs:Be,watchEffect:je,toRaw:Ne}=await e("vue");function Fe(e){const n=ze(null),{height:r,width:o,settings:l,depth:i,isLoop:s}=Te(e)?Be(e):Be(De(e)),{onRender:c}=a(),{camera:u,renderer:m,scene:d,sizes:f}=t();return je(()=>{n.value?.dispose(),n.value=new Ae(o?.value||f.width.value,r?.value||f.height.value,{minFilter:Ce,magFilter:Ce,type:Ie,...l?.value}),i?.value&&(n.value.depthTexture=new Pe(o?.value||f.width.value,r?.value||f.height.value),n.value.depthTexture.format=Ee,n.value.depthTexture.type=Re)}),c(()=>{s?.value&&(m.setRenderTarget(Ne(n.value)),m.clear(),m.render(Ne(d.value),Ne(u.value)),m.setRenderTarget(null))}),Oe(()=>{n.value?.dispose()}),n}const{defineComponent:Le}=await e("vue"),{unref:He,openBlock:Ue,createElementBlock:Ve}=await e("vue"),Ge=["buffer","side"],{shallowRef:We,nextTick:$e,onMounted:Ye}=await e("vue"),{BackSide:qe,DoubleSide:Ke}=await e("three"),Ze=Le({__name:"index",props:{backside:{type:Boolean,default:!0},thickness:{default:1},backsideThickness:{default:.5},fboResolution:{default:256}},setup(e,{expose:n}){const r=We(),{extend:o,scene:l,renderer:i,camera:s}=t(),c=We(),u=e;o({MeshTransmissionMaterial:g});const m=new y,{onBeforeRender:d}=a(),f=Fe({width:u.fboResolution,height:u.fboResolution,isLoop:!1}),p=Fe({width:u.fboResolution,height:u.fboResolution,isLoop:!1});let v,h,_,b;return Ye(async()=>{await $e(),c.value=function(e,t){let a;return e.traverse(e=>{e.isMesh&&e.material&&e.material.uuid===t&&(a=e)}),a}(l.value,r.value.uuid)}),d(({elapsed:e})=>{r.value&&(r.value.time=e,r.value.buffer===p.value.texture&&c.value&&(_=i.toneMapping,v=l.value.background,h=r.value.envMapIntensity,b=c.value.material.side,c.value.material=m,u.backside&&(i.setRenderTarget(f.value),i.render(l.value,s.value),c.value.material=r.value,c.value.material.thickness=u.backsideThickness,c.value.material.buffer=f.value.texture,c.value.material.side=qe,c.value.material.envMapIntensity=0),i.setRenderTarget(p.value),i.render(l.value,s.value),c.value.material.buffer=p.value.texture,c.value.material=r.value,c.value.material.thickness=u.thickness,c.value.material.side=b,c.value.material.envMapIntensity=h,l.value.background=v,i.setRenderTarget(null),i.toneMapping=_))}),n({root:r,constructor:g}),(e,t)=>(Ue(),Ve("TresMeshTransmissionMaterial",{ref_key:"MeshTransmissionMaterialClass",ref:r,buffer:He(p).texture,side:He(Ke)},null,8,Ge))}}),{defineComponent:Xe}=await e("vue"),{renderSlot:Je,createElementVNode:Qe,openBlock:et,createElementBlock:tt}=await e("vue"),{ref:at,onMounted:nt}=await e("vue"),{Box3:rt,Vector3:ot,Sphere:lt}=await e("three"),it=Xe({__name:"index",props:{precise:{type:Boolean,default:!0},top:{type:Boolean,default:!1},right:{type:Boolean,default:!1},bottom:{type:Boolean,default:!1},left:{type:Boolean,default:!1},front:{type:Boolean,default:!1},back:{type:Boolean,default:!1},disable:{type:Boolean,default:!1},disableX:{type:Boolean,default:!1},disableY:{type:Boolean,default:!1},disableZ:{type:Boolean,default:!1}},setup(e){const t=e,a=at(null),n=at(null),r=at(null);return nt(()=>{if(!n.value)return;if(!r.value)return;n.value.matrixWorld.identity();const e=(new rt).setFromObject(r.value,t.precise),a=new ot,o=new lt,l=e.max.x-e.min.x,i=e.max.y-e.min.y,s=e.max.z-e.min.z;e.getCenter(a),e.getBoundingSphere(o);const c=t.top?i/2:t.bottom?-i/2:0,u=t.left?-l/2:t.right?l/2:0,m=t.front?s/2:t.back?-s/2:0;n.value.position.set(t.disable||t.disableX?0:-a.x+u,t.disable||t.disableY?0:-a.y+c,t.disable||t.disableZ?0:-a.z+m)}),(e,t)=>(et(),tt("TresGroup",{ref_key:"gref",ref:a},[Qe("TresGroup",{ref_key:"outer",ref:n},[Qe("TresGroup",{ref_key:"inner",ref:r},[Je(e.$slots,"default")],512)],512)],512))}}),{defineComponent:st}=await e("vue"),{renderSlot:ct,createElementVNode:ut,unref:mt,Fragment:dt,openBlock:ft,createElementBlock:pt}=await e("vue"),vt=["object"],ht=["object"],{shallowRef:gt,watch:yt,watchEffect:_t}=await e("vue"),bt=await e("three"),St=st({__name:"index",props:{color:{default:"#ffffff"},ior:{default:1.1},backsideIOR:{default:1.1},far:{default:15},worldRadius:{default:.3},intensity:{default:.05},causticsOnly:{type:Boolean,default:!1},lightSource:{default:{x:1,y:1,z:1}},resolution:{default:1024}},setup(e){const n=e,{renderer:r}=t(),o=_(r,{frames:1/0,resolution:n.resolution,worldRadius:n.worldRadius});o.params.backside=!0;const l=gt(null);yt(l,e=>{e&&o.scene.add(e)});const{onBeforeRender:i}=a();return i(({elapsed:e})=>{o.update()}),_t(()=>{n.color&&o.params.color.set(n.color),n.ior&&(o.params.ior=n.ior),n.backsideIOR&&(o.params.backsideIOR=n.backsideIOR),n.far&&(o.params.far=n.far),n.worldRadius&&(o.params.worldRadius=n.worldRadius),n.intensity&&(o.params.intensity=n.intensity)}),yt(()=>n.causticsOnly,e=>{o.params.causticsOnly=e}),yt(()=>n.lightSource,e=>{e&&o.params.lightSource instanceof bt.Vector3&&o.params.lightSource.set(e.x,e.y,e.z)},{deep:!0}),(e,t)=>(ft(),pt(dt,null,[ut("TresGroup",{ref_key:"group",ref:l},[ct(e.$slots,"default")],512),ut("primitive",{object:mt(o).group,position:[0,.003,0]},null,8,vt),ut("primitive",{object:mt(o).helper,visible:!1},null,8,ht)],64))}}),Mt=await e("three");const xt=({focus:e=0,size:t=25,samples:a=10}={})=>{const n=Mt.ShaderChunk.shadowmap_pars_fragment;return Mt.ShaderChunk.shadowmap_pars_fragment=Mt.ShaderChunk.shadowmap_pars_fragment.replace("#ifdef USE_SHADOWMAP",`#ifdef USE_SHADOWMAP\n\n    #define PENUMBRA_FILTER_SIZE float(${t})\n    #define RGB_NOISE_FUNCTION(uv) (randRGB(uv))\n    vec3 randRGB(vec2 uv) {\n      return vec3(\n        fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),\n        fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),\n        fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)\n      );\n    }\n    \n    vec3 lowPassRandRGB(vec2 uv) {\n      // 3x3 convolution (average)\n      // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9\n      vec3 result = vec3(0);\n      result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));\n      result *= 0.111111111; // 1.0 / 9.0\n      return result;\n    }\n    vec3 highPassRandRGB(vec2 uv) {\n      // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal\n      // hp(x) = x - lp(x)\n      return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;\n    }\n    \n    \n    vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n      const float goldenAngle = 2.399963f; // radians\n      float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n      float theta = float(sampleIndex) * goldenAngle + angle;\n      float sine = sin(theta);\n      float cosine = cos(theta);\n      return vec2(cosine, sine) * r;\n    }\n    float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n      return (zReceiver - zBlocker) / zBlocker;\n    }\n    float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {\n      float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\n      float blockerDepthSum = float(${e});\n      float blockers = 0.0;\n    \n      int j = 0;\n      vec2 offset = vec2(0.);\n      float depth = 0.;\n    \n      #pragma unroll_loop_start\n      for(int i = 0; i < ${a}; i ++) {\n        offset = (vogelDiskSample(j, ${a}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;\n        depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));\n        if (depth < compare) {\n          blockerDepthSum += depth;\n          blockers++;\n        }\n        j++;\n      }\n      #pragma unroll_loop_end\n    \n      if (blockers > 0.0) {\n        return blockerDepthSum / blockers;\n      }\n      return -1.0;\n    }\n            \n    float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {\n      float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\n      float shadow = 0.0f;\n      int j = 0;\n      vec2 vogelSample = vec2(0.0);\n      vec2 offset = vec2(0.0);\n      #pragma unroll_loop_start\n      for (int i = 0; i < ${a}; i++) {\n        vogelSample = vogelDiskSample(j, ${a}, angle) * texelSize;\n        offset = vogelSample * (1.0 + filterRadius * float(${t}));\n        shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n        j++;\n      }\n      #pragma unroll_loop_end\n      return shadow * 1.0 / ${a}.0;\n    }\n    \n    float PCSS (sampler2D shadowMap, vec4 coords) {\n      vec2 uv = coords.xy;\n      float zReceiver = coords.z; // Assumed to be eye-space z in this code\n      float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;\n      float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);\n      if (avgBlockerDepth == -1.0) {\n        return 1.0;\n      }\n      float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n      return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);\n    }`).replace("#if defined( SHADOWMAP_TYPE_PCF )","\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )"),(e,t,a)=>{Mt.ShaderChunk.shadowmap_pars_fragment=n,function(e,t,a){t.traverse(t=>{t.material&&(Array.isArray(t.material)?t.material.forEach(t=>{e.properties.remove(t),t.dispose()}):(e.properties.remove(t.material),t.material.dispose()))}),e.info.programs.length=0,e.compile(t,a)}(e,t,a)}},{defineComponent:wt}=await e("vue"),{watch:kt}=await e("vue"),{Mesh:Pt}=await e("three"),Et=wt({__name:"index",props:{enabled:{type:Boolean,default:!0},size:{default:25},focus:{default:0},samples:{default:10}},setup(e){const a=e,{camera:n,renderer:r,scene:o}=t();let l=null;const i=e=>{const{enabled:t,size:a,focus:i,samples:s}=e;l&&(l(r,o.value,n.value),l=null),t&&(l=xt({focus:i,size:a,samples:s}),o.value.traverse(e=>{e instanceof Pt&&e.material.dispose()}))};return i(a),kt(a,()=>{i(a)}),(e,t)=>null}}),Rt=await e("three"),{HalfFloatType:It,WebGLCubeRenderTarget:Ct}=await e("three"),{onBeforeUnmount:At,ref:Tt,watch:Ot}=await e("vue");const{defineComponent:Dt}=await e("vue"),{unref:zt,createElementVNode:Bt,renderSlot:jt,openBlock:Nt,createElementBlock:Ft}=await e("vue"),Lt=["object"],{ref:Ht}=await e("vue"),Ut=Dt({__name:"index",props:{resolution:{default:256},near:{default:.1},far:{default:1e3},envMap:{default:null},fog:{default:null},frames:{default:1/0}},setup(e,{expose:n}){const r=e,{fbo:o,camera:l,update:i}=function({resolution:e=256,near:a=.1,far:n=1e3,envMap:r,fog:o}={}){const{renderer:l,scene:i}=t(),s=Tt(null),c=Tt(e),u=Tt(a),m=Tt(n),d=Tt(null);let f,p;return Ot(()=>c,e=>{s.value?.dispose(),s.value=new Ct(e.value),s.value.texture.type=It},{immediate:!0}),Ot([u,m,s],([e,t,a])=>{a&&(d.value=new Rt.CubeCamera(e,t,a))},{immediate:!0}),At(()=>{s.value?.dispose()}),{fbo:s,camera:d,update:()=>{f=i.value.fog,p=i.value.background,i.value.background=r||p,i.value.fog=o||f,d.value?.update(l,i.value),i.value.fog=f,i.value.background=p}}}({resolution:r.resolution,near:r.near,far:r.far,envMap:r.envMap,fog:r.fog}),{onBeforeRender:s}=a();let c=0;const u=Ht(null);return s(()=>{u.value&&(r.frames===1/0||c<r.frames)&&(u.value.visible=!1,i(),u.value.visible=!0,c++)}),n({texture:o.value?.texture}),(e,t)=>(Nt(),Ft("TresGroup",null,[Bt("primitive",{object:zt(l)},null,8,Lt),Bt("TresGroup",{ref_key:"rgRef",ref:u},[jt(e.$slots,"default")],512)]))}}),Vt=await e("three");function Gt(e,t,a,n){const r=class extends Vt.ShaderMaterial{constructor(r={}){const o=Object.entries(e);super({uniforms:o.reduce((e,[t,a])=>({...e,...Vt.UniformsUtils.clone({[t]:{value:a}})}),{}),vertexShader:t,fragmentShader:a}),this.key="",o.forEach(([e])=>Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:t=>this.uniforms[e].value=t})),Object.assign(this,r),n&&n(this)}};return r.key=Vt.MathUtils.generateUUID(),r}const Wt=await e("three");function $t(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var a=e[Symbol.toPrimitive];if(void 0!==a){var n=a.call(e,t);if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e,"string");return"symbol"==typeof t?t:String(t)}function Yt(e,t,a){return(t=$t(t))in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function qt(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),a.push.apply(a,n)}return a}function Kt(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?qt(Object(a),!0).forEach(function(t){Yt(e,t,a[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):qt(Object(a)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))})}return e}function Zt(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}function Xt(e,t){(null==t||t>e.length)&&(t=e.length);for(var a=0,n=new Array(t);a<t;a++)n[a]=e[a];return n}function Jt(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var a=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=a){var n,r,o,l,i=[],s=!0,c=!1;try{if(o=(a=a.call(e)).next,0===t);else for(;!(s=(n=o.call(a)).done)&&(i.push(n.value),i.length!==t);s=!0);}catch(u){c=!0,r=u}finally{try{if(!s&&null!=a.return&&(l=a.return(),Object(l)!==l))return}finally{if(c)throw r}}return i}}(e,t)||function(e,t){if(e){if("string"==typeof e)return Xt(e,t);var a=Object.prototype.toString.call(e).slice(8,-1);return"Object"===a&&e.constructor&&(a=e.constructor.name),"Map"===a||"Set"===a?Array.from(e):"Arguments"===a||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)?Xt(e,t):void 0}}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Qt(e,t,a){return t&&function(e,t){for(var a=0;a<t.length;a++){var n=t[a];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,$t(n.key),n)}}(e.prototype,t),Object.defineProperty(e,"prototype",{writable:!1}),e}function ea(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function ta(e,t){return ta=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},ta(e,t)}function aa(e){return aa=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},aa(e)}function na(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(e){return!1}}();return function(){var a,n=aa(e);if(t){var r=aa(this).constructor;a=Reflect.construct(n,arguments,r)}else a=n.apply(this,arguments);return function(e,t){if(t&&("object"==typeof t||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return ea(e)}(this,a)}}var ra,oa,la,ia="csm_DiffuseColor",sa="csm_Normal",ca="csm_Roughness",ua="csm_Metalness",ma="csm_Emissive",da="csm_AO",fa="csm_Bump",pa="csm_Clearcoat",va="csm_ClearcoatRoughness",ha="csm_ClearcoatNormal",ga="csm_PointSize",ya="csm_FragColor",_a="csm_DepthAlpha",ba="csm_Position",Sa="csm_PositionRaw",Ma=(Yt(ra={},"".concat(ba),"*"),Yt(ra,"".concat(Sa),"*"),Yt(ra,"".concat(sa),"*"),Yt(ra,"".concat(ga),["PointsMaterial"]),Yt(ra,"".concat(ia),"*"),Yt(ra,"".concat(ya),"*"),Yt(ra,"".concat(ma),["MeshStandardMaterial","MeshPhysicalMaterial"]),Yt(ra,"".concat(ca),["MeshStandardMaterial","MeshPhysicalMaterial"]),Yt(ra,"".concat(ua),["MeshStandardMaterial","MeshPhysicalMaterial"]),Yt(ra,"".concat(da),["MeshStandardMaterial","MeshPhysicalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial"]),Yt(ra,"".concat(fa),["MeshLambertMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MeshToonMaterial","ShadowMaterial"]),Yt(ra,"".concat(_a),["MeshDepthMaterial"]),Yt(ra,"".concat(pa),["MeshPhysicalMaterial"]),Yt(ra,"".concat(va),["MeshPhysicalMaterial"]),Yt(ra,"".concat(ha),["MeshPhysicalMaterial"]),ra),xa={"#include <lights_physical_fragment>":Wt.ShaderChunk.lights_physical_fragment},wa=(Yt(oa={},"".concat(sa),{"#include <beginnormal_vertex>":"\n    vec3 objectNormal = ".concat(sa,";\n    #ifdef USE_TANGENT\n\t    vec3 objectTangent = vec3( tangent.xyz );\n    #endif\n    ")}),Yt(oa,"".concat(ba),{"#include <begin_vertex>":"\n    vec3 transformed = ".concat(ba,";\n  ")}),Yt(oa,"".concat(Sa),{"#include <begin_vertex>":"\n    vec4 csm_internal_positionUnprojected = ".concat(Sa,";\n    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;\n    #ifdef USE_INSTANCING\n      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;\n    #endif\n    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;\n    vec3 transformed = csm_internal_positionUnprojected.xyz;\n  ")}),Yt(oa,"".concat(ga),{"gl_PointSize = size;":"\n    gl_PointSize = ".concat(ga,";\n    ")}),Yt(oa,"".concat(ia),{"#include <color_fragment>":"\n    #include <color_fragment>\n    diffuseColor = ".concat(ia,";\n  ")}),Yt(oa,"".concat(ya),{"#include <dithering_fragment>":"\n    #include <dithering_fragment>\n    gl_FragColor  = ".concat(ya,";\n  ")}),Yt(oa,"".concat(ma),{"vec3 totalEmissiveRadiance = emissive;":"\n    vec3 totalEmissiveRadiance = ".concat(ma,";\n    ")}),Yt(oa,"".concat(ca),{"#include <roughnessmap_fragment>":"\n    #include <roughnessmap_fragment>\n    roughnessFactor = ".concat(ca,";\n    ")}),Yt(oa,"".concat(ua),{"#include <metalnessmap_fragment>":"\n    #include <metalnessmap_fragment>\n    metalnessFactor = ".concat(ua,";\n    ")}),Yt(oa,"".concat(da),{"#include <aomap_fragment>":"\n    #include <aomap_fragment>\n    reflectedLight.indirectDiffuse *= 1. - ".concat(da,";\n    ")}),Yt(oa,"".concat(fa),{"#include <normal_fragment_maps>":"\n    #include <normal_fragment_maps>\n\n    vec3 csm_internal_orthogonal = ".concat(fa," - (dot(").concat(fa,", normal) * normal);\n    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;\n    normal = normalize(normal - csm_internal_projectedbump);\n    ")}),Yt(oa,"".concat(_a),{"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );":"\n      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * ".concat(_a," );\n    "),"gl_FragColor = packDepthToRGBA( fragCoordZ );":"\n      gl_FragColor = packDepthToRGBA( fragCoordZ );\n      gl_FragColor.a *= ".concat(_a,";\n    ")}),Yt(oa,"".concat(pa),{"material.clearcoat = clearcoat;":"material.clearcoat = ".concat(pa,";")}),Yt(oa,"".concat(va),{"material.clearcoatRoughness = clearcoatRoughness;":"material.clearcoatRoughness = ".concat(va,";")}),Yt(oa,"".concat(ha),{"#include <clearcoat_normal_fragment_begin>":"\n      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);\n      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;\n      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);\n    "}),oa),ka=(Yt(la={},"".concat(ba),{"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );":"\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( ".concat(ba,", 1.0 );\n  ")}),Yt(la,"".concat(Sa),{"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );":"\n    gl_Position = ".concat(ba,";\n  ")}),Yt(la,"".concat(ia),{"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );":"\n    gl_FragColor = ".concat(ia,";\n  ")}),Yt(la,"".concat(ya),{"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );":"\n    gl_FragColor = ".concat(ya,";\n  ")}),la),Pa={clearcoat:[pa,ha,va]},Ea=["baseMaterial","fragmentShader","vertexShader","uniforms","patchMap","cacheKey","silent"],Ra=function(e,t,a){return e.split(t).join(a)},Ia=function(e,t){return new RegExp("\\b".concat((a=t,a.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")),"\\b")).test(e);var a};function Ca(e){return e?e.replace(/\s/g,""):void 0}function Aa(e){return e.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm,"")}var Ta=function(){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&ta(e,t)}(t,Wt.Material);var e=na(t);function t(a){var n,r,o,l,i=a.baseMaterial,s=a.fragmentShader,c=a.vertexShader,u=a.uniforms,m=a.patchMap,d=a.cacheKey,f=a.silent,p=Zt(a,Ea);if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),!function(e){try{new e}catch(t){if(t.message.indexOf("is not a constructor")>=0)return!1}return!0}(i)?(r=i,Object.assign(r,p)):r=new i(p),"RawShaderMaterial"===r.type)throw new Error("CustomShaderMaterial does not support RawShaderMaterial");(function(e,t){Object.assign(e,t);var a=Object.getPrototypeOf(t);Object.entries(Object.getOwnPropertyDescriptors(a)).filter(function(e){var t="function"==typeof e[1].get,a="function"==typeof e[1].set,n="function"==typeof e[1].value,r="constructor"===e[0];return(t||a||n)&&!r}).forEach(function(t){"function"!=typeof e[t[0]]&&Object.defineProperty(e,t[0],t[1])})})(ea(n=e.call(this)),r),n.__csm={patchMap:m||{},fragmentShader:s||"",vertexShader:c||"",cacheKey:d,baseMaterial:i,instanceID:Wt.MathUtils.generateUUID(),type:r.type,isAlreadyExtended:(o=r.onBeforeCompile,l=o.toString().trim(),!(0===l.substring(l.indexOf("{")+1,l.lastIndexOf("}")).trim().length)),cacheHash:"",silent:f},n.uniforms=Kt(Kt({},n.uniforms||{}),u||{});var v=n.__csm,h=v.fragmentShader,g=v.vertexShader,y=n.uniforms;return n.__csm.cacheHash=n._getCacheHash(),n._generateMaterial(h,g,y),n}return Qt(t,[{key:"update",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.uniforms=e.uniforms||this.uniforms,Object.assign(this.__csm,e);var t=this.__csm,a=t.fragmentShader,n=t.vertexShader,r=this.uniforms,o=this._getCacheHash();this.__csm.cacheHash=o,this._generateMaterial(a,n,r)}},{key:"clone",value:function(){var e={baseMaterial:this.__csm.baseMaterial,fragmentShader:this.__csm.fragmentShader,vertexShader:this.__csm.vertexShader,uniforms:this.uniforms,silent:this.__csm.silent,patchMap:this.__csm.patchMap,cacheKey:this.__csm.cacheKey},t=new this.constructor(e);return Object.assign(this,t),t}},{key:"_getCacheHash",value:function(){var e=this.__csm,t=e.fragmentShader,a=e.vertexShader,n=this.uniforms,r=[Ca(t),Ca(a),n].filter(function(e){return void 0!==e});return r.length>0?b(r,{excludeValues:!0}):this.customProgramCacheKey()}},{key:"_generateMaterial",value:function(e,t,a){var n=this;this.uniforms=a||{},this.customProgramCacheKey=function(){return n.__csm.cacheHash};var r=function(a){try{var r=n._getMaterialDefine();if(e){var o=n._patchShader(Aa(e),a.fragmentShader,!0);a.fragmentShader=r+o}if(t){var l=n._patchShader(Aa(t),a.vertexShader);a.vertexShader="#define IS_VERTEX;\n"+l,a.vertexShader=r+a.vertexShader}a.uniforms=Kt(Kt({},a.uniforms),n.uniforms),n.uniforms=a.uniforms}catch(i){console.error(i)}};if(this.__csm.isAlreadyExtended){var o=this.onBeforeCompile;this.onBeforeCompile=function(e,t){o(e,t),r(e)}}else this.onBeforeCompile=r;this.needsUpdate=!0}},{key:"_patchShader",value:function(e,t,a){var n=this,r=t,o=Kt(Kt({},this._getPatchMapForMaterial()),this.__csm.patchMap);Object.entries(Pa).forEach(function(t){var a=Jt(t,2),r=a[0],o=a[1].find(function(t){return Ia(e,t)});if(o&&!n[r])throw new Error('CSM: Property "'.concat(r,'" is required to use output "').concat(o,'". Shader cannot compile.'))}),Object.entries(xa).forEach(function(e){var t=Jt(e,2),a=t[0],n=t[1];r=Ra(r,a,n)}),Object.keys(o).forEach(function(t){Object.keys(o[t]).forEach(function(a){var l=Ma[t],i=n.__csm.type;if("*"===t||Ia(e,t)){if(!(!l||Array.isArray(l)&&l.includes(i)||"*"===l))throw new Error("CSM: ".concat(t," is not available in ").concat(i,". Shader cannot compile."));r=Ra(r,a,o[t][a])}})});var l,i,s,c,u="csm_main_"+this.__csm.instanceID.replace(/-/g,"_"),m=e.replace(/void\s+main\s*\(\s*\)/g,"void ".concat(u,"()")),d=e.includes("void main()"),f=r.includes("// #_CSM_#");return d&&(f&&this.__csm.isAlreadyExtended?(r=r.replace("void main() {","\n            ".concat(m,"\n            \n            void main() {\n          ")),l=r,i="// #_CSM_#",s="\n            ".concat(u,"();\n            // #_CSM_#\n          "),c=l.lastIndexOf(i),r=-1===c?l:l.substring(0,c)+s+l.substring(c+i.length)):r=r.replace("void main() {","\n            #ifndef CSM_IS_HEAD_DEFAULTS_DEFINED\n              ".concat("\n    varying mat4 csm_internal_vModelViewMatrix;\n","\n              #define CSM_IS_HEAD_DEFAULTS_DEFINED 1\n            #endif\n    \n            ").concat("\n    \n#ifdef IS_VERTEX\n    vec3 csm_Position;\n    vec4 csm_PositionRaw;\n    vec3 csm_Normal;\n\n    // csm_PointSize\n    #ifdef IS_POINTSMATERIAL\n        float csm_PointSize;\n    #endif\n#else\n    vec4 csm_DiffuseColor;\n    vec4 csm_FragColor;\n\n    // csm_Emissive, csm_Roughness, csm_Metalness\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\n        vec3 csm_Emissive;\n        float csm_Roughness;\n        float csm_Metalness;\n        \n        #if defined IS_MESHPHYSICALMATERIAL\n            float csm_Clearcoat;\n            float csm_ClearcoatRoughness;\n            vec3 csm_ClearcoatNormal;\n        #endif\n    #endif\n\n    // csm_AO\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\n        float csm_AO;\n    #endif\n\n    // csm_Bump\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \n        vec3 csm_Bump;\n    #endif\n\n    float csm_DepthAlpha;\n#endif\n","\n    \n            ").concat(m,"\n            \n            void main() {\n              #ifndef CSM_IS_DEFAULTS_DEFINED\n                ").concat("\n\n#ifdef IS_VERTEX\n    // csm_Position & csm_PositionRaw\n    #ifdef IS_UNKNOWN\n        csm_Position = vec3(0.0);\n        csm_PositionRaw = vec4(0.0);\n        csm_Normal = vec3(0.0);\n    #else\n        csm_Position = position;\n        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n        csm_Normal = normal;\n    #endif\n\n    // csm_PointSize\n    #ifdef IS_POINTSMATERIAL\n        csm_PointSize = size;\n    #endif\n#else\n    // csm_DiffuseColor & csm_FragColor\n    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL\n        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\n        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n    #else\n        #ifdef USE_MAP\n            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);\n\n            #ifdef DECODE_VIDEO_TEXTURE\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\n            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);\n            #endif\n\n            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\n            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\n        #else\n            csm_DiffuseColor = vec4(diffuse, opacity);\n            csm_FragColor = vec4(diffuse, opacity);\n        #endif\n    #endif\n\n    // csm_Emissive, csm_Roughness, csm_Metalness\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\n        csm_Emissive = emissive;\n        csm_Roughness = roughness;\n        csm_Metalness = metalness;\n\n        #if defined IS_MESHPHYSICALMATERIAL\n            #ifdef USE_CLEARCOAT\n                csm_Clearcoat = clearcoat;\n                csm_ClearcoatRoughness = clearcoatRoughness;\n            #else\n                csm_Clearcoat = 0.0;\n                csm_ClearcoatRoughness = 0.0;\n            #endif\n        #endif\n    #endif\n\n    // csm_AO\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\n        csm_AO = 0.0;\n    #endif\n\n    // csm_Bump\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \n        csm_Bump = vec3(0.0);\n    #endif\n\n    csm_DepthAlpha = 1.0;\n#endif\n","\n                #define CSM_IS_DEFAULTS_DEFINED 1\n              #endif\n              \n              #ifndef CSM_IS_MAIN_DEFAULTS_DEFINED\n                ").concat(a?"\n    \n":"\n    csm_internal_vModelViewMatrix = modelViewMatrix;\n","\n                #define CSM_IS_MAIN_DEFAULTS_DEFINED 1\n              #endif\n  \n              ").concat(u,"();\n              // #_CSM_#\n          "))),r}},{key:"_getMaterialDefine",value:function(){var e=this.__csm.type;return e?"#define IS_".concat(e.toUpperCase(),";\n"):"#define IS_UNKNOWN;\n"}},{key:"_getPatchMapForMaterial",value:function(){return"ShaderMaterial"===this.__csm.type?ka:wa}}]),t}();const{defineComponent:Oa}=await e("vue"),{unref:Da,openBlock:za,createElementBlock:Ba}=await e("vue"),ja=["object"],Na=await e("three"),{watchEffect:Fa}=await e("vue"),La=Oa({__name:"index",props:{color:{default:"#ff00fc"},metalness:{default:1},roughness:{default:1},clearcoat:{default:1},clearcoatRoughness:{default:0}},setup(e){const t=e,a={baseMaterial:Na.MeshPhysicalMaterial,metalness:t.metalness,roughness:t.roughness,clearcoat:t.clearcoat,clearcoatRoughness:t.clearcoatRoughness,color:t.color,vertexShader:"\n\t\t\tvarying vec3 csm_vPosition;\n\t\t\tvarying vec3 csm_vWorldNormal;\n\t\t\tvarying vec3 csm_vWorldViewDirection;\n\t\t\tvarying vec4 csm_vGlPosition;\n\n\t\t\tvoid main() {\n\t\t\t\t\tcsm_vWorldNormal = normalize((modelMatrix * vec4(normal.xyz, 0.0)).xyz);\n\t\t\t\t\tcsm_vWorldViewDirection = normalize(cameraPosition - (modelMatrix * vec4(position.xyz, 0.0)).xyz) ;\n\n\t\t\t\t\tcsm_vGlPosition = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t\t\t\t\tcsm_vPosition = position;\n\t\t\t}",fragmentShader:"\n\t\t\tconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv) {\n  uv *= myt;\n  uv *= mys;\n  return fract(fract(uv / mys) * uv);\n}\n\nvec3 hash(vec3 p) {\n  return fract(\n      sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),\n               dot(p, vec3(113.0, 1.0, 57.0)))) *\n      43758.5453);\n}\n\nfloat mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 perm(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\nfloat floatHash(vec3 p) {\n  vec3 a = floor(p);\n  vec3 d = p - a;\n  d = d * d * (3.0 - 2.0 * d);\n\n  vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n  vec4 k1 = perm(b.xyxy);\n  vec4 k2 = perm(k1.xyxy + b.zzww);\n\n  vec4 c = k2 + a.zzzz;\n  vec4 k3 = perm(c);\n  vec4 k4 = perm(c + 1.0);\n\n  vec4 o1 = fract(k3 * (1.0 / 41.0));\n  vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n  vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n  vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n  return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvec2 voronoi3d(vec3 pos) {\n  vec3 baseCell = floor(pos);\n\n  float minDistToCell = 10.0;\n  vec3 closestCell;\n  for (int x = -1; x <= 1; x++) {\n    for (int y = -1; y <= 1; y++) {\n      for (int z = -1; z <= 1; z++) {\n        vec3 cell = baseCell + vec3(float(x), float(y), float(z));\n        vec3 cellPosition = cell + hash(cell);\n        vec3 toCell = cellPosition - pos;\n        float distToCell = length(toCell);\n        if (distToCell < minDistToCell) {\n          minDistToCell = distToCell;\n          closestCell = cell;\n        }\n      }\n    }\n  }\n\n  float random = floatHash(closestCell);\n  return vec2(minDistToCell, random);\n}\n      vec4 permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n\nfloat pnoise(vec3 P) {\n  vec3 Pi0 = floor(P);        \n  vec3 Pi1 = Pi0 + vec3(1.0); \n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P);        \n  vec3 Pf1 = Pf0 - vec3(1.0); \n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(\n      vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(\n      vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111),\n                 fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\t\t\tvarying vec3 csm_vPosition;\n\t\t\tvarying vec3 csm_vWorldNormal;\n\t\t\tvarying vec3 csm_vWorldViewDirection;\n\t\t\tvarying vec4 csm_vGlPosition;\n\n      uniform vec3 uFleckColor;\n\n      const float fresnel_Power = 1.0;\n\n      float fresnel() {\n          return pow(1.0 - dot(csm_vWorldNormal, csm_vWorldViewDirection), fresnel_Power);\n      }\n\n      float mapLinear(float x, float a1, float a2, float b1, float b2) {\n          return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n      }\n\n      void main() {\n      // Fresnel\n      float fresnelFactor = fresnel();\n\n      // Fleck\n      float fleckFactor = voronoi3d(csm_vPosition * 2000.0).y;\n      float fleckFactorY = voronoi3d(csm_vPosition * 2000.0 + 100.0).y;\n      float fleckFactorZ = voronoi3d(csm_vPosition * 2000.0 + 200.0).y;\n\n      // Distance from camera\n      float normalizedDist = csm_vGlPosition.z / csm_vGlPosition.w;\n      normalizedDist = smoothstep(0.6, 1.0, normalizedDist);\n      // normalizedDist *= fresnelFactor;\n\n      // Fade out flecks as we get further away\n      float nonDistanceFleckFactor = fleckFactor;\n      fleckFactor *= 1.0 - normalizedDist;\n\n      // Diffuse\n      float diffuseFactor = csm_DiffuseColor.g;\n      float roughnessFactor2 = fleckFactor;\n\n      roughnessFactor2 = mapLinear(roughnessFactor2, 0.0, 1.0, 0.4, 0.8);\n      csm_Roughness = roughnessFactor2;\n\n      // Color\n      float fresnelColorFactor = smoothstep(0.0, 1.0, clamp(fresnelFactor, 0.0, 0.4));\n      vec3 fresnelColor = mix(csm_DiffuseColor.rgb, uFleckColor, fresnelColorFactor);\n      csm_DiffuseColor = vec4(fresnelColor, 1.0);\n\n      float fleckColorFactor = smoothstep(0.99, 0.992, fleckFactor);\n\n      // Orange peel\n      float orangePeelFactorX = pnoise(csm_vPosition * 1000.0);\n      float orangePeelFactorY = pnoise(csm_vPosition * 1000.0 + 100.0);\n      float orangePeelFactorZ = pnoise(csm_vPosition * 1000.0 + 200.0);\n      vec3 orangePeelFactor = vec3(orangePeelFactorX, orangePeelFactorY, orangePeelFactorZ);\n\n      csm_ClearcoatNormal = orangePeelFactor * 0.01 * (1.0 - normalizedDist);\n      // csm_Clearcoat = 10.0;\n      // csm_ClearcoatRoughness = 0.0;\n\n      csm_Bump = vec3(fleckFactor, fleckFactorY, fleckFactorZ) * 1.0 * (1.0 - normalizedDist);\n      }\n\t\t"},n=new Ta(a);return Fa(()=>{n.color.setStyle(t.color),n.metalness=t.metalness,n.roughness=t.roughness,n.clearcoat=t.clearcoat,n.clearcoatRoughness=t.clearcoatRoughness}),(e,t)=>(za(),Ba("primitive",{object:Da(n)},null,8,ja))}}),{watch:Ha}=await e("vue");async function Ua(e){const t=e.split("/").pop();S.getResource("TextureLoader",e,t);const a=S.getReactiveItem(t);return new Promise((e,t)=>{const n=a();if(n)return void e(n);const r=Ha(()=>a(),a=>{a?(r(),e(a)):t(new Error("useTexture 加载失败，未得到模型"))})})}async function Va(e,t,a,n,r){const o=new e;return r&&r(o),a&&a(o),await new Promise((e,a)=>{o.load(t,t=>{const a=t;a.scene&&Object.assign(a,function(e){const t={nodes:{},materials:{}};return e&&e.traverse(e=>{e.name&&(t.nodes[e.name]=e),e.material&&!t.materials[e.material.name]&&(t.materials[e.material.name]=e.material)}),t}(a.scene)),e(a)},n,e=>{a(e)})})}const{TextureLoader:Ga}=await e("three"),Wa=Array.isArray;async function $a(e,t){const a=new Ga(t),n=e=>new Promise((t,n)=>{a.load(e,e=>t(e),()=>null,()=>{n(new Error("[useTextures] - Failed to load texture"))})});if(Wa(e)){const t=await Promise.all(e.map(e=>n(e)));return e.length>1?t:t[0]}{const{map:t,displacementMap:a,normalMap:r,roughnessMap:o,metalnessMap:l,aoMap:i,alphaMap:s,matcap:c}=e;return{map:t?await n(t):null,displacementMap:a?await n(a):null,normalMap:r?await n(r):null,roughnessMap:o?await n(o):null,metalnessMap:l?await n(l):null,aoMap:i?await n(i):null,alphaMap:s?await n(s):null,matcap:c?await n(c):null}}}const{FrontSide:Ya,BackSide:qa,DoubleSide:Ka,NormalBlending:Za,AdditiveBlending:Xa,SubtractiveBlending:Ja,MultiplyBlending:Qa,NoBlending:en}=await e("three"),tn=[{label:"FrontSide",value:Ya},{label:"BackSide",value:qa},{label:"DoubleSide",value:Ka}],an=[{label:"NoBlending",value:en},{label:"NormalBlending",value:Za},{label:"AdditiveBlending",value:Xa},{label:"SubtractiveBlending",value:Ja},{label:"MultiplyBlending",value:Qa}],nn={color:"#ffffff",map:null,wireframe:!1,opacity:1,transparent:!1,side:Ya,alphaTest:0,blending:Za,depthTest:!0,depthWrite:!0},rn={emissive:"#000000",emissiveIntensity:1,metalness:.5,roughness:.5,metalnessMap:null,roughnessMap:null,normalMap:null,normalScale:{x:1,y:1},bumpMap:null,bumpScale:1,displacementMap:null,displacementScale:1,displacementBias:0,aoMap:null,aoMapIntensity:1,envMap:null,envMapIntensity:1},on={...rn,clearcoat:.2,clearcoatRoughness:.1,reflectivity:.5,transmission:0,ior:1.5,thickness:.01,attenuationColor:"#ffffff",attenuationDistance:0,specularIntensity:1,specularColor:"#ffffff",sheen:0,sheenColor:"#ffffff",clearcoatNormalMap:null,clearcoatNormalScale:{x:1,y:1}},ln={MeshBasicMaterial:{component:"TresMeshBasicMaterial",props:{...nn}},MeshLambertMaterial:{component:"TresMeshLambertMaterial",props:{...nn,emissive:"#000000",emissiveIntensity:1,emissiveMap:null,reflectivity:1,refractionRatio:.98}},MeshPhongMaterial:{component:"TresMeshPhongMaterial",props:{...nn,emissive:"#000000",emissiveIntensity:1,specular:"#111111",shininess:30,specularMap:null,emissiveMap:null,bumpMap:null,bumpScale:1,normalMap:null,normalScale:{x:1,y:1},displacementMap:null,displacementScale:1,displacementBias:0}},MeshStandardMaterial:{component:"TresMeshStandardMaterial",props:{...nn,...rn}},MeshPhysicalMaterial:{component:"TresMeshPhysicalMaterial",props:{...nn,...on}},MeshToonMaterial:{component:"TresMeshToonMaterial",props:{...nn,gradientMap:null,bumpMap:null,bumpScale:1,normalMap:null,normalScale:{x:1,y:1}}},MeshGlassMaterial:{component:async()=>(await M(()=>import("./@tresjs.B1f7s3pS1767066396612.js").then(e=>e.a8),__vite__mapDeps([0,1,2,3,4,5,6]),import.meta.url)).MeshGlassMaterial,props:{...nn,metalness:.5,roughness:0}},TransmissionMaterial:{component:async()=>(await M(()=>import("./index.8btb0a2t1767066396612.js"),__vite__mapDeps([7,8,1,2,3,0,4,5,6,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]),import.meta.url)).TransmissionMaterial,props:{color:"#ffffff",roughness:0,reflectivity:.5,attenuationColor:"#ffffff",attenuationDistance:2,chromaticAberration:.05,anisotropicBlur:.1,distortion:0,temporalDistortion:0,backside:!0,thickness:1,backsideThickness:.5}},ClearcoatMaterial:{component:async()=>(await M(()=>import("./index.8btb0a2t1767066396612.js"),__vite__mapDeps([7,8,1,2,3,0,4,5,6,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]),import.meta.url)).ClearcoatMaterial,props:{color:"#ff00fc",metalness:1,roughness:1,clearcoat:1,clearcoatRoughness:0}},dissolveEffectMaterial:{component:async()=>(await M(()=>import("./index.C8rw211p1767066396612.js"),__vite__mapDeps([25,26,1,2,3,0,4,5,6,27,28,29,30]),import.meta.url)).dissolveEffectMaterial,props:{color:"#B520A9",uEdgeColor:"#4d9bff",uEdge:6,uFreq:.41,uAmp:20,uProgress:-1,metalness:1,roughness:1}}},{markRaw:sn}=await e("vue");const{defineComponent:cn}=await e("vue"),{resolveDynamicComponent:un,mergeProps:mn,openBlock:dn,createBlock:fn}=await e("vue"),{ref:pn,watch:vn}=await e("vue"),hn=cn({__name:"index",props:{type:{},materialProps:{}},setup(e){const t=e,a=pn(null),n=pn({}),r=pn(null);let o=!1;return vn(()=>t.type,async e=>{if(r.value)try{r.value.dispose?.(),console.log("已释放旧材质组件")}catch(i){console.warn("释放材质组件失败:",i)}var l;o=!1,a.value=await async function(e){let t=ln[e].component;return"function"==typeof t&&(t=sn(await t())),t}(e),o=!0,n.value={...(l=e,ln[l].props),...t.materialProps}},{immediate:!0}),vn(()=>[t.type,t.materialProps],([e,t],[a])=>{e===a&&o&&(n.value=t)},{deep:!0}),(e,t)=>(dn(),fn(un(a.value),mn(n.value,{ref_key:"materialRef",ref:r}),null,16))}}),gn={Box:{params:[{key:"width",label:"width",type:"number",default:1},{key:"height",label:"height",type:"number",default:1},{key:"depth",label:"depth",type:"number",default:1},{key:"widthSegments",label:"widthSegments",type:"number",default:1,min:1,max:6,step:1},{key:"heightSegments",label:"heightSegments",type:"number",default:1,min:1,max:6,step:1},{key:"depthSegments",label:"depthSegments",type:"number",default:1,min:1,max:6,step:1}]},Circle:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"segments",label:"segments",type:"number",default:32,min:3,max:64,step:1},{key:"thetaStart",label:"thetaStart",type:"number",default:0,min:0,max:2*Math.PI,step:.01},{key:"thetaLength",label:"thetaLength",type:"number",default:2*Math.PI,min:.1,max:2*Math.PI,step:.01}]},Cone:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"height",label:"height",type:"number",default:2,min:0},{key:"radialSegments",label:"radialSegments",type:"number",default:8,min:3,max:64,step:1},{key:"heightSegments",label:"heightSegments",type:"number",default:1,min:1,max:32,step:1},{key:"openEnded",label:"openEnded",type:"boolean",default:!1},{key:"thetaStart",label:"thetaStart",type:"number",default:0,min:0,max:2*Math.PI,step:.01},{key:"thetaLength",label:"thetaLength",type:"number",default:2*Math.PI,min:.1,max:2*Math.PI,step:.01}]},Cylinder:{params:[{key:"radiusTop",label:"radiusTop",type:"number",default:1,min:0},{key:"radiusBottom",label:"radiusBottom",type:"number",default:1,min:0},{key:"height",label:"height",type:"number",default:2,min:0},{key:"radialSegments",label:"radialSegments",type:"number",default:8,min:3,max:64,step:1},{key:"heightSegments",label:"heightSegments",type:"number",default:1,min:1,max:32,step:1},{key:"openEnded",label:"openEnded",type:"boolean",default:!1},{key:"thetaStart",label:"thetaStart",type:"number",default:0,min:0,max:2*Math.PI,step:.01},{key:"thetaLength",label:"thetaLength",type:"number",default:2*Math.PI,min:.1,max:2*Math.PI,step:.01}]},Dodecahedron:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"detail",label:"detail",type:"number",default:0,min:0,max:5,step:1}]},Icosahedron:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"detail",label:"detail",type:"number",default:0,min:0,max:5,step:1}]},Octahedron:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"detail",label:"detail",type:"number",default:0,min:0,max:5,step:1}]},Plane:{params:[{key:"width",label:"width",type:"number",default:1,min:0},{key:"height",label:"height",type:"number",default:1,min:0},{key:"widthSegments",label:"widthSegments",type:"number",default:1,min:1,max:64,step:1},{key:"heightSegments",label:"heightSegments",type:"number",default:1,min:1,max:64,step:1}]},Ring:{params:[{key:"innerRadius",label:"innerRadius",type:"number",default:.5,min:0},{key:"outerRadius",label:"outerRadius",type:"number",default:1,min:0},{key:"thetaSegments",label:"thetaSegments",type:"number",default:8,min:3,max:64,step:1},{key:"phiSegments",label:"phiSegments",type:"number",default:1,min:1,max:16,step:1},{key:"thetaStart",label:"thetaStart",type:"number",default:0,min:0,max:2*Math.PI,step:.01},{key:"thetaLength",label:"thetaLength",type:"number",default:2*Math.PI,min:.1,max:2*Math.PI,step:.01}]},RoundedBox:{params:[{key:"width",label:"width",type:"number",default:1,min:0},{key:"height",label:"height",type:"number",default:1,min:0},{key:"depth",label:"depth",type:"number",default:1,min:0},{key:"segments",label:"segments",type:"number",default:2,min:0,max:8,step:.1},{key:"radius",label:"radius",type:"number",default:.1,min:0,max:1,step:.01}]},Sphere:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"widthSegments",label:"widthSegments",type:"number",default:32,min:3,max:128,step:1},{key:"heightSegments",label:"heightSegments",type:"number",default:16,min:2,max:128,step:1},{key:"phiStart",label:"phiStart",type:"number",default:0,min:0,max:2*Math.PI,step:.01},{key:"phiLength",label:"phiLength",type:"number",default:2*Math.PI,min:.1,max:2*Math.PI,step:.01},{key:"thetaStart",label:"thetaStart",type:"number",default:0,min:0,max:Math.PI,step:.01},{key:"thetaLength",label:"thetaLength",type:"number",default:Math.PI,min:.1,max:Math.PI,step:.01}]},Tetrahedron:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"detail",label:"detail",type:"number",default:0,min:0,max:5,step:1}]},Torus:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"tube",label:"tube",type:"number",default:.4,min:0},{key:"radialSegments",label:"radialSegments",type:"number",default:8,min:3,max:64,step:1},{key:"tubularSegments",label:"tubularSegments",type:"number",default:64,min:3,max:256,step:1},{key:"arc",label:"arc",type:"number",default:2*Math.PI,min:.1,max:2*Math.PI,step:.01}]},TorusKnot:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"tube",label:"tube",type:"number",default:.4,min:0},{key:"tubularSegments",label:"tubularSegments",type:"number",default:64,min:3,max:256,step:1},{key:"radialSegments",label:"radialSegments",type:"number",default:8,min:3,max:128,step:1},{key:"p",label:"p",type:"number",default:2,min:1,max:10,step:.1},{key:"q",label:"q",type:"number",default:3,min:1,max:10,step:.1}]}},{defineComponent:yn}=await e("vue"),{unref:_n,createVNode:bn,renderList:Sn,Fragment:Mn,openBlock:xn,createElementBlock:wn,mergeProps:kn,createBlock:Pn,createCommentVNode:En,withCtx:Rn}=await e("vue"),In={class:"shape-configurator"},{ref:Cn,reactive:An,computed:Tn,watch:On}=await e("vue"),Dn=yn({__name:"shapeConfigurator",props:{modelValue:{}},emits:["update:modelValue"],setup(e,{emit:t}){const a=e,n=t,r=Object.keys(gn).map(e=>({label:e,value:e})),o=Cn(a.modelValue?.type??"Box"),l=Tn(()=>gn[o.value]),i=An({});function s(e=!0){const t=l.value;if(t)for(const n of t.params)if(i[n.key]=n.default,e&&a.modelValue&&a.modelValue.args){const e=t.params.findIndex(e=>e.key===n.key);-1!==e&&void 0!==a.modelValue.args[e]&&(i[n.key]=a.modelValue.args[e])}}const c=Tn(()=>{const e=l.value;return e?e.params.map(e=>i[e.key]):[]});function u(e){return"number"!==e.type?{}:{min:e.min??.1,max:e.max??5,step:e.step??.1}}return On(()=>({type:o.value,args:c.value}),e=>n("update:modelValue",e),{deep:!0,immediate:!0}),s(),(e,t)=>(xn(),wn("div",In,[bn(_n(x),null,{default:Rn(()=>[bn(_n(w),{vertical:"",size:"small"},{default:Rn(()=>[bn(_n(k),{value:o.value,"onUpdate:value":[t[0]||(t[0]=e=>o.value=e),t[1]||(t[1]=e=>s(!1))],options:_n(r),placeholder:"选择图形类型"},null,8,["value","options"]),l.value?(xn(),Pn(_n(P),{key:0,size:"small","label-placement":"left","label-width":100},{default:Rn(()=>[(xn(!0),wn(Mn,null,Sn(l.value.params,e=>(xn(),wn("div",{key:e.key,style:{"margin-bottom":"12px"}},[bn(_n(E),{label:e.label},{default:Rn(()=>["number"===e.type?(xn(),Pn(_n(R),kn({key:0,size:"tiny",value:i[e.key],"onUpdate:value":t=>i[e.key]=t},{ref_for:!0},u(e),{style:{width:"100%"}}),null,16,["value","onUpdate:value"])):"boolean"===e.type?(xn(),Pn(_n(I),{key:1,size:"small",value:i[e.key],"onUpdate:value":t=>i[e.key]=t},null,8,["value","onUpdate:value"])):En("",!0)]),_:2},1032,["label"])]))),128))]),_:1})):En("",!0)]),_:1})]),_:1})]))}}),{defineComponent:zn}=await e("vue"),{renderSlot:Bn,resolveDynamicComponent:jn,withCtx:Nn,openBlock:Fn,createBlock:Ln,createCommentVNode:Hn}=await e("vue"),{computed:Un}=await e("vue"),Vn=zn({__name:"shapeRenderer",props:{modelValue:{}},setup(e){const t={Box:h,Circle:v,Cone:p,Cylinder:f,Dodecahedron:d,Icosahedron:m,Octahedron:u,Plane:c,Ring:s,RoundedBox:i,Sphere:l,Tetrahedron:o,Torus:r,TorusKnot:n},a=e,g=Un(()=>t[a.modelValue?.type]??null);return(e,t)=>g.value?(Fn(),Ln(jn(g.value),{key:0,args:e.modelValue.args},{default:Nn(()=>[Bn(e.$slots,"default")]),_:3},8,["args"])):Hn("",!0)}}),{defineComponent:Gn}=await e("vue"),{unref:Wn,createVNode:$n,withCtx:Yn,openBlock:qn,createBlock:Kn}=await e("vue"),Zn=Gn({__name:"forEditor",props:{shape:{default:{type:"Box",args:[2,1,1]}},materialType:{type:String,default:"MeshStandardMaterial"},materialProps:{type:Object,required:!0}},setup:e=>(t,a)=>(qn(),Kn(Wn(Vn),{position:[0,.5,0],modelValue:e.shape},{default:Yn(()=>[$n(Wn(hn),{type:e.materialType,"material-props":e.materialProps},null,8,["type","material-props"])]),_:1},8,["modelValue"]))}),{defineComponent:Xn}=await e("vue"),{openBlock:Jn,createElementBlock:Qn}=await e("vue"),er=["object"],{shallowRef:tr,watch:ar,useAttrs:nr}=await e("vue"),rr=await e("three"),or=Xn({__name:"customShaderMaterial",props:{baseMaterial:{},vertexShader:{},fragmentShader:{},uniforms:{}},setup(e){const t=nr(),a=e,n=tr(null);return ar(()=>a.baseMaterial,e=>{n.value&&n.value.dispose(),n.value=new C({baseMaterial:rr[e],vertexShader:a.vertexShader,fragmentShader:a.fragmentShader,uniforms:a.uniforms})},{immediate:!0}),ar(()=>({...t}),e=>{const t=n.value;t&&Object.keys(e).forEach(a=>{if(!(a in t))return;const n=e[a];!0===n&&"boolean"!=typeof t[a]||t[a]!==n&&(t[a]=n,t.needsUpdate=!0)})},{immediate:!0,deep:!1}),(e,t)=>(Jn(),Qn("primitive",{object:n.value},null,8,er))}});export{Gt as C,se as _,ke as a,Ze as b,it as c,St as d,Et as e,Ut as f,La as g,Ua as h,$a as i,Va as j,hn as k,Vn as l,Zn as m,or as n,Dn as o,ln as p,an as q,tn as s,Fe as u};
