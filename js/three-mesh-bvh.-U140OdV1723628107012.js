var t=Object.defineProperty,e=Object.defineProperties,n=Object.getOwnPropertyDescriptors,r=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable,i=(e,n,r)=>n in e?t(e,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[n]=r,a=(t,e)=>{for(var n in e||(e={}))o.call(e,n)&&i(t,n,e[n]);if(r)for(var n of r(e))s.call(e,n)&&i(t,n,e[n]);return t},c=(t,r)=>e(t,n(r));import{a as u,V as l,j as f,e as d,ao as p,af as y,g as h,M as x,f as m,A as g,Z as w,x as B,q as b,R as A}from"./three.LOnTLfxo1723628107012.js";const T=0,P=1,v=2,M=0,U=1,S=2,F=1.25,I=1,_=32,z=65535,V=Math.pow(2,-24),q=Symbol("SKIP_GENERATION");function O(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function C(t,e){if(!t.index){const n=t.attributes.position.count,r=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(n,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new u(r,1));for(let t=0;t<n;t++)r[t]=t}}function E(t){const e=O(t),n=t.drawRange,r=n.start/3,o=(n.start+n.count)/3,s=Math.max(0,r),i=Math.min(e,o)-s;return[{offset:Math.floor(s),count:Math.floor(i)}]}function N(t){if(!t.groups||!t.groups.length)return E(t);const e=[],n=new Set,r=t.drawRange,o=r.start/3,s=(r.start+r.count)/3;for(const a of t.groups){const t=a.start/3,e=(a.start+a.count)/3;n.add(Math.max(o,t)),n.add(Math.min(s,e))}const i=Array.from(n.values()).sort(((t,e)=>t-e));for(let a=0;a<i.length-1;a++){const t=i[a],n=i[a+1];e.push({offset:Math.floor(t),count:Math.floor(n-t)})}return e}function X(t,e,n,r,o){let s=1/0,i=1/0,a=1/0,c=-1/0,u=-1/0,l=-1/0,f=1/0,d=1/0,p=1/0,y=-1/0,h=-1/0,x=-1/0;for(let m=6*e,g=6*(e+n);m<g;m+=6){const e=t[m+0],n=t[m+1],r=e-n,o=e+n;r<s&&(s=r),o>c&&(c=o),e<f&&(f=e),e>y&&(y=e);const g=t[m+2],w=t[m+3],B=g-w,b=g+w;B<i&&(i=B),b>u&&(u=b),g<d&&(d=g),g>h&&(h=g);const A=t[m+4],T=t[m+5],P=A-T,v=A+T;P<a&&(a=P),v>l&&(l=v),A<p&&(p=A),A>x&&(x=A)}r[0]=s,r[1]=i,r[2]=a,r[3]=c,r[4]=u,r[5]=l,o[0]=f,o[1]=d,o[2]=p,o[3]=y,o[4]=h,o[5]=x}function j(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function H(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const o=t[r+3]-t[r];o>n&&(n=o,e=r)}return e}function R(t,e){e.set(t)}function D(t,e,n){let r,o;for(let s=0;s<3;s++){const i=s+3;r=t[s],o=e[s],n[s]=r<o?r:o,r=t[i],o=e[i],n[i]=r>o?r:o}}function L(t,e,n){for(let r=0;r<3;r++){const o=e[t+2*r],s=e[t+2*r+1],i=o-s,a=o+s;i<n[r]&&(n[r]=i),a>n[r+3]&&(n[r+3]=a)}}function Z(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}const k=32,Y=(t,e)=>t.candidate-e.candidate,G=new Array(k).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),W=new Float32Array(6);class K{constructor(){this.boundingData=new Float32Array(6)}}function J(t,e,n,r,o,s){let i=r,a=r+o-1;const c=s.pos,u=2*s.axis;for(;;){for(;i<=a&&n[6*i+u]<c;)i++;for(;i<=a&&n[6*a+u]>=c;)a--;if(!(i<a))return i;for(let t=0;t<3;t++){let n=e[3*i+t];e[3*i+t]=e[3*a+t],e[3*a+t]=n}for(let t=0;t<6;t++){let e=n[6*i+t];n[6*i+t]=n[6*a+t],n[6*a+t]=e}i++,a--}}function Q(t,e,n,r,o,s){let i=r,a=r+o-1;const c=s.pos,u=2*s.axis;for(;;){for(;i<=a&&n[6*i+u]<c;)i++;for(;i<=a&&n[6*a+u]>=c;)a--;if(!(i<a))return i;{let e=t[i];t[i]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=n[6*i+t];n[6*i+t]=n[6*a+t],n[6*a+t]=e}i++,a--}}}function $(t,e){return 65535===e[t+15]}function tt(t,e){return e[t+6]}function et(t,e){return e[t+14]}function nt(t){return t+8}function rt(t,e){return e[t+6]}function ot(t,e){return e[t+7]}let st,it,at,ct;const ut=Math.pow(2,32);function lt(t){return"count"in t?1:1+lt(t.left)+lt(t.right)}function ft(t,e,n){return st=new Float32Array(n),it=new Uint32Array(n),at=new Uint16Array(n),ct=new Uint8Array(n),dt(t,e)}function dt(t,e){const n=t/4,r=t/2,o="count"in e,s=e.boundingData;for(let i=0;i<6;i++)st[n+i]=s[i];if(o){if(e.buffer){const r=e.buffer;ct.set(new Uint8Array(r),t);for(let e=t,o=t+r.byteLength;e<o;e+=_){$(e/2,at)||(it[e/4+6]+=n)}return t+r.byteLength}{const o=e.offset,s=e.count;return it[n+6]=o,at[r+14]=s,at[r+15]=z,t+_}}{const r=e.left,o=e.right,s=e.splitAxis;let i;if(i=dt(t+_,r),i/4>ut)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return it[n+6]=i/4,i=dt(i,o),it[n+7]=s,i}}function pt(t,e,n,r,o){const{maxDepth:s,verbose:i,maxLeafTris:a,strategy:c,onProgress:u,indirect:l}=o,f=t._indirectBuffer,d=t.geometry,p=d.index?d.index.array:null,y=l?Q:J,h=O(d),x=new Float32Array(6);let m=!1;const g=new K;return X(e,n,r,g.boundingData,x),function t(n,r,o,u=null,l=0){!m&&l>=s&&(m=!0,i&&(console.warn("MeshBVH: Max depth of ".concat(s," reached when generating BVH. Consider increasing maxDepth.")),console.warn(d)));if(o<=a||l>=s)return w(r+o),n.offset=r,n.count=o,n;const h=function(t,e,n,r,o,s){let i=-1,a=0;if(s===T)i=H(e),-1!==i&&(a=(e[i]+e[i+3])/2);else if(s===P)i=H(t),-1!==i&&(a=function(t,e,n,r){let o=0;for(let s=e,i=e+n;s<i;s++)o+=t[6*s+2*r];return o/n}(n,r,o,i));else if(s===v){const s=Z(t);let c=F*o;const u=6*r,l=6*(r+o);for(let t=0;t<3;t++){const r=e[t],f=(e[t+3]-r)/k;if(o<k/4){const e=[...G];e.length=o;let r=0;for(let o=u;o<l;o+=6,r++){const s=e[r];s.candidate=n[o+2*t],s.count=0;const{bounds:i,leftCacheBounds:a,rightCacheBounds:c}=s;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,i[t]=1/0,i[t+3]=-1/0;L(o,n,i)}e.sort(Y);let f=o;for(let t=0;t<f;t++){const n=e[t];for(;t+1<f&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),f--}for(let o=u;o<l;o+=6){const r=n[o+2*t];for(let t=0;t<f;t++){const s=e[t];r>=s.candidate?L(o,n,s.rightCacheBounds):(L(o,n,s.leftCacheBounds),s.count++)}}for(let n=0;n<f;n++){const r=e[n],u=r.count,l=o-r.count,f=r.leftCacheBounds,d=r.rightCacheBounds;let p=0;0!==u&&(p=Z(f)/s);let y=0;0!==l&&(y=Z(d)/s);const h=I+F*(p*u+y*l);h<c&&(i=t,c=h,a=r.candidate)}}else{for(let t=0;t<k;t++){const e=G[t];e.count=0,e.candidate=r+f+t*f;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let o=u;o<l;o+=6){let e=~~((n[o+2*t]-r)/f);e>=k&&(e=k-1);const s=G[e];s.count++,L(o,n,s.bounds)}const e=G[k-1];R(e.bounds,e.rightCacheBounds);for(let t=k-2;t>=0;t--){const e=G[t],n=G[t+1];D(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let d=0;for(let n=0;n<k-1;n++){const e=G[n],r=e.count,u=e.bounds,l=G[n+1].rightCacheBounds;0!==r&&(0===d?R(u,W):D(u,W,W)),d+=r;let f=0,p=0;0!==d&&(f=Z(W)/s);const y=o-d;0!==y&&(p=Z(l)/s);const h=I+F*(f*d+p*y);h<c&&(i=t,c=h,a=e.candidate)}}}}else console.warn("MeshBVH: Invalid build strategy value ".concat(s," used."));return{axis:i,pos:a}}(n.boundingData,u,e,r,o,c);if(-1===h.axis)return w(r+o),n.offset=r,n.count=o,n;const g=y(f,p,e,r,o,h);if(g===r||g===r+o)w(r+o),n.offset=r,n.count=o;else{n.splitAxis=h.axis;const s=new K,i=r,a=g-r;n.left=s,X(e,i,a,s.boundingData,x),t(s,i,a,x,l+1);const c=new K,u=g,f=o-a;n.right=c,X(e,u,f,c.boundingData,x),t(c,u,f,x,l+1)}return n}(g,n,r,x),g;function w(t){u&&u(t/h)}}function yt(t,e){const n=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const n=(t.index?t.index.count:t.attributes.position.count)/3,r=n>65536,o=r?4:2,s=e?new SharedArrayBuffer(n*o):new ArrayBuffer(n*o),i=r?new Uint32Array(s):new Uint16Array(s);for(let a=0,c=i.length;a<c;a++)i[a]=a;return i}(n,e.useSharedArrayBuffer),function(t){if(0===t.groups.length)return!1;const e=O(t),n=N(t).sort(((t,e)=>t.offset-e.offset)),r=n[n.length-1];r.count=Math.min(e-r.offset,r.count);let o=0;return n.forEach((({count:t})=>o+=t)),e!==o}(n)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||C(n,e);const r=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=function(t,e=null,n=null,r=null){const o=t.attributes.position,s=t.index?t.index.array:null,i=O(t),a=o.normalized;let c;null===e?(c=new Float32Array(6*i*4),n=0,r=i):(c=e,n=n||0,r=r||i);const u=o.array,l=o.offset||0;let f=3;o.isInterleavedBufferAttribute&&(f=o.data.stride);const d=["getX","getY","getZ"];for(let p=n;p<n+r;p++){const t=3*p,e=6*p;let n=t+0,r=t+1,i=t+2;s&&(n=s[n],r=s[r],i=s[i]),a||(n=n*f+l,r=r*f+l,i=i*f+l);for(let s=0;s<3;s++){let t,l,f;a?(t=o[d[s]](n),l=o[d[s]](r),f=o[d[s]](i)):(t=u[n+s],l=u[r+s],f=u[i+s]);let p=t;l<p&&(p=l),f<p&&(p=f);let y=t;l>y&&(y=l),f>y&&(y=f);const h=(y-p)/2,x=2*s;c[e+x+0]=p+h,c[e+x+1]=h+(Math.abs(p)+h)*V}}return c}(n),s=e.indirect?E(n):N(n);t._roots=s.map((n=>{const s=pt(t,o,n.offset,n.count,e),i=lt(s),a=new r(_*i);return ft(0,s,a),a}))}class ht{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,r=-1/0;for(let o=0,s=t.length;o<s;o++){const s=t[o][e];n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}setFromPoints(t,e){let n=1/0,r=-1/0;for(let o=0,s=e.length;o<s;o++){const s=e[o],i=t.dot(s);n=i<n?i:n,r=i>r?i:r}this.min=n,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}ht.prototype.setFromBox=function(){const t=new l;return function(e,n){const r=n.min,o=n.max;let s=1/0,i=-1/0;for(let a=0;a<=1;a++)for(let n=0;n<=1;n++)for(let c=0;c<=1;c++){t.x=r.x*a+o.x*(1-a),t.y=r.y*n+o.y*(1-n),t.z=r.z*c+o.z*(1-c);const u=e.dot(t);s=Math.min(u,s),i=Math.max(u,i)}this.min=s,this.max=i}}();const xt=function(){const t=new l,e=new l,n=new l;return function(r,o,s){const i=r.start,a=t,c=o.start,u=e;n.subVectors(i,c),t.subVectors(r.end,r.start),e.subVectors(o.end,o.start);const l=n.dot(u),f=u.dot(a),d=u.dot(u),p=n.dot(a),y=a.dot(a)*d-f*f;let h,x;h=0!==y?(l*f-p*d)/y:0,x=(l+h*f)/d,s.x=h,s.y=x}}(),mt=function(){const t=new f,e=new l,n=new l;return function(r,o,s,i){xt(r,o,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return r.at(a,s),void o.at(c,i);if(a>=0&&a<=1)return c<0?o.at(0,i):o.at(1,i),void r.closestPointToPoint(i,!0,s);if(c>=0&&c<=1)return a<0?r.at(0,s):r.at(1,s),void o.closestPointToPoint(s,!0,i);{let t,u;t=a<0?r.start:r.end,u=c<0?o.start:o.end;const l=e,f=n;return r.closestPointToPoint(u,!0,e),o.closestPointToPoint(t,!0,n),l.distanceToSquared(u)<=f.distanceToSquared(t)?(s.copy(l),void i.copy(u)):(s.copy(t),void i.copy(f))}}}(),gt=function(){const t=new l,e=new l,n=new d,r=new p;return function(o,s){const{radius:i,center:a}=o,{a:c,b:u,c:l}=s;r.start=c,r.end=u;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;r.start=c,r.end=l;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;r.start=u,r.end=l;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;const f=s.getPlane(n);if(Math.abs(f.distanceToPoint(a))<=i){const t=f.projectPoint(a,e);if(s.containsPoint(t))return!0}return!1}}();function wt(t){return Math.abs(t)<1e-15}class Bt extends y{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new l)),this.satBounds=new Array(4).fill().map((()=>new ht)),this.points=[this.a,this.b,this.c],this.sphere=new h,this.plane=new d,this.needsUpdate=!0}intersectsSphere(t){return gt(t,this)}update(){const t=this.a,e=this.b,n=this.c,r=this.points,o=this.satAxes,s=this.satBounds,i=o[0],a=s[0];this.getNormal(i),a.setFromPoints(i,r);const c=o[1],u=s[1];c.subVectors(t,e),u.setFromPoints(c,r);const l=o[2],f=s[2];l.subVectors(e,n),f.setFromPoints(l,r);const d=o[3],p=s[3];d.subVectors(n,t),p.setFromPoints(d,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(i,t),this.needsUpdate=!1}}Bt.prototype.closestPointToSegment=function(){const t=new l,e=new l,n=new p;return function(r,o=null,s=null){const{start:i,end:a}=r,c=this.points;let u,l=1/0;for(let f=0;f<3;f++){const i=(f+1)%3;n.start.copy(c[f]),n.end.copy(c[i]),mt(n,r,t,e),u=t.distanceToSquared(e),u<l&&(l=u,o&&o.copy(t),s&&s.copy(e))}return this.closestPointToPoint(i,t),u=i.distanceToSquared(t),u<l&&(l=u,o&&o.copy(t),s&&s.copy(i)),this.closestPointToPoint(a,t),u=a.distanceToSquared(t),u<l&&(l=u,o&&o.copy(t),s&&s.copy(a)),Math.sqrt(l)}}(),Bt.prototype.intersectsTriangle=function(){const t=new Bt,e=new Array(3),n=new Array(3),r=new ht,o=new ht,s=new l,i=new l,a=new l,c=new l,u=new l,f=new p,d=new p,y=new p,h=new l;function x(t,e,n){const r=t.points;let o=0,s=-1;for(let a=0;a<3;a++){const{start:t,end:c}=f;t.copy(r[a]),c.copy(r[(a+1)%3]),f.delta(i);const u=wt(e.distanceToPoint(t));if(wt(e.normal.dot(i))&&u){n.copy(f),o=2;break}const l=e.intersectLine(f,h);if(!l&&u&&h.copy(t),(l||u)&&!wt(h.distanceTo(c))){if(o<=1){(1===o?n.start:n.end).copy(h),u&&(s=o)}else if(o>=2){(1===s?n.start:n.end).copy(h),o=2;break}if(o++,2===o&&-1===s)break}}return o}return function(i,l=null,f=!1){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(t.copy(i),t.update(),i=t);const p=this.plane,h=i.plane;if(Math.abs(p.normal.dot(h.normal))>1-1e-10){const t=this.satBounds,a=this.satAxes;n[0]=i.a,n[1]=i.b,n[2]=i.c;for(let e=0;e<4;e++){const o=t[e],s=a[e];if(r.setFromPoints(s,n),o.isSeparated(r))return!1}const c=i.satBounds,u=i.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let n=0;n<4;n++){const t=c[n],o=u[n];if(r.setFromPoints(o,e),t.isSeparated(r))return!1}for(let i=0;i<4;i++){const t=a[i];for(let i=0;i<4;i++){const a=u[i];if(s.crossVectors(t,a),r.setFromPoints(s,e),o.setFromPoints(s,n),r.isSeparated(o))return!1}}return l&&(f||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),l.start.set(0,0,0),l.end.set(0,0,0)),!0}{const t=x(this,h,d);if(1===t&&i.containsPoint(d.end))return l&&(l.start.copy(d.end),l.end.copy(d.end)),!0;if(2!==t)return!1;const e=x(i,p,y);if(1===e&&this.containsPoint(y.end))return l&&(l.start.copy(y.end),l.end.copy(y.end)),!0;if(2!==e)return!1;if(d.delta(a),y.delta(c),a.dot(c)<0){let t=y.start;y.start=y.end,y.end=t}const n=d.start.dot(a),r=d.end.dot(a),o=y.start.dot(a),s=y.end.dot(a);return(n===s||o===r||r<o!==n<s)&&(l&&(u.subVectors(d.start,y.start),u.dot(a)>0?l.start.copy(d.start):l.start.copy(y.start),u.subVectors(d.end,y.end),u.dot(a)<0?l.end.copy(d.end):l.end.copy(y.end)),!0)}}}(),Bt.prototype.distanceToPoint=function(){const t=new l;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),Bt.prototype.distanceToTriangle=function(){const t=new l,e=new l,n=["a","b","c"],r=new p,o=new p;return function(s,i=null,a=null){const c=i||a?r:null;if(this.intersectsTriangle(s,c))return(i||a)&&(i&&c.getCenter(i),a&&c.getCenter(a)),0;let u=1/0;for(let e=0;e<3;e++){let r;const o=n[e],c=s[o];this.closestPointToPoint(c,t),r=c.distanceToSquared(t),r<u&&(u=r,i&&i.copy(t),a&&a.copy(c));const l=this[o];s.closestPointToPoint(l,t),r=l.distanceToSquared(t),r<u&&(u=r,i&&i.copy(l),a&&a.copy(t))}for(let l=0;l<3;l++){const c=n[l],f=n[(l+1)%3];r.set(this[c],this[f]);for(let l=0;l<3;l++){const c=n[l],f=n[(l+1)%3];o.set(s[c],s[f]),mt(r,o,t,e);const d=t.distanceToSquared(e);d<u&&(u=d,i&&i.copy(t),a&&a.copy(e))}}return Math.sqrt(u)}}();class bt{constructor(t,e,n){this.isOrientedBox=!0,this.min=new l,this.max=new l,this.matrix=new x,this.invMatrix=new x,this.points=new Array(8).fill().map((()=>new l)),this.satAxes=new Array(3).fill().map((()=>new l)),this.satBounds=new Array(3).fill().map((()=>new ht)),this.alignedSatBounds=new Array(3).fill().map((()=>new ht)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}bt.prototype.update=function(){return function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let c=0;c<=1;c++)for(let o=0;o<=1;o++)for(let s=0;s<=1;s++){const i=r[1*c|2*o|4*s];i.x=c?n.x:e.x,i.y=o?n.y:e.y,i.z=s?n.z:e.z,i.applyMatrix4(t)}const o=this.satBounds,s=this.satAxes,i=r[0];for(let c=0;c<3;c++){const t=s[c],e=o[c],n=r[1<<c];t.subVectors(i,n),e.setFromPoints(t,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}(),bt.prototype.intersectsBox=function(){const t=new ht;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,o=this.satBounds,s=this.satAxes,i=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,i[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,i[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,i[2].isSeparated(t))return!1;for(let a=0;a<3;a++){const n=s[a],r=o[a];if(t.setFromBox(n,e),r.isSeparated(t))return!1}return!0}}(),bt.prototype.intersectsTriangle=function(){const t=new Bt,e=new Array(3),n=new ht,r=new ht,o=new l;return function(s){this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const i=this.satBounds,a=this.satAxes;e[0]=s.a,e[1]=s.b,e[2]=s.c;for(let t=0;t<3;t++){const r=i[t],o=a[t];if(n.setFromPoints(o,e),r.isSeparated(n))return!1}const c=s.satBounds,u=s.satAxes,l=this.points;for(let t=0;t<3;t++){const e=c[t],r=u[t];if(n.setFromPoints(r,l),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const s=a[t];for(let t=0;t<4;t++){const i=u[t];if(o.crossVectors(s,i),n.setFromPoints(o,e),r.setFromPoints(o,l),n.isSeparated(r))return!1}}return!0}}(),bt.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}(),bt.prototype.distanceToPoint=function(){const t=new l;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),bt.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new p)),n=new Array(12).fill().map((()=>new p)),r=new l,o=new l;return function(s,i=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(s))return(a||c)&&(s.getCenter(o),this.closestPointToPoint(o,r),s.closestPointToPoint(r,o),a&&a.copy(r),c&&c.copy(o)),0;const u=i*i,l=s.min,f=s.max,d=this.points;let p=1/0;for(let t=0;t<8;t++){const e=d[t];o.copy(e).clamp(l,f);const n=e.distanceToSquared(o);if(n<p&&(p=n,a&&a.copy(e),c&&c.copy(o),n<u))return Math.sqrt(n)}let y=0;for(let r=0;r<3;r++)for(let o=0;o<=1;o++)for(let s=0;s<=1;s++){const i=(r+1)%3,a=(r+2)%3,c=1<<r|o<<i|s<<a,u=d[o<<i|s<<a],p=d[c];e[y].set(u,p);const h=t[r],x=t[i],m=t[a],g=n[y],w=g.start,B=g.end;w[h]=l[h],w[x]=o?l[x]:f[x],w[m]=s?l[m]:f[x],B[h]=f[h],B[x]=o?l[x]:f[x],B[m]=s?l[m]:f[x],y++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){o.x=t?f.x:l.x,o.y=e?f.y:l.y,o.z=n?f.z:l.z,this.closestPointToPoint(o,r);const s=o.distanceToSquared(r);if(s<p&&(p=s,a&&a.copy(r),c&&c.copy(o),s<u))return Math.sqrt(s)}for(let t=0;t<12;t++){const s=e[t];for(let t=0;t<12;t++){const e=n[t];mt(s,e,r,o);const i=r.distanceToSquared(o);if(i<p&&(p=i,a&&a.copy(r),c&&c.copy(o),i<u))return Math.sqrt(i)}}return Math.sqrt(p)}}();class At{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Tt extends At{constructor(){super((()=>new Bt))}}const Pt=new Tt;const vt=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let Mt,Ut;const St=[],Ft=new At((()=>new m));function It(t,e,n,r,o,s){Mt=Ft.getPrimitive(),Ut=Ft.getPrimitive(),St.push(Mt,Ut),vt.setBuffer(t._roots[e]);const i=_t(0,t.geometry,n,r,o,s);vt.clearBuffer(),Ft.releasePrimitive(Mt),Ft.releasePrimitive(Ut),St.pop(),St.pop();const a=St.length;return a>0&&(Ut=St[a-1],Mt=St[a-2]),i}function _t(t,e,n,r,o=null,s=0,i=0){const{float32Array:a,uint16Array:c,uint32Array:u}=vt;let l=2*t;if($(l,c)){const e=tt(t,u),n=et(l,c);return j(t,a,Mt),r(e,n,!1,i,s+t,Mt)}{let l=function(t){const{uint16Array:e,uint32Array:n}=vt;let r=2*t;for(;!$(r,e);)r=2*(t=nt(t));return tt(t,n)},f=function(t){const{uint16Array:e,uint32Array:n}=vt;let r=2*t;for(;!$(r,e);)r=2*(t=rt(t,n));return tt(t,n)+et(r,e)};const d=nt(t),p=rt(t,u);let y,h,x,m,g=d,w=p;if(o&&(x=Mt,m=Ut,j(g,a,x),j(w,a,m),y=o(x),h=o(m),h<y)){g=p,w=d;const t=y;y=h,h=t,x=m}x||(x=Mt,j(g,a,x));const B=n(x,$(2*g,c),y,i+1,s+g);let b;if(B===S){const t=l(g);b=r(t,f(g)-t,!0,i+1,s+g,x)}else b=B&&_t(g,e,n,r,o,s,i+1);if(b)return!0;m=Ut,j(w,a,m);const A=n(m,$(2*w,c),h,i+1,s+w);let T;if(A===S){const t=l(w);T=r(t,f(w)-t,!0,i+1,s+w,m)}else T=A&&_t(w,e,n,r,o,s,i+1);return!!T}}const zt=new l,Vt=new l;const qt=new l,Ot=new l,Ct=new l,Et=new f,Nt=new f,Xt=new f,jt=new l,Ht=new l,Rt=new l,Dt=new l;function Lt(t,e,n,r,o,s,i,a,c,u,d){qt.fromBufferAttribute(e,s),Ot.fromBufferAttribute(e,i),Ct.fromBufferAttribute(e,a);const p=function(t,e,n,r,o,s,i,a){let c;if(c=s===g?t.intersectTriangle(r,n,e,!0,o):t.intersectTriangle(e,n,r,s!==w,o),null===c)return null;const u=t.origin.distanceTo(o);return u<i||u>a?null:{distance:u,point:o.clone()}}(t,qt,Ot,Ct,Dt,c,u,d);if(p){r&&(Et.fromBufferAttribute(r,s),Nt.fromBufferAttribute(r,i),Xt.fromBufferAttribute(r,a),p.uv=y.getInterpolation(Dt,qt,Ot,Ct,Et,Nt,Xt,new f)),o&&(Et.fromBufferAttribute(o,s),Nt.fromBufferAttribute(o,i),Xt.fromBufferAttribute(o,a),p.uv1=y.getInterpolation(Dt,qt,Ot,Ct,Et,Nt,Xt,new f)),n&&(jt.fromBufferAttribute(n,s),Ht.fromBufferAttribute(n,i),Rt.fromBufferAttribute(n,a),p.normal=y.getInterpolation(Dt,qt,Ot,Ct,jt,Ht,Rt,new l),p.normal.dot(t.direction)>0&&p.normal.multiplyScalar(-1));const e={a:s,b:i,c:a,normal:new l,materialIndex:0};y.getNormal(qt,Ot,Ct,e.normal),p.face=e,p.faceIndex=s}return p}function Zt(t,e,n,r,o,s,i){const a=3*r;let c=a+0,u=a+1,l=a+2;const f=t.index;t.index&&(c=f.getX(c),u=f.getX(u),l=f.getX(l));const{position:d,normal:p,uv:y,uv1:h}=t.attributes,x=Lt(n,d,p,y,h,c,u,l,e,s,i);return x?(x.faceIndex=r,o&&o.push(x),x):null}function kt(t,e,n,r){const o=t.a,s=t.b,i=t.c;let a=e,c=e+1,u=e+2;n&&(a=n.getX(a),c=n.getX(c),u=n.getX(u)),o.x=r.getX(a),o.y=r.getY(a),o.z=r.getZ(a),s.x=r.getX(c),s.y=r.getY(c),s.z=r.getZ(c),i.x=r.getX(u),i.y=r.getY(u),i.z=r.getZ(u)}function Yt(t,e,n,r,o,s,i){const{geometry:a}=n,{index:c}=a,u=a.attributes.position;for(let l=t,f=e+t;l<f;l++){let t;if(t=l,kt(i,3*t,c,u),i.needsUpdate=!0,r(i,t,o,s))return!0}return!1}function Gt(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let s,i,a,c,u=0;const l=t._roots;for(let d=0,p=l.length;d<p;d++)s=l[d],i=new Uint32Array(s),a=new Uint16Array(s),c=new Float32Array(s),f(0,u),u+=s.byteLength;function f(t,n,s=!1){const u=2*t;if(a[u+15]===z){const e=i[t+6];let n=1/0,s=1/0,l=1/0,f=-1/0,d=-1/0,p=-1/0;for(let t=3*e,i=3*(e+a[u+14]);t<i;t++){let e=r[t];const i=o.getX(e),a=o.getY(e),c=o.getZ(e);i<n&&(n=i),i>f&&(f=i),a<s&&(s=a),a>d&&(d=a),c<l&&(l=c),c>p&&(p=c)}return(c[t+0]!==n||c[t+1]!==s||c[t+2]!==l||c[t+3]!==f||c[t+4]!==d||c[t+5]!==p)&&(c[t+0]=n,c[t+1]=s,c[t+2]=l,c[t+3]=f,c[t+4]=d,c[t+5]=p,!0)}{const r=t+8,o=i[t+6],a=r+n,u=o+n;let l=s,d=!1,p=!1;e?l||(d=e.has(a),p=e.has(u),l=!d&&!p):(d=!0,p=!0);const y=l||p;let h=!1;(l||d)&&(h=f(r,n,l));let x=!1;y&&(x=f(o,n,l));const m=h||x;if(m)for(let e=0;e<3;e++){const n=r+e,s=o+e,i=c[n],a=c[n+3],u=c[s],l=c[s+3];c[t+e]=i<u?i:u,c[t+e+3]=a>l?a:l}return m}}}function Wt(t,e,n,r,o){let s,i,a,c,u,l;const f=1/n.direction.x,d=1/n.direction.y,p=1/n.direction.z,y=n.origin.x,h=n.origin.y,x=n.origin.z;let m=e[t],g=e[t+3],w=e[t+1],B=e[t+3+1],b=e[t+2],A=e[t+3+2];return f>=0?(s=(m-y)*f,i=(g-y)*f):(s=(g-y)*f,i=(m-y)*f),d>=0?(a=(w-h)*d,c=(B-h)*d):(a=(B-h)*d,c=(w-h)*d),!(s>c||a>i)&&((a>s||isNaN(s))&&(s=a),(c<i||isNaN(i))&&(i=c),p>=0?(u=(b-x)*p,l=(A-x)*p):(u=(A-x)*p,l=(b-x)*p),!(s>l||u>i)&&((u>s||s!=s)&&(s=u),(l<i||i!=i)&&(i=l),s<=o&&i>=r))}function Kt(t,e,n,r,o,s,i){const{geometry:a}=n,{index:c}=a,u=a.attributes.position;for(let l=t,f=e+t;l<f;l++){let t;if(t=n.resolveTriangleIndex(l),kt(i,3*t,c,u),i.needsUpdate=!0,r(i,t,o,s))return!0}return!1}function Jt(t,e,n,r,o,s,i){vt.setBuffer(t._roots[e]),Qt(0,t,n,r,o,s,i),vt.clearBuffer()}function Qt(t,e,n,r,o,s,i){const{float32Array:a,uint16Array:c,uint32Array:u}=vt,l=2*t;if($(l,c)){!function(t,e,n,r,o,s,i,a){const{geometry:c,_indirectBuffer:u}=t;for(let l=r,f=r+o;l<f;l++)Zt(c,e,n,l,s,i,a)}(e,n,r,tt(t,u),et(l,c),o,s,i)}else{const c=nt(t);Wt(c,a,r,s,i)&&Qt(c,e,n,r,o,s,i);const l=rt(t,u);Wt(l,a,r,s,i)&&Qt(l,e,n,r,o,s,i)}}const $t=["x","y","z"];function te(t,e,n,r,o,s){vt.setBuffer(t._roots[e]);const i=ee(0,t,n,r,o,s);return vt.clearBuffer(),i}function ee(t,e,n,r,o,s){const{float32Array:i,uint16Array:a,uint32Array:c}=vt;let u=2*t;if($(u,a)){return function(t,e,n,r,o,s,i){const{geometry:a,_indirectBuffer:c}=t;let u=1/0,l=null;for(let f=r,d=r+o;f<d;f++){let t;t=Zt(a,e,n,f,null,s,i),t&&t.distance<u&&(l=t,u=t.distance)}return l}(e,n,r,tt(t,c),et(u,a),o,s)}{const a=ot(t,c),u=$t[a],l=r.direction[u]>=0;let f,d;l?(f=nt(t),d=rt(t,c)):(f=rt(t,c),d=nt(t));const p=Wt(f,i,r,o,s)?ee(f,e,n,r,o,s):null;if(p){const t=p.point[u];if(l?t<=i[d+a]:t>=i[d+a+3])return p}const y=Wt(d,i,r,o,s)?ee(d,e,n,r,o,s):null;return p&&y?p.distance<=y.distance?p:y:p||y||null}}const ne=new m,re=new Bt,oe=new Bt,se=new x,ie=new bt,ae=new bt;function ce(t,e,n,r){vt.setBuffer(t._roots[e]);const o=ue(0,t,n,r);return vt.clearBuffer(),o}function ue(t,e,n,r,o=null){const{float32Array:s,uint16Array:i,uint32Array:a}=vt;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),ie.set(n.boundingBox.min,n.boundingBox.max,r),o=ie);if(!$(c,i)){const i=t+8,c=a[t+6];j(i,s,ne);if(o.intersectsBox(ne)&&ue(i,e,n,r,o))return!0;j(c,s,ne);return!!(o.intersectsBox(ne)&&ue(c,e,n,r,o))}{const o=e.geometry,u=o.index,l=o.attributes.position,f=n.index,d=n.attributes.position,p=tt(t,a),y=et(c,i);if(se.copy(r).invert(),n.boundsTree){j(t,s,ae),ae.matrix.copy(se),ae.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>ae.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let e=3*p,n=3*(y+p);e<n;e+=3)if(kt(oe,e,u,l),oe.needsUpdate=!0,t.intersectsTriangle(oe))return!0;return!1}})}for(let t=3*p,e=3*(y+p);t<e;t+=3){kt(re,t,u,l),re.a.applyMatrix4(se),re.b.applyMatrix4(se),re.c.applyMatrix4(se),re.needsUpdate=!0;for(let t=0,e=f.count;t<e;t+=3)if(kt(oe,t,f,d),oe.needsUpdate=!0,re.intersectsTriangle(oe))return!0}}}const le=new x,fe=new bt,de=new bt,pe=new l,ye=new l,he=new l,xe=new l;function me(t,e,n,r={},o={},s=0,i=1/0){e.boundingBox||e.computeBoundingBox(),fe.set(e.boundingBox.min,e.boundingBox.max,n),fe.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,u=a.index,l=e.attributes.position,f=e.index,d=Pt.getPrimitive(),p=Pt.getPrimitive();let y=pe,h=ye,x=null,m=null;o&&(x=he,m=xe);let g=1/0,w=null,B=null;return le.copy(n).invert(),de.matrix.copy(le),t.shapecast({boundsTraverseOrder:t=>fe.distanceToBox(t),intersectsBounds:(t,e,n)=>n<g&&n<i&&(e&&(de.min.copy(t.min),de.max.copy(t.max),de.needsUpdate=!0),!0),intersectsRange:(t,r)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>de.distanceToBox(t),intersectsBounds:(t,e,n)=>n<g&&n<i,intersectsRange:(e,o)=>{for(let i=e,a=e+o;i<a;i++){kt(p,3*i,f,l),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){kt(d,3*e,u,c),d.needsUpdate=!0;const t=d.distanceToTriangle(p,y,x);if(t<g&&(h.copy(y),m&&m.copy(x),g=t,w=e,B=i),t<s)return!0}}}})}for(let o=0,i=O(e);o<i;o++){kt(p,3*o,f,l),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){kt(d,3*e,u,c),d.needsUpdate=!0;const t=d.distanceToTriangle(p,y,x);if(t<g&&(h.copy(y),m&&m.copy(x),g=t,w=e,B=o),t<s)return!0}}}}),Pt.releasePrimitive(d),Pt.releasePrimitive(p),g===1/0?null:(r.point?r.point.copy(h):r.point=h.clone(),r.distance=g,r.faceIndex=w,o&&(o.point?o.point.copy(m):o.point=m.clone(),o.point.applyMatrix4(le),h.applyMatrix4(le),o.distance=h.sub(o.point).length(),o.faceIndex=B),r)}function ge(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let s,i,a,c,u=0;const l=t._roots;for(let d=0,p=l.length;d<p;d++)s=l[d],i=new Uint32Array(s),a=new Uint16Array(s),c=new Float32Array(s),f(0,u),u+=s.byteLength;function f(n,s,u=!1){const l=2*n;if(a[l+15]===z){const e=i[n+6];let s=1/0,u=1/0,f=1/0,d=-1/0,p=-1/0,y=-1/0;for(let n=e,i=e+a[l+14];n<i;n++){const e=3*t.resolveTriangleIndex(n);for(let t=0;t<3;t++){let n=e+t;n=r?r[n]:n;const i=o.getX(n),a=o.getY(n),c=o.getZ(n);i<s&&(s=i),i>d&&(d=i),a<u&&(u=a),a>p&&(p=a),c<f&&(f=c),c>y&&(y=c)}}return(c[n+0]!==s||c[n+1]!==u||c[n+2]!==f||c[n+3]!==d||c[n+4]!==p||c[n+5]!==y)&&(c[n+0]=s,c[n+1]=u,c[n+2]=f,c[n+3]=d,c[n+4]=p,c[n+5]=y,!0)}{const t=n+8,r=i[n+6],o=t+s,a=r+s;let l=u,d=!1,p=!1;e?l||(d=e.has(o),p=e.has(a),l=!d&&!p):(d=!0,p=!0);const y=l||p;let h=!1;(l||d)&&(h=f(t,s,l));let x=!1;y&&(x=f(r,s,l));const m=h||x;if(m)for(let e=0;e<3;e++){const o=t+e,s=r+e,i=c[o],a=c[o+3],u=c[s],l=c[s+3];c[n+e]=i<u?i:u,c[n+e+3]=a>l?a:l}return m}}}function we(t,e,n,r,o,s,i){vt.setBuffer(t._roots[e]),Be(0,t,n,r,o,s,i),vt.clearBuffer()}function Be(t,e,n,r,o,s,i){const{float32Array:a,uint16Array:c,uint32Array:u}=vt,l=2*t;if($(l,c)){!function(t,e,n,r,o,s,i,a){const{geometry:c,_indirectBuffer:u}=t;for(let l=r,f=r+o;l<f;l++)Zt(c,e,n,u?u[l]:l,s,i,a)}(e,n,r,tt(t,u),et(l,c),o,s,i)}else{const c=nt(t);Wt(c,a,r,s,i)&&Be(c,e,n,r,o,s,i);const l=rt(t,u);Wt(l,a,r,s,i)&&Be(l,e,n,r,o,s,i)}}const be=["x","y","z"];function Ae(t,e,n,r,o,s){vt.setBuffer(t._roots[e]);const i=Te(0,t,n,r,o,s);return vt.clearBuffer(),i}function Te(t,e,n,r,o,s){const{float32Array:i,uint16Array:a,uint32Array:c}=vt;let u=2*t;if($(u,a)){return function(t,e,n,r,o,s,i){const{geometry:a,_indirectBuffer:c}=t;let u=1/0,l=null;for(let f=r,d=r+o;f<d;f++){let t;t=Zt(a,e,n,c?c[f]:f,null,s,i),t&&t.distance<u&&(l=t,u=t.distance)}return l}(e,n,r,tt(t,c),et(u,a),o,s)}{const a=ot(t,c),u=be[a],l=r.direction[u]>=0;let f,d;l?(f=nt(t),d=rt(t,c)):(f=rt(t,c),d=nt(t));const p=Wt(f,i,r,o,s)?Te(f,e,n,r,o,s):null;if(p){const t=p.point[u];if(l?t<=i[d+a]:t>=i[d+a+3])return p}const y=Wt(d,i,r,o,s)?Te(d,e,n,r,o,s):null;return p&&y?p.distance<=y.distance?p:y:p||y||null}}const Pe=new m,ve=new Bt,Me=new Bt,Ue=new x,Se=new bt,Fe=new bt;function Ie(t,e,n,r){vt.setBuffer(t._roots[e]);const o=_e(0,t,n,r);return vt.clearBuffer(),o}function _e(t,e,n,r,o=null){const{float32Array:s,uint16Array:i,uint32Array:a}=vt;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),Se.set(n.boundingBox.min,n.boundingBox.max,r),o=Se);if(!$(c,i)){const i=t+8,c=a[t+6];j(i,s,Pe);if(o.intersectsBox(Pe)&&_e(i,e,n,r,o))return!0;j(c,s,Pe);return!!(o.intersectsBox(Pe)&&_e(c,e,n,r,o))}{const o=e.geometry,u=o.index,l=o.attributes.position,f=n.index,d=n.attributes.position,p=tt(t,a),y=et(c,i);if(Ue.copy(r).invert(),n.boundsTree){j(t,s,Fe),Fe.matrix.copy(Ue),Fe.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>Fe.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let n=p,r=y+p;n<r;n++)if(kt(Me,3*e.resolveTriangleIndex(n),u,l),Me.needsUpdate=!0,t.intersectsTriangle(Me))return!0;return!1}})}for(let t=p,n=y+p;t<n;t++){const n=e.resolveTriangleIndex(t);kt(ve,3*n,u,l),ve.a.applyMatrix4(Ue),ve.b.applyMatrix4(Ue),ve.c.applyMatrix4(Ue),ve.needsUpdate=!0;for(let t=0,e=f.count;t<e;t+=3)if(kt(Me,t,f,d),Me.needsUpdate=!0,ve.intersectsTriangle(Me))return!0}}}const ze=new x,Ve=new bt,qe=new bt,Oe=new l,Ce=new l,Ee=new l,Ne=new l;function Xe(t,e,n,r={},o={},s=0,i=1/0){e.boundingBox||e.computeBoundingBox(),Ve.set(e.boundingBox.min,e.boundingBox.max,n),Ve.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,u=a.index,l=e.attributes.position,f=e.index,d=Pt.getPrimitive(),p=Pt.getPrimitive();let y=Oe,h=Ce,x=null,m=null;o&&(x=Ee,m=Ne);let g=1/0,w=null,B=null;return ze.copy(n).invert(),qe.matrix.copy(ze),t.shapecast({boundsTraverseOrder:t=>Ve.distanceToBox(t),intersectsBounds:(t,e,n)=>n<g&&n<i&&(e&&(qe.min.copy(t.min),qe.max.copy(t.max),qe.needsUpdate=!0),!0),intersectsRange:(r,o)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>qe.distanceToBox(t),intersectsBounds:(t,e,n)=>n<g&&n<i,intersectsRange:(e,i)=>{for(let b=e,A=e+i;b<A;b++){const e=a.resolveTriangleIndex(b);kt(p,3*e,f,l),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let n=r,i=r+o;n<i;n++){const e=t.resolveTriangleIndex(n);kt(d,3*e,u,c),d.needsUpdate=!0;const r=d.distanceToTriangle(p,y,x);if(r<g&&(h.copy(y),m&&m.copy(x),g=r,w=n,B=b),r<s)return!0}}}})}for(let i=0,a=O(e);i<a;i++){kt(p,3*i,f,l),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=r,n=r+o;e<n;e++){const n=t.resolveTriangleIndex(e);kt(d,3*n,u,c),d.needsUpdate=!0;const r=d.distanceToTriangle(p,y,x);if(r<g&&(h.copy(y),m&&m.copy(x),g=r,w=e,B=i),r<s)return!0}}}}),Pt.releasePrimitive(d),Pt.releasePrimitive(p),g===1/0?null:(r.point?r.point.copy(h):r.point=h.clone(),r.distance=g,r.faceIndex=w,o&&(o.point?o.point.copy(m):o.point=m.clone(),o.point.applyMatrix4(ze),h.applyMatrix4(ze),o.distance=h.sub(o.point).length(),o.faceIndex=B),r)}const je=new vt.constructor,He=new vt.constructor,Re=new At((()=>new m)),De=new m,Le=new m,Ze=new m,ke=new m;let Ye=!1;function Ge(t,e,n,r,o,s=0,i=0,a=0,c=0,u=null,l=!1){let f,d;l?(f=He,d=je):(f=je,d=He);const p=f.float32Array,y=f.uint32Array,h=f.uint16Array,x=d.float32Array,m=d.uint32Array,g=d.uint16Array,w=2*e,B=$(2*t,h),b=$(w,g);let A=!1;if(b&&B)A=l?o(tt(e,m),et(2*e,g),tt(t,y),et(2*t,h),c,i+e,a,s+t):o(tt(t,y),et(2*t,h),tt(e,m),et(2*e,g),a,s+t,c,i+e);else if(b){const u=Re.getPrimitive();j(e,x,u),u.applyMatrix4(n);const f=nt(t),d=rt(t,y);j(f,p,De),j(d,p,Le);const h=u.intersectsBox(De),m=u.intersectsBox(Le);A=h&&Ge(e,f,r,n,o,i,s,c,a+1,u,!l)||m&&Ge(e,d,r,n,o,i,s,c,a+1,u,!l),Re.releasePrimitive(u)}else{const f=nt(e),d=rt(e,m);j(f,x,Ze),j(d,x,ke);const h=u.intersectsBox(Ze),g=u.intersectsBox(ke);if(h&&g)A=Ge(t,f,n,r,o,s,i,a,c+1,u,l)||Ge(t,d,n,r,o,s,i,a,c+1,u,l);else if(h)if(B)A=Ge(t,f,n,r,o,s,i,a,c+1,u,l);else{const e=Re.getPrimitive();e.copy(Ze).applyMatrix4(n);const u=nt(t),d=rt(t,y);j(u,p,De),j(d,p,Le);const h=e.intersectsBox(De),x=e.intersectsBox(Le);A=h&&Ge(f,u,r,n,o,i,s,c,a+1,e,!l)||x&&Ge(f,d,r,n,o,i,s,c,a+1,e,!l),Re.releasePrimitive(e)}else if(g)if(B)A=Ge(t,d,n,r,o,s,i,a,c+1,u,l);else{const e=Re.getPrimitive();e.copy(ke).applyMatrix4(n);const u=nt(t),f=rt(t,y);j(u,p,De),j(f,p,Le);const h=e.intersectsBox(De),x=e.intersectsBox(Le);A=h&&Ge(d,u,r,n,o,i,s,c,a+1,e,!l)||x&&Ge(d,f,r,n,o,i,s,c,a+1,e,!l),Re.releasePrimitive(e)}}return A}const We=new bt,Ke=new m,Je={strategy:T,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class Qe{static serialize(t,e={}){e=a({cloneBuffers:!0},e);const n=t.geometry,r=t._roots,o=t._indirectBuffer,s=n.getIndex();let i;return i=e.cloneBuffers?{roots:r.map((t=>t.slice())),index:s?s.array.slice():null,indirectBuffer:o?o.slice():null}:{roots:r,index:s?s.array:null,indirectBuffer:o},i}static deserialize(t,e,n={}){n=a({setIndex:!0,indirect:Boolean(t.indirectBuffer)},n);const{index:r,roots:o,indirectBuffer:s}=t,i=new Qe(e,c(a({},n),{[q]:!0}));if(i._roots=o,i._indirectBuffer=s||null,n.setIndex){const n=e.getIndex();if(null===n){const n=new u(t.index,1,!1);e.setIndex(n)}else n.array!==r&&(n.array.set(r),n.needsUpdate=!0)}return i}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign(c(a({},Je),{[q]:!1}),e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[q]||(yt(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new m))),this.resolveTriangleIndex=e.indirect?t=>this._indirectBuffer[t]:t=>t}refit(t=null){return(this.indirect?ge:Gt)(this,t)}traverse(t,e=0){const n=this._roots[e],r=new Uint32Array(n),o=new Uint16Array(n);!function e(s,i=0){const a=2*s,c=o[a+15]===z;if(c){const e=r[s+6],u=o[a+14];t(i,c,new Float32Array(n,4*s,6),e,u)}else{const o=s+_/4,a=r[s+6],u=r[s+7];t(i,c,new Float32Array(n,4*s,6),u)||(e(o,i+1),e(a,i+1))}}(0)}raycast(t,e=B,n=0,r=1/0){const o=this._roots,s=this.geometry,i=[],a=e.isMaterial,c=Array.isArray(e),u=s.groups,l=a?e.side:e,f=this.indirect?we:Jt;for(let d=0,p=o.length;d<p;d++){const o=c?e[u[d].materialIndex].side:l,s=i.length;if(f(this,d,o,t,i,n,r),c){const t=u[d].materialIndex;for(let e=s,n=i.length;e<n;e++)i[e].face.materialIndex=t}}return i}raycastFirst(t,e=B,n=0,r=1/0){const o=this._roots,s=this.geometry,i=e.isMaterial,a=Array.isArray(e);let c=null;const u=s.groups,l=i?e.side:e,f=this.indirect?Ae:te;for(let d=0,p=o.length;d<p;d++){const o=f(this,d,a?e[u[d].materialIndex].side:l,t,n,r);null!=o&&(null==c||o.distance<c.distance)&&(c=o,a&&(o.face.materialIndex=u[d].materialIndex))}return c}intersectsGeometry(t,e){let n=!1;const r=this._roots,o=this.indirect?Ie:ce;for(let s=0,i=r.length;s<i&&(n=o(this,s,t,e),!n);s++);return n}shapecast(t){const e=Pt.getPrimitive(),n=this.indirect?Kt:Yt;let{boundsTraverseOrder:r,intersectsBounds:o,intersectsRange:s,intersectsTriangle:i}=t;if(s&&i){const t=s;s=(r,o,s,a,c)=>!!t(r,o,s,a,c)||n(r,o,this,i,s,a,e)}else s||(s=i?(t,r,o,s)=>n(t,r,this,i,o,s,e):(t,e,n)=>n);let a=!1,c=0;const u=this._roots;for(let l=0,f=u.length;l<f;l++){const t=u[l];if(a=It(this,l,o,s,r,c),a)break;c+=t.byteLength}return Pt.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:r,intersectsTriangles:o}=n;const s=Pt.getPrimitive(),i=this.geometry.index,a=this.geometry.attributes.position,c=this.indirect?t=>{const e=this.resolveTriangleIndex(t);kt(s,3*e,i,a)}:t=>{kt(s,3*t,i,a)},u=Pt.getPrimitive(),l=t.geometry.index,f=t.geometry.attributes.position,d=t.indirect?e=>{const n=t.resolveTriangleIndex(e);kt(u,3*n,l,f)}:t=>{kt(u,3*t,l,f)};if(o){const t=(t,n,r,i,a,l,f,p)=>{for(let y=r,h=r+i;y<h;y++){d(y),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(c(e),s.needsUpdate=!0,o(s,u,e,y,a,l,f,p))return!0}return!1};if(r){const e=r;r=function(n,r,o,s,i,a,c,u){return!!e(n,r,o,s,i,a,c,u)||t(n,r,o,s,i,a,c,u)}}else r=t}return function(t,e,n,r){if(Ye)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ye=!0;const o=t._roots,s=e._roots;let i,a=0,c=0;const u=(new x).copy(n).invert();for(let l=0,f=o.length;l<f;l++){je.setBuffer(o[l]),c=0;const t=Re.getPrimitive();j(0,je.float32Array,t),t.applyMatrix4(u);for(let e=0,o=s.length;e<o&&(He.setBuffer(s[l]),i=Ge(0,0,n,u,r,a,c,0,0,t),He.clearBuffer(),c+=s[e].length,!i);e++);if(Re.releasePrimitive(t),je.clearBuffer(),a+=o[l].length,i)break}return Ye=!1,i}(this,t,e,r)}intersectsBox(t,e){return We.set(t.min,t.max,e),We.needsUpdate=!0,this.shapecast({intersectsBounds:t=>We.intersectsBox(t),intersectsTriangle:t=>We.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},r={},o=0,s=1/0){return(this.indirect?Xe:me)(this,t,e,n,r,o,s)}closestPointToPoint(t,e={},n=0,r=1/0){return function(t,e,n={},r=0,o=1/0){const s=r*r,i=o*o;let a=1/0,c=null;if(t.shapecast({boundsTraverseOrder:t=>(zt.copy(e).clamp(t.min,t.max),zt.distanceToSquared(e)),intersectsBounds:(t,e,n)=>n<a&&n<i,intersectsTriangle:(t,n)=>{t.closestPointToPoint(e,zt);const r=e.distanceToSquared(zt);return r<a&&(Vt.copy(zt),a=r,c=n),r<s}}),a===1/0)return null;const u=Math.sqrt(a);return n.point?n.point.copy(Vt):n.point=Vt.clone(),n.distance=u,n.faceIndex=c,n}(this,t,e,n,r)}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{j(0,new Float32Array(e),Ke),t.union(Ke)})),t}}function $e(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t)}const tn=new A,en=new l,nn=new x,rn=b.prototype.raycast,on=new l;function sn(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;nn.copy(this.matrixWorld).invert(),tn.copy(t.ray).applyMatrix4(nn),function(t,e){const n=t.elements,r=e.set(n[0],n[1],n[2]).length(),o=e.set(n[4],n[5],n[6]).length(),s=e.set(n[8],n[9],n[10]).length();e.set(r,o,s)}(this.matrixWorld,on),en.copy(tn.direction).multiply(on);const n=en.length(),r=t.near/n,o=t.far/n,s=this.geometry.boundsTree;if(!0===t.firstHitOnly){const n=$e(s.raycastFirst(tn,this.material,r,o),this,t);n&&e.push(n)}else{const n=s.raycast(tn,this.material,r,o);for(let r=0,o=n.length;r<o;r++){const o=$e(n[r],this,t);o&&e.push(o)}}}else rn.call(this,t,e)}function an(t){return this.boundsTree=new Qe(this,t),this.boundsTree}function cn(){this.boundsTree=null}export{S as C,U as I,M as N,sn as a,an as c,cn as d};
