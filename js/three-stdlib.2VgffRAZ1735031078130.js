import{s as e,bS as t,m as n,a0 as o,d as a,R as i,e as r,aK as s,at as c,l,V as m,Q as h,a9 as u,O as p,S as d,k as b,t as f,b8 as g,H as v,p as E,bq as y,n as w}from"./three.bc6MLGU_1735031078130.js";class P extends e{constructor(e,i){var r,s;const c=(l=e)&&l.isCubeTexture;var l;const m=(null!=(s=c?null==(r=e.image[0])?void 0:r.width:e.image.width)?s:1024)/4,h=Math.floor(Math.log2(m)),u=Math.pow(2,h),p=3*Math.max(u,112),d=4*u,b=[c?"#define ENVMAP_TYPE_CUBE":"","#define CUBEUV_TEXEL_WIDTH ".concat(1/p),"#define CUBEUV_TEXEL_HEIGHT ".concat(1/d),"#define CUBEUV_MAX_MIP ".concat(h,".0")].join("\n")+"\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <".concat(parseInt(a.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment",">\n        }\n        "),f={map:{value:e},height:{value:(null==i?void 0:i.height)||15},radius:{value:(null==i?void 0:i.radius)||100}};super(new t(1,16),new n({uniforms:f,fragmentShader:b,vertexShader:"\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        ",side:o}))}set radius(e){this.material.uniforms.radius.value=e}get radius(){return this.material.uniforms.radius.value}set height(e){this.material.uniforms.height.value=e}get height(){return this.material.uniforms.height.value}}var T=Object.defineProperty,j=(e,t,n)=>(((e,t,n)=>{t in e?T(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n})(e,"symbol"!=typeof t?t+"":t,n),n);const A=new i,O=new r,M=Math.cos(Math.PI/180*70),x=(e,t)=>(e%t+t)%t;class L extends l{constructor(e,t){super(),j(this,"object"),j(this,"domElement"),j(this,"enabled",!0),j(this,"target",new m),j(this,"minDistance",0),j(this,"maxDistance",1/0),j(this,"minZoom",0),j(this,"maxZoom",1/0),j(this,"minPolarAngle",0),j(this,"maxPolarAngle",Math.PI),j(this,"minAzimuthAngle",-1/0),j(this,"maxAzimuthAngle",1/0),j(this,"enableDamping",!1),j(this,"dampingFactor",.05),j(this,"enableZoom",!0),j(this,"zoomSpeed",1),j(this,"enableRotate",!0),j(this,"rotateSpeed",1),j(this,"enablePan",!0),j(this,"panSpeed",1),j(this,"screenSpacePanning",!0),j(this,"keyPanSpeed",7),j(this,"zoomToCursor",!1),j(this,"autoRotate",!1),j(this,"autoRotateSpeed",2),j(this,"reverseOrbit",!1),j(this,"reverseHorizontalOrbit",!1),j(this,"reverseVerticalOrbit",!1),j(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),j(this,"mouseButtons",{LEFT:s.ROTATE,MIDDLE:s.DOLLY,RIGHT:s.PAN}),j(this,"touches",{ONE:c.ROTATE,TWO:c.DOLLY_PAN}),j(this,"target0"),j(this,"position0"),j(this,"zoom0"),j(this,"_domElementKeyEvents",null),j(this,"getPolarAngle"),j(this,"getAzimuthalAngle"),j(this,"setPolarAngle"),j(this,"setAzimuthalAngle"),j(this,"getDistance"),j(this,"listenToKeyEvents"),j(this,"stopListenToKeyEvents"),j(this,"saveState"),j(this,"reset"),j(this,"update"),j(this,"connect"),j(this,"dispose"),this.object=e,this.domElement=t,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>g.phi,this.getAzimuthalAngle=()=>g.theta,this.setPolarAngle=e=>{let t=x(e,2*Math.PI),o=g.phi;o<0&&(o+=2*Math.PI),t<0&&(t+=2*Math.PI);let a=Math.abs(t-o);2*Math.PI-a<a&&(t<o?t+=2*Math.PI:o+=2*Math.PI),v.phi=t-o,n.update()},this.setAzimuthalAngle=e=>{let t=x(e,2*Math.PI),o=g.theta;o<0&&(o+=2*Math.PI),t<0&&(t+=2*Math.PI);let a=Math.abs(t-o);2*Math.PI-a<a&&(t<o?t+=2*Math.PI:o+=2*Math.PI),v.theta=t-o,n.update()},this.getDistance=()=>n.object.position.distanceTo(n.target),this.listenToKeyEvents=e=>{e.addEventListener("keydown",ce),this._domElementKeyEvents=e},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",ce),this._domElementKeyEvents=null},this.saveState=()=>{n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=()=>{n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(o),n.update(),l=r.NONE},this.update=(()=>{const t=new m,a=new m(0,1,0),i=(new h).setFromUnitVectors(e.up,a),s=i.clone().invert(),c=new m,d=new h,b=2*Math.PI;return function(){const h=n.object.position;i.setFromUnitVectors(e.up,a),s.copy(i).invert(),t.copy(h).sub(n.target),t.applyQuaternion(i),g.setFromVector3(t),n.autoRotate&&l===r.NONE&&z(2*Math.PI/60/60*n.autoRotateSpeed),n.enableDamping?(g.theta+=v.theta*n.dampingFactor,g.phi+=v.phi*n.dampingFactor):(g.theta+=v.theta,g.phi+=v.phi);let w=n.minAzimuthAngle,P=n.maxAzimuthAngle;isFinite(w)&&isFinite(P)&&(w<-Math.PI?w+=b:w>Math.PI&&(w-=b),P<-Math.PI?P+=b:P>Math.PI&&(P-=b),g.theta=w<=P?Math.max(w,Math.min(P,g.theta)):g.theta>(w+P)/2?Math.max(w,g.theta):Math.min(P,g.theta)),g.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,g.phi)),g.makeSafe(),!0===n.enableDamping?n.target.addScaledVector(y,n.dampingFactor):n.target.add(y),n.zoomToCursor&&S||n.object.isOrthographicCamera?g.radius=K(g.radius):g.radius=K(g.radius*E),t.setFromSpherical(g),t.applyQuaternion(s),h.copy(n.target).add(t),n.object.matrixAutoUpdate||n.object.updateMatrix(),n.object.lookAt(n.target),!0===n.enableDamping?(v.theta*=1-n.dampingFactor,v.phi*=1-n.dampingFactor,y.multiplyScalar(1-n.dampingFactor)):(v.set(0,0,0),y.set(0,0,0));let T=!1;if(n.zoomToCursor&&S){let o=null;if(n.object instanceof u&&n.object.isPerspectiveCamera){const e=t.length();o=K(e*E);const a=e-o;n.object.position.addScaledVector(D,a),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const e=new m(k.x,k.y,0);e.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/E)),n.object.updateProjectionMatrix(),T=!0;const a=new m(k.x,k.y,0);a.unproject(n.object),n.object.position.sub(a).add(e),n.object.updateMatrixWorld(),o=t.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;null!==o&&(n.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(o).add(n.object.position):(A.origin.copy(n.object.position),A.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(A.direction))<M?e.lookAt(n.target):(O.setFromNormalAndCoplanarPoint(n.object.up,n.target),A.intersectPlane(O,n.target))))}else n.object instanceof p&&n.object.isOrthographicCamera&&(T=1!==E,T&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/E)),n.object.updateProjectionMatrix()));return E=1,S=!1,!!(T||c.distanceToSquared(n.object.position)>f||8*(1-d.dot(n.object.quaternion))>f)&&(n.dispatchEvent(o),c.copy(n.object.position),d.copy(n.object.quaternion),T=!1,!0)}})(),this.connect=e=>{n.domElement=e,n.domElement.style.touchAction="none",n.domElement.addEventListener("contextmenu",le),n.domElement.addEventListener("pointerdown",ae),n.domElement.addEventListener("pointercancel",re),n.domElement.addEventListener("wheel",se)},this.dispose=()=>{var e,t,o,a,i,r;n.domElement&&(n.domElement.style.touchAction="auto"),null==(e=n.domElement)||e.removeEventListener("contextmenu",le),null==(t=n.domElement)||t.removeEventListener("pointerdown",ae),null==(o=n.domElement)||o.removeEventListener("pointercancel",re),null==(a=n.domElement)||a.removeEventListener("wheel",se),null==(i=n.domElement)||i.ownerDocument.removeEventListener("pointermove",ie),null==(r=n.domElement)||r.ownerDocument.removeEventListener("pointerup",re),null!==n._domElementKeyEvents&&n._domElementKeyEvents.removeEventListener("keydown",ce)};const n=this,o={type:"change"},a={type:"start"},i={type:"end"},r={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let l=r.NONE;const f=1e-6,g=new d,v=new d;let E=1;const y=new m,w=new b,P=new b,T=new b,L=new b,N=new b,R=new b,C=new b,I=new b,_=new b,D=new m,k=new b;let S=!1;const U=[],Y={};function F(){return Math.pow(.95,n.zoomSpeed)}function z(e){n.reverseOrbit||n.reverseHorizontalOrbit?v.theta+=e:v.theta-=e}function H(e){n.reverseOrbit||n.reverseVerticalOrbit?v.phi+=e:v.phi-=e}const B=(()=>{const e=new m;return function(t,n){e.setFromMatrixColumn(n,0),e.multiplyScalar(-t),y.add(e)}})(),X=(()=>{const e=new m;return function(t,o){!0===n.screenSpacePanning?e.setFromMatrixColumn(o,1):(e.setFromMatrixColumn(o,0),e.crossVectors(n.object.up,e)),e.multiplyScalar(t),y.add(e)}})(),V=(()=>{const e=new m;return function(t,o){const a=n.domElement;if(a&&n.object instanceof u&&n.object.isPerspectiveCamera){const i=n.object.position;e.copy(i).sub(n.target);let r=e.length();r*=Math.tan(n.object.fov/2*Math.PI/180),B(2*t*r/a.clientHeight,n.object.matrix),X(2*o*r/a.clientHeight,n.object.matrix)}else a&&n.object instanceof p&&n.object.isOrthographicCamera?(B(t*(n.object.right-n.object.left)/n.object.zoom/a.clientWidth,n.object.matrix),X(o*(n.object.top-n.object.bottom)/n.object.zoom/a.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}})();function W(e){n.object instanceof u&&n.object.isPerspectiveCamera||n.object instanceof p&&n.object.isOrthographicCamera?E/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function Z(e){n.object instanceof u&&n.object.isPerspectiveCamera||n.object instanceof p&&n.object.isOrthographicCamera?E*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function G(e){if(!n.zoomToCursor||!n.domElement)return;S=!0;const t=n.domElement.getBoundingClientRect(),o=e.clientX-t.left,a=e.clientY-t.top,i=t.width,r=t.height;k.x=o/i*2-1,k.y=-a/r*2+1,D.set(k.x,k.y,1).unproject(n.object).sub(n.object.position).normalize()}function K(e){return Math.max(n.minDistance,Math.min(n.maxDistance,e))}function q(e){w.set(e.clientX,e.clientY)}function $(e){L.set(e.clientX,e.clientY)}function Q(){if(1==U.length)w.set(U[0].pageX,U[0].pageY);else{const e=.5*(U[0].pageX+U[1].pageX),t=.5*(U[0].pageY+U[1].pageY);w.set(e,t)}}function J(){if(1==U.length)L.set(U[0].pageX,U[0].pageY);else{const e=.5*(U[0].pageX+U[1].pageX),t=.5*(U[0].pageY+U[1].pageY);L.set(e,t)}}function ee(){const e=U[0].pageX-U[1].pageX,t=U[0].pageY-U[1].pageY,n=Math.sqrt(e*e+t*t);C.set(0,n)}function te(e){if(1==U.length)P.set(e.pageX,e.pageY);else{const t=he(e),n=.5*(e.pageX+t.x),o=.5*(e.pageY+t.y);P.set(n,o)}T.subVectors(P,w).multiplyScalar(n.rotateSpeed);const t=n.domElement;t&&(z(2*Math.PI*T.x/t.clientHeight),H(2*Math.PI*T.y/t.clientHeight)),w.copy(P)}function ne(e){if(1==U.length)N.set(e.pageX,e.pageY);else{const t=he(e),n=.5*(e.pageX+t.x),o=.5*(e.pageY+t.y);N.set(n,o)}R.subVectors(N,L).multiplyScalar(n.panSpeed),V(R.x,R.y),L.copy(N)}function oe(e){const t=he(e),o=e.pageX-t.x,a=e.pageY-t.y,i=Math.sqrt(o*o+a*a);I.set(0,i),_.set(0,Math.pow(I.y/C.y,n.zoomSpeed)),W(_.y),C.copy(I)}function ae(e){var t,o;!1!==n.enabled&&(0===U.length&&(null==(t=n.domElement)||t.ownerDocument.addEventListener("pointermove",ie),null==(o=n.domElement)||o.ownerDocument.addEventListener("pointerup",re)),function(e){U.push(e)}(e),"touch"===e.pointerType?function(e){switch(me(e),U.length){case 1:switch(n.touches.ONE){case c.ROTATE:if(!1===n.enableRotate)return;Q(),l=r.TOUCH_ROTATE;break;case c.PAN:if(!1===n.enablePan)return;J(),l=r.TOUCH_PAN;break;default:l=r.NONE}break;case 2:switch(n.touches.TWO){case c.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;n.enableZoom&&ee(),n.enablePan&&J(),l=r.TOUCH_DOLLY_PAN;break;case c.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;n.enableZoom&&ee(),n.enableRotate&&Q(),l=r.TOUCH_DOLLY_ROTATE;break;default:l=r.NONE}break;default:l=r.NONE}l!==r.NONE&&n.dispatchEvent(a)}(e):function(e){let t;switch(e.button){case 0:t=n.mouseButtons.LEFT;break;case 1:t=n.mouseButtons.MIDDLE;break;case 2:t=n.mouseButtons.RIGHT;break;default:t=-1}switch(t){case s.DOLLY:if(!1===n.enableZoom)return;!function(e){G(e),C.set(e.clientX,e.clientY)}(e),l=r.DOLLY;break;case s.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enablePan)return;$(e),l=r.PAN}else{if(!1===n.enableRotate)return;q(e),l=r.ROTATE}break;case s.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enableRotate)return;q(e),l=r.ROTATE}else{if(!1===n.enablePan)return;$(e),l=r.PAN}break;default:l=r.NONE}l!==r.NONE&&n.dispatchEvent(a)}(e))}function ie(e){!1!==n.enabled&&("touch"===e.pointerType?function(e){switch(me(e),l){case r.TOUCH_ROTATE:if(!1===n.enableRotate)return;te(e),n.update();break;case r.TOUCH_PAN:if(!1===n.enablePan)return;ne(e),n.update();break;case r.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(e){n.enableZoom&&oe(e),n.enablePan&&ne(e)}(e),n.update();break;case r.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(e){n.enableZoom&&oe(e),n.enableRotate&&te(e)}(e),n.update();break;default:l=r.NONE}}(e):function(e){if(!1===n.enabled)return;switch(l){case r.ROTATE:if(!1===n.enableRotate)return;!function(e){P.set(e.clientX,e.clientY),T.subVectors(P,w).multiplyScalar(n.rotateSpeed);const t=n.domElement;t&&(z(2*Math.PI*T.x/t.clientHeight),H(2*Math.PI*T.y/t.clientHeight)),w.copy(P),n.update()}(e);break;case r.DOLLY:if(!1===n.enableZoom)return;!function(e){I.set(e.clientX,e.clientY),_.subVectors(I,C),_.y>0?W(F()):_.y<0&&Z(F()),C.copy(I),n.update()}(e);break;case r.PAN:if(!1===n.enablePan)return;!function(e){N.set(e.clientX,e.clientY),R.subVectors(N,L).multiplyScalar(n.panSpeed),V(R.x,R.y),L.copy(N),n.update()}(e)}}(e))}function re(e){var t,o,a;!function(e){delete Y[e.pointerId];for(let t=0;t<U.length;t++)if(U[t].pointerId==e.pointerId)return void U.splice(t,1)}(e),0===U.length&&(null==(t=n.domElement)||t.releasePointerCapture(e.pointerId),null==(o=n.domElement)||o.ownerDocument.removeEventListener("pointermove",ie),null==(a=n.domElement)||a.ownerDocument.removeEventListener("pointerup",re)),n.dispatchEvent(i),l=r.NONE}function se(e){!1===n.enabled||!1===n.enableZoom||l!==r.NONE&&l!==r.ROTATE||(e.preventDefault(),n.dispatchEvent(a),function(e){G(e),e.deltaY<0?Z(F()):e.deltaY>0&&W(F()),n.update()}(e),n.dispatchEvent(i))}function ce(e){!1!==n.enabled&&!1!==n.enablePan&&function(e){let t=!1;switch(e.code){case n.keys.UP:V(0,n.keyPanSpeed),t=!0;break;case n.keys.BOTTOM:V(0,-n.keyPanSpeed),t=!0;break;case n.keys.LEFT:V(n.keyPanSpeed,0),t=!0;break;case n.keys.RIGHT:V(-n.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),n.update())}(e)}function le(e){!1!==n.enabled&&e.preventDefault()}function me(e){let t=Y[e.pointerId];void 0===t&&(t=new b,Y[e.pointerId]=t),t.set(e.pageX,e.pageY)}function he(e){const t=e.pointerId===U[0].pointerId?U[1]:U[0];return Y[t.pointerId]}void 0!==t&&this.connect(t),this.update()}}class N extends L{constructor(e,t){super(e,t),this.screenSpacePanning=!1,this.mouseButtons.LEFT=s.PAN,this.mouseButtons.RIGHT=s.ROTATE,this.touches.ONE=c.PAN,this.touches.TWO=c.DOLLY_ROTATE}}var R=Object.defineProperty,C=(e,t,n)=>(((e,t,n)=>{t in e?R(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n})(e,"symbol"!=typeof t?t+"":t,n),n);class I{constructor(t){C(this,"camera",new p(-1,1,1,-1,0,1)),C(this,"geometry",new f(2,2)),C(this,"mesh"),this.mesh=new e(this.geometry,t)}get material(){return this.mesh.material}set material(e){this.mesh.material=e}dispose(){this.mesh.geometry.dispose()}render(e){e.render(this.mesh,this.camera)}}const _={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","\tvec4 texel = texture2D( tDiffuse, vUv );","\tgl_FragColor = opacity * texel;","}"].join("\n")};class D extends g{constructor(e){super(e),this.type=v}parse(e){const t=function(e,t){switch(e){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(t||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(t||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(t||""));default:throw new Error("THREE.RGBELoader: Memory Error: "+(t||""))}},n=function(e,t,n){t=t||1024;let o=e.pos,a=-1,i=0,r="",s=String.fromCharCode.apply(null,new Uint16Array(e.subarray(o,o+128)));for(;0>(a=s.indexOf("\n"))&&i<t&&o<e.byteLength;)r+=s,i+=s.length,o+=128,s+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(o,o+128)));return-1<a&&(!1!==n&&(e.pos+=i+a+1),r+s.slice(0,a))},o=function(e,t,n,o){const a=e[t+3],i=Math.pow(2,a-128)/255;n[o+0]=e[t+0]*i,n[o+1]=e[t+1]*i,n[o+2]=e[t+2]*i,n[o+3]=1},a=function(e,t,n,o){const a=e[t+3],i=Math.pow(2,a-128)/255;n[o+0]=y.toHalfFloat(Math.min(e[t+0]*i,65504)),n[o+1]=y.toHalfFloat(Math.min(e[t+1]*i,65504)),n[o+2]=y.toHalfFloat(Math.min(e[t+2]*i,65504)),n[o+3]=y.toHalfFloat(1)},i=new Uint8Array(e);i.pos=0;const r=function(e){const o=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*FORMAT=(\S+)\s*$/,r=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,s={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let c,l;for((e.pos>=e.byteLength||!(c=n(e)))&&t(1,"no header found"),(l=c.match(/^#\?(\S+)/))||t(3,"bad initial token"),s.valid|=1,s.programtype=l[1],s.string+=c+"\n";c=n(e),!1!==c;)if(s.string+=c+"\n","#"!==c.charAt(0)){if((l=c.match(o))&&(s.gamma=parseFloat(l[1])),(l=c.match(a))&&(s.exposure=parseFloat(l[1])),(l=c.match(i))&&(s.valid|=2,s.format=l[1]),(l=c.match(r))&&(s.valid|=4,s.height=parseInt(l[1],10),s.width=parseInt(l[2],10)),2&s.valid&&4&s.valid)break}else s.comments+=c+"\n";return 2&s.valid||t(3,"missing format specifier"),4&s.valid||t(3,"missing image size specifier"),s}(i),s=r.width,c=r.height,l=function(e,n,o){const a=n;if(a<8||a>32767||2!==e[0]||2!==e[1]||128&e[2])return new Uint8Array(e);a!==(e[2]<<8|e[3])&&t(3,"wrong scanline width");const i=new Uint8Array(4*n*o);i.length||t(4,"unable to allocate buffer space");let r=0,s=0;const c=4*a,l=new Uint8Array(4),m=new Uint8Array(c);let h=o;for(;h>0&&s<e.byteLength;){s+4>e.byteLength&&t(1),l[0]=e[s++],l[1]=e[s++],l[2]=e[s++],l[3]=e[s++],2==l[0]&&2==l[1]&&(l[2]<<8|l[3])==a||t(3,"bad rgbe scanline format");let n,o=0;for(;o<c&&s<e.byteLength;){n=e[s++];const a=n>128;if(a&&(n-=128),(0===n||o+n>c)&&t(3,"bad scanline data"),a){const t=e[s++];for(let e=0;e<n;e++)m[o++]=t}else m.set(e.subarray(s,s+n),o),o+=n,s+=n}const u=a;for(let e=0;e<u;e++){let t=0;i[r]=m[e+t],t+=a,i[r+1]=m[e+t],t+=a,i[r+2]=m[e+t],t+=a,i[r+3]=m[e+t],r+=4}h--}return i}(i.subarray(i.pos),s,c);let m,h,u;switch(this.type){case E:u=l.length/4;const e=new Float32Array(4*u);for(let n=0;n<u;n++)o(l,4*n,e,4*n);m=e,h=E;break;case v:u=l.length/4;const t=new Uint16Array(4*u);for(let n=0;n<u;n++)a(l,4*n,t,4*n);m=t,h=v;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:s,height:c,data:m,header:r.string,gamma:r.gamma,exposure:r.exposure,type:h}}setDataType(e){return this.type=e,this}load(e,t,n,o){return super.load(e,(function(e,n){switch(e.type){case E:case v:"colorSpace"in e?e.colorSpace="srgb-linear":e.encoding=3e3,e.minFilter=w,e.magFilter=w,e.generateMipmaps=!1,e.flipY=!0}t&&t(e,n)}),n,o)}}export{_ as C,I as F,P as G,N as M,D as R};
