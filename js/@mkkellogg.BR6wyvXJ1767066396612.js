import{i as e}from"./3d-tiles-renderer.CbgZh8zU1767066396612.js";const t=await e("three"),{Ray:n,Plane:s,MathUtils:r,EventDispatcher:i,Vector3:o,MOUSE:a,TOUCH:l,Quaternion:c,Spherical:h,Vector2:d}=await e("three");class p{static idGen=0;constructor(e,t){let n,s;this.promise=new Promise((e,t)=>{n=e,s=t});const r=n.bind(this),i=s.bind(this);e(((...e)=>{r(...e)}).bind(this),(e=>{i(e)}).bind(this)),this.abortHandler=t,this.id=p.idGen++}then(e){return new p((t,n)=>{this.promise=this.promise.then((...n)=>{const s=e(...n);s instanceof Promise||s instanceof p?s.then((...e)=>{t(...e)}):t(s)}).catch(e=>{n(e)})},this.abortHandler)}catch(e){return new p(t=>{this.promise=this.promise.then((...e)=>{t(...e)}).catch(e)},this.abortHandler)}abort(e){this.abortHandler&&this.abortHandler(e)}}class u extends Error{constructor(e){super(e)}}!function(){const e=new Float32Array(1),t=new Int32Array(e.buffer)}();const m=function(){const e=new Float32Array(1),t=new Int32Array(e.buffer);return function(n){return e[0]=n,t[0]}}(),A=function(e,t){return e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24)},f=function(e,t,n=!0,s){const r=new AbortController,i=r.signal;let o=!1;let a=!1;const l=(e,n,s,r)=>{t&&!a&&(t(e,n,s,r),100===e&&(a=!0))};return new p((t,r)=>{const a={signal:i};s&&(a.headers=s),fetch(e,a).then(async e=>{if(!e.ok){const t=await e.text();return void r(new Error(`Fetch failed: ${e.status} ${e.statusText} ${t}`))}const s=e.body.getReader();let i=0,a=e.headers.get("Content-Length"),c=a?parseInt(a):void 0;const h=[];for(;!o;)try{const{value:e,done:r}=await s.read();if(r){if(l(100,"100%",e,c),n){const e=new Blob(h).arrayBuffer();t(e)}else t();break}let o,a;i+=e.length,void 0!==c&&(o=i/c*100,a=`${o.toFixed(2)}%`),n&&h.push(e),l(o,a,e,c)}catch(d){return void r(d)}}).catch(e=>{r(new u(e))})},e=>{r.abort(e),o=!0})},g=function(e,t,n){return Math.max(Math.min(e,n),t)},S=function(){return performance.now()/1e3},C=e=>{if(e.geometry&&(e.geometry.dispose(),e.geometry=null),e.material&&(e.material.dispose(),e.material=null),e.children)for(let t of e.children)C(t)},y=(e,t)=>new Promise(n=>{window.setTimeout(()=>{n(e?e():void 0)},t?1:50)}),x=(e=0)=>{let t=0;if(1===e)t=9;else if(2===e)t=24;else if(3===e)t=45;else if(e>3)throw new Error("getSphericalHarmonicsComponentCountForDegree() -> Invalid spherical harmonics degree");return t},v=()=>{let e,t;return{promise:new Promise((n,s)=>{e=n,t=s}),resolve:e,reject:t}},I=e=>{let t,n;e||(e=()=>{});return{promise:new p((e,s)=>{t=e,n=s},e),resolve:t,reject:n}};class B{constructor(e,t,n){this.major=e,this.minor=t,this.patch=n}toString(){return`${this.major}_${this.minor}_${this.patch}`}}function w(){const e=navigator.userAgent;return e.indexOf("iPhone")>0||e.indexOf("iPad")>0}function b(){if(w()){const e=navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/);return new B(parseInt(e[1]||0,10),parseInt(e[2]||0,10),parseInt(e[3]||0,10))}return null}class D{static OFFSET={X:0,Y:1,Z:2,SCALE0:3,SCALE1:4,SCALE2:5,ROTATION0:6,ROTATION1:7,ROTATION2:8,ROTATION3:9,FDC0:10,FDC1:11,FDC2:12,OPACITY:13,FRC0:14,FRC1:15,FRC2:16,FRC3:17,FRC4:18,FRC5:19,FRC6:20,FRC7:21,FRC8:22,FRC9:23,FRC10:24,FRC11:25,FRC12:26,FRC13:27,FRC14:28,FRC15:29,FRC16:30,FRC17:31,FRC18:32,FRC19:33,FRC20:34,FRC21:35,FRC22:36,FRC23:37};constructor(e=0){this.sphericalHarmonicsDegree=e,this.sphericalHarmonicsCount=x(this.sphericalHarmonicsDegree),this.componentCount=this.sphericalHarmonicsCount+14,this.defaultSphericalHarmonics=new Array(this.sphericalHarmonicsCount).fill(0),this.splats=[],this.splatCount=0}static createSplat(e=0){const t=[0,0,0,1,1,1,1,0,0,0,0,0,0,0];let n=x(e);for(let s=0;s<n;s++)t.push(0);return t}addSplat(e){this.splats.push(e),this.splatCount++}getSplat(e){return this.splats[e]}addDefaultSplat(){const e=D.createSplat(this.sphericalHarmonicsDegree);return this.addSplat(e),e}addSplatFromComonents(e,t,n,s,r,i,o,a,l,c,h,d,p,u,...m){const A=[e,t,n,s,r,i,o,a,l,c,h,d,p,u,...this.defaultSphericalHarmonics];for(let f=0;f<m.length&&f<this.sphericalHarmonicsCount;f++)A[f]=m[f];return this.addSplat(A),A}addSplatFromArray(e,t){const n=e.splats[t],s=D.createSplat(this.sphericalHarmonicsDegree);for(let r=0;r<this.componentCount&&r<n.length;r++)s[r]=n[r];this.addSplat(s)}}class T{static DefaultSplatSortDistanceMapPrecision=16;static MemoryPageSize=65536;static BytesPerFloat=4;static BytesPerInt=4;static MaxScenes=32;static ProgressiveLoadSectionSize=262144;static ProgressiveLoadSectionDelayDuration=15;static SphericalHarmonics8BitCompressionRange=3}const E=T.SphericalHarmonics8BitCompressionRange/2,M=t.DataUtils.toHalfFloat.bind(t.DataUtils),F=t.DataUtils.fromHalfFloat.bind(t.DataUtils),R=(e,n,s=!1,r,i)=>0===n?e:1===n||2===n&&!s?t.DataUtils.fromHalfFloat(e):2===n?H(e,r,i):void 0,P=(e,t,n)=>{e=g(e,t,n);const s=n-t;return g(Math.floor((e-t)/s*255),0,255)},H=(e,t,n)=>e/255*(n-t)+t,k=(e,t,n)=>P(F(e,t,n)),L=(e,t,n)=>M(H(e,t,n)),O=(e,t,n,s=!1)=>0===n?e.getFloat32(4*t,!0):1===n||2===n&&!s?e.getUint16(2*t,!0):e.getUint8(t,!0),U=function(){const e=e=>e;return function(t,n,s,r=!1){if(n===s)return t;let i=e;return 2===n&&r?1===s?i=L:0==s&&(i=H):2===n||1===n?0===s?i=F:2==s&&(i=r?k:e):0===n&&(1===s?i=M:2==s&&(i=r?P:M)),i(t)}}(),z=(e,t,n,s,r=0)=>{const i=new Uint8Array(e,t),o=new Uint8Array(n,s);for(let a=0;a<r;a++)o[a]=i[a]};class _{static CurrentMajorVersion=0;static CurrentMinorVersion=1;static CenterComponentCount=3;static ScaleComponentCount=3;static RotationComponentCount=4;static ColorComponentCount=4;static CovarianceComponentCount=6;static SplatScaleOffsetFloat=3;static SplatRotationOffsetFloat=6;static CompressionLevels={0:{BytesPerCenter:12,BytesPerScale:12,BytesPerRotation:16,BytesPerColor:4,ScaleOffsetBytes:12,RotationffsetBytes:24,ColorOffsetBytes:40,SphericalHarmonicsOffsetBytes:44,ScaleRange:1,BytesPerSphericalHarmonicsComponent:4,SphericalHarmonicsOffsetFloat:11,SphericalHarmonicsDegrees:{0:{BytesPerSplat:44},1:{BytesPerSplat:80},2:{BytesPerSplat:140}}},1:{BytesPerCenter:6,BytesPerScale:6,BytesPerRotation:8,BytesPerColor:4,ScaleOffsetBytes:6,RotationffsetBytes:12,ColorOffsetBytes:20,SphericalHarmonicsOffsetBytes:24,ScaleRange:32767,BytesPerSphericalHarmonicsComponent:2,SphericalHarmonicsOffsetFloat:12,SphericalHarmonicsDegrees:{0:{BytesPerSplat:24},1:{BytesPerSplat:42},2:{BytesPerSplat:72}}},2:{BytesPerCenter:6,BytesPerScale:6,BytesPerRotation:8,BytesPerColor:4,ScaleOffsetBytes:6,RotationffsetBytes:12,ColorOffsetBytes:20,SphericalHarmonicsOffsetBytes:24,ScaleRange:32767,BytesPerSphericalHarmonicsComponent:1,SphericalHarmonicsOffsetFloat:12,SphericalHarmonicsDegrees:{0:{BytesPerSplat:24},1:{BytesPerSplat:33},2:{BytesPerSplat:48}}}};static CovarianceSizeFloats=6;static HeaderSizeBytes=4096;static SectionHeaderSizeBytes=1024;static BucketStorageSizeBytes=12;static BucketStorageSizeFloats=3;static BucketBlockSize=5;static BucketSize=256;constructor(e,t=!0){this.constructFromBuffer(e,t)}getSplatCount(){return this.splatCount}getMaxSplatCount(){return this.maxSplatCount}getMinSphericalHarmonicsDegree(){let e=0;for(let t=0;t<this.sections.length;t++){const n=this.sections[t];(0===t||n.sphericalHarmonicsDegree<e)&&(e=n.sphericalHarmonicsDegree)}return e}getBucketIndex(e,t){let n;const s=e.fullBucketCount*e.bucketSize;if(t<s)n=Math.floor(t/e.bucketSize);else{let r=s;n=e.fullBucketCount;let i=0;for(;r<e.splatCount;){let s=e.partiallyFilledBucketLengths[i];if(t>=r&&t<r+s)break;r+=s,n++,i++}}return n}getSplatCenter(e,t,n){const s=this.globalSplatIndexToSectionMap[e],r=this.sections[s],i=e-r.splatCountOffset,o=r.bytesPerSplat*i,a=new DataView(this.bufferData,r.dataBase+o),l=O(a,0,this.compressionLevel),c=O(a,1,this.compressionLevel),h=O(a,2,this.compressionLevel);if(this.compressionLevel>=1){const e=this.getBucketIndex(r,i)*_.BucketStorageSizeFloats,n=r.compressionScaleFactor,s=r.compressionScaleRange;t.x=(l-s)*n+r.bucketArray[e],t.y=(c-s)*n+r.bucketArray[e+1],t.z=(h-s)*n+r.bucketArray[e+2]}else t.x=l,t.y=c,t.z=h;n&&t.applyMatrix4(n)}getSplatScaleAndRotation=function(){const e=new t.Matrix4,n=new t.Matrix4,s=new t.Matrix4,r=new t.Vector3,i=new t.Vector3,o=new t.Quaternion;return function(t,a,l,c,h){const d=this.globalSplatIndexToSectionMap[t],p=this.sections[d],u=t-p.splatCountOffset,m=p.bytesPerSplat*u+_.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,A=new DataView(this.bufferData,p.dataBase+m);i.set(R(O(A,0,this.compressionLevel),this.compressionLevel),R(O(A,1,this.compressionLevel),this.compressionLevel),R(O(A,2,this.compressionLevel),this.compressionLevel)),h&&(void 0!==h.x&&(i.x=h.x),void 0!==h.y&&(i.y=h.y),void 0!==h.z&&(i.z=h.z)),o.set(R(O(A,4,this.compressionLevel),this.compressionLevel),R(O(A,5,this.compressionLevel),this.compressionLevel),R(O(A,6,this.compressionLevel),this.compressionLevel),R(O(A,3,this.compressionLevel),this.compressionLevel)),c?(e.makeScale(i.x,i.y,i.z),n.makeRotationFromQuaternion(o),s.copy(e).multiply(n).multiply(c),s.decompose(r,l,a)):(a.copy(i),l.copy(o))}}();getSplatColor(e,t){const n=this.globalSplatIndexToSectionMap[e],s=this.sections[n],r=e-s.splatCountOffset,i=s.bytesPerSplat*r+_.CompressionLevels[this.compressionLevel].ColorOffsetBytes,o=new Uint8Array(this.bufferData,s.dataBase+i,4);t.set(o[0],o[1],o[2],o[3])}fillSplatCenterArray(e,n,s,r,i){const o=this.splatCount;s=s||0,r=r||o-1,void 0===i&&(i=s);const a=new t.Vector3;for(let t=s;t<=r;t++){const r=this.globalSplatIndexToSectionMap[t],o=this.sections[r],l=t-o.splatCountOffset,c=(t-s+i)*_.CenterComponentCount,h=o.bytesPerSplat*l,d=new DataView(this.bufferData,o.dataBase+h),p=O(d,0,this.compressionLevel),u=O(d,1,this.compressionLevel),m=O(d,2,this.compressionLevel);if(this.compressionLevel>=1){const e=this.getBucketIndex(o,l)*_.BucketStorageSizeFloats,t=o.compressionScaleFactor,n=o.compressionScaleRange;a.x=(p-n)*t+o.bucketArray[e],a.y=(u-n)*t+o.bucketArray[e+1],a.z=(m-n)*t+o.bucketArray[e+2]}else a.x=p,a.y=u,a.z=m;n&&a.applyMatrix4(n),e[c]=a.x,e[c+1]=a.y,e[c+2]=a.z}}fillSplatScaleRotationArray=function(){const e=new t.Matrix4,n=new t.Matrix4,s=new t.Matrix4,r=new t.Vector3,i=new t.Quaternion,o=new t.Vector3,a=e=>{const t=e.w<0?-1:1;e.x*=t,e.y*=t,e.z*=t,e.w*=t};return function(t,l,c,h,d,p,u,m){const A=this.splatCount;h=h||0,d=d||A-1,void 0===p&&(p=h);const f=(e,t)=>U(e,t,u);for(let g=h;g<=d;g++){const d=this.globalSplatIndexToSectionMap[g],u=this.sections[d],A=g-u.splatCountOffset,S=u.bytesPerSplat*A+_.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,C=(g-h+p)*_.ScaleComponentCount,y=(g-h+p)*_.RotationComponentCount,x=new DataView(this.bufferData,u.dataBase+S),v=m&&void 0!==m.x?m.x:O(x,0,this.compressionLevel),I=m&&void 0!==m.y?m.y:O(x,1,this.compressionLevel),B=m&&void 0!==m.z?m.z:O(x,2,this.compressionLevel),w=O(x,3,this.compressionLevel),b=O(x,4,this.compressionLevel),D=O(x,5,this.compressionLevel),T=O(x,6,this.compressionLevel);r.set(R(v,this.compressionLevel),R(I,this.compressionLevel),R(B,this.compressionLevel)),i.set(R(b,this.compressionLevel),R(D,this.compressionLevel),R(T,this.compressionLevel),R(w,this.compressionLevel)).normalize(),c&&(o.set(0,0,0),e.makeScale(r.x,r.y,r.z),n.makeRotationFromQuaternion(i),s.identity().premultiply(e).premultiply(n),s.premultiply(c),s.decompose(o,i,r),i.normalize()),a(i),t&&(t[C]=f(r.x,0),t[C+1]=f(r.y,0),t[C+2]=f(r.z,0)),l&&(l[y]=f(i.x,0),l[y+1]=f(i.y,0),l[y+2]=f(i.z,0),l[y+3]=f(i.w,0))}}}();static computeCovariance=function(){const e=new t.Matrix4,n=new t.Matrix3,s=new t.Matrix3,r=new t.Matrix3,i=new t.Matrix3,o=new t.Matrix3,a=new t.Matrix3;return function(t,l,c,h,d=0,p){e.makeScale(t.x,t.y,t.z),n.setFromMatrix4(e),e.makeRotationFromQuaternion(l),s.setFromMatrix4(e),r.copy(s).multiply(n),i.copy(r).transpose().premultiply(r),c&&(o.setFromMatrix4(c),a.copy(o).transpose(),i.multiply(a),i.premultiply(o)),p>=1?(h[d]=M(i.elements[0]),h[d+1]=M(i.elements[3]),h[d+2]=M(i.elements[6]),h[d+3]=M(i.elements[4]),h[d+4]=M(i.elements[7]),h[d+5]=M(i.elements[8])):(h[d]=i.elements[0],h[d+1]=i.elements[3],h[d+2]=i.elements[6],h[d+3]=i.elements[4],h[d+4]=i.elements[7],h[d+5]=i.elements[8])}}();fillSplatCovarianceArray(e,n,s,r,i,o){const a=this.splatCount,l=new t.Vector3,c=new t.Quaternion;s=s||0,r=r||a-1,void 0===i&&(i=s);for(let t=s;t<=r;t++){const r=this.globalSplatIndexToSectionMap[t],a=this.sections[r],h=t-a.splatCountOffset,d=(t-s+i)*_.CovarianceComponentCount,p=a.bytesPerSplat*h+_.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,u=new DataView(this.bufferData,a.dataBase+p);l.set(R(O(u,0,this.compressionLevel),this.compressionLevel),R(O(u,1,this.compressionLevel),this.compressionLevel),R(O(u,2,this.compressionLevel),this.compressionLevel)),c.set(R(O(u,4,this.compressionLevel),this.compressionLevel),R(O(u,5,this.compressionLevel),this.compressionLevel),R(O(u,6,this.compressionLevel),this.compressionLevel),R(O(u,3,this.compressionLevel),this.compressionLevel)),_.computeCovariance(l,c,n,e,d,o)}}fillSplatColorArray(e,t,n,s,r){const i=this.splatCount;n=n||0,s=s||i-1,void 0===r&&(r=n);for(let o=n;o<=s;o++){const s=this.globalSplatIndexToSectionMap[o],i=this.sections[s],a=o-i.splatCountOffset,l=(o-n+r)*_.ColorComponentCount,c=i.bytesPerSplat*a+_.CompressionLevels[this.compressionLevel].ColorOffsetBytes,h=new Uint8Array(this.bufferData,i.dataBase+c);let d=h[3];d=d>=t?d:0,e[l]=h[0],e[l+1]=h[1],e[l+2]=h[2],e[l+3]=d}}fillSphericalHarmonicsArray=function(){for(let x=0;x<15;x++)new t.Vector3;const e=new t.Matrix3,n=new t.Matrix4,s=new t.Vector3,r=new t.Vector3,i=new t.Quaternion,o=[],a=[],l=[],c=[],h=[],d=[],p=[],u=[],m=[],A=[],f=[],g=[],S=[],C=[],y=[],v=[],I=[],B=[],w=e=>e,b=(e,t,n,s)=>{e[0]=t,e[1]=n,e[2]=s},D=(e,t,n,s,r)=>{e[0]=O(t,s,r,!0),e[1]=O(t,s+n,r,!0),e[2]=O(t,s+n+n,r,!0)},T=(e,t)=>{t[0]=e[0],t[1]=e[1],t[2]=e[2]},E=(e,t,n,s)=>{t[n]=s(e[0]),t[n+1]=s(e[1]),t[n+2]=s(e[2])},H=(e,t,n,s,r)=>(t[0]=R(e[0],n,!0,s,r),t[1]=R(e[1],n,!0,s,r),t[2]=R(e[2],n,!0,s,r),t);return function(t,R,L,O,U,z,Q){const V=this.splatCount;O=O||0,U=U||V-1,void 0===z&&(z=O),L&&R>=1&&(n.copy(L),n.decompose(s,i,r),i.normalize(),n.makeRotationFromQuaternion(i),e.setFromMatrix4(n),b(o,e.elements[4],-e.elements[7],e.elements[1]),b(a,-e.elements[5],e.elements[8],-e.elements[2]),b(l,e.elements[3],-e.elements[6],e.elements[0]));const N=e=>k(e,this.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff),G=e=>P(e,this.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff);for(let e=O;e<=U;e++){const n=this.globalSplatIndexToSectionMap[e],s=this.sections[n];R=Math.min(R,s.sphericalHarmonicsDegree);const r=x(R),i=e-s.splatCountOffset,b=s.bytesPerSplat*i+_.CompressionLevels[this.compressionLevel].SphericalHarmonicsOffsetBytes,P=new DataView(this.bufferData,s.dataBase+b),k=(e-O+z)*r;let U=L?0:this.compressionLevel,V=w;U!==Q&&(1===U?0===Q?V=F:2==Q&&(V=N):0===U&&(1===Q?V=M:2==Q&&(V=G)));const K=this.minSphericalHarmonicsCoeff,q=this.maxSphericalHarmonicsCoeff;R>=1&&(D(m,P,3,0,this.compressionLevel),D(A,P,3,1,this.compressionLevel),D(f,P,3,2,this.compressionLevel),L?(H(m,m,this.compressionLevel,K,q),H(A,A,this.compressionLevel,K,q),H(f,f,this.compressionLevel,K,q),_.rotateSphericalHarmonics3(m,A,f,o,a,l,C,y,v)):(T(m,C),T(A,y),T(f,v)),E(C,t,k,V),E(y,t,k+3,V),E(v,t,k+6,V),R>=2&&(D(m,P,5,9,this.compressionLevel),D(A,P,5,10,this.compressionLevel),D(f,P,5,11,this.compressionLevel),D(g,P,5,12,this.compressionLevel),D(S,P,5,13,this.compressionLevel),L?(H(m,m,this.compressionLevel,K,q),H(A,A,this.compressionLevel,K,q),H(f,f,this.compressionLevel,K,q),H(g,g,this.compressionLevel,K,q),H(S,S,this.compressionLevel,K,q),_.rotateSphericalHarmonics5(m,A,f,g,S,o,a,l,c,h,d,p,u,C,y,v,I,B)):(T(m,C),T(A,y),T(f,v),T(g,I),T(S,B)),E(C,t,k+9,V),E(y,t,k+12,V),E(v,t,k+15,V),E(I,t,k+18,V),E(B,t,k+21,V)))}}}();static dot3=(e,t,n,s,r)=>{r[0]=r[1]=r[2]=0;const i=s[0],o=s[1],a=s[2];_.addInto3(e[0]*i,e[1]*i,e[2]*i,r),_.addInto3(t[0]*o,t[1]*o,t[2]*o,r),_.addInto3(n[0]*a,n[1]*a,n[2]*a,r)};static addInto3=(e,t,n,s)=>{s[0]=s[0]+e,s[1]=s[1]+t,s[2]=s[2]+n};static dot5=(e,t,n,s,r,i,o)=>{o[0]=o[1]=o[2]=0;const a=i[0],l=i[1],c=i[2],h=i[3],d=i[4];_.addInto3(e[0]*a,e[1]*a,e[2]*a,o),_.addInto3(t[0]*l,t[1]*l,t[2]*l,o),_.addInto3(n[0]*c,n[1]*c,n[2]*c,o),_.addInto3(s[0]*h,s[1]*h,s[2]*h,o),_.addInto3(r[0]*d,r[1]*d,r[2]*d,o)};static rotateSphericalHarmonics3=(e,t,n,s,r,i,o,a,l)=>{_.dot3(e,t,n,s,o),_.dot3(e,t,n,r,a),_.dot3(e,t,n,i,l)};static rotateSphericalHarmonics5=(e,t,n,s,r,i,o,a,l,c,h,d,p,u,m,A,f,g)=>{const S=Math.sqrt(1/4),C=Math.sqrt(3/4),y=Math.sqrt(1/3),x=Math.sqrt(4/3),v=Math.sqrt(1/12);l[0]=S*(a[2]*i[0]+a[0]*i[2]+(i[2]*a[0]+i[0]*a[2])),l[1]=a[1]*i[0]+i[1]*a[0],l[2]=C*(a[1]*i[1]+i[1]*a[1]),l[3]=a[1]*i[2]+i[1]*a[2],l[4]=S*(a[2]*i[2]-a[0]*i[0]+(i[2]*a[2]-i[0]*a[0])),_.dot5(e,t,n,s,r,l,u),c[0]=S*(o[2]*i[0]+o[0]*i[2]+(i[2]*o[0]+i[0]*o[2])),c[1]=o[1]*i[0]+i[1]*o[0],c[2]=C*(o[1]*i[1]+i[1]*o[1]),c[3]=o[1]*i[2]+i[1]*o[2],c[4]=S*(o[2]*i[2]-o[0]*i[0]+(i[2]*o[2]-i[0]*o[0])),_.dot5(e,t,n,s,r,c,m),h[0]=y*(o[2]*o[0]+o[0]*o[2])+-v*(a[2]*a[0]+a[0]*a[2]+(i[2]*i[0]+i[0]*i[2])),h[1]=x*o[1]*o[0]+-y*(a[1]*a[0]+i[1]*i[0]),h[2]=o[1]*o[1]+-S*(a[1]*a[1]+i[1]*i[1]),h[3]=x*o[1]*o[2]+-y*(a[1]*a[2]+i[1]*i[2]),h[4]=y*(o[2]*o[2]-o[0]*o[0])+-v*(a[2]*a[2]-a[0]*a[0]+(i[2]*i[2]-i[0]*i[0])),_.dot5(e,t,n,s,r,h,A),d[0]=S*(o[2]*a[0]+o[0]*a[2]+(a[2]*o[0]+a[0]*o[2])),d[1]=o[1]*a[0]+a[1]*o[0],d[2]=C*(o[1]*a[1]+a[1]*o[1]),d[3]=o[1]*a[2]+a[1]*o[2],d[4]=S*(o[2]*a[2]-o[0]*a[0]+(a[2]*o[2]-a[0]*o[0])),_.dot5(e,t,n,s,r,d,f),p[0]=S*(a[2]*a[0]+a[0]*a[2]-(i[2]*i[0]+i[0]*i[2])),p[1]=a[1]*a[0]-i[1]*i[0],p[2]=C*(a[1]*a[1]-i[1]*i[1]),p[3]=a[1]*a[2]-i[1]*i[2],p[4]=S*(a[2]*a[2]-a[0]*a[0]-(i[2]*i[2]-i[0]*i[0])),_.dot5(e,t,n,s,r,p,g)};static parseHeader(e){const n=new Uint8Array(e,0,_.HeaderSizeBytes),s=new Uint16Array(e,0,_.HeaderSizeBytes/2),r=new Uint32Array(e,0,_.HeaderSizeBytes/4),i=new Float32Array(e,0,_.HeaderSizeBytes/4);return{versionMajor:n[0],versionMinor:n[1],maxSectionCount:r[1],sectionCount:r[2],maxSplatCount:r[3],splatCount:r[4],compressionLevel:s[10],sceneCenter:new t.Vector3(i[6],i[7],i[8]),minSphericalHarmonicsCoeff:i[9]||-E,maxSphericalHarmonicsCoeff:i[10]||E}}static writeHeaderCountsToBuffer(e,t,n){const s=new Uint32Array(n,0,_.HeaderSizeBytes/4);s[2]=e,s[4]=t}static writeHeaderToBuffer(e,t){const n=new Uint8Array(t,0,_.HeaderSizeBytes),s=new Uint16Array(t,0,_.HeaderSizeBytes/2),r=new Uint32Array(t,0,_.HeaderSizeBytes/4),i=new Float32Array(t,0,_.HeaderSizeBytes/4);n[0]=e.versionMajor,n[1]=e.versionMinor,n[2]=0,n[3]=0,r[1]=e.maxSectionCount,r[2]=e.sectionCount,r[3]=e.maxSplatCount,r[4]=e.splatCount,s[10]=e.compressionLevel,i[6]=e.sceneCenter.x,i[7]=e.sceneCenter.y,i[8]=e.sceneCenter.z,i[9]=e.minSphericalHarmonicsCoeff||-E,i[10]=e.maxSphericalHarmonicsCoeff||E}static parseSectionHeaders(e,t,n=0,s){const r=e.compressionLevel,i=e.maxSectionCount,o=new Uint16Array(t,n,i*_.SectionHeaderSizeBytes/2),a=new Uint32Array(t,n,i*_.SectionHeaderSizeBytes/4),l=new Float32Array(t,n,i*_.SectionHeaderSizeBytes/4),c=[];let h=0,d=h/2,p=h/4,u=_.HeaderSizeBytes+e.maxSectionCount*_.SectionHeaderSizeBytes,m=0;for(let A=0;A<i;A++){const e=a[p+1],t=a[p+2],n=a[p+3],i=l[p+4],f=i/2,g=o[d+10],S=a[p+6]||_.CompressionLevels[r].ScaleRange,C=a[p+8],y=a[p+9],x=4*y,v=g*n+x,I=o[d+20],{bytesPerSplat:B}=_.calculateComponentStorage(r,I),w=B*e,b=w+v,D={bytesPerSplat:B,splatCountOffset:m,splatCount:s?e:0,maxSplatCount:e,bucketSize:t,bucketCount:n,bucketBlockSize:i,halfBucketBlockSize:f,bucketStorageSizeBytes:g,bucketsStorageSizeBytes:v,splatDataStorageSizeBytes:w,storageSizeBytes:b,compressionScaleRange:S,compressionScaleFactor:f/S,base:u,bucketsBase:u+x,dataBase:u+v,fullBucketCount:C,partiallyFilledBucketCount:y,sphericalHarmonicsDegree:I};c[A]=D,u+=b,h+=_.SectionHeaderSizeBytes,d=h/2,p=h/4,m+=e}return c}static writeSectionHeaderToBuffer(e,t,n,s=0){const r=new Uint16Array(n,s,_.SectionHeaderSizeBytes/2),i=new Uint32Array(n,s,_.SectionHeaderSizeBytes/4),o=new Float32Array(n,s,_.SectionHeaderSizeBytes/4);i[0]=e.splatCount,i[1]=e.maxSplatCount,i[2]=t>=1?e.bucketSize:0,i[3]=t>=1?e.bucketCount:0,o[4]=t>=1?e.bucketBlockSize:0,r[10]=t>=1?_.BucketStorageSizeBytes:0,i[6]=t>=1?e.compressionScaleRange:0,i[7]=e.storageSizeBytes,i[8]=t>=1?e.fullBucketCount:0,i[9]=t>=1?e.partiallyFilledBucketCount:0,r[20]=e.sphericalHarmonicsDegree}static writeSectionHeaderSplatCountToBuffer(e,t,n=0){new Uint32Array(t,n,_.SectionHeaderSizeBytes/4)[0]=e}constructFromBuffer(e,n){this.bufferData=e,this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSectionMap=[];const s=_.parseHeader(this.bufferData);this.versionMajor=s.versionMajor,this.versionMinor=s.versionMinor,this.maxSectionCount=s.maxSectionCount,this.sectionCount=n?s.maxSectionCount:0,this.maxSplatCount=s.maxSplatCount,this.splatCount=n?s.maxSplatCount:0,this.compressionLevel=s.compressionLevel,this.sceneCenter=(new t.Vector3).copy(s.sceneCenter),this.minSphericalHarmonicsCoeff=s.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff=s.maxSphericalHarmonicsCoeff,this.sections=_.parseSectionHeaders(s,this.bufferData,_.HeaderSizeBytes,n),this.linkBufferArrays(),this.buildMaps()}static calculateComponentStorage(e,t){const n=_.CompressionLevels[e].BytesPerCenter,s=_.CompressionLevels[e].BytesPerScale,r=_.CompressionLevels[e].BytesPerRotation,i=_.CompressionLevels[e].BytesPerColor,o=x(t),a=_.CompressionLevels[e].BytesPerSphericalHarmonicsComponent*o;return{bytesPerCenter:n,bytesPerScale:s,bytesPerRotation:r,bytesPerColor:i,sphericalHarmonicsComponentsPerSplat:o,sphericalHarmonicsBytesPerSplat:a,bytesPerSplat:n+s+r+i+a}}linkBufferArrays(){for(let e=0;e<this.maxSectionCount;e++){const t=this.sections[e];t.bucketArray=new Float32Array(this.bufferData,t.bucketsBase,t.bucketCount*_.BucketStorageSizeFloats),t.partiallyFilledBucketCount>0&&(t.partiallyFilledBucketLengths=new Uint32Array(this.bufferData,t.base,t.partiallyFilledBucketCount))}}buildMaps(){let e=0;for(let t=0;t<this.maxSectionCount;t++){const n=this.sections[t];for(let s=0;s<n.maxSplatCount;s++){const n=e+s;this.globalSplatIndexToLocalSplatIndexMap[n]=s,this.globalSplatIndexToSectionMap[n]=t}e+=n.maxSplatCount}}updateLoadedCounts(e,t){_.writeHeaderCountsToBuffer(e,t,this.bufferData),this.sectionCount=e,this.splatCount=t}updateSectionLoadedCounts(e,t){const n=_.HeaderSizeBytes+_.SectionHeaderSizeBytes*e;_.writeSectionHeaderSplatCountToBuffer(t,this.bufferData,n),this.sections[e].splatCount=t}static writeSplatDataToSectionBuffer=function(){const e=new ArrayBuffer(12),n=new ArrayBuffer(12),s=new ArrayBuffer(16),r=new ArrayBuffer(4),i=new ArrayBuffer(256),o=new t.Quaternion,a=new t.Vector3,l=new t.Vector3,{X:c,Y:h,Z:d,SCALE0:p,SCALE1:u,SCALE2:m,ROTATION0:A,ROTATION1:f,ROTATION2:S,ROTATION3:C,FDC0:y,FDC1:v,FDC2:I,OPACITY:B,FRC0:w,FRC9:b}=D.OFFSET,T=(e,t,n)=>{const s=2*n+1;return e=Math.round(e*t)+n,g(e,0,s)};return function(t,g,D,F,R,H,k,L,O=-E,U=E){const Q=x(R),V=D,N=V+_.CompressionLevels[F].BytesPerCenter,G=N+_.CompressionLevels[F].BytesPerScale,K=G+_.CompressionLevels[F].BytesPerRotation,q=K+_.CompressionLevels[F].BytesPerColor;if(void 0!==t[A]?(o.set(t[A],t[f],t[S],t[C]),o.normalize()):o.set(1,0,0,0),void 0!==t[p]?a.set(t[p]||0,t[u]||0,t[m]||0):a.set(0,0,0),0===F){const e=new Float32Array(g,V,_.CenterComponentCount),n=new Float32Array(g,G,_.RotationComponentCount),s=new Float32Array(g,N,_.ScaleComponentCount);if(n.set([o.x,o.y,o.z,o.w]),s.set([a.x,a.y,a.z]),e.set([t[c],t[h],t[d]]),R>0){const e=new Float32Array(g,q,Q);if(R>=1){for(let n=0;n<9;n++)e[n]=t[w+n]||0;if(R>=2)for(let n=0;n<15;n++)e[n+9]=t[b+n]||0}}}else{const r=new Uint16Array(e,0,_.CenterComponentCount),p=new Uint16Array(s,0,_.RotationComponentCount),u=new Uint16Array(n,0,_.ScaleComponentCount);if(p.set([M(o.x),M(o.y),M(o.z),M(o.w)]),u.set([M(a.x),M(a.y),M(a.z)]),l.set(t[c],t[h],t[d]).sub(H),l.x=T(l.x,k,L),l.y=T(l.y,k,L),l.z=T(l.z,k,L),r.set([l.x,l.y,l.z]),R>0){const e=1===F?2:1,n=new(1===F?Uint16Array:Uint8Array)(i,0,Q);if(R>=1){for(let e=0;e<9;e++){const s=t[w+e]||0;n[e]=1===F?M(s):P(s,O,U)}const s=9*e;if(z(n.buffer,0,g,q,s),R>=2){for(let e=0;e<15;e++){const s=t[b+e]||0;n[e+9]=1===F?M(s):P(s,O,U)}z(n.buffer,s,g,q+s,15*e)}}}z(r.buffer,0,g,V,6),z(u.buffer,0,g,N,6),z(p.buffer,0,g,G,8)}const W=new Uint8ClampedArray(r,0,4);W.set([t[y]||0,t[v]||0,t[I]||0]),W[3]=t[B]||0,z(W.buffer,0,g,K,4)}}();static generateFromUncompressedSplatArrays(e,n,s,r,i,o,a=[]){let l,c,h=0;for(let t=0;t<e.length;t++){const n=e[t];h=Math.max(n.sphericalHarmonicsDegree,h)}for(let t=0;t<e.length;t++){const n=e[t];for(let e=0;e<n.splats.length;e++){const t=n.splats[e];for(let e=D.OFFSET.FRC0;e<D.OFFSET.FRC23&&e<t.length;e++)(!l||t[e]<l)&&(l=t[e]),(!c||t[e]>c)&&(c=t[e])}}l=l||-E,c=c||E;const{bytesPerSplat:d}=_.calculateComponentStorage(s,h),p=_.CompressionLevels[s].ScaleRange,u=[],m=[];let A=0;for(let y=0;y<e.length;y++){const r=e[y],f=new D(h);for(let e=0;e<r.splatCount;e++){const t=r.splats[e];(t[D.OFFSET.OPACITY]||0)>=n&&f.addSplat(t)}const g=a[y]||{},S=(g.blockSizeFactor||1)*(i||_.BucketBlockSize),C=Math.ceil((g.bucketSizeFactor||1)*(o||_.BucketSize)),x=_.computeBucketsForUncompressedSplatArray(f,S,C),v=x.fullBuckets.length,I=x.partiallyFullBuckets.map(e=>e.splats.length),B=I.length,w=[...x.fullBuckets,...x.partiallyFullBuckets],b=f.splats.length*d,T=4*B,E=s>=1?w.length*_.BucketStorageSizeBytes+T:0,M=b+E,F=new ArrayBuffer(M),R=p/(.5*S),P=new t.Vector3;let H=0;for(let e=0;e<w.length;e++){const t=w[e];P.fromArray(t.center);for(let e=0;e<t.splats.length;e++){let n=t.splats[e];const r=f.splats[n],i=E+H*d;_.writeSplatDataToSectionBuffer(r,F,i,s,h,P,R,p,l,c),H++}}if(A+=H,s>=1){const e=new Uint32Array(F,0,4*I.length);for(let n=0;n<I.length;n++)e[n]=I[n];const t=new Float32Array(F,T,w.length*_.BucketStorageSizeFloats);for(let n=0;n<w.length;n++){const e=w[n],s=3*n;t[s]=e.center[0],t[s+1]=e.center[1],t[s+2]=e.center[2]}}u.push(F);const k=new ArrayBuffer(_.SectionHeaderSizeBytes);_.writeSectionHeaderToBuffer({maxSplatCount:H,splatCount:H,bucketSize:C,bucketCount:w.length,bucketBlockSize:S,compressionScaleRange:p,storageSizeBytes:M,fullBucketCount:v,partiallyFilledBucketCount:B,sphericalHarmonicsDegree:h},s,k,0),m.push(k)}let f=0;for(let t of u)f+=t.byteLength;const g=_.HeaderSizeBytes+_.SectionHeaderSizeBytes*u.length+f,S=new ArrayBuffer(g);_.writeHeaderToBuffer({versionMajor:0,versionMinor:1,maxSectionCount:u.length,sectionCount:u.length,maxSplatCount:A,splatCount:A,compressionLevel:s,sceneCenter:r,minSphericalHarmonicsCoeff:l,maxSphericalHarmonicsCoeff:c},S);let C=_.HeaderSizeBytes;for(let t of m)new Uint8Array(S,C,_.SectionHeaderSizeBytes).set(new Uint8Array(t)),C+=_.SectionHeaderSizeBytes;for(let t of u)new Uint8Array(S,C,t.byteLength).set(new Uint8Array(t)),C+=t.byteLength;return new _(S)}static computeBucketsForUncompressedSplatArray(e,n,s){let r=e.splatCount;const i=n/2,o=new t.Vector3,a=new t.Vector3;for(let t=0;t<r;t++){const n=e.splats[t],s=[n[D.OFFSET.X],n[D.OFFSET.Y],n[D.OFFSET.Z]];(0===t||s[0]<o.x)&&(o.x=s[0]),(0===t||s[0]>a.x)&&(a.x=s[0]),(0===t||s[1]<o.y)&&(o.y=s[1]),(0===t||s[1]>a.y)&&(a.y=s[1]),(0===t||s[2]<o.z)&&(o.z=s[2]),(0===t||s[2]>a.z)&&(a.z=s[2])}const l=(new t.Vector3).copy(a).sub(o),c=Math.ceil(l.y/n),h=Math.ceil(l.z/n),d=new t.Vector3,p=[],u={};for(let t=0;t<r;t++){const r=e.splats[t],a=[r[D.OFFSET.X],r[D.OFFSET.Y],r[D.OFFSET.Z]],l=Math.floor((a[0]-o.x)/n),m=Math.floor((a[1]-o.y)/n),A=Math.floor((a[2]-o.z)/n);d.x=l*n+o.x+i,d.y=m*n+o.y+i,d.z=A*n+o.z+i;const f=l*(c*h)+m*h+A;let g=u[f];g||(u[f]=g={splats:[],center:d.toArray()}),g.splats.push(t),g.splats.length>=s&&(p.push(g),u[f]=null)}const m=[];for(let t in u)if(u.hasOwnProperty(t)){const e=u[t];e&&m.push(e)}return{fullBuckets:p,partiallyFullBuckets:m}}static preallocateUncompressed(e,n){const s=_.CompressionLevels[0].SphericalHarmonicsDegrees[n],r=_.HeaderSizeBytes+_.SectionHeaderSizeBytes,i=r+s.BytesPerSplat*e,o=new ArrayBuffer(i);return _.writeHeaderToBuffer({versionMajor:_.CurrentMajorVersion,versionMinor:_.CurrentMinorVersion,maxSectionCount:1,sectionCount:1,maxSplatCount:e,splatCount:e,compressionLevel:0,sceneCenter:new t.Vector3},o),_.writeSectionHeaderToBuffer({maxSplatCount:e,splatCount:e,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0,sphericalHarmonicsDegree:n},0,o,_.HeaderSizeBytes),{splatBuffer:new _(o,!0),splatBufferDataOffsetBytes:r}}}const Q=new Uint8Array([112,108,121,10]),V=new Uint8Array([10,101,110,100,95,104,101,97,100,101,114,10]),N="end_header",G=new Map([["char",Int8Array],["uchar",Uint8Array],["short",Int16Array],["ushort",Uint16Array],["int",Int32Array],["uint",Uint32Array],["float",Float32Array],["double",Float64Array]]),K=(e,t)=>{const n=(1<<t)-1;return(e&n)/n},q=(e,t)=>{e.x=K(t>>>21,11),e.y=K(t>>>11,10),e.z=K(t,11)},W=(e,t,n)=>e*(1-n)+t*n,j=(e,t)=>e.properties.find(e=>e.name===t&&e.storage)?.storage;class Y{static decodeHeaderText(e){let t,n,s,r;const i=e.split("\n").filter(e=>!e.startsWith("comment "));let o=0,a=!1;for(let h=1;h<i.length;++h){const e=i[h].split(" ");switch(e[0]){case"format":if("binary_little_endian"!==e[1])throw new Error("Unsupported ply format");break;case"element":t={name:e[1],count:parseInt(e[2],10),properties:[],storageSizeBytes:0},"chunk"===t.name?n=t:"vertex"===t.name?s=t:"sh"===t.name&&(r=t);break;case"property":{if(!G.has(e[1]))throw new Error(`Unrecognized property data type '${e[1]}' in ply header`);const n=G.get(e[1]),s=n.BYTES_PER_ELEMENT*t.count;"vertex"===t.name&&(o+=n.BYTES_PER_ELEMENT),t.properties.push({type:e[1],name:e[2],storage:null,byteSize:n.BYTES_PER_ELEMENT,storageSizeByes:s}),t.storageSizeBytes+=s;break}case N:a=!0;break;default:throw new Error(`Unrecognized header value '${e[0]}' in ply header`)}if(a)break}let l=0,c=0;return r&&(c=r.properties.length,r.properties.length>=45?l=3:r.properties.length>=24?l=2:r.properties.length>=9&&(l=1)),{chunkElement:n,vertexElement:s,shElement:r,bytesPerSplat:o,headerSizeBytes:e.indexOf(N)+10+1,sphericalHarmonicsDegree:l,sphericalHarmonicsPerSplat:c}}static decodeHeader(e){let t,n=new Uint8Array(e);if(n.length>=Q.length&&!((e,t)=>{if(e.length<t.length)return!1;for(let n=0;n<t.length;++n)if(e[n]!==t[n])return!1;return!0})(n,Q))throw new Error("Invalid PLY header");if(t=((e,t)=>{const n=e.length-t.length;let s,r;for(s=0;s<=n;++s){for(r=0;r<t.length&&e[s+r]===t[r];++r);if(r===t.length)return s}return-1})(n,V),-1===t)throw new Error("End of PLY header not found");const s=new TextDecoder("ascii").decode(n.slice(0,t)),{chunkElement:r,vertexElement:i,shElement:o,sphericalHarmonicsDegree:a,sphericalHarmonicsPerSplat:l,bytesPerSplat:c}=Y.decodeHeaderText(s);return{headerSizeBytes:t+V.length,bytesPerSplat:c,chunkElement:r,vertexElement:i,shElement:o,sphericalHarmonicsDegree:a,sphericalHarmonicsPerSplat:l}}static readElementData(e,t,n,s,r,i=null){let o=t instanceof DataView?t:new DataView(t);s=s||0,r=r||e.count-1;for(let a=s;a<=r;++a)for(let t=0;t<e.properties.length;++t){const s=e.properties[t],r=G.get(s.type),l=r.BYTES_PER_ELEMENT*e.count;if(s.storage&&!(s.storage.byteLength<l)||i&&!i(s.name)||(s.storage=new r(e.count)),s.storage)switch(s.type){case"char":s.storage[a]=o.getInt8(n);break;case"uchar":s.storage[a]=o.getUint8(n);break;case"short":s.storage[a]=o.getInt16(n,!0);break;case"ushort":s.storage[a]=o.getUint16(n,!0);break;case"int":s.storage[a]=o.getInt32(n,!0);break;case"uint":s.storage[a]=o.getUint32(n,!0);break;case"float":s.storage[a]=o.getFloat32(n,!0);break;case"double":s.storage[a]=o.getFloat64(n,!0)}n+=s.byteSize}return n}static readPly(e,t=null){const n=Y.decodeHeader(e);let s=Y.readElementData(n.chunkElement,e,n.headerSizeBytes,null,null,t);return s=Y.readElementData(n.vertexElement,e,s,null,null,t),Y.readElementData(n.shElement,e,s,null,null,t),{chunkElement:n.chunkElement,vertexElement:n.vertexElement,shElement:n.shElement,sphericalHarmonicsDegree:n.sphericalHarmonicsDegree,sphericalHarmonicsPerSplat:n.sphericalHarmonicsPerSplat}}static getElementStorageArrays(e,t,n){const s={};if(t){const n=j(e,"min_r"),r=j(e,"min_g"),i=j(e,"min_b"),o=j(e,"max_r"),a=j(e,"max_g"),l=j(e,"max_b"),c=j(e,"min_x"),h=j(e,"min_y"),d=j(e,"min_z"),p=j(e,"max_x"),u=j(e,"max_y"),m=j(e,"max_z"),A=j(e,"min_scale_x"),f=j(e,"min_scale_y"),g=j(e,"min_scale_z"),S=j(e,"max_scale_x"),C=j(e,"max_scale_y"),y=j(e,"max_scale_z"),x=j(t,"packed_position"),v=j(t,"packed_rotation"),I=j(t,"packed_scale"),B=j(t,"packed_color");s.colorExtremes={minR:n,maxR:o,minG:r,maxG:a,minB:i,maxB:l},s.positionExtremes={minX:c,maxX:p,minY:h,maxY:u,minZ:d,maxZ:m},s.scaleExtremes={minScaleX:A,maxScaleX:S,minScaleY:f,maxScaleY:C,minScaleZ:g,maxScaleZ:y},s.position=x,s.rotation=v,s.scale=I,s.color=B}if(n){const e={};for(let t=0;t<45;t++){const s=`f_rest_${t}`,r=j(n,s);if(!r)break;e[s]=r}s.sh=e}return s}static decompressBaseSplat=function(){const e=new t.Vector3,n=new t.Quaternion,s=new t.Vector3,r=new t.Vector4,i=D.OFFSET;return function(t,o,a,l,c,h,d,p,u,m){m=m||D.createSplat();const A=Math.floor((o+t)/256);var f,S;return q(e,a[t]),((e,t)=>{const n=1/(.5*Math.sqrt(2)),s=(K(t>>>20,10)-.5)*n,r=(K(t>>>10,10)-.5)*n,i=(K(t,10)-.5)*n,o=Math.sqrt(1-(s*s+r*r+i*i));switch(t>>>30){case 0:e.set(o,s,r,i);break;case 1:e.set(s,o,r,i);break;case 2:e.set(s,r,o,i);break;case 3:e.set(s,r,i,o)}})(n,d[t]),q(s,c[t]),f=r,S=u[t],f.x=K(S>>>24,8),f.y=K(S>>>16,8),f.z=K(S>>>8,8),f.w=K(S,8),m[i.X]=W(l.minX[A],l.maxX[A],e.x),m[i.Y]=W(l.minY[A],l.maxY[A],e.y),m[i.Z]=W(l.minZ[A],l.maxZ[A],e.z),m[i.ROTATION0]=n.x,m[i.ROTATION1]=n.y,m[i.ROTATION2]=n.z,m[i.ROTATION3]=n.w,m[i.SCALE0]=Math.exp(W(h.minScaleX[A],h.maxScaleX[A],s.x)),m[i.SCALE1]=Math.exp(W(h.minScaleY[A],h.maxScaleY[A],s.y)),m[i.SCALE2]=Math.exp(W(h.minScaleZ[A],h.maxScaleZ[A],s.z)),p.minR&&p.maxR?m[i.FDC0]=g(Math.round(255*W(p.minR[A],p.maxR[A],r.x)),0,255):m[i.FDC0]=g(Math.floor(255*r.x),0,255),p.minG&&p.maxG?m[i.FDC1]=g(Math.round(255*W(p.minG[A],p.maxG[A],r.y)),0,255):m[i.FDC1]=g(Math.floor(255*r.y),0,255),p.minB&&p.maxB?m[i.FDC2]=g(Math.round(255*W(p.minB[A],p.maxB[A],r.z)),0,255):m[i.FDC2]=g(Math.floor(255*r.z),0,255),m[i.OPACITY]=g(Math.floor(255*r.w),0,255),m}}();static decompressSphericalHarmonics=function(){const e=[0,3,8,15],t=[0,1,2,9,10,11,12,13,24,25,26,27,28,29,30,3,4,5,14,15,16,17,18,31,32,33,34,35,36,37,6,7,8,19,20,21,22,23,38,39,40,41,42,43,44];return function(n,s,r,i,o){o=o||D.createSplat();let a=e[r],l=e[i];for(let e=0;e<3;++e)for(let r=0;r<15;++r){const i=t[15*e+r];r<a&&r<l&&(o[D.OFFSET.FRC0+i]=s[e*l+r][n]*(8/255)-4)}return o}}();static parseToUncompressedSplatBufferSection(e,t,n,s,r,i,o,a,l=null){Y.readElementData(t,i,0,n,s,l);const c=_.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,{positionExtremes:h,scaleExtremes:d,colorExtremes:p,position:u,rotation:m,scale:A,color:f}=Y.getElementStorageArrays(e,t),g=D.createSplat();for(let S=n;S<=s;++S){Y.decompressBaseSplat(S,r,u,h,A,d,m,p,f,g);const e=S*c+a;_.writeSplatDataToSectionBuffer(g,o,e,0,0)}}static parseToUncompressedSplatArraySection(e,t,n,s,r,i,o,a=null){Y.readElementData(t,i,0,n,s,a);const{positionExtremes:l,scaleExtremes:c,colorExtremes:h,position:d,rotation:p,scale:u,color:m}=Y.getElementStorageArrays(e,t);for(let A=n;A<=s;++A){const e=D.createSplat();Y.decompressBaseSplat(A,r,d,l,u,c,p,h,m,e),o.addSplat(e)}}static parseSphericalHarmonicsToUncompressedSplatArraySection(e,t,n,s,r,i,o,a,l,c=null){Y.readElementData(t,r,i,n,s,c);const{sh:h}=Y.getElementStorageArrays(e,void 0,t),d=Object.values(h);for(let p=n;p<=s;++p)Y.decompressSphericalHarmonics(p,d,o,a,l.splats[p])}static parseToUncompressedSplatArray(e,t){const{chunkElement:n,vertexElement:s,shElement:r,sphericalHarmonicsDegree:i}=Y.readPly(e);t=Math.min(t,i);const o=new D(t),{positionExtremes:a,scaleExtremes:l,colorExtremes:c,position:h,rotation:d,scale:p,color:u}=Y.getElementStorageArrays(n,s);let m;if(t>0){const{sh:e}=Y.getElementStorageArrays(n,void 0,r);m=Object.values(e)}for(let A=0;A<s.count;++A){o.addDefaultSplat();const e=o.getSplat(o.splatCount-1);Y.decompressBaseSplat(A,0,h,a,p,l,d,c,u,e),t>0&&Y.decompressSphericalHarmonics(A,m,t,i,e)}return o}static parseToUncompressedSplatBuffer(e,t){const{chunkElement:n,vertexElement:s,shElement:r,sphericalHarmonicsDegree:i}=Y.readPly(e);t=Math.min(t,i);const{splatBuffer:o,splatBufferDataOffsetBytes:a}=_.preallocateUncompressed(s.count,t),{positionExtremes:l,scaleExtremes:c,colorExtremes:h,position:d,rotation:p,scale:u,color:m}=Y.getElementStorageArrays(n,s);let A;if(t>0){const{sh:e}=Y.getElementStorageArrays(n,void 0,r);A=Object.values(e)}const f=_.CompressionLevels[0].SphericalHarmonicsDegrees[t].BytesPerSplat,g=D.createSplat(t);for(let S=0;S<s.count;++S){Y.decompressBaseSplat(S,0,d,l,u,c,p,h,m,g),t>0&&Y.decompressSphericalHarmonics(S,A,t,i,g);const e=S*f+a;_.writeSplatDataToSectionBuffer(g,o.bufferData,e,0,t)}return o}}const X=0,J=1,Z=2,[$,ee,te,ne,se,re,ie]=[0,1,2,3,4,5,6],oe={double:$,int:ee,uint:te,float:ne,short:se,ushort:re,uchar:ie},ae={[$]:8,[ee]:4,[te]:4,[ne]:4,[se]:2,[re]:2,[ie]:1};class le{static HeaderEndToken="end_header";static decodeSectionHeader(e,t,n=0){const s=[];let r=!1,i=-1,o=0,a=!1,l=null;const c=[],h=[],d=[],p={};for(let f=n;f<e.length;f++){const u=e[f].trim();if(u.startsWith("element")){if(r){i--;break}{r=!0,n=f,i=f;const e=u.split(" ");let t=0;for(let n of e){const e=n.trim();e.length>0&&(t++,2===t?l=e:3===t&&(o=parseInt(e)))}}}else if(u.startsWith("property")){const e=u.match(/(\w+)\s+(\w+)\s+(\w+)/);if(e){const n=e[2],s=e[3];d.push(s);const r=t[s];p[s]=n;const i=oe[n];void 0!==r&&(c.push(r),h[r]=i)}}if(u===le.HeaderEndToken){a=!0;break}r&&(s.push(u),i++)}const u=[];let m=0;for(let f of d){const e=p[f];if(p.hasOwnProperty(f)){const e=t[f];void 0!==e&&(u[e]=m)}m+=ae[oe[e]]}const A=le.decodeSphericalHarmonicsFromSectionHeader(d,t);return{headerLines:s,headerStartLine:n,headerEndLine:i,fieldTypes:h,fieldIds:c,fieldOffsets:u,bytesPerVertex:m,vertexCount:o,dataSizeBytes:m*o,endOfHeader:a,sectionName:l,sphericalHarmonicsDegree:A.degree,sphericalHarmonicsCoefficientsPerChannel:A.coefficientsPerChannel,sphericalHarmonicsDegree1Fields:A.degree1Fields,sphericalHarmonicsDegree2Fields:A.degree2Fields}}static decodeSphericalHarmonicsFromSectionHeader(e,t){let n=0,s=0;for(let a of e)a.startsWith("f_rest")&&n++;s=n/3;let r=0;s>=3&&(r=1),s>=8&&(r=2);let i=[],o=[];for(let a=0;a<3;a++){if(r>=1)for(let e=0;e<3;e++)i.push(t["f_rest_"+(e+s*a)]);if(r>=2)for(let e=0;e<5;e++)o.push(t["f_rest_"+(e+s*a+3)])}return{degree:r,coefficientsPerChannel:s,degree1Fields:i,degree2Fields:o}}static getHeaderSectionNames(e){const t=[];for(let n of e)if(n.startsWith("element")){const e=n.split(" ");let s=0;for(let n of e){const e=n.trim();e.length>0&&(s++,2===s&&t.push(e))}}return t}static checkTextForEndHeader(e){return!!e.includes(le.HeaderEndToken)}static checkBufferForEndHeader(e,t,n,s){const r=new Uint8Array(e,Math.max(0,t-n),n),i=s.decode(r);return le.checkTextForEndHeader(i)}static extractHeaderFromBufferToText(e){const t=new TextDecoder;let n=0,s="";const r=100;for(;;){if(n+r>=e.byteLength)throw new Error("End of file reached while searching for end of header");const i=new Uint8Array(e,n,r);if(s+=t.decode(i),n+=r,le.checkBufferForEndHeader(e,n,200,t))break}return s}static readHeaderFromBuffer(e){const t=new TextDecoder;let n=0,s="";const r=100;for(;;){if(n+r>=e.byteLength)throw new Error("End of file reached while searching for end of header");const i=new Uint8Array(e,n,r);if(s+=t.decode(i),n+=r,le.checkBufferForEndHeader(e,n,200,t))break}return s}static convertHeaderTextToLines(e){const t=e.split("\n"),n=[];for(let s=0;s<t.length;s++){const e=t[s].trim();if(n.push(e),e===le.HeaderEndToken)break}return n}static determineHeaderFormatFromHeaderText(e){const t=le.convertHeaderTextToLines(e);let n=X;for(let s=0;s<t.length;s++){const e=t[s].trim();if(e.startsWith("element chunk")||e.match(/[A-Za-z]*packed_[A-Za-z]*/))n=Z;else if(e.startsWith("element codebook_centers"))n=J;else if(e===le.HeaderEndToken)break}return n}static determineHeaderFormatFromPlyBuffer(e){const t=le.extractHeaderFromBufferToText(e);return le.determineHeaderFormatFromHeaderText(t)}static readVertex(e,t,n,s,r,i,o=!0){const a=n*t.bytesPerVertex+s,l=t.fieldOffsets,c=t.fieldTypes;for(let h of r){const t=c[h];t===ne?i[h]=e.getFloat32(a+l[h],!0):t===se?i[h]=e.getInt16(a+l[h],!0):t===re?i[h]=e.getUint16(a+l[h],!0):t===ee?i[h]=e.getInt32(a+l[h],!0):t===te?i[h]=e.getUint32(a+l[h],!0):t===ie&&(i[h]=o?e.getUint8(a+l[h])/255:e.getUint8(a+l[h]))}}}const ce=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","red","green","blue","f_rest_0"],he=ce.map((e,t)=>t),[de,pe,ue,me,Ae,fe,ge,Se,Ce,ye,xe,ve,Ie,Be,we,be,De,Te]=he;class Ee{static decodeHeaderLines(e){let t=0;e.forEach(e=>{e.includes("f_rest_")&&t++});let n=0;t>=45?n=45:t>=24?n=24:t>=9&&(n=9);let s=Array.from(Array(Math.max(n-1,0))).map((e,t)=>`f_rest_${t+1}`);const r=[...ce,...s],i=r.map((e,t)=>t),o=i.reduce((e,t)=>(e[r[t]]=t,e),{}),a=le.decodeSectionHeader(e,o,0);return a.splatCount=a.vertexCount,a.bytesPerSplat=a.bytesPerVertex,a.fieldsToReadIndexes=i,a}static decodeHeaderText(e){const t=le.convertHeaderTextToLines(e),n=Ee.decodeHeaderLines(t);return n.headerText=e,n.headerSizeBytes=e.indexOf(le.HeaderEndToken)+le.HeaderEndToken.length+1,n}static decodeHeaderFromBuffer(e){const t=le.readHeaderFromBuffer(e);return Ee.decodeHeaderText(t)}static findSplatData(e,t){return new DataView(e,t.headerSizeBytes)}static parseToUncompressedSplatBufferSection(e,t,n,s,r,i,o,a=0){a=Math.min(a,e.sphericalHarmonicsDegree);const l=_.CompressionLevels[0].SphericalHarmonicsDegrees[a].BytesPerSplat;for(let c=t;c<=n;c++){const t=Ee.parseToUncompressedSplat(s,c,e,r,a),n=c*l+o;_.writeSplatDataToSectionBuffer(t,i,n,0,a)}}static parseToUncompressedSplatArraySection(e,t,n,s,r,i,o=0){o=Math.min(o,e.sphericalHarmonicsDegree);for(let a=t;a<=n;a++){const t=Ee.parseToUncompressedSplat(s,a,e,r,o);i.addSplat(t)}}static decodeSectionSplatData(e,t,n,s,r=!0){if(s=Math.min(s,n.sphericalHarmonicsDegree),r){const r=new D(s);for(let i=0;i<t;i++){const t=Ee.parseToUncompressedSplat(e,i,n,0,s);r.addSplat(t)}return r}{const{splatBuffer:r,splatBufferDataOffsetBytes:i}=_.preallocateUncompressed(t,s);return Ee.parseToUncompressedSplatBufferSection(n,0,t-1,e,0,r.bufferData,i,s),r}}static parseToUncompressedSplat=function(){let e=[];const n=new t.Quaternion,s=D.OFFSET.X,r=D.OFFSET.Y,i=D.OFFSET.Z,o=D.OFFSET.SCALE0,a=D.OFFSET.SCALE1,l=D.OFFSET.SCALE2,c=D.OFFSET.ROTATION0,h=D.OFFSET.ROTATION1,d=D.OFFSET.ROTATION2,p=D.OFFSET.ROTATION3,u=D.OFFSET.FDC0,m=D.OFFSET.FDC1,A=D.OFFSET.FDC2,f=D.OFFSET.OPACITY,S=[];for(let t=0;t<45;t++)S[t]=D.OFFSET.FRC0+t;return function(t,C,y,x=0,v=0){v=Math.min(v,y.sphericalHarmonicsDegree),Ee.readSplat(t,y,C,x,e);const I=D.createSplat(v);if(void 0!==e[de]?(I[o]=Math.exp(e[de]),I[a]=Math.exp(e[pe]),I[l]=Math.exp(e[ue])):(I[o]=.01,I[a]=.01,I[l]=.01),void 0!==e[xe]){const t=.28209479177387814;I[u]=255*(.5+t*e[xe]),I[m]=255*(.5+t*e[ve]),I[A]=255*(.5+t*e[Ie])}else void 0!==e[we]?(I[u]=255*e[we],I[m]=255*e[be],I[A]=255*e[De]):(I[u]=0,I[m]=0,I[A]=0);if(void 0!==e[Be]&&(I[f]=1/(1+Math.exp(-e[Be]))*255),I[u]=g(Math.floor(I[u]),0,255),I[m]=g(Math.floor(I[m]),0,255),I[A]=g(Math.floor(I[A]),0,255),I[f]=g(Math.floor(I[f]),0,255),v>=1&&void 0!==e[Te]){for(let t=0;t<9;t++)I[S[t]]=e[y.sphericalHarmonicsDegree1Fields[t]];if(v>=2)for(let t=0;t<15;t++)I[S[9+t]]=e[y.sphericalHarmonicsDegree2Fields[t]]}return n.set(e[me],e[Ae],e[fe],e[ge]),n.normalize(),I[c]=n.x,I[h]=n.y,I[d]=n.z,I[p]=n.w,I[s]=e[Se],I[r]=e[Ce],I[i]=e[ye],I}}();static readSplat(e,t,n,s,r){return le.readVertex(e,t,n,s,t.fieldsToReadIndexes,r,!0)}static parseToUncompressedSplatArray(e,t=0){const{header:n,splatCount:s,splatData:r}=Me(e);return Ee.decodeSectionSplatData(r,s,n,t,!0)}static parseToUncompressedSplatBuffer(e,t=0){const{header:n,splatCount:s,splatData:r}=Me(e);return Ee.decodeSectionSplatData(r,s,n,t,!1)}}function Me(e){const t=Ee.decodeHeaderFromBuffer(e);return{header:t,splatCount:t.splatCount,splatData:Ee.findSplatData(e,t)}}const Fe=["features_dc","features_rest_0","features_rest_1","features_rest_2","features_rest_3","features_rest_4","features_rest_5","features_rest_6","features_rest_7","features_rest_8","features_rest_9","features_rest_10","features_rest_11","features_rest_12","features_rest_13","features_rest_14","opacity","scaling","rotation_re","rotation_im"],Re=Fe.map((e,t)=>t),[Pe,He,ke,Le,Oe,Ue,ze]=[0,1,4,16,17,18,19],_e=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","red","green","blue","f_rest_0","f_rest_1","f_rest_2","f_rest_3","f_rest_4","f_rest_5","f_rest_6","f_rest_7","f_rest_8","f_rest_9","f_rest_10","f_rest_11","f_rest_12","f_rest_13","f_rest_14","f_rest_15","f_rest_16","f_rest_17","f_rest_18","f_rest_19","f_rest_20","f_rest_21","f_rest_22","f_rest_23","f_rest_24","f_rest_25","f_rest_26","f_rest_27","f_rest_28","f_rest_29","f_rest_30","f_rest_31","f_rest_32","f_rest_33","f_rest_34","f_rest_35","f_rest_36","f_rest_37","f_rest_38","f_rest_39","f_rest_40","f_rest_41","f_rest_42","f_rest_43","f_rest_44","f_rest_45"],Qe=_e.map((e,t)=>t),[Ve,Ne,Ge,Ke,qe,We,je,Ye,Xe,Je,Ze,$e,et,tt]=Qe,nt=Ze,st=$e,rt=et,it=e=>{const t=(31744&e)>>10,n=1023&e;return(e>>15?-1:1)*(t?31===t?n?NaN:1/0:Math.pow(2,t-15)*(1+n/1024):n/1024*6103515625e-14)};class ot{static decodeSectionHeadersFromHeaderLines(e){const t=Qe.reduce((e,t)=>(e[_e[t]]=t,e),{}),n=Re.reduce((e,t)=>(e[Fe[t]]=t,e),{}),s=le.getHeaderSectionNames(e);let r;for(let c=0;c<s.length;c++){"codebook_centers"===s[c]&&(r=c)}let i=0,o=!1;const a=[];let l=0;for(;!o;){let s;s=l===r?le.decodeSectionHeader(e,n,i):le.decodeSectionHeader(e,t,i),o=s.endOfHeader,i=s.headerEndLine+1,o||(s.splatCount=s.vertexCount,s.bytesPerSplat=s.bytesPerVertex),a.push(s),l++}return a}static decodeSectionHeadersFromHeaderText(e){const t=le.convertHeaderTextToLines(e);return ot.decodeSectionHeadersFromHeaderLines(t)}static getSplatCountFromSectionHeaders(e){let t=0;for(let n of e)"codebook_centers"!==n.sectionName&&(t+=n.vertexCount);return t}static decodeHeaderFromHeaderText(e){const t=e.indexOf(le.HeaderEndToken)+le.HeaderEndToken.length+1,n=ot.decodeSectionHeadersFromHeaderText(e);return{headerSizeBytes:t,sectionHeaders:n,splatCount:ot.getSplatCountFromSectionHeaders(n)}}static decodeHeaderFromBuffer(e){const t=le.readHeaderFromBuffer(e);return ot.decodeHeaderFromHeaderText(t)}static findVertexData(e,t,n){let s=t.headerSizeBytes;for(let r=0;r<n&&r<t.sectionHeaders.length;r++){s+=t.sectionHeaders[r].dataSizeBytes}return new DataView(e,s,t.sectionHeaders[n].dataSizeBytes)}static decodeCodeBook(e,t){const n=[],s=[];for(let r=0;r<t.vertexCount;r++){le.readVertex(e,t,r,0,Re,n);for(let e of Re){const t=Re[e];let r=s[t];r||(s[t]=r=[]),r.push(n[e])}}for(let r=0;r<s.length;r++){const e=s[r],t=.28209479177387814;for(let n=0;n<e.length;n++){const s=it(e[n]);e[n]=r===Le?Math.round(1/(1+Math.exp(-s))*255):r===Pe?Math.round(255*(.5+t*s)):r===Oe?Math.exp(s):s}}return s}static decodeSectionSplatData(e,t,n,s,r){r=Math.min(r,n.sphericalHarmonicsDegree);const i=new D(r);for(let o=0;o<t;o++){const t=ot.parseToUncompressedSplat(e,o,n,s,0,r);i.addSplat(t)}return i}static parseToUncompressedSplat=function(){let e=[];const n=new t.Quaternion,s=D.OFFSET.X,r=D.OFFSET.Y,i=D.OFFSET.Z,o=D.OFFSET.SCALE0,a=D.OFFSET.SCALE1,l=D.OFFSET.SCALE2,c=D.OFFSET.ROTATION0,h=D.OFFSET.ROTATION1,d=D.OFFSET.ROTATION2,p=D.OFFSET.ROTATION3,u=D.OFFSET.FDC0,m=D.OFFSET.FDC1,A=D.OFFSET.FDC2,f=D.OFFSET.OPACITY,S=[];for(let t=0;t<45;t++)S[t]=D.OFFSET.FRC0+t;return function(t,C,y,x,v=0,I=0){I=Math.min(I,y.sphericalHarmonicsDegree),ot.readSplat(t,y,C,v,e);const B=D.createSplat(I);if(void 0!==e[Ve]?(B[o]=x[Oe][e[Ve]],B[a]=x[Oe][e[Ne]],B[l]=x[Oe][e[Ge]]):(B[o]=.01,B[a]=.01,B[l]=.01),void 0!==e[Ze]?(B[u]=x[Pe][e[Ze]],B[m]=x[Pe][e[$e]],B[A]=x[Pe][e[et]]):void 0!==e[nt]?(B[u]=255*e[nt],B[m]=255*e[st],B[A]=255*e[rt]):(B[u]=0,B[m]=0,B[A]=0),void 0!==e[tt]&&(B[f]=x[Le][e[tt]]),B[u]=g(Math.floor(B[u]),0,255),B[m]=g(Math.floor(B[m]),0,255),B[A]=g(Math.floor(B[A]),0,255),B[f]=g(Math.floor(B[f]),0,255),I>=1&&y.sphericalHarmonicsDegree>=1){for(let t=0;t<9;t++){const n=x[He+t%3];B[S[t]]=n[e[y.sphericalHarmonicsDegree1Fields[t]]]}if(I>=2&&y.sphericalHarmonicsDegree>=2)for(let t=0;t<15;t++){const n=x[ke+t%5];B[S[9+t]]=n[e[y.sphericalHarmonicsDegree2Fields[t]]]}}const w=x[Ue][e[Ke]],b=x[ze][e[qe]],T=x[ze][e[We]],E=x[ze][e[je]];return n.set(w,b,T,E),n.normalize(),B[c]=n.x,B[h]=n.y,B[d]=n.z,B[p]=n.w,B[s]=it(e[Ye]),B[r]=it(e[Xe]),B[i]=it(e[Je]),B}}();static readSplat(e,t,n,s,r){return le.readVertex(e,t,n,s,Qe,r,!1)}static parseToUncompressedSplatArray(e,t=0){const n=[],s=ot.decodeHeaderFromBuffer(e,t);let r;for(let o=0;o<s.sectionHeaders.length;o++){const t=s.sectionHeaders[o];if("codebook_centers"===t.sectionName){const n=ot.findVertexData(e,s,o);r=ot.decodeCodeBook(n,t)}}for(let o=0;o<s.sectionHeaders.length;o++){const i=s.sectionHeaders[o];if("codebook_centers"!==i.sectionName){const a=i.vertexCount,l=ot.findVertexData(e,s,o),c=ot.decodeSectionSplatData(l,a,i,r,t);n.push(c)}}const i=new D(t);for(let o of n)for(let e of o.splats)i.addSplat(e);return i}}class at{static parseToUncompressedSplatArray(e,t=0){const n=le.determineHeaderFormatFromPlyBuffer(e);return n===Z?Y.parseToUncompressedSplatArray(e,t):n===X?Ee.parseToUncompressedSplatArray(e,t):n===J?ot.parseToUncompressedSplatArray(e,t):void 0}static parseToUncompressedSplatBuffer(e,t=0){const n=le.determineHeaderFormatFromPlyBuffer(e);if(n===Z)return Y.parseToUncompressedSplatBuffer(e,t);if(n===X)return Ee.parseToUncompressedSplatBuffer(e,t);if(n===J)throw new Error("parseToUncompressedSplatBuffer() is not implemented for INRIA V2 PLY files")}}class lt{constructor(e,t,n,s){this.sectionCount=e,this.sectionFilters=t,this.groupingParameters=n,this.partitionGenerator=s}partitionUncompressedSplatArray(e){let t,n,s;if(this.partitionGenerator){const r=this.partitionGenerator(e);t=r.groupingParameters,n=r.sectionCount,s=r.sectionFilters}else t=this.groupingParameters,n=this.sectionCount,s=this.sectionFilters;const r=[];for(let i=0;i<n;i++){const t=new D(e.sphericalHarmonicsDegree),n=s[i];for(let s=0;s<e.splatCount;s++)n(s)&&t.addSplat(e.splats[s]);r.push(t)}return{splatArrays:r,parameters:t}}static getStandardPartitioner(e=0,n=new t.Vector3,s=_.BucketBlockSize,r=_.BucketSize){return new lt(void 0,void 0,void 0,i=>{const o=D.OFFSET.X,a=D.OFFSET.Y,l=D.OFFSET.Z;e<=0&&(e=i.splatCount);const c=new t.Vector3,h=.5;i.splats.forEach(e=>{var t;c.set(e[o],e[a],e[l]).sub(n),(t=c).x=Math.floor(t.x/h)*h,t.y=Math.floor(t.y/h)*h,t.z=Math.floor(t.z/h)*h,e.centerDist=c.lengthSq()}),i.splats.sort((e,t)=>e.centerDist>t.centerDist?1:-1);const d=[],p=[];e=Math.min(i.splatCount,e);const u=Math.ceil(i.splatCount/e);let m=0;for(let t=0;t<u;t++){let t=m;d.push(n=>n>=t&&n<t+e),p.push({blocksSize:s,bucketSize:r}),m+=e}return{sectionCount:d.length,sectionFilters:d,groupingParameters:p}})}}class ct{constructor(e,n,s,r,i,o,a){this.splatPartitioner=e,this.alphaRemovalThreshold=n,this.compressionLevel=s,this.sectionSize=r,this.sceneCenter=i?(new t.Vector3).copy(i):void 0,this.blockSize=o,this.bucketSize=a}generateFromUncompressedSplatArray(e){const t=this.splatPartitioner.partitionUncompressedSplatArray(e);return _.generateFromUncompressedSplatArrays(t.splatArrays,this.alphaRemovalThreshold,this.compressionLevel,this.sceneCenter,this.blockSize,this.bucketSize,t.parameters)}static getStandardGenerator(e=1,n=1,s=0,r=new t.Vector3,i=_.BucketBlockSize,o=_.BucketSize){const a=lt.getStandardPartitioner(s,r,i,o);return new ct(a,e,n,s,r,i,o)}}const ht=0,dt=1,pt=2;class ut extends Error{constructor(e){super(e)}}const mt=0,At=1,ft=2;function gt(e,t){let n=0;for(let r of e)n+=r.sizeBytes;(!t||t.byteLength<n)&&(t=new ArrayBuffer(n));let s=0;for(let r of e)new Uint8Array(t,s,r.sizeBytes).set(r.data),s+=r.sizeBytes;return t}function St(e,n,s,r,i,o,a,l){if(n){return ct.getStandardGenerator(s,r,i,o,a,l).generateFromUncompressedSplatArray(e)}return _.generateFromUncompressedSplatArrays([e],s,0,new t.Vector3)}class Ct{static loadFromURL(e,n,s,r,i,o,a=!0,l=0,c,h,d,p,u){let m;m=s||a?a?At:mt:ft;const A=T.ProgressiveLoadSectionSize,g=_.HeaderSizeBytes+_.SectionHeaderSizeBytes;let S,C,x,I,B,w=0,b=0,E=0,M=!1,F=!1,R=!1;const P=v();let H,k=0,L=0,O=0,U=0,z="",Q=null,V=[];const N=new TextDecoder;return n&&n(0,"0%",ht),f(e,(e,s,i)=>{const o=e>=100;if(i&&(V.push({data:i,sizeBytes:i.byteLength,startBytes:O,endBytes:O+i.byteLength}),O+=i.byteLength),m===ft)o&&P.resolve(V);else{if(M){if(S===Z&&!F){const e=Q.headerSizeBytes+Q.chunkElement.storageSizeBytes;B=gt(V,B),B.byteLength>=e&&(Y.readElementData(Q.chunkElement,B,Q.headerSizeBytes),k=e,L=e,F=!0)}}else if(z+=N.decode(i),le.checkTextForEndHeader(z)){if(S=le.determineHeaderFormatFromHeaderText(z),S===X)Q=Ee.decodeHeaderText(z),l=Math.min(l,Q.sphericalHarmonicsDegree),w=Q.splatCount,F=!0,U=Q.headerSizeBytes+Q.bytesPerSplat*w;else{if(S!==Z){if(m===mt)throw new ut("PlyLoader.loadFromURL() -> Selected PLY format cannot be progressively loaded.");return void(m=ft)}if(Q=Y.decodeHeaderText(z),l=Math.min(l,Q.sphericalHarmonicsDegree),m===mt&&l>0)throw new ut("PlyLoader.loadFromURL() -> Selected PLY format has spherical harmonics data that cannot be progressively loaded.");w=Q.vertexElement.count,U=Q.headerSizeBytes+Q.bytesPerSplat*w+Q.chunkElement.storageSizeBytes}if(m===mt){const e=_.CompressionLevels[0].SphericalHarmonicsDegrees[l],n=g+e.BytesPerSplat*w;x=new ArrayBuffer(n),_.writeHeaderToBuffer({versionMajor:_.CurrentMajorVersion,versionMinor:_.CurrentMinorVersion,maxSectionCount:1,sectionCount:1,maxSplatCount:w,splatCount:0,compressionLevel:0,sceneCenter:new t.Vector3},x)}else H=new D(l);k=Q.headerSizeBytes,L=Q.headerSizeBytes,M=!0}if(M&&F&&V.length>0){C=gt(V,C);if(O-k>A||O>=U&&!R||o){const e=R?Q.sphericalHarmonicsPerSplat:Q.bytesPerSplat,t=(R?O:Math.min(U,O))-L,n=Math.floor(t/e),s=n*e,r=O-L-s,i=L-V[0].startBytes,o=new DataView(C,i,s);if(R)S===Z&&m===At&&(Y.parseSphericalHarmonicsToUncompressedSplatArraySection(Q.chunkElement,Q.shElement,E,E+n-1,o,0,l,Q.sphericalHarmonicsDegree,H),E+=n);else{if(m===mt){const e=_.CompressionLevels[0].SphericalHarmonicsDegrees[l],t=b*e.BytesPerSplat+g;S===Z?Y.parseToUncompressedSplatBufferSection(Q.chunkElement,Q.vertexElement,0,n-1,b,o,x,t):Ee.parseToUncompressedSplatBufferSection(Q,0,n-1,o,0,x,t,l)}else S===Z?Y.parseToUncompressedSplatArraySection(Q.chunkElement,Q.vertexElement,0,n-1,b,o,H):Ee.parseToUncompressedSplatArraySection(Q,0,n-1,o,0,H,l);b+=n,m===mt&&(I||(_.writeSectionHeaderToBuffer({maxSplatCount:w,splatCount:b,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0,sphericalHarmonicsDegree:l},0,x,_.HeaderSizeBytes),I=new _(x,!1)),I.updateLoadedCounts(1,b)),O>=U&&(R=!0)}if(0===r)V=[];else{let e=[],t=0;for(let n=V.length-1;n>=0;n--){const s=V[n];if(t+=s.sizeBytes,e.unshift(s),t>=r)break}V=e}k+=A,L+=s}}r&&I&&r(I,o),o&&(m===mt?P.resolve(I):P.resolve(H))}n&&n(e,s,ht)},!1,c).then(()=>(n&&n(0,"0%",dt),P.promise.then(e=>{if(n&&n(100,"100%",pt),m===ft){const e=V.map(e=>e.data);return new Blob(e).arrayBuffer().then(e=>Ct.loadFromFileData(e,i,o,a,l,h,d,p,u))}return m===mt?e:y(()=>St(e,a,i,o,h,d,p,u))})))}static loadFromFileData(e,t,n,s,r=0,i,o,a,l){return s?y(()=>at.parseToUncompressedSplatArray(e,r)).then(e=>St(e,s,t,n,i,o,a,l)):y(()=>at.parseToUncompressedSplatBuffer(e,r))}}async function yt(e){try{const t=(e=>new ReadableStream({async start(t){t.enqueue(e),t.close()}}))(e);if(!t)throw new Error("Failed to create stream from data");return await async function(e){const t=e.pipeThrough(new DecompressionStream("gzip")),n=new Response(t),s=await n.arrayBuffer();return new Uint8Array(s)}(t)}catch(t){throw console.error("Error decompressing gzipped data:",t),t}}function xt(e){const t=e>>10&31,n=1023&e,s=1===(e>>15&1)?-1:1;return 0===t?s*Math.pow(2,-14)*n/1024:31===t?0!==n?NaN:s*(1/0):s*Math.pow(2,t-15)*(1+n/1024)}function vt(e){return(e-128)/128}function It(e){switch(e){case 0:return 0;case 1:return 3;case 2:return 8;case 3:return 15;default:return console.error(`[SPZ: ERROR] Unsupported SH degree: ${e}`),0}}const Bt=function(){let e=[];const n=new t.Quaternion,s=D.OFFSET.X,r=D.OFFSET.Y,i=D.OFFSET.Z,o=D.OFFSET.SCALE0,a=D.OFFSET.SCALE1,l=D.OFFSET.SCALE2,c=D.OFFSET.ROTATION0,h=D.OFFSET.ROTATION1,d=D.OFFSET.ROTATION2,p=D.OFFSET.ROTATION3,u=D.OFFSET.FDC0,m=D.OFFSET.FDC1,A=D.OFFSET.FDC2,f=D.OFFSET.OPACITY,S=[It(0),It(1),It(2),It(3)],C=[0,1,2,9,10,11,12,13,24,25,26,27,28,29,30,3,4,5,14,15,16,17,18,31,32,33,34,35,36,37,6,7,8,19,20,21,22,23,38,39,40,41,42,43,44];return function(t,y,x){x=Math.min(y,x);const v=D.createSplat(x);void 0!==t.scale[0]?(v[o]=t.scale[0],v[a]=t.scale[1],v[l]=t.scale[2]):(v[o]=.01,v[a]=.01,v[l]=.01),void 0!==t.color[0]?(v[u]=t.color[0],v[m]=t.color[1],v[A]=t.color[2]):void 0!==e[RED]?(v[u]=255*e[RED],v[m]=255*e[GREEN],v[A]=255*e[BLUE]):(v[u]=0,v[m]=0,v[A]=0),void 0!==t.alpha&&(v[f]=t.alpha),v[u]=g(Math.floor(v[u]),0,255),v[m]=g(Math.floor(v[m]),0,255),v[A]=g(Math.floor(v[A]),0,255),v[f]=g(Math.floor(v[f]),0,255);let I=S[x],B=S[y];for(let e=0;e<3;++e)for(let n=0;n<15;++n){const s=C[15*e+n];n<I&&n<B&&(v[D.OFFSET.FRC0+s]=t.sh[e*B+n])}return n.set(t.rotation[3],t.rotation[0],t.rotation[1],t.rotation[2]),n.normalize(),v[c]=n.x,v[h]=n.y,v[d]=n.z,v[p]=n.w,v[s]=t.position[0],v[r]=t.position[1],v[i]=t.position[2],v}}();function wt(e,t,n,s,r){t=Math.min(t,e.shDegree);const i=e.numPoints,o=It(e.shDegree),a=e.positions.length===3*i*2;if(!function(e,t,n,s){return e.positions.length===3*t*(s?2:3)&&e.scales.length===3*t&&e.rotations.length===3*t&&e.alphas.length===t&&e.colors.length===3*t&&e.sh.length===t*n*3}(e,i,o,a))return null;const l={position:[],scale:[],rotation:[],alpha:void 0,color:[],sh:[]};let c;a&&(c=new Uint16Array(e.positions.buffer,e.positions.byteOffset,3*i));const h=1/(1<<e.fractionalBits),d=It(e.shDegree);for(let p=0;p<i;p++){if(a)for(let e=0;e<3;e++)l.position[e]=xt(c[3*p+e]);else for(let t=0;t<3;t++){const n=9*p+3*t;let s=e.positions[n];s|=e.positions[n+1]<<8,s|=e.positions[n+2]<<16,s|=8388608&s?4278190080:0,l.position[t]=s*h}for(let t=0;t<3;t++)l.scale[t]=Math.exp(e.scales[3*p+t]/16-10);const i=e.rotations.subarray(3*p,3*p+3),o=[i[0]/127.5-1,i[1]/127.5-1,i[2]/127.5-1];l.rotation[0]=o[0],l.rotation[1]=o[1],l.rotation[2]=o[2];const u=o[0]*o[0]+o[1]*o[1]+o[2]*o[2];l.rotation[3]=Math.sqrt(Math.max(0,1-u)),l.alpha=Math.floor(e.alphas[p]);for(let t=0;t<3;t++)l.color[t]=Math.floor(255*((e.colors[3*p+t]/255-.5)/.15*.28209479177387814+.5));for(let t=0;t<3;t++)for(let n=0;n<d;n++)l.sh[t*d+n]=vt(e.sh[3*d*p+3*n+t]);const m=Bt(l,e.shDegree,t);if(n){const e=p*_.CompressionLevels[0].SphericalHarmonicsDegrees[t].BytesPerSplat+r;_.writeSplatDataToSectionBuffer(m,s,e,0,t)}else s.addSplat(m)}}async function bt(e){try{return function(e){const t=new DataView(e);let n=0;const s={magic:t.getUint32(n,!0),version:t.getUint32(n+4,!0),numPoints:t.getUint32(n+8,!0),shDegree:t.getUint8(n+12),fractionalBits:t.getUint8(n+13),flags:t.getUint8(n+14),reserved:t.getUint8(n+15)};if(n+=16,1347635022!==s.magic)return console.error("[SPZ ERROR] deserializePackedGaussians: header not found"),null;if(s.version<1||s.version>2)return console.error(`[SPZ ERROR] deserializePackedGaussians: version not supported: ${s.version}`),null;if(s.numPoints>1e7)return console.error(`[SPZ ERROR] deserializePackedGaussians: Too many points: ${s.numPoints}`),null;if(s.shDegree>3)return console.error(`[SPZ ERROR] deserializePackedGaussians: Unsupported SH degree: ${s.shDegree}`),null;const r=s.numPoints,i=It(s.shDegree),o={numPoints:r,shDegree:s.shDegree,fractionalBits:s.fractionalBits,antialiased:!!(1&s.flags),positions:new Uint8Array(3*r*(1===s.version?2:3)),scales:new Uint8Array(3*r),rotations:new Uint8Array(3*r),alphas:new Uint8Array(r),colors:new Uint8Array(3*r),sh:new Uint8Array(r*i*3)};try{const t=new Uint8Array(e);let s=o.positions.length,r=n;if(o.positions.set(t.slice(r,r+s)),r+=s,o.alphas.set(t.slice(r,r+o.alphas.length)),r+=o.alphas.length,o.colors.set(t.slice(r,r+o.colors.length)),r+=o.colors.length,o.scales.set(t.slice(r,r+o.scales.length)),r+=o.scales.length,o.rotations.set(t.slice(r,r+o.rotations.length)),r+=o.rotations.length,o.sh.set(t.slice(r,r+o.sh.length)),r+o.sh.length!==e.byteLength)return console.error("[SPZ ERROR] deserializePackedGaussians: incorrect buffer size"),null}catch(a){return console.error("[SPZ ERROR] deserializePackedGaussians: read error",a),null}return o}((await yt(e)).buffer)}catch(t){return console.error("[SPZ ERROR] loadSpzPacked: decompression error",t),null}}class Dt{static loadFromURL(e,t,n,s,r=!0,i=0,o,a,l,c,h){return t&&t(0,"0%",ht),f(e,t,!0,o).then(e=>(t&&t(0,"0%",dt),Dt.loadFromFileData(e,n,s,r,i,a,l,c,h)))}static async loadFromFileData(e,t,n,s,r=0,i,o,a,l){await y();const c=await bt(e);r=Math.min(c.shDegree,r);const h=new D(r);if(s){wt(c,r,!1,h,0);return ct.getStandardGenerator(t,n,i,o,a,l).generateFromUncompressedSplatArray(h)}{const{splatBuffer:e,splatBufferDataOffsetBytes:t}=_.preallocateUncompressed(c.numPoints,r);return wt(c,r,!0,e.bufferData,t),e}}}class Tt{static RowSizeBytes=32;static CenterSizeBytes=12;static ScaleSizeBytes=12;static RotationSizeBytes=4;static ColorSizeBytes=4;static parseToUncompressedSplatBufferSection(e,n,s,r,i,o){const a=_.CompressionLevels[0].BytesPerCenter,l=_.CompressionLevels[0].BytesPerScale,c=_.CompressionLevels[0].BytesPerRotation,h=_.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat;for(let d=e;d<=n;d++){const e=d*Tt.RowSizeBytes+r,n=new Float32Array(s,e,3),p=new Float32Array(s,e+Tt.CenterSizeBytes,3),u=new Uint8Array(s,e+Tt.CenterSizeBytes+Tt.ScaleSizeBytes,4),m=new Uint8Array(s,e+Tt.CenterSizeBytes+Tt.ScaleSizeBytes+Tt.RotationSizeBytes,4),A=new t.Quaternion((m[1]-128)/128,(m[2]-128)/128,(m[3]-128)/128,(m[0]-128)/128);A.normalize();const f=d*h+o,g=new Float32Array(i,f,3),S=new Float32Array(i,f+a,3),C=new Float32Array(i,f+a+l,4),y=new Uint8Array(i,f+a+l+c,4);g[0]=n[0],g[1]=n[1],g[2]=n[2],S[0]=p[0],S[1]=p[1],S[2]=p[2],C[0]=A.w,C[1]=A.x,C[2]=A.y,C[3]=A.z,y[0]=u[0],y[1]=u[1],y[2]=u[2],y[3]=u[3]}}static parseToUncompressedSplatArraySection(e,n,s,r,i){for(let o=e;o<=n;o++){const e=o*Tt.RowSizeBytes+r,n=new Float32Array(s,e,3),a=new Float32Array(s,e+Tt.CenterSizeBytes,3),l=new Uint8Array(s,e+Tt.CenterSizeBytes+Tt.ScaleSizeBytes,4),c=new Uint8Array(s,e+Tt.CenterSizeBytes+Tt.ScaleSizeBytes+Tt.RotationSizeBytes,4),h=new t.Quaternion((c[1]-128)/128,(c[2]-128)/128,(c[3]-128)/128,(c[0]-128)/128);h.normalize(),i.addSplatFromComonents(n[0],n[1],n[2],a[0],a[1],a[2],h.w,h.x,h.y,h.z,l[0],l[1],l[2],l[3])}}static parseStandardSplatToUncompressedSplatArray(e){const n=e.byteLength/Tt.RowSizeBytes,s=new D;for(let r=0;r<n;r++){const n=r*Tt.RowSizeBytes,i=new Float32Array(e,n,3),o=new Float32Array(e,n+Tt.CenterSizeBytes,3),a=new Uint8Array(e,n+Tt.CenterSizeBytes+Tt.ScaleSizeBytes,4),l=new Uint8Array(e,n+Tt.CenterSizeBytes+Tt.ScaleSizeBytes+Tt.ColorSizeBytes,4),c=new t.Quaternion((l[1]-128)/128,(l[2]-128)/128,(l[3]-128)/128,(l[0]-128)/128);c.normalize(),s.addSplatFromComonents(i[0],i[1],i[2],o[0],o[1],o[2],c.w,c.x,c.y,c.z,a[0],a[1],a[2],a[3])}return s}}function Et(e,n,s,r,i,o,a,l){if(n){return ct.getStandardGenerator(s,r,i,o,a,l).generateFromUncompressedSplatArray(e)}return _.generateFromUncompressedSplatArrays([e],s,0,new t.Vector3)}class Mt{static loadFromURL(e,n,s,r,i,o,a=!0,l,c,h,d,p){let u=s?mt:At;a&&(u=At);const m=_.HeaderSizeBytes+_.SectionHeaderSizeBytes,A=T.ProgressiveLoadSectionSize;let g,S,C,x,I=0,B=0;const w=v();let b=0,E=0,M=[];return n&&n(0,"0%",ht),f(e,(e,i,o,a)=>{const l=e>=100;if(o&&M.push(o),u!==ft)if(a){if(!g){I=a/Tt.RowSizeBytes,g=new ArrayBuffer(a);const e=_.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat;u===mt?(S=new ArrayBuffer(m+e*I),_.writeHeaderToBuffer({versionMajor:_.CurrentMajorVersion,versionMinor:_.CurrentMinorVersion,maxSectionCount:1,sectionCount:1,maxSplatCount:I,splatCount:B,compressionLevel:0,sceneCenter:new t.Vector3},S)):x=new D(0)}if(o){new Uint8Array(g,E,o.byteLength).set(new Uint8Array(o)),E+=o.byteLength;const e=E-b;if(e>A||l){const t=(l?e:A)/Tt.RowSizeBytes,n=B+t;u===mt?Tt.parseToUncompressedSplatBufferSection(B,n-1,g,0,S,m):Tt.parseToUncompressedSplatArraySection(B,n-1,g,0,x),B=n,u===mt&&(C||(_.writeSectionHeaderToBuffer({maxSplatCount:I,splatCount:B,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0},0,S,_.HeaderSizeBytes),C=new _(S,!1)),C.updateLoadedCounts(1,B),r&&r(C,l)),b+=A}}l&&(u===mt?w.resolve(C):w.resolve(x)),n&&n(e,i,ht)}else{if(s)throw new ut("Cannon directly load .splat because no file size info is available.");u=ft}else l&&w.resolve(M)},!1,l).then(()=>(n&&n(0,"0%",dt),w.promise.then(e=>(n&&n(100,"100%",pt),u===ft?new Blob(M).arrayBuffer().then(e=>Mt.loadFromFileData(e,i,o,a,c,h,d,p)):u===mt?e:y(()=>Et(e,a,i,o,c,h,d,p))))))}static loadFromFileData(e,t,n,s,r,i,o,a){return y(()=>Et(Tt.parseStandardSplatToUncompressedSplatArray(e),s,t,n,r,i,o,a))}}class Ft{static checkVersion(e){const t=_.CurrentMajorVersion,n=_.CurrentMinorVersion,s=_.parseHeader(e);if(s.versionMajor===t&&s.versionMinor>=n||s.versionMajor>t)return!0;throw new Error(`KSplat version not supported: v${s.versionMajor}.${s.versionMinor}. Minimum required: v${t}.${n}`)}static loadFromURL(e,t,n,s,r){let i,o,a,l,c,h=!1,d=!1,p=[],u=!1,m=!1,A=0,g=0,S=0,C=!1,y=!1,x=!1,I=[];const B=v();let w=0;const b=()=>{const e=()=>{m=!0;new Blob(I).arrayBuffer().then(e=>{m=!1,u=!0,c=new ArrayBuffer(l.maxSectionCount*_.SectionHeaderSizeBytes),new Uint8Array(c).set(new Uint8Array(e,_.HeaderSizeBytes,l.maxSectionCount*_.SectionHeaderSizeBytes)),p=_.parseSectionHeaders(l,c,0,!1);let t=0;for(let s=0;s<l.maxSectionCount;s++)t+=p[s].storageSizeBytes;const n=_.HeaderSizeBytes+l.maxSectionCount*_.SectionHeaderSizeBytes+t;if(!i){i=new ArrayBuffer(n);let e=0;for(let t=0;t<I.length;t++){const n=I[t];new Uint8Array(i,e,n.byteLength).set(new Uint8Array(n)),e+=n.byteLength}}S=_.HeaderSizeBytes+_.SectionHeaderSizeBytes*l.maxSectionCount;for(let s=0;s<=p.length&&s<l.maxSectionCount;s++)S+=p[s].storageSizeBytes;0===w&&(w++,window.setTimeout(()=>{w--,D()},1))})};!m&&!u&&h&&A>=_.HeaderSizeBytes+_.SectionHeaderSizeBytes*l.maxSectionCount&&e()},D=()=>{if(x)return;x=!0;window.setTimeout(()=>{if(x=!1,u){if(y)return;if(C=A>=S,A-g>T.ProgressiveLoadSectionSize||C){g+=T.ProgressiveLoadSectionSize,y=g>=S,o||(o=new _(i,!1));const e=_.HeaderSizeBytes+_.SectionHeaderSizeBytes*l.maxSectionCount;let n=0,r=0,a=0;for(let t=0;t<l.maxSectionCount;t++){const s=p[t],i=e+(n+4*s.partiallyFilledBucketCount+s.bucketStorageSizeBytes*s.bucketCount);if(!(g>=i))break;{r++;const e=g-i,n=_.CompressionLevels[l.compressionLevel].SphericalHarmonicsDegrees[s.sphericalHarmonicsDegree].BytesPerSplat;let c=Math.floor(e/n);c=Math.min(c,s.maxSplatCount),a+=c,o.updateLoadedCounts(r,a),o.updateSectionLoadedCounts(t,c)}n+=s.storageSizeBytes}s(o,y);const c=g/S*100,h=c.toFixed(2)+"%";t&&t(c,h,ht),y?B.resolve(o):D()}}},T.ProgressiveLoadSectionDelayDuration)};return f(e,(e,s,r)=>{r&&(I.push(r),i&&new Uint8Array(i,A,r.byteLength).set(new Uint8Array(r)),A+=r.byteLength),n?(!h&&!d&&A>=_.HeaderSizeBytes&&(d=!0,new Blob(I).arrayBuffer().then(e=>{a=new ArrayBuffer(_.HeaderSizeBytes),new Uint8Array(a).set(new Uint8Array(e,0,_.HeaderSizeBytes)),Ft.checkVersion(a),d=!1,h=!0,l=_.parseHeader(a),window.setTimeout(()=>{b()},1)})),b(),D()):t&&t(e,s,ht)},!n,r).then(e=>{t&&t(0,"0%",dt);return(n?B.promise:Ft.loadFromFileData(e)).then(e=>(t&&t(100,"100%",pt),e))})}static loadFromFileData(e){return y(()=>(Ft.checkVersion(e),new _(e)))}static downloadFile=function(){let e;return function(t,n){const s=new Blob([t.bufferData],{type:"application/octet-stream"});e||(e=document.createElement("a"),document.body.appendChild(e)),e.download=n,e.href=URL.createObjectURL(s),e.click()}}()}const Rt=0,Pt=1,Ht=2,kt=3,Lt=e=>e.endsWith(".ply")?Ht:e.endsWith(".splat")?Rt:e.endsWith(".ksplat")?Pt:e.endsWith(".spz")?kt:null,Ot={type:"change"},Ut={type:"start"},zt={type:"end"},_t=new n,Qt=new s,Vt=Math.cos(70*r.DEG2RAD);class Nt extends i{constructor(e,t){super(),this.object=e,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new o,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"KeyA",UP:"KeyW",RIGHT:"KeyD",BOTTOM:"KeyS"},this.mouseButtons={LEFT:a.ROTATE,MIDDLE:a.DOLLY,RIGHT:a.PAN},this.touches={ONE:l.ROTATE,TWO:l.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return p.phi},this.getAzimuthalAngle=function(){return p.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(e){e.addEventListener("keydown",Z),this._domElementKeyEvents=e},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",Z),this._domElementKeyEvents=null},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,this.clearDampedRotation(),this.clearDampedPan(),n.object.updateProjectionMatrix(),n.dispatchEvent(Ot),n.update(),r=s.NONE},this.clearDampedRotation=function(){u.theta=0,u.phi=0},this.clearDampedPan=function(){A.set(0,0,0)},this.update=function(){const t=new o,a=(new c).setFromUnitVectors(e.up,new o(0,1,0)),l=a.clone().invert(),h=new o,d=new c,f=new o,g=2*Math.PI;return function(){a.setFromUnitVectors(e.up,new o(0,1,0)),l.copy(a).invert();const c=n.object.position;t.copy(c).sub(n.target),t.applyQuaternion(a),p.setFromVector3(t),n.autoRotate&&r===s.NONE&&F(2*Math.PI/60/60*n.autoRotateSpeed),n.enableDamping?(p.theta+=u.theta*n.dampingFactor,p.phi+=u.phi*n.dampingFactor):(p.theta+=u.theta,p.phi+=u.phi);let S=n.minAzimuthAngle,C=n.maxAzimuthAngle;isFinite(S)&&isFinite(C)&&(S<-Math.PI?S+=g:S>Math.PI&&(S-=g),C<-Math.PI?C+=g:C>Math.PI&&(C-=g),p.theta=S<=C?Math.max(S,Math.min(C,p.theta)):p.theta>(S+C)/2?Math.max(S,p.theta):Math.min(C,p.theta)),p.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,p.phi)),p.makeSafe(),!0===n.enableDamping?n.target.addScaledVector(A,n.dampingFactor):n.target.add(A),n.zoomToCursor&&D||n.object.isOrthographicCamera?p.radius=z(p.radius):p.radius=z(p.radius*m),t.setFromSpherical(p),t.applyQuaternion(l),c.copy(n.target).add(t),n.object.lookAt(n.target),!0===n.enableDamping?(u.theta*=1-n.dampingFactor,u.phi*=1-n.dampingFactor,A.multiplyScalar(1-n.dampingFactor)):(u.set(0,0,0),A.set(0,0,0));let y=!1;if(n.zoomToCursor&&D){let s=null;if(n.object.isPerspectiveCamera){const e=t.length();s=z(e*m);const r=e-s;n.object.position.addScaledVector(w,r),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const e=new o(b.x,b.y,0);e.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/m)),n.object.updateProjectionMatrix(),y=!0;const r=new o(b.x,b.y,0);r.unproject(n.object),n.object.position.sub(r).add(e),n.object.updateMatrixWorld(),s=t.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;null!==s&&(this.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(s).add(n.object.position):(_t.origin.copy(n.object.position),_t.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(_t.direction))<Vt?e.lookAt(n.target):(Qt.setFromNormalAndCoplanarPoint(n.object.up,n.target),_t.intersectPlane(Qt,n.target))))}else n.object.isOrthographicCamera&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/m)),n.object.updateProjectionMatrix(),y=!0);return m=1,D=!1,!!(y||h.distanceToSquared(n.object.position)>i||8*(1-d.dot(n.object.quaternion))>i||f.distanceToSquared(n.target)>0)&&(n.dispatchEvent(Ot),h.copy(n.object.position),d.copy(n.object.quaternion),f.copy(n.target),y=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",$),n.domElement.removeEventListener("pointerdown",j),n.domElement.removeEventListener("pointercancel",X),n.domElement.removeEventListener("wheel",J),n.domElement.removeEventListener("pointermove",Y),n.domElement.removeEventListener("pointerup",X),null!==n._domElementKeyEvents&&(n._domElementKeyEvents.removeEventListener("keydown",Z),n._domElementKeyEvents=null)};const n=this,s={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let r=s.NONE;const i=1e-6,p=new h,u=new h;let m=1;const A=new o,f=new d,g=new d,S=new d,C=new d,y=new d,x=new d,v=new d,I=new d,B=new d,w=new o,b=new d;let D=!1;const T=[],E={};function M(){return Math.pow(.95,n.zoomSpeed)}function F(e){u.theta-=e}function R(e){u.phi-=e}const P=function(){const e=new o;return function(t,n){e.setFromMatrixColumn(n,0),e.multiplyScalar(-t),A.add(e)}}(),H=function(){const e=new o;return function(t,s){!0===n.screenSpacePanning?e.setFromMatrixColumn(s,1):(e.setFromMatrixColumn(s,0),e.crossVectors(n.object.up,e)),e.multiplyScalar(t),A.add(e)}}(),k=function(){const e=new o;return function(t,s){const r=n.domElement;if(n.object.isPerspectiveCamera){const i=n.object.position;e.copy(i).sub(n.target);let o=e.length();o*=Math.tan(n.object.fov/2*Math.PI/180),P(2*t*o/r.clientHeight,n.object.matrix),H(2*s*o/r.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(P(t*(n.object.right-n.object.left)/n.object.zoom/r.clientWidth,n.object.matrix),H(s*(n.object.top-n.object.bottom)/n.object.zoom/r.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function L(e){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?m/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function O(e){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?m*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function U(t){if(!n.zoomToCursor)return;D=!0;const s=n.domElement.getBoundingClientRect(),r=t.clientX-s.left,i=t.clientY-s.top,o=s.width,a=s.height;b.x=r/o*2-1,b.y=-i/a*2+1,w.set(b.x,b.y,1).unproject(e).sub(e.position).normalize()}function z(e){return Math.max(n.minDistance,Math.min(n.maxDistance,e))}function _(e){f.set(e.clientX,e.clientY)}function Q(e){C.set(e.clientX,e.clientY)}function V(){if(1===T.length)f.set(T[0].pageX,T[0].pageY);else{const e=.5*(T[0].pageX+T[1].pageX),t=.5*(T[0].pageY+T[1].pageY);f.set(e,t)}}function N(){if(1===T.length)C.set(T[0].pageX,T[0].pageY);else{const e=.5*(T[0].pageX+T[1].pageX),t=.5*(T[0].pageY+T[1].pageY);C.set(e,t)}}function G(){const e=T[0].pageX-T[1].pageX,t=T[0].pageY-T[1].pageY,n=Math.sqrt(e*e+t*t);v.set(0,n)}function K(e){if(1==T.length)g.set(e.pageX,e.pageY);else{const t=te(e),n=.5*(e.pageX+t.x),s=.5*(e.pageY+t.y);g.set(n,s)}S.subVectors(g,f).multiplyScalar(n.rotateSpeed);const t=n.domElement;F(2*Math.PI*S.x/t.clientHeight),R(2*Math.PI*S.y/t.clientHeight),f.copy(g)}function q(e){if(1===T.length)y.set(e.pageX,e.pageY);else{const t=te(e),n=.5*(e.pageX+t.x),s=.5*(e.pageY+t.y);y.set(n,s)}x.subVectors(y,C).multiplyScalar(n.panSpeed),k(x.x,x.y),C.copy(y)}function W(e){const t=te(e),s=e.pageX-t.x,r=e.pageY-t.y,i=Math.sqrt(s*s+r*r);I.set(0,i),B.set(0,Math.pow(I.y/v.y,n.zoomSpeed)),L(B.y),v.copy(I)}function j(e){!1!==n.enabled&&(0===T.length&&(n.domElement.setPointerCapture(e.pointerId),n.domElement.addEventListener("pointermove",Y),n.domElement.addEventListener("pointerup",X)),function(e){T.push(e)}(e),"touch"===e.pointerType?function(e){switch(ee(e),T.length){case 1:switch(n.touches.ONE){case l.ROTATE:if(!1===n.enableRotate)return;V(),r=s.TOUCH_ROTATE;break;case l.PAN:if(!1===n.enablePan)return;N(),r=s.TOUCH_PAN;break;default:r=s.NONE}break;case 2:switch(n.touches.TWO){case l.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;n.enableZoom&&G(),n.enablePan&&N(),r=s.TOUCH_DOLLY_PAN;break;case l.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;n.enableZoom&&G(),n.enableRotate&&V(),r=s.TOUCH_DOLLY_ROTATE;break;default:r=s.NONE}break;default:r=s.NONE}r!==s.NONE&&n.dispatchEvent(Ut)}(e):function(e){let t;switch(e.button){case 0:t=n.mouseButtons.LEFT;break;case 1:t=n.mouseButtons.MIDDLE;break;case 2:t=n.mouseButtons.RIGHT;break;default:t=-1}switch(t){case a.DOLLY:if(!1===n.enableZoom)return;!function(e){U(e),v.set(e.clientX,e.clientY)}(e),r=s.DOLLY;break;case a.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enablePan)return;Q(e),r=s.PAN}else{if(!1===n.enableRotate)return;_(e),r=s.ROTATE}break;case a.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enableRotate)return;_(e),r=s.ROTATE}else{if(!1===n.enablePan)return;Q(e),r=s.PAN}break;default:r=s.NONE}r!==s.NONE&&n.dispatchEvent(Ut)}(e))}function Y(e){!1!==n.enabled&&("touch"===e.pointerType?function(e){switch(ee(e),r){case s.TOUCH_ROTATE:if(!1===n.enableRotate)return;K(e),n.update();break;case s.TOUCH_PAN:if(!1===n.enablePan)return;q(e),n.update();break;case s.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(e){n.enableZoom&&W(e),n.enablePan&&q(e)}(e),n.update();break;case s.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(e){n.enableZoom&&W(e),n.enableRotate&&K(e)}(e),n.update();break;default:r=s.NONE}}(e):function(e){switch(r){case s.ROTATE:if(!1===n.enableRotate)return;!function(e){g.set(e.clientX,e.clientY),S.subVectors(g,f).multiplyScalar(n.rotateSpeed);const t=n.domElement;F(2*Math.PI*S.x/t.clientHeight),R(2*Math.PI*S.y/t.clientHeight),f.copy(g),n.update()}(e);break;case s.DOLLY:if(!1===n.enableZoom)return;!function(e){I.set(e.clientX,e.clientY),B.subVectors(I,v),B.y>0?L(M()):B.y<0&&O(M()),v.copy(I),n.update()}(e);break;case s.PAN:if(!1===n.enablePan)return;!function(e){y.set(e.clientX,e.clientY),x.subVectors(y,C).multiplyScalar(n.panSpeed),k(x.x,x.y),C.copy(y),n.update()}(e)}}(e))}function X(e){!function(e){delete E[e.pointerId];for(let t=0;t<T.length;t++)if(T[t].pointerId==e.pointerId)return void T.splice(t,1)}(e),0===T.length&&(n.domElement.releasePointerCapture(e.pointerId),n.domElement.removeEventListener("pointermove",Y),n.domElement.removeEventListener("pointerup",X)),n.dispatchEvent(zt),r=s.NONE}function J(e){!1!==n.enabled&&!1!==n.enableZoom&&r===s.NONE&&(e.preventDefault(),n.dispatchEvent(Ut),function(e){U(e),e.deltaY<0?O(M()):e.deltaY>0&&L(M()),n.update()}(e),n.dispatchEvent(zt))}function Z(e){!1!==n.enabled&&!1!==n.enablePan&&function(e){let t=!1;switch(e.code){case n.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?R(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):k(0,n.keyPanSpeed),t=!0;break;case n.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?R(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):k(0,-n.keyPanSpeed),t=!0;break;case n.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?F(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):k(n.keyPanSpeed,0),t=!0;break;case n.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?F(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):k(-n.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),n.update())}(e)}function $(e){!1!==n.enabled&&e.preventDefault()}function ee(e){let t=E[e.pointerId];void 0===t&&(t=new d,E[e.pointerId]=t),t.set(e.pageX,e.pageY)}function te(e){const t=e.pointerId===T[0].pointerId?T[1]:T[0];return E[t.pointerId]}n.domElement.addEventListener("contextmenu",$),n.domElement.addEventListener("pointerdown",j),n.domElement.addEventListener("pointercancel",X),n.domElement.addEventListener("wheel",J,{passive:!1}),this.update()}}class Gt{static elementIDGen=0;constructor(e,t){this.taskIDGen=0,this.elementID=Gt.elementIDGen++,this.tasks=[],this.message=e||"Loading...",this.container=t||document.body,this.spinnerContainerOuter=document.createElement("div"),this.spinnerContainerOuter.className=`spinnerOuterContainer${this.elementID}`,this.spinnerContainerOuter.style.display="none",this.spinnerContainerPrimary=document.createElement("div"),this.spinnerContainerPrimary.className=`spinnerContainerPrimary${this.elementID}`,this.spinnerPrimary=document.createElement("div"),this.spinnerPrimary.classList.add(`spinner${this.elementID}`,`spinnerPrimary${this.elementID}`),this.messageContainerPrimary=document.createElement("div"),this.messageContainerPrimary.classList.add(`messageContainer${this.elementID}`,`messageContainerPrimary${this.elementID}`),this.messageContainerPrimary.innerHTML=this.message,this.spinnerContainerMin=document.createElement("div"),this.spinnerContainerMin.className=`spinnerContainerMin${this.elementID}`,this.spinnerMin=document.createElement("div"),this.spinnerMin.classList.add(`spinner${this.elementID}`,`spinnerMin${this.elementID}`),this.messageContainerMin=document.createElement("div"),this.messageContainerMin.classList.add(`messageContainer${this.elementID}`,`messageContainerMin${this.elementID}`),this.messageContainerMin.innerHTML=this.message,this.spinnerContainerPrimary.appendChild(this.spinnerPrimary),this.spinnerContainerPrimary.appendChild(this.messageContainerPrimary),this.spinnerContainerOuter.appendChild(this.spinnerContainerPrimary),this.spinnerContainerMin.appendChild(this.spinnerMin),this.spinnerContainerMin.appendChild(this.messageContainerMin),this.spinnerContainerOuter.appendChild(this.spinnerContainerMin);const n=document.createElement("style");n.innerHTML=`\n\n            .spinnerOuterContainer${this.elementID} {\n                width: 100%;\n                height: 100%;\n                margin: 0;\n                top: 0;\n                left: 0;\n                position: absolute;\n                pointer-events: none;\n            }\n\n            .messageContainer${this.elementID} {\n                height: 20px;\n                font-family: arial;\n                font-size: 12pt;\n                color: #ffffff;\n                text-align: center;\n                vertical-align: middle;\n            }\n\n            .spinner${this.elementID} {\n                padding: 15px;\n                background: #07e8d6;\n                z-index:99999;\n            \n                aspect-ratio: 1;\n                border-radius: 50%;\n                --_m: \n                    conic-gradient(#0000,#000),\n                    linear-gradient(#000 0 0) content-box;\n                -webkit-mask: var(--_m);\n                    mask: var(--_m);\n                -webkit-mask-composite: source-out;\n                    mask-composite: subtract;\n                box-sizing: border-box;\n                animation: load 1s linear infinite;\n            }\n\n            .spinnerContainerPrimary${this.elementID} {\n                z-index:99999;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #666666 1px solid;\n                border-radius: 5px;\n                padding-top: 20px;\n                padding-bottom: 10px;\n                margin: 0;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-80px, -80px);\n                width: 180px;\n                pointer-events: auto;\n            }\n\n            .spinnerPrimary${this.elementID} {\n                width: 120px;\n                margin-left: 30px;\n            }\n\n            .messageContainerPrimary${this.elementID} {\n                padding-top: 15px;\n            }\n\n            .spinnerContainerMin${this.elementID} {\n                z-index:99999;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #666666 1px solid;\n                border-radius: 5px;\n                padding-top: 20px;\n                padding-bottom: 15px;\n                margin: 0;\n                position: absolute;\n                bottom: 50px;\n                left: 50%;\n                transform: translate(-50%, 0);\n                display: flex;\n                flex-direction: left;\n                pointer-events: auto;\n                min-width: 250px;\n            }\n\n            .messageContainerMin${this.elementID} {\n                margin-right: 15px;\n            }\n\n            .spinnerMin${this.elementID} {\n                width: 50px;\n                height: 50px;\n                margin-left: 15px;\n                margin-right: 25px;\n            }\n\n            .messageContainerMin${this.elementID} {\n                padding-top: 15px;\n            }\n            \n            @keyframes load {\n                to{transform: rotate(1turn)}\n            }\n\n        `,this.spinnerContainerOuter.appendChild(n),this.container.appendChild(this.spinnerContainerOuter),this.setMinimized(!1,!0),this.fadeTransitions=[]}addTask(e){const t={message:e,id:this.taskIDGen++};return this.tasks.push(t),this.update(),t.id}removeTask(e){let t=0;for(let n of this.tasks){if(n.id===e){this.tasks.splice(t,1);break}t++}this.update()}removeAllTasks(){this.tasks=[],this.update()}setMessageForTask(e,t){for(let n of this.tasks)if(n.id===e){n.message=t;break}this.update()}update(){this.tasks.length>0?(this.show(),this.setMessage(this.tasks[this.tasks.length-1].message)):this.hide()}show(){this.spinnerContainerOuter.style.display="block",this.visible=!0}hide(){this.spinnerContainerOuter.style.display="none",this.visible=!1}setContainer(e){this.container&&this.spinnerContainerOuter.parentElement===this.container&&this.container.removeChild(this.spinnerContainerOuter),e&&(this.container=e,this.container.appendChild(this.spinnerContainerOuter),this.spinnerContainerOuter.style.zIndex=this.container.style.zIndex+1)}setMinimized(e,t){const n=(e,t,n,s,r)=>{n?e.style.display=t?s:"none":this.fadeTransitions[r]=((e,t,n,s,r)=>{const i=performance.now();let o="none"===e.style.display?0:parseFloat(e.style.opacity);isNaN(o)&&(o=1);const a=window.setInterval(()=>{const l=performance.now()-i;let c,h=Math.min(l/s,1);h>.999&&(h=1),t?(c=(1-h)*o,c<1e-4&&(c=0)):c=(1-o)*h+o,c>0?(e.style.display=n,e.style.opacity=c):e.style.display="none",h>=1&&(r&&r(),window.clearInterval(a))},16);return a})(e,!t,s,500,()=>{this.fadeTransitions[r]=null})};n(this.spinnerContainerPrimary,!e,t,"block",0),n(this.spinnerContainerMin,e,t,"flex",1),this.minimized=e}setMessage(e){this.messageContainerPrimary.innerHTML=e,this.messageContainerMin.innerHTML=e}}class Kt{constructor(e){this.idGen=0,this.tasks=[],this.container=e||document.body,this.progressBarContainerOuter=document.createElement("div"),this.progressBarContainerOuter.className="progressBarOuterContainer",this.progressBarContainerOuter.style.display="none",this.progressBarBox=document.createElement("div"),this.progressBarBox.className="progressBarBox",this.progressBarBackground=document.createElement("div"),this.progressBarBackground.className="progressBarBackground",this.progressBar=document.createElement("div"),this.progressBar.className="progressBar",this.progressBarBackground.appendChild(this.progressBar),this.progressBarBox.appendChild(this.progressBarBackground),this.progressBarContainerOuter.appendChild(this.progressBarBox);const t=document.createElement("style");t.innerHTML="\n\n            .progressBarOuterContainer {\n                width: 100%;\n                height: 100%;\n                margin: 0;\n                top: 0;\n                left: 0;\n                position: absolute;\n                pointer-events: none;\n            }\n\n            .progressBarBox {\n                z-index:99999;\n                padding: 7px 9px 5px 7px;\n                background-color: rgba(190, 190, 190, 0.75);\n                border: #555555 1px solid;\n                border-radius: 15px;\n                margin: 0;\n                position: absolute;\n                bottom: 50px;\n                left: 50%;\n                transform: translate(-50%, 0);\n                width: 180px;\n                height: 30px;\n                pointer-events: auto;\n            }\n\n            .progressBarBackground {\n                width: 100%;\n                height: 25px;\n                border-radius:10px;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #444444 1px solid;\n                box-shadow: inset 0 0 10px #333333;\n            }\n\n            .progressBar {\n                height: 25px;\n                width: 0px;\n                border-radius:10px;\n                background-color: rgba(0, 200, 0, 0.75);\n                box-shadow: inset 0 0 10px #003300;\n            }\n\n        ",this.progressBarContainerOuter.appendChild(t),this.container.appendChild(this.progressBarContainerOuter)}show(){this.progressBarContainerOuter.style.display="block"}hide(){this.progressBarContainerOuter.style.display="none"}setProgress(e){this.progressBar.style.width=e+"%"}setContainer(e){this.container&&this.progressBarContainerOuter.parentElement===this.container&&this.container.removeChild(this.progressBarContainerOuter),e&&(this.container=e,this.container.appendChild(this.progressBarContainerOuter),this.progressBarContainerOuter.style.zIndex=this.container.style.zIndex+1)}}class qt{constructor(e){this.container=e||document.body,this.infoCells={};const t=[["Camera position","cameraPosition"],["Camera look-at","cameraLookAt"],["Camera up","cameraUp"],["Camera mode","orthographicCamera"],["Cursor position","cursorPosition"],["FPS","fps"],["Rendering:","renderSplatCount"],["Sort time","sortTime"],["Render window","renderWindow"],["Focal adjustment","focalAdjustment"],["Splat scale","splatScale"],["Point cloud mode","pointCloudMode"]];this.infoPanelContainer=document.createElement("div");const n=document.createElement("style");n.innerHTML="\n\n            .infoPanel {\n                width: 430px;\n                padding: 10px;\n                background-color: rgba(50, 50, 50, 0.85);\n                border: #555555 2px solid;\n                color: #dddddd;\n                border-radius: 10px;\n                z-index: 9999;\n                font-family: arial;\n                font-size: 11pt;\n                text-align: left;\n                margin: 0;\n                top: 10px;\n                left:10px;\n                position: absolute;\n                pointer-events: auto;\n            }\n\n            .info-panel-cell {\n                margin-bottom: 5px;\n                padding-bottom: 2px;\n            }\n\n            .label-cell {\n                font-weight: bold;\n                font-size: 12pt;\n                width: 140px;\n            }\n\n        ",this.infoPanelContainer.append(n),this.infoPanel=document.createElement("div"),this.infoPanel.className="infoPanel";const s=document.createElement("div");s.style.display="table";for(let r of t){const e=document.createElement("div");e.style.display="table-row",e.className="info-panel-row";const t=document.createElement("div");t.style.display="table-cell",t.innerHTML=`${r[0]}: `,t.classList.add("info-panel-cell","label-cell");const n=document.createElement("div");n.style.display="table-cell",n.style.width="10px",n.innerHTML=" ",n.className="info-panel-cell";const i=document.createElement("div");i.style.display="table-cell",i.innerHTML="",i.className="info-panel-cell",this.infoCells[r[1]]=i,e.appendChild(t),e.appendChild(n),e.appendChild(i),s.appendChild(e)}this.infoPanel.appendChild(s),this.infoPanelContainer.append(this.infoPanel),this.infoPanelContainer.style.display="none",this.container.appendChild(this.infoPanelContainer),this.visible=!1}update=function(e,t,n,s,r,i,o,a,l,c,h,d,p,u){const m=`${t.x.toFixed(5)}, ${t.y.toFixed(5)}, ${t.z.toFixed(5)}`;if(this.infoCells.cameraPosition.innerHTML!==m&&(this.infoCells.cameraPosition.innerHTML=m),n){const e=n,t=`${e.x.toFixed(5)}, ${e.y.toFixed(5)}, ${e.z.toFixed(5)}`;this.infoCells.cameraLookAt.innerHTML!==t&&(this.infoCells.cameraLookAt.innerHTML=t)}const A=`${s.x.toFixed(5)}, ${s.y.toFixed(5)}, ${s.z.toFixed(5)}`;if(this.infoCells.cameraUp.innerHTML!==A&&(this.infoCells.cameraUp.innerHTML=A),this.infoCells.orthographicCamera.innerHTML=r?"Orthographic":"Perspective",i){const e=i,t=`${e.x.toFixed(5)}, ${e.y.toFixed(5)}, ${e.z.toFixed(5)}`;this.infoCells.cursorPosition.innerHTML=t}else this.infoCells.cursorPosition.innerHTML="N/A";this.infoCells.fps.innerHTML=o,this.infoCells.renderWindow.innerHTML=`${e.x} x ${e.y}`,this.infoCells.renderSplatCount.innerHTML=`${l} splats out of ${a} (${c.toFixed(2)}%)`,this.infoCells.sortTime.innerHTML=`${h.toFixed(3)} ms`,this.infoCells.focalAdjustment.innerHTML=`${d.toFixed(3)}`,this.infoCells.splatScale.innerHTML=`${p.toFixed(3)}`,this.infoCells.pointCloudMode.innerHTML=`${u}`};setContainer(e){this.container&&this.infoPanelContainer.parentElement===this.container&&this.container.removeChild(this.infoPanelContainer),e&&(this.container=e,this.container.appendChild(this.infoPanelContainer),this.infoPanelContainer.style.zIndex=this.container.style.zIndex+1)}show(){this.infoPanelContainer.style.display="block",this.visible=!0}hide(){this.infoPanelContainer.style.display="none",this.visible=!1}}const Wt=new t.Vector3;class jt extends t.Object3D{constructor(e=new t.Vector3(0,0,1),n=new t.Vector3(0,0,0),s=1,r=.1,i=16776960,o=.2*s,a=.2*o){super(),this.type="ArrowHelper";const l=new t.CylinderGeometry(r,r,s,32);l.translate(0,s/2,0);const c=new t.CylinderGeometry(0,a,o,32);c.translate(0,s,0),this.position.copy(n),this.line=new t.Mesh(l,new t.MeshBasicMaterial({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new t.Mesh(c,new t.MeshBasicMaterial({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{Wt.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(Wt,t)}}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class Yt{constructor(e){this.threeScene=e,this.splatRenderTarget=null,this.renderTargetCopyQuad=null,this.renderTargetCopyCamera=null,this.meshCursor=null,this.focusMarker=null,this.controlPlane=null,this.debugRoot=null,this.secondaryDebugRoot=null}updateSplatRenderTargetForRenderDimensions(e,n){this.destroySplatRendertarget(),this.splatRenderTarget=new t.WebGLRenderTarget(e,n,{format:t.RGBAFormat,stencilBuffer:!1,depthBuffer:!0}),this.splatRenderTarget.depthTexture=new t.DepthTexture(e,n),this.splatRenderTarget.depthTexture.format=t.DepthFormat,this.splatRenderTarget.depthTexture.type=t.UnsignedIntType}destroySplatRendertarget(){this.splatRenderTarget&&(this.splatRenderTarget=null)}setupRenderTargetCopyObjects(){const e=new t.ShaderMaterial({vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4( position.xy, 0.0, 1.0 );    \n                }\n            ",fragmentShader:"\n                #include <common>\n                #include <packing>\n                varying vec2 vUv;\n                uniform sampler2D sourceColorTexture;\n                uniform sampler2D sourceDepthTexture;\n                void main() {\n                    vec4 color = texture2D(sourceColorTexture, vUv);\n                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;\n                    gl_FragDepth = fragDepth;\n                    gl_FragColor = vec4(color.rgb, color.a * 2.0);\n              }\n            ",uniforms:{sourceColorTexture:{type:"t",value:null},sourceDepthTexture:{type:"t",value:null}},depthWrite:!1,depthTest:!1,transparent:!0,blending:t.CustomBlending,blendSrc:t.SrcAlphaFactor,blendSrcAlpha:t.SrcAlphaFactor,blendDst:t.OneMinusSrcAlphaFactor,blendDstAlpha:t.OneMinusSrcAlphaFactor});e.extensions.fragDepth=!0,this.renderTargetCopyQuad=new t.Mesh(new t.PlaneGeometry(2,2),e),this.renderTargetCopyCamera=new t.OrthographicCamera(-1,1,1,-1,0,1)}destroyRenderTargetCopyObjects(){this.renderTargetCopyQuad&&(C(this.renderTargetCopyQuad),this.renderTargetCopyQuad=null)}setupMeshCursor(){if(!this.meshCursor){const e=new t.ConeGeometry(.5,1.5,32),n=new t.MeshBasicMaterial({color:16777215}),s=new t.Mesh(e,n);s.rotation.set(0,0,Math.PI),s.position.set(0,1,0);const r=new t.Mesh(e,n);r.position.set(0,-1,0);const i=new t.Mesh(e,n);i.rotation.set(0,0,Math.PI/2),i.position.set(1,0,0);const o=new t.Mesh(e,n);o.rotation.set(0,0,-Math.PI/2),o.position.set(-1,0,0),this.meshCursor=new t.Object3D,this.meshCursor.add(s),this.meshCursor.add(r),this.meshCursor.add(i),this.meshCursor.add(o),this.meshCursor.scale.set(.1,.1,.1),this.threeScene.add(this.meshCursor),this.meshCursor.visible=!1}}destroyMeshCursor(){this.meshCursor&&(C(this.meshCursor),this.threeScene.remove(this.meshCursor),this.meshCursor=null)}setMeshCursorVisibility(e){this.meshCursor.visible=e}getMeschCursorVisibility(){return this.meshCursor.visible}setMeshCursorPosition(e){this.meshCursor.position.copy(e)}positionAndOrientMeshCursor(e,t){this.meshCursor.position.copy(e),this.meshCursor.up.copy(t.up),this.meshCursor.lookAt(t.position)}setupFocusMarker(){if(!this.focusMarker){const e=new t.SphereGeometry(.5,32,32),n=Yt.buildFocusMarkerMaterial();n.depthTest=!1,n.depthWrite=!1,n.transparent=!0,this.focusMarker=new t.Mesh(e,n)}}destroyFocusMarker(){this.focusMarker&&(C(this.focusMarker),this.focusMarker=null)}updateFocusMarker=function(){const e=new t.Vector3,n=new t.Matrix4,s=new t.Vector3;return function(t,r,i){n.copy(r.matrixWorld).invert(),e.copy(t).applyMatrix4(n),e.normalize().multiplyScalar(10),e.applyMatrix4(r.matrixWorld),s.copy(r.position).sub(t);const o=s.length();this.focusMarker.position.copy(t),this.focusMarker.scale.set(o,o,o),this.focusMarker.material.uniforms.realFocusPosition.value.copy(t),this.focusMarker.material.uniforms.viewport.value.copy(i),this.focusMarker.material.uniformsNeedUpdate=!0}}();setFocusMarkerVisibility(e){this.focusMarker.visible=e}setFocusMarkerOpacity(e){this.focusMarker.material.uniforms.opacity.value=e,this.focusMarker.material.uniformsNeedUpdate=!0}getFocusMarkerOpacity(){return this.focusMarker.material.uniforms.opacity.value}setupControlPlane(){if(!this.controlPlane){const e=new t.PlaneGeometry(1,1);e.rotateX(-Math.PI/2);const n=new t.MeshBasicMaterial({color:16777215});n.transparent=!0,n.opacity=.6,n.depthTest=!1,n.depthWrite=!1,n.side=t.DoubleSide;const s=new t.Mesh(e,n),r=new t.Vector3(0,1,0);r.normalize();const i=new t.Vector3(0,0,0),o=new jt(r,i,.5,.01,56576,.1,.03);this.controlPlane=new t.Object3D,this.controlPlane.add(s),this.controlPlane.add(o)}}destroyControlPlane(){this.controlPlane&&(C(this.controlPlane),this.controlPlane=null)}setControlPlaneVisibility(e){this.controlPlane.visible=e}positionAndOrientControlPlane=function(){const e=new t.Quaternion,n=new t.Vector3(0,1,0);return function(t,s){e.setFromUnitVectors(n,s),this.controlPlane.position.copy(t),this.controlPlane.quaternion.copy(e)}}();addDebugMeshes(){this.debugRoot=this.createDebugMeshes(),this.secondaryDebugRoot=this.createSecondaryDebugMeshes(),this.threeScene.add(this.debugRoot),this.threeScene.add(this.secondaryDebugRoot)}destroyDebugMeshes(){for(let e of[this.debugRoot,this.secondaryDebugRoot])e&&(C(e),this.threeScene.remove(e));this.debugRoot=null,this.secondaryDebugRoot=null}createDebugMeshes(e){const n=new t.SphereGeometry(1,32,32),s=new t.Object3D,r=(r,i)=>{let o=new t.Mesh(n,Yt.buildDebugMaterial(r));o.renderOrder=e,s.add(o),o.position.fromArray(i)};return r(16711680,[-50,0,0]),r(16711680,[50,0,0]),r(65280,[0,0,-50]),r(65280,[0,0,50]),r(16755200,[5,0,5]),s}createSecondaryDebugMeshes(e){const n=new t.BoxGeometry(3,3,3),s=new t.Object3D;const r=r=>{let i=new t.Mesh(n,Yt.buildDebugMaterial(12303291));i.renderOrder=e,s.add(i),i.position.fromArray(r)};let i=10;return r([-10,0,-10]),r([-10,0,i]),r([i,0,-10]),r([i,0,i]),s}static buildDebugMaterial(e){const n={color:{type:"v3",value:new t.Color(e)}},s=new t.ShaderMaterial({uniforms:n,vertexShader:"\n            #include <common>\n            varying float ndcDepth;\n\n            void main() {\n                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);\n                ndcDepth = gl_Position.z / gl_Position.w;\n                gl_Position.x = gl_Position.x / gl_Position.w;\n                gl_Position.y = gl_Position.y / gl_Position.w;\n                gl_Position.z = 0.0;\n                gl_Position.w = 1.0;\n    \n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            varying float ndcDepth;\n            void main() {\n                gl_FragDepth = (ndcDepth + 1.0) / 2.0;\n                gl_FragColor = vec4(color.rgb, 0.0);\n            }\n        ",transparent:!1,depthTest:!0,depthWrite:!0,side:t.FrontSide});return s.extensions.fragDepth=!0,s}static buildFocusMarkerMaterial(e){const n={color:{type:"v3",value:new t.Color(e)},realFocusPosition:{type:"v3",value:new t.Vector3},viewport:{type:"v2",value:new t.Vector2},opacity:{value:0}};return new t.ShaderMaterial({uniforms:n,vertexShader:"\n            #include <common>\n\n            uniform vec2 viewport;\n            uniform vec3 realFocusPosition;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                float radius = 0.01;\n\n                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);\n                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n\n                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);\n\n                ndcPosition = projectionMatrix * viewPosition;\n                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);\n                ndcCenter = projectionMatrix * viewCenter;\n                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);\n\n                ndcFocusPosition = projectionMatrix * viewFocusPosition;\n                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);\n\n                gl_Position = projectionMatrix * viewPosition;\n\n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            uniform vec2 viewport;\n            uniform float opacity;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                vec2 screenPosition = vec2(ndcPosition) * viewport;\n                vec2 screenCenter = vec2(ndcCenter) * viewport;\n\n                vec2 screenVec = screenPosition - screenCenter;\n\n                float projectedRadius = length(screenVec);\n\n                float lineWidth = 0.0005 * viewport.y;\n                float aaRange = 0.0025 * viewport.y;\n                float radius = 0.06 * viewport.y;\n                float radDiff = abs(projectedRadius - radius) - lineWidth;\n                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); \n\n                gl_FragColor = vec4(color.rgb, alpha * opacity);\n            }\n        ",transparent:!0,depthTest:!1,depthWrite:!1,side:t.FrontSide})}dispose(){this.destroyMeshCursor(),this.destroyFocusMarker(),this.destroyDebugMeshes(),this.destroyControlPlane(),this.destroyRenderTargetCopyObjects(),this.destroySplatRendertarget()}}const Xt=new t.Vector3(1,0,0),Jt=new t.Vector3(0,1,0),Zt=new t.Vector3(0,0,1);class $t{constructor(e=new t.Vector3,n=new t.Vector3){this.origin=new t.Vector3,this.direction=new t.Vector3,this.setParameters(e,n)}setParameters(e,t){this.origin.copy(e),this.direction.copy(t).normalize()}boxContainsPoint(e,t,n){return!(t.x<e.min.x-n||t.x>e.max.x+n||t.y<e.min.y-n||t.y>e.max.y+n||t.z<e.min.z-n||t.z>e.max.z+n)}intersectBox=function(){const e=new t.Vector3,n=[],s=[],r=[];return function(t,i){if(s[0]=this.origin.x,s[1]=this.origin.y,s[2]=this.origin.z,r[0]=this.direction.x,r[1]=this.direction.y,r[2]=this.direction.z,this.boxContainsPoint(t,this.origin,1e-4))return i&&(i.origin.copy(this.origin),i.normal.set(0,0,0),i.distance=-1),!0;for(let o=0;o<3;o++){if(0==r[o])continue;const a=0==o?Xt:1==o?Jt:Zt,l=r[o]<0?t.max:t.min;let c=-Math.sign(r[o]);n[0]=0==o?l.x:1==o?l.y:l.z;let h=n[0]-s[o];if(h*c<0){const l=(o+1)%3,d=(o+2)%3;if(n[2]=r[l]/r[o]*h+s[l],n[1]=r[d]/r[o]*h+s[d],e.set(n[o],n[d],n[l]),this.boxContainsPoint(t,e,1e-4))return i&&(i.origin.copy(e),i.normal.copy(a).multiplyScalar(c),i.distance=e.sub(this.origin).length()),!0}}return!1}}();intersectSphere=function(){const e=new t.Vector3;return function(t,n,s){e.copy(t).sub(this.origin);const r=e.dot(this.direction),i=r*r,o=e.dot(e)-i,a=n*n;if(o>a)return!1;const l=Math.sqrt(a-o),c=r-l,h=r+l;if(h<0)return!1;let d=c<0?h:c;return s&&(s.origin.copy(this.origin).addScaledVector(this.direction,d),s.normal.copy(s.origin).sub(t).normalize(),s.distance=d),!0}}()}class en{constructor(){this.origin=new t.Vector3,this.normal=new t.Vector3,this.distance=0,this.splatIndex=0}set(e,t,n,s){this.origin.copy(e),this.normal.copy(t),this.distance=n,this.splatIndex=s}clone(){const e=new en;return e.origin.copy(this.origin),e.normal.copy(this.normal),e.distance=this.distance,e.splatIndex=this.splatIndex,e}}const tn=0,nn=1;class sn{constructor(e,t,n=!1){this.ray=new $t(e,t),this.raycastAgainstTrueSplatEllipsoid=n}setFromCameraAndScreenPosition=function(){const e=new t.Vector2;return function(t,n,s){if(e.x=n.x/s.x*2-1,e.y=(s.y-n.y)/s.y*2-1,t.isPerspectiveCamera)this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t;else{if(!t.isOrthographicCamera)throw new Error("Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type");this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t}}}();intersectSplatMesh=function(){const e=new t.Matrix4,n=new t.Matrix4,s=new t.Matrix4,r=new $t,i=new t.Vector3;return function(t,o=[]){const a=t.getSplatTree();if(a){for(let l=0;l<a.subTrees.length;l++){const c=a.subTrees[l];n.copy(t.matrixWorld),t.dynamicMode&&(t.getSceneTransform(l,s),n.multiply(s)),e.copy(n).invert(),r.origin.copy(this.ray.origin).applyMatrix4(e),r.direction.copy(this.ray.origin).add(this.ray.direction),r.direction.applyMatrix4(e).sub(r.origin).normalize();const h=[];c.rootNode&&this.castRayAtSplatTreeNode(r,a,c.rootNode,h),h.forEach(e=>{e.origin.applyMatrix4(n),e.normal.applyMatrix4(n).normalize(),e.distance=i.copy(e.origin).sub(this.ray.origin).length()}),o.push(...h)}return o.sort((e,t)=>e.distance>t.distance?1:-1),o}}}();castRayAtSplatTreeNode=function(){const e=new t.Vector4,n=new t.Vector3,s=new t.Vector3,r=new t.Quaternion,i=new en,o=1e-7,a=new t.Vector3(0,0,0),l=new t.Matrix4,c=new t.Matrix4,h=new t.Matrix4,d=new t.Matrix4,p=new t.Matrix4,u=new $t;return function(t,m,A,f=[]){if(t.intersectBox(A.boundingBox)){if(A.data&&A.data.indexes&&A.data.indexes.length>0)for(let g=0;g<A.data.indexes.length;g++){const S=A.data.indexes[g],C=m.splatMesh.getSceneIndexForSplat(S);if(m.splatMesh.getScene(C).visible&&(m.splatMesh.getSplatColor(S,e),m.splatMesh.getSplatCenter(S,n),m.splatMesh.getSplatScaleAndRotation(S,s,r),!(s.x<=o||s.y<=o||m.splatMesh.splatRenderMode===tn&&s.z<=o)))if(this.raycastAgainstTrueSplatEllipsoid){c.makeScale(s.x,s.y,s.z),h.makeRotationFromQuaternion(r);const o=2*Math.log10(e.w);if(l.makeScale(o,o,o),p.copy(l).multiply(h).multiply(c),d.copy(p).invert(),u.origin.copy(t.origin).sub(n).applyMatrix4(d),u.direction.copy(t.origin).add(t.direction).sub(n),u.direction.applyMatrix4(d).sub(u.origin).normalize(),u.intersectSphere(a,1,i)){const e=i.clone();e.splatIndex=S,e.origin.applyMatrix4(p).add(n),f.push(e)}}else{let e=s.x+s.y,r=2;if(m.splatMesh.splatRenderMode===tn&&(e+=s.z,r=3),e/=r,t.intersectSphere(n,e,i)){const e=i.clone();e.splatIndex=S,f.push(e)}}}if(A.children&&A.children.length>0)for(let e of A.children)this.castRayAtSplatTreeNode(t,m,e,f);return f}}}()}class rn{static buildVertexShaderBase(e=!1,t=!1,n=0,s=""){let r="\n        precision highp float;\n        #include <common>\n\n        attribute uint splatIndex;\n        uniform highp usampler2D centersColorsTexture;\n        uniform highp sampler2D sphericalHarmonicsTexture;\n        uniform highp sampler2D sphericalHarmonicsTextureR;\n        uniform highp sampler2D sphericalHarmonicsTextureG;\n        uniform highp sampler2D sphericalHarmonicsTextureB;\n\n        uniform highp usampler2D sceneIndexesTexture;\n        uniform vec2 sceneIndexesTextureSize;\n        uniform int sceneCount;\n    ";return t&&(r+=`\n            uniform float sceneOpacity[${T.MaxScenes}];\n            uniform int sceneVisibility[${T.MaxScenes}];\n        `),e&&(r+=`\n            uniform highp mat4 transforms[${T.MaxScenes}];\n        `),r+=`\n        ${s}\n        uniform vec2 focal;\n        uniform float orthoZoom;\n        uniform int orthographicMode;\n        uniform int pointCloudModeEnabled;\n        uniform float inverseFocalAdjustment;\n        uniform vec2 viewport;\n        uniform vec2 basisViewport;\n        uniform vec2 centersColorsTextureSize;\n        uniform int sphericalHarmonicsDegree;\n        uniform vec2 sphericalHarmonicsTextureSize;\n        uniform int sphericalHarmonics8BitMode;\n        uniform int sphericalHarmonicsMultiTextureMode;\n        uniform float visibleRegionRadius;\n        uniform float visibleRegionFadeStartRadius;\n        uniform float firstRenderTime;\n        uniform float currentTime;\n        uniform int fadeInComplete;\n        uniform vec3 sceneCenter;\n        uniform float splatScale;\n        uniform float sphericalHarmonics8BitCompressionRangeMin[${T.MaxScenes}];\n        uniform float sphericalHarmonics8BitCompressionRangeMax[${T.MaxScenes}];\n\n        varying vec4 vColor;\n        varying vec2 vUv;\n        varying vec2 vPosition;\n\n        mat3 quaternionToRotationMatrix(float x, float y, float z, float w) {\n            float s = 1.0 / sqrt(w * w + x * x + y * y + z * z);\n        \n            return mat3(\n                1. - 2. * (y * y + z * z),\n                2. * (x * y + w * z),\n                2. * (x * z - w * y),\n                2. * (x * y - w * z),\n                1. - 2. * (x * x + z * z),\n                2. * (y * z + w * x),\n                2. * (x * z + w * y),\n                2. * (y * z - w * x),\n                1. - 2. * (x * x + y * y)\n            );\n        }\n\n        const float sqrt8 = sqrt(8.0);\n        const float minAlpha = 1.0 / 255.0;\n\n        const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n        const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));\n        const uvec4 shift4 = uvec4(0, 8, 16, 24);\n        vec4 uintToRGBAVec (uint u) {\n           uvec4 urgba = mask4 & u;\n           urgba = urgba >> shift4;\n           vec4 rgba = vec4(urgba) * encodeNorm4;\n           return rgba;\n        }\n\n        vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {\n            vec2 samplerUV = vec2(0.0, 0.0);\n            float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;\n            samplerUV.y = float(floor(d)) / dimensions.y;\n            samplerUV.x = fract(d);\n            return samplerUV;\n        }\n\n        vec2 getDataUVF(in uint sIndex, in float stride, in uint offset, in vec2 dimensions) {\n            vec2 samplerUV = vec2(0.0, 0.0);\n            float d = float(uint(float(sIndex) * stride) + offset) / dimensions.x;\n            samplerUV.y = float(floor(d)) / dimensions.y;\n            samplerUV.x = fract(d);\n            return samplerUV;\n        }\n\n        const float SH_C1 = 0.4886025119029199f;\n        const float[5] SH_C2 = float[](1.0925484, -1.0925484, 0.3153916, -1.0925484, 0.5462742);\n\n        void main () {\n\n            uint oddOffset = splatIndex & uint(0x00000001);\n            uint doubleOddOffset = oddOffset * uint(2);\n            bool isEven = oddOffset == uint(0);\n            uint nearestEvenIndex = splatIndex - oddOffset;\n            float fOddOffset = float(oddOffset);\n\n            uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));\n            vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));\n\n            uint sceneIndex = uint(0);\n            if (sceneCount > 1) {\n                sceneIndex = texture(sceneIndexesTexture, getDataUV(1, 0, sceneIndexesTextureSize)).r;\n            }\n            `,t&&(r+="\n                float splatOpacityFromScene = sceneOpacity[sceneIndex];\n                int sceneVisible = sceneVisibility[sceneIndex];\n                if (splatOpacityFromScene <= 0.01 || sceneVisible == 0) {\n                    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                    return;\n                }\n            "),r+=e?"\n                mat4 transform = transforms[sceneIndex];\n                mat4 transformModelViewMatrix = viewMatrix * transform;\n            ":"mat4 transformModelViewMatrix = modelViewMatrix;",r+="\n            float sh8BitCompressionRangeMinForScene = sphericalHarmonics8BitCompressionRangeMin[sceneIndex];\n            float sh8BitCompressionRangeMaxForScene = sphericalHarmonics8BitCompressionRangeMax[sceneIndex];\n            float sh8BitCompressionRangeForScene = sh8BitCompressionRangeMaxForScene - sh8BitCompressionRangeMinForScene;\n            float sh8BitCompressionHalfRangeForScene = sh8BitCompressionRangeForScene / 2.0;\n            vec3 vec8BitSHShift = vec3(sh8BitCompressionRangeMinForScene);\n\n            vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);\n\n            vec4 clipCenter = projectionMatrix * viewCenter;\n\n            float clip = 1.2 * clipCenter.w;\n            if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {\n                gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                return;\n            }\n\n            vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n            vPosition = position.xy;\n            vColor = uintToRGBAVec(sampledCenterColor.r);\n        ",n>=1&&(r+="   \n            if (sphericalHarmonicsDegree >= 1) {\n            ",r+=e?"\n                    vec3 worldViewDir = normalize(splatCenter - vec3(inverse(transform) * vec4(cameraPosition, 1.0)));\n                ":"\n                    vec3 worldViewDir = normalize(splatCenter - cameraPosition);\n                ",r+="\n                vec3 sh1;\n                vec3 sh2;\n                vec3 sh3;\n            ",n>=2&&(r+="\n                    vec3 sh4;\n                    vec3 sh5;\n                    vec3 sh6;\n                    vec3 sh7;\n                    vec3 sh8;\n                "),1===n?r+="\n                    if (sphericalHarmonicsMultiTextureMode == 0) {\n                        vec2 shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset, sphericalHarmonicsTextureSize);\n                        vec4 sampledSH0123 = texture(sphericalHarmonicsTexture, shUV);\n                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(1), sphericalHarmonicsTextureSize);\n                        vec4 sampledSH4567 = texture(sphericalHarmonicsTexture, shUV);\n                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(2), sphericalHarmonicsTextureSize);\n                        vec4 sampledSH891011 = texture(sphericalHarmonicsTexture, shUV);\n                        sh1 = vec3(sampledSH0123.rgb) * (1.0 - fOddOffset) + vec3(sampledSH0123.ba, sampledSH4567.r) * fOddOffset;\n                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg) * (1.0 - fOddOffset) + vec3(sampledSH4567.gba) * fOddOffset;\n                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r) * (1.0 - fOddOffset) + vec3(sampledSH891011.rgb) * fOddOffset;\n                    } else {\n                        vec2 sampledSH01R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH23R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH01G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH23G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH01B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH23B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                        sh1 = vec3(sampledSH01R.rg, sampledSH23R.r);\n                        sh2 = vec3(sampledSH01G.rg, sampledSH23G.r);\n                        sh3 = vec3(sampledSH01B.rg, sampledSH23B.r);\n                    }\n                ":2===n&&(r+="\n                    vec4 sampledSH0123;\n                    vec4 sampledSH4567;\n                    vec4 sampledSH891011;\n\n                    vec4 sampledSH0123R;\n                    vec4 sampledSH0123G;\n                    vec4 sampledSH0123B;\n\n                    if (sphericalHarmonicsMultiTextureMode == 0) {\n                        sampledSH0123 = texture(sphericalHarmonicsTexture, getDataUV(6, 0, sphericalHarmonicsTextureSize));\n                        sampledSH4567 = texture(sphericalHarmonicsTexture, getDataUV(6, 1, sphericalHarmonicsTextureSize));\n                        sampledSH891011 = texture(sphericalHarmonicsTexture, getDataUV(6, 2, sphericalHarmonicsTextureSize));\n                        sh1 = sampledSH0123.rgb;\n                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg);\n                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r);\n                    } else {\n                        sampledSH0123R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                        sampledSH0123G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                        sampledSH0123B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                        sh1 = vec3(sampledSH0123R.rgb);\n                        sh2 = vec3(sampledSH0123G.rgb);\n                        sh3 = vec3(sampledSH0123B.rgb);\n                    }\n                "),r+="\n                    if (sphericalHarmonics8BitMode == 1) {\n                        sh1 = sh1 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                        sh2 = sh2 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                        sh3 = sh3 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                    }\n                    float x = worldViewDir.x;\n                    float y = worldViewDir.y;\n                    float z = worldViewDir.z;\n                    vColor.rgb += SH_C1 * (-sh1 * y + sh2 * z - sh3 * x);\n            ",n>=2&&(r+="\n                    if (sphericalHarmonicsDegree >= 2) {\n                        float xx = x * x;\n                        float yy = y * y;\n                        float zz = z * z;\n                        float xy = x * y;\n                        float yz = y * z;\n                        float xz = x * z;\n                ",2===n&&(r+="\n                        if (sphericalHarmonicsMultiTextureMode == 0) {\n                            vec4 sampledSH12131415 = texture(sphericalHarmonicsTexture, getDataUV(6, 3, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH16171819 = texture(sphericalHarmonicsTexture, getDataUV(6, 4, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH20212223 = texture(sphericalHarmonicsTexture, getDataUV(6, 5, sphericalHarmonicsTextureSize));\n                            sh4 = sampledSH891011.gba;\n                            sh5 = sampledSH12131415.rgb;\n                            sh6 = vec3(sampledSH12131415.a, sampledSH16171819.rg);\n                            sh7 = vec3(sampledSH16171819.ba, sampledSH20212223.r);\n                            sh8 = sampledSH20212223.gba;\n                        } else {\n                            vec4 sampledSH4567R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH4567G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH4567B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                            sh4 = vec3(sampledSH0123R.a, sampledSH4567R.rg);\n                            sh5 = vec3(sampledSH4567R.ba, sampledSH0123G.a);\n                            sh6 = vec3(sampledSH4567G.rgb);\n                            sh7 = vec3(sampledSH4567G.a, sampledSH0123B.a, sampledSH4567B.r);\n                            sh8 = vec3(sampledSH4567B.gba);\n                        }\n                    "),r+="\n                        if (sphericalHarmonics8BitMode == 1) {\n                            sh4 = sh4 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh5 = sh5 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh6 = sh6 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh7 = sh7 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh8 = sh8 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                        }\n\n                        vColor.rgb +=\n                            (SH_C2[0] * xy) * sh4 +\n                            (SH_C2[1] * yz) * sh5 +\n                            (SH_C2[2] * (2.0 * zz - xx - yy)) * sh6 +\n                            (SH_C2[3] * xz) * sh7 +\n                            (SH_C2[4] * (xx - yy)) * sh8;\n                    }\n                "),r+="\n\n                vColor.rgb = clamp(vColor.rgb, vec3(0.), vec3(1.));\n\n            }\n\n            "),r}static getVertexShaderFadeIn(){return"\n            if (fadeInComplete == 0) {\n                float opacityAdjust = 1.0;\n                float centerDist = length(splatCenter - sceneCenter);\n                float renderTime = max(currentTime - firstRenderTime, 0.0);\n\n                float fadeDistance = 0.75;\n                float distanceLoadFadeInFactor = step(visibleRegionFadeStartRadius, centerDist);\n                distanceLoadFadeInFactor = (1.0 - distanceLoadFadeInFactor) +\n                                        (1.0 - clamp((centerDist - visibleRegionFadeStartRadius) / fadeDistance, 0.0, 1.0)) *\n                                        distanceLoadFadeInFactor;\n                opacityAdjust *= distanceLoadFadeInFactor;\n                vColor.a *= opacityAdjust;\n            }\n        "}static getUniforms(e=!1,n=!1,s=0,r=1,i=!1){const o={sceneCenter:{type:"v3",value:new t.Vector3},fadeInComplete:{type:"i",value:0},orthographicMode:{type:"i",value:0},visibleRegionFadeStartRadius:{type:"f",value:0},visibleRegionRadius:{type:"f",value:0},currentTime:{type:"f",value:0},firstRenderTime:{type:"f",value:0},centersColorsTexture:{type:"t",value:null},sphericalHarmonicsTexture:{type:"t",value:null},sphericalHarmonicsTextureR:{type:"t",value:null},sphericalHarmonicsTextureG:{type:"t",value:null},sphericalHarmonicsTextureB:{type:"t",value:null},sphericalHarmonics8BitCompressionRangeMin:{type:"f",value:[]},sphericalHarmonics8BitCompressionRangeMax:{type:"f",value:[]},focal:{type:"v2",value:new t.Vector2},orthoZoom:{type:"f",value:1},inverseFocalAdjustment:{type:"f",value:1},viewport:{type:"v2",value:new t.Vector2},basisViewport:{type:"v2",value:new t.Vector2},debugColor:{type:"v3",value:new t.Color},centersColorsTextureSize:{type:"v2",value:new t.Vector2(1024,1024)},sphericalHarmonicsDegree:{type:"i",value:s},sphericalHarmonicsTextureSize:{type:"v2",value:new t.Vector2(1024,1024)},sphericalHarmonics8BitMode:{type:"i",value:0},sphericalHarmonicsMultiTextureMode:{type:"i",value:0},splatScale:{type:"f",value:r},pointCloudModeEnabled:{type:"i",value:i?1:0},sceneIndexesTexture:{type:"t",value:null},sceneIndexesTextureSize:{type:"v2",value:new t.Vector2(1024,1024)},sceneCount:{type:"i",value:1}};for(let t=0;t<T.MaxScenes;t++)o.sphericalHarmonics8BitCompressionRangeMin.value.push(-1.5),o.sphericalHarmonics8BitCompressionRangeMax.value.push(T.SphericalHarmonics8BitCompressionRange/2);if(n){const e=[];for(let n=0;n<T.MaxScenes;n++)e.push(1);o.sceneOpacity={type:"f",value:e};const t=[];for(let n=0;n<T.MaxScenes;n++)t.push(1);o.sceneVisibility={type:"i",value:t}}if(e){const e=[];for(let n=0;n<T.MaxScenes;n++)e.push(new t.Matrix4);o.transforms={type:"mat4",value:e}}return o}}class on{static build(e=!1,n=!1,s=!1,r=2048,i=1,o=!1,a=0,l=.3){let c=rn.buildVertexShaderBase(e,n,a,"\n            uniform vec2 covariancesTextureSize;\n            uniform highp sampler2D covariancesTexture;\n            uniform highp usampler2D covariancesTextureHalfFloat;\n            uniform int covariancesAreHalfFloat;\n\n            void fromCovarianceHalfFloatV4(uvec4 val, out vec4 first, out vec4 second) {\n                vec2 r = unpackHalf2x16(val.r);\n                vec2 g = unpackHalf2x16(val.g);\n                vec2 b = unpackHalf2x16(val.b);\n\n                first = vec4(r.x, r.y, g.x, g.y);\n                second = vec4(b.x, b.y, 0.0, 0.0);\n            }\n        ");c+=on.buildVertexShaderProjection(s,n,r,l);const h=on.buildFragmentShader(),d=rn.getUniforms(e,n,a,i,o);d.covariancesTextureSize={type:"v2",value:new t.Vector2(1024,1024)},d.covariancesTexture={type:"t",value:null},d.covariancesTextureHalfFloat={type:"t",value:null},d.covariancesAreHalfFloat={type:"i",value:0};return new t.ShaderMaterial({uniforms:d,vertexShader:c,fragmentShader:h,transparent:!0,alphaTest:1,blending:t.NormalBlending,depthTest:!0,depthWrite:!1,side:t.DoubleSide})}static buildVertexShaderProjection(e,t,n,s){let r="\n\n            vec4 sampledCovarianceA;\n            vec4 sampledCovarianceB;\n            vec3 cov3D_M11_M12_M13;\n            vec3 cov3D_M22_M23_M33;\n            if (covariancesAreHalfFloat == 0) {\n                sampledCovarianceA = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset,\n                                                                            covariancesTextureSize));\n                sampledCovarianceB = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset + uint(1),\n                                                                            covariancesTextureSize));\n\n                cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rgb) * (1.0 - fOddOffset) +\n                                    vec3(sampledCovarianceA.ba, sampledCovarianceB.r) * fOddOffset;\n                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg) * (1.0 - fOddOffset) +\n                                    vec3(sampledCovarianceB.gba) * fOddOffset;\n            } else {\n                uvec4 sampledCovarianceU = texture(covariancesTextureHalfFloat, getDataUV(1, 0, covariancesTextureSize));\n                fromCovarianceHalfFloatV4(sampledCovarianceU, sampledCovarianceA, sampledCovarianceB);\n                cov3D_M11_M12_M13 = sampledCovarianceA.rgb;\n                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg);\n            }\n        \n            // Construct the 3D covariance matrix\n            mat3 Vrk = mat3(\n                cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,\n                cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,\n                cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z\n            );\n\n            mat3 J;\n            if (orthographicMode == 1) {\n                // Since the projection is linear, we don't need an approximation\n                J = transpose(mat3(orthoZoom, 0.0, 0.0,\n                                0.0, orthoZoom, 0.0,\n                                0.0, 0.0, 0.0));\n            } else {\n                // Construct the Jacobian of the affine approximation of the projection matrix. It will be used to transform the\n                // 3D covariance matrix instead of using the actual projection matrix because that transformation would\n                // require a non-linear component (perspective division) which would yield a non-gaussian result.\n                float s = 1.0 / (viewCenter.z * viewCenter.z);\n                J = mat3(\n                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,\n                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,\n                    0., 0., 0.\n                );\n            }\n\n            // Concatenate the projection approximation with the model-view transformation\n            mat3 W = transpose(mat3(transformModelViewMatrix));\n            mat3 T = W * J;\n\n            // Transform the 3D covariance matrix (Vrk) to compute the 2D covariance matrix\n            mat3 cov2Dm = transpose(T) * Vrk * T;\n            ";return r+=e?`\n                float detOrig = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];\n                cov2Dm[0][0] += ${s};\n                cov2Dm[1][1] += ${s};\n                float detBlur = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];\n                vColor.a *= sqrt(max(detOrig / detBlur, 0.0));\n                if (vColor.a < minAlpha) return;\n            `:`\n                cov2Dm[0][0] += ${s};\n                cov2Dm[1][1] += ${s};\n            `,r+=`\n\n            // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because\n            // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],\n            // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't\n            // need cov2Dm[1][0] because it is a symetric matrix.\n            vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n\n            // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix\n            // so that we can determine the 2D basis for the splat. This is done using the method described\n            // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n            // After calculating the eigen-values and eigen-vectors, we calculate the basis for rendering the splat\n            // by normalizing the eigen-vectors and then multiplying them by (sqrt(8) * sqrt(eigen-value)), which is\n            // equal to scaling them by sqrt(8) standard deviations.\n            //\n            // This is a different approach than in the original work at INRIA. In that work they compute the\n            // max extents of the projected splat in screen space to form a screen-space aligned bounding rectangle\n            // which forms the geometry that is actually rasterized. The dimensions of that bounding box are 3.0\n            // times the square root of the maximum eigen-value, or 3 standard deviations. They then use the inverse\n            // 2D covariance matrix (called 'conic') in the CUDA rendering thread to determine fragment opacity by\n            // calculating the full gaussian: exp(-0.5 * (X - mean) * conic * (X - mean)) * splat opacity\n            float a = cov2Dv.x;\n            float d = cov2Dv.z;\n            float b = cov2Dv.y;\n            float D = a * d - b * b;\n            float trace = a + d;\n            float traceOver2 = 0.5 * trace;\n            float term2 = sqrt(max(0.1f, traceOver2 * traceOver2 - D));\n            float eigenValue1 = traceOver2 + term2;\n            float eigenValue2 = traceOver2 - term2;\n\n            if (pointCloudModeEnabled == 1) {\n                eigenValue1 = eigenValue2 = 0.2;\n            }\n\n            if (eigenValue2 <= 0.0) return;\n\n            vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\n            // since the eigen vectors are orthogonal, we derive the second one from the first\n            vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\n\n            // We use sqrt(8) standard deviations instead of 3 to eliminate more of the splat with a very low opacity.\n            vec2 basisVector1 = eigenVector1 * splatScale * min(sqrt8 * sqrt(eigenValue1), ${parseInt(n)}.0);\n            vec2 basisVector2 = eigenVector2 * splatScale * min(sqrt8 * sqrt(eigenValue2), ${parseInt(n)}.0);\n            `,t&&(r+="\n                vColor.a *= splatOpacityFromScene;\n            "),r+="\n            vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) *\n                             basisViewport * 2.0 * inverseFocalAdjustment;\n\n            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n            gl_Position = quadPos;\n\n            // Scale the position data we send to the fragment shader\n            vPosition *= sqrt8;\n        ",r+=rn.getVertexShaderFadeIn(),r+="}",r}static buildFragmentShader(){let e="\n            precision highp float;\n            #include <common>\n \n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n            varying vec2 vPosition;\n        ";return e+="\n            void main () {\n                // Compute the positional squared distance from the center of the splat to the current fragment.\n                float A = dot(vPosition, vPosition);\n                // Since the positional data in vPosition has been scaled by sqrt(8), the squared result will be\n                // scaled by a factor of 8. If the squared result is larger than 8, it means it is outside the ellipse\n                // defined by the rectangle formed by vPosition. It also means it's farther\n                // away than sqrt(8) standard deviations from the mean.\n                if (A > 8.0) discard;\n                vec3 color = vColor.rgb;\n\n                // Since the rendered splat is scaled by sqrt(8), the inverse covariance matrix that is part of\n                // the gaussian formula becomes the identity matrix. We're then left with (X - mean) * (X - mean),\n                // and since 'mean' is zero, we have X * X, which is the same as A:\n                float opacity = exp(-0.5 * A) * vColor.a;\n\n                gl_FragColor = vec4(color.rgb, opacity);\n            }\n        ","\n            precision highp float;\n            #include <common>\n \n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n            varying vec2 vPosition;\n        \n            void main () {\n                // Compute the positional squared distance from the center of the splat to the current fragment.\n                float A = dot(vPosition, vPosition);\n                // Since the positional data in vPosition has been scaled by sqrt(8), the squared result will be\n                // scaled by a factor of 8. If the squared result is larger than 8, it means it is outside the ellipse\n                // defined by the rectangle formed by vPosition. It also means it's farther\n                // away than sqrt(8) standard deviations from the mean.\n                if (A > 8.0) discard;\n                vec3 color = vColor.rgb;\n\n                // Since the rendered splat is scaled by sqrt(8), the inverse covariance matrix that is part of\n                // the gaussian formula becomes the identity matrix. We're then left with (X - mean) * (X - mean),\n                // and since 'mean' is zero, we have X * X, which is the same as A:\n                float opacity = exp(-0.5 * A) * vColor.a;\n\n                gl_FragColor = vec4(color.rgb, opacity);\n            }\n        "}}class an{static build(e=!1,n=!1,s=1,r=!1,i=0){let o=rn.buildVertexShaderBase(e,n,i,"\n            uniform vec2 scaleRotationsTextureSize;\n            uniform highp sampler2D scaleRotationsTexture;\n            varying mat3 vT;\n            varying vec2 vQuadCenter;\n            varying vec2 vFragCoord;\n        ");o+=an.buildVertexShaderProjection();const a=an.buildFragmentShader(),l=rn.getUniforms(e,n,i,s,r);l.scaleRotationsTexture={type:"t",value:null},l.scaleRotationsTextureSize={type:"v2",value:new t.Vector2(1024,1024)};return new t.ShaderMaterial({uniforms:l,vertexShader:o,fragmentShader:a,transparent:!0,alphaTest:1,blending:t.NormalBlending,depthTest:!0,depthWrite:!1,side:t.DoubleSide})}static buildVertexShaderProjection(){let e="\n\n            vec4 scaleRotationA = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,\n                                                                            oddOffset, scaleRotationsTextureSize));\n            vec4 scaleRotationB = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,\n                                                                            oddOffset + uint(1), scaleRotationsTextureSize));\n\n            vec3 scaleRotation123 = vec3(scaleRotationA.rgb) * (1.0 - fOddOffset) +\n                                    vec3(scaleRotationA.ba, scaleRotationB.r) * fOddOffset;\n            vec3 scaleRotation456 = vec3(scaleRotationA.a, scaleRotationB.rg) * (1.0 - fOddOffset) +\n                                    vec3(scaleRotationB.gba) * fOddOffset;\n\n            float missingW = sqrt(1.0 - scaleRotation456.x * scaleRotation456.x - scaleRotation456.y *\n                                    scaleRotation456.y - scaleRotation456.z * scaleRotation456.z);\n            mat3 R = quaternionToRotationMatrix(scaleRotation456.r, scaleRotation456.g, scaleRotation456.b, missingW);\n            mat3 S = mat3(scaleRotation123.r, 0.0, 0.0,\n                            0.0, scaleRotation123.g, 0.0,\n                            0.0, 0.0, scaleRotation123.b);\n            \n            mat3 L = R * S;\n\n            mat3x4 splat2World = mat3x4(vec4(L[0], 0.0),\n                                        vec4(L[1], 0.0),\n                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));\n\n            mat4 world2ndc = transpose(projectionMatrix * transformModelViewMatrix);\n\n            mat3x4 ndc2pix = mat3x4(vec4(viewport.x / 2.0, 0.0, 0.0, (viewport.x - 1.0) / 2.0),\n                                    vec4(0.0, viewport.y / 2.0, 0.0, (viewport.y - 1.0) / 2.0),\n                                    vec4(0.0, 0.0, 0.0, 1.0));\n\n            mat3 T = transpose(splat2World) * world2ndc * ndc2pix;\n            vec3 normal = vec3(viewMatrix * vec4(L[0][2], L[1][2], L[2][2], 0.0));\n        ";return e+="\n\n                mat4 splat2World4 = mat4(vec4(L[0], 0.0),\n                                        vec4(L[1], 0.0),\n                                        vec4(L[2], 0.0),\n                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));\n\n                mat4 Tt = transpose(transpose(splat2World4) * world2ndc);\n\n                vec4 tempPoint1 = Tt * vec4(1.0, 0.0, 0.0, 1.0);\n                tempPoint1 /= tempPoint1.w;\n\n                vec4 tempPoint2 = Tt * vec4(0.0, 1.0, 0.0, 1.0);\n                tempPoint2 /= tempPoint2.w;\n\n                vec4 center = Tt * vec4(0.0, 0.0, 0.0, 1.0);\n                center /= center.w;\n\n                vec2 basisVector1 = tempPoint1.xy - center.xy;\n                vec2 basisVector2 = tempPoint2.xy - center.xy;\n\n                vec2 basisVector1Screen = basisVector1 * 0.5 * viewport;\n                vec2 basisVector2Screen = basisVector2 * 0.5 * viewport;\n\n                const float minPix = 1.;\n                if (length(basisVector1Screen) < minPix || length(basisVector2Screen) < minPix) {\n                    \n            vec3 T0 = vec3(T[0][0], T[0][1], T[0][2]);\n            vec3 T1 = vec3(T[1][0], T[1][1], T[1][2]);\n            vec3 T3 = vec3(T[2][0], T[2][1], T[2][2]);\n\n            vec3 tempPoint = vec3(1.0, 1.0, -1.0);\n            float distance = (T3.x * T3.x * tempPoint.x) + (T3.y * T3.y * tempPoint.y) + (T3.z * T3.z * tempPoint.z);\n            vec3 f = (1.0 / distance) * tempPoint;\n            if (abs(distance) < 0.00001) return;\n\n            float pointImageX = (T0.x * T3.x * f.x) + (T0.y * T3.y * f.y) + (T0.z * T3.z * f.z);\n            float pointImageY = (T1.x * T3.x * f.x) + (T1.y * T3.y * f.y) + (T1.z * T3.z * f.z);\n            vec2 pointImage = vec2(pointImageX, pointImageY);\n\n            float tempX = (T0.x * T0.x * f.x) + (T0.y * T0.y * f.y) + (T0.z * T0.z * f.z);\n            float tempY = (T1.x * T1.x * f.x) + (T1.y * T1.y * f.y) + (T1.z * T1.z * f.z);\n            vec2 temp = vec2(tempX, tempY);\n\n            vec2 halfExtend = pointImage * pointImage - temp;\n            vec2 extent = sqrt(max(vec2(0.0001), halfExtend));\n            float radius = max(extent.x, extent.y);\n\n            vec2 ndcOffset = ((position.xy * radius * 3.0) * basisViewport * 2.0);\n\n            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n            gl_Position = quadPos;\n\n            vT = T;\n            vQuadCenter = pointImage;\n            vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;\n        \n                } else {\n                    vec2 ndcOffset = vec2(position.x * basisVector1 + position.y * basisVector2) * 3.0 * inverseFocalAdjustment;\n                    vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n                    gl_Position = quadPos;\n\n                    vT = T;\n                    vQuadCenter = center.xy;\n                    vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;\n                }\n            ",e+=rn.getVertexShaderFadeIn(),e+="}",e}static buildFragmentShader(){return"\n            precision highp float;\n            #include <common>\n\n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n            varying vec2 vPosition;\n            varying mat3 vT;\n            varying vec2 vQuadCenter;\n            varying vec2 vFragCoord;\n\n            void main () {\n\n                const float FilterInvSquare = 2.0;\n                const float near_n = 0.2;\n                const float T = 1.0;\n\n                vec2 xy = vQuadCenter;\n                vec3 Tu = vT[0];\n                vec3 Tv = vT[1];\n                vec3 Tw = vT[2];\n                vec3 k = vFragCoord.x * Tw - Tu;\n                vec3 l = vFragCoord.y * Tw - Tv;\n                vec3 p = cross(k, l);\n                if (p.z == 0.0) discard;\n                vec2 s = vec2(p.x / p.z, p.y / p.z);\n                float rho3d = (s.x * s.x + s.y * s.y); \n                vec2 d = vec2(xy.x - vFragCoord.x, xy.y - vFragCoord.y);\n                float rho2d = FilterInvSquare * (d.x * d.x + d.y * d.y); \n\n                // compute intersection and depth\n                float rho = min(rho3d, rho2d);\n                float depth = (rho3d <= rho2d) ? (s.x * Tw.x + s.y * Tw.y) + Tw.z : Tw.z; \n                if (depth < near_n) discard;\n                //  vec4 nor_o = collected_normal_opacity[j];\n                //  float normal[3] = {nor_o.x, nor_o.y, nor_o.z};\n                float opa = vColor.a;\n\n                float power = -0.5f * rho;\n                if (power > 0.0f) discard;\n\n                // Eq. (2) from 3D Gaussian splatting paper.\n                // Obtain alpha by multiplying with Gaussian opacity\n                // and its exponential falloff from mean.\n                // Avoid numerical instabilities (see paper appendix). \n                float alpha = min(0.99f, opa * exp(power));\n                if (alpha < 1.0f / 255.0f) discard;\n                float test_T = T * (1.0 - alpha);\n                if (test_T < 0.0001)discard;\n\n                float w = alpha * T;\n                gl_FragColor = vec4(vColor.rgb, w);\n            }\n        "}}class ln{static build(e){const n=new t.BufferGeometry;n.setIndex([0,1,2,0,2,3]);const s=new Float32Array(12),r=new t.BufferAttribute(s,3);n.setAttribute("position",r),r.setXYZ(0,-1,-1,0),r.setXYZ(1,-1,1,0),r.setXYZ(2,1,1,0),r.setXYZ(3,1,-1,0),r.needsUpdate=!0;const i=(new t.InstancedBufferGeometry).copy(n),o=new Uint32Array(e),a=new t.InstancedBufferAttribute(o,1,!1);return a.setUsage(t.DynamicDrawUsage),i.setAttribute("splatIndex",a),i.instanceCount=0,i}}class cn extends t.Object3D{constructor(e,n=new t.Vector3,s=new t.Quaternion,r=new t.Vector3(1,1,1),i=1,o=1,a=!0){super(),this.splatBuffer=e,this.position.copy(n),this.quaternion.copy(s),this.scale.copy(r),this.transform=new t.Matrix4,this.minimumAlpha=i,this.opacity=o,this.visible=a}copyTransformData(e){this.position.copy(e.position),this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.transform.copy(e.transform)}updateTransform(e){e?(this.matrixWorldAutoUpdate&&this.updateWorldMatrix(!0,!1),this.transform.copy(this.matrixWorld)):(this.matrixAutoUpdate&&this.updateMatrix(),this.transform.copy(this.matrix))}}class hn{static idGen=0;constructor(e,n,s,r){this.min=(new t.Vector3).copy(e),this.max=(new t.Vector3).copy(n),this.boundingBox=new t.Box3(this.min,this.max),this.center=(new t.Vector3).copy(this.max).sub(this.min).multiplyScalar(.5).add(this.min),this.depth=s,this.children=[],this.data=null,this.id=r||hn.idGen++}}class dn{constructor(e,n){this.maxDepth=e,this.maxCentersPerNode=n,this.sceneDimensions=new t.Vector3,this.sceneMin=new t.Vector3,this.sceneMax=new t.Vector3,this.rootNode=null,this.nodesWithIndexes=[],this.splatMesh=null}static convertWorkerSubTreeNode(e){const n=(new t.Vector3).fromArray(e.min),s=(new t.Vector3).fromArray(e.max),r=new hn(n,s,e.depth,e.id);if(e.data.indexes){r.data={indexes:[]};for(let t of e.data.indexes)r.data.indexes.push(t)}if(e.children)for(let t of e.children)r.children.push(dn.convertWorkerSubTreeNode(t));return r}static convertWorkerSubTree(e,n){const s=new dn(e.maxDepth,e.maxCentersPerNode);s.sceneMin=(new t.Vector3).fromArray(e.sceneMin),s.sceneMax=(new t.Vector3).fromArray(e.sceneMax),s.splatMesh=n,s.rootNode=dn.convertWorkerSubTreeNode(e.rootNode);const r=(e,t)=>{0===e.children.length&&t(e);for(let n of e.children)r(n,t)};return s.nodesWithIndexes=[],r(s.rootNode,e=>{e.data&&e.data.indexes&&e.data.indexes.length>0&&s.nodesWithIndexes.push(e)}),s}}function pn(e){let t=0;class n{constructor(e,t){this.min=[e[0],e[1],e[2]],this.max=[t[0],t[1],t[2]]}containsPoint(e){return e[0]>=this.min[0]&&e[0]<=this.max[0]&&e[1]>=this.min[1]&&e[1]<=this.max[1]&&e[2]>=this.min[2]&&e[2]<=this.max[2]}}class s{constructor(e,t){this.maxDepth=e,this.maxCentersPerNode=t,this.sceneDimensions=[],this.sceneMin=[],this.sceneMax=[],this.rootNode=null,this.addedIndexes={},this.nodesWithIndexes=[],this.splatMesh=null,this.disposed=!1}}class r{constructor(e,n,s,r){this.min=[e[0],e[1],e[2]],this.max=[n[0],n[1],n[2]],this.center=[.5*(n[0]-e[0])+e[0],.5*(n[1]-e[1])+e[1],.5*(n[2]-e[2])+e[2]],this.depth=s,this.children=[],this.data=null,this.id=r||t++}}processSplatTreeNode=function(e,t,s,i){const o=t.data.indexes.length;if(o<e.maxCentersPerNode||t.depth>e.maxDepth){const n=[];for(let s=0;s<t.data.indexes.length;s++)e.addedIndexes[t.data.indexes[s]]||(n.push(t.data.indexes[s]),e.addedIndexes[t.data.indexes[s]]=!0);return t.data.indexes=n,t.data.indexes.sort((e,t)=>e>t?1:-1),void e.nodesWithIndexes.push(t)}const a=[t.max[0]-t.min[0],t.max[1]-t.min[1],t.max[2]-t.min[2]],l=[.5*a[0],.5*a[1],.5*a[2]],c=[t.min[0]+l[0],t.min[1]+l[1],t.min[2]+l[2]],h=[new n([c[0]-l[0],c[1],c[2]-l[2]],[c[0],c[1]+l[1],c[2]]),new n([c[0],c[1],c[2]-l[2]],[c[0]+l[0],c[1]+l[1],c[2]]),new n([c[0],c[1],c[2]],[c[0]+l[0],c[1]+l[1],c[2]+l[2]]),new n([c[0]-l[0],c[1],c[2]],[c[0],c[1]+l[1],c[2]+l[2]]),new n([c[0]-l[0],c[1]-l[1],c[2]-l[2]],[c[0],c[1],c[2]]),new n([c[0],c[1]-l[1],c[2]-l[2]],[c[0]+l[0],c[1],c[2]]),new n([c[0],c[1]-l[1],c[2]],[c[0]+l[0],c[1],c[2]+l[2]]),new n([c[0]-l[0],c[1]-l[1],c[2]],[c[0],c[1],c[2]+l[2]])],d=[];for(let n=0;n<h.length;n++)d[n]=[];const p=[0,0,0];for(let n=0;n<o;n++){const e=t.data.indexes[n],r=s[e];p[0]=i[r],p[1]=i[r+1],p[2]=i[r+2];for(let t=0;t<h.length;t++)h[t].containsPoint(p)&&d[t].push(e)}for(let n=0;n<h.length;n++){const e=new r(h[n].min,h[n].max,t.depth+1);e.data={indexes:d[n]},t.children.push(e)}t.data={};for(let n of t.children)processSplatTreeNode(e,n,s,i)};const i=(e,t,n)=>{const i=[0,0,0],o=[0,0,0],a=[],l=Math.floor(e.length/4);for(let s=0;s<l;s++){const t=4*s,n=e[t],r=e[t+1],l=e[t+2],c=Math.round(e[t+3]);(0===s||n<i[0])&&(i[0]=n),(0===s||n>o[0])&&(o[0]=n),(0===s||r<i[1])&&(i[1]=r),(0===s||r>o[1])&&(o[1]=r),(0===s||l<i[2])&&(i[2]=l),(0===s||l>o[2])&&(o[2]=l),a.push(c)}const c=new s(t,n);return c.sceneMin=i,c.sceneMax=o,c.rootNode=new r(c.sceneMin,c.sceneMax,0),c.rootNode.data={indexes:a},c};e.onmessage=t=>{t.data.process&&function(t,n,s){const r=[];for(let e of t){const t=Math.floor(e.length/4);for(let n=0;n<t;n++){const t=4*n;r[Math.round(e[t+3])]=t}}const o=[];for(let e of t){const t=i(e,n,s);o.push(t),processSplatTreeNode(t,t.rootNode,r,e)}e.postMessage({subTrees:o})}(t.data.process.centers,t.data.process.maxDepth,t.data.process.maxCentersPerNode)}}class un{constructor(e,t){this.maxDepth=e,this.maxCentersPerNode=t,this.subTrees=[],this.splatMesh=null}dispose(){this.diposeSplatTreeWorker(),this.disposed=!0}diposeSplatTreeWorker(){this.splatTreeWorker&&this.splatTreeWorker.terminate(),this.splatTreeWorker=null}processSplatMesh=function(e,n=()=>!0,s,r){this.splatTreeWorker||(this.splatTreeWorker=new Worker(URL.createObjectURL(new Blob(["(",pn.toString(),")(self)"],{type:"application/javascript"})))),this.splatMesh=e,this.subTrees=[];const i=new t.Vector3,o=(t,s)=>{const r=new Float32Array(4*s);let o=0;for(let a=0;a<s;a++){const s=a+t;if(n(s)){e.getSplatCenter(s,i);const t=4*o;r[t]=i.x,r[t+1]=i.y,r[t+2]=i.z,r[t+3]=s,o++}}return r};return new Promise(t=>{const n=()=>!!this.disposed&&(this.diposeSplatTreeWorker(),t(),!0);s&&s(!1),y(()=>{if(n())return;const i=[];if(e.dynamicMode){let t=0;for(let n=0;n<e.scenes.length;n++){const s=e.getScene(n).splatBuffer.getSplatCount(),r=o(t,s);i.push(r),t+=s}}else{const t=o(0,e.getSplatCount());i.push(t)}this.splatTreeWorker.onmessage=s=>{n()||s.data.subTrees&&(r&&r(!1),y(()=>{if(!n()){for(let t of s.data.subTrees){const n=dn.convertWorkerSubTree(t,e);this.subTrees.push(n)}this.diposeSplatTreeWorker(),r&&r(!0),y(()=>{t()})}}))},y(()=>{if(n())return;s&&s(!0);const e=i.map(e=>e.buffer);!function(e,t,n,s,r){e.postMessage({process:{centers:t,maxDepth:s,maxCentersPerNode:r}},n)}(this.splatTreeWorker,i,e,this.maxDepth,this.maxCentersPerNode)})})})};countLeaves(){let e=0;return this.visitLeaves(()=>{e++}),e}visitLeaves(e){const t=(e,n)=>{0===e.children.length&&n(e);for(let s of e.children)t(s,n)};for(let n of this.subTrees)t(n.rootNode,e)}}function mn(e){const t={};function n(n){if(void 0!==t[n])return t[n];let s;switch(n){case"WEBGL_depth_texture":s=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=e.getExtension(n)}return t[n]=s,s}return{has:function(e){return null!==n(e)},init:function(e){e.isWebGL2?(n("EXT_color_buffer_float"),n("WEBGL_clip_cull_distance")):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture")},get:function(e){const t=n(e);return null===t&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),t}}}function An(e,t,n){let s;function r(t){if("highp"===t){if(e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const i="undefined"!=typeof WebGL2RenderingContext&&"WebGL2RenderingContext"===e.constructor.name;let o=void 0!==n.precision?n.precision:"highp";const a=r(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);const l=i||t.has("WEBGL_draw_buffers"),c=!0===n.logarithmicDepthBuffer,h=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),d=e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),p=e.getParameter(e.MAX_TEXTURE_SIZE),u=e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),m=e.getParameter(e.MAX_VERTEX_ATTRIBS),A=e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),f=e.getParameter(e.MAX_VARYING_VECTORS),g=e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),S=d>0,C=i||t.has("OES_texture_float");return{isWebGL2:i,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==s)return s;if(!0===t.has("EXT_texture_filter_anisotropic")){const n=t.get("EXT_texture_filter_anisotropic");s=e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s},getMaxPrecision:r,precision:o,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:d,maxTextureSize:p,maxCubemapSize:u,maxAttributes:m,maxVertexUniforms:A,maxVaryings:f,maxFragmentUniforms:g,vertexTextures:S,floatFragmentTextures:C,floatVertexTextures:S&&C,maxSamples:i?e.getParameter(e.MAX_SAMPLES):0}}const fn=0,gn=2,Sn=0,Cn=3,yn=new t.BufferGeometry,xn=new t.MeshBasicMaterial,vn=16777216;class In extends t.Mesh{constructor(e=tn,n=!1,s=!1,r=!1,i=1,o=!0,a=!1,l=!1,c=1024,h=Sn,d=0,p=1,u=.3){super(yn,xn),this.renderer=void 0,this.splatRenderMode=e,this.dynamicMode=n,this.enableOptionalEffects=s,this.halfPrecisionCovariancesOnGPU=r,this.devicePixelRatio=i,this.enableDistancesComputationOnGPU=o,this.integerBasedDistancesComputation=a,this.antialiased=l,this.kernel2DSize=u,this.maxScreenSpaceSplatSize=c,this.logLevel=h,this.sphericalHarmonicsDegree=d,this.minSphericalHarmonicsDegree=0,this.sceneFadeInRateMultiplier=p,this.scenes=[],this.splatTree=null,this.baseSplatTree=null,this.splatDataTextures={},this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,sceneIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,sceneIndexesLoc:-1,transformsLocs:[]},this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[],this.lastBuildSplatCount=0,this.lastBuildScenes=[],this.lastBuildMaxSplatCount=0,this.lastBuildSceneCount=0,this.firstRenderTime=-1,this.finalBuild=!1,this.webGLUtils=null,this.boundingBox=new t.Box3,this.calculatedSceneCenter=new t.Vector3,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.visibleRegionChanging=!1,this.splatScale=1,this.pointCloudModeEnabled=!1,this.disposed=!1,this.lastRenderer=null,this.visible=!1}static buildScenes(e,n,s){const r=[];r.length=n.length;for(let i=0;i<n.length;i++){const o=n[i],a=s[i]||{};let l=a.position||[0,0,0],c=a.rotation||[0,0,0,1],h=a.scale||[1,1,1];const d=(new t.Vector3).fromArray(l),p=(new t.Quaternion).fromArray(c),u=(new t.Vector3).fromArray(h),m=In.createScene(o,d,p,u,a.splatAlphaRemovalThreshold||1,a.opacity,a.visible);e.add(m),r[i]=m}return r}static createScene(e,t,n,s,r,i=1,o=!0){return new cn(e,t,n,s,r,i,o)}static buildSplatIndexMaps(e){const t=[],n=[];let s=0;for(let r=0;r<e.length;r++){const i=e[r].getMaxSplatCount();for(let e=0;e<i;e++)t[s]=e,n[s]=r,s++}return{localSplatIndexMap:t,sceneIndexMap:n}}buildSplatTree=function(e=[],n,s){return new Promise(r=>{this.disposeSplatTree(),this.baseSplatTree=new un(8,1e3);const i=performance.now(),o=new t.Vector4;this.baseSplatTree.processSplatMesh(this,t=>{this.getSplatColor(t,o);const n=this.getSceneIndexForSplat(t),s=e[n]||1;return o.w>=s},n,s).then(()=>{const e=performance.now()-i;if(this.logLevel>=Cn&&console.log("SplatTree build: "+e+" ms"),this.disposed)r();else{this.splatTree=this.baseSplatTree,this.baseSplatTree=null;let e=0,t=0,n=0;this.splatTree.visitLeaves(s=>{const r=s.data.indexes.length;r>0&&(t+=r,n++,e++)}),this.logLevel>=Cn&&(console.log(`SplatTree leaves: ${this.splatTree.countLeaves()}`),console.log(`SplatTree leaves with splats:${e}`),t/=n,console.log(`Avg splat count per node: ${t}`),console.log(`Total splat count: ${this.getSplatCount()}`)),r()}})})};build(e,n,s=!0,r=!1,i,o,a=!0){this.sceneOptions=n,this.finalBuild=r;const l=In.getTotalMaxSplatCountForSplatBuffers(e),c=In.buildScenes(this,e,n);if(s)for(let t=0;t<this.scenes.length&&t<c.length;t++){const e=c[t],n=this.getScene(t);e.copyTransformData(n)}this.scenes=c;let h=3;for(let t of e){const e=t.getMinSphericalHarmonicsDegree();e<h&&(h=e)}this.minSphericalHarmonicsDegree=Math.min(h,this.sphericalHarmonicsDegree);let d=!1;if(e.length!==this.lastBuildScenes.length)d=!0;else for(let t=0;t<e.length;t++){if(e[t]!==this.lastBuildScenes[t].splatBuffer){d=!0;break}}let p=!0;if((1!==this.scenes.length||this.lastBuildSceneCount!==this.scenes.length||this.lastBuildMaxSplatCount!==l||d)&&(p=!1),!p){this.boundingBox=new t.Box3,a||(this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.firstRenderTime=-1),this.lastBuildScenes=[],this.lastBuildSplatCount=0,this.lastBuildMaxSplatCount=0,this.disposeMeshData(),this.geometry=ln.build(l),this.splatRenderMode===tn?this.material=on.build(this.dynamicMode,this.enableOptionalEffects,this.antialiased,this.maxScreenSpaceSplatSize,this.splatScale,this.pointCloudModeEnabled,this.minSphericalHarmonicsDegree,this.kernel2DSize):this.material=an.build(this.dynamicMode,this.enableOptionalEffects,this.splatScale,this.pointCloudModeEnabled,this.minSphericalHarmonicsDegree);const n=In.buildSplatIndexMaps(e);this.globalSplatIndexToLocalSplatIndexMap=n.localSplatIndexMap,this.globalSplatIndexToSceneIndexMap=n.sceneIndexMap}const u=this.getSplatCount(!0);this.enableDistancesComputationOnGPU&&this.setupDistancesComputationTransformFeedback();const m=this.refreshGPUDataFromSplatBuffers(p);for(let t=0;t<this.scenes.length;t++)this.lastBuildScenes[t]=this.scenes[t];return this.lastBuildSplatCount=u,this.lastBuildMaxSplatCount=this.getMaxSplatCount(),this.lastBuildSceneCount=this.scenes.length,r&&this.scenes.length>0&&this.buildSplatTree(n.map(e=>e.splatAlphaRemovalThreshold||1),i,o).then(()=>{this.onSplatTreeReadyCallback&&this.onSplatTreeReadyCallback(this.splatTree),this.onSplatTreeReadyCallback=null}),this.visible=this.scenes.length>0,m}freeIntermediateSplatData(){const e=e=>{delete e.source.data,delete e.image,e.onUpdate=null};delete this.splatDataTextures.baseData.covariances,delete this.splatDataTextures.baseData.centers,delete this.splatDataTextures.baseData.colors,delete this.splatDataTextures.baseData.sphericalHarmonics,delete this.splatDataTextures.centerColors.data,delete this.splatDataTextures.covariances.data,this.splatDataTextures.sphericalHarmonics&&delete this.splatDataTextures.sphericalHarmonics.data,this.splatDataTextures.sceneIndexes&&delete this.splatDataTextures.sceneIndexes.data,this.splatDataTextures.centerColors.texture.needsUpdate=!0,this.splatDataTextures.centerColors.texture.onUpdate=()=>{e(this.splatDataTextures.centerColors.texture)},this.splatDataTextures.covariances.texture.needsUpdate=!0,this.splatDataTextures.covariances.texture.onUpdate=()=>{e(this.splatDataTextures.covariances.texture)},this.splatDataTextures.sphericalHarmonics&&(this.splatDataTextures.sphericalHarmonics.texture?(this.splatDataTextures.sphericalHarmonics.texture.needsUpdate=!0,this.splatDataTextures.sphericalHarmonics.texture.onUpdate=()=>{e(this.splatDataTextures.sphericalHarmonics.texture)}):this.splatDataTextures.sphericalHarmonics.textures.forEach(t=>{t.needsUpdate=!0,t.onUpdate=()=>{e(t)}})),this.splatDataTextures.sceneIndexes&&(this.splatDataTextures.sceneIndexes.texture.needsUpdate=!0,this.splatDataTextures.sceneIndexes.texture.onUpdate=()=>{e(this.splatDataTextures.sceneIndexes.texture)})}dispose(){this.disposeMeshData(),this.disposeTextures(),this.disposeSplatTree(),this.enableDistancesComputationOnGPU&&(this.computeDistancesOnGPUSyncTimeout&&(clearTimeout(this.computeDistancesOnGPUSyncTimeout),this.computeDistancesOnGPUSyncTimeout=null),this.disposeDistancesComputationGPUResources()),this.scenes=[],this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,sceneIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,sceneIndexesLoc:-1,transformsLocs:[]},this.renderer=null,this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[],this.lastBuildSplatCount=0,this.lastBuildScenes=[],this.lastBuildMaxSplatCount=0,this.lastBuildSceneCount=0,this.firstRenderTime=-1,this.finalBuild=!1,this.webGLUtils=null,this.boundingBox=new t.Box3,this.calculatedSceneCenter=new t.Vector3,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.visibleRegionChanging=!1,this.splatScale=1,this.pointCloudModeEnabled=!1,this.disposed=!0,this.lastRenderer=null,this.visible=!1}disposeMeshData(){this.geometry&&this.geometry!==yn&&(this.geometry.dispose(),this.geometry=null),this.material&&(this.material.dispose(),this.material=null)}disposeTextures(){for(let e in this.splatDataTextures)if(this.splatDataTextures.hasOwnProperty(e)){const t=this.splatDataTextures[e];t.texture&&(t.texture.dispose(),t.texture=null)}this.splatDataTextures=null}disposeSplatTree(){this.splatTree&&(this.splatTree.dispose(),this.splatTree=null),this.baseSplatTree&&(this.baseSplatTree.dispose(),this.baseSplatTree=null)}getSplatTree(){return this.splatTree}onSplatTreeReady(e){this.onSplatTreeReadyCallback=e}getDataForDistancesComputation(e,t){return{centers:this.integerBasedDistancesComputation?this.getIntegerCenters(e,t,!0):this.getFloatCenters(e,t,!0),sceneIndexes:this.getSceneIndexes(e,t)}}refreshGPUDataFromSplatBuffers(e){const t=this.getSplatCount(!0);this.refreshDataTexturesFromSplatBuffers(e);const n=e?this.lastBuildSplatCount:0,{centers:s,sceneIndexes:r}=this.getDataForDistancesComputation(n,t-1);return this.enableDistancesComputationOnGPU&&this.refreshGPUBuffersForDistancesComputation(s,r,e),{from:n,to:t-1,count:t-n,centers:s,sceneIndexes:r}}refreshGPUBuffersForDistancesComputation(e,t,n=!1){const s=n?this.lastBuildSplatCount:0;this.updateGPUCentersBufferForDistancesComputation(n,e,s),this.updateGPUTransformIndexesBufferForDistancesComputation(n,t,s)}refreshDataTexturesFromSplatBuffers(e){const t=this.getSplatCount(!0),n=this.lastBuildSplatCount,s=t-1;e?this.updateBaseDataFromSplatBuffers(n,s):(this.setupDataTextures(),this.updateBaseDataFromSplatBuffers()),this.updateDataTexturesFromBaseData(n,s),this.updateVisibleRegion(e)}setupDataTextures(){const e=this.getMaxSplatCount(),n=this.getSplatCount(!0);this.disposeTextures();const s=(n,s)=>{const r=new t.Vector2(4096,1024);for(;r.x*r.y*n<e*s;)r.y*=2;return r},r=e=>{const t=(e=>e>=1?6:4)(e);return{elementsPerTexelStored:t,texSize:s(t,6)}};let i=this.getTargetCovarianceCompressionLevel();const o=this.getTargetSphericalHarmonicsCompressionLevel();let a,l,c;if(this.splatRenderMode===tn){const t=r(i);t.texSize.x*t.texSize.y>vn&&0===i&&(i=1),a=new Float32Array(6*e)}else l=new Float32Array(3*e),c=new Float32Array(4*e);const h=new Float32Array(3*e),d=new Uint8Array(4*e);let p=Float32Array;1===o?p=Uint16Array:2===o&&(p=Uint8Array);const u=x(this.minSphericalHarmonicsDegree),m=this.minSphericalHarmonicsDegree?new p(e*u):void 0,A=s(4,4),f=new Uint32Array(A.x*A.y*4);In.updateCenterColorsPaddedData(0,n-1,h,d,f);const g=new t.DataTexture(f,A.x,A.y,t.RGBAIntegerFormat,t.UnsignedIntType);if(g.internalFormat="RGBA32UI",g.needsUpdate=!0,this.material.uniforms.centersColorsTexture.value=g,this.material.uniforms.centersColorsTextureSize.value.copy(A),this.material.uniformsNeedUpdate=!0,this.splatDataTextures={baseData:{covariances:a,scales:l,rotations:c,centers:h,colors:d,sphericalHarmonics:m},centerColors:{data:f,texture:g,size:A}},this.splatRenderMode===tn){const e=r(i),n=e.elementsPerTexelStored,s=e.texSize;const o=i>=1?8:4,l=new(i>=1?Uint32Array:Float32Array)(s.x*s.y*o);let c;if(0===i?l.set(a):In.updatePaddedCompressedCovariancesTextureData(a,l,0,0,a.length),i>=1)c=new t.DataTexture(l,s.x,s.y,t.RGBAIntegerFormat,t.UnsignedIntType),c.internalFormat="RGBA32UI",this.material.uniforms.covariancesTextureHalfFloat.value=c;else{c=new t.DataTexture(l,s.x,s.y,t.RGBAFormat,t.FloatType),this.material.uniforms.covariancesTexture.value=c;const e=new t.DataTexture(new Uint32Array(32),2,2,t.RGBAIntegerFormat,t.UnsignedIntType);e.internalFormat="RGBA32UI",this.material.uniforms.covariancesTextureHalfFloat.value=e,e.needsUpdate=!0}c.needsUpdate=!0,this.material.uniforms.covariancesAreHalfFloat.value=i>=1?1:0,this.material.uniforms.covariancesTextureSize.value.copy(s),this.splatDataTextures.covariances={data:l,texture:c,size:s,compressionLevel:i,elementsPerTexelStored:n,elementsPerTexelAllocated:o}}else{const e=s(4,6);let r=Float32Array,i=t.FloatType;const o=new r(e.x*e.y*4);In.updateScaleRotationsPaddedData(0,n-1,l,c,o);const a=new t.DataTexture(o,e.x,e.y,t.RGBAFormat,i);a.needsUpdate=!0,this.material.uniforms.scaleRotationsTexture.value=a,this.material.uniforms.scaleRotationsTextureSize.value.copy(e),this.splatDataTextures.scaleRotations={data:o,texture:a,size:e,compressionLevel:0}}if(m){const e=2===o?t.UnsignedByteType:t.HalfFloatType;let r=u;r%2!=0&&r++;const i=4,a=t.RGBAFormat;let l=s(i,r);if(l.x*l.y<=vn){const s=new p(l.x*l.y*i);for(let e=0;e<n;e++){const t=u*e,n=r*e;for(let e=0;e<u;e++)s[n+e]=m[t+e]}const c=new t.DataTexture(s,l.x,l.y,a,e);c.needsUpdate=!0,this.material.uniforms.sphericalHarmonicsTexture.value=c,this.splatDataTextures.sphericalHarmonics={componentCount:u,paddedComponentCount:r,data:s,textureCount:1,texture:c,size:l,compressionLevel:o,elementsPerTexel:i}}else{const c=u/3;r=c,r%2!=0&&r++,l=s(i,r);const h=l.x*l.y*i,d=[this.material.uniforms.sphericalHarmonicsTextureR,this.material.uniforms.sphericalHarmonicsTextureG,this.material.uniforms.sphericalHarmonicsTextureB],A=[],f=[];for(let s=0;s<3;s++){const i=new p(h);A.push(i);for(let e=0;e<n;e++){const t=u*e,n=r*e;if(c>=3){for(let e=0;e<3;e++)i[n+e]=m[t+3*s+e];if(c>=8)for(let e=0;e<5;e++)i[n+3+e]=m[t+9+5*s+e]}}const o=new t.DataTexture(i,l.x,l.y,a,e);f.push(o),o.needsUpdate=!0,d[s].value=o}this.material.uniforms.sphericalHarmonicsMultiTextureMode.value=1,this.splatDataTextures.sphericalHarmonics={componentCount:u,componentCountPerChannel:c,paddedComponentCount:r,data:A,textureCount:3,textures:f,size:l,compressionLevel:o,elementsPerTexel:i}}this.material.uniforms.sphericalHarmonicsTextureSize.value.copy(l),this.material.uniforms.sphericalHarmonics8BitMode.value=2===o?1:0;for(let t=0;t<this.scenes.length;t++){const e=this.scenes[t].splatBuffer;this.material.uniforms.sphericalHarmonics8BitCompressionRangeMin.value[t]=e.minSphericalHarmonicsCoeff,this.material.uniforms.sphericalHarmonics8BitCompressionRangeMax.value[t]=e.maxSphericalHarmonicsCoeff}this.material.uniformsNeedUpdate=!0}const S=s(1,4),C=new Uint32Array(S.x*S.y*1);for(let t=0;t<n;t++)C[t]=this.globalSplatIndexToSceneIndexMap[t];const y=new t.DataTexture(C,S.x,S.y,t.RedIntegerFormat,t.UnsignedIntType);y.internalFormat="R32UI",y.needsUpdate=!0,this.material.uniforms.sceneIndexesTexture.value=y,this.material.uniforms.sceneIndexesTextureSize.value.copy(S),this.material.uniformsNeedUpdate=!0,this.splatDataTextures.sceneIndexes={data:C,texture:y,size:S},this.material.uniforms.sceneCount.value=this.scenes.length}updateBaseDataFromSplatBuffers(e,t){const n=this.splatDataTextures.covariances,s=n?n.compressionLevel:void 0,r=this.splatDataTextures.scaleRotations,i=r?r.compressionLevel:void 0,o=this.splatDataTextures.sphericalHarmonics,a=o?o.compressionLevel:0;this.fillSplatDataArrays(this.splatDataTextures.baseData.covariances,this.splatDataTextures.baseData.scales,this.splatDataTextures.baseData.rotations,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,this.splatDataTextures.baseData.sphericalHarmonics,void 0,s,i,a,e,t,e)}updateDataTexturesFromBaseData(e,t){const n=this.splatDataTextures.covariances,s=n?n.compressionLevel:void 0,r=this.splatDataTextures.scaleRotations,i=r?r.compressionLevel:void 0,o=this.splatDataTextures.sphericalHarmonics,a=o?o.compressionLevel:0,l=this.splatDataTextures.centerColors,c=l.data,h=l.texture;In.updateCenterColorsPaddedData(e,t,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,c);const d=this.renderer?this.renderer.properties.get(h):null;if(d&&d.__webglTexture?this.updateDataTexture(c,l.texture,l.size,d,4,4,4,e,t):h.needsUpdate=!0,n){const r=n.texture,i=6*e,o=6*t;if(0===s)for(let e=i;e<=o;e++){const t=this.splatDataTextures.baseData.covariances[e];n.data[e]=t}else In.updatePaddedCompressedCovariancesTextureData(this.splatDataTextures.baseData.covariances,n.data,e*n.elementsPerTexelAllocated,i,o);const a=this.renderer?this.renderer.properties.get(r):null;a&&a.__webglTexture?0===s?this.updateDataTexture(n.data,n.texture,n.size,a,n.elementsPerTexelStored,6,4,e,t):this.updateDataTexture(n.data,n.texture,n.size,a,n.elementsPerTexelAllocated,n.elementsPerTexelAllocated,2,e,t):r.needsUpdate=!0}if(r){const n=r.data,s=r.texture,o=6,a=0===i?4:2;In.updateScaleRotationsPaddedData(e,t,this.splatDataTextures.baseData.scales,this.splatDataTextures.baseData.rotations,n);const l=this.renderer?this.renderer.properties.get(s):null;l&&l.__webglTexture?this.updateDataTexture(n,r.texture,r.size,l,4,o,a,e,t):s.needsUpdate=!0}const p=this.splatDataTextures.baseData.sphericalHarmonics;if(p){let n=4;1===a?n=2:2===a&&(n=1);const s=(s,r,i,o,a)=>{const l=this.renderer?this.renderer.properties.get(s):null;l&&l.__webglTexture?this.updateDataTexture(o,s,r,l,i,a,n,e,t):s.needsUpdate=!0},r=o.componentCount,i=o.paddedComponentCount;if(1===o.textureCount){const n=o.data;for(let s=e;s<=t;s++){const e=r*s,t=i*s;for(let s=0;s<r;s++)n[t+s]=p[e+s]}s(o.texture,o.size,o.elementsPerTexel,n,i)}else{const n=o.componentCountPerChannel;for(let a=0;a<3;a++){const l=o.data[a];for(let s=e;s<=t;s++){const e=r*s,t=i*s;if(n>=3){for(let n=0;n<3;n++)l[t+n]=p[e+3*a+n];if(n>=8)for(let n=0;n<5;n++)l[t+3+n]=p[e+9+5*a+n]}}s(o.textures[a],o.size,o.elementsPerTexel,l,i)}}}const u=this.splatDataTextures.sceneIndexes,m=u.data;for(let g=this.lastBuildSplatCount;g<=t;g++)m[g]=this.globalSplatIndexToSceneIndexMap[g];const A=u.texture,f=this.renderer?this.renderer.properties.get(A):null;f&&f.__webglTexture?this.updateDataTexture(m,u.texture,u.size,f,1,1,1,this.lastBuildSplatCount,t):A.needsUpdate=!0}getTargetCovarianceCompressionLevel(){return this.halfPrecisionCovariancesOnGPU?1:0}getTargetSphericalHarmonicsCompressionLevel(){return Math.max(1,this.getMaximumSplatBufferCompressionLevel())}getMaximumSplatBufferCompressionLevel(){let e;for(let t=0;t<this.scenes.length;t++){const n=this.getScene(t).splatBuffer;(0===t||n.compressionLevel>e)&&(e=n.compressionLevel)}return e}getMinimumSplatBufferCompressionLevel(){let e;for(let t=0;t<this.scenes.length;t++){const n=this.getScene(t).splatBuffer;(0===t||n.compressionLevel<e)&&(e=n.compressionLevel)}return e}static computeTextureUpdateRegion(e,t,n,s,r){const i=r/s,o=e*i,a=Math.floor(o/n),l=a*n*s,c=t*i,h=Math.floor(c/n);return{dataStart:l,dataEnd:h*n*s+n*s,startRow:a,endRow:h}}updateDataTexture(e,t,n,s,r,i,o,a,l){const c=this.renderer.getContext(),h=In.computeTextureUpdateRegion(a,l,n.x,r,i),d=h.dataEnd-h.dataStart,p=new e.constructor(e.buffer,h.dataStart*o,d),u=h.endRow-h.startRow+1,m=this.webGLUtils.convert(t.type),A=this.webGLUtils.convert(t.format,t.colorSpace),f=c.getParameter(c.TEXTURE_BINDING_2D);c.bindTexture(c.TEXTURE_2D,s.__webglTexture),c.texSubImage2D(c.TEXTURE_2D,0,0,h.startRow,n.x,u,A,m,p),c.bindTexture(c.TEXTURE_2D,f)}static updatePaddedCompressedCovariancesTextureData(e,t,n,s,r){let i=new DataView(t.buffer),o=n,a=0;for(let l=s;l<=r;l+=2)i.setUint16(2*o,e[l],!0),i.setUint16(2*o+2,e[l+1],!0),o+=2,a++,a>=3&&(o+=2,a=0)}static updateCenterColorsPaddedData(e,t,n,s,r){for(let i=e;i<=t;i++){const e=4*i,t=3*i,o=4*i;r[o]=A(s,e),r[o+1]=m(n[t]),r[o+2]=m(n[t+1]),r[o+3]=m(n[t+2])}}static updateScaleRotationsPaddedData(e,t,n,s,r){for(let i=e;i<=t;i++){const e=3*i,t=4*i,o=6*i;r[o]=n[e],r[o+1]=n[e+1],r[o+2]=n[e+2],r[o+3]=s[t],r[o+4]=s[t+1],r[o+5]=s[t+2]}}updateVisibleRegion(e){const n=this.getSplatCount(!0),s=new t.Vector3;if(!e){const e=new t.Vector3;this.scenes.forEach(t=>{e.add(t.splatBuffer.sceneCenter)}),e.multiplyScalar(1/this.scenes.length),this.calculatedSceneCenter.copy(e),this.material.uniforms.sceneCenter.value.copy(this.calculatedSceneCenter),this.material.uniformsNeedUpdate=!0}for(let t=e?this.lastBuildSplatCount:0;t<n;t++){this.getSplatCenter(t,s,!0);const e=s.sub(this.calculatedSceneCenter).length();e>this.maxSplatDistanceFromSceneCenter&&(this.maxSplatDistanceFromSceneCenter=e)}this.maxSplatDistanceFromSceneCenter-this.visibleRegionBufferRadius>1&&(this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter,this.visibleRegionRadius=Math.max(this.visibleRegionBufferRadius-1,0)),this.finalBuild&&(this.visibleRegionRadius=this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter),this.updateVisibleRegionFadeDistance()}updateVisibleRegionFadeDistance(e=fn){const t=.012*this.sceneFadeInRateMultiplier,n=.003*this.sceneFadeInRateMultiplier,s=this.finalBuild?t:n,r=e===fn?s:n;this.visibleRegionFadeStartRadius=(this.visibleRegionRadius-this.visibleRegionFadeStartRadius)*r+this.visibleRegionFadeStartRadius;const i=(this.visibleRegionBufferRadius>0?this.visibleRegionFadeStartRadius/this.visibleRegionBufferRadius:0)>.99,o=i||e===gn?1:0;this.material.uniforms.visibleRegionFadeStartRadius.value=this.visibleRegionFadeStartRadius,this.material.uniforms.visibleRegionRadius.value=this.visibleRegionRadius,this.material.uniforms.firstRenderTime.value=this.firstRenderTime,this.material.uniforms.currentTime.value=performance.now(),this.material.uniforms.fadeInComplete.value=o,this.material.uniformsNeedUpdate=!0,this.visibleRegionChanging=!i}updateRenderIndexes(e,t){const n=this.geometry;n.attributes.splatIndex.set(e),n.attributes.splatIndex.needsUpdate=!0,t>0&&-1===this.firstRenderTime&&(this.firstRenderTime=performance.now()),n.instanceCount=t,n.setDrawRange(0,t)}updateTransforms(){for(let e=0;e<this.scenes.length;e++){this.getScene(e).updateTransform(this.dynamicMode)}}updateUniforms=function(){const e=new t.Vector2;return function(t,n,s,r,i,o){if(this.getSplatCount()>0){if(e.set(t.x*this.devicePixelRatio,t.y*this.devicePixelRatio),this.material.uniforms.viewport.value.copy(e),this.material.uniforms.basisViewport.value.set(1/e.x,1/e.y),this.material.uniforms.focal.value.set(n,s),this.material.uniforms.orthographicMode.value=r?1:0,this.material.uniforms.orthoZoom.value=i,this.material.uniforms.inverseFocalAdjustment.value=o,this.dynamicMode)for(let e=0;e<this.scenes.length;e++)this.material.uniforms.transforms.value[e].copy(this.getScene(e).transform);if(this.enableOptionalEffects)for(let e=0;e<this.scenes.length;e++)this.material.uniforms.sceneOpacity.value[e]=g(this.getScene(e).opacity,0,1),this.material.uniforms.sceneVisibility.value[e]=this.getScene(e).visible?1:0,this.material.uniformsNeedUpdate=!0;this.material.uniformsNeedUpdate=!0}}}();setSplatScale(e=1){this.splatScale=e,this.material.uniforms.splatScale.value=e,this.material.uniformsNeedUpdate=!0}getSplatScale(){return this.splatScale}setPointCloudModeEnabled(e){this.pointCloudModeEnabled=e,this.material.uniforms.pointCloudModeEnabled.value=e?1:0,this.material.uniformsNeedUpdate=!0}getPointCloudModeEnabled(){return this.pointCloudModeEnabled}getSplatDataTextures(){return this.splatDataTextures}getSplatCount(e=!1){return e?In.getTotalSplatCountForScenes(this.scenes):this.lastBuildSplatCount}static getTotalSplatCountForScenes(e){let t=0;for(let n of e)n&&n.splatBuffer&&(t+=n.splatBuffer.getSplatCount());return t}static getTotalSplatCountForSplatBuffers(e){let t=0;for(let n of e)t+=n.getSplatCount();return t}getMaxSplatCount(){return In.getTotalMaxSplatCountForScenes(this.scenes)}static getTotalMaxSplatCountForScenes(e){let t=0;for(let n of e)n&&n.splatBuffer&&(t+=n.splatBuffer.getMaxSplatCount());return t}static getTotalMaxSplatCountForSplatBuffers(e){let t=0;for(let n of e)t+=n.getMaxSplatCount();return t}disposeDistancesComputationGPUResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.vao&&(e.deleteVertexArray(this.distancesTransformFeedback.vao),this.distancesTransformFeedback.vao=null),this.distancesTransformFeedback.program&&(e.deleteProgram(this.distancesTransformFeedback.program),e.deleteShader(this.distancesTransformFeedback.vertexShader),e.deleteShader(this.distancesTransformFeedback.fragmentShader),this.distancesTransformFeedback.program=null,this.distancesTransformFeedback.vertexShader=null,this.distancesTransformFeedback.fragmentShader=null),this.disposeDistancesComputationGPUBufferResources(),this.distancesTransformFeedback.id&&(e.deleteTransformFeedback(this.distancesTransformFeedback.id),this.distancesTransformFeedback.id=null)}disposeDistancesComputationGPUBufferResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.centersBuffer&&(this.distancesTransformFeedback.centersBuffer=null,e.deleteBuffer(this.distancesTransformFeedback.centersBuffer)),this.distancesTransformFeedback.outDistancesBuffer&&(e.deleteBuffer(this.distancesTransformFeedback.outDistancesBuffer),this.distancesTransformFeedback.outDistancesBuffer=null)}setRenderer(e){if(e!==this.renderer){this.renderer=e;const n=this.renderer.getContext(),s=new mn(n),r=new An(n,s,{});if(s.init(r),this.webGLUtils=new t.WebGLUtils(n,s,r),this.enableDistancesComputationOnGPU&&this.getSplatCount()>0){this.setupDistancesComputationTransformFeedback();const{centers:e,sceneIndexes:t}=this.getDataForDistancesComputation(0,this.getSplatCount()-1);this.refreshGPUBuffersForDistancesComputation(e,t)}}}setupDistancesComputationTransformFeedback=function(){let e;return function(){const t=this.getMaxSplatCount();if(!this.renderer)return;const n=this.lastRenderer!==this.renderer,s=e!==t;if(!n&&!s)return;n?this.disposeDistancesComputationGPUResources():s&&this.disposeDistancesComputationGPUBufferResources();const r=this.renderer.getContext(),i=(e,t,n)=>{const s=e.createShader(t);if(!s)return console.error("Fatal error: gl could not create a shader object."),null;e.shaderSource(s,n),e.compileShader(s);if(!e.getShaderParameter(s,e.COMPILE_STATUS)){let n="unknown";t===e.VERTEX_SHADER?n="vertex shader":t===e.FRAGMENT_SHADER&&(n="fragement shader");const r=e.getShaderInfoLog(s);return console.error("Failed to compile "+n+" with these errors:"+r),e.deleteShader(s),null}return s};let o;this.integerBasedDistancesComputation?(o="#version 300 es\n                in ivec4 center;\n                flat out int distance;",this.dynamicMode?o+=`\n                        in uint sceneIndex;\n                        uniform ivec4 transforms[${T.MaxScenes}];\n                        void main(void) {\n                            ivec4 transform = transforms[sceneIndex];\n                            distance = center.x * transform.x + center.y * transform.y + center.z * transform.z + transform.w * center.w;\n                        }\n                    `:o+="\n                        uniform ivec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    "):(o="#version 300 es\n                in vec4 center;\n                flat out float distance;",this.dynamicMode?o+=`\n                        in uint sceneIndex;\n                        uniform mat4 transforms[${T.MaxScenes}];\n                        void main(void) {\n                            vec4 transformedCenter = transforms[sceneIndex] * vec4(center.xyz, 1.0);\n                            distance = transformedCenter.z;\n                        }\n                    `:o+="\n                        uniform vec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    ");const a=r.getParameter(r.VERTEX_ARRAY_BINDING),l=r.getParameter(r.CURRENT_PROGRAM),c=!!l&&r.getProgramParameter(l,r.DELETE_STATUS);if(n&&(this.distancesTransformFeedback.vao=r.createVertexArray()),r.bindVertexArray(this.distancesTransformFeedback.vao),n){const e=r.createProgram(),t=i(r,r.VERTEX_SHADER,o),n=i(r,r.FRAGMENT_SHADER,"#version 300 es\n                precision lowp float;\n                out vec4 fragColor;\n                void main(){}\n            ");if(!t||!n)throw new Error("Could not compile shaders for distances computation on GPU.");r.attachShader(e,t),r.attachShader(e,n),r.transformFeedbackVaryings(e,["distance"],r.SEPARATE_ATTRIBS),r.linkProgram(e);if(!r.getProgramParameter(e,r.LINK_STATUS)){const s=r.getProgramInfoLog(e);throw console.error("Fatal error: Failed to link program: "+s),r.deleteProgram(e),r.deleteShader(n),r.deleteShader(t),new Error("Could not link shaders for distances computation on GPU.")}this.distancesTransformFeedback.program=e,this.distancesTransformFeedback.vertexShader=t,this.distancesTransformFeedback.vertexShader=n}if(r.useProgram(this.distancesTransformFeedback.program),this.distancesTransformFeedback.centersLoc=r.getAttribLocation(this.distancesTransformFeedback.program,"center"),this.dynamicMode){this.distancesTransformFeedback.sceneIndexesLoc=r.getAttribLocation(this.distancesTransformFeedback.program,"sceneIndex");for(let e=0;e<this.scenes.length;e++)this.distancesTransformFeedback.transformsLocs[e]=r.getUniformLocation(this.distancesTransformFeedback.program,`transforms[${e}]`)}else this.distancesTransformFeedback.modelViewProjLoc=r.getUniformLocation(this.distancesTransformFeedback.program,"modelViewProj");(n||s)&&(this.distancesTransformFeedback.centersBuffer=r.createBuffer(),r.bindBuffer(r.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),r.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?r.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,r.INT,0,0):r.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,4,r.FLOAT,!1,0,0),this.dynamicMode&&(this.distancesTransformFeedback.sceneIndexesBuffer=r.createBuffer(),r.bindBuffer(r.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),r.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),r.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc,1,r.UNSIGNED_INT,0,0))),(n||s)&&(this.distancesTransformFeedback.outDistancesBuffer=r.createBuffer()),r.bindBuffer(r.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),r.bufferData(r.ARRAY_BUFFER,4*t,r.STATIC_READ),n&&(this.distancesTransformFeedback.id=r.createTransformFeedback()),r.bindTransformFeedback(r.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),l&&!0!==c&&r.useProgram(l),a&&r.bindVertexArray(a),this.lastRenderer=this.renderer,e=t}}();updateGPUCentersBufferForDistancesComputation(e,t,n){if(!this.renderer)return;const s=this.renderer.getContext(),r=s.getParameter(s.VERTEX_ARRAY_BINDING);s.bindVertexArray(this.distancesTransformFeedback.vao);const i=this.integerBasedDistancesComputation?Uint32Array:Float32Array,o=16*n;if(s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),e)s.bufferSubData(s.ARRAY_BUFFER,o,t);else{const e=new i(16*this.getMaxSplatCount());e.set(t),s.bufferData(s.ARRAY_BUFFER,e,s.STATIC_DRAW)}s.bindBuffer(s.ARRAY_BUFFER,null),r&&s.bindVertexArray(r)}updateGPUTransformIndexesBufferForDistancesComputation(e,t,n){if(!this.renderer||!this.dynamicMode)return;const s=this.renderer.getContext(),r=s.getParameter(s.VERTEX_ARRAY_BINDING);s.bindVertexArray(this.distancesTransformFeedback.vao);const i=4*n;if(s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),e)s.bufferSubData(s.ARRAY_BUFFER,i,t);else{const e=new Uint32Array(4*this.getMaxSplatCount());e.set(t),s.bufferData(s.ARRAY_BUFFER,e,s.STATIC_DRAW)}s.bindBuffer(s.ARRAY_BUFFER,null),r&&s.bindVertexArray(r)}getSceneIndexes(e,t){let n;n=new Uint32Array(t-e+1);for(let s=e;s<=t;s++)n[s]=this.globalSplatIndexToSceneIndexMap[s];return n}fillTransformsArray=function(){const e=[];return function(t){e.length!==t.length&&(e.length=t.length);for(let n=0;n<this.scenes.length;n++){const t=this.getScene(n).transform.elements;for(let s=0;s<16;s++)e[16*n+s]=t[s]}t.set(e)}}();computeDistancesOnGPU=function(){const e=new t.Matrix4;return function(t,n){if(!this.renderer)return;const s=this.renderer.getContext(),r=s.getParameter(s.VERTEX_ARRAY_BINDING),i=s.getParameter(s.CURRENT_PROGRAM),o=!!i&&s.getProgramParameter(i,s.DELETE_STATUS);if(s.bindVertexArray(this.distancesTransformFeedback.vao),s.useProgram(this.distancesTransformFeedback.program),s.enable(s.RASTERIZER_DISCARD),this.dynamicMode)for(let c=0;c<this.scenes.length;c++)if(e.copy(this.getScene(c).transform),e.premultiply(t),this.integerBasedDistancesComputation){const t=In.getIntegerMatrixArray(e),n=[t[2],t[6],t[10],t[14]];s.uniform4i(this.distancesTransformFeedback.transformsLocs[c],n[0],n[1],n[2],n[3])}else s.uniformMatrix4fv(this.distancesTransformFeedback.transformsLocs[c],!1,e.elements);else if(this.integerBasedDistancesComputation){const e=In.getIntegerMatrixArray(t),n=[e[2],e[6],e[10]];s.uniform3i(this.distancesTransformFeedback.modelViewProjLoc,n[0],n[1],n[2])}else{const e=[t.elements[2],t.elements[6],t.elements[10]];s.uniform3f(this.distancesTransformFeedback.modelViewProjLoc,e[0],e[1],e[2])}s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),s.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?s.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,s.INT,0,0):s.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,4,s.FLOAT,!1,0,0),this.dynamicMode&&(s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),s.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),s.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc,1,s.UNSIGNED_INT,0,0)),s.bindTransformFeedback(s.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),s.beginTransformFeedback(s.POINTS),s.drawArrays(s.POINTS,0,this.getSplatCount()),s.endTransformFeedback(),s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER,0,null),s.bindTransformFeedback(s.TRANSFORM_FEEDBACK,null),s.disable(s.RASTERIZER_DISCARD);const a=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);s.flush();const l=new Promise(e=>{const t=()=>{if(this.disposed)e();else{const r=0,i=0;switch(s.clientWaitSync(a,i,r)){case s.TIMEOUT_EXPIRED:return this.computeDistancesOnGPUSyncTimeout=setTimeout(t),this.computeDistancesOnGPUSyncTimeout;case s.WAIT_FAILED:throw new Error("should never get here");default:this.computeDistancesOnGPUSyncTimeout=null,s.deleteSync(a);const r=s.getParameter(s.VERTEX_ARRAY_BINDING);s.bindVertexArray(this.distancesTransformFeedback.vao),s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),s.getBufferSubData(s.ARRAY_BUFFER,0,n),s.bindBuffer(s.ARRAY_BUFFER,null),r&&s.bindVertexArray(r),e()}}};this.computeDistancesOnGPUSyncTimeout=setTimeout(t)});return i&&!0!==o&&s.useProgram(i),r&&s.bindVertexArray(r),l}}();getLocalSplatParameters(e,t,n){null==n&&(n=!this.dynamicMode),t.splatBuffer=this.getSplatBufferForSplat(e),t.localIndex=this.getSplatLocalIndex(e),t.sceneTransform=n?this.getSceneTransformForSplat(e):null}fillSplatDataArrays(e,n,s,r,i,o,a,l=0,c=0,h=1,d,p,u=0,m){const A=new t.Vector3;A.x=void 0,A.y=void 0,this.splatRenderMode===tn?A.z=void 0:A.z=1;const f=new t.Matrix4;let g=0,S=this.scenes.length-1;null!=m&&m>=0&&m<=this.scenes.length&&(g=m,S=m);for(let t=g;t<=S;t++){null==a&&(a=!this.dynamicMode);const m=this.getScene(t),g=m.splatBuffer;let S;if(a&&(this.getSceneTransform(t,f),S=f),e&&g.fillSplatCovarianceArray(e,S,d,p,u,l),n||s){if(!n||!s)throw new Error('SplatMesh::fillSplatDataArrays() -> "scales" and "rotations" must both be valid.');g.fillSplatScaleRotationArray(n,s,S,d,p,u,c,A)}r&&g.fillSplatCenterArray(r,S,d,p,u),i&&g.fillSplatColorArray(i,m.minimumAlpha,d,p,u),o&&g.fillSphericalHarmonicsArray(o,this.minSphericalHarmonicsDegree,S,d,p,u,h),u+=g.getSplatCount()}}getIntegerCenters(e,t,n=!1){const s=t-e+1,r=new Float32Array(3*s);let i;this.fillSplatDataArrays(null,null,null,r,null,null,void 0,void 0,void 0,void 0,e);let o=n?4:3;i=new Int32Array(s*o);for(let a=0;a<s;a++){for(let e=0;e<3;e++)i[a*o+e]=Math.round(1e3*r[3*a+e]);n&&(i[a*o+3]=1e3)}return i}getFloatCenters(e,t,n=!1){const s=t-e+1,r=new Float32Array(3*s);if(this.fillSplatDataArrays(null,null,null,r,null,null,void 0,void 0,void 0,void 0,e),!n)return r;let i=new Float32Array(4*s);for(let o=0;o<s;o++){for(let e=0;e<3;e++)i[4*o+e]=r[3*o+e];i[4*o+3]=1}return i}getSplatCenter=function(){const e={};return function(t,n,s){this.getLocalSplatParameters(t,e,s),e.splatBuffer.getSplatCenter(e.localIndex,n,e.sceneTransform)}}();getSplatScaleAndRotation=function(){const e={},n=new t.Vector3;return function(t,s,r,i){this.getLocalSplatParameters(t,e,i),n.x=void 0,n.y=void 0,n.z=void 0,this.splatRenderMode===nn&&(n.z=0),e.splatBuffer.getSplatScaleAndRotation(e.localIndex,s,r,e.sceneTransform,n)}}();getSplatColor=function(){const e={};return function(t,n){this.getLocalSplatParameters(t,e),e.splatBuffer.getSplatColor(e.localIndex,n)}}();getSceneTransform(e,t){const n=this.getScene(e);n.updateTransform(this.dynamicMode),t.copy(n.transform)}getScene(e){if(e<0||e>=this.scenes.length)throw new Error("SplatMesh::getScene() -> Invalid scene index.");return this.scenes[e]}getSceneCount(){return this.scenes.length}getSplatBufferForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).splatBuffer}getSceneIndexForSplat(e){return this.globalSplatIndexToSceneIndexMap[e]}getSceneTransformForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).transform}getSplatLocalIndex(e){return this.globalSplatIndexToLocalSplatIndexMap[e]}static getIntegerMatrixArray(e){const t=e.elements,n=[];for(let s=0;s<16;s++)n[s]=Math.round(1e3*t[s]);return n}computeBoundingBox(e=!1,n){let s=this.getSplatCount();if(null!=n){if(n<0||n>=this.scenes.length)throw new Error("SplatMesh::computeBoundingBox() -> Invalid scene index.");s=this.scenes[n].splatBuffer.getSplatCount()}const r=new Float32Array(3*s);this.fillSplatDataArrays(null,null,null,r,null,null,e,void 0,void 0,void 0,void 0,n);const i=new t.Vector3,o=new t.Vector3;for(let t=0;t<s;t++){const e=3*t,n=r[e],s=r[e+1],a=r[e+2];(0===t||n<i.x)&&(i.x=n),(0===t||s<i.y)&&(i.y=s),(0===t||a<i.z)&&(i.z=a),(0===t||n>o.x)&&(o.x=n),(0===t||s>o.y)&&(o.y=s),(0===t||a>o.z)&&(o.z=a)}return new t.Box3(i,o)}}var Bn="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";function wn(e){let t,n,s,r,i,o,a,l,c,h,d,p,u,m,A,f,g,S,C,y;e.onmessage=x=>{if(x.data.centers)centers=x.data.centers,sceneIndexes=x.data.sceneIndexes,r?new Int32Array(n,m+x.data.range.from*y.BytesPerInt*4,4*x.data.range.count).set(new Int32Array(centers)):new Float32Array(n,m+x.data.range.from*y.BytesPerFloat*4,4*x.data.range.count).set(new Float32Array(centers)),i&&new Uint32Array(n,c+4*x.data.range.from,x.data.range.count).set(new Uint32Array(sceneIndexes)),C=x.data.range.from+x.data.range.count;else if(x.data.sort){const v=Math.min(x.data.sort.splatRenderCount||0,C),I=Math.min(x.data.sort.splatSortCount||0,C),B=x.data.sort.usePrecomputedDistances;let w,b,D;s||(w=x.data.sort.indexesToSort,D=x.data.sort.transforms,B&&(b=x.data.sort.precomputedDistances)),function(C,x,v,I,B,w,b){const D=performance.now();if(!s&&(new Uint32Array(n,a,B.byteLength/y.BytesPerInt).set(B),new Float32Array(n,h,b.byteLength/y.BytesPerFloat).set(b),I)){let e;e=r?new Int32Array(n,d,w.byteLength/y.BytesPerInt):new Float32Array(n,d,w.byteLength/y.BytesPerFloat),e.set(w)}f||(f=new Uint32Array(S)),new Float32Array(n,A,16).set(v),new Uint32Array(n,u,S).set(f),t.exports.sortIndexes(a,m,d,p,u,A,l,c,h,S,C,x,o,I,r,i);const T={sortDone:!0,splatSortCount:C,splatRenderCount:x,sortTime:0};if(!s){const e=new Uint32Array(n,l,x);(!g||g.length<x)&&(g=new Uint32Array(x)),g.set(e),T.sortedIndexes=g}const E=performance.now();T.sortTime=E-D,e.postMessage(T)}(I,v,x.data.sort.modelViewProj,B,w,b,D)}else if(x.data.init){y=x.data.init.Constants,o=x.data.init.splatCount,s=x.data.init.useSharedMemory,r=x.data.init.integerBasedSort,i=x.data.init.dynamicMode,S=x.data.init.distanceMapRange,C=0;const f=r?4*y.BytesPerInt:4*y.BytesPerFloat,g=new Uint8Array(x.data.init.sorterWasmBytes),v=16*y.BytesPerFloat,I=o*y.BytesPerInt,B=o*f,w=v,b=r?o*y.BytesPerInt:o*y.BytesPerFloat,D=o*y.BytesPerInt,T=o*y.BytesPerInt,E=r?S*y.BytesPerInt*2:S*y.BytesPerFloat*2,M=i?o*y.BytesPerInt:0,F=i?y.MaxScenes*v:0,R=32*y.MemoryPageSize,P=I+B+w+b+D+E+T+M+F+R,H=Math.floor(P/y.MemoryPageSize)+1,k={module:{},env:{memory:new WebAssembly.Memory({initial:H,maximum:H,shared:!0})}};WebAssembly.compile(g).then(e=>WebAssembly.instantiate(e,k)).then(r=>{t=r,a=0,m=a+I,A=m+B,d=A+w,p=d+b,u=p+D,l=u+E,c=l+T,h=c+M,n=k.env.memory.buffer,s?e.postMessage({sortSetupPhase1Complete:!0,indexesToSortBuffer:n,indexesToSortOffset:a,sortedIndexesBuffer:n,sortedIndexesOffset:l,precomputedDistancesBuffer:n,precomputedDistancesOffset:d,transformsBuffer:n,transformsOffset:h}):e.postMessage({sortSetupPhase1Complete:!0})})}}}const bn=0,Dn=1,Tn=2;class En{static createButton(e,t={}){const n=document.createElement("button");function s(){n.style.display="",n.style.cursor="auto",n.style.left="calc(50% - 75px)",n.style.width="150px",n.onmouseenter=null,n.onmouseleave=null,n.onclick=null}function r(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return n.id="VRButton",n.style.display="none",r(n),navigator.xr.isSessionSupported("immersive-vr").then(function(r){r?function(){let s=null;async function r(t){t.addEventListener("end",i),await e.xr.setSession(t),n.textContent="EXIT VR",s=t}function i(){s.removeEventListener("end",i),n.textContent="ENTER VR",s=null}n.style.display="",n.style.cursor="pointer",n.style.left="calc(50% - 50px)",n.style.width="100px",n.textContent="ENTER VR";const o={...t,optionalFeatures:["local-floor","bounded-floor","layers",...t.optionalFeatures||[]]};n.onmouseenter=function(){n.style.opacity="1.0"},n.onmouseleave=function(){n.style.opacity="0.5"},n.onclick=function(){null===s?navigator.xr.requestSession("immersive-vr",o).then(r):(s.end(),void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-vr",o).then(r).catch(e=>{console.warn(e)}))},void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-vr",o).then(r).catch(e=>{console.warn(e)})}():(s(),n.textContent="VR NOT SUPPORTED"),r&&En.xrSessionIsGranted&&n.click()}).catch(function(e){s(),console.warn("Exception when trying to call xr.isSessionSupported",e),n.textContent="VR NOT ALLOWED"}),n;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",r(e),e}}static registerSessionGrantedListener(){if("undefined"!=typeof navigator&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",()=>{En.xrSessionIsGranted=!0})}}}En.xrSessionIsGranted=!1,En.registerSessionGrantedListener();class Mn{static createButton(e,t={}){const n=document.createElement("button");function s(){n.style.display="",n.style.cursor="auto",n.style.left="calc(50% - 75px)",n.style.width="150px",n.onmouseenter=null,n.onmouseleave=null,n.onclick=null}function r(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return n.id="ARButton",n.style.display="none",r(n),navigator.xr.isSessionSupported("immersive-ar").then(function(r){r?function(){if(void 0===t.domOverlay){const e=document.createElement("div");e.style.display="none",document.body.appendChild(e);const n=document.createElementNS("http://www.w3.org/2000/svg","svg");n.setAttribute("width",38),n.setAttribute("height",38),n.style.position="absolute",n.style.right="20px",n.style.top="20px",n.addEventListener("click",function(){s.end()}),e.appendChild(n);const r=document.createElementNS("http://www.w3.org/2000/svg","path");r.setAttribute("d","M 12,12 L 28,28 M 28,12 12,28"),r.setAttribute("stroke","#fff"),r.setAttribute("stroke-width",2),n.appendChild(r),void 0===t.optionalFeatures&&(t.optionalFeatures=[]),t.optionalFeatures.push("dom-overlay"),t.domOverlay={root:e}}let s=null;async function r(r){r.addEventListener("end",i),e.xr.setReferenceSpaceType("local"),await e.xr.setSession(r),n.textContent="STOP AR",t.domOverlay.root.style.display="",s=r}function i(){s.removeEventListener("end",i),n.textContent="START AR",t.domOverlay.root.style.display="none",s=null}n.style.display="",n.style.cursor="pointer",n.style.left="calc(50% - 50px)",n.style.width="100px",n.textContent="START AR",n.onmouseenter=function(){n.style.opacity="1.0"},n.onmouseleave=function(){n.style.opacity="0.5"},n.onclick=function(){null===s?navigator.xr.requestSession("immersive-ar",t).then(r):(s.end(),void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-ar",t).then(r).catch(e=>{console.warn(e)}))},void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-ar",t).then(r).catch(e=>{console.warn(e)})}():(s(),n.textContent="AR NOT SUPPORTED")}).catch(function(e){s(),console.warn("Exception when trying to call xr.isSessionSupported",e),n.textContent="AR NOT ALLOWED"}),n;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",r(e),e}}}const Fn=0,Rn=2;class Pn{constructor(e={}){if(e.cameraUp||(e.cameraUp=[0,1,0]),this.cameraUp=(new t.Vector3).fromArray(e.cameraUp),e.initialCameraPosition||(e.initialCameraPosition=[0,10,15]),this.initialCameraPosition=(new t.Vector3).fromArray(e.initialCameraPosition),e.initialCameraLookAt||(e.initialCameraLookAt=[0,0,0]),this.initialCameraLookAt=(new t.Vector3).fromArray(e.initialCameraLookAt),this.dropInMode=e.dropInMode||!1,void 0!==e.selfDrivenMode&&null!==e.selfDrivenMode||(e.selfDrivenMode=!0),this.selfDrivenMode=e.selfDrivenMode&&!this.dropInMode,this.selfDrivenUpdateFunc=this.selfDrivenUpdate.bind(this),void 0===e.useBuiltInControls&&(e.useBuiltInControls=!0),this.useBuiltInControls=e.useBuiltInControls,this.rootElement=e.rootElement,this.ignoreDevicePixelRatio=e.ignoreDevicePixelRatio||!1,this.devicePixelRatio=this.ignoreDevicePixelRatio?1:window.devicePixelRatio||1,this.halfPrecisionCovariancesOnGPU=e.halfPrecisionCovariancesOnGPU||!1,this.threeScene=e.threeScene,this.renderer=e.renderer,this.camera=e.camera,this.gpuAcceleratedSort=e.gpuAcceleratedSort||!1,void 0!==e.integerBasedSort&&null!==e.integerBasedSort||(e.integerBasedSort=!0),this.integerBasedSort=e.integerBasedSort,void 0!==e.sharedMemoryForWorkers&&null!==e.sharedMemoryForWorkers||(e.sharedMemoryForWorkers=!0),this.sharedMemoryForWorkers=e.sharedMemoryForWorkers,this.dynamicScene=!!e.dynamicScene,this.antialiased=e.antialiased||!1,this.kernel2DSize=void 0===e.kernel2DSize?.3:e.kernel2DSize,this.webXRMode=e.webXRMode||bn,this.webXRMode!==bn&&(this.gpuAcceleratedSort=!1),this.webXRActive=!1,this.webXRSessionInit=e.webXRSessionInit||{},this.renderMode=e.renderMode||Fn,this.sceneRevealMode=e.sceneRevealMode||fn,this.focalAdjustment=e.focalAdjustment||1,this.maxScreenSpaceSplatSize=e.maxScreenSpaceSplatSize||1024,this.logLevel=e.logLevel||Sn,this.sphericalHarmonicsDegree=e.sphericalHarmonicsDegree||0,this.enableOptionalEffects=e.enableOptionalEffects||!1,void 0!==e.enableSIMDInSort&&null!==e.enableSIMDInSort||(e.enableSIMDInSort=!0),this.enableSIMDInSort=e.enableSIMDInSort,void 0!==e.inMemoryCompressionLevel&&null!==e.inMemoryCompressionLevel||(e.inMemoryCompressionLevel=0),this.inMemoryCompressionLevel=e.inMemoryCompressionLevel,void 0!==e.optimizeSplatData&&null!==e.optimizeSplatData||(e.optimizeSplatData=!0),this.optimizeSplatData=e.optimizeSplatData,void 0!==e.freeIntermediateSplatData&&null!==e.freeIntermediateSplatData||(e.freeIntermediateSplatData=!1),this.freeIntermediateSplatData=e.freeIntermediateSplatData,w()){const e=b();e.major<17&&(this.enableSIMDInSort=!1),e.major<16&&(this.sharedMemoryForWorkers=!1)}void 0!==e.splatRenderMode&&null!==e.splatRenderMode||(e.splatRenderMode=tn),this.splatRenderMode=e.splatRenderMode,this.sceneFadeInRateMultiplier=e.sceneFadeInRateMultiplier||1,this.splatSortDistanceMapPrecision=e.splatSortDistanceMapPrecision||T.DefaultSplatSortDistanceMapPrecision;const n=this.integerBasedSort?20:24;this.splatSortDistanceMapPrecision=g(this.splatSortDistanceMapPrecision,10,n),this.onSplatMeshChangedCallback=null,this.createSplatMesh(),this.controls=null,this.perspectiveControls=null,this.orthographicControls=null,this.orthographicCamera=null,this.perspectiveCamera=null,this.showMeshCursor=!1,this.showControlPlane=!1,this.showInfo=!1,this.sceneHelper=null,this.sortWorker=null,this.sortRunning=!1,this.splatRenderCount=0,this.splatSortCount=0,this.lastSplatSortCount=0,this.sortWorkerIndexesToSort=null,this.sortWorkerSortedIndexes=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.preSortMessages=[],this.runAfterNextSort=[],this.selfDrivenModeRunning=!1,this.splatRenderReady=!1,this.raycaster=new sn,this.infoPanel=null,this.startInOrthographicMode=!1,this.currentFPS=0,this.lastSortTime=0,this.consecutiveRenderFrames=0,this.previousCameraTarget=new t.Vector3,this.nextCameraTarget=new t.Vector3,this.mousePosition=new t.Vector2,this.mouseDownPosition=new t.Vector2,this.mouseDownTime=null,this.resizeObserver=null,this.mouseMoveListener=null,this.mouseDownListener=null,this.mouseUpListener=null,this.keyDownListener=null,this.sortPromise=null,this.sortPromiseResolver=null,this.splatSceneDownloadPromises={},this.splatSceneDownloadAndBuildPromise=null,this.splatSceneRemovalPromise=null,this.loadingSpinner=new Gt(null,this.rootElement||document.body),this.loadingSpinner.hide(),this.loadingProgressBar=new Kt(this.rootElement||document.body),this.loadingProgressBar.hide(),this.infoPanel=new qt(this.rootElement||document.body),this.infoPanel.hide(),this.usingExternalCamera=!(!this.dropInMode&&!this.camera),this.usingExternalRenderer=!(!this.dropInMode&&!this.renderer),this.initialized=!1,this.disposing=!1,this.disposed=!1,this.disposePromise=null,this.dropInMode||this.init()}createSplatMesh(){this.splatMesh=new In(this.splatRenderMode,this.dynamicScene,this.enableOptionalEffects,this.halfPrecisionCovariancesOnGPU,this.devicePixelRatio,this.gpuAcceleratedSort,this.integerBasedSort,this.antialiased,this.maxScreenSpaceSplatSize,this.logLevel,this.sphericalHarmonicsDegree,this.sceneFadeInRateMultiplier,this.kernel2DSize),this.splatMesh.frustumCulled=!1,this.onSplatMeshChangedCallback&&this.onSplatMeshChangedCallback()}init(){this.initialized||(this.rootElement||(this.usingExternalRenderer?this.rootElement=this.renderer.domElement||document.body:(this.rootElement=document.createElement("div"),this.rootElement.style.width="100%",this.rootElement.style.height="100%",this.rootElement.style.position="absolute",document.body.appendChild(this.rootElement))),this.setupCamera(),this.setupRenderer(),this.setupWebXR(this.webXRSessionInit),this.setupControls(),this.setupEventHandlers(),this.threeScene=this.threeScene||new t.Scene,this.sceneHelper=new Yt(this.threeScene),this.sceneHelper.setupMeshCursor(),this.sceneHelper.setupFocusMarker(),this.sceneHelper.setupControlPlane(),this.loadingProgressBar.setContainer(this.rootElement),this.loadingSpinner.setContainer(this.rootElement),this.infoPanel.setContainer(this.rootElement),this.initialized=!0)}setupCamera(){if(!this.usingExternalCamera){const e=new t.Vector2;this.getRenderDimensions(e),this.perspectiveCamera=new t.PerspectiveCamera(50,e.x/e.y,.1,1e3),this.orthographicCamera=new t.OrthographicCamera(e.x/-2,e.x/2,e.y/2,e.y/-2,.1,1e3),this.camera=this.startInOrthographicMode?this.orthographicCamera:this.perspectiveCamera,this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt)}}setupRenderer(){if(!this.usingExternalRenderer){const e=new t.Vector2;this.getRenderDimensions(e),this.renderer=new t.WebGLRenderer({antialias:!1,precision:"highp"}),this.renderer.setPixelRatio(this.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(new t.Color(0),0),this.renderer.setSize(e.x,e.y),this.resizeObserver=new ResizeObserver(()=>{this.getRenderDimensions(e),this.renderer.setSize(e.x,e.y),this.forceRenderNextFrame()}),this.resizeObserver.observe(this.rootElement),this.rootElement.appendChild(this.renderer.domElement)}}setupWebXR(e){this.webXRMode&&(this.webXRMode===Dn?this.rootElement.appendChild(En.createButton(this.renderer,e)):this.webXRMode===Tn&&this.rootElement.appendChild(Mn.createButton(this.renderer,e)),this.renderer.xr.addEventListener("sessionstart",e=>{this.webXRActive=!0}),this.renderer.xr.addEventListener("sessionend",e=>{this.webXRActive=!1}),this.renderer.xr.enabled=!0,this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt))}setupControls(){if(this.useBuiltInControls&&this.webXRMode===bn){this.usingExternalCamera?this.camera.isOrthographicCamera?this.orthographicControls=new Nt(this.camera,this.renderer.domElement):this.perspectiveControls=new Nt(this.camera,this.renderer.domElement):(this.perspectiveControls=new Nt(this.perspectiveCamera,this.renderer.domElement),this.orthographicControls=new Nt(this.orthographicCamera,this.renderer.domElement));for(let e of[this.orthographicControls,this.perspectiveControls])e&&(e.listenToKeyEvents(window),e.rotateSpeed=.5,e.maxPolarAngle=.75*Math.PI,e.minPolarAngle=.1,e.enableDamping=!0,e.dampingFactor=.05,e.target.copy(this.initialCameraLookAt),e.update());this.controls=this.camera.isOrthographicCamera?this.orthographicControls:this.perspectiveControls,this.controls.update()}}setupEventHandlers(){this.useBuiltInControls&&this.webXRMode===bn&&(this.mouseMoveListener=this.onMouseMove.bind(this),this.renderer.domElement.addEventListener("pointermove",this.mouseMoveListener,!1),this.mouseDownListener=this.onMouseDown.bind(this),this.renderer.domElement.addEventListener("pointerdown",this.mouseDownListener,!1),this.mouseUpListener=this.onMouseUp.bind(this),this.renderer.domElement.addEventListener("pointerup",this.mouseUpListener,!1),this.keyDownListener=this.onKeyDown.bind(this),window.addEventListener("keydown",this.keyDownListener,!1))}removeEventHandlers(){this.useBuiltInControls&&(this.renderer.domElement.removeEventListener("pointermove",this.mouseMoveListener),this.mouseMoveListener=null,this.renderer.domElement.removeEventListener("pointerdown",this.mouseDownListener),this.mouseDownListener=null,this.renderer.domElement.removeEventListener("pointerup",this.mouseUpListener),this.mouseUpListener=null,window.removeEventListener("keydown",this.keyDownListener),this.keyDownListener=null)}setRenderMode(e){this.renderMode=e}setActiveSphericalHarmonicsDegrees(e){this.splatMesh.material.uniforms.sphericalHarmonicsDegree.value=e,this.splatMesh.material.uniformsNeedUpdate=!0}onSplatMeshChanged(e){this.onSplatMeshChangedCallback=e}onKeyDown=function(){const e=new t.Vector3,n=new t.Matrix4,s=new t.Matrix4;return function(t){switch(e.set(0,0,-1),e.transformDirection(this.camera.matrixWorld),n.makeRotationAxis(e,Math.PI/128),s.makeRotationAxis(e,-Math.PI/128),t.code){case"KeyG":this.focalAdjustment+=.02,this.forceRenderNextFrame();break;case"KeyF":this.focalAdjustment-=.02,this.forceRenderNextFrame();break;case"ArrowLeft":this.camera.up.transformDirection(n);break;case"ArrowRight":this.camera.up.transformDirection(s);break;case"KeyC":this.showMeshCursor=!this.showMeshCursor;break;case"KeyU":this.showControlPlane=!this.showControlPlane;break;case"KeyI":this.showInfo=!this.showInfo,this.showInfo?this.infoPanel.show():this.infoPanel.hide();break;case"KeyO":this.usingExternalCamera||this.setOrthographicMode(!this.camera.isOrthographicCamera);break;case"KeyP":this.usingExternalCamera||this.splatMesh.setPointCloudModeEnabled(!this.splatMesh.getPointCloudModeEnabled());break;case"Equal":this.usingExternalCamera||this.splatMesh.setSplatScale(this.splatMesh.getSplatScale()+.05);break;case"Minus":this.usingExternalCamera||this.splatMesh.setSplatScale(Math.max(this.splatMesh.getSplatScale()-.05,0))}}}();onMouseMove(e){this.mousePosition.set(e.offsetX,e.offsetY)}onMouseDown(){this.mouseDownPosition.copy(this.mousePosition),this.mouseDownTime=S()}onMouseUp=function(){const e=new t.Vector2;return function(t){e.copy(this.mousePosition).sub(this.mouseDownPosition);S()-this.mouseDownTime<.5&&e.length()<2&&this.onMouseClick(t)}}();onMouseClick(e){this.mousePosition.set(e.offsetX,e.offsetY),this.checkForFocalPointChange()}checkForFocalPointChange=function(){const e=new t.Vector2,n=new t.Vector3,s=[];return function(){if(!this.transitioningCameraTarget&&(this.getRenderDimensions(e),s.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,e),this.raycaster.intersectSplatMesh(this.splatMesh,s),s.length>0)){const e=s[0].origin;n.copy(e).sub(this.camera.position),n.length()>.75&&(this.previousCameraTarget.copy(this.controls.target),this.nextCameraTarget.copy(e),this.transitioningCameraTarget=!0,this.transitioningCameraTargetStartTime=S())}}}();getRenderDimensions(e){this.rootElement?(e.x=this.rootElement.offsetWidth,e.y=this.rootElement.offsetHeight):this.renderer.getSize(e)}setOrthographicMode(e){if(e===this.camera.isOrthographicCamera)return;const t=this.camera,n=e?this.orthographicCamera:this.perspectiveCamera;if(n.position.copy(t.position),n.up.copy(t.up),n.rotation.copy(t.rotation),n.quaternion.copy(t.quaternion),n.matrix.copy(t.matrix),this.camera=n,this.controls){const s=e=>{e.saveState(),e.reset()},r=this.controls,i=e?this.orthographicControls:this.perspectiveControls;s(i),s(r),i.target.copy(r.target),e?Pn.setCameraZoomFromPosition(n,t,r):Pn.setCameraPositionFromZoom(n,t,i),this.controls=i,this.camera.lookAt(this.controls.target)}}static setCameraPositionFromZoom=function(){const e=new t.Vector3;return function(t,n,s){const r=1/(.001*n.zoom);e.copy(s.target).sub(t.position).normalize().multiplyScalar(r).negate(),t.position.copy(s.target).add(e)}}();static setCameraZoomFromPosition=function(){const e=new t.Vector3;return function(t,n,s){const r=e.copy(s.target).sub(n.position).length();t.zoom=1/(.001*r)}}();updateSplatMesh=function(){const e=new t.Vector2;return function(){if(!this.splatMesh)return;if(this.splatMesh.getSplatCount()>0){this.splatMesh.updateVisibleRegionFadeDistance(this.sceneRevealMode),this.splatMesh.updateTransforms(),this.getRenderDimensions(e);const t=.5*this.camera.projectionMatrix.elements[0]*this.devicePixelRatio*e.x,n=.5*this.camera.projectionMatrix.elements[5]*this.devicePixelRatio*e.y,s=this.camera.isOrthographicCamera?1/this.devicePixelRatio:1,r=this.focalAdjustment*s,i=1/r;this.adjustForWebXRStereo(e),this.splatMesh.updateUniforms(e,t*r,n*r,this.camera.isOrthographicCamera,this.camera.zoom||1,i)}}}();adjustForWebXRStereo(e){if(this.camera&&this.webXRActive){const t=this.renderer.xr.getCamera().projectionMatrix.elements[0],n=this.camera.projectionMatrix.elements[0];e.x*=n/t}}isLoadingOrUnloading(){return Object.keys(this.splatSceneDownloadPromises).length>0||null!==this.splatSceneDownloadAndBuildPromise||null!==this.splatSceneRemovalPromise}isDisposingOrDisposed(){return this.disposing||this.disposed}addSplatSceneDownloadPromise(e){this.splatSceneDownloadPromises[e.id]=e}removeSplatSceneDownloadPromise(e){delete this.splatSceneDownloadPromises[e.id]}setSplatSceneDownloadAndBuildPromise(e){this.splatSceneDownloadAndBuildPromise=e}clearSplatSceneDownloadAndBuildPromise(){this.splatSceneDownloadAndBuildPromise=null}addSplatScene(e,t={}){if(this.isLoadingOrUnloading())throw new Error("Cannot add splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");t.progressiveLoad&&this.splatMesh.scenes&&this.splatMesh.scenes.length>0&&(console.log('addSplatScene(): "progressiveLoad" option ignore because there are multiple splat scenes'),t.progressiveLoad=!1);const n=void 0!==t.format&&null!==t.format?t.format:Lt(e),s=Pn.isProgressivelyLoadable(n)&&t.progressiveLoad,r=void 0===t.showLoadingUI||null===t.showLoadingUI||t.showLoadingUI;let i=null;r&&(this.loadingSpinner.removeAllTasks(),i=this.loadingSpinner.addTask("Downloading..."));const o=(e,t,n)=>{if(r)if(n===ht)if(100==e)this.loadingSpinner.setMessageForTask(i,"Download complete!");else if(s)this.loadingSpinner.setMessageForTask(i,"Downloading splats...");else{const e=t?`: ${t}`:"...";this.loadingSpinner.setMessageForTask(i,`Downloading${e}`)}else n===dt&&this.loadingSpinner.setMessageForTask(i,"Processing splats...")};let a=!1,l=0;const c=(e,t)=>{r&&((e&&s||t&&!s)&&(this.loadingSpinner.removeTask(i),t||a||this.loadingProgressBar.show()),s&&(t?(a=!0,this.loadingProgressBar.hide()):this.loadingProgressBar.setProgress(l)))};return(s?this.downloadAndBuildSingleSplatSceneProgressiveLoad.bind(this):this.downloadAndBuildSingleSplatSceneStandardLoad.bind(this))(e,n,t.splatAlphaRemovalThreshold,((e,n,i)=>{!s&&t.onProgress&&t.onProgress(0,"0%",dt);const o={rotation:t.rotation||t.orientation,position:t.position,scale:t.scale,splatAlphaRemovalThreshold:t.splatAlphaRemovalThreshold};return this.addSplatBuffers([e],[o],i,n&&r,r,s,s).then(()=>{!s&&t.onProgress&&t.onProgress(100,"100%",dt),c(n,i)})}).bind(this),(e,n,s)=>{l=e,o(e,n,s),t.onProgress&&t.onProgress(e,n,s)},(()=>{this.loadingProgressBar.hide(),this.loadingSpinner.removeAllTasks()}).bind(this),t.headers)}downloadAndBuildSingleSplatSceneStandardLoad(e,t,n,s,r,i,o){const a=this.downloadSplatSceneToSplatBuffer(e,n,r,!1,void 0,t,o),l=I(a.abortHandler);return a.then(e=>(this.removeSplatSceneDownloadPromise(a),s(e,!0,!0).then(()=>{l.resolve(),this.clearSplatSceneDownloadAndBuildPromise()}))).catch(t=>{i&&i(),this.clearSplatSceneDownloadAndBuildPromise(),this.removeSplatSceneDownloadPromise(a),l.reject(this.updateError(t,`Viewer::addSplatScene -> Could not load file ${e}`))}),this.addSplatSceneDownloadPromise(a),this.setSplatSceneDownloadAndBuildPromise(l.promise),l.promise}downloadAndBuildSingleSplatSceneProgressiveLoad(e,t,n,s,r,i,o){let a=0,l=!1;const c=[],h=()=>{if(c.length>0&&!l&&!this.isDisposingOrDisposed()){l=!0;const e=c.shift();s(e.splatBuffer,e.firstBuild,e.finalBuild).then(()=>{l=!1,e.firstBuild?p.resolve():e.finalBuild&&(u.resolve(),this.clearSplatSceneDownloadAndBuildPromise()),c.length>0&&y(()=>h())})}},d=this.downloadSplatSceneToSplatBuffer(e,n,r,!0,(e,t)=>{this.isDisposingOrDisposed()||(t||0===c.length||e.getSplatCount()>c[0].splatBuffer.getSplatCount())&&(c.push({splatBuffer:e,firstBuild:0===a,finalBuild:t}),a++,h())},t,o),p=I(d.abortHandler),u=I();return this.addSplatSceneDownloadPromise(d),this.setSplatSceneDownloadAndBuildPromise(u.promise),d.then(()=>{this.removeSplatSceneDownloadPromise(d)}).catch(e=>{this.clearSplatSceneDownloadAndBuildPromise(),this.removeSplatSceneDownloadPromise(d);const t=this.updateError(e,"Viewer::addSplatScene -> Could not load one or more scenes");p.reject(t),i&&i(t)}),p.promise}addSplatScenes(e,t=!0,n=void 0){if(this.isLoadingOrUnloading())throw new Error("Cannot add splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");const s=e.length,r=[];let i;t&&(this.loadingSpinner.removeAllTasks(),i=this.loadingSpinner.addTask("Downloading..."));const o=(e,o,a,l)=>{r[e]=o;let c=0;for(let t=0;t<s;t++)c+=r[t]||0;c/=s,a=`${c.toFixed(2)}%`,t&&l===ht&&this.loadingSpinner.setMessageForTask(i,100==c?"Download complete!":`Downloading: ${a}`),n&&n(c,a,l)},a=[],l=[];for(let h=0;h<e.length;h++){const t=e[h],n=void 0!==t.format&&null!==t.format?t.format:Lt(t.path),s=this.downloadSplatSceneToSplatBuffer(t.path,t.splatAlphaRemovalThreshold,o.bind(this,h),!1,void 0,n,t.headers);a.push(s),l.push(s.promise)}const c=new p((s,r)=>{Promise.all(l).then(r=>{t&&this.loadingSpinner.removeTask(i),n&&n(0,"0%",dt),this.addSplatBuffers(r,e,!0,t,t,!1,!1).then(()=>{n&&n(100,"100%",dt),this.clearSplatSceneDownloadAndBuildPromise(),s()})}).catch(e=>{t&&this.loadingSpinner.removeTask(i),this.clearSplatSceneDownloadAndBuildPromise(),r(this.updateError(e,"Viewer::addSplatScenes -> Could not load one or more splat scenes."))}).finally(()=>{this.removeSplatSceneDownloadPromise(c)})},e=>{for(let t of a)t.abort(e)});return this.addSplatSceneDownloadPromise(c),this.setSplatSceneDownloadAndBuildPromise(c),c}downloadSplatSceneToSplatBuffer(e,t=1,n=void 0,s=!1,r=void 0,i,o){try{if(i===Rt||i===Pt||i===Ht){const a=!s&&this.optimizeSplatData;if(i===Rt)return Mt.loadFromURL(e,n,s,r,t,this.inMemoryCompressionLevel,a,o);if(i===Pt)return Ft.loadFromURL(e,n,s,r,o);if(i===Ht)return Ct.loadFromURL(e,n,s,r,t,this.inMemoryCompressionLevel,a,this.sphericalHarmonicsDegree,o)}else if(i===kt)return Dt.loadFromURL(e,n,t,this.inMemoryCompressionLevel,this.optimizeSplatData,this.sphericalHarmonicsDegree,o)}catch(a){throw this.updateError(a,null)}throw new Error(`Viewer::downloadSplatSceneToSplatBuffer -> File format not supported: ${e}`)}static isProgressivelyLoadable(e){return e===Rt||e===Pt||e===Ht}addSplatBuffers=function(){return function(e,t=[],n=!0,s=!0,r=!0,i=!1,o=!1,a=!0){if(this.isDisposingOrDisposed())return Promise.resolve();let l=null;const c=()=>{null!==l&&(this.loadingSpinner.removeTask(l),l=null)};return this.splatRenderReady=!1,new Promise(h=>{s&&(l=this.loadingSpinner.addTask("Processing splats...")),y(()=>{if(this.isDisposingOrDisposed())h();else{const s=this.addSplatBuffersToMesh(e,t,n,r,i,a),l=this.splatMesh.getMaxSplatCount();this.sortWorker&&this.sortWorker.maxSplatCount!==l&&this.disposeSortWorker(),this.gpuAcceleratedSort||this.preSortMessages.push({centers:s.centers.buffer,sceneIndexes:s.sceneIndexes.buffer,range:{from:s.from,to:s.to,count:s.count}});(!this.sortWorker&&l>0?this.setupSortWorker(this.splatMesh):Promise.resolve()).then(()=>{this.isDisposingOrDisposed()||this.runSplatSort(!0,!0).then(e=>{this.sortWorker&&e?(o?this.splatRenderReady=!0:this.runAfterNextSort.push(()=>{this.splatRenderReady=!0}),this.runAfterNextSort.push(()=>{c(),h()})):(this.splatRenderReady=!0,c(),h())})})}},!0)})}}();addSplatBuffersToMesh=function(){let e;return function(t,n,s=!0,r=!1,i=!1,o=!0){if(this.isDisposingOrDisposed())return;let a=[],l=[];i||(a=this.splatMesh.scenes.map(e=>e.splatBuffer)||[],l=this.splatMesh.sceneOptions?this.splatMesh.sceneOptions.map(e=>e):[]),a.push(...t),l.push(...n),this.renderer&&this.splatMesh.setRenderer(this.renderer);const c=this.splatMesh.build(a,l,!0,s,t=>{if(this.isDisposingOrDisposed())return;const n=this.splatMesh.getSplatCount();r&&n>=15e5&&(t||e||(this.loadingSpinner.setMinimized(!0,!0),e=this.loadingSpinner.addTask("Optimizing data structures...")))},t=>{this.isDisposingOrDisposed()||t&&e&&(this.loadingSpinner.removeTask(e),e=null)},o);return s&&this.freeIntermediateSplatData&&this.splatMesh.freeIntermediateSplatData(),c}}();setupSortWorker(e){if(!this.isDisposingOrDisposed())return new Promise(t=>{const n=this.integerBasedSort?Int32Array:Float32Array,s=e.getSplatCount(),r=e.getMaxSplatCount();this.sortWorker=function(e,t,n,s,r,i=T.DefaultSplatSortDistanceMapPrecision){const o=new Worker(URL.createObjectURL(new Blob(["(",wn.toString(),")(self)"],{type:"application/javascript"})));let a="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";const l=w()?b():null;n||t?n?t||l&&l.major<=16&&l.minor<4&&(a="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"):a=Bn:(a=Bn,l&&l.major<=16&&l.minor<4&&(a="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"));const c=atob(a),h=new Uint8Array(c.length);for(let d=0;d<c.length;d++)h[d]=c.charCodeAt(d);return o.postMessage({init:{sorterWasmBytes:h.buffer,splatCount:e,useSharedMemory:t,integerBasedSort:s,dynamicMode:r,distanceMapRange:1<<i,Constants:{BytesPerFloat:T.BytesPerFloat,BytesPerInt:T.BytesPerInt,MemoryPageSize:T.MemoryPageSize,MaxScenes:T.MaxScenes}}}),o}(r,this.sharedMemoryForWorkers,this.enableSIMDInSort,this.integerBasedSort,this.splatMesh.dynamicMode,this.splatSortDistanceMapPrecision),this.sortWorker.onmessage=e=>{if(e.data.sortDone){if(this.sortRunning=!1,this.sharedMemoryForWorkers)this.splatMesh.updateRenderIndexes(this.sortWorkerSortedIndexes,e.data.splatRenderCount);else{const t=new Uint32Array(e.data.sortedIndexes.buffer,0,e.data.splatRenderCount);this.splatMesh.updateRenderIndexes(t,e.data.splatRenderCount)}this.lastSplatSortCount=this.splatSortCount,this.lastSortTime=e.data.sortTime,this.sortPromiseResolver(),this.sortPromiseResolver=null,this.forceRenderNextFrame(),this.runAfterNextSort.length>0&&(this.runAfterNextSort.forEach(e=>{e()}),this.runAfterNextSort.length=0)}else if(e.data.sortCanceled)this.sortRunning=!1;else if(e.data.sortSetupPhase1Complete){this.logLevel>=Cn&&console.log("Sorting web worker WASM setup complete."),this.sharedMemoryForWorkers?(this.sortWorkerSortedIndexes=new Uint32Array(e.data.sortedIndexesBuffer,e.data.sortedIndexesOffset,r),this.sortWorkerIndexesToSort=new Uint32Array(e.data.indexesToSortBuffer,e.data.indexesToSortOffset,r),this.sortWorkerPrecomputedDistances=new n(e.data.precomputedDistancesBuffer,e.data.precomputedDistancesOffset,r),this.sortWorkerTransforms=new Float32Array(e.data.transformsBuffer,e.data.transformsOffset,16*T.MaxScenes)):(this.sortWorkerIndexesToSort=new Uint32Array(r),this.sortWorkerPrecomputedDistances=new n(r),this.sortWorkerTransforms=new Float32Array(16*T.MaxScenes));for(let e=0;e<s;e++)this.sortWorkerIndexesToSort[e]=e;if(this.sortWorker.maxSplatCount=r,this.logLevel>=Cn){console.log("Sorting web worker ready.");const e=this.splatMesh.getSplatDataTextures(),t=e.covariances.size,n=e.centerColors.size;console.log("Covariances texture size: "+t.x+" x "+t.y),console.log("Centers/colors texture size: "+n.x+" x "+n.y)}t()}}})}updateError(e,t){return e instanceof u?e:e instanceof ut?new Error("File type or server does not support progressive loading."):t?new Error(t):e}disposeSortWorker(){this.sortWorker&&this.sortWorker.terminate(),this.sortWorker=null,this.sortPromise=null,this.sortPromiseResolver&&(this.sortPromiseResolver(),this.sortPromiseResolver=null),this.preSortMessages=[],this.sortRunning=!1}removeSplatScene(e,t=!0){return this.removeSplatScenes([e],t)}removeSplatScenes(e,t=!0){if(this.isLoadingOrUnloading())throw new Error("Cannot remove splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot remove splat scene after dispose() is called.");let n;return this.splatSceneRemovalPromise=new Promise((s,r)=>{let i;t&&(this.loadingSpinner.removeAllTasks(),this.loadingSpinner.show(),i=this.loadingSpinner.addTask("Removing splat scene..."));const o=()=>{t&&(this.loadingSpinner.hide(),this.loadingSpinner.removeTask(i))},a=e=>{o(),this.splatSceneRemovalPromise=null,e?r(e):s()},l=()=>!!this.isDisposingOrDisposed()&&(a(),!0);n=this.sortPromise||Promise.resolve(),n.then(()=>{if(l())return;const t=[],s=[],r=[];for(let n=0;n<this.splatMesh.scenes.length;n++){let i=!1;for(let t of e)if(t===n){i=!0;break}if(!i){const e=this.splatMesh.scenes[n];t.push(e.splatBuffer),s.push(this.splatMesh.sceneOptions[n]),r.push({position:e.position.clone(),quaternion:e.quaternion.clone(),scale:e.scale.clone()})}}this.disposeSortWorker(),this.splatMesh.dispose(),this.sceneRevealMode=gn,this.createSplatMesh(),this.addSplatBuffers(t,s,!0,!1,!0).then(()=>{l()||(o(),this.splatMesh.scenes.forEach((e,t)=>{e.position.copy(r[t].position),e.quaternion.copy(r[t].quaternion),e.scale.copy(r[t].scale)}),this.splatMesh.updateTransforms(),this.splatRenderReady=!1,this.runSplatSort(!0).then(()=>{l()?this.splatRenderReady=!0:(n=this.sortPromise||Promise.resolve(),n.then(()=>{this.splatRenderReady=!0,a()}))}))}).catch(e=>{a(e)})})}),this.splatSceneRemovalPromise}start(){if(!this.selfDrivenMode)throw new Error("Cannot start viewer unless it is in self driven mode.");this.webXRMode?this.renderer.setAnimationLoop(this.selfDrivenUpdateFunc):this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc),this.selfDrivenModeRunning=!0}stop(){this.selfDrivenMode&&this.selfDrivenModeRunning&&(this.webXRMode?this.renderer.setAnimationLoop(null):cancelAnimationFrame(this.requestFrameId),this.selfDrivenModeRunning=!1)}async dispose(){if(this.isDisposingOrDisposed())return this.disposePromise;let e=[],t=[];for(let n in this.splatSceneDownloadPromises)if(this.splatSceneDownloadPromises.hasOwnProperty(n)){const s=this.splatSceneDownloadPromises[n];t.push(s),e.push(s.promise)}return this.sortPromise&&e.push(this.sortPromise),this.disposing=!0,this.disposePromise=Promise.all(e).finally(()=>{this.stop(),this.orthographicControls&&(this.orthographicControls.dispose(),this.orthographicControls=null),this.perspectiveControls&&(this.perspectiveControls.dispose(),this.perspectiveControls=null),this.controls=null,this.splatMesh&&(this.splatMesh.dispose(),this.splatMesh=null),this.sceneHelper&&(this.sceneHelper.dispose(),this.sceneHelper=null),this.resizeObserver&&(this.resizeObserver.unobserve(this.rootElement),this.resizeObserver=null),this.disposeSortWorker(),this.removeEventHandlers(),this.loadingSpinner.removeAllTasks(),this.loadingSpinner.setContainer(null),this.loadingProgressBar.hide(),this.loadingProgressBar.setContainer(null),this.infoPanel.setContainer(null),this.camera=null,this.threeScene=null,this.splatRenderReady=!1,this.initialized=!1,this.renderer&&(this.usingExternalRenderer||(this.rootElement.removeChild(this.renderer.domElement),this.renderer.dispose()),this.renderer=null),this.usingExternalRenderer||document.body.removeChild(this.rootElement),this.sortWorkerSortedIndexes=null,this.sortWorkerIndexesToSort=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.disposed=!0,this.disposing=!1,this.disposePromise=null}),t.forEach(e=>{e.abort("Scene disposed")}),this.disposePromise}selfDrivenUpdate(){this.selfDrivenMode&&!this.webXRMode&&(this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc)),this.update(),this.shouldRender()?(this.render(),this.consecutiveRenderFrames++):this.consecutiveRenderFrames=0,this.renderNextFrame=!1}forceRenderNextFrame(){this.renderNextFrame=!0}shouldRender=function(){let e=0;const n=new t.Vector3,s=new t.Quaternion,r=1e-4;return function(){if(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())return!1;let t=!1,i=!1;if(this.camera){const e=this.camera.position,t=this.camera.quaternion;i=Math.abs(e.x-n.x)>r||Math.abs(e.y-n.y)>r||Math.abs(e.z-n.z)>r||Math.abs(t.x-s.x)>r||Math.abs(t.y-s.y)>r||Math.abs(t.z-s.z)>r||Math.abs(t.w-s.w)>r}return t=this.renderMode!==Rn&&(0===e||this.splatMesh.visibleRegionChanging||i||this.renderMode===Fn||!0===this.dynamicMode||this.renderNextFrame),this.camera&&(n.copy(this.camera.position),s.copy(this.camera.quaternion)),e++,t}}();render=function(){if(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())return;const e=this.renderer.autoClear;(e=>{for(let t of e.children)if(t.visible)return!0;return!1})(this.threeScene)&&(this.renderer.render(this.threeScene,this.camera),this.renderer.autoClear=!1),this.renderer.render(this.splatMesh,this.camera),this.renderer.autoClear=!1,this.sceneHelper.getFocusMarkerOpacity()>0&&this.renderer.render(this.sceneHelper.focusMarker,this.camera),this.showControlPlane&&this.renderer.render(this.sceneHelper.controlPlane,this.camera),this.renderer.autoClear=e};update(e,t){this.dropInMode&&this.updateForDropInMode(e,t),this.initialized&&this.splatRenderReady&&!this.isDisposingOrDisposed()&&(this.controls&&(this.controls.update(),this.camera.isOrthographicCamera&&!this.usingExternalCamera&&Pn.setCameraPositionFromZoom(this.camera,this.camera,this.controls)),this.runSplatSort(),this.updateForRendererSizeChanges(),this.updateSplatMesh(),this.updateMeshCursor(),this.updateFPS(),this.timingSensitiveUpdates(),this.updateInfoPanel(),this.updateControlPlane())}updateForDropInMode(e,t){this.renderer=e,this.splatMesh&&this.splatMesh.setRenderer(this.renderer),this.camera=t,this.controls&&(this.controls.object=t),this.init()}updateFPS=function(){let e=S(),t=0;return function(){if(this.consecutiveRenderFrames>60){const n=S();n-e>=1?(this.currentFPS=t,t=0,e=n):t++}else this.currentFPS=null}}();updateForRendererSizeChanges=function(){const e=new t.Vector2,n=new t.Vector2;let s;return function(){this.usingExternalCamera||(this.renderer.getSize(n),void 0!==s&&s===this.camera.isOrthographicCamera&&n.x===e.x&&n.y===e.y||(this.camera.isOrthographicCamera?(this.camera.left=-n.x/2,this.camera.right=n.x/2,this.camera.top=n.y/2,this.camera.bottom=-n.y/2):this.camera.aspect=n.x/n.y,this.camera.updateProjectionMatrix(),e.copy(n),s=this.camera.isOrthographicCamera))}}();timingSensitiveUpdates=function(){let e;return function(){const t=S();e||(e=t);const n=t-e;this.updateCameraTransition(t),this.updateFocusMarker(n),e=t}}();updateCameraTransition=function(){let e=new t.Vector3,n=new t.Vector3,s=new t.Vector3;return function(t){if(this.transitioningCameraTarget){n.copy(this.previousCameraTarget).sub(this.camera.position).normalize(),s.copy(this.nextCameraTarget).sub(this.camera.position).normalize();const r=Math.acos(n.dot(s)),i=(r/(Math.PI/3)*.65+.3)/r*(t-this.transitioningCameraTargetStartTime);e.copy(this.previousCameraTarget).lerp(this.nextCameraTarget,i),this.camera.lookAt(e),this.controls.target.copy(e),i>=1&&(this.transitioningCameraTarget=!1)}}}();updateFocusMarker=function(){const e=new t.Vector2;let n=!1;return function(t){if(this.getRenderDimensions(e),this.transitioningCameraTarget){this.sceneHelper.setFocusMarkerVisibility(!0);const s=Math.max(this.sceneHelper.getFocusMarkerOpacity(),0);let r=Math.min(s+10*t,1);this.sceneHelper.setFocusMarkerOpacity(r),this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e),n=!0,this.forceRenderNextFrame()}else{let s;if(s=n?1:Math.min(this.sceneHelper.getFocusMarkerOpacity(),1),s>0){this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e);let n=Math.max(s-2.5*t,0);this.sceneHelper.setFocusMarkerOpacity(n),0===n&&this.sceneHelper.setFocusMarkerVisibility(!1)}s>0&&this.forceRenderNextFrame(),n=!1}}}();updateMeshCursor=function(){const e=[],n=new t.Vector2;return function(){this.showMeshCursor?(this.forceRenderNextFrame(),this.getRenderDimensions(n),e.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,n),this.raycaster.intersectSplatMesh(this.splatMesh,e),e.length>0?(this.sceneHelper.setMeshCursorVisibility(!0),this.sceneHelper.positionAndOrientMeshCursor(e[0].origin,this.camera)):this.sceneHelper.setMeshCursorVisibility(!1)):(this.sceneHelper.getMeschCursorVisibility()&&this.forceRenderNextFrame(),this.sceneHelper.setMeshCursorVisibility(!1))}}();updateInfoPanel=function(){const e=new t.Vector2;return function(){if(!this.showInfo)return;const t=this.splatMesh.getSplatCount();this.getRenderDimensions(e);const n=this.controls?this.controls.target:null,s=this.showMeshCursor?this.sceneHelper.meshCursor.position:null,r=t>0?this.splatRenderCount/t*100:0;this.infoPanel.update(e,this.camera.position,n,this.camera.up,this.camera.isOrthographicCamera,s,this.currentFPS||"N/A",t,this.splatRenderCount,r,this.lastSortTime,this.focalAdjustment,this.splatMesh.getSplatScale(),this.splatMesh.getPointCloudModeEnabled())}}();updateControlPlane(){this.showControlPlane?(this.sceneHelper.setControlPlaneVisibility(!0),this.sceneHelper.positionAndOrientControlPlane(this.controls.target,this.camera.up)):this.sceneHelper.setControlPlaneVisibility(!1)}runSplatSort=function(){const e=new t.Matrix4,n=[],s=new t.Vector3(0,0,-1),r=new t.Vector3(0,0,-1),i=new t.Vector3,o=new t.Vector3,a=[],l=[{angleThreshold:.55,sortFractions:[.125,.33333,.75]},{angleThreshold:.65,sortFractions:[.33333,.66667]},{angleThreshold:.8,sortFractions:[.5]}];return function(t=!1,c=!1){if(!this.initialized)return Promise.resolve(!1);if(this.sortRunning)return Promise.resolve(!0);if(this.splatMesh.getSplatCount()<=0)return this.splatRenderCount=0,Promise.resolve(!1);let h=0,d=0,p=!1,u=!1;if(r.set(0,0,-1).applyQuaternion(this.camera.quaternion),h=r.dot(s),d=o.copy(this.camera.position).sub(i).length(),!(t||this.splatMesh.dynamicMode||0!==a.length||(h<=.99&&(p=!0),d>=1&&(u=!0),p||u)))return Promise.resolve(!1);this.sortRunning=!0;let{splatRenderCount:m,shouldSortAll:A}=this.gatherSceneNodesForSort();A=A||c,this.splatRenderCount=m,e.copy(this.camera.matrixWorld).invert();const f=this.perspectiveCamera||this.camera;e.premultiply(f.projectionMatrix),this.splatMesh.dynamicMode||e.multiply(this.splatMesh.matrixWorld);let g=Promise.resolve(!0);return this.gpuAcceleratedSort&&(a.length<=1||a.length%2==0)&&(g=this.splatMesh.computeDistancesOnGPU(e,this.sortWorkerPrecomputedDistances)),g.then(()=>{if(0===a.length)if(this.splatMesh.dynamicMode||A)a.push(this.splatRenderCount);else{for(let e of l)if(h<e.angleThreshold){for(let t of e.sortFractions)a.push(Math.floor(this.splatRenderCount*t));break}a.push(this.splatRenderCount)}let t=Math.min(a.shift(),this.splatRenderCount);this.splatSortCount=t,n[0]=this.camera.position.x,n[1]=this.camera.position.y,n[2]=this.camera.position.z;const o={modelViewProj:e.elements,cameraPosition:n,splatRenderCount:this.splatRenderCount,splatSortCount:t,usePrecomputedDistances:this.gpuAcceleratedSort};return this.splatMesh.dynamicMode&&this.splatMesh.fillTransformsArray(this.sortWorkerTransforms),this.sharedMemoryForWorkers||(o.indexesToSort=this.sortWorkerIndexesToSort,o.transforms=this.sortWorkerTransforms,this.gpuAcceleratedSort&&(o.precomputedDistances=this.sortWorkerPrecomputedDistances)),this.sortPromise=new Promise(e=>{this.sortPromiseResolver=e}),this.preSortMessages.length>0&&(this.preSortMessages.forEach(e=>{this.sortWorker.postMessage(e)}),this.preSortMessages=[]),this.sortWorker.postMessage({sort:o}),0===a.length&&(i.copy(this.camera.position),s.copy(r)),!0}),g}}();gatherSceneNodesForSort=function(){const e=[];let n=null;const s=new t.Vector3,r=new t.Vector3,i=new t.Vector3,o=new t.Matrix4,a=new t.Matrix4,l=new t.Matrix4,c=new t.Vector3,h=new t.Vector3(0,0,-1),d=new t.Vector3,p=e=>d.copy(e.max).sub(e.min).length();return function(d=!1){this.getRenderDimensions(c);const u=c.y/2/Math.tan(this.camera.fov/2*t.MathUtils.DEG2RAD),m=Math.atan(c.x/2/u),A=Math.atan(c.y/2/u),f=Math.cos(m),g=Math.cos(A),S=this.splatMesh.getSplatTree();if(S){a.copy(this.camera.matrixWorld).invert(),this.splatMesh.dynamicMode||a.multiply(this.splatMesh.matrixWorld);let t=0,n=0;for(let u=0;u<S.subTrees.length;u++){const c=S.subTrees[u];o.copy(a),this.splatMesh.dynamicMode&&(this.splatMesh.getSceneTransform(u,l),o.multiply(l));const m=c.nodesWithIndexes.length;for(let a=0;a<m;a++){const l=c.nodesWithIndexes[a];if(!l.data||!l.data.indexes||0===l.data.indexes.length)continue;i.copy(l.center).applyMatrix4(o);const u=i.length();i.normalize(),s.copy(i).setX(0).normalize(),r.copy(i).setY(0).normalize();const m=h.dot(r),A=h.dot(s),S=p(l);!d&&(m<f-.6||A<g-.6)&&u>S||(n+=l.data.indexes.length,e[t]=l,l.data.distanceToNode=u,t++)}}e.length=t,e.sort((e,t)=>e.data.distanceToNode<t.data.distanceToNode?-1:1);let c=n*T.BytesPerInt;for(let s=0;s<t;s++){const t=e[s],n=t.data.indexes.length,r=n*T.BytesPerInt;new Uint32Array(this.sortWorkerIndexesToSort.buffer,c-r,n).set(t.data.indexes),c-=r}return{splatRenderCount:n,shouldSortAll:!1}}{const e=this.splatMesh.getSplatCount();if(!n||n.length!==e){n=new Uint32Array(e);for(let t=0;t<e;t++)n[t]=t}return this.sortWorkerIndexesToSort.set(n),{splatRenderCount:e,shouldSortAll:!0}}}}();getSplatMesh(){return this.splatMesh}getSplatScene(e){return this.splatMesh.getScene(e)}getSceneCount(){return this.splatMesh.getSceneCount()}isMobile(){return navigator.userAgent.includes("Mobi")}}class Hn extends t.Group{constructor(e={}){super(),e.selfDrivenMode=!1,e.useBuiltInControls=!1,e.rootElement=null,e.dropInMode=!0,e.camera=void 0,e.renderer=void 0,this.viewer=new Pn(e),this.splatMesh=null,this.updateSplatMesh(),this.callbackMesh=Hn.createCallbackMesh(),this.add(this.callbackMesh),this.callbackMesh.onBeforeRender=Hn.onBeforeRender.bind(this,this.viewer),this.viewer.onSplatMeshChanged(()=>{this.updateSplatMesh()})}updateSplatMesh(){this.splatMesh!==this.viewer.splatMesh&&(this.splatMesh&&this.remove(this.splatMesh),this.splatMesh=this.viewer.splatMesh,this.add(this.viewer.splatMesh))}addSplatScene(e,t={}){return!1!==t.showLoadingUI&&(t.showLoadingUI=!0),this.viewer.addSplatScene(e,t)}addSplatScenes(e,t){return!1!==t&&(t=!0),this.viewer.addSplatScenes(e,t)}getSplatScene(e){return this.viewer.getSplatScene(e)}removeSplatScene(e,t=!0){return this.viewer.removeSplatScene(e,t)}removeSplatScenes(e,t=!0){return this.viewer.removeSplatScenes(e,t)}getSceneCount(){return this.viewer.getSceneCount()}setActiveSphericalHarmonicsDegrees(e){this.viewer.setActiveSphericalHarmonicsDegrees(e)}async dispose(){return await this.viewer.dispose()}static onBeforeRender(e,t,n,s){e.update(t,s)}static createCallbackMesh(){const e=new t.SphereGeometry(1,8,8),n=new t.MeshBasicMaterial;n.colorWrite=!1,n.depthWrite=!1;const s=new t.Mesh(e,n);return s.frustumCulled=!1,s}}export{Hn as D};
