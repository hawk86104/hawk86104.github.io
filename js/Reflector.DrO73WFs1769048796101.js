import{importShared as e}from"./3d-tiles-renderer.DoRCwQO21769048796101.js";const{Color:t,Matrix4:r,Mesh:n,PerspectiveCamera:a,Plane:o,ShaderMaterial:i,UniformsUtils:l,Vector3:s,Vector4:d,WebGLRenderTarget:c,HalfFloatType:m}=await e("three");class u extends n{constructor(e,n={}){super(e),this.isReflector=!0,this.type="Reflector",this.forceUpdate=!1,this.camera=new a;const p=this,f=void 0!==n.color?new t(n.color):new t(8355711),v=n.textureWidth||512,x=n.textureHeight||512,b=n.clipBias||0,h=n.shader||u.ReflectorShader,g=void 0!==n.multisample?n.multisample:4,M=new o,w=new s,y=new s,R=new s,U=new r,S=new s(0,0,-1),W=new d,_=new s,j=new s,P=new d,D=new r,O=this.camera,T=new c(v,x,{samples:g,type:m}),C=new i({name:void 0!==h.name?h.name:"unspecified",uniforms:l.clone(h.uniforms),fragmentShader:h.fragmentShader,vertexShader:h.vertexShader});C.uniforms.tDiffuse.value=T.texture,C.uniforms.color.value=f,C.uniforms.textureMatrix.value=D,this.material=C,this.onBeforeRender=function(e,t,r){y.setFromMatrixPosition(p.matrixWorld),R.setFromMatrixPosition(r.matrixWorld),U.extractRotation(p.matrixWorld),w.set(0,0,1),w.applyMatrix4(U),_.subVectors(y,R);if(!0===_.dot(w)>0&&!1===this.forceUpdate)return;_.reflect(w).negate(),_.add(y),U.extractRotation(r.matrixWorld),S.set(0,0,-1),S.applyMatrix4(U),S.add(R),j.subVectors(y,S),j.reflect(w).negate(),j.add(y),O.position.copy(_),O.up.set(0,1,0),O.up.applyMatrix4(U),O.up.reflect(w),O.lookAt(j),O.far=r.far,O.updateMatrixWorld(),O.projectionMatrix.copy(r.projectionMatrix),D.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),D.multiply(O.projectionMatrix),D.multiply(O.matrixWorldInverse),D.multiply(p.matrixWorld),M.setFromNormalAndCoplanarPoint(w,y),M.applyMatrix4(O.matrixWorldInverse),W.set(M.normal.x,M.normal.y,M.normal.z,M.constant);const n=O.projectionMatrix;P.x=(Math.sign(W.x)+n.elements[8])/n.elements[0],P.y=(Math.sign(W.y)+n.elements[9])/n.elements[5],P.z=-1,P.w=(1+n.elements[10])/n.elements[14],W.multiplyScalar(2/W.dot(P)),n.elements[2]=W.x,n.elements[6]=W.y,n.elements[10]=W.z+1-b,n.elements[14]=W.w,p.visible=!1;const a=e.getRenderTarget(),o=e.xr.enabled,i=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(T),e.state.buffers.depth.setMask(!0),!1===e.autoClear&&e.clear(),e.render(t,O),e.xr.enabled=o,e.shadowMap.autoUpdate=i,e.setRenderTarget(a);const l=r.viewport;void 0!==l&&e.state.viewport(l),p.visible=!0,this.forceUpdate=!1},this.getRenderTarget=function(){return T},this.dispose=function(){T.dispose(),p.material.dispose()}}}u.ReflectorShader={name:"ReflectorShader",uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}",fragmentShader:"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}"};export{u as Reflector};
