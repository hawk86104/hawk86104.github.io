import{ag as n,ar as e,au as t,bo as a,A as i,c2 as o,aE as r,bN as c,C as s,b as l,V as m,a as _,t as d,i as f,M as v,ah as p}from"./three.CtgP63ME1758259351508.js";import{D as u}from"./glsl-tokenizer.BMVmBPoE1758259351508.js";import{T as x}from"./glsl-token-descope.4V2_7q6C1758259351508.js";import{K as y}from"./glsl-token-string.BBIN0iOh1758259351508.js";import{A as h}from"./glsl-token-functions.7xgp6R6C1758259351508.js";const g="csm_DiffuseColor",z="csm_Roughness",S="csm_Metalness",b="csm_Emissive",M="csm_AO",P="csm_Bump",A="csm_FragNormal",w="csm_Clearcoat",$="csm_ClearcoatRoughness",E="csm_ClearcoatNormal",I="csm_Transmission",C="csm_Thickness",T="csm_Iridescence",R="csm_PointSize",N="csm_FragColor",K="csm_DepthAlpha",D="csm_UnlitFac",F="csm_Position",O="csm_PositionRaw",L="csm_Normal",j={[`${F}`]:"*",[`${O}`]:"*",[`${L}`]:"*",[`${K}`]:"*",[`${R}`]:["PointsMaterial"],[`${g}`]:"*",[`${N}`]:"*",[`${A}`]:"*",[`${D}`]:"*",[`${b}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${z}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${S}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${T}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${M}`]:["MeshStandardMaterial","MeshPhysicalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial"],[`${P}`]:["MeshLambertMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MeshToonMaterial","ShadowMaterial"],[`${w}`]:["MeshPhysicalMaterial"],[`${$}`]:["MeshPhysicalMaterial"],[`${E}`]:["MeshPhysicalMaterial"],[`${I}`]:["MeshPhysicalMaterial"],[`${C}`]:["MeshPhysicalMaterial"]},H={"*":{"#include <lights_physical_fragment>":e.lights_physical_fragment,"#include <transmission_fragment>":e.transmission_fragment},[`${L}`]:{"#include <beginnormal_vertex>":`\n    vec3 objectNormal = ${L};\n    #ifdef USE_TANGENT\n\t    vec3 objectTangent = vec3( tangent.xyz );\n    #endif\n    `},[`${F}`]:{"#include <begin_vertex>":`\n    vec3 transformed = ${F};\n  `},[`${O}`]:{"#include <project_vertex>":`\n    #include <project_vertex>\n    gl_Position = ${O};\n  `},[`${R}`]:{"gl_PointSize = size;":`\n    gl_PointSize = ${R};\n    `},[`${g}`]:{"#include <color_fragment>":`\n    #include <color_fragment>\n    diffuseColor = ${g};\n  `},[`${N}`]:{"#include <opaque_fragment>":`\n    #include <opaque_fragment>\n    gl_FragColor = mix(gl_FragColor, ${N}, ${D});\n  `},[`${b}`]:{"vec3 totalEmissiveRadiance = emissive;":`\n    vec3 totalEmissiveRadiance = ${b};\n    `},[`${z}`]:{"#include <roughnessmap_fragment>":`\n    #include <roughnessmap_fragment>\n    roughnessFactor = ${z};\n    `},[`${S}`]:{"#include <metalnessmap_fragment>":`\n    #include <metalnessmap_fragment>\n    metalnessFactor = ${S};\n    `},[`${M}`]:{"#include <aomap_fragment>":`\n    #include <aomap_fragment>\n    reflectedLight.indirectDiffuse *= 1. - ${M};\n    `},[`${P}`]:{"#include <normal_fragment_maps>":`\n    #include <normal_fragment_maps>\n\n    vec3 csm_internal_orthogonal = ${P} - (dot(${P}, normal) * normal);\n    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;\n    normal = normalize(normal - csm_internal_projectedbump);\n    `},[`${A}`]:{"#include <normal_fragment_maps>":`\n      #include <normal_fragment_maps>\n      normal = ${A};\n    `},[`${K}`]:{"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );":`\n      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * 1.0 - ${K} );\n    `,"gl_FragColor = packDepthToRGBA( fragCoordZ );":`\n      if(${K} < 1.0) discard;\n      gl_FragColor = packDepthToRGBA( dist );\n    `,"gl_FragColor = packDepthToRGBA( dist );":`\n      if(${K} < 1.0) discard;\n      gl_FragColor = packDepthToRGBA( dist );\n    `},[`${w}`]:{"material.clearcoat = clearcoat;":`material.clearcoat = ${w};`},[`${$}`]:{"material.clearcoatRoughness = clearcoatRoughness;":`material.clearcoatRoughness = ${$};`},[`${E}`]:{"#include <clearcoat_normal_fragment_begin>":"\n      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);\n      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;\n      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);\n    "},[`${I}`]:{"material.transmission = transmission;":`\n      material.transmission = ${I};\n    `},[`${C}`]:{"material.thickness = thickness;":`\n      material.thickness = ${C};\n    `},[`${T}`]:{"material.iridescence = iridescence;":`\n      material.iridescence = ${T};\n    `}},B={clearcoat:[w,E,$],transmission:[I],iridescence:[T]};function k(n){return n.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g,"")}class V extends n{constructor({baseMaterial:n,vertexShader:e,fragmentShader:t,uniforms:a,patchMap:i,cacheKey:o,...r}){if(!n)throw new Error("CustomShaderMaterial: baseMaterial is required.");let c;if(function(e){try{new e}catch(n){if(n.message.indexOf("is not a constructor")>=0)return!1}return!0}(n)){const e=0===Object.keys(r).length;c=new n(e?void 0:r)}else c=n,Object.assign(c,r);if(["ShaderMaterial","RawShaderMaterial"].includes(c.type))throw new Error(`CustomShaderMaterial does not support ${c.type} as a base material.`);super(),this.uniforms={},this.vertexShader="",this.fragmentShader="";const s=c;s.name=`CustomShaderMaterial<${c.name||c.type}>`,s.update=this.update,s.__csm={prevOnBeforeCompile:c.onBeforeCompile,baseMaterial:c,vertexShader:e,fragmentShader:t,uniforms:a,patchMap:i,cacheKey:o};const l={...s.uniforms||{},...a||{}};s.uniforms=this.uniforms=l,s.vertexShader=this.vertexShader=e||"",s.fragmentShader=this.fragmentShader=t||"",s.update({fragmentShader:s.fragmentShader,vertexShader:s.vertexShader,uniforms:s.uniforms,patchMap:i,cacheKey:o}),Object.assign(this,s);const m=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(s));for(const _ in m){const n=m[_];(n.get||n.set)&&Object.defineProperty(this,_,n)}return Object.defineProperty(this,"type",{get:()=>c.type,set(n){c.type=n}}),this}update({fragmentShader:n,vertexShader:e,uniforms:t,cacheKey:a,patchMap:i}){const o=k(e||""),r=k(n||""),c=this;t&&(c.uniforms=t),e&&(c.vertexShader=e),n&&(c.fragmentShader=n),Object.entries(B).forEach((([n,e])=>{for(const t in e){const a=e[t];(r&&r.includes(a)||o&&o.includes(a))&&(c[n]||(c[n]=1))}}));const s=c.__csm.prevOnBeforeCompile,l=(n,e,t)=>{let a,i="";if(e){const n=e.search(/void\s+main\s*\(\s*\)\s*{/);if(-1!==n){i=e.slice(0,n);let t=0,o=-1;for(let a=n;a<e.length;a++)if("{"===e[a]&&t++,"}"===e[a]&&(t--,0===t)){o=a;break}if(-1!==o){const t=e.slice(n,o+1);a=t.slice(t.indexOf("{")+1,-1)}}else i=e}if(t&&e&&e.includes(N)&&a&&(a="csm_UnlitFac = 1.0;\n"+a),n.includes("//~CSM_DEFAULTS")){const e=(n=n.replace("void main() {",`\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\n  \n          ${i}\n          \n          void main() {\n          `)).lastIndexOf("//~CSM_MAIN_END");if(-1!==e){const t=`\n            ${a?`${a}`:""}\n            //~CSM_MAIN_END\n          `;n=n.slice(0,e)+t+n.slice(e)}}else{const e=/void\s*main\s*\(\s*\)\s*{/gm;n=n.replace(e,`\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\n  \n          //~CSM_DEFAULTS\n          \n    varying mat4 csm_internal_vModelViewMatrix;\n\n          \n    \n#ifdef IS_VERTEX\n    vec3 csm_Position;\n    vec4 csm_PositionRaw;\n    vec3 csm_Normal;\n\n    // csm_PointSize\n    #ifdef IS_POINTSMATERIAL\n        float csm_PointSize;\n    #endif\n#else\n    vec4 csm_DiffuseColor;\n    vec4 csm_FragColor;\n    float csm_UnlitFac;\n\n    // csm_Emissive, csm_Roughness, csm_Metalness\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\n        vec3 csm_Emissive;\n        float csm_Roughness;\n        float csm_Metalness;\n        float csm_Iridescence;\n        \n        #if defined IS_MESHPHYSICALMATERIAL\n            float csm_Clearcoat;\n            float csm_ClearcoatRoughness;\n            vec3 csm_ClearcoatNormal;\n            float csm_Transmission;\n            float csm_Thickness;\n        #endif\n    #endif\n\n    // csm_AO\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\n        float csm_AO;\n    #endif\n\n    // csm_Bump\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \n        vec3 csm_Bump;\n        vec3 csm_FragNormal;\n    #endif\n\n    float csm_DepthAlpha;\n#endif\n\n  \n          ${i}\n          \n          void main() {\n            {\n              \n\n#ifdef IS_VERTEX\n    // csm_Position & csm_PositionRaw\n    #ifdef IS_UNKNOWN\n        csm_Position = vec3(0.0);\n        csm_PositionRaw = vec4(0.0);\n        csm_Normal = vec3(0.0);\n    #else\n        csm_Position = position;\n        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n        csm_Normal = normal;\n    #endif\n\n    // csm_PointSize\n    #ifdef IS_POINTSMATERIAL\n        csm_PointSize = size;\n    #endif\n#else\n    csm_UnlitFac = 0.0;\n\n    // csm_DiffuseColor & csm_FragColor\n    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL\n        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\n        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n    #else\n        #ifdef USE_MAP\n            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);\n\n            #ifdef DECODE_VIDEO_TEXTURE\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\n            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);\n            #endif\n\n            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\n            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\n        #else\n            csm_DiffuseColor = vec4(diffuse, opacity);\n            csm_FragColor = vec4(diffuse, opacity);\n        #endif\n    #endif\n\n    // csm_Emissive, csm_Roughness, csm_Metalness\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\n        csm_Emissive = emissive;\n        csm_Roughness = roughness;\n        csm_Metalness = metalness;\n\n        #ifdef USE_IRIDESCENCE\n            csm_Iridescence = iridescence;\n        #else\n            csm_Iridescence = 0.0;\n        #endif\n\n        #if defined IS_MESHPHYSICALMATERIAL\n            #ifdef USE_CLEARCOAT\n                csm_Clearcoat = clearcoat;\n                csm_ClearcoatRoughness = clearcoatRoughness;\n            #else\n                csm_Clearcoat = 0.0;\n                csm_ClearcoatRoughness = 0.0;\n            #endif\n\n            #ifdef USE_TRANSMISSION\n                csm_Transmission = transmission;\n                csm_Thickness = thickness;\n            #else\n                csm_Transmission = 0.0;\n                csm_Thickness = 0.0;\n            #endif\n        #endif\n    #endif\n\n    // csm_AO\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\n        csm_AO = 0.0;\n    #endif\n\n    // csm_Bump\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \n        csm_Bump = vec3(0.0);\n        #ifdef FLAT_SHADED\n            vec3 fdx = dFdx( vViewPosition );\n            vec3 fdy = dFdy( vViewPosition );\n            csm_FragNormal = normalize( cross( fdx, fdy ) );\n        #else\n            csm_FragNormal = normalize(vNormal);\n            #ifdef DOUBLE_SIDED\n                csm_FragNormal *= gl_FrontFacing ? 1.0 : - 1.0;\n            #endif\n        #endif\n    #endif\n\n    csm_DepthAlpha = 1.0;\n#endif\n\n            }\n            ${t?"\n    \n":"\n    csm_internal_vModelViewMatrix = modelViewMatrix;\n"}\n\n            ${a?`${a}`:""}\n            //~CSM_MAIN_END\n          `)}return n};c.onBeforeCompile=(n,e)=>{null==s||s(n,e);const a=i||{},m=c.type,_=m?`#define IS_${m.toUpperCase()};\n`:"#define IS_UNKNOWN;\n";n.vertexShader=_+"#define IS_VERTEX\n"+n.vertexShader,n.fragmentShader=_+"#define IS_FRAGMENT\n"+n.fragmentShader;const d=e=>{for(const t in e){const a="*"===t||o&&o.includes(t);if("*"===t||r&&r.includes(t)||a){const a=j[t];if(a&&"*"!==a&&(Array.isArray(a)?!a.includes(m):a!==m))return void console.error(`CustomShaderMaterial: ${t} is not available in ${m}. Shader cannot compile.`);const i=e[t];for(const e in i){const t=i[e];if("object"==typeof t){const a=t.type,i=t.value;"fs"===a?n.fragmentShader=n.fragmentShader.replace(e,i):"vs"===a&&(n.vertexShader=n.vertexShader.replace(e,i))}else t&&(n.vertexShader=n.vertexShader.replace(e,t),n.fragmentShader=n.fragmentShader.replace(e,t))}}}};d(H),d(a),n.vertexShader=l(n.vertexShader,o,!1),n.fragmentShader=l(n.fragmentShader,r,!0),t&&(n.uniforms={...n.uniforms,...c.uniforms}),c.uniforms=n.uniforms};const m=c.customProgramCacheKey;c.customProgramCacheKey=()=>((null==a?void 0:a())||function(n){let e=0;for(let t=0;t<n.length;t++)e=n.charCodeAt(t)+(e<<6)+(e<<16)-e;return String(e>>>0)}((o||"")+(r||"")))+(null==m?void 0:m.call(c)),c.needsUpdate=!0}clone(){const n=this;return new n.constructor({baseMaterial:n.__csm.baseMaterial.clone(),vertexShader:n.__csm.vertexShader,fragmentShader:n.__csm.fragmentShader,uniforms:n.__csm.uniforms,patchMap:n.__csm.patchMap,cacheKey:n.__csm.cacheKey})}}const U={normal:"normal",add:"add",subtract:"subtract",multiply:"multiply",lighten:"lighten",darken:"darken",divide:"divide",overlay:"overlay",screen:"screen",softlight:"softlight",negation:"negation",reflect:"reflect"},q={perlin:"perlin",simplex:"simplex",cell:"cell",curl:"curl",white:"white"},G={local:"local",world:"world",uv:"uv"},W={phong:c,physical:r,toon:o,basic:i,lambert:a,standard:t};function Y(n){return"string"==typeof n?new s(n).convertLinearToSRGB():n}function X(n){switch(n){case"alpha":return{min:0,max:1};case"scale":return{min:0};case"map":return{image:void 0};default:return{}}}function Z(n){return n instanceof m||n instanceof _||n instanceof d||n instanceof f||n instanceof v}function J(n){return Z(n)?n.toArray():n instanceof s?"#"+n.clone().convertLinearToSRGB().getHexString():n instanceof p?n.image.src:n}class Q{constructor(n,e,t){this.uuid=l.generateUUID().replace(/-/g,"_"),this.name="LayerMaterial",this.mode="normal",this.visible=!0;const a=Object.getOwnPropertyNames(n).filter((n=>n.startsWith("u_"))).reduce(((e,t)=>{var a;let i=null==(a=Object.getOwnPropertyDescriptor(n,t))?void 0:a.value;return(Z(i)||i instanceof s)&&(i=i.clone()),{...e,[t.slice(1)]:i}}),{});for(const o in a){const n=o.split("_")[1];void 0!==(null==e?void 0:e[n])&&(a[o]=e[n])}e&&Object.keys(e).map((n=>{void 0!==e[n]&&(this[n]=e[n])})),this.uniforms={},this.schema=[];const i={};Object.keys(a).map((n=>{const e=n.split("_")[1];this.uniforms[`u_${this.uuid}_${e}`]={value:Y(a[n])},this.schema.push({value:a[n],label:e}),i[e]={set:n=>{this.uniforms[`u_${this.uuid}_${e}`].value=Y(n)},get:()=>this.uniforms[`u_${this.uuid}_${e}`].value}})),null!=e&&e.name&&(this.name=e.name),null!=e&&e.mode&&(this.mode=e.mode),null!=e&&e.visible&&(this.visible=e.visible),Object.defineProperties(this,i),this.vertexShader="",this.fragmentShader="",this.vertexVariables="",this.fragmentVariables="",this.onParse=t,this.buildShaders(n),this.schema.push({value:this.mode,label:"mode",options:Object.values(U)}),this.schema.push({value:this.visible,label:"visible"})}buildShaders(n){var e;const t=Object.getOwnPropertyNames(n).filter((n=>"fragmentShader"===n||"vertexShader"===n)).reduce(((e,t)=>{var a;return{...e,[t]:null==(a=Object.getOwnPropertyDescriptor(n,t))?void 0:a.value}}),{}),a={vert:u(t.vertexShader||""),frag:u(t.fragmentShader||"")},i={vert:x(a.vert,this.renameTokens.bind(this)),frag:x(a.frag,this.renameTokens.bind(this))},o={vert:h(i.vert),frag:h(i.frag)},r=o.vert.map((n=>n.name)).indexOf("main"),c=o.frag.map((n=>n.name)).indexOf("main"),s={vert:r>=0?y(i.vert.slice(0,o.vert[r].outer[0])):"",frag:c>=0?y(i.frag.slice(0,o.frag[c].outer[0])):""},l={vert:r>=0?this.getShaderFromIndex(i.vert,o.vert[r].body):"",frag:c>=0?this.getShaderFromIndex(i.frag,o.frag[c].body):""};this.vertexShader=this.processFinal(l.vert,!0),this.fragmentShader=this.processFinal(l.frag),this.vertexVariables=s.vert,this.fragmentVariables=s.frag,null==(e=this.onParse)||e.call(this,this),this.schema=this.schema.filter(((n,e)=>{const t=n.label;return e===this.schema.findIndex((n=>n.label===t))}))}renameTokens(n){if(n.startsWith("u_")){const e=n.slice(2);return`u_${this.uuid}_${e}`}if(n.startsWith("v_")){const e=n.slice(2);return`v_${this.uuid}_${e}`}if(n.startsWith("f_")){const e=n.slice(2);return`f_${this.uuid}_${e}`}return n}processFinal(n,e){const t=n.replace(/\sf_/gm,` f_${this.uuid}_`).replace(/\(f_/gm,`(f_${this.uuid}_`),a=t.match(/^.*return.*$/gm);let i=t.replace(/^.*return.*$/gm,"");if(null!=a&&a[0]){const n=a[0].replace("return","").trim().replace(";",""),t=this.getBlendMode(n,"lamina_finalColor");i+=e?`lamina_finalPosition = ${n};`:`lamina_finalColor = ${t};`}return i}getShaderFromIndex(n,e){return y(n.slice(e[0],e[1]))}getBlendMode(n,e){switch(this.mode){default:case"normal":return`lamina_blend_alpha(${e}, ${n}, ${n}.a)`;case"add":return`lamina_blend_add(${e}, ${n}, ${n}.a)`;case"subtract":return`lamina_blend_subtract(${e}, ${n}, ${n}.a)`;case"multiply":return`lamina_blend_multiply(${e}, ${n}, ${n}.a)`;case"lighten":return`lamina_blend_lighten(${e}, ${n}, ${n}.a)`;case"darken":return`lamina_blend_darken(${e}, ${n}, ${n}.a)`;case"divide":return`lamina_blend_divide(${e}, ${n}, ${n}.a)`;case"overlay":return`lamina_blend_overlay(${e}, ${n}, ${n}.a)`;case"screen":return`lamina_blend_screen(${e}, ${n}, ${n}.a)`;case"softlight":return`lamina_blend_softlight(${e}, ${n}, ${n}.a)`;case"reflect":return`lamina_blend_reflect(${e}, ${n}, ${n}.a)`;case"negation":return`lamina_blend_negation(${e}, ${n}, ${n}.a)`}}getSchema(){return this.schema.map((({label:n,options:e,...t})=>({label:n,options:e,...X(n),...t,value:J(this[n])})))}serialize(){const n=this.constructor.name.split("$")[0];let e=Object.keys(this);e=e.filter((n=>!["uuid","uniforms","schema","fragmentShader","vertexShader","fragmentVariables","vertexVariables","attribs","events","__r3f","onParse"].includes(n)));const t={};e.forEach((n=>{t[n]=this[n]}));const a={};for(const i in this.uniforms){a[i.replace(`u_${this.uuid}_`,"")]=J(this.uniforms[i].value)}return{constructor:n,properties:{...a,...t}}}}const nn=class n extends Q{constructor(e){super(n,{name:"Color",...e})}};nn.u_color="red",nn.u_alpha=1,nn.fragmentShader="   \n    uniform vec3 u_color;\n    uniform float u_alpha;\n\n    void main() {\n      return vec4(u_color, u_alpha);\n    }\n  ";let en=nn;const tn=class n extends Q{constructor(e){super(n,{name:"Depth",...e},(e=>{e.schema.push({value:e.mapping,label:"mapping",options:["vector","world","camera"]});const t=n.getMapping(e.uuid,e.mapping);e.fragmentShader=e.fragmentShader.replace("lamina_mapping_template",t)})),this.mapping="vector"}static getMapping(n,e){switch(e){default:case"vector":return`length(v_${n}_worldPosition - u_${n}_origin)`;case"world":return`length(v_${n}_position - vec3(0.))`;case"camera":return`length(v_${n}_worldPosition - cameraPosition)`}}};tn.u_near=2,tn.u_far=10,tn.u_origin=new m(0,0,0),tn.u_colorA="white",tn.u_colorB="black",tn.u_alpha=1,tn.vertexShader="\n  varying vec3 v_worldPosition;\n  varying vec3 v_position;\n\n  void main() {\n    v_worldPosition = (vec4(position, 1.0) * modelMatrix).xyz;\n    v_position = position;\n  }\n  ",tn.fragmentShader="   \n    uniform float u_alpha;\n    uniform float u_near;\n    uniform float u_far;\n    uniform float u_isVector;\n    uniform vec3 u_origin;\n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n\n    varying vec3 v_worldPosition;\n    varying vec3 v_position;\n\n    void main() {\n      float f_dist = lamina_mapping_template;\n      float f_depth = (f_dist - u_near) / (u_far - u_near);\n\t\t\tvec3 f_depthColor =  mix(u_colorB, u_colorA, 1.0 - clamp(f_depth, 0., 1.));\n  \n  \n      return vec4(f_depthColor, u_alpha);\n    }\n  ";let an=tn;const on=class n extends Q{constructor(e){super(n,{name:"Displace",...e},(e=>{e.schema.push({value:e.type,label:"type",options:Object.values(q)}),e.schema.push({value:e.mapping,label:"mapping",options:Object.values(G)});const t=n.getNoiseFunction(e.type),a=n.getMapping(e.mapping);e.vertexVariables=e.vertexVariables.replace("lamina_mapping_template",a),e.vertexVariables=e.vertexVariables.replace("lamina_noise_template",t)})),this.type="perlin",this.mapping="local"}static getNoiseFunction(n){switch(n){default:case"perlin":return"lamina_noise_perlin";case"simplex":return"lamina_noise_simplex";case"cell":return"lamina_noise_worley";case"white":return"lamina_noise_white";case"curl":return"lamina_noise_swirl"}}static getMapping(n){switch(n){default:case"local":return"p";case"world":return"(modelMatrix * vec4(p,1.0)).xyz";case"uv":return"vec3(uv, 0.)"}}};on.u_strength=1,on.u_scale=1,on.u_offset=new m(0,0,0),on.vertexShader="\n       \n      uniform float u_strength;\n      uniform float u_scale;\n      uniform vec3 u_offset;\n\n      vec3 displace(vec3 p) {\n\t\t\t\tvec3 f_position = lamina_mapping_template;\n        float f_n = lamina_noise_template((f_position + u_offset) * u_scale) * u_strength;\n        vec3 f_newPosition = p + (f_n * normal);\n\n\t\t\t\treturn f_newPosition;\n      }\n\n      \n\t\t\tvec3 orthogonal(vec3 v) {\n  \t\t  return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n  \t\t  : vec3(0.0, -v.z, v.y));\n  \t\t}\n  \t\tvec3 recalcNormals(vec3 newPos) {\n  \t\t  float offset = 0.001;\n  \t\t  vec3 tangent = orthogonal(normal);\n  \t\t  vec3 bitangent = normalize(cross(normal, tangent));\n  \t\t  vec3 neighbour1 = position + tangent * offset;\n  \t\t  vec3 neighbour2 = position + bitangent * offset;\n  \t\t  vec3 displacedNeighbour1 = displace(neighbour1);\n  \t\t  vec3 displacedNeighbour2 = displace(neighbour2);\n  \t\t  vec3 displacedTangent = displacedNeighbour1 - newPos;\n  \t\t  vec3 displacedBitangent = displacedNeighbour2 - newPos;\n  \t\t  return normalize(cross(displacedTangent, displacedBitangent));\n  \t\t}\n  \n  \n      void main() {\n       \n\t\t\t\tvec3 f_newPosition = displace(position);\n        lamina_finalNormal = recalcNormals(f_newPosition);\n\n        return f_newPosition;\n      }\n    ";const rn=class n extends Q{constructor(e){super(n,{name:"Fresnel",...e})}};rn.u_color="white",rn.u_alpha=1,rn.u_bias=0,rn.u_intensity=1,rn.u_power=2,rn.u_factor=1,rn.vertexShader="\n    varying vec3 v_worldPosition;\n    varying vec3 v_worldNormal;\n\n    void main() {\n        v_worldPosition = vec3(-viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2]);\n        v_worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n        \n    }\n  ",rn.fragmentShader="   \n    uniform vec3 u_color;\n    uniform float u_alpha;\n    uniform float u_bias;\n    uniform float u_intensity;\n    uniform float u_power;\n    uniform float u_factor;\n\n    varying vec3 v_worldPosition;\n    varying vec3 v_worldNormal;\n\n    void main() {\n        float f_a = (u_factor  + dot(v_worldPosition, v_worldNormal));\n        float f_fresnel = u_bias + u_intensity * pow(abs(f_a), u_power);\n\n        f_fresnel = clamp(f_fresnel, 0.0, 1.0);\n        return vec4(f_fresnel * u_color, u_alpha);\n    }\n  ";const cn=class n extends Q{constructor(e){super(n,{name:"Gradient",...e},(e=>{e.schema.push({value:e.axes,label:"axes",options:["x","y","z"]}),e.schema.push({value:e.mapping,label:"mapping",options:Object.values(G)});const t=n.getMapping(e.mapping);e.vertexShader=e.vertexShader.replace("lamina_mapping_template",t||"local"),e.fragmentShader=e.fragmentShader.replace("axes_template",e.axes||"x")})),this.axes="x",this.mapping="local"}static getMapping(n){switch(n){default:case"local":return"position";case"world":return"(modelMatrix * vec4(position,1.0)).xyz";case"uv":return"vec3(uv, 0.)"}}};cn.u_colorA="white",cn.u_colorB="black",cn.u_alpha=1,cn.u_start=1,cn.u_end=-1,cn.u_contrast=1,cn.vertexShader="\n\t\tvarying vec3 v_position;\n\n\t\tvod main() {\n      v_position = lamina_mapping_template;\n\t\t}\n  ",cn.fragmentShader="   \n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n    uniform vec3 u_axis;\n    uniform float u_alpha;\n    uniform float u_start;\n    uniform float u_end;\n    uniform float u_contrast;\n\n\t\tvarying vec3 v_position;\n\n    void main() {\n\n      float f_step = smoothstep(u_start, u_end, v_position.axes_template * u_contrast);\n      vec3 f_color = mix(u_colorA, u_colorB, f_step);\n\n      return vec4(f_color, u_alpha);\n    }\n  ";const sn=class n extends Q{constructor(e){super(n,{name:"Matcap",...e})}};sn.u_alpha=1,sn.u_map=void 0,sn.vertexShader="\n    varying vec3 v_position;\n    varying vec3 v_normal;\n    \n    void main() {\n      v_position = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );\n      v_normal = normalize( normalMatrix * normal );\n    }\n    ",sn.fragmentShader=" \n\t\tuniform sampler2D u_map;  \n\t\tuniform float u_alpha;  \n\t\tvarying vec3 v_position;\n\t\tvarying vec3 v_normal;\n\n\t\t\n    void main() {\n\t\t\tvec3 f_r = reflect( v_position, v_normal );\n\t\t\tfloat f_m = 2. * sqrt( pow( f_r.x, 2. ) + pow( f_r.y, 2. ) + pow( f_r.z + 1., 2. ) );\n\t\t\tvec2 f_vN = f_r.xy / f_m + .5;\n\n\t\t\tvec3 f_base = texture2D(u_map, f_vN).rgb;\n\n      return vec4(f_base, u_alpha);\n    }\n  ";const ln=class n extends Q{constructor(e){super(n,{name:"noise",...e},(e=>{e.schema.push({value:e.type,label:"type",options:Object.values(q)}),e.schema.push({value:e.mapping,label:"mapping",options:Object.values(G)});const t=n.getNoiseFunction(e.type),a=n.getMapping(e.mapping);e.vertexShader=e.vertexShader.replace("lamina_mapping_template",a),e.fragmentShader=e.fragmentShader.replace("lamina_noise_template",t)})),this.type="perlin",this.mapping="local"}static getNoiseFunction(n){switch(n){default:case"perlin":return"lamina_noise_perlin";case"simplex":return"lamina_noise_simplex";case"cell":return"lamina_noise_worley";case"white":return"lamina_noise_white";case"curl":return"lamina_noise_swirl"}}static getMapping(n){switch(n){default:case"local":return"position";case"world":return"(modelMatrix * vec4(position,1.0)).xyz";case"uv":return"vec3(uv, 0.)"}}};ln.u_colorA="#666666",ln.u_colorB="#666666",ln.u_colorC="#FFFFFF",ln.u_colorD="#FFFFFF",ln.u_alpha=1,ln.u_scale=1,ln.u_offset=new m(0,0,0),ln.vertexShader="\n    varying vec3 v_position;\n\n    void main() {\n        v_position = lamina_mapping_template;\n    }\n  ",ln.fragmentShader="   \n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n    uniform vec3 u_colorC;\n    uniform vec3 u_colorD;\n    uniform vec3 u_offset;\n\n    uniform float u_alpha;\n    uniform float u_scale;\n\n    varying vec3 v_position;\n\n\n    void main() {\n        float f_n = lamina_noise_template((v_position + u_offset) * u_scale);\n\n        float f_step1 = 0.;\n        float f_step2 = 0.2;\n        float f_step3 = 0.6;\n        float f_step4 = 1.;\n\n        vec3 f_color = mix(u_colorA, u_colorB, smoothstep(f_step1, f_step2, f_n));\n        f_color = mix(f_color, u_colorC, smoothstep(f_step2, f_step3, f_n));\n        f_color = mix(f_color, u_colorD, smoothstep(f_step3, f_step4, f_n));\n\n        return vec4(f_color, u_alpha);\n    }\n  ";const mn=class n extends Q{constructor(e){super(n,{name:"Normal",...e})}};mn.u_alpha=1,mn.u_direction=new m(1,1,1),mn.vertexShader="   \n  varying vec3 v_normals; \n\n  void main() {\n    v_normals = normal;\n  }\n",mn.fragmentShader="   \n  \tuniform float u_alpha;\n  \tuniform vec3 u_color;\n  \tuniform vec3 u_direction;\n\n\t\tvarying vec3 v_normals;\n\n    void main() {\n\t\t\tvec3 f_normalColor = vec3(1.);\n      f_normalColor.x = v_normals.x * u_direction.x;\n      f_normalColor.y = v_normals.y * u_direction.y;\n      f_normalColor.z = v_normals.z * u_direction.z;\n\n      return vec4(f_normalColor, u_alpha);\n    }\n  ";const _n=class n extends Q{constructor(e){super(n,{name:"Texture",...e})}};_n.u_alpha=1,_n.u_map=void 0,_n.vertexShader="\n    varying vec2 v_uv;\n    \n    void main() {\n        v_uv = uv;\n    }\n    ",_n.fragmentShader=" \n\t\tuniform sampler2D u_map;  \n\t\tuniform float u_alpha;  \n\t\tvarying vec2 v_uv;\n\n    void main() {\n\t\t\tvec4 f_color = texture2D(u_map, v_uv);\n      return vec4(f_color.rgb, f_color.a * u_alpha);\n    }\n  ";const dn="\n\nfloat lamina_map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat lamina_normalize(float v) { return lamina_map(v, -1.0, 1.0, 0.0, 1.0); }\n",fn="\n\n// From: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n// Huge thanks to the creators of these algorithms\n\nfloat lamina_noise_mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 lamina_noise_mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 lamina_noise_perm(vec4 x){return lamina_noise_mod289(((x * 34.0) + 1.0) * x);}\nvec4 lamina_noise_permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nvec4 lamina_noise_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n\nfloat lamina_noise_white(vec2 p) {\n  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) *\n               (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\nfloat lamina_noise_white(vec3 p) {\n  return lamina_noise_white(p.xy);\n}\n\n\nvec3 lamina_noise_fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n\nfloat lamina_noise_perlin(vec3 P) {\n  vec3 Pi0 = floor(P);        // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P);        // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = lamina_noise_permute(lamina_noise_permute(ix) + iy);\n  vec4 ixy0 = lamina_noise_permute(ixy + iz0);\n  vec4 ixy1 = lamina_noise_permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n  vec4 norm0 = lamina_noise_taylorInvSqrt(\n      vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = lamina_noise_taylorInvSqrt(\n      vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = lamina_noise_fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111),\n                 fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return lamina_normalize(2.2 * n_xyz);\n}\n\nfloat lamina_noise_simplex(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  //  x0 = x0 - 0. + 0.0 * C\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n  // Permutations\n  i = mod(i, 289.0);\n  vec4 p = lamina_noise_permute(lamina_noise_permute(lamina_noise_permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +\n                             vec4(0.0, i1.y, i2.y, 1.0)) +\n                    i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  // Gradients\n  // ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0 / 7.0; // N=7\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  // Normalise gradients\n  vec4 norm =\n      lamina_noise_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m =\n      max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return lamina_normalize(42.0 *\n         dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))));\n}\n\nvec3 lamina_noise_simplex3(vec3 x) {\n  float s = lamina_noise_simplex(vec3(x));\n  float s1 = lamina_noise_simplex(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));\n  float s2 = lamina_noise_simplex(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));\n  vec3 c = vec3(s, s1, s2);\n  return c;\n}\n\nvec3 lamina_noise_curl(vec3 p) {\n  const float e = .1;\n  vec3 dx = vec3(e, 0.0, 0.0);\n  vec3 dy = vec3(0.0, e, 0.0);\n  vec3 dz = vec3(0.0, 0.0, e);\n\n  vec3 p_x0 = lamina_noise_simplex3(p - dx);\n  vec3 p_x1 = lamina_noise_simplex3(p + dx);\n  vec3 p_y0 = lamina_noise_simplex3(p - dy);\n  vec3 p_y1 = lamina_noise_simplex3(p + dy);\n  vec3 p_z0 = lamina_noise_simplex3(p - dz);\n  vec3 p_z1 = lamina_noise_simplex3(p + dz);\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / (2.0 * e);\n  return normalize(vec3(x, y, z) * divisor);\n}\n\nvec3 lamina_permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 lamina_dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\n// From: https://github.com/Erkaman/glsl-worley\nfloat lamina_noise_worley(vec3 P) {\n  float jitter = 1.;\n  bool manhattanDistance = false; \n\n  float K = 0.142857142857; // 1/7\n  float Ko = 0.428571428571; // 1/2-K/2\n  float  K2 = 0.020408163265306; // 1/(7*7)\n  float Kz = 0.166666666667; // 1/6\n  float Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = lamina_permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = lamina_permute(p + Pi.y - 1.0);\n\tvec3 p2 = lamina_permute(p + Pi.y);\n\tvec3 p3 = lamina_permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = lamina_permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = lamina_permute(p1 + Pi.z);\n\tvec3 p13 = lamina_permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = lamina_permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = lamina_permute(p2 + Pi.z);\n\tvec3 p23 = lamina_permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = lamina_permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = lamina_permute(p3 + Pi.z);\n\tvec3 p33 = lamina_permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = lamina_dist(dx11, dy11, dz11, manhattanDistance);\n\tvec3 d12 = lamina_dist(dx12, dy12, dz12, manhattanDistance);\n\tvec3 d13 = lamina_dist(dx13, dy13, dz13, manhattanDistance);\n\tvec3 d21 = lamina_dist(dx21, dy21, dz21, manhattanDistance);\n\tvec3 d22 = lamina_dist(dx22, dy22, dz22, manhattanDistance);\n\tvec3 d23 = lamina_dist(dx23, dy23, dz23, manhattanDistance);\n\tvec3 d31 = lamina_dist(dx31, dy31, dz31, manhattanDistance);\n\tvec3 d32 = lamina_dist(dx32, dy32, dz32, manhattanDistance);\n\tvec3 d33 = lamina_dist(dx33, dy33, dz33, manhattanDistance);\n\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\n  vec2 F = sqrt(d11.xy);\n\treturn F.x; // F1, F2\n\n}\n\nfloat lamina_noise_swirl(vec3 position) {\n    float scale = 0.1;\n    float freq = 4. * scale;\n    float t = 1.;\n\n    vec3 pos = (position * scale) + lamina_noise_curl(position * 7. * scale);\n\n    float worley1 = 1. - lamina_noise_worley((pos * (freq * 2.)) +  (t * 2.));\n    float worley2 = 1. - lamina_noise_worley((pos * (freq * 4.)) +  (t * 4.));\n    float worley3 = 1. - lamina_noise_worley((pos * (freq * 8.)) +  (t * 8.));\n    float worley4 = 1. - lamina_noise_worley((pos * (freq * 16.)) +  (t * 16.));\n    \n    float fbm1 = worley1 * .625 + worley2 * .25 + worley3 * .125;\n    float fbm2 = worley2 * .625 + worley3 * .25 + worley4 * .125;\n    float fbm3 = worley3 * .75 + worley4 * .25;\n\n    vec3 curlWorleyFbm = vec3(fbm1, fbm2, fbm3);\n    float curlWorley = curlWorleyFbm.r * .625 + curlWorleyFbm.g * .25 + \n        curlWorleyFbm.b * .125;\n\n    return curlWorley;\n}\n  \n  \n";class vn extends V{constructor({color:n,alpha:e,lighting:t,layers:a,name:i,...o}={}){super({baseMaterial:W[t||"basic"],...o}),this.name="LayerMaterial",this.layers=[],this.lighting="basic";const r=n||"white",c=e??1;this.uniforms={u_lamina_color:{value:"string"==typeof r?new s(r).convertSRGBToLinear():r},u_lamina_alpha:{value:c}},this.layers=a||this.layers,this.lighting=t||this.lighting,this.name=i||this.name,this.refresh()}genShaders(){let n="",e="",t="",a="",i={};return this.layers.filter((n=>n.visible)).forEach((o=>{n+=o.vertexVariables+"\n",e+=o.fragmentVariables+"\n",t+=o.vertexShader+"\n",a+=o.fragmentShader+"\n",i={...i,...o.uniforms}})),i={...i,...this.uniforms},{uniforms:i,vertexShader:`\n        ${dn}\n        ${fn}\n        ${n}\n\n        void main() {\n          vec3 lamina_finalPosition = position;\n          vec3 lamina_finalNormal = normal;\n\n          ${t}\n\n          csm_Position = lamina_finalPosition;\n          csm_Normal = lamina_finalNormal;\n        }\n        `,fragmentShader:`\n        ${dn}\n        ${fn}\n        \nvec4 lamina_blend_add(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4(min(x.xyz + y.xyz, 1.0) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec3 lamina_blend_alpha(const in vec3 x, const in vec3 y, const in float opacity) {\n\n\treturn y * opacity + x * (1.0 - opacity);\n\n}\n\nvec4 lamina_blend_alpha(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tfloat a = min(y.a, opacity);\n\n\treturn vec4(lamina_blend_alpha(x.rgb, y.rgb, a), x.a);\n\n}\nvec4 lamina_blend_average(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4((x.xyz + y.xyz) * 0.5 * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_color_burn(const in float x, const in float y) {\n\n\treturn (y == 0.0) ? y : max(1.0 - (1.0 - x) / y, 0.0);\n\n}\n\nvec4 lamina_blend_color_burn(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_color_burn(x.r, y.r),\n\t\tlamina_blend_color_burn(x.g, y.g),\n\t\tlamina_blend_color_burn(x.b, y.b),\n\t\tlamina_blend_color_burn(x.a, y.a)\n\t);\n\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_color_dodge(const in float x, const in float y) {\n\n\treturn (y == 1.0) ? y : min(x / (1.0 - y), 1.0);\n\n}\n\nvec4 lamina_blend_color_dodge(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_color_dodge(x.r, y.r),\n\t\tlamina_blend_color_dodge(x.g, y.g),\n\t\tlamina_blend_color_dodge(x.b, y.b),\n\t\tlamina_blend_color_dodge(x.a, y.a)\n\t);\n\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_darken(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4(min(x.xyz, y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_difference(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4(abs(x.xyz - y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_divide(const in float x, const in float y) {\n\n\treturn (y > 0.0) ? min(x / y, 1.0) : 1.0;\n\n}\n\nvec4 lamina_blend_divide(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_divide(x.r, y.r),\n\t\tlamina_blend_divide(x.g, y.g),\n\t\tlamina_blend_divide(x.b, y.b),\n\t\tlamina_blend_divide(x.a, y.a)\n\t);\n\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_exclusion(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4((x.xyz + y.xyz - 2.0 * x.xyz * y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_lighten(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4(max(x.xyz, y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_multiply(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4( x.xyz * y.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_negation(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4((1.0 - abs(1.0 - x.xyz - y.xyz)) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_normal(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4(y.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_overlay(const in float x, const in float y) {\n\n\treturn (x < 0.5) ? (2.0 * x * y) : (1.0 - 2.0 * (1.0 - x) * (1.0 - y));\n\n}\n\nvec4 lamina_blend_overlay(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_overlay(x.r, y.r),\n\t\tlamina_blend_overlay(x.g, y.g),\n\t\tlamina_blend_overlay(x.b, y.b),\n\t\tlamina_blend_overlay(x.a, y.a)\n\t);\n\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_reflect(const in float x, const in float y) {\n\n\treturn (y == 1.0) ? y : min(x * x / (1.0 - y), 1.0);\n\n}\n\nvec4 lamina_blend_reflect(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_reflect(x.r, y.r),\n\t\tlamina_blend_reflect(x.g, y.g),\n\t\tlamina_blend_reflect(x.b, y.b),\n\t\tlamina_blend_reflect(x.a, y.a)\n\t);\n\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_screen(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4((1.0 - (1.0 - x.xyz) * (1.0 - y.xyz)) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_softlight(const in float x, const in float y) {\n\n\treturn (y < 0.5) ?\n\t\t(2.0 * x * y + x * x * (1.0 - 2.0 * y)) :\n\t\t(sqrt(x) * (2.0 * y - 1.0) + 2.0 * x * (1.0 - y));\n\n}\n\nvec4 lamina_blend_softlight(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_softlight(x.r, y.r),\n\t\tlamina_blend_softlight(x.g, y.g),\n\t\tlamina_blend_softlight(x.b, y.b),\n\t\tlamina_blend_softlight(x.a, y.a)\n\t);\n\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_subtract(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4(max(x.xyz + y.xyz - 1.0, 0.0) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\n\n\n        ${e}\n\n        uniform vec3 u_lamina_color;\n        uniform float u_lamina_alpha;\n\n        void main() {\n          vec4 lamina_finalColor = vec4(u_lamina_color, u_lamina_alpha);\n\n          ${a}\n\n          csm_DiffuseColor = lamina_finalColor;\n         \n        }\n        `}}refresh(){const{uniforms:n,fragmentShader:e,vertexShader:t}=this.genShaders();super.update({fragmentShader:e,vertexShader:t,uniforms:n})}serialize(){return{constructor:"LayerMaterial",properties:{color:this.color,alpha:this.alpha,name:this.name,lighting:this.lighting}}}set color(n){var e,t;null!=(t=null==(e=this.uniforms)?void 0:e.u_lamina_color)&&t.value&&(this.uniforms.u_lamina_color.value="string"==typeof n?new s(n).convertSRGBToLinear():n)}get color(){var n,e;return null==(e=null==(n=this.uniforms)?void 0:n.u_lamina_color)?void 0:e.value}set alpha(n){this.uniforms.u_lamina_alpha.value=n}get alpha(){return this.uniforms.u_lamina_alpha.value}}export{an as $,en as S,vn as n};
