class t{constructor(){this._controller=new AbortController,this.listeners=new Set}static{this.pendings=new Map}fetch(s,e={}){t.pendings.has(s)||(t.pendings.set(s,this),fetch(s,{...e,signal:this._controller.signal}).then((t=>{this.listeners.forEach((s=>s.resolve(t.clone())))})).catch((t=>{this.listeners.forEach((s=>s.reject(t)))})).finally((()=>{t.pendings.delete(s)})))}abort(){this._controller.abort()}}class s{constructor(t,s){this.url=t,this.init=s,this.promise=new Promise(((t,s)=>{this.resolve=t,this.reject=s}))}ready(){let s=t.pendings.get(this.url);return s||(s=new t,s.fetch(this.url,this.init)),s.listeners.add(this),this.promise}abort(){this.reject("User abort.");const s=t.pendings.get(this.url);s&&(s.listeners.delete(this),0===s.listeners.size&&s.abort())}}class e{constructor(t){this.mode=e.DOWN,this.geometry=t}static{this.UP=1}static{this.DOWN=2}static{this.MATCH=3}}export{s as F};
