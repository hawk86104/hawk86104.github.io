import{_ as n,C as t,cp as e,bW as o,m as i,h as r,ab as a}from"./three.874nNzAX1726273176332.js";import{p as s,U as l,z as u}from"./@tresjs.BFyWuCYn1726273176332.js";import{d as c,b as f,a4 as p,a3 as m,o as g,E as b,L as v,aj as y,ak as d,u as h}from"./@vue.JNsx1iN61726273176332.js";const w=T;!function(n,t){const e=T,o=x();for(;;)try{if(664847===-parseInt(e(350))/1*(parseInt(e(353))/2)+parseInt(e(326))/3*(parseInt(e(338))/4)+-parseInt(e(310))/5+parseInt(e(331))/6*(-parseInt(e(339))/7)+parseInt(e(311))/8+-parseInt(e(335))/9+parseInt(e(342))/10)break;o.push(o.shift())}catch(i){o.push(o.shift())}}();const _=function(){let n=!0;return function(t,e){const o=n?function(){if(e){const n=e[T(325)](t,arguments);return e=null,n}}:function(){};return n=!1,o}}();!function(){_(this,(function(){const n=T,t=new RegExp(n(359)),e=new RegExp(n(358),"i"),o=I("init");t[n(316)](o+"chain")&&e[n(316)](o+"input")?I():o("0")}))()}();const z=function(){let n=!0;return function(t,e){const o=n?function(){if(e){const n=e.apply(t,arguments);return e=null,n}}:function(){};return n=!1,o}}();function x(){const n=["constructor","string","TresMeshRef","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","function *\\( *\\)","warn",'{}.constructor("return this")( )',"table","1008770ohtzMk","3674736ZZEWqn","gger","Color","verticesNeedUpdate","Mesh","test","trace","opacity","toString","error","counter","push","color","#84ccff","apply","519lXAoPc","action","TresMesh","position","dispose","5569638CwoMAb","glowColor","length","uOpacity","8473185pYEJcv","AdditiveBlending","value","15852eGuhFU","7omqQlV","traverse","prototype","19885390EfvIMF","map","console","debu","uniforms","DoubleSide","TresShaderMaterial","offsetY","397141JTMzDE","bind","exception","2wRndzD","TresBufferGeometry"];return(x=function(){return n})()}z(void 0,(function(){const n=T,t=function(){const n=T;let t;try{t=Function("return (function() "+n(361)+");")()}catch(e){t=window}return t}(),e=t[n(344)]=t[n(344)]||{},o=["log",n(360),"info",n(320),n(352),n(362),n(317)];for(let i=0;i<o[n(333)];i++){const t=z.constructor[n(341)][n(351)](z),r=o[i],a=e[r]||t;t.__proto__=z[n(351)](z),t[n(319)]=a[n(319)][n(351)](a),e[r]=t}}))();const P=v(w(354),null,null,-1);function T(n,t){const e=x();return(T=function(n,t){return e[n-=310]})(n,t)}const S=c({__name:"xRayEffect",props:{model:{},color:{default:w(324)},opacity:{default:1}},async setup(o){const i=w;let r,a;const c=o,h=f(),_=[];c.model[i(340)]((t=>{const e=i;t instanceof n[e(315)]&&(t.geometry[e(314)]=!0,_[e(322)](t.geometry))}));const z=([r,a]=p((()=>u({map:"./plugins/medical/image/brainXRayLight.png"}))),r=await r,a(),r),x={uniforms:{c:{type:"f",value:1.11},p:{type:"f",value:1},glowColor:{type:"c",value:new t(c[i(323)])},lightningTexture:{type:"t",value:z[i(343)]},offsetY:{type:"f",value:.1},uTime:{type:"f",value:0},uOpacity:{type:"f",value:c.opacity}},vertexShader:"uniform float c;\nuniform float p;\nuniform float uTime;\nvarying float intensity;\nvarying vec2 vUv;\nvoid main(){\n    vUv=uv;\n    vec3 vNormal=normalize(normalMatrix*normal);\n    intensity=pow(c-abs(dot(vNormal,vec3(0,0,1))),p);\n    gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\n}",fragmentShader:"uniform vec3 glowColor;\nuniform sampler2D lightningTexture;\nvarying float intensity;\nvarying vec2 vUv;\nuniform float offsetY;\nuniform float uTime;\nuniform float uOpacity;\n\nvoid main(){\n  vec2 uv=vUv;\n  uv.y+=offsetY;\n  vec3 glow=glowColor*intensity;\n  vec3 color=vec3(step(.1,uv.y)-step(.2,uv.y))-vec3(texture2D(lightningTexture,uv));\n  float alpha=clamp(cos(uTime*3.),.5,1.);\n  gl_FragColor=vec4(glow+color,alpha*uOpacity);\n}",side:n[i(347)],blending:n[i(336)],depthWrite:!1};x[i(346)][i(349)][i(337)]=Math.sin(5);const{camera:T}=s(),{onLoop:S}=l();return S((({delta:n})=>{const t=i;T[t(337)][t(329)]&&h[t(337)]&&(x.uniforms.uTime[t(337)]+=n)})),m((()=>{const t=i;h[t(337)]&&(h[t(337)].geometry[t(330)](),h.value.geometry=e(_)),c[t(323)]&&(x.uniforms[t(332)].value=new(n[t(313)])(c[t(323)])),c[t(318)]&&(x[t(346)][t(334)][t(337)]=c[t(318)])})),(n,t)=>{const e=i;return g(),b(e(328),{ref_key:e(357),ref:h},[P,v(e(348),y(d(x)),null,16)],512)}}});function I(n){function t(n){const e=T;if(typeof n===e(356))return function(n){}[e(355)]("while (true) {}").apply(e(321));1!==(""+n/n)[e(333)]||n%20==0?function(){return!0}[e(355)](e(345)+"gger").call(e(327)):function(){return!1}[e(355)]("debu"+e(312))[e(325)]("stateObject"),t(++n)}try{if(n)return t;t(0)}catch(e){}}!function(n,t){const e=B,o=M();for(;;)try{if(345156===-parseInt(e(408))/1*(parseInt(e(376))/2)+parseInt(e(421))/3*(-parseInt(e(375))/4)+-parseInt(e(427))/5*(-parseInt(e(385))/6)+-parseInt(e(396))/7+parseInt(e(384))/8*(parseInt(e(415))/9)+parseInt(e(426))/10+-parseInt(e(401))/11*(-parseInt(e(364))/12))break;o.push(o.shift())}catch(i){o.push(o.shift())}}();const C=function(){let n=!0;return function(t,e){const o=n?function(){if(e){const n=e[B(431)](t,arguments);return e=null,n}}:function(){};return n=!1,o}}();function M(){const n=["mergeGeometries","MathUtils","Mesh","value","constructor","brainstem","afective","includes","bind","chain","2718737WytFcu","__proto__","call","model","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","857131lAHXfY","randInt","size","BufferGeometryRef","TresShaderMaterial","stateObject","randFloat","1941uDhtiv","push","opacity","string","DoubleSide","color","geometry","180YnnZZy","amigdala","glowColor","Float32BufferAttribute","prototype","position","1500NoXJty","table","traverse","length","log","2651240SJPZHc","5aBhazf","aDelayDuration","material","map","apply","console","action","info","while (true) {}","debu","Color","init","test","TresPoints","warn","counter","48heFnEZ","error","exception","array","gger","TresMeshRef","analitic","uniforms","bubbles","semantic","return (function() ","3652jAfRco","160pKToGi","episodic","attributes","AdditiveBlending","toString","setAttribute",'{}.constructor("return this")( )',"input","133880phXXyZ","2602914BNdoDD"];return(M=function(){return n})()}!function(){C(this,(function(){const n=B,t=new RegExp("function *\\( *\\)"),e=new RegExp(n(400),"i"),o=D(n(359));t[n(360)](o+n(395))&&e[n(360)](o+n(383))?D():o("0")}))()}();const F=function(){let n=!0;return function(t,e){const o=n?function(){if(e){const n=e.apply(t,arguments);return e=null,n}}:function(){};return n=!1,o}}();function B(n,t){const e=M();return(B=function(n,t){return e[n-=356]})(n,t)}F(void 0,(function(){const n=B,t=function(){const n=B;let t;try{t=Function(n(374)+n(382)+");")()}catch(e){t=window}return t}(),e=t[n(432)]=t[n(432)]||{},o=[n(425),n(362),n(434),n(365),n(366),n(422),"trace"];for(let i=0;i<o[n(424)];i++){const t=F[n(390)][n(419)].bind(F),r=o[i],a=e[r]||t;t[n(397)]=F[n(394)](F),t[n(380)]=a[n(380)].bind(a),e[r]=t}}))();const U=c({__name:"bubblesEffect",props:{model:{},color:{default:"#FFF"},opacity:{default:1}},setup(t){const e=B,s=t,u=[e(392),e(373),e(377),"process",e(416),e(391),"bridge","cerebellum",e(370)],c={};s[e(399)][e(423)]((t=>{const i=e;t instanceof n[i(388)]&&u[i(430)]((n=>{const e=i;if(t.name[e(393)](n)){if(c[n]){const i=[c[n],t.geometry];return c[n]=o[e(386)](i),c}return c[n]=t[e(414)]}return[]}))}));const p=f(),w=new i({uniforms:{glowColor:{type:"c",value:new(n[e(358)])(s[e(413)])},uTime:{type:"f",value:0},uSlowTime:{type:"f",value:0},uBubblesUp:{type:"f",value:1},uOpacity:{type:"f",value:s[e(410)]}},vertexShader:"uniform float p;\nuniform float uTime;\nuniform float uSlowTime;\nuniform float uBubblesUp;\nvarying float intensity;\nattribute vec2 aDelayDuration;\nattribute float size;\nattribute vec4 bubbles;\nvarying float alpha;\n\nfloat easeExpoInOut(float p){\n    return((p*=2.)<1.)?.5*pow(2.,10.*(p-1.)):.5*(2.-pow(2.,-10.*(p-1.)));\n}\n\nvoid main()\n{\n    intensity=.9;\n    vec4 mvPosition=modelViewMatrix*vec4(position,1.);\n    gl_PointSize=size*(300./-mvPosition.z);\n    float m=mod(size,sin(uSlowTime*.12+size));\n    \n    alpha=step(.5,abs(m));\n    if(m>.5&&m<.7){\n        gl_PointSize=.9*size;\n    }\n    if(m>.8){\n        gl_PointSize=.9*size;\n    }\n    \n    gl_Position=projectionMatrix*mvPosition;\n    \n    if(bubbles.w>0.&&bubbles.w<2.&&bubbles.x!=0.&&bubbles.y!=0.){\n        gl_PointSize=size+15.;\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,1.);\n        \n        float tProgress=smoothstep(0.,aDelayDuration.x,uBubblesUp);\n        vec3 tranlated=mix(position,bubbles.xyz,tProgress);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        gl_Position+=projectionMatrix*bPosition;\n        alpha=5.;\n    }\n    \n    if(bubbles.w==2.){\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,.6);\n        gl_PointSize=size+60.;\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        float normalized=clamp(uBubblesUp,0.,2.)*2.;\n        vec3 tranlated=mix(position,bubbles.xyz,normalized);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        gl_Position+=projectionMatrix*bPosition;\n    }\n    if(bubbles.w==3.){\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,1.);\n        gl_PointSize=size+90.;\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        float normalized=clamp(uBubblesUp,0.,2.)*2.;\n        vec3 tranlated=mix(position,bubbles.xyz,normalized);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        gl_Position+=projectionMatrix*bPosition;\n    }\n}",fragmentShader:"precision mediump float;\nuniform vec3 glowColor;\nvarying float intensity;\nvarying float alpha;\nuniform float uOpacity;\nvoid main() {\n  float distanceToCenter = distance(gl_PointCoord, vec2(.5));\n  float pct = 1. - smoothstep(0., .5, distanceToCenter);\n  vec3 color = vec3(1.) * gl_FragColor.rgb;\n  vec3 glow = glowColor * intensity;\n  gl_FragColor = vec4(glow, clamp(alpha, 0., 1.));\n  gl_FragColor = vec4(glow, pct * gl_FragColor.a);\n  gl_FragColor = vec4(gl_FragColor.rgb, gl_FragColor.a * uOpacity);\n  // gl_FragColor=vec4(1.,1.,0.,1.);\n}",blending:n[e(379)],side:n[e(412)],depthTest:!1,vertexColors:!1,transparent:!0});m((()=>{p[e(389)]&&(()=>{const t=e,o=[],i=[],s=[],l=[];for(let e=0;e<2e4-3*u.length;e+=1){const a=r[t(402)](0,u[t(424)]-1),f=u[a],p=c[f][t(378)][t(420)][t(367)][3*e+0]||0,m=c[f][t(378)][t(420)].array[3*e+1]||0,g=c[f].attributes[t(420)][t(367)][3*e+2]||0;if(i.push(p,m,g),o[e]=n[t(387)][t(407)](10,20),e%100==0){const e=n[t(387)].randInt(100,250)+m;l[t(409)](p,e,g,1)}else l[t(409)](p,m,g,0);s[2*e+0]=n[t(387)].randFloat(.5,1.5),s[2*e+1]=2.5}p[t(389)][t(381)](t(428),new(n[t(418)])(s,2)),p[t(389)][t(381)](t(372),new(n[t(418)])(l,4)),p[t(389)][t(381)](t(420),new a(i,3)),p[t(389)][t(381)](t(413),new(n[t(418)])([],3)),p[t(389)][t(381)](t(403),new(n[t(418)])(o,1)),p[t(389)].computeBoundingSphere()})()}));const _=f(),{onLoop:z}=l();return z((({delta:t})=>{const o=e;_.value&&(_.value[o(429)][o(371)].uTime[o(389)]+=.05,_[o(389)][o(429)].uniforms.uSlowTime.value+=1/400),s[o(413)]&&(w[o(371)][o(417)].value=new(n[o(358)])(s[o(413)])),s.opacity&&(w.uniforms.uOpacity.value=s[o(410)])})),(n,t)=>{const o=e;return g(),b(o(361),{ref_key:o(369),ref:_},[v("TresBufferGeometry",{ref_key:o(404),ref:p},null,512),v(o(405),y(d(h(w))),null,16)],512)}}});function D(n){function t(n){const e=B;if(typeof n===e(411))return function(n){}[e(390)](e(356)).apply(e(363));1!==(""+n/n)[e(424)]||n%20==0?function(){return!0}[e(390)]("debugger")[e(398)](e(433)):function(){return!1}[e(390)](e(357)+e(368)).apply(e(406)),t(++n)}try{if(n)return t;t(0)}catch(e){}}export{S as _,U as a};
