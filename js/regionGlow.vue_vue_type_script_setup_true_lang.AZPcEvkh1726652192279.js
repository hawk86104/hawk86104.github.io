import{cl as n,_ as t,cm as o,ce as r,C as e,cn as c}from"./three.3esZ7Hzr1726652192279.js";import{r as i}from"./utils.PP2M0YIY1726652192279.js";import{d as s,a3 as a,o as u,E as l,L as f,u as p}from"./@vue.JNsx1iN61726652192279.js";const v=x;function d(){const n=["ShapeGeometry","gger","positionSrc","DoubleSide","2603282TmqdKw","action","bind","rotation-x","319dapbRH","regionGlow","setPositions","#ffff00","exception","primitive","Mesh","trace","44058KSucEu","lineTo","ShaderMaterial","18747AnHaNt","111363pmTBaC","color","call","2QninRN","length","debu","260252hObgSz","getPoints","87390vCpjbh","TresGroup","apply","uvs","flatMap","__proto__","toString","string","15GZSbPd","moveTo","init","constructor","1184OruTGJ","chain","warn","12AzDXPG","table","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","Color","value","return (function() ","object","input","console","\n    varying vec2 vUv;\n\t\tuniform vec3 color;\n    void main() {\n\t\t\t// 计算距离四条边的最小距离\n        float distance = max(max(vUv.x, -vUv.x), max(vUv.y, -vUv.y));\n\n        // 将距离映射到透明度（从边缘到中心逐渐变透明）\n        float alpha = smoothstep(0.1, 0.9, distance*1.1);\n\n        // 设置最终颜色和透明度\n        gl_FragColor = vec4(color, alpha);\n    }\n  ","prototype"];return(d=function(){return n})()}!function(n,t){const o=x,r=d();for(;;)try{if(161013===-parseInt(o(203))/1*(parseInt(o(164))/2)+parseInt(o(157))/3+parseInt(o(167))/4*(parseInt(o(177))/5)+parseInt(o(184))/6*(parseInt(o(161))/7)+-parseInt(o(181))/8*(parseInt(o(160))/9)+-parseInt(o(169))/10+parseInt(o(199))/11)break;r.push(r.shift())}catch(e){r.push(r.shift())}}();const h=function(){let n=!0;return function(t,o){const r=n?function(){if(o){const n=o[x(171)](t,arguments);return o=null,n}}:function(){};return n=!1,r}}();!function(){h(this,(function(){const n=x,t=new RegExp("function *\\( *\\)"),o=new RegExp(n(186),"i"),r=y(n(179));t.test(r+n(182))&&o.test(r+n(191))?y():r("0")}))()}();const m=function(){let n=!0;return function(t,o){const r=n?function(){if(o){const n=o.apply(t,arguments);return o=null,n}}:function(){};return n=!1,r}}();m(void 0,(function(){const n=x,t=function(){const n=x;let t;try{t=Function(n(189)+'{}.constructor("return this")( ));')()}catch(o){t=window}return t}(),o=t.console=t[n(192)]||{},r=["log",n(183),"info","error",n(207),n(185),n(156)];for(let e=0;e<r[n(165)];e++){const t=m.constructor[n(194)].bind(m),c=r[e],i=o[c]||t;t[n(174)]=m[n(201)](m),t[n(175)]=i[n(175)][n(201)](i),o[c]=t}}))();const w=[v(190),"rotation-x"],g=[v(190),v(202)];function x(n,t){const o=d();return(x=function(n,t){return o[n-=155]})(n,t)}const b=s({__name:v(204),props:{positionSrc:{default:[[0,0],[1,1]]},color:{default:v(206)}},setup(s){const d=v,h=s,m=new n;h[d(197)].forEach(((n,t)=>{const o=d;0===t?m[o(178)](n[0],n[1]):m[o(158)](n[0],n[1])}));const x=new(t[d(159)])({vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:d(193),transparent:!0,side:t[d(198)],depthWrite:!1,depthTest:!0,uniforms:{color:{type:d(172),value:new(t[d(187)])(h[d(162)])}}});let b=new(t[d(195)])(m);i(b,!0);const y=new(t[d(155)])(b,x),I=m[d(168)](),_=new o;_[d(205)](I[d(173)]((n=>[n.x,n.y,0])));var S=new r({color:new e(h.color),linewidth:.002});const j=new c(_,S);return a((()=>{const n=d;x.uniforms[n(162)][n(188)]=new(t[n(187)])(h.color),S[n(162)]=new(t[n(187)])(h.color)})),(n,t)=>{const o=d;return u(),l(o(170),null,[f(o(208),{object:p(y),renderOrder:9999,"rotation-x":Math.PI/2},null,8,w),f("primitive",{object:p(j),renderOrder:9999,"rotation-x":Math.PI/2},null,8,g)])}}});function y(n){function t(n){const o=x;if(typeof n===o(176))return function(n){}.constructor("while (true) {}")[o(171)]("counter");1!==(""+n/n)[o(165)]||n%20==0?function(){return!0}[o(180)]("debu"+o(196))[o(163)](o(200)):function(){return!1}[o(180)](o(166)+"gger")[o(171)]("stateObject"),t(++n)}try{if(n)return t;t(0)}catch(o){}}export{b as _};
