import{m as n,e,b as t,U as r,c as o}from"./@tresjs.XlmHwCPa1735906732968.js";import{P as i}from"./tweakpane.yHWGBmom1735906732968.js";import{_ as c,K as a,O as l,m as s,W as u,aA as f,t as p}from"./three.VhLXWX0H1735906732968.js";import{d as v,a4 as g,b as d,o as x,f as h,u as m,g as y,j as w,al as b,r as R,J as C,aj as I,ak as _}from"./@vue.yG49nQHr1735906732968.js";import"./@vueuse.HCIFcVWX1735906732968.js";var M="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";function z(){const n=["280TwhggT","counter","apply","console","toString","28lhOmHJ","water","tiles","input","light","BufferGeometry","1170891BGliVc","stateObject","366605lgRsBW","call","FrontSide","return (function() ","gger","217jouBXR","Mesh","bind","uniforms","string","31992UOPlhd","constructor","RawShaderMaterial","exception","function *\\( *\\)","6941wTCwub",'{}.constructor("return this")( )',"init","29102vGaHOp","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","render","action","info","waterTexture","BufferAttribute","14lzlwrO","value","length","163623uwtHtJ","setAttribute","1669416EhciSB","position","__proto__","chain","causticsTexture","debu","while (true) {}","error"];return(z=function(){return n})()}!function(n,e){const t=A,r=z();for(;;)try{if(210146===parseInt(t(291))/1*(parseInt(t(298))/2)+-parseInt(t(301))/3*(-parseInt(t(316))/4)+-parseInt(t(324))/5+-parseInt(t(303))/6+parseInt(t(329))/7*(parseInt(t(283))/8)+-parseInt(t(322))/9+parseInt(t(311))/10*(-parseInt(t(288))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[A(313)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){T(this,(function(){const n=A,e=new RegExp(n(287)),t=new RegExp(n(292),"i"),r=O(n(290));e.test(r+n(306))&&t.test(r+n(319))?O():r("0")}))()}();const D=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function A(n,e){const t=z();return(A=function(n,e){return t[n-=279]})(n,e)}D(void 0,(function(){const n=A,e=function(){const n=A;let e;try{e=Function(n(327)+n(289)+");")()}catch(t){e=window}return e}(),t=e[n(314)]=e[n(314)]||{},r=["log","warn",n(295),n(310),n(286),"table","trace"];for(let o=0;o<r[n(300)];o++){const e=D[n(284)].prototype[n(280)](D),i=r[o],c=t[i]||e;e[n(305)]=D[n(280)](D),e[n(315)]=c[n(315)][n(280)](c),t[i]=e}}))();const L=v({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=A,o=t,i=new(c[r(321)]),a=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),l=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(302)](r(304),new(c[r(297)])(a,3)),i.setIndex(new(c[r(297)])(l,1));const s=new(c[r(285)])({uniforms:{light:{value:o[r(320)]},tiles:{value:o[r(318)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(326)]}),u=new(c[r(279)])(i,s),{renderer:f,camera:p}=n(),{onAfterLoop:v}=e();return v((()=>{const n=r;((n,e)=>{const t=r;s[t(281)][t(317)][t(299)]=n,s[t(281)].causticTex[t(299)]=e,f.value[t(293)](u,p[t(299)])})(o[n(296)],o[n(307)])})),(n,e)=>null}});function O(n){function e(n){const t=A;if(typeof n===t(282))return function(n){}[t(284)](t(309)).apply(t(312));1!==(""+n/n)[t(300)]||n%20==0?function(){return!0}.constructor(t(308)+t(328))[t(325)](t(294)):function(){return!1}[t(284)]("debu"+t(328)).apply(t(323)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const j=S;!function(n,e){const t=S,r=W();for(;;)try{if(151612===-parseInt(t(340))/1+-parseInt(t(319))/2+-parseInt(t(316))/3+-parseInt(t(337))/4*(-parseInt(t(353))/5)+-parseInt(t(358))/6*(-parseInt(t(341))/7)+-parseInt(t(330))/8+parseInt(t(324))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[S(361)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){F(this,(function(){const n=S,e=new RegExp(n(314)),t=new RegExp(n(335),"i"),r=H(n(356));e[n(342)](r+n(350))&&t.test(r+n(357))?H():r("0")}))()}();const E=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[S(361)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function S(n,e){const t=W();return(S=function(n,e){return t[n-=305]})(n,e)}function W(){const n=["debu","5575FjWKrE","waterTexture","uniforms","init","input","214602joxyTu","Mesh","toString","apply","constructor","pos-x.jpg","__proto__","underwater","setRenderTarget","pooRef","side","exception","bind","light","console","neg-y.jpg","function *\\( *\\)","length","605343BTyEiK","log","geometry","277956PEWMjm","CubeTextureLoader","Color","trace","clear","4825431viQnpc","counter","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","causticTex","table","RawShaderMaterial","709984vQxkry","neg-x.jpg","neg-z.jpg","prototype","call","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","render","456Rgetpp","FrontSide","info","189451AlKfRV","21HPJciB","test","pos-z.jpg","gger","action","water","white","causticsTexture","return (function() ","chain","value"];return(W=function(){return n})()}E(void 0,(function(){const n=S;let e;try{e=Function(n(349)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(312)]=e[n(312)]||{},r=[n(317),"warn",n(339),"error",n(309),n(328),n(322)];for(let i=0;i<r.length;i++){const e=E[n(362)][n(333)][n(310)](E),o=r[i],c=t[o]||e;e[n(364)]=E.bind(E),e[n(360)]=c[n(360)].bind(c),t[o]=e}}))();const P=v({__name:j(346),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=j;let i,l;const s=r,u=s[o(318)],f=(new(c[o(320)])).setPath(o(326)).load([o(363),o(331),"pos-y.jpg",o(313),o(343),o(332)]),p=([i,l]=g((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,l(),i),v=new(c[o(329)])({uniforms:{light:{value:s[o(311)]},tiles:{value:p},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new(c[o(359)])(u,v),w=d(null),b=new(c[o(321)])(o(347)),{renderer:R,camera:C}=n(),{onLoop:I}=e();return I((()=>{const n=o;R.value[n(306)](null),R[n(351)].setClearColor(b,1),R[n(351)][n(323)](),v[n(355)].water[n(351)]=s[n(354)],v[n(355)][n(327)][n(351)]=s.causticsTexture,v[n(308)]=c[n(338)],v[n(355)].underwater[n(351)]=!0,R[n(351)].render(y,C.value),v[n(308)]=a,v[n(355)][n(305)][n(351)]=!1,R[n(351)][n(336)](y,C[n(351)])})),(n,e)=>{const t=o;return x(),h(L,{tiles:m(p),light:n[t(311)],waterTexture:n[t(354)],causticsTexture:n[t(348)],ref_key:t(307),ref:w},null,8,["tiles",t(311),"waterTexture","causticsTexture"])}}});function H(n){function e(n){const t=S;if("string"==typeof n)return function(n){}[t(362)]("while (true) {}").apply(t(325));1!==(""+n/n)[t(315)]||n%20==0?function(){return!0}[t(362)](t(352)+t(344))[t(334)](t(345)):function(){return!1}[t(362)](t(352)+"gger").apply("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=G,r=k();for(;;)try{if(696764===-parseInt(t(190))/1+parseInt(t(185))/2+-parseInt(t(178))/3*(parseInt(t(180))/4)+parseInt(t(204))/5*(-parseInt(t(169))/6)+-parseInt(t(171))/7+-parseInt(t(211))/8*(-parseInt(t(175))/9)+-parseInt(t(187))/10*(-parseInt(t(195))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const V=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[G(196)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function k(){const n=["render","light","111384WwIfff","WebGLRenderTarget","__proto__","6bFnNpj","debu","5179503nuhvyY","Color","PlaneGeometry","exception","738luUowh","call","info","93xeKJEh","gger","47992OwKDGu","string","prototype","causticsTexture","geometry","354778iMMReO","setRenderTarget","42940MxyAxv","setClearColor","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","603405eTiGGJ","log","table","counter","init","5995wAcboT","apply","test","black","texture","bind","return (function() ","stateObject","function *\\( *\\)","6236345OruHRw","Mesh","length","value","while (true) {}"];return(k=function(){return n})()}!function(){V(this,(function(){const n=G,e=new RegExp(n(203)),t=new RegExp(n(189),"i"),r=N(n(194));e[n(197)](r+"chain")&&t[n(197)](r+"input")?N():r("0")}))()}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[G(196)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function G(n,e){const t=k();return(G=function(n,e){return t[n-=169]})(n,e)}B(void 0,(function(){const n=G,e=function(){const n=G;let e;try{e=Function(n(201)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e.console=e.console||{},r=[n(191),"warn",n(177),"error",n(174),n(192),"trace"];for(let o=0;o<r[n(206)];o++){const e=B.constructor[n(182)][n(200)](B),i=r[o],c=t[i]||e;e[n(213)]=B[n(200)](B),e.toString=c.toString.bind(c),t[i]=e}}))();const Z=v({__name:"caustics",props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=G,o=t,i=new l(0,1,1,0,0,2e3),a=new(c[r(173)])(2,2,200,200),u=new(c[r(212)])(1024,1024),f=new s({uniforms:{light:{value:o[r(210)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new(c[r(205)])(a,f),v=new(c[r(172)])(r(198)),{renderer:g}=n(),{onBeforeLoop:d}=e();return d((()=>{const n=r;p.material.uniforms.water[n(207)]=o.waterTexture,g[n(207)][n(186)](u),g[n(207)][n(188)](v,0),g[n(207)].clear(),g[n(207)][n(209)](p,i)})),(n,e)=>{const t=r;return x(),h(b,null,{default:y((()=>[w(P,{waterTexture:n.waterTexture,causticsTexture:m(u)[t(199)],light:n[t(210)],geometry:m(a)},null,8,["waterTexture",t(183),"light",t(184)])])),_:1})}}});function N(n){function e(n){const t=G;if(typeof n===t(181))return function(n){}.constructor(t(208))[t(196)](t(193));1!==(""+n/n)[t(206)]||n%20==0?function(){return!0}.constructor("debugger")[t(176)]("action"):function(){return!1}.constructor(t(170)+t(179))[t(196)](t(202)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=Y,r=U();for(;;)try{if(872953===parseInt(t(257))/1+-parseInt(t(254))/2+-parseInt(t(275))/3+parseInt(t(235))/4+parseInt(t(288))/5+-parseInt(t(243))/6*(parseInt(t(289))/7)+parseInt(t(292))/8)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const $=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){$(this,(function(){const n=Y,e=new RegExp(n(284)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=q(n(244));e[n(266)](r+n(295))&&t[n(266)](r+n(296))?q():r("0")}))()}();const J=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Y(270)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function U(){const n=["getY","setRenderTarget","534pztJyX","init","uniforms","render","prototype","return (function() ","RawShaderMaterial","counter","bind","stateObject","setY","878576yqYaAp","light","call","621734TUzhDP","setFromCamera","Mesh","domElement","trace","clientX","log","exception","length","test","string","PlaneGeometry","OrthographicCamera","apply","console","Vector2","__proto__","needsUpdate","2234991pjeigs","mousemove","material","waterTexture","toString","error","FloatType",'{}.constructor("return this")( )',"width","function *\\( *\\)","debu","lightFrontGeometry","autoClear","4333815ZgnHwu","20524EatvHz","left","warn","6183008DfSWrN","top","while (true) {}","chain","input","WebGLRenderTarget","gger","point","texture","227252ZzMjku","constructor","value","count","info","getBoundingClientRect"];return(U=function(){return n})()}J(void 0,(function(){const n=Y;let e;try{e=Function(n(248)+n(282)+");")()}catch(o){e=window}const t=e[n(271)]=e[n(271)]||{},r=[n(263),n(291),n(239),n(280),n(264),"table",n(261)];for(let i=0;i<r.length;i++){const e=J.constructor[n(247)][n(251)](J),o=r[i],c=t[o]||e;e[n(273)]=J[n(251)](J),e[n(279)]=c[n(279)][n(251)](c),t[o]=e}}))();const K=v({__name:"waterSimulation",props:{light:{}},setup(t,{expose:r}){const o=Y,i=new(c[o(269)])(0,1,1,0,0,2e3),a=new(c[o(268)])(2,2),l=new(c[o(297)])(256,256,{type:c[o(281)]}),s=new u(256,256,{type:c[o(281)]}),v=new f({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),g=new(c[o(249)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),d=new(c[o(249)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),y=new(c[o(259)])(a,v),w=new(c[o(259)])(a,g),b=new(c[o(259)])(a,d);let R=l;const C=(n,e)=>{const t=o,r=R,c=R===l?s:l;e[t(277)][t(245)][t(234)].value=r[t(234)],n[t(242)](c),n[t(246)](e,i),R=c},{renderer:I,camera:_,raycaster:z}=n();I[o(237)][o(287)]=!1;const{onBeforeLoop:T}=e();T((()=>{const n=o;var e,t;t=I.value,C(t,b),e=I[n(237)],C(e,w)}));const D=(n,e,t,r)=>{const i=o;y[i(277)][i(245)].center[i(237)]=[n,e],y[i(277)].uniforms.radius[i(237)]=t,y[i(277)].uniforms.strength[i(237)]=r,C(I[i(237)],y)},A=new(c[o(272)]),L=new p(2,2),O=L.attributes.position;for(let n=0;n<O[o(238)];n++){const e=-O[o(241)](n);O[o(253)](n,0),O.setZ(n,e)}O[o(274)]=!0;const j=new(c[o(259)])(L),F={handleEvent:n=>{const e=o,t=I[e(237)][e(260)][e(240)](),r=t[e(283)],i=t.height;A.x=2*(n[e(262)]-t[e(290)])/r-1,A.y=2*-(n.clientY-t[e(293)])/i+1,z.value[e(258)](A,_[e(237)]);const c=z[e(237)].intersectObject(j);for(let o of c)D(o[e(299)].x,o[e(299)].z,.03,.04)}};return r({addDrop:D,mouseEvent:n=>{const e=o;n?I[e(237)][e(260)].addEventListener(e(276),F):I[e(237)].domElement.removeEventListener("mousemove",F)}}),(n,e)=>{const t=o;return x(),h(Z,{lightFrontGeometry:m(a),waterTexture:m(R).texture,light:n[t(255)]},null,8,[t(286),t(278),"light"])}}});function Y(n,e){const t=U();return(Y=function(n,e){return t[n-=234]})(n,e)}function q(n){function e(n){const t=Y;if(typeof n===t(267))return function(n){}[t(236)](t(294)).apply(t(250));1!==(""+n/n)[t(265)]||n%20==0?function(){return!0}[t(236)](t(285)+t(298))[t(256)]("action"):function(){return!1}.constructor(t(285)+t(298))[t(270)](t(252)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const Q=tn;!function(n,e){const t=tn,r=en();for(;;)try{if(388271===-parseInt(t(121))/1+parseInt(t(120))/2+parseInt(t(124))/3+-parseInt(t(117))/4*(parseInt(t(139))/5)+parseInt(t(114))/6*(parseInt(t(126))/7)+-parseInt(t(103))/8*(-parseInt(t(138))/9)+parseInt(t(109))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const X=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(118)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){X(this,(function(){const n=tn,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(107),"i"),r=on(n(113));e[n(115)](r+n(130))&&t[n(115)](r+n(102))?on():r("0")}))()}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(118)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function en(){const n=["prototype","debu","364017AtQDFW","__proto__","827918USaySe","toString","mouseEvent","addDrop","chain","constructor","call","stateObject","action","bind","trace","random","300519JdewVi","8215kzGoMv","info","gger","console","change","input","48tgakHv","click","error","return (function() ","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","log","3244100HsmpHp","length","realWater","value","init","30PGBVYd","test","addButton","1064uxoNAS","apply","table","133014BxhqZd","478663hTPPRc"];return(en=function(){return n})()}function tn(n,e){const t=en();return(tn=function(n,e){return t[n-=102]})(n,e)}nn(void 0,(function(){const n=tn,e=function(){const n=tn;let e;try{e=Function(n(106)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(142)]=e.console||{},r=[n(108),"warn",n(140),n(105),"exception",n(119),n(136)];for(let o=0;o<r[n(110)];o++){const e=nn.constructor[n(122)][n(135)](nn),i=r[o],c=t[i]||e;e[n(125)]=nn[n(135)](nn),e[n(127)]=c[n(127)][n(135)](c),t[i]=e}}))();const rn=v({__name:Q(111),setup(n){const e=Q,t=R({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:"manual"}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=d(null),l=new i;l[e(116)]({label:"点击按钮",title:"随机增加波纹"}).on(e(104),(()=>{const n=e;for(var t=0;t<10;t++)a[n(112)][n(129)](2*Math.random()-1,2*Math[n(137)]()-1,.03,1&t?.02:-.02)}));const s=d(!1);return l.addBinding(s,e(112),{label:"鼠标波纹"}).on(e(143),(n=>{const t=e;a[t(112)][t(128)](n[t(112)])})),(n,e)=>(x(),h(m(o),I(_(t)),{default:y((()=>[e[0]||(e[0]=C("TresPerspectiveCamera",{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),w(m(r)),w(K,{light:c,ref_key:"waterSimulationRef",ref:a},null,512)])),_:1},16))}});function on(n){function e(n){const t=tn;if("string"==typeof n)return function(n){}[t(131)]("while (true) {}")[t(118)]("counter");1!==(""+n/n)[t(110)]||n%20==0?function(){return!0}[t(131)](t(123)+t(141))[t(132)](t(134)):function(){return!1}.constructor("debu"+t(141))[t(118)](t(133)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{rn as default};
