import{C as e,bL as n,N as o,_ as a,ce as t,c as s}from"./three.QlBabAUP1756712874380.js";import{e as r,I as i,K as l,a as u}from"./@tresjs.CsRUmnoW1756712874380.js";import{d as m,b as d,w as c,h as v,G as h,o as p,j as f,u as w,f as g,I as P,a7 as M,a8 as C,F as b}from"./@vue.BzMISRrV1756712874380.js";import"./postprocessing.COeOixE51756712874380.js";import"./@vueuse.BerxTw9o1756712874380.js";const y=["position","a-scale","color","a-randomness"],x=m({__name:"galaxy",setup(m){const x={clearColor:"black",shadows:!0,alpha:!1,shadowMapType:t,outputColorSpace:a,toneMapping:o,windowSize:!0},z={count:3e4,size:20,radius:5,branches:5,spin:4,randomness:.13,randomnessPower:7.5,insideColor:"#b5f28d",outsideColor:"#1b3984"},T=new e(z.insideColor),S=new e(z.outsideColor),A=new Float32Array(3*z.count),j=new Float32Array(3*z.count),F=new Float32Array(z.count),_=new Float32Array(3*z.count);for(let e=0;e<z.count;e++){const n=3*e,o=Math.random()*z.radius,a=e%z.branches*Math.PI*2/z.branches;A[n]=Math.cos(a)*o,A[n+1]=0,A[n+2]=Math.sin(a)*o;const t=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),s=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),r=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1);_[n]=t,_[n+1]=s,_[n+2]=r;const i=T.clone();i.lerp(S,o/z.radius),j[n+0]=i.r,j[n+1]=i.g,j[n+2]=i.b,F[e]=Math.random()}const I={transparent:!0,depthWrite:!1,blending:n,vertexColors:!0,vertexShader:"uniform float uSize;\nuniform float uTime;\n\nattribute float aScale;\nattribute vec3 aRandomness;\n\nvarying vec3 vColor;\n\nvoid main() {\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n\n    \n    float angle = atan(modelPosition.x, modelPosition.z);\n    float distanceToCenter = length(modelPosition.xz);\n    float angleOffset = (1.0 / distanceToCenter) * uTime * 0.2;\n    angle += angleOffset;\n\n    modelPosition.x = distanceToCenter * cos(angle);\n    modelPosition.z = distanceToCenter * sin(angle);\n\n    \n    modelPosition.xyz += aRandomness;\n\n    vec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectedPosition = projectionMatrix * viewPosition;\n    gl_Position = projectedPosition;\n\n    gl_PointSize = uSize * aScale;\n\n    \n    gl_PointSize *= ( 1.0 / - viewPosition.z);\n\n    \n    vColor = color;\n\n}",fragmentShader:"varying vec3 vColor;\n\nvoid main()\n{\n    \n    float strength = distance(gl_PointCoord, vec2(0.5));\n    strength = 1.0 - strength;\n    strength = pow(strength, 5.0);\n\n    \n    vec3 color = mix(vec3(0.0), vColor, strength);\n    gl_FragColor = vec4(color, 1.0);\n}",uniforms:{uTime:{value:0},uSize:{value:z.size}}};const R=d(null),{onLoop:k}=r();k((({elapsed:e})=>{R.value&&(R.value.material.uniforms.uTime.value=e)}));const{count:O,size:G,radius:L,branches:B,spin:E,randomness:K,randomnessPower:N,insideColor:W,outsideColor:q}=i({count:{value:3e4,min:0,max:1e5,step:1},size:{value:20,min:.01,max:40,step:1},radius:{value:5,min:.1,max:20,step:.01},branches:{value:5,min:2,max:10,step:1},spin:{value:4,min:-5,max:5,step:.01},randomness:{value:.13,min:.1,max:.2,step:.01},randomnessPower:{value:7.5,min:1,max:10,step:.001},insideColor:"#b5f28d",outsideColor:"#1b3984"});return c([O.value,G.value,L.value,B.value,E.value,K.value,N.value,W.value,q.value],(n=>{n.forEach(((e,n)=>{z[Object.keys(z)[n]]=e.value})),function(){if(R.value){const n=new e(z.insideColor),o=new e(z.outsideColor),a=new Float32Array(3*z.count),t=new Float32Array(3*z.count),r=new Float32Array(z.count),i=new Float32Array(3*z.count);for(let e=0;e<z.count;e++){const s=3*e,l=Math.random()*z.radius,u=e%z.branches*Math.PI*2/z.branches;a[s]=Math.cos(u)*l,a[s+1]=0,a[s+2]=Math.sin(u)*l;const m=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),d=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),c=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1);i[s]=m,i[s+1]=d,i[s+2]=c;const v=n.clone();v.lerp(o,l/z.radius),t[s+0]=v.r,t[s+1]=v.g,t[s+2]=v.b,r[e]=Math.random()}R.value.geometry.setAttribute("position",new s(a,3)),R.value.geometry.setAttribute("aRandomness",new s(i,3)),R.value.geometry.setAttribute("color",new s(t,3)),R.value.geometry.setAttribute("aScale",new s(r,1))}}()})),(e,n)=>{const o=v("TresCanvas");return p(),h(b,null,[f(w(l)),f(o,M(C(x)),{default:g((()=>[n[0]||(n[0]=P("TresPerspectiveCamera",{position:[3,3,3]},null,-1)),P("TresPoints",{ref_key:"bufferRef",ref:R},[P("TresBufferGeometry",{position:[w(A),3],"a-scale":[w(F),1],color:[w(j),3],"a-randomness":[w(_),3]},null,8,y),P("TresShaderMaterial",M(C(I)),null,16)],512),f(w(u))])),_:1},16)],64)}}});export{x as default};
