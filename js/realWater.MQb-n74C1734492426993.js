import{m as n,e,b as t,U as r,c as o}from"./@tresjs.WiFlZbqU1734492426993.js";import{P as i}from"./tweakpane.yHWGBmom1734492426993.js";import{_ as c,t as a,W as l,s}from"./three.-W-Avfc61734492426993.js";import{d as u,a6 as f,b as p,o as v,f as g,u as d,g as x,j as h,al as m,r as y,J as w,aj as b,ak as I}from"./@vue.-THQH3GC1734492426993.js";import"./@vueuse.HnQgsJ961734492426993.js";var R="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const C=M;function _(){const n=["error","10oaLWkO","log","causticTex","BufferAttribute","RawShaderMaterial","setAttribute","pool","length","toString","call","info","init","__proto__","bind","warn","table","value","apply","causticsTexture","while (true) {}","stateObject","action","water",'{}.constructor("return this")( )',"chain","129pUwSdS","render","8kftwzU","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","Mesh","gger","prototype","1419186plvwUV","10461447zPITAV","2553309JclEQv","89308xneXVx","test","counter","console","uniforms","15iZXsap","debu","position","217593QzFiqa","FrontSide","light","tiles","BufferGeometry","constructor","return (function() ","122856mpzZvr","69559QWnCiS","360qJgVpu","input"];return(_=function(){return n})()}!function(n,e){const t=M,r=_();for(;;)try{if(708597===-parseInt(t(471))/1*(-parseInt(t(455))/2)+-parseInt(t(453))/3*(-parseInt(t(463))/4)+-parseInt(t(468))/5*(-parseInt(t(460))/6)+-parseInt(t(424))/7*(parseInt(t(425))/8)+-parseInt(t(461))/9*(parseInt(t(428))/10)+-parseInt(t(462))/11+parseInt(t(423))/12)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function M(n,e){const t=_();return(M=function(n,e){return t[n-=419]})(n,e)}!function(){z(this,(function(){const n=M,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(456),"i"),r=A(n(439));e[n(464)](r+n(452))&&t[n(464)](r+n(426))?A():r("0")}))()}();const D=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[M(445)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();D(void 0,(function(){const n=M,e=function(){const n=M;let e;try{e=Function(n(422)+n(451)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(466)]||{},r=[n(429),n(442),n(438),n(427),"exception",n(443),"trace"];for(let o=0;o<r[n(435)];o++){const e=D.constructor[n(459)][n(441)](D),i=r[o],c=t[i]||e;e[n(440)]=D[n(441)](D),e[n(436)]=c[n(436)][n(441)](c),t[i]=e}}))();const T=u({__name:C(434),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=C,o=t,i=new(c[r(420)]),a=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),l=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(433)](r(470),new(c[r(431)])(a,3)),i.setIndex(new(c[r(431)])(l,1));const s=new(c[r(432)])({uniforms:{light:{value:o[r(473)]},tiles:{value:o[r(419)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(472)]}),u=new(c[r(457)])(i,s),{renderer:f,camera:p}=n(),{onAfterLoop:v}=e();return v((()=>{const n=r;((n,e)=>{const t=r;s[t(467)][t(450)].value=n,s[t(467)][t(430)][t(444)]=e,f[t(444)][t(454)](u,p[t(444)])})(o.waterTexture,o[n(446)])})),(n,e)=>null}});function A(n){function e(n){const t=M;if("string"==typeof n)return function(n){}[t(421)](t(447)).apply(t(465));1!==(""+n/n).length||n%20==0?function(){return!0}[t(421)](t(469)+"gger")[t(437)](t(449)):function(){return!1}[t(421)](t(469)+t(458))[t(445)](t(448)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function L(){const n=["prototype","geometry","value","while (true) {}","render","BackSide","light","apply","tiles","pooRef","constructor","debu","return (function() ","chain","10PyZEYh","table","Color","pos-y.jpg","11554rNigeJ","underwater","causticTex","clear","neg-z.jpg","string","function *\\( *\\)","RawShaderMaterial","toString","neg-y.jpg","FrontSide","62cReGEh","3458224NiVixg","setRenderTarget","side","water","3186350zoKapu","stateObject","130638MWSlzR","trace","info","Mesh","19348208GNybgx","setClearColor","477273iTcPYq","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","load","log","white","7rZcRiV","init","console","counter","uniforms","causticsTexture","test","exception","length","setPath","warn","bind","CubeTextureLoader","call","waterTexture","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","5022747manEOX","4qLpWpN"];return(L=function(){return n})()}!function(n,e){const t=O,r=L();for(;;)try{if(352153===parseInt(t(445))/1*(parseInt(t(456))/2)+-parseInt(t(469))/3+parseInt(t(426))/4*(-parseInt(t(461))/5)+parseInt(t(463))/6*(parseInt(t(474))/7)+-parseInt(t(457))/8+-parseInt(t(425))/9*(parseInt(t(441))/10)+parseInt(t(467))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[O(434)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){S(this,(function(){const n=O,e=new RegExp(n(451)),t=new RegExp(n(489),"i"),r=j(n(475));e[n(480)](r+n(440))&&t[n(480)](r+"input")?j():r("0")}))()}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[O(434)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function O(n,e){const t=L();return(O=function(n,e){return t[n-=425]})(n,e)}F(void 0,(function(){const n=O;let e;try{e=Function(n(439)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(476)]=e[n(476)]||{},r=[n(472),n(484),n(465),"error",n(481),n(442),n(464)];for(let i=0;i<r[n(482)];i++){const e=F.constructor[n(427)][n(485)](F),o=r[i],c=t[o]||e;e.__proto__=F.bind(F),e[n(453)]=c.toString[n(485)](c),t[o]=e}}))();const E=u({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=O;let i,a;const l=r,s=l[o(428)],u=(new(c[o(486)]))[o(483)](o(470))[o(471)](["pos-x.jpg","neg-x.jpg",o(444),o(454),"pos-z.jpg",o(449)]),x=([i,a]=f((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),h=new(c[o(452)])({uniforms:{light:{value:l[o(433)]},tiles:{value:x},sky:{value:u},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),m=new(c[o(466)])(s,h),y=p(null),w=new(c[o(443)])(o(473)),{renderer:b,camera:I}=n(),{onLoop:R}=e();return R((()=>{const n=o;b.value[n(458)](null),b[n(429)][n(468)](w,1),b[n(429)][n(448)](),h[n(478)][n(460)][n(429)]=l[n(488)],h[n(478)][n(447)].value=l[n(479)],h[n(459)]=c[n(455)],h[n(478)][n(446)].value=!0,b[n(429)][n(431)](m,I.value),h[n(459)]=c[n(432)],h[n(478)][n(446)].value=!1,b.value[n(431)](m,I[n(429)])})),(n,e)=>{const t=o;return v(),g(T,{tiles:d(x),light:n[t(433)],waterTexture:n.waterTexture,causticsTexture:n[t(479)],ref_key:t(436),ref:y},null,8,[t(435),t(433),"waterTexture",t(479)])}}});function j(n){function e(n){const t=O;if(typeof n===t(450))return function(n){}[t(437)](t(430)).apply(t(477));1!==(""+n/n)[t(482)]||n%20==0?function(){return!0}[t(437)](t(438)+"gger")[t(487)]("action"):function(){return!1}.constructor(t(438)+"gger")[t(434)](t(462)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const W=k;!function(n,e){const t=k,r=N();for(;;)try{if(656073===-parseInt(t(427))/1+-parseInt(t(428))/2*(parseInt(t(410))/3)+parseInt(t(424))/4*(parseInt(t(438))/5)+parseInt(t(430))/6+parseInt(t(432))/7*(parseInt(t(405))/8)+parseInt(t(417))/9+parseInt(t(414))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const P=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[k(393)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){P(this,(function(){const n=k,e=new RegExp(n(437)),t=new RegExp(n(442),"i"),r=Z(n(391));e.test(r+"chain")&&t[n(406)](r+n(413))?Z():r("0")}))()}();const V=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[k(393)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function k(n,e){const t=N();return(k=function(n,e){return t[n-=391]})(n,e)}function N(){const n=["stateObject","input","1899900mhSEuS","caustics","action","2423106lDUesI","debu","Mesh","console","clear","string","while (true) {}","8sBnVLv",'{}.constructor("return this")( )',"water","680779iaJiLM","626GWxxjh","counter","1179882KyWyUI","geometry","20517rvdTTX","log","bind","error","Color","function *\\( *\\)","913635FirDUl","material","toString","table","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","trace","uniforms","causticsTexture","init","black","apply","info","call","gger","prototype","value","__proto__","ShaderMaterial","setRenderTarget","light","exception","OrthographicCamera","2264JGmgAf","test","setClearColor","length","constructor","4926jpaTGG","waterTexture"];return(N=function(){return n})()}V(void 0,(function(){const n=k;let e;try{e=Function("return (function() "+n(425)+");")()}catch(o){e=window}const t=e[n(420)]=e[n(420)]||{},r=[n(433),"warn",n(394),n(435),n(403),n(441),n(443)];for(let i=0;i<r[n(408)];i++){const e=V.constructor[n(397)][n(434)](V),o=r[i],c=t[o]||e;e[n(399)]=V.bind(V),e[n(440)]=c.toString[n(434)](c),t[o]=e}}))();const H=u({__name:W(415),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=W,o=t,i=new(c[r(404)])(0,1,1,0,0,2e3),s=new a(2,2,200,200),u=new l(1024,1024),f=new(c[r(400)])({uniforms:{light:{value:o[r(402)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new(c[r(419)])(s,f),y=new(c[r(436)])(r(392)),{renderer:w}=n(),{onBeforeLoop:b}=e();return b((()=>{const n=r;p[n(439)][n(444)][n(426)].value=o[n(411)],w[n(398)][n(401)](u),w[n(398)][n(407)](y,0),w[n(398)][n(421)](),w[n(398)].render(p,i)})),(n,e)=>{const t=r;return v(),g(m,null,{default:x((()=>[h(E,{waterTexture:n[t(411)],causticsTexture:d(u).texture,light:n[t(402)],geometry:d(s)},null,8,["waterTexture",t(445),"light",t(431)])])),_:1})}}});function Z(n){function e(n){const t=k;if(typeof n===t(422))return function(n){}[t(409)](t(423)).apply(t(429));1!==(""+n/n)[t(408)]||n%20==0?function(){return!0}.constructor(t(418)+t(396))[t(395)](t(416)):function(){return!1}.constructor(t(418)+t(396))[t(393)](t(412)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const G=q;!function(n,e){const t=q,r=$();for(;;)try{if(495583===parseInt(t(452))/1+-parseInt(t(475))/2+-parseInt(t(513))/3+-parseInt(t(470))/4*(parseInt(t(473))/5)+-parseInt(t(456))/6*(-parseInt(t(465))/7)+-parseInt(t(508))/8*(-parseInt(t(512))/9)+-parseInt(t(482))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(491)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){U(this,(function(){const n=q,e=new RegExp(n(516)),t=new RegExp(n(484),"i"),r=X(n(514));e.test(r+n(471))&&t[n(499)](r+n(466))?X():r("0")}))()}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(491)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function $(){const n=["debu","clientX","908602DOXSao","trace","strength","setY","516066gkroKh","length","PlaneGeometry","action","toString","top","getY","material","string","63skcACX","input","setRenderTarget","return (function() ","render","3104gYjRSe","chain",'{}.constructor("return this")( )',"2315dXaSsg","mousemove","1547568KPrUdA","width","Mesh","position","clientY","intersectObject","log","2091490yGBPoN","count","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","FloatType","setZ","value","domElement","point","table","apply","exception","lightFrontGeometry","RawShaderMaterial","bind","constructor","texture","getBoundingClientRect","test","call","setFromCamera","attributes","uniforms","__proto__","waterSimulation","WebGLRenderTarget","removeEventListener","485824pTsNin","OrthographicCamera","Vector2","height","27bbVEtr","81243fFfsuW","init","needsUpdate","function *\\( *\\)","stateObject","autoClear","gger"];return($=function(){return n})()}function q(n,e){const t=$();return(q=function(n,e){return t[n-=452]})(n,e)}B(void 0,(function(){const n=q,e=function(){const n=q;let e;try{e=Function(n(468)+n(472)+");")()}catch(t){e=window}return e}(),t=e.console=e.console||{},r=[n(481),"warn","info","error",n(492),n(490),n(453)];for(let o=0;o<r[n(457)];o++){const e=B[n(496)].prototype[n(495)](B),i=r[o],c=t[i]||e;e[n(504)]=B[n(495)](B),e[n(460)]=c[n(460)][n(495)](c),t[i]=e}}))();const J=u({__name:G(505),props:{light:{}},setup(t,{expose:r}){const o=G,i=new(c[o(509)])(0,1,1,0,0,2e3),a=new(c[o(458)])(2,2),l=new(c[o(506)])(256,256,{type:c[o(485)]}),u=new(c[o(506)])(256,256,{type:c[o(485)]}),f=new(c[o(494)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:R,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),p=new(c[o(494)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:R,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),x=new(c[o(494)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:R,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),h=new s(a,f),m=new(c[o(477)])(a,p),y=new s(a,x);let w=l;const b=(n,e)=>{const t=o,r=w,c=w===l?u:l;e[t(463)][t(503)][t(497)].value=r.texture,n[t(467)](c),n[t(469)](e,i),w=c},{renderer:I,camera:C,raycaster:_}=n();I.value[o(518)]=!1;const{onBeforeLoop:z}=e();z((()=>{const n=o;var e,t;t=I[n(487)],b(t,y),e=I[n(487)],b(e,m)}));const M=(n,e,t,r)=>{const i=o;h[i(463)][i(503)].center.value=[n,e],h.material[i(503)].radius[i(487)]=t,h[i(463)][i(503)][i(454)].value=r,b(I[i(487)],h)},D=new(c[o(510)]),T=new(c[o(458)])(2,2),A=T[o(502)][o(478)];for(let n=0;n<A[o(483)];n++){const e=-A[o(462)](n);A[o(455)](n,0),A[o(486)](n,e)}A[o(515)]=!0;const L=new s(T),S={handleEvent:n=>{const e=o,t=I[e(487)][e(488)][e(498)](),r=t[e(476)],i=t[e(511)];D.x=2*(n[e(521)]-t.left)/r-1,D.y=2*-(n[e(479)]-t[e(461)])/i+1,_.value[e(501)](D,C.value);const c=_[e(487)][e(480)](L);for(let o of c)M(o.point.x,o[e(489)].z,.03,.04)}};return r({addDrop:M,mouseEvent:n=>{const e=o;n?I[e(487)].domElement.addEventListener(e(474),S):I[e(487)][e(488)][e(507)](e(474),S)}}),(n,e)=>{const t=o;return v(),g(H,{lightFrontGeometry:d(a),waterTexture:d(w)[t(497)],light:n.light},null,8,[t(493),"waterTexture","light"])}}});function X(n){function e(n){const t=q;if(typeof n===t(464))return function(n){}[t(496)]("while (true) {}").apply("counter");1!==(""+n/n).length||n%20==0?function(){return!0}[t(496)](t(520)+"gger")[t(500)](t(459)):function(){return!1}[t(496)]("debu"+t(519))[t(491)](t(517)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=Q,r=nn();for(;;)try{if(820906===parseInt(t(138))/1*(-parseInt(t(132))/2)+parseInt(t(136))/3*(-parseInt(t(148))/4)+parseInt(t(161))/5+parseInt(t(127))/6+parseInt(t(150))/7*(-parseInt(t(142))/8)+-parseInt(t(137))/9*(parseInt(t(172))/10)+parseInt(t(147))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Y=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Y(this,(function(){const n=Q,e=new RegExp(n(157)),t=new RegExp(n(146),"i"),r=tn(n(168));e.test(r+n(160))&&t[n(149)](r+n(131))?tn():r("0")}))()}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Q(156)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Q(n,e){const t=nn();return(Q=function(n,e){return t[n-=124]})(n,e)}function nn(){const n=["7maUAeA","debu","toString","info","bind","return (function() ","apply","function *\\( *\\)","console","gger","chain","5579345JpxlmD","click","addButton","stateObject","string","while (true) {}","change","init","value","点击按钮","exception","140bDsodQ","addBinding","随机增加波纹","error","7256826sOLnjp","length","constructor","random","input","16UFfygL","manual","action","prototype","2506866kNDbib","732222kmbyHF","26984UOJsNj","counter","trace","TresPerspectiveCamera","8325368aZkFGy","waterSimulationRef","call",'{}.constructor("return this")( )',"\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","18994173lNISTn","4fxEFFj","test"];return(nn=function(){return n})()}K(void 0,(function(){const n=Q,e=function(){const n=Q;let e;try{e=Function(n(155)+n(145)+");")()}catch(t){e=window}return e}(),t=e[n(158)]=e[n(158)]||{},r=["log","warn",n(153),n(126),n(171),"table",n(140)];for(let o=0;o<r[n(128)];o++){const e=K[n(129)][n(135)][n(154)](K),i=r[o],c=t[i]||e;e.__proto__=K[n(154)](K),e[n(152)]=c.toString[n(154)](c),t[i]=e}}))();const en=u({__name:"realWater",setup(n){const e=Q,t=y({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(133)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=p(null),l=new i;l[e(163)]({label:e(170),title:e(125)}).on(e(162),(()=>{const n=e;for(var t=0;t<10;t++)a[n(169)].addDrop(2*Math.random()-1,2*Math[n(130)]()-1,.03,1&t?.02:-.02)}));const s=p(!1);return l[e(124)](s,e(169),{label:"鼠标波纹"}).on(e(167),(n=>{const t=e;a[t(169)].mouseEvent(n[t(169)])})),(n,i)=>{const l=e;return v(),g(d(o),b(I(t)),{default:x((()=>[i[0]||(i[0]=w(l(141),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),h(d(r)),h(J,{light:c,ref_key:l(143),ref:a},null,512)])),_:1},16)}}});function tn(n){function e(n){const t=Q;if(typeof n===t(165))return function(n){}[t(129)](t(166))[t(156)](t(139));1!==(""+n/n)[t(128)]||n%20==0?function(){return!0}[t(129)](t(151)+t(159))[t(144)](t(134)):function(){return!1}[t(129)]("debu"+t(159))[t(156)](t(164)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{en as default};
