import{b2 as M,bm as Se,at as ce,au as ee,a0 as we,bq as ge,az as pe,k as se,ay as be,a5 as Be,w as le,aj as Te,o as Ae,c as xe,X as j,a9 as Me,aa as ze,a8 as Ce,aC as $e,a1 as Ee,ap as ke,bp as Ge,ao as Ne,bS as Ie,r as Re,v as Ve,D as ye,a7 as oe,bb as je,a as te,K as ne,ab as Pe,a_ as Le}from"./vendor.dUBjHEtG1712557423713.js";/**
 * @description Loop Subdivision Surface
 * @about       Smooth subdivision surface modifier for use with three.js BufferGeometry.
 * @author      Stephens Nunnally <@stevinz>
 * @license     MIT - Copyright (c) 2022 Stephens Nunnally
 * @source      https://github.com/stevinz/three-subdivide
 */const Oe=2,V=new M,S=new M,x=new M,fe=new M,ae=new M,v=new M,b=new M,y=new M,Q=new M,U=new M,Y=new M,ie=[new M,new M,new M],B=[new M,new M,new M],He=new Se;class L{static modify(e,o=1,n={}){if(arguments.length>3&&console.warn("LoopSubdivision.modify() now uses a parameter object. See readme for more info!"),typeof n!="object"&&(n={}),n.split===void 0&&(n.split=!0),n.uvSmooth===void 0&&(n.uvSmooth=!1),n.preserveEdges===void 0&&(n.preserveEdges=!1),n.flatOnly===void 0&&(n.flatOnly=!1),n.maxTriangles===void 0&&(n.maxTriangles=1/0),n.weight===void 0&&(n.weight=1),(isNaN(n.weight)||!isFinite(n.weight))&&(n.weight=1),n.weight=Math.max(0,Math.min(1,n.weight)),!re(e))return e;let u=e.clone();if(n.split){const g=L.edgeSplit(u);u.dispose(),u=g}for(let g=0;g<o;g++)if(u.attributes.position.count/3<n.maxTriangles){let p;n.flatOnly?p=L.flat(u,n):p=L.smooth(u,n),u.groups.forEach(c=>{p.addGroup(c.start*4,c.count*4,c.materialIndex)}),u.dispose(),u=p}return u}static edgeSplit(e){if(!re(e))return e;const o=e.index!==null?e.toNonIndexed():e.clone(),n=new ce,u=de(o),g=o.attributes.position.count,d=o.getAttribute("position"),p=o.getAttribute("normal"),c={},m=[],z={},$=[];for(let h=0;h<g;h+=3){v.fromBufferAttribute(d,h+0),b.fromBufferAttribute(d,h+1),y.fromBufferAttribute(d,h+2),fe.fromBufferAttribute(p,h);const C=G(v),T=G(b),E=G(y),F=He.set(v,b,y).getArea();if($.push(!Fe(F,0)),!$[h/3]){m.push([]);continue}qe(fe,v,b,y);const t=G(fe),s=["".concat(C,"_").concat(T,"_").concat(t),"".concat(T,"_").concat(C,"_").concat(t),"".concat(T,"_").concat(E,"_").concat(t),"".concat(E,"_").concat(T,"_").concat(t),"".concat(E,"_").concat(C,"_").concat(t),"".concat(C,"_").concat(E,"_").concat(t)],f=h/3;for(let l=0;l<s.length;l++)c[s[l]]||(c[s[l]]=[]),c[s[l]].push(f),z[s[l]]||((l===0||l===1)&&(z[s[l]]=v.distanceTo(b)),(l===2||l===3)&&(z[s[l]]=b.distanceTo(y)),(l===4||l===5)&&(z[s[l]]=y.distanceTo(v)));m.push([s[0],s[2],s[4]])}u.forEach(h=>{const C=o.getAttribute(h);if(!C)return;const T=X(C,h);n.setAttribute(h,new ee(T,C.itemSize))});const N=o.morphAttributes;for(const h in N){const C=[],T=N[h];for(let E=0,F=T.length;E<F;E++){if(T[E].count!==g)continue;const t=X(T[E],h,!0);C.push(new ee(t,T[E].itemSize))}n.morphAttributes[h]=C}return n.morphTargetsRelative=o.morphTargetsRelative,o.dispose(),n;function X(h,C,T=!1){const F=g*h.itemSize*4,t=new h.array.constructor(F),s=C==="position"&&!T&&o.groups.length>0;let f,l,r=0,I=0,i=h.itemSize;for(let _=0;_<g;_+=3){if(!$[_/3]){I+=3;continue}v.fromBufferAttribute(h,_+0),b.fromBufferAttribute(h,_+1),y.fromBufferAttribute(h,_+2);const R=_/3,k=m[R][0],O=m[R][1],D=m[R][2],H=c[k].length,J=c[O].length,P=c[D].length,q=H+J+P-3,K=r*3/i/3;if(q===0)A(t,r,i,v,b,y),r+=i*3;else{const Z=z[k],me=z[O],ve=z[D];(Z>me||J<=1)&&(Z>ve||P<=1)&&H>1?(S.copy(v).add(b).divideScalar(2),P>1?(x.copy(y).add(v).divideScalar(2),A(t,r,i,v,S,x),r+=i*3,A(t,r,i,S,y,x),r+=i*3):(A(t,r,i,v,S,y),r+=i*3),J>1?(x.copy(b).add(y).divideScalar(2),A(t,r,i,S,b,x),r+=i*3,A(t,r,i,x,y,S),r+=i*3):(A(t,r,i,b,y,S),r+=i*3)):(me>ve||P<=1)&&J>1?(S.copy(b).add(y).divideScalar(2),H>1?(x.copy(v).add(b).divideScalar(2),A(t,r,i,S,x,b),r+=i*3,A(t,r,i,x,S,v),r+=i*3):(A(t,r,i,b,S,v),r+=i*3),P>1?(x.copy(y).add(v).divideScalar(2),A(t,r,i,S,y,x),r+=i*3,A(t,r,i,x,v,S),r+=i*3):(A(t,r,i,y,v,S),r+=i*3)):P>1?(S.copy(y).add(v).divideScalar(2),J>1?(x.copy(b).add(y).divideScalar(2),A(t,r,i,y,S,x),r+=i*3,A(t,r,i,S,b,x),r+=i*3):(A(t,r,i,y,S,b),r+=i*3),H>1?(x.copy(v).add(b).divideScalar(2),A(t,r,i,v,x,S),r+=i*3,A(t,r,i,x,b,S),r+=i*3):(A(t,r,i,v,b,S),r+=i*3)):(A(t,r,i,v,b,y),r+=i*3)}s&&o.groups.forEach(Z=>{Z.start===_-I&&(f!==void 0&&l!==void 0&&n.addGroup(f,K-f,l),f=K,l=Z.materialIndex)}),I=0}const w=r*3/i,W=new h.array.constructor(w);for(let _=0;_<w;_++)W[_]=t[_];return s&&f!==void 0&&l!==void 0&&n.addGroup(f,r*3/i/3-f,l),W}}static flat(e,o={}){if(!re(e))return e;const n=e.index!==null?e.toNonIndexed():e.clone(),u=new ce,g=de(n),d=n.attributes.position.count;g.forEach(c=>{const m=n.getAttribute(c);m&&u.setAttribute(c,L.flatAttribute(m,d,o))});const p=n.morphAttributes;for(const c in p){const m=[],z=p[c];for(let $=0,N=z.length;$<N;$++)z[$].count===d&&m.push(L.flatAttribute(z[$],d,o));u.morphAttributes[c]=m}return u.morphTargetsRelative=n.morphTargetsRelative,n.dispose(),u}static flatAttribute(e,o,n={}){const g=o*e.itemSize*4,d=new e.array.constructor(g);let p=0,c=e.itemSize;for(let m=0;m<o;m+=3)v.fromBufferAttribute(e,m+0),b.fromBufferAttribute(e,m+1),y.fromBufferAttribute(e,m+2),Q.copy(v).add(b).divideScalar(2),U.copy(b).add(y).divideScalar(2),Y.copy(y).add(v).divideScalar(2),A(d,p,c,v,Q,Y),p+=c*3,A(d,p,c,b,U,Q),p+=c*3,A(d,p,c,y,Y,U),p+=c*3,A(d,p,c,Q,U,Y),p+=c*3;return new ee(d,e.itemSize)}static smooth(e,o={}){if(typeof o!="object"&&(o={}),o.uvSmooth===void 0&&(o.uvSmooth=!1),o.preserveEdges===void 0&&(o.preserveEdges=!1),!re(e))return e;const n=e.index!==null?e.toNonIndexed():e.clone(),u=L.flat(n,o),g=new ce,d=de(n),p=n.attributes.position.count,c=n.getAttribute("position"),m=u.getAttribute("position"),z={},$={},N={},X={};function h(t,s,f){$[t]||($[t]={}),$[t][s]||($[t][s]=[]),$[t][s].push(f)}function C(t,s){N[t]||(N[t]=[]),N[t].push(s)}function T(t,s){X[t]||(X[t]=new Set),X[t].add(s)}for(let t=0;t<p;t+=3){const s=G(B[0].fromBufferAttribute(c,t+0)),f=G(B[1].fromBufferAttribute(c,t+1)),l=G(B[2].fromBufferAttribute(c,t+2));h(s,f,t+1),h(s,l,t+2),h(f,s,t+0),h(f,l,t+2),h(l,s,t+0),h(l,f,t+1),Q.copy(B[0]).add(B[1]).divideScalar(2),U.copy(B[1]).add(B[2]).divideScalar(2),Y.copy(B[2]).add(B[0]).divideScalar(2);const r=G(Q),I=G(U),i=G(Y);C(r,t+2),C(I,t+0),C(i,t+1),T(s,r),T(s,i),T(f,r),T(f,I),T(l,I),T(l,i)}for(let t=0;t<u.attributes.position.count;t++){const s=G(ae.fromBufferAttribute(m,t));z[s]||(z[s]=[]),z[s].push(t)}d.forEach(t=>{const s=n.getAttribute(t),f=u.getAttribute(t);if(s===void 0||f===void 0)return;const l=F(t,s,f);g.setAttribute(t,new ee(l,f.itemSize))});const E=n.morphAttributes;for(const t in E){const s=[],f=E[t];for(let l=0,r=f.length;l<r;l++){if(f[l].count!==p)continue;const I=f[l],i=L.flatAttribute(f[l],f[l].count,o),w=F(t,I,i);s.push(new ee(w,i.itemSize))}g.morphAttributes[t]=s}return g.morphTargetsRelative=n.morphTargetsRelative,u.dispose(),n.dispose(),g;function F(t,s,f){const l=u.attributes.position.count*f.itemSize,r=new s.array.constructor(l);let I=0;for(let i=0;i<u.attributes.position.count;i+=3){for(let w=0;w<3;w++)if(t==="uv"&&!o.uvSmooth)B[w].fromBufferAttribute(f,i+w);else if(t==="normal"){ie[w].fromBufferAttribute(m,i+w);const W=G(ie[w]),_=z[W],R=Object.keys(_).length,k=.75/R,O=1-k*R;B[w].fromBufferAttribute(f,i+w),B[w].multiplyScalar(O),_.forEach(D=>{V.fromBufferAttribute(f,D),V.multiplyScalar(k),B[w].add(V)})}else{B[w].fromBufferAttribute(f,i+w),ie[w].fromBufferAttribute(m,i+w);const W=G(ie[w]),_=$[W],R=N[W];if(_){if(o.preserveEdges){const P=X[W];let q=!0;for(const K of P)N[K].length%2!==0&&(q=!1);if(!q)continue}const k=Object.keys(_).length,O=1/k*(5/8-Math.pow(3/8+1/4*Math.cos(2*Math.PI/k),2)),D=1/k/k,H=We(D,O,o.weight),J=1-H*k;B[w].multiplyScalar(J);for(let P in _){const q=_[P];V.set(0,0,0);for(let K=0;K<q.length;K++)V.add(ae.fromBufferAttribute(s,q[K]));V.divideScalar(q.length),V.multiplyScalar(H),B[w].add(V)}}else if(R&&R.length===2){const k=R.length,O=.125,D=1-O*k;B[w].multiplyScalar(D),R.forEach(H=>{V.fromBufferAttribute(s,H),V.multiplyScalar(O),B[w].add(V)})}}A(r,I,f.itemSize,B[0],B[1],B[2]),I+=f.itemSize*3}return r}}}const _e=Math.pow(10,Oe);function Fe(a,e,o=1e-5){return a<e+o&&a>e-o}function ue(a,e=_e){let o=De(a*e);return o==0&&(o=0),"".concat(o)}function G(a,e=_e){return"".concat(ue(a.x,e),",").concat(ue(a.y,e),",").concat(ue(a.z,e))}function We(a,e,o){return(1-o)*a+o*e}function De(a){return a+(a>0?.5:-.5)<<0}function qe(a,e,o,n){ae.subVectors(e,o),a.subVectors(o,n),a.cross(ae).normalize()}function de(a){const e=["position","normal","uv"],o=Object.keys(a.attributes);return Array.from(new Set(e.concat(o)))}function A(a,e,o,n,u,g){o>=1&&(a[e+0+o*0]=n.x,a[e+0+o*1]=u.x,a[e+0+o*2]=g.x),o>=2&&(a[e+1+o*0]=n.y,a[e+1+o*1]=u.y,a[e+1+o*2]=g.y),o>=3&&(a[e+2+o*0]=n.z,a[e+2+o*1]=u.z,a[e+2+o*2]=g.z),o>=4&&(a[e+3+o*0]=n.w,a[e+3+o*1]=u.w,a[e+3+o*2]=g.w)}function re(a){return a===void 0?(console.warn("LoopSubdivision: Geometry provided is undefined"),!1):a.isBufferGeometry?a.attributes.position===void 0?(console.warn("LoopSubdivision: Geometry provided missing required 'position' attribute"),!1):(a.attributes.normal===void 0&&a.computeVertexNormals(),!0):(console.warn("LoopSubdivision: Geometry provided is not 'BufferGeometry' type"),!1)}const Ke=["scale"],he=we({__name:"shineShader",props:{srcMesh:{},scale:{default:1.2},color:{default:"#ffff00"},subdivision:{type:Boolean,default:!0},c:{default:1.1},p:{default:1.4},side:{default:ge},blending:{default:pe}},setup(a){const e=a,o=se(),n={uniforms:{c:{type:"f",value:e.c},p:{type:"f",value:e.p},glowColor:{type:"c",value:new be(e.color)},viewVector:{type:"v3",value:{x:0,y:0,z:0}}},vertexShader:"\n          uniform vec3 viewVector;\n          uniform float c;\n          uniform float p;\n          varying float intensity;\n          void main() {\n            vec3 vNormal = normalize( normalMatrix * normal);\n            vec3 vNormel = normalize( normalMatrix * viewVector);\n            intensity = pow( c - dot(vNormal, vNormel), p );\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0);\n          }\n            ",fragmentShader:"\n          uniform vec3 glowColor;\n          varying float intensity;\n          void main() \n          {\n          	vec3 glow = glowColor * intensity;\n						if(intensity < 1.0){\n            	gl_FragColor = vec4( glow, 1.0 );\n						}\n          }\n        ",side:e.side,transparent:!0,depthWrite:!1,depthTest:!0,blending:e.blending};Be(()=>{if(e.srcMesh&&!o.value.geometry.attributes.position){let d=e.srcMesh.geometry.clone();e.subdivision&&(d=L.modify(d,2)),o.value.geometry=d,o.value.position.copy(e.srcMesh.position)}e.color&&(n.uniforms.glowColor.value=new be(e.color)),e.c&&(n.uniforms.c.value=e.c),e.p&&(n.uniforms.p.value=e.p)}),le(()=>e.subdivision,d=>{let p=e.srcMesh.geometry.clone();d&&(p=L.modify(p,2)),o.value.geometry=p}),le(()=>e.side,d=>{o.value.material.side=d}),le(()=>e.blending,d=>{o.value.material.blending=d});const{onLoop:u}=Ce(),{camera:g}=Te();return u(()=>{g.value&&o.value&&(n.uniforms.viewVector.value=new M().subVectors(g.value.position,o.value.position))}),(d,p)=>(Ae(),xe("TresMesh",{ref_key:"TSGref",ref:o,scale:e.scale},[j("TresShaderMaterial",Me(ze(n)),null,16)],8,Ke))}}),Xe=j("TresPerspectiveCamera",{position:[5,5,5]},null,-1),Je=j("TresAmbientLight",{intensity:1},null,-1),Qe=j("TresGridHelper",{args:[10,10]},null,-1),Ue=j("TresSphereGeometry",{args:[1,32,16]},null,-1),Ye=["map"],Ze=["map"],et=j("TresBoxGeometry",{args:[1,1,1,1,1]},null,-1),tt=j("TresMeshBasicMaterial",{color:"#0ff"},null,-1),ot=[et,tt],it=we({__name:"shader",async setup(a){let e,o;const n={clearColor:"#222"},u=se(),g=se(),d=se(),p=([e,o]=$e(()=>je(["./plugins/earthSample/image/earthA/earth.jpg","logo.png"])),e=await e,o(),e),c=Ee({scale:1.6,color:"#00dfff",subdivision:!0,c:1.1,p:1.4,side:ge,blending:pe}),m=new ke({title:"参数",expanded:!0});return m.addBinding(c,"color",{label:"颜色"}),m.addBinding(c,"scale",{label:"大小",min:1,max:3,step:.2}),m.addBinding(c,"subdivision",{label:"边缘处理"}),m.addBinding(c,"c",{label:"c",min:0,max:2,step:.1}),m.addBinding(c,"p",{label:"p",min:0,max:8,step:.2}),m.addBinding(c,"side",{options:{FrontSide:ge,BackSide:Ge,DoubleSide:Ne}}),m.addBinding(c,"blending",{options:{AdditiveBlending:pe,NormalBlending:Ie}}),(z,$)=>{const N=Re("TresCanvas");return Ae(),Ve(N,oe(n,{"window-size":""}),{default:ye(()=>[Xe,Je,te(ne(Pe)),Qe,j("TresMesh",{ref_key:"TresMeshRefA",ref:u,position:[-2,1,0]},[Ue,j("TresMeshBasicMaterial",{map:ne(p)[0]},null,8,Ye)],512),te(he,oe({srcMesh:u.value},c),null,16,["srcMesh"]),te(ne(Le),{ref_key:"TreBoxRef",ref:d,args:[1,1,1],position:[2,1,0]},{default:ye(()=>[j("TresMeshBasicMaterial",{map:ne(p)[1]},null,8,Ze)]),_:1},512),te(he,oe({srcMesh:d.value&&d.value.value},c),null,16,["srcMesh"]),j("TresMesh",{ref_key:"TresMeshRefB",ref:g,position:[0,1,-2]},ot,512),te(he,oe({srcMesh:g.value},c),null,16,["srcMesh"])]),_:1},16)}}});export{it as default};
