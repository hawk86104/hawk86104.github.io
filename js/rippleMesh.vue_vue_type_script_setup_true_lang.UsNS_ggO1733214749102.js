import{_ as n}from"./three.aWgA1gea1733214749102.js";import{e as t}from"./@tresjs.lftldzUe1733214749102.js";import{g as o}from"./utils.Lq-nxkh31733214749102.js";import{d as e,b as r,a3 as i,o as s,D as c,J as a,u,aj as l,ak as f}from"./@vue.-THQH3GC1733214749102.js";const p=m;!function(n,t){const o=m,e=y();for(;;)try{if(164344===-parseInt(o(249))/1+parseInt(o(270))/2*(parseInt(o(259))/3)+parseInt(o(242))/4+parseInt(o(240))/5+-parseInt(o(229))/6*(parseInt(o(243))/7)+-parseInt(o(239))/8*(parseInt(o(266))/9)+-parseInt(o(265))/10)break;e.push(e.shift())}catch(r){e.push(e.shift())}}();const v=function(){let n=!0;return function(t,o){const e=n?function(){if(o){const n=o[m(223)](t,arguments);return o=null,n}}:function(){};return n=!1,e}}();function m(n,t){const o=y();return(m=function(n,t){return o[n-=219]})(n,t)}!function(){v(this,(function(){const n=m,t=new RegExp(n(219)),o=new RegExp(n(256),"i"),e=x("init");t[n(271)](e+n(241))&&o[n(271)](e+n(257))?x():e("0")}))()}();const d=function(){let n=!0;return function(t,o){const e=n?function(){if(o){const n=o.apply(t,arguments);return o=null,n}}:function(){};return n=!1,e}}();d(void 0,(function(){const n=m,t=function(){const n=m;let t;try{t=Function(n(255)+'{}.constructor("return this")( ));')()}catch(o){t=window}return t}(),o=t.console=t[n(247)]||{},e=["log",n(236),"info","error",n(220),"table",n(234)];for(let r=0;r<e[n(275)];r++){const t=d[n(251)][n(250)][n(227)](d),i=e[r],s=o[i]||t;t[n(269)]=d.bind(d),t[n(225)]=s.toString[n(227)](s),o[i]=t}}))();const h=[p(232),"uv"];function y(){const n=["448640twqBPl","9ttCNlL","color","height","__proto__","26Zrfbby","test","counter","\nprecision lowp float;\nprecision lowp int;\n","speed","length","pv2","function *\\( *\\)","exception","value","call","apply","action","toString","num","bind","#ffff00","6SrkFiY","positionSrc","time","position","DoubleSide","trace","tresMeshRef","warn","\n}\n","gger","476888JiDBWi","664450SVgUqh","chain","869792GtGJlG","748559WYASFh","set","ShaderChunk","stateObject","console","Color","199677tTWXdh","prototype","constructor","uniforms","opacity","while (true) {}","return (function() ","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","input","fog_vertex","51945VyYRpC","string","uvs","debu","fog_pars_vertex","TresShaderMaterial"];return(y=function(){return n})()}const g=e({__name:"rippleMesh",props:{positionSrc:{default:[{x:0,y:0},{x:10,y:10}]},color:{default:p(228)},opacity:{default:.8},height:{default:100},num:{default:8},speed:{default:.15}},setup(e){const v=p,m=e,d=r(),y={side:n[v(233)],transparent:!0,depthWrite:!1,depthTest:!0,vertexShader:v(273)+n[v(245)][v(263)]+"\nvarying vec2 vUv;\nvoid main() {\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    "+n[v(245)][v(258)]+v(237),fragmentShader:"\n  precision lowp float;\n  precision lowp int;\n  uniform float time;\n  uniform float opacity;\n  uniform vec3 color;\n  uniform float num;\n  uniform float speed;\n  varying vec2 vUv;\n  void main() {\n    vec4 fragColor = vec4(0.);\n    float sin = sin((vUv.y - time * speed) * 10. * num);\n    float high = 0.92;\n    float medium = 0.4;\n    if (sin > high) {\n      fragColor = vec4(mix(vec3(.8, 1., 1.), color, (1. - sin) / (1. - high)), 1.);\n    } else if(sin > medium) {\n      fragColor = vec4(color, mix(1., 0., 1.-(sin - medium) / (high - medium)));\n    } else {\n      fragColor = vec4(color, 0.);\n    }\n    vec3 fade = mix(color, vec3(0., 0., 0.), vUv.y);\n    fragColor = mix(fragColor, vec4(fade, 1.), 0.85);\n    gl_FragColor = vec4(fragColor.rgb, fragColor.a * opacity * (1. - vUv.y));\n  }\n\t",uniforms:{time:{type:v(276),value:0},color:{type:v(261),value:new(n[v(248)])(m[v(267)])},opacity:{type:v(276),value:m[v(253)]},num:{type:v(276),value:m[v(226)]},speed:{type:"pv2",value:m[v(274)]}}};let g=null,x=null;const{centerPoint:w,points:_}=o(m[v(230)]);!function(n=[],t){const o=v,e=[],r=[];for(let i=0,s=e.length,c=r[o(275)];i<n.length-1;i++){let o=1,a=n[i],u=n[i+1];e[s++]=a.x,e[s++]=0,e[s++]=a.y,r[c++]=0,r[c++]=0,e[s++]=u.x,e[s++]=0,e[s++]=u.y,r[c++]=1,r[c++]=0,e[s++]=a.x,e[s++]=t,e[s++]=a.y,r[c++]=0,r[c++]=o,e[s++]=a.x,e[s++]=t,e[s++]=a.y,r[c++]=0,r[c++]=o,e[s++]=u.x,e[s++]=0,e[s++]=u.y,r[c++]=1,r[c++]=0,e[s++]=u.x,e[s++]=t,e[s++]=u.y,r[c++]=1,r[c++]=o}g=new Float32Array(e),x=new Float32Array(r)}(_,m[v(268)]);const{onLoop:C}=t();return C((({delta:n})=>{const t=v;y[t(252)][t(231)][t(221)]+=n})),i((()=>{const t=v;m.color&&(y[t(252)][t(267)][t(221)]=new(n[t(248)])(m[t(267)])),m.opacity&&(y[t(252)][t(253)][t(221)]=m[t(253)]),m.num&&(y[t(252)][t(226)][t(221)]=m[t(226)]),m[t(274)]&&(y.uniforms[t(274)][t(221)]=m.speed),d[t(221)]&&d[t(221)][t(232)][t(244)](w.x,d[t(221)][t(232)].y,w.y)})),(n,t)=>{const o=v;return s(),c("TresMesh",{renderOrder:2200,ref_key:o(235),ref:d},[a("TresBufferGeometry",{position:[u(g),3],uv:[u(x),2]},null,8,h),a(o(264),l(f(y)),null,16)],512)}}});function x(n){function t(n){const o=m;if(typeof n===o(260))return function(n){}.constructor(o(254))[o(223)](o(272));1!==(""+n/n)[o(275)]||n%20==0?function(){return!0}.constructor(o(262)+o(238))[o(222)](o(224)):function(){return!1}.constructor(o(262)+o(238)).apply(o(246)),t(++n)}try{if(n)return t;t(0)}catch(o){}}export{g as _};
