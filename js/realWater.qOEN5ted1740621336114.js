import{m as n,e,a as t,o as r,f as o}from"./@tresjs.Td0X-dew1740621336114.js";import{P as i}from"./tweakpane.yDiyAAkA1740621336114.js";import{_ as c,aW as a,r as l,aM as s,W as u,o as f,V as p}from"./three.sXv6UbbL1740621336114.js";import{d as v,a3 as g,b as d,o as x,f as h,u as m,g as y,j as w,al as b,r as R,N as I,aj as C,ak as _}from"./@vue.NRI7TcgI1740621336114.js";import"./@vueuse.cgJUSr_21740621336114.js";var z="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const M=A;!function(n,e){const t=A,r=L();for(;;)try{if(447483===parseInt(t(522))/1*(-parseInt(t(489))/2)+parseInt(t(501))/3*(parseInt(t(526))/4)+-parseInt(t(497))/5*(-parseInt(t(506))/6)+parseInt(t(508))/7*(-parseInt(t(499))/8)+-parseInt(t(513))/9*(-parseInt(t(498))/10)+-parseInt(t(518))/11*(parseInt(t(520))/12)+parseInt(t(488))/13*(parseInt(t(490))/14))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const D=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[A(532)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){D(this,(function(){const n=A,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(503),"i"),r=S(n(527));e.test(r+n(487))&&t[n(504)](r+n(517))?S():r("0")}))()}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[A(532)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function L(){const n=["warn","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","test","table","2544mGtdRt","waterTexture","373604ueuEKo","length","debu","value","setIndex","15246REyNxJ","BufferAttribute","uniforms","exception","input","11yTYpHW","constructor","7158144FuIRLl","while (true) {}","93641nykSzS","call","error","render","353016kVFuzg","init","__proto__","position","pool","counter","apply","log","tiles","console","gger","chain","9210058JvoKIe","2WRmXsc","14NEmwUn","toString","stateObject","bind","light","string","BufferGeometry","8005imuoYw","950uhzgof","88OzCKUW","FrontSide","6DgGVdo"];return(L=function(){return n})()}function A(n,e){const t=L();return(A=function(n,e){return t[n-=487]})(n,e)}T(void 0,(function(){const n=A,e=function(){let n;try{n=Function('return (function() {}.constructor("return this")( ));')()}catch(e){n=window}return n}(),t=e[n(535)]=e.console||{},r=[n(533),n(502),"info",n(524),n(516),n(505),"trace"];for(let o=0;o<r[n(509)];o++){const e=T.constructor.prototype[n(493)](T),i=r[o],c=t[i]||e;e[n(528)]=T[n(493)](T),e[n(491)]=c[n(491)][n(493)](c),t[i]=e}}))();const O=v({__name:M(530),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=M,o=t,i=new(c[r(496)]),s=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),u=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i.setAttribute(r(529),new(c[r(514)])(s,3)),i[r(512)](new(c[r(514)])(u,1));const f=new a({uniforms:{light:{value:o[r(494)]},tiles:{value:o[r(534)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(500)]}),p=new l(i,f),{renderer:v,camera:g}=n(),{onAfterLoop:d}=e();return d((()=>{((n,e)=>{const t=r;f[t(515)].water[t(511)]=n,f[t(515)].causticTex[t(511)]=e,v[t(511)][t(525)](p,g[t(511)])})(o[r(507)],o.causticsTexture)})),(n,e)=>null}});function S(n){function e(n){const t=A;if(typeof n===t(495))return function(n){}[t(519)](t(521)).apply(t(531));1!==(""+n/n)[t(509)]||n%20==0?function(){return!0}[t(519)](t(510)+"gger")[t(523)]("action"):function(){return!1}[t(519)](t(510)+t(536)).apply(t(492)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const E=W;!function(n,e){const t=W,r=P();for(;;)try{if(759769===parseInt(t(309))/1+-parseInt(t(292))/2+-parseInt(t(276))/3+parseInt(t(282))/4*(parseInt(t(326))/5)+parseInt(t(277))/6*(parseInt(t(280))/7)+-parseInt(t(312))/8+parseInt(t(327))/9*(parseInt(t(319))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[W(302)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){F(this,(function(){const n=W,e=new RegExp(n(287)),t=new RegExp(n(303),"i"),r=V(n(278));e.test(r+n(321))&&t.test(r+"input")?V():r("0")}))()}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[W(302)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function W(n,e){const t=P();return(W=function(n,e){return t[n-=276]})(n,e)}function P(){const n=["neg-x.jpg","tiles","11512632IIavgo","setClearColor","neg-y.jpg","BackSide","neg-z.jpg","side","toString","10pLSPGh","bind","chain","action","uniforms","exception","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","1175iHRGWa","2225511UZwpJh","underwater","return (function() ","warn","FrontSide","length","pos-z.jpg","light","geometry","causticsTexture","white","2191215XVhaKH","1044ODyiGv","init","pooRef","49231ioCNMH","stateObject","21300URhNUD","water","RawShaderMaterial","prototype","Color","function *\\( *\\)","string","debu","call","causticTex","1510716pWNBIr","trace","while (true) {}","counter","setPath","constructor","Mesh","value","clear","console","apply","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","load","table","error","pos-x.jpg","log","962215VJQxmZ"];return(P=function(){return n})()}j(void 0,(function(){const n=W,e=function(){const n=W;let e;try{e=Function(n(329)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(301)]=e[n(301)]||{},r=[n(308),n(330),"info",n(306),n(324),n(305),n(293)];for(let o=0;o<r.length;o++){const e=j.constructor[n(285)][n(320)](j),i=r[o],c=t[i]||e;e.__proto__=j[n(320)](j),e[n(318)]=c[n(318)][n(320)](c),t[i]=e}}))();const k=v({__name:E(283),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=E;let i,a;const l=r,u=l[o(335)],f=(new s)[o(296)](o(325))[o(304)]([o(307),o(310),"pos-y.jpg",o(314),o(333),o(316)]),p=([i,a]=g((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),v=new(c[o(284)])({uniforms:{light:{value:l[o(334)]},tiles:{value:p},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new(c[o(298)])(u,v),w=d(null),b=new(c[o(286)])(o(337)),{renderer:R,camera:I}=n(),{onLoop:C}=e();return C((()=>{const n=o;R[n(299)].setRenderTarget(null),R[n(299)][n(313)](b,1),R[n(299)][n(300)](),v[n(323)][n(283)][n(299)]=l.waterTexture,v.uniforms[n(291)][n(299)]=l[n(336)],v[n(317)]=c[n(331)],v[n(323)][n(328)].value=!0,R[n(299)].render(y,I.value),v[n(317)]=c[n(315)],v[n(323)][n(328)].value=!1,R[n(299)].render(y,I[n(299)])})),(n,e)=>{const t=o;return x(),h(O,{tiles:m(p),light:n.light,waterTexture:n.waterTexture,causticsTexture:n.causticsTexture,ref_key:t(279),ref:w},null,8,[t(311),t(334),"waterTexture","causticsTexture"])}}});function V(n){function e(n){const t=W;if(typeof n===t(288))return function(n){}[t(297)](t(294))[t(302)](t(295));1!==(""+n/n)[t(332)]||n%20==0?function(){return!0}[t(297)](t(289)+"gger")[t(290)](t(322)):function(){return!1}[t(297)](t(289)+"gger")[t(302)](t(281)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const G=H;function H(n,e){const t=B();return(H=function(n,e){return t[n-=453]})(n,e)}!function(n,e){const t=H,r=B();for(;;)try{if(180152===parseInt(t(462))/1*(-parseInt(t(484))/2)+-parseInt(t(468))/3+parseInt(t(464))/4*(parseInt(t(501))/5)+-parseInt(t(497))/6+-parseInt(t(482))/7*(-parseInt(t(479))/8)+-parseInt(t(496))/9*(parseInt(t(461))/10)+-parseInt(t(485))/11*(-parseInt(t(503))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const N=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[H(500)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){N(this,(function(){const n=H,e=new RegExp(n(458)),t=new RegExp(n(454),"i"),r=Y(n(493));e[n(457)](r+"chain")&&t[n(457)](r+n(471))?Y():r("0")}))()}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[H(500)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function B(){const n=["length","info","init","PlaneGeometry","material","549lanOxk","100530eGflXr","gger","toString","apply","5FSrcqe","black","562404DdhgrE","log","WebGLRenderTarget","constructor","exception","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","water","action","test","function *\\( *\\)","string","prototype","21470sldmgS","74KYZXkl","ShaderMaterial","879916maYurt","Color","render","debu","643005YjVDhL","value","causticsTexture","input","setClearColor","return (function() ","console","while (true) {}","trace","caustics","counter","1062096TuwkcS","bind","stateObject","7ldElDM","__proto__","7546ZJBGcG","110eUgKCk","light","OrthographicCamera","uniforms","waterTexture","Mesh"];return(B=function(){return n})()}Z(void 0,(function(){const n=H,e=function(){const n=H;let e;try{e=Function(n(473)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(474)]=e.console||{},r=[n(504),"warn",n(492),"error",n(453),"table",n(476)];for(let o=0;o<r[n(491)];o++){const e=Z.constructor[n(460)][n(480)](Z),i=r[o],c=t[i]||e;e[n(483)]=Z.bind(Z),e[n(499)]=c[n(499)][n(480)](c),t[i]=e}}))();const K=v({__name:G(477),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=G,o=t,i=new(c[r(487)])(0,1,1,0,0,2e3),a=new(c[r(494)])(2,2,200,200),l=new(c[r(505)])(1024,1024),s=new(c[r(463)])({uniforms:{light:{value:o[r(486)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),u=new(c[r(490)])(a,s),f=new(c[r(465)])(r(502)),{renderer:p}=n(),{onBeforeLoop:v}=e();return v((()=>{const n=r;u[n(495)][n(488)][n(455)][n(469)]=o[n(489)],p[n(469)].setRenderTarget(l),p[n(469)][n(472)](f,0),p[n(469)].clear(),p[n(469)][n(466)](u,i)})),(n,e)=>{const t=r;return x(),h(b,null,{default:y((()=>[w(k,{waterTexture:n[t(489)],causticsTexture:m(l).texture,light:n[t(486)],geometry:m(a)},null,8,[t(489),t(470),t(486),"geometry"])])),_:1})}}});function Y(n){function e(n){const t=H;if(typeof n===t(459))return function(n){}[t(506)](t(475))[t(500)](t(478));1!==(""+n/n)[t(491)]||n%20==0?function(){return!0}[t(506)](t(467)+t(498)).call(t(456)):function(){return!1}[t(506)](t(467)+"gger")[t(500)](t(481)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const U=J;!function(n,e){const t=J,r=q();for(;;)try{if(508502===-parseInt(t(298))/1*(-parseInt(t(348))/2)+parseInt(t(356))/3*(-parseInt(t(338))/4)+-parseInt(t(317))/5+-parseInt(t(294))/6+parseInt(t(351))/7+-parseInt(t(316))/8+-parseInt(t(334))/9*(-parseInt(t(346))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const $=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[J(297)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){$(this,(function(){const n=J,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(289),"i"),r=nn(n(344));e[n(337)](r+n(303))&&t[n(337)](r+"input")?nn():r("0")}))()}();const Q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[J(297)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function q(){const n=["WebGLRenderTarget","40lmMfSp","info","219938QGrKzo","attributes","stateObject","3731532nceBgR","OrthographicCamera","removeEventListener","while (true) {}","autoClear","294759cUwtEN","RawShaderMaterial","needsUpdate","height","trace","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","point","__proto__","length","texture","2998206KKixQN","Mesh","waterTexture","apply","8oQTIRU","count","uniforms","table","getBoundingClientRect","chain","console","width","left","clientY","call","prototype","material",'{}.constructor("return this")( )',"constructor","setZ","domElement","counter","2022392OGgfNv","2979220OnqvvW","error","waterSimulation","gger","action","render","toString","intersectObject","setRenderTarget","log","debu","bind","position","mousemove","FloatType","string","getY","1441179RXArvk","PlaneGeometry","setY","test","8JWoEGn","value","top","warn","clientX","return (function() ","init"];return(q=function(){return n})()}function J(n,e){const t=q();return(J=function(n,e){return t[n-=289]})(n,e)}Q(void 0,(function(){const n=J;let e;try{e=Function(n(343)+n(311)+");")()}catch(o){e=window}const t=e[n(304)]=e[n(304)]||{},r=[n(326),n(341),n(347),n(318),"exception",n(301),n(360)];for(let i=0;i<r.length;i++){const e=Q[n(312)][n(309)][n(328)](Q),o=r[i],c=t[o]||e;e[n(291)]=Q[n(328)](Q),e[n(323)]=c.toString.bind(c),t[o]=e}}))();const X=v({__name:U(319),props:{light:{}},setup(t,{expose:r}){const o=U,i=new(c[o(352)])(0,1,1,0,0,2e3),s=new(c[o(335)])(2,2),v=new u(256,256,{type:f}),g=new(c[o(345)])(256,256,{type:c[o(331)]}),d=new a({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),y=new a({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),w=new(c[o(357)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),b=new l(s,d),R=new(c[o(295)])(s,y),I=new l(s,w);let C=v;const _=(n,e)=>{const t=o,r=C,c=C===v?g:v;e[t(310)].uniforms[t(293)][t(339)]=r[t(293)],n[t(325)](c),n[t(322)](e,i),C=c},{renderer:M,camera:D,raycaster:T}=n();M[o(339)][o(355)]=!1;const{onBeforeLoop:L}=e();L((()=>{const n=o;var e,t;t=M[n(339)],_(t,I),e=M[n(339)],_(e,R)}));const A=(n,e,t,r)=>{const i=o;b[i(310)][i(300)].center[i(339)]=[n,e],b.material[i(300)].radius[i(339)]=t,b[i(310)].uniforms.strength[i(339)]=r,_(M[i(339)],b)},O=new p,S=new(c[o(335)])(2,2),E=S[o(349)][o(329)];for(let n=0;n<E[o(299)];n++){const e=-E[o(333)](n);E[o(336)](n,0),E[o(313)](n,e)}E[o(358)]=!0;const F=new(c[o(295)])(S),j={handleEvent:n=>{const e=o,t=M[e(339)][e(314)][e(302)](),r=t[e(305)],i=t[e(359)];O.x=2*(n[e(342)]-t[e(306)])/r-1,O.y=2*-(n[e(307)]-t[e(340)])/i+1,T[e(339)].setFromCamera(O,D[e(339)]);const c=T[e(339)][e(324)](F);for(let o of c)A(o[e(290)].x,o[e(290)].z,.03,.04)}};return r({addDrop:A,mouseEvent:n=>{const e=o;n?M[e(339)].domElement.addEventListener(e(330),j):M.value[e(314)][e(353)](e(330),j)}}),(n,e)=>{const t=o;return x(),h(K,{lightFrontGeometry:m(s),waterTexture:m(C).texture,light:n.light},null,8,["lightFrontGeometry",t(296),"light"])}}});function nn(n){function e(n){const t=J;if(typeof n===t(332))return function(n){}[t(312)](t(354))[t(297)](t(315));1!==(""+n/n)[t(292)]||n%20==0?function(){return!0}[t(312)](t(327)+t(320))[t(308)](t(321)):function(){return!1}[t(312)](t(327)+t(320)).apply(t(350)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function en(){const n=["\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","return (function() ","table","debu","3493635zcIjac","__proto__","addDrop","counter","点击按钮","mouseEvent","console","info","init","bind","鼠标波纹","length","gger","1sQYLso","warn","click","31821489xjTKOP","1703082inQtgY","TresPerspectiveCamera","action","exception","stateObject","trace","10MVTfQq","2678702kEeAzK","manual","while (true) {}","constructor","error","addBinding","waterSimulationRef","input","apply","function *\\( *\\)","change","value","random","4510752xnbZWD","2159787ScwRku","test","20180LuYbLj","prototype","realWater","toString"];return(en=function(){return n})()}const tn=on;!function(n,e){const t=on,r=en();for(;;)try{if(714389===parseInt(t(256))/1*(-parseInt(t(267))/2)+-parseInt(t(243))/3+-parseInt(t(235))/4+-parseInt(t(266))/5*(parseInt(t(260))/6)+-parseInt(t(233))/7+parseInt(t(232))/8+parseInt(t(259))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(275)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function on(n,e){const t=en();return(on=function(n,e){return t[n-=230]})(n,e)}!function(){rn(this,(function(){const n=on,e=new RegExp(n(276)),t=new RegExp(n(239),"i"),r=ln(n(251));e[n(234)](r+"chain")&&t[n(234)](r+n(274))?ln():r("0")}))()}();const cn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(275)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();cn(void 0,(function(){const n=on,e=function(){const n=on;let e;try{e=Function(n(240)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e.console=e[n(249)]||{},r=["log",n(257),n(250),n(271),n(263),n(241),n(265)];for(let o=0;o<r[n(254)];o++){const e=cn[n(270)][n(236)][n(252)](cn),i=r[o],c=t[i]||e;e[n(244)]=cn[n(252)](cn),e.toString=c[n(238)][n(252)](c),t[i]=e}}))();const an=v({__name:tn(237),setup(n){const e=tn,t=R({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(268)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=d(null),l=new i;l.addButton({label:e(247),title:"随机增加波纹"}).on(e(258),(()=>{const n=e;for(var t=0;t<10;t++)a[n(230)][n(245)](2*Math.random()-1,2*Math[n(231)]()-1,.03,1&t?.02:-.02)}));const s=d(!1);return l[e(272)](s,e(230),{label:e(253)}).on(e(277),(n=>{const t=e;a[t(230)][t(248)](n.value)})),(n,i)=>{const l=e;return x(),h(m(o),C(_(t)),{default:y((()=>[i[0]||(i[0]=I(l(261),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),w(m(r)),w(X,{light:c,ref_key:l(273),ref:a},null,512)])),_:1},16)}}});function ln(n){function e(n){const t=on;if("string"==typeof n)return function(n){}[t(270)](t(269))[t(275)](t(246));1!==(""+n/n)[t(254)]||n%20==0?function(){return!0}.constructor("debu"+t(255)).call(t(262)):function(){return!1}[t(270)](t(242)+t(255))[t(275)](t(264)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{an as default};
