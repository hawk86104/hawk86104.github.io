import{ad as t,B as e,n as i,F as r,V as s,M as o,j as a,y as n,o as h,k as l,z as c,u as d,x as m,cy as p}from"./three.rXKzP9fQ1763540743861.js";import{g as u,b as g,t as f}from"./@mapbox.DBNDgF_h1763540743861.js";import{c as w,d as x,a as v}from"./three-mesh-bvh.BY-MaG5X1763540743861.js";import{F as y}from"./Fetch.CIMEiaKn1763540743861.js";import{U as T,a as b,M,l as P}from"./CoordUtil.BerJhsxi1763540743861.js";import{B as C}from"./three-custom-shader-material.C6taB_aY1763540743861.js";class _ extends t{constructor(){super(),this.isDisposed=!1,this.isReady=!1,this.childrenTiles=[],this.boundingBoxWorld=new e}init(t,e,i){this.tileNo=t,Object.freeze(this.tileNo),this.map=e,this.parentTile=i,this.visible=!1,this.renderOrder=t[2],this.ready()}async ready(){if(this.content=await this.map.provider.getTile(this.tileNo),!this.isDisposed){if(this.add(this.content),this.boundingBoxWorld.setFromObject(this.content).applyMatrix4(this.matrixWorld.makeRotationX(-Math.PI/2)),this.map.add(this),this.visible=!0,this.isReady=!0,this.parentTile){const t=this.parentTile.childrenTiles;let e=0;for(let i=0;i<t.length;i++)t[i].isReady&&e++;4===e&&(this.parentTile.visible=!1)}this.update()}}update(){if(!this.isReady||this.isDisposed)return;const{cameraFrustum:t,cameraWorldPosition:e}=this.map;if(!t.intersectsBox(this.boundingBoxWorld))return void this.simplify();this.content instanceof i&&this.map.provider.filter&&(this.content.material.uniforms.t_Matrix.value=this.map.provider.getTranMatrix());let r=this.boundingBoxWorld.distanceToPoint(e);const s=this.tileNo[2];r/=Math.pow(2,this.map.provider.maxZoom-s),r<60&&this.subdivide(),r>80&&this.simplify();this.childrenTiles.sort((t,i)=>t.boundingBoxWorld.distanceToPoint(e)-i.boundingBoxWorld.distanceToPoint(e)).forEach(t=>t.update())}subdivide(){const{isReady:t,tileNo:e,map:i,childrenTiles:r}=this,s=e[2];if(!t||r.length>0||s>=i.maxZoom)return;u(e).forEach(t=>{const e=new _;e.init(t,i,this),r.push(e)})}simplify(){this.childrenTiles.forEach(t=>t.dispose()),this.childrenTiles=[],this.visible=!0}dispose(){this.map.remove(this),this.map.provider.abort(this.tileNo),this.childrenTiles.forEach(t=>t.dispose()),this.childrenTiles=[],this.parentTile=void 0,this.content&&(this.map.provider.dispose(this.tileNo,this.content),this.content=void 0),this.isDisposed=!0}}let F,B=class extends t{constructor(){super(),this.bbox=[74.390592,6.900905,134.071423,54.318199],this.maxZoom=20,this.rootForward=0,this.cameraFrustum=new r,this.cameraWorldPosition=new s,this.cameraProjectionMatrix=new o,this.lastCameraProjectionMatrix=new o,this.lastCameraWorldPosition=new s,this.rootTiles=[],this.lastUpdateTime=0,a.prototype.computeBoundsTree||(a.prototype.computeBoundsTree=w),a.prototype.disposeBoundsTree||(a.prototype.disposeBoundsTree=x),i.prototype.raycast=v}initRootTiles(){this.rootForward>3&&(console.warn("rootForward needs to be 0 - 3."),this.rootForward=3),this.rootForward<0&&(console.warn("rootForward needs to be 0 - 3."),this.rootForward=0);const t=[];let e=[g(this.bbox)],i=this.rootForward;for(;i>0;){const t=[...e];e=[],t.forEach(t=>{const i=u(t);e.push(...i)}),i--}t.push(...e),t.forEach(t=>{const e=new _;e.init(t,this),this.rootTiles.push(e)})}update(){if(!this.visible||!this.camera)return;const t=Date.now();t-this.lastUpdateTime<300||(0!==this.rootTiles.length?(this.camera.getWorldPosition(this.cameraWorldPosition),this.cameraProjectionMatrix.multiplyMatrices(this.camera.projectionMatrix,this.camera.matrixWorldInverse),this.cameraWorldPosition.equals(this.lastCameraWorldPosition)&&this.cameraProjectionMatrix.equals(this.lastCameraProjectionMatrix)||(this.cameraFrustum.setFromProjectionMatrix(this.cameraProjectionMatrix),this.rootTiles.forEach(t=>t.update()),this.lastCameraProjectionMatrix.copy(this.cameraProjectionMatrix),this.lastCameraWorldPosition.copy(this.cameraWorldPosition),this.lastUpdateTime=t)):this.initRootTiles())}dispose(){throw new Error("[Map.dispose] Method not implemented.")}regenerate(){throw new Error("[Map.regenerate] Method not implemented.")}};class W{constructor(t){this.terminated=!0,this.map=new Map,this.worker=new t,this.worker.onmessage=this.onMessage.bind(this),this.terminated=!1}async postMessage(t){if(!this.terminated)return this.worker.postMessage(t),new Promise((e,i)=>{this.map.set(t.id,e)})}onMessage(t){const{id:e,error:i}=t.data,r=this.map.get(e);r&&!i&&r(t.data),this.map.delete(e)}terminate(){this.worker.onmessage=null,this.worker.terminate(),this.terminated=!0,this.map.clear()}}function k(t){return new Worker(""+new URL("../static/MapWorker-BP068Z4Y.js",import.meta.url).href,{name:t?.name})}class j{constructor(){this.maxZoom=20,this.source="https://gac-geo.googlecnapps.cn/maps/vt?lyrs=s&x=[x]&y=[y]&z=[z]",this.showTileNo=!1,this._useWorker=!1,this.fetching=new Map}set useWorker(t){this._useWorker=t,this._useWorker||(this._worker?.terminate(),this._worker=void 0)}get useWorker(){return this._useWorker}async getTile(t){const e=this.getUrl(t),i=new n;if(this._useWorker){this._worker||(this._worker=new W(k));const r=this.getId(t),s=await this._worker.postMessage({id:r,tileNo:t,url:e,debug:this.showTileNo});i.image=s.bitmap}else{const r=new y(e,{cache:"force-cache",mode:"cors"});this.fetching.set(t,r);try{i.image=await async function(t,e,i=!1){const r=await e.ready(),s=await r.blob(),o=await createImageBitmap(s,i?void 0:{imageOrientation:"flipY"});if(!i)return o;F||(F=new OffscreenCanvas(256,256));const a=F.getContext("2d");if(!a)throw new Error('Offscreencanvas.getContext("2d") error!');const{width:n,height:h}=F;return a.drawImage(o,0,0),a.rect(0,0,n,h),a.strokeStyle="#00FFFF",a.font="20px Arial",a.stroke(),a.fillStyle="#FF4444",a.fillText(`${t[0]}`,10,30),a.fillStyle="#44FF44",a.fillText(`${t[1]}`,10,55),a.fillStyle="#66AAFF",a.fillText(`${t[2]}`,10,80),await createImageBitmap(F,{imageOrientation:"flipY"})}(t,r,this.showTileNo)}finally{this.fetching.delete(t)}}return i.needsUpdate=!0,i.anisotropy=4,i}abort(t){if(this._useWorker)this._worker?.postMessage({id:this.getId(t),abort:!0});else{const e=this.fetching.get(t);e&&e.abort(),this.fetching.delete(t)}}dispose(t,e){e.dispose()}getId(t){return t.join("-")}getUrl(t){const[e,i,r]=t;return-1===this.source.indexOf("[x]")?this.source.replace("{x}",e+"").replace("{y}",i+"").replace("{z}",r+""):this.source.replace("[x]",e+"").replace("[y]",i+"").replace("[z]",r+"")}}class U{constructor(){this.utmZone=50,this.coordType=T,this.maxZoom=20}async getTile(t){const e=new h,i=f(t),r=this.convertCoordinate(i[0],i[3]),s=this.convertCoordinate(i[2],i[3]),o=this.convertCoordinate(i[0],i[1]),a=this.convertCoordinate(i[2],i[1]),n=new Float32Array([r[0],r[1],0,s[0],s[1],0,o[0],o[1],0,a[0],a[1],0]);return e.setAttribute("position",new l(n,3)),e}abort(t){}dispose(t,e){e.dispose()}convertCoordinate(t,e){return this.coordType===T?P(t,e,this.utmZone):b(t,e)}}class S extends i{constructor(t){super(t),this.center=new s}}class R{constructor(t,e){this.geometryProvider=t,this.textureProvider=e,this.maxZoom=20,this.showBoundingBox=!1,this.wireframe=!1,this.flatShading=!1,this.useStandardMaterial=!1,this.filter=null}getTranMatrix(){let t=new o;if(this.filter?.opposite){let e=new o;e.set(-1,0,0,0,0,-1,0,0,0,0,-1,0,1,1,1,1),t.multiply(e)}if(this.filter?.monochrome){let e=new o;const i=this.filter.monochrome.r,r=this.filter.monochrome.g,s=this.filter.monochrome.b;e.set(i,r,s,0,i,r,s,0,i,r,s,0,0,0,0,1),t.multiply(e)}if(this.filter?.genBright){let e=new o;const i=this.filter.genBright;e.set(i,0,0,0,0,i,0,0,0,0,i,0,0,0,0,1),t.multiply(e)}if(this.filter?.genContrast){let e=new o;const i=this.filter.genContrast,r=.5*(1-i);e.set(i,0,0,0,0,i,0,0,0,0,i,0,r,r,r,1),t.multiply(e)}if(this.filter?.genSaturate){let e=new o;const i=this.filter.genSaturate,r=.3*(1-i),s=.6*(1-i),a=.1*(1-i);e.set(r+i,r,r,0,s,s+i,s,0,a,a,a+i,0,0,0,0,1),t.multiply(e)}return t}async getTile(t){const e=[this.geometryProvider.getTile(t),this.textureProvider.getTile(t)],i=await Promise.all(e),r=i[0],s=i[1];s.colorSpace=c;const{wireframe:o,flatShading:a}=this;let n=null;const h=t[0]+t[1]+t[2];n=this.useStandardMaterial?new d({map:s,wireframe:o,flatShading:a}):new m({map:s,wireframe:o}),this.filter&&(n=new C({baseMaterial:n,vertexShader:"\n                varying vec2 vUv;    //顶点纹理坐标\n                void main () {\n                    vUv = uv;\n                    // gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 ); 着色器会抖动\n                    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                    csm_Position = position * vec3(1.0);\n                }\n                ",fragmentShader:"\n                uniform sampler2D e_Texture;     //纹理图像\n                varying vec2 vUv;               //片元纹理坐标\n                uniform mat4 t_Matrix;     //接收变换矩阵\n                void main () {\n                    // gl_FragColor = texture2D( e_Texture, vUv );\n\n                    // vec4 textureColor = texture2D( e_Texture, vUv );\n                    // //计算加权平均值\n                    // float w_a = textureColor.r * 0.3 + textureColor.g * 0.6 + textureColor.b * 0.1;\n                    // gl_FragColor = vec4(w_a, w_a, w_a, 1.0);\n\n                    vec4 textureColor = texture2D( e_Texture, vUv );\n                    //变换矩阵乘以 vec4(R,G,B,1)    ---\x3evec4(R,G,B,1) 是齐次坐标，原本是n维的向量用一个n+1维向量来表示\n                    //vec4(R,G,B,1)第四个分量不是透明度\n                    vec4 transColor =  vec4(textureColor.r, textureColor.g, textureColor.b, 1.0)*t_Matrix; \n                    //设置透明度\n                    transColor.a = 1.0;\n                    csm_FragColor = transColor;\n\n                    // if(vUv.x==0.0 || vUv.x==1.0 || vUv.y==0.0 || vUv.y==1.0){\n                    //     gl_FragColor.a = 0.0;\n                    // }\n                }",silent:!0,flatShading:a,uniforms:{e_Texture:{value:s},t_Matrix:{value:this.getTranMatrix()}}}));const l=new S;if(l.renderOrder=h,r.computeBoundingBox(),r.boundingBox.getCenter(l.center),r.center(),r.computeBoundingSphere(),r.computeBoundsTree(),l.position.copy(l.center),l.geometry=r,l.material=n,this.showBoundingBox){const t=new p(r.boundingBox);l.add(t)}return l}abort(t){this.geometryProvider.abort(t),this.textureProvider.abort(t)}dispose(t,e){const i=e.geometry,r=e.material;i&&this.geometryProvider.dispose(t,i),r&&r.map&&this.textureProvider.dispose(t,r.map),r?.dispose()}}export{j as M,U as P,R as T,B as a,W as b};
