import{an as e,s as t,t as i,bL as n,$ as r,a0 as s,aB as a,aP as o,a6 as l,T as d,X as m,bM as f,bm as c,m as h,B as u,a as p,aq as v,V as g,bN as y,b3 as _,c as S,a1 as x,b as M,a$ as T,b0 as E,aa as U,bO as A,bJ as P,f as w,g as b,I as B,a4 as C,bP as O,bQ as R,aW as N,bR as z,aX as L,aY as I,bo as F,O as D,a9 as V,q as k,C as G,bS as H,bT as j,bI as X}from"./three.-z-VOBM71731641201182.js";import{V as W,C as Y,A as q,M as J,a as Z,b as K,S as Q,T as $,c as ee,Q as te,E as ie,d as ne,G as re,e as se,B as ae,l as oe,f as le,g as de,h as me,i as fe,j as ce,k as he,m as ue,n as pe,o as ve,p as ge,q as ye,r as _e,s as Se,D as xe,t as Me,u as Te,v as Ee,w as Ue,x as Ae,F as Pe,y as we,z as be,H as Be,I as Ce,J as Oe,K as Re,L as Ne,N as ze,O as Le,P as Ie,R as Fe,U as De,W as Ve,X as ke,Y as Ge,Z as He,_ as je,$ as Xe,a0 as We,a1 as Ye,a2 as qe,a3 as Je,a4 as Ze,a5 as Ke,a6 as Qe,a7 as $e,a8 as et,a9 as tt,aa as it,ab as nt,ac as rt,ad as st,ae as at,af as ot,ag as lt,ah as dt,ai as mt,aj as ft,ak as ct,al as ht,am as ut,an as pt,ao as vt,ap as gt,aq as yt,ar as _t,as as St,at as xt,au as Mt,av as Tt,aw as Et,ax as Ut,ay as At,az as Pt,aA as wt,aB as bt,aC as Bt,aD as Ct,aE as Ot,aF as Rt,aG as Nt,aH as zt,aI as Lt}from"./quarks.core.4MLLO9vf1731641201182.js";const It=X;function Ft(){It.tile_pars_vertex="\n#ifdef UV_TILE\n    attribute float uvTile;\n    uniform vec2 tileCount;\n    \n    mat3 makeTileTransform(float uvTile) {\n        float col = mod(uvTile, tileCount.x);\n        float row = (tileCount.y - floor(uvTile / tileCount.x) - 1.0);\n        \n        return mat3(\n          1.0 / tileCount.x, 0.0, 0.0,\n          0.0, 1.0 / tileCount.y, 0.0, \n          col / tileCount.x, row / tileCount.y, 1.0);\n    }\n#else\n    mat3 makeTileTransform(float uvTile) {\n        return mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    }\n#endif\n\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\n\tvarying vec2 vUv;\n#ifdef TILE_BLEND\n    varying vec2 vUvNext;\n    varying float vUvBlend;\n#endif\n\n#endif\n#ifdef USE_MAP\n\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#ifdef TILE_BLEND\n    varying vec2 vMapUvNext;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n\n#endif\n#ifdef USE_AOMAP\n\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n\n#endif\n#ifdef USE_BUMPMAP\n\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n\n#endif\n#ifdef USE_NORMALMAP\n\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n\n#endif\n#ifdef USE_METALNESSMAP\n\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n\n#endif\n#ifdef USE_SPECULARMAP\n\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n\n#endif\n",It.tile_vertex="\n#ifdef UV_TILE\n    mat3 tileTransform = makeTileTransform(floor(uvTile));\n    #ifdef TILE_BLEND\n        mat3 nextTileTransform = makeTileTransform(ceil(uvTile));\n        vUvBlend = fract(uvTile);\n    #endif\n#else\n    mat3 tileTransform = makeTileTransform(0.0);\n#endif\n\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\nvUv = (tileTransform *vec3( uv, 1 )).xy;\n#if defined( TILE_BLEND ) && defined( UV_TILE )\n    vUvNext = (nextTileTransform *vec3( uv, 1 )).xy;\n#endif\n\n#endif\n#ifdef USE_MAP\n\nvMapUv = ( tileTransform * (mapTransform * vec3( MAP_UV, 1 ) )).xy;\n#if defined( TILE_BLEND ) && defined( UV_TILE )\n    vMapUvNext = (nextTileTransform * (mapTransform * vec3( MAP_UV, 1 ))).xy;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\nvAlphaMapUv = ( tileTransform * (alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) )).xy;\n    \n#endif\n#ifdef USE_LIGHTMAP\n\nvLightMapUv = ( tileTransform * (lightMapTransform * vec3( LIGHTMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_AOMAP\n\nvAoMapUv = ( tileTransform * (aoMapTransform * vec3( AOMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_BUMPMAP\n\nvBumpMapUv = ( tileTransform * (bumpMapTransform * vec3( BUMPMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_NORMALMAP\n\nvNormalMapUv = ( tileTransform * (normalMapTransform * vec3( NORMALMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\nvDisplacementMapUv = ( tileTransform * (displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\nvEmissiveMapUv = ( tileTransform * (emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_METALNESSMAP\n\nvMetalnessMapUv = ( tileTransform * (metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\nvRoughnessMapUv = ( tileTransform * (roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\nvAnisotropyMapUv = ( tileTransform * (anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\nvClearcoatMapUv = ( tileTransform * (clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\nvClearcoatNormalMapUv = ( tileTransform * (clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\nvClearcoatRoughnessMapUv = ( tileTransform * (clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\nvIridescenceMapUv = ( tileTransform * (iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\nvIridescenceThicknessMapUv = ( tileTransform * (iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\nvSheenColorMapUv = ( tileTransform * (sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\nvSheenRoughnessMapUv = ( tileTransform * (sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULARMAP\n\nvSpecularMapUv = ( tileTransform * (specularMapTransform * vec3( SPECULARMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\nvSpecularColorMapUv = ( tileTransform * (specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\nvSpecularIntensityMapUv = ( tileTransform * (specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\nvTransmissionMapUv = ( tileTransform * transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\nvThicknessMapUv = ( tileTransform * thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) )).xy;\n\n#endif\n\n",It.tile_pars_fragment="\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\n\tvarying vec2 vUv;\n#ifdef TILE_BLEND\n    varying vec2 vUvNext;\n    varying float vUvBlend;\n#endif\n\n#endif\n#ifdef USE_MAP\n\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#ifdef TILE_BLEND\n    varying vec2 vMapUvNext;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n\n#endif\n#ifdef USE_AOMAP\n\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n\n#endif\n#ifdef USE_BUMPMAP\n\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n\n#endif\n#ifdef USE_NORMALMAP\n\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n\n#endif\n#ifdef USE_METALNESSMAP\n\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n\n#endif\n#ifdef USE_SPECULARMAP\n\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n\n#endif\n",It.tile_fragment="\n#ifdef USE_MAP\n    vec4 texelColor = texture2D( map, vUv);\n    #ifdef TILE_BLEND\n        texelColor = mix( texelColor, texture2D( map, vUvNext ), vUvBlend );\n    #endif\n    diffuseColor *= texelColor;\n#endif\n",It.soft_pars_vertex="\n#ifdef SOFT_PARTICLES\n    varying vec4 projPosition;\n    varying float linearDepth;\n#endif\n",It.soft_vertex="\n#ifdef SOFT_PARTICLES\n    projPosition = gl_Position;\n    linearDepth = -mvPosition.z;\n#endif\n",It.soft_pars_fragment="\n#ifdef SOFT_PARTICLES\n\n    uniform sampler2D depthTexture;\n    uniform vec4 projParams;\n    uniform vec2 softParams;\n\n    varying vec4 projPosition;\n    varying float linearDepth;\n\n    #define SOFT_NEAR_FADE softParams.x\n    #define SOFT_INV_FADE_DISTANCE softParams.y\n\n    #define zNear projParams.x\n    #define zFar projParams.y\n\n    float linearize_depth(float d)\n    {\n        return (zFar * zNear) / (zFar - d * (zFar - zNear));\n    }\n\n#endif\n",It.soft_fragment="\n#ifdef SOFT_PARTICLES\n\n    /* #ifdef LOGDEPTH\n    float distSample = linearize_depth_log(sampleDepth, near, far);\n    #else\n    float distSample = ortho ? linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far);\n    #endif */\n\n    vec2 p2 = projPosition.xy / projPosition.w;\n    \n    p2 = 0.5 * p2 + 0.5;\n\n    float readDepth = texture2D(depthTexture, p2.xy).r;\n    float viewDepth = linearize_depth(readDepth);\n\n    float softParticlesFade = saturate(SOFT_INV_FADE_DISTANCE * ((viewDepth - SOFT_NEAR_FADE) - linearDepth));\n    \n    gl_FragColor *= softParticlesFade;\n\n    //gl_FragColor = vec4(softParticlesFade , 0, 0, 1);\n#endif\n"}class Dt extends e{constructor(e){super(),this.type="ParticleEmitter",this.system=e}clone(){const e=this.system.clone();return e.emitter.copy(this,!0),e.emitter}dispose(){}extractFromCache(e){const t=[];for(const i in e){const n=e[i];delete n.metadata,t.push(n)}return t}toJSON(e,t={}){const i=this.children;this.children=this.children.filter((e=>"ParticleSystemPreview"!==e.type));const n=super.toJSON(e);return this.children=i,null!==this.system&&(n.object.ps=this.system.toJSON(e,t)),n}}var Vt,kt;(kt=Vt||(Vt={}))[kt.BillBoard=0]="BillBoard",kt[kt.StretchedBillBoard=1]="StretchedBillBoard",kt[kt.Mesh=2]="Mesh",kt[kt.Trail=3]="Trail",kt[kt.HorizontalBillBoard=4]="HorizontalBillBoard",kt[kt.VerticalBillBoard=5]="VerticalBillBoard";class Gt extends t{constructor(e){super(),this.type="VFXBatch",this.maxParticles=1e3,this.systems=new Set;const t=new n;t.mask=e.layers.mask;const i=e.material.clone();i.defines={},Object.assign(i.defines,e.material.defines),this.settings={instancingGeometry:e.instancingGeometry,renderMode:e.renderMode,renderOrder:e.renderOrder,material:i,uTileCount:e.uTileCount,vTileCount:e.vTileCount,blendTiles:e.blendTiles,softParticles:e.softParticles,softNearFade:e.softNearFade,softFarFade:e.softFarFade,layers:t},this.frustumCulled=!1,this.renderOrder=this.settings.renderOrder}addSystem(e){this.systems.add(e)}removeSystem(e){this.systems.delete(e)}applyDepthTexture(e){const t=this.material.uniforms.depthTexture;t&&t.value!==e&&(t.value=e,this.material.needsUpdate=!0)}}const Ht=new W(0,0,1),jt=new te,Xt=new W,Wt=new W;new W;const Yt=new i(1,1,1,1);class qt{set time(e){this.emissionState.time=e}get time(){return this.emissionState.time}get layers(){return this.rendererSettings.layers}get texture(){return this.rendererSettings.material.map}set texture(e){this.rendererSettings.material.map=e,this.neededToUpdateRender=!0}get material(){return this.rendererSettings.material}set material(e){this.rendererSettings.material=e,this.neededToUpdateRender=!0}get uTileCount(){return this.rendererSettings.uTileCount}set uTileCount(e){this.rendererSettings.uTileCount=e,this.neededToUpdateRender=!0}get vTileCount(){return this.rendererSettings.vTileCount}set vTileCount(e){this.rendererSettings.vTileCount=e,this.neededToUpdateRender=!0}get blendTiles(){return this.rendererSettings.blendTiles}set blendTiles(e){this.rendererSettings.blendTiles=e,this.neededToUpdateRender=!0}get softParticles(){return this.rendererSettings.softParticles}set softParticles(e){this.rendererSettings.softParticles=e,this.neededToUpdateRender=!0}get softNearFade(){return this.rendererSettings.softNearFade}set softNearFade(e){this.rendererSettings.softNearFade=e,this.neededToUpdateRender=!0}get softFarFade(){return this.rendererSettings.softFarFade}set softFarFade(e){this.rendererSettings.softFarFade=e,this.neededToUpdateRender=!0}get instancingGeometry(){return this.rendererSettings.instancingGeometry}set instancingGeometry(e){this.restart(),this.particles.length=0,this.rendererSettings.instancingGeometry=e,this.neededToUpdateRender=!0}get renderMode(){return this.rendererSettings.renderMode}set renderMode(e){if((this.rendererSettings.renderMode!=Vt.Trail&&e===Vt.Trail||this.rendererSettings.renderMode==Vt.Trail&&e!==Vt.Trail)&&(this.restart(),this.particles.length=0),this.rendererSettings.renderMode!==e)switch(e){case Vt.Trail:this.rendererEmitterSettings={startLength:new Y(30),followLocalOrigin:!1};break;case Vt.Mesh:this.rendererEmitterSettings={geometry:new i(1,1)},this.startRotation=new q(new W(0,1,0),new Y(0));break;case Vt.StretchedBillBoard:this.rendererEmitterSettings={speedFactor:0,lengthFactor:2},this.rendererSettings.renderMode===Vt.Mesh&&(this.startRotation=new Y(0));break;case Vt.BillBoard:case Vt.VerticalBillBoard:case Vt.HorizontalBillBoard:this.rendererEmitterSettings={},this.rendererSettings.renderMode===Vt.Mesh&&(this.startRotation=new Y(0))}this.rendererSettings.renderMode=e,this.neededToUpdateRender=!0}get renderOrder(){return this.rendererSettings.renderOrder}set renderOrder(e){this.rendererSettings.renderOrder=e,this.neededToUpdateRender=!0}get blending(){return this.rendererSettings.material.blending}set blending(e){this.rendererSettings.material.blending=e,this.neededToUpdateRender=!0}constructor(e){var t,i,r,s,a,o,l,d,m,f,c,h,u,p,v,g,y,_,S,x,M,T,E,U,A,P;if(this.temp=new W,this.travelDistance=0,this.normalMatrix=new J,this.memory=[],this.listeners={},this.firstTimeUpdate=!0,this.autoDestroy=void 0!==e.autoDestroy&&e.autoDestroy,this.duration=null!==(t=e.duration)&&void 0!==t?t:1,this.looping=void 0===e.looping||e.looping,this.prewarm=void 0!==e.prewarm&&e.prewarm,this.startLife=null!==(i=e.startLife)&&void 0!==i?i:new Y(5),this.startSpeed=null!==(r=e.startSpeed)&&void 0!==r?r:new Y(0),this.startRotation=null!==(s=e.startRotation)&&void 0!==s?s:new Y(0),this.startSize=null!==(a=e.startSize)&&void 0!==a?a:new Y(1),this.startColor=null!==(o=e.startColor)&&void 0!==o?o:new Z(new K(1,1,1,1)),this.emissionOverTime=null!==(l=e.emissionOverTime)&&void 0!==l?l:new Y(10),this.emissionOverDistance=null!==(d=e.emissionOverDistance)&&void 0!==d?d:new Y(0),this.emissionBursts=null!==(m=e.emissionBursts)&&void 0!==m?m:[],this.onlyUsedByOther=null!==(f=e.onlyUsedByOther)&&void 0!==f&&f,this.emitterShape=null!==(c=e.shape)&&void 0!==c?c:new Q,this.behaviors=null!==(h=e.behaviors)&&void 0!==h?h:new Array,this.worldSpace=null!==(u=e.worldSpace)&&void 0!==u&&u,this.rendererEmitterSettings=null!==(p=e.rendererEmitterSettings)&&void 0!==p?p:{},e.renderMode===Vt.StretchedBillBoard){const t=this.rendererEmitterSettings;void 0!==e.speedFactor&&(t.speedFactor=e.speedFactor),t.speedFactor=null!==(v=t.speedFactor)&&void 0!==v?v:0,t.lengthFactor=null!==(g=t.lengthFactor)&&void 0!==g?g:0}this.rendererSettings={instancingGeometry:null!==(y=e.instancingGeometry)&&void 0!==y?y:Yt,renderMode:null!==(_=e.renderMode)&&void 0!==_?_:Vt.BillBoard,renderOrder:null!==(S=e.renderOrder)&&void 0!==S?S:0,material:e.material,uTileCount:null!==(x=e.uTileCount)&&void 0!==x?x:1,vTileCount:null!==(M=e.vTileCount)&&void 0!==M?M:1,blendTiles:null!==(T=e.blendTiles)&&void 0!==T&&T,softParticles:null!==(E=e.softParticles)&&void 0!==E&&E,softNearFade:null!==(U=e.softNearFade)&&void 0!==U?U:0,softFarFade:null!==(A=e.softFarFade)&&void 0!==A?A:0,layers:null!==(P=e.layers)&&void 0!==P?P:new n},this.neededToUpdateRender=!0,this.particles=new Array,this.startTileIndex=e.startTileIndex||new Y(0),this.emitter=new Dt(this),this.paused=!1,this.particleNum=0,this.emissionState={isBursting:!1,burstParticleIndex:0,burstParticleCount:0,burstIndex:0,burstWaveIndex:0,time:0,waitEmiting:0,travelDistance:0},this.emissionBursts.forEach((e=>e.count.startGen(this.memory))),this.emissionOverDistance.startGen(this.memory),this.emitEnded=!1,this.markForDestroy=!1,this.prewarmed=!1}pause(){this.paused=!0}play(){this.paused=!1}stop(){this.restart(),this.pause()}spawn(e,t,i){jt.setFromRotationMatrix(i);const n=Xt,r=jt,s=Wt;i.decompose(n,r,s);for(let a=0;a<e;a++){for(t.burstParticleIndex=a,this.particleNum++;this.particles.length<this.particleNum;)this.rendererSettings.renderMode===Vt.Trail?this.particles.push(new $):this.particles.push(new ee);const e=this.particles[this.particleNum-1];if(e.reset(),e.speedModifier=1,this.startColor.startGen(e.memory),this.startColor.genColor(e.memory,e.startColor,this.emissionState.time),e.color.copy(e.startColor),this.startSpeed.startGen(e.memory),e.startSpeed=this.startSpeed.genValue(e.memory,t.time/this.duration),this.startLife.startGen(e.memory),e.life=this.startLife.genValue(e.memory,t.time/this.duration),e.age=0,this.startSize.startGen(e.memory),"vec3function"===this.startSize.type)this.startSize.genValue(e.memory,e.startSize,t.time/this.duration);else{const i=this.startSize.genValue(e.memory,t.time/this.duration);e.startSize.set(i,i,i)}if(this.startTileIndex.startGen(e.memory),e.uvTile=this.startTileIndex.genValue(e.memory),e.size.copy(e.startSize),this.rendererSettings.renderMode===Vt.Mesh||this.rendererSettings.renderMode===Vt.BillBoard||this.rendererSettings.renderMode===Vt.VerticalBillBoard||this.rendererSettings.renderMode===Vt.HorizontalBillBoard||this.rendererSettings.renderMode===Vt.StretchedBillBoard){const i=e;this.startRotation.startGen(e.memory),this.rendererSettings.renderMode===Vt.Mesh?(i.rotation instanceof te||(i.rotation=new te),"rotation"===this.startRotation.type?this.startRotation.genValue(e.memory,i.rotation,1,t.time/this.duration):i.rotation.setFromAxisAngle(Ht,this.startRotation.genValue(i.memory,t.time/this.duration))):"rotation"===this.startRotation.type?i.rotation=0:i.rotation=this.startRotation.genValue(i.memory,t.time/this.duration)}else if(this.rendererSettings.renderMode===Vt.Trail){const i=e;this.rendererEmitterSettings.startLength.startGen(i.memory),i.length=this.rendererEmitterSettings.startLength.genValue(i.memory,t.time/this.duration)}if(this.emitterShape.initialize(e,t),this.rendererSettings.renderMode===Vt.Trail&&this.rendererEmitterSettings.followLocalOrigin){const t=e;t.localPosition=(new W).copy(t.position)}this.worldSpace?(e.position.applyMatrix4(i),e.startSize.multiply(s).abs(),e.size.copy(e.startSize),e.velocity.multiply(s).applyMatrix3(this.normalMatrix),e.rotation&&e.rotation instanceof te&&e.rotation.multiplyQuaternions(jt,e.rotation)):this.onlyUsedByOther&&(e.parentMatrix=i);for(let t=0;t<this.behaviors.length;t++)this.behaviors[t].initialize(e,this)}}endEmit(){this.emitEnded=!0,this.autoDestroy&&(this.markForDestroy=!0),this.fire({type:"emitEnd",particleSystem:this})}dispose(){this._renderer&&this._renderer.deleteSystem(this),this.emitter.dispose(),this.emitter.parent&&this.emitter.parent.remove(this.emitter),this.fire({type:"destroy",particleSystem:this})}restart(){this.memory.length=0,this.paused=!1,this.particleNum=0,this.emissionState.isBursting=!1,this.emissionState.burstIndex=0,this.emissionState.burstWaveIndex=0,this.emissionState.time=0,this.emissionState.waitEmiting=0,this.behaviors.forEach((e=>{e.reset()})),this.emitEnded=!1,this.markForDestroy=!1,this.prewarmed=!1,this.emissionBursts.forEach((e=>e.count.startGen(this.memory))),this.emissionOverDistance.startGen(this.memory)}update(e){if(this.paused)return;let t=this.emitter;for(;t.parent;)t=t.parent;if("Scene"===t.type)if(this.firstTimeUpdate&&(this.firstTimeUpdate=!1,this.emitter.updateWorldMatrix(!0,!1)),this.emitEnded&&0===this.particleNum)this.markForDestroy&&this.emitter.parent&&this.dispose();else{if(this.looping&&this.prewarm&&!this.prewarmed){this.prewarmed=!0;for(let e=0;e<60*this.duration;e++)this.update(1/60)}e>.1&&(e=.1),this.neededToUpdateRender&&(this._renderer&&this._renderer.updateSystem(this),this.neededToUpdateRender=!1),this.onlyUsedByOther||this.emit(e,this.emissionState,this.emitter.matrixWorld),this.emitterShape.update(this,e);for(let t=0;t<this.behaviors.length;t++){this.behaviors[t].frameUpdate(e);for(let i=0;i<this.particleNum;i++)this.particles[i].died||this.behaviors[t].update(this.particles[i],e)}for(let t=0;t<this.particleNum;t++)this.rendererEmitterSettings.followLocalOrigin&&this.particles[t].localPosition?(this.particles[t].position.copy(this.particles[t].localPosition),this.particles[t].parentMatrix?this.particles[t].position.applyMatrix4(this.particles[t].parentMatrix):this.particles[t].position.applyMatrix4(this.emitter.matrixWorld)):this.particles[t].position.addScaledVector(this.particles[t].velocity,e*this.particles[t].speedModifier),this.particles[t].age+=e;if(this.rendererSettings.renderMode===Vt.Trail)for(let e=0;e<this.particleNum;e++){this.particles[e].update()}for(let e=0;e<this.particleNum;e++){const t=this.particles[e];!t.died||t instanceof $&&0!==t.previous.length||(this.particles[e]=this.particles[this.particleNum-1],this.particles[this.particleNum-1]=t,this.particleNum--,e--,this.fire({type:"particleDied",particleSystem:this,particle:t}))}}else this.dispose()}emit(e,t,i){t.time>this.duration&&(this.looping?(t.time-=this.duration,t.burstIndex=0,this.behaviors.forEach((e=>{e.reset()}))):this.emitEnded||this.onlyUsedByOther||this.endEmit()),this.normalMatrix.getNormalMatrix(i);const n=Math.ceil(t.waitEmiting);for(this.spawn(n,t,i),t.waitEmiting-=n;t.burstIndex<this.emissionBursts.length&&this.emissionBursts[t.burstIndex].time<=t.time;){if(Math.random()<this.emissionBursts[t.burstIndex].probability){const e=this.emissionBursts[t.burstIndex].count.genValue(this.memory,this.time);t.isBursting=!0,t.burstParticleCount=e,this.spawn(e,t,i),t.isBursting=!1}t.burstIndex++}if(!this.emitEnded&&(t.waitEmiting+=e*this.emissionOverTime.genValue(this.memory,t.time/this.duration),null!=t.previousWorldPos)){this.temp.set(i.elements[12],i.elements[13],i.elements[14]),t.travelDistance+=t.previousWorldPos.distanceTo(this.temp);const e=this.emissionOverDistance.genValue(this.memory,t.time/this.duration);if(t.travelDistance*e>0){const i=Math.floor(t.travelDistance*e);t.travelDistance-=i/e,t.waitEmiting+=i}}void 0===t.previousWorldPos&&(t.previousWorldPos=new W),t.previousWorldPos.set(i.elements[12],i.elements[13],i.elements[14]),t.time+=e}toJSON(e,t={}){var i;if((void 0===e||"string"==typeof e)&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}}),e.materials[this.rendererSettings.material.uuid]=this.rendererSettings.material.toJSON(e),t.useUrlForImage&&void 0!==(null===(i=this.texture)||void 0===i?void 0:i.source)){const t=this.texture.source;e.images[t.uuid]={uuid:t.uuid,url:this.texture.image.url}}let n;n=this.renderMode===Vt.Trail?{startLength:this.rendererEmitterSettings.startLength.toJSON(),followLocalOrigin:this.rendererEmitterSettings.followLocalOrigin}:this.renderMode===Vt.Mesh?{}:this.renderMode===Vt.StretchedBillBoard?{speedFactor:this.rendererEmitterSettings.speedFactor,lengthFactor:this.rendererEmitterSettings.lengthFactor}:{};const r=this.rendererSettings.instancingGeometry;return e.geometries&&!e.geometries[r.uuid]&&(e.geometries[r.uuid]=r.toJSON()),{version:"3.0",autoDestroy:this.autoDestroy,looping:this.looping,prewarm:this.prewarm,duration:this.duration,shape:this.emitterShape.toJSON(),startLife:this.startLife.toJSON(),startSpeed:this.startSpeed.toJSON(),startRotation:this.startRotation.toJSON(),startSize:this.startSize.toJSON(),startColor:this.startColor.toJSON(),emissionOverTime:this.emissionOverTime.toJSON(),emissionOverDistance:this.emissionOverDistance.toJSON(),emissionBursts:this.emissionBursts.map((e=>({time:e.time,count:e.count.toJSON(),probability:e.probability,interval:e.interval,cycle:e.cycle}))),onlyUsedByOther:this.onlyUsedByOther,instancingGeometry:this.rendererSettings.instancingGeometry.uuid,renderOrder:this.renderOrder,renderMode:this.renderMode,rendererEmitterSettings:n,material:this.rendererSettings.material.uuid,layers:this.layers.mask,startTileIndex:this.startTileIndex.toJSON(),uTileCount:this.uTileCount,vTileCount:this.vTileCount,blendTiles:this.blendTiles,softParticles:this.rendererSettings.softParticles,softFarFade:this.rendererSettings.softFarFade,softNearFade:this.rendererSettings.softNearFade,behaviors:this.behaviors.map((e=>e.toJSON())),worldSpace:this.worldSpace}}static fromJSON(e,t,i){var o,l;const d=ie(e.shape,t);let m;if(e.renderMode===Vt.Trail){const t=e.rendererEmitterSettings;m={startLength:null!=t.startLength?ne(t.startLength):new Y(30),followLocalOrigin:t.followLocalOrigin}}else e.renderMode===Vt.Mesh?m={}:e.renderMode===Vt.StretchedBillBoard?(m=e.rendererEmitterSettings,null!=e.speedFactor&&(m.speedFactor=e.speedFactor)):m={};const f=new n;e.layers&&(f.mask=e.layers);const c=new qt({autoDestroy:e.autoDestroy,looping:e.looping,prewarm:e.prewarm,duration:e.duration,shape:d,startLife:ne(e.startLife),startSpeed:ne(e.startSpeed),startRotation:re(e.startRotation),startSize:re(e.startSize),startColor:se(e.startColor),emissionOverTime:ne(e.emissionOverTime),emissionOverDistance:ne(e.emissionOverDistance),emissionBursts:null===(o=e.emissionBursts)||void 0===o?void 0:o.map((e=>{var t,i,n;return{time:e.time,count:"number"==typeof e.count?new Y(e.count):ne(e.count),probability:null!==(t=e.probability)&&void 0!==t?t:1,interval:null!==(i=e.interval)&&void 0!==i?i:.1,cycle:null!==(n=e.cycle)&&void 0!==n?n:1}})),onlyUsedByOther:e.onlyUsedByOther,instancingGeometry:t.geometries[e.instancingGeometry],renderMode:e.renderMode,rendererEmitterSettings:m,renderOrder:e.renderOrder,layers:f,material:e.material?t.materials[e.material]:e.texture?new r({map:t.textures[e.texture],transparent:null===(l=e.transparent)||void 0===l||l,blending:e.blending,side:s}):new r({color:16777215,transparent:!0,blending:a,side:s}),startTileIndex:"number"==typeof e.startTileIndex?new Y(e.startTileIndex):ne(e.startTileIndex),uTileCount:e.uTileCount,vTileCount:e.vTileCount,blendTiles:e.blendTiles,softParticles:e.softParticles,softFarFade:e.softFarFade,softNearFade:e.softNearFade,behaviors:[],worldSpace:e.worldSpace});return c.behaviors=e.behaviors.map((e=>{const t=ae(e,c);return"EmitSubParticleSystem"===t.type&&(i[e.subParticleSystem]=t),t})),c}addBehavior(e){this.behaviors.push(e)}getRendererSettings(){return this.rendererSettings}addEventListener(e,t){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(t)}removeAllEventListeners(e){this.listeners[e]&&(this.listeners[e]=[])}removeEventListener(e,t){if(this.listeners[e]){const i=this.listeners[e].indexOf(t);-1!==i&&this.listeners[e].splice(i,1)}}fire(e){this.listeners[e.type]&&this.listeners[e.type].forEach((t=>t(e)))}clone(){const e=[];for(const n of this.emissionBursts){const t={};Object.assign(t,n),e.push(t)}const t=[];for(const n of this.behaviors)t.push(n.clone());let i;i=this.renderMode===Vt.Trail?{startLength:this.rendererEmitterSettings.startLength.clone(),followLocalOrigin:this.rendererEmitterSettings.followLocalOrigin}:this.renderMode===Vt.StretchedBillBoard?{lengthFactor:this.rendererEmitterSettings.lengthFactor,speedFactor:this.rendererEmitterSettings.speedFactor}:{};const r=new n;return r.mask=this.layers.mask,new qt({autoDestroy:this.autoDestroy,looping:this.looping,duration:this.duration,shape:this.emitterShape.clone(),startLife:this.startLife.clone(),startSpeed:this.startSpeed.clone(),startRotation:this.startRotation.clone(),startSize:this.startSize.clone(),startColor:this.startColor.clone(),emissionOverTime:this.emissionOverTime.clone(),emissionOverDistance:this.emissionOverDistance.clone(),emissionBursts:e,onlyUsedByOther:this.onlyUsedByOther,instancingGeometry:this.rendererSettings.instancingGeometry,renderMode:this.renderMode,renderOrder:this.renderOrder,rendererEmitterSettings:i,material:this.rendererSettings.material,startTileIndex:this.startTileIndex,uTileCount:this.uTileCount,vTileCount:this.vTileCount,blendTiles:this.blendTiles,softParticles:this.softParticles,softFarFade:this.softFarFade,softNearFade:this.softNearFade,behaviors:t,worldSpace:this.worldSpace,layers:r})}}var Jt="\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <alphatest_pars_fragment>\n\n#include <tile_pars_fragment>\n#include <soft_pars_fragment>\n\nvoid main() {\n\n    #include <clipping_planes_fragment>\n    \n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vColor;\n    \n    #include <logdepthbuf_fragment>\n    \n    #include <tile_fragment>\n    #include <alphatest_fragment>\n\n    outgoingLight = diffuseColor.rgb;\n    \n    #ifdef USE_COLOR_AS_ALPHA\n    gl_FragColor = vec4( outgoingLight, diffuseColor.r );\n    #else\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #endif\n    \n    #include <soft_fragment>\n    #include <tonemapping_fragment>\n}\n",Zt="\n#define STANDARD\n\n#ifdef PHYSICAL\n#define IOR\n#define USE_SPECULAR\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef IOR\nuniform float ior;\n#endif\n\n#ifdef USE_SPECULAR\nuniform float specularIntensity;\nuniform vec3 specularColor;\n\n#ifdef USE_SPECULAR_COLORMAP\nuniform sampler2D specularColorMap;\n#endif\n\n#ifdef USE_SPECULAR_INTENSITYMAP\nuniform sampler2D specularIntensityMap;\n#endif\n#endif\n\n#ifdef USE_CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_DISPERSION\nuniform float dispersion;\n#endif\n\n#ifdef USE_IRIDESCENCE\nuniform float iridescence;\nuniform float iridescenceIOR;\nuniform float iridescenceThicknessMinimum;\nuniform float iridescenceThicknessMaximum;\n#endif\n\n#ifdef USE_SHEEN\nuniform vec3 sheenColor;\nuniform float sheenRoughness;\n\n#ifdef USE_SHEEN_COLORMAP\nuniform sampler2D sheenColorMap;\n#endif\n\n#ifdef USE_SHEEN_ROUGHNESSMAP\nuniform sampler2D sheenRoughnessMap;\n#endif\n#endif\n\n#ifdef USE_ANISOTROPY\nuniform vec2 anisotropyVector;\n\n#ifdef USE_ANISOTROPYMAP\nuniform sampler2D anisotropyMap;\n#endif\n#endif\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\nvec4 diffuseColor = vec4( diffuse, opacity );\n#include <clipping_planes_fragment>\n\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\nvec3 totalEmissiveRadiance = emissive;\n\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <alphahash_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n\n// accumulation\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n\n// modulation\n#include <aomap_fragment>\n\nvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\nvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n#include <transmission_fragment>\n\nvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n#ifdef USE_SHEEN\n\n// Sheen energy compensation approximation calculation can be found at the end of\n// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\noutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\n#endif\n\n#ifdef USE_CLEARCOAT\n\nfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\nvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\noutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\n#endif\n\n#include <opaque_fragment>\n#include <tonemapping_fragment>\n#include <colorspace_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",Kt="\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n\nattribute vec3 offset;\nattribute vec4 rotation;\nattribute vec3 size;\n#include <tile_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n    #include <tile_vertex>\n    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;\n    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;\n    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;\n    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;\n    float sx = size.x, sy = size.y, sz = size.z;\n\n    mat4 particleMatrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column\n                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column\n                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column\n                      offset.x, offset.y, offset.z, 1.0);\n\n#include <color_vertex>\n#include <morphinstance_vertex>\n#include <morphcolor_vertex>\n#include <batching_vertex>\n\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n\n\t// replace defaultnormal_vertex\n\tvec3 transformedNormal = objectNormal;\n    mat3 m = mat3( particleMatrix );\n    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n    transformedNormal = m * transformedNormal;\n    transformedNormal = normalMatrix * transformedNormal;\n    #ifdef FLIP_SIDED\n        transformedNormal = - transformedNormal;\n    #endif\n    #ifdef USE_TANGENT\n        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n        #ifdef FLIP_SIDED\n        transformedTangent = - transformedTangent;\n        #endif\n    #endif\n\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\n\t// replace include <project_vertex>\n  vec4 mvPosition = vec4( transformed, 1.0 );\n  mvPosition = modelViewMatrix * (particleMatrix * mvPosition);\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t\n\tvViewPosition = - mvPosition.xyz;\n\t\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n    vWorldPosition = worldPosition.xyz;\n#endif\n}\n";function Qt(e){return 0===e?"uv":"uv".concat(e)}class $t extends o{constructor(e){super(e)}onBeforeCompile(e,t){super.onBeforeCompile(e,t),e.vertexShader=Kt,e.fragmentShader=Zt}}class ei extends l{constructor(e){super(e)}onBeforeCompile(e,t){super.onBeforeCompile(e,t),e.vertexShader=Kt,e.fragmentShader=Zt}}new W(0,0,1);class ti extends Gt{constructor(e){super(e),this.vector_=new W,this.vector2_=new W,this.vector3_=new W,this.quaternion_=new te,this.quaternion2_=new te,this.quaternion3_=new te,this.rotationMat_=new J,this.rotationMat2_=new J,this.maxParticles=1e3,this.setupBuffers(),this.rebuildMaterial()}buildExpandableBuffers(){this.offsetBuffer=new d(new Float32Array(3*this.maxParticles),3),this.offsetBuffer.setUsage(m),this.geometry.setAttribute("offset",this.offsetBuffer),this.colorBuffer=new d(new Float32Array(4*this.maxParticles),4),this.colorBuffer.setUsage(m),this.geometry.setAttribute("color",this.colorBuffer),this.settings.renderMode===Vt.Mesh?(this.rotationBuffer=new d(new Float32Array(4*this.maxParticles),4),this.rotationBuffer.setUsage(m),this.geometry.setAttribute("rotation",this.rotationBuffer)):this.settings.renderMode!==Vt.BillBoard&&this.settings.renderMode!==Vt.HorizontalBillBoard&&this.settings.renderMode!==Vt.VerticalBillBoard&&this.settings.renderMode!==Vt.StretchedBillBoard||(this.rotationBuffer=new d(new Float32Array(this.maxParticles),1),this.rotationBuffer.setUsage(m),this.geometry.setAttribute("rotation",this.rotationBuffer)),this.sizeBuffer=new d(new Float32Array(3*this.maxParticles),3),this.sizeBuffer.setUsage(m),this.geometry.setAttribute("size",this.sizeBuffer),this.uvTileBuffer=new d(new Float32Array(this.maxParticles),1),this.uvTileBuffer.setUsage(m),this.geometry.setAttribute("uvTile",this.uvTileBuffer),this.settings.renderMode===Vt.StretchedBillBoard&&(this.velocityBuffer=new d(new Float32Array(4*this.maxParticles),4),this.velocityBuffer.setUsage(m),this.geometry.setAttribute("velocity",this.velocityBuffer))}setupBuffers(){this.geometry&&this.geometry.dispose(),this.geometry=new f,this.geometry.setIndex(this.settings.instancingGeometry.getIndex()),this.settings.instancingGeometry.hasAttribute("normal")&&this.geometry.setAttribute("normal",this.settings.instancingGeometry.getAttribute("normal")),this.geometry.setAttribute("position",this.settings.instancingGeometry.getAttribute("position")),this.geometry.setAttribute("uv",this.settings.instancingGeometry.getAttribute("uv")),this.buildExpandableBuffers()}expandBuffers(e){for(;e>=this.maxParticles;)this.maxParticles*=2;this.setupBuffers()}rebuildMaterial(){this.layers.mask=this.settings.layers.mask;const e={},t={};"MeshStandardMaterial"!==this.settings.material.type&&"MeshPhysicalMaterial"!==this.settings.material.type&&(e.map=new c(this.settings.material.map)),this.settings.material.alphaTest&&(t.USE_ALPHATEST="",e.alphaTest=new c(this.settings.material.alphaTest)),t.USE_UV="";const i=this.settings.uTileCount,n=this.settings.vTileCount;let r;if((i>1||n>1)&&(t.UV_TILE="",e.tileCount=new c(new de(i,n))),this.settings.material.defines&&void 0!==this.settings.material.defines.USE_COLOR_AS_ALPHA&&(t.USE_COLOR_AS_ALPHA=""),this.settings.material.normalMap&&(t.USE_NORMALMAP="",t.NORMALMAP_UV=Qt(this.settings.material.normalMap.channel),e.normalMapTransform=new c((new J).copy(this.settings.material.normalMap.matrix))),this.settings.material.map&&(t.USE_MAP="",this.settings.blendTiles&&(t.TILE_BLEND=""),t.MAP_UV=Qt(this.settings.material.map.channel),e.mapTransform=new c((new J).copy(this.settings.material.map.matrix))),t.USE_COLOR_ALPHA="",this.settings.softParticles){t.SOFT_PARTICLES="";const i=this.settings.softNearFade,n=1/(this.settings.softFarFade-this.settings.softNearFade);e.softParams=new c(new de(i,n)),e.depthTexture=new c(null);const s=e.projParams=new c(new K);r=(e,t,i)=>{s.value.set(i.near,i.far,0,0)}}let s=!1;if(this.settings.renderMode===Vt.BillBoard||this.settings.renderMode===Vt.VerticalBillBoard||this.settings.renderMode===Vt.HorizontalBillBoard||this.settings.renderMode===Vt.Mesh){let i,n;this.settings.renderMode===Vt.Mesh?"MeshStandardMaterial"===this.settings.material.type||"MeshPhysicalMaterial"===this.settings.material.type?(t.USE_COLOR="",i=Kt,n=Zt,s=!0):(i="\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute vec4 rotation;\nattribute vec3 size;\n// attribute vec4 color;\n\nvoid main() {\n\n    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;\n    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;\n    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;\n    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;\n    float sx = size.x, sy = size.y, sz = size.z;\n    \n    mat4 matrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column\n                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column\n                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column\n                      offset.x, offset.y, offset.z, 1.0);\n    \n    vec4 mvPosition = modelViewMatrix * (matrix * vec4( position, 1.0 ));\n\n\tvColor = color;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n    #include <tile_vertex>\n    #include <soft_vertex>\n}\n",n=Jt):(i="\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute float rotation;\nattribute vec3 size;\n\nvoid main() {\n\t\n    vec2 alignedPosition = position.xy * size.xy;\n    \n    vec2 rotatedPosition;\n    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n#ifdef HORIZONTAL\n    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );\n    mvPosition.x += rotatedPosition.x;\n    mvPosition.z -= rotatedPosition.y;\n    mvPosition = viewMatrix * mvPosition;\n#elif defined(VERTICAL)\n    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );\n    mvPosition.y += rotatedPosition.y;\n    mvPosition = viewMatrix * mvPosition;\n    mvPosition.x += rotatedPosition.x;\n#else\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    mvPosition.xy += rotatedPosition;\n#endif\n\n\tvColor = color;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\n\t#include <clipping_planes_vertex>\n\n\t#include <tile_vertex>\n\t#include <soft_vertex>\n}\n",n=Jt),this.settings.renderMode===Vt.VerticalBillBoard?t.VERTICAL="":this.settings.renderMode===Vt.HorizontalBillBoard&&(t.HORIZONTAL="");let r=!1;this.settings.renderMode===Vt.Mesh&&("MeshStandardMaterial"===this.settings.material.type?(this.material=new $t({}),this.material.copy(this.settings.material),this.material.uniforms=e,this.material.defines=t,r=!0):"MeshPhysicalMaterial"===this.settings.material.type&&(this.material=new ei({}),this.material.copy(this.settings.material),this.material.uniforms=e,this.material.defines=t,r=!0)),r||(this.material=new h({uniforms:e,defines:t,vertexShader:i,fragmentShader:n,transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,blending:this.settings.material.blending,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha,side:this.settings.material.side,alphaTest:this.settings.material.alphaTest,depthTest:this.settings.material.depthTest,lights:s}))}else{if(this.settings.renderMode!==Vt.StretchedBillBoard)throw new Error("render mode unavailable");e.speedFactor=new c(1),this.material=new h({uniforms:e,defines:t,vertexShader:"\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute float rotation;\nattribute vec3 size;\nattribute vec4 velocity;\n\nuniform float speedFactor;\n\nvoid main() {\n    float lengthFactor = velocity.w;\n    float avgSize = (size.x + size.y) * 0.5;\n#ifdef USE_SKEW\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    vec3 viewVelocity = normalMatrix * velocity.xyz;\n\n    vec3 scaledPos = vec3(position.xy * size.xy, position.z);\n    float vlength = length(viewVelocity);\n    vec3 projVelocity =  dot(scaledPos, viewVelocity) * viewVelocity / vlength;\n    mvPosition.xyz += scaledPos + projVelocity * (speedFactor / avgSize + lengthFactor / vlength);\n#else\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    vec3 viewVelocity = normalMatrix * velocity.xyz;\n    float vlength = length(viewVelocity); \n    mvPosition.xyz += position.y * normalize(cross(mvPosition.xyz, viewVelocity)) * avgSize; // switch the cross to  match unity implementation\n    mvPosition.xyz -= (position.x + 0.5) * viewVelocity * (1.0 + lengthFactor / vlength) * avgSize; // minus position.x to match unity implementation\n#endif\n\tvColor = color;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <tile_vertex>\n\t#include <soft_vertex>\n}\n",fragmentShader:Jt,transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,blending:this.settings.material.blending,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha,side:this.settings.material.side,alphaTest:this.settings.material.alphaTest,depthTest:this.settings.material.depthTest})}this.material&&r&&(this.material.onBeforeRender=r)}update(){let e=0,t=0;this.systems.forEach((e=>{t+=e.particleNum})),t>this.maxParticles&&this.expandBuffers(t),this.systems.forEach((t=>{t.emitter.updateMatrixWorld&&(t.emitter.updateWorldMatrix(!0,!1),t.emitter.updateMatrixWorld(!0));const i=t.particles,n=t.particleNum,r=this.quaternion2_,s=this.vector2_,a=this.vector3_;t.emitter.matrixWorld.decompose(s,r,a),this.rotationMat_.setFromMatrix4(t.emitter.matrixWorld);for(let o=0;o<n;o++,e++){const n=i[o];if(this.settings.renderMode===Vt.Mesh){let i;if(t.worldSpace)i=n.rotation;else{let e;e=n.parentMatrix?this.quaternion3_.setFromRotationMatrix(n.parentMatrix):r,i=this.quaternion_,i.copy(e).multiply(n.rotation)}this.rotationBuffer.setXYZW(e,i.x,i.y,i.z,i.w)}else this.settings.renderMode!==Vt.StretchedBillBoard&&this.settings.renderMode!==Vt.VerticalBillBoard&&this.settings.renderMode!==Vt.HorizontalBillBoard&&this.settings.renderMode!==Vt.BillBoard||this.rotationBuffer.setX(e,n.rotation);let s;if(t.worldSpace?s=n.position:(s=this.vector_,n.parentMatrix?s.copy(n.position).applyMatrix4(n.parentMatrix):s.copy(n.position).applyMatrix4(t.emitter.matrixWorld)),this.offsetBuffer.setXYZ(e,s.x,s.y,s.z),this.colorBuffer.setXYZW(e,n.color.x,n.color.y,n.color.z,n.color.w),t.worldSpace||n.parentMatrix?this.sizeBuffer.setXYZ(e,n.size.x,n.size.y,n.size.z):this.sizeBuffer.setXYZ(e,n.size.x*Math.abs(a.x),n.size.y*Math.abs(a.y),n.size.z*Math.abs(a.z)),this.uvTileBuffer.setX(e,n.uvTile),this.settings.renderMode===Vt.StretchedBillBoard&&this.velocityBuffer){let i=t.rendererEmitterSettings.speedFactor;0===i&&(i=.001);const r=t.rendererEmitterSettings.lengthFactor;let s;t.worldSpace?s=n.velocity:(s=this.vector_,n.parentMatrix?(this.rotationMat2_.setFromMatrix4(n.parentMatrix),s.copy(n.velocity).applyMatrix3(this.rotationMat2_)):s.copy(n.velocity).applyMatrix3(this.rotationMat_)),this.velocityBuffer.setXYZW(e,s.x*i,s.y*i,s.z*i,r)}}})),this.geometry.instanceCount=e,e>0&&(this.offsetBuffer.clearUpdateRanges(),this.offsetBuffer.addUpdateRange(0,3*e),this.offsetBuffer.needsUpdate=!0,this.sizeBuffer.clearUpdateRanges(),this.sizeBuffer.addUpdateRange(0,3*e),this.sizeBuffer.needsUpdate=!0,this.colorBuffer.clearUpdateRanges(),this.colorBuffer.addUpdateRange(0,4*e),this.colorBuffer.needsUpdate=!0,this.uvTileBuffer.clearUpdateRanges(),this.uvTileBuffer.addUpdateRange(0,e),this.uvTileBuffer.needsUpdate=!0,this.settings.renderMode===Vt.StretchedBillBoard&&this.velocityBuffer&&(this.velocityBuffer.clearUpdateRanges(),this.velocityBuffer.addUpdateRange(0,4*e),this.velocityBuffer.needsUpdate=!0),this.settings.renderMode===Vt.Mesh?(this.rotationBuffer.clearUpdateRanges(),this.rotationBuffer.addUpdateRange(0,4*e),this.rotationBuffer.needsUpdate=!0):this.settings.renderMode!==Vt.StretchedBillBoard&&this.settings.renderMode!==Vt.HorizontalBillBoard&&this.settings.renderMode!==Vt.VerticalBillBoard&&this.settings.renderMode!==Vt.BillBoard||(this.rotationBuffer.clearUpdateRanges(),this.rotationBuffer.addUpdateRange(0,e),this.rotationBuffer.needsUpdate=!0))}dispose(){this.geometry.dispose()}}new W(0,0,1);class ii extends Gt{constructor(e){super(e),this.vector_=new W,this.vector2_=new W,this.vector3_=new W,this.quaternion_=new te,this.maxParticles=1e4,this.setupBuffers(),this.rebuildMaterial()}setupBuffers(){this.geometry&&this.geometry.dispose(),this.geometry=new u,this.indexBuffer=new p(new Uint32Array(6*this.maxParticles),1),this.indexBuffer.setUsage(m),this.geometry.setIndex(this.indexBuffer),this.positionBuffer=new p(new Float32Array(6*this.maxParticles),3),this.positionBuffer.setUsage(m),this.geometry.setAttribute("position",this.positionBuffer),this.previousBuffer=new p(new Float32Array(6*this.maxParticles),3),this.previousBuffer.setUsage(m),this.geometry.setAttribute("previous",this.previousBuffer),this.nextBuffer=new p(new Float32Array(6*this.maxParticles),3),this.nextBuffer.setUsage(m),this.geometry.setAttribute("next",this.nextBuffer),this.widthBuffer=new p(new Float32Array(2*this.maxParticles),1),this.widthBuffer.setUsage(m),this.geometry.setAttribute("width",this.widthBuffer),this.sideBuffer=new p(new Float32Array(2*this.maxParticles),1),this.sideBuffer.setUsage(m),this.geometry.setAttribute("side",this.sideBuffer),this.uvBuffer=new p(new Float32Array(4*this.maxParticles),2),this.uvBuffer.setUsage(m),this.geometry.setAttribute("uv",this.uvBuffer),this.colorBuffer=new p(new Float32Array(8*this.maxParticles),4),this.colorBuffer.setUsage(m),this.geometry.setAttribute("color",this.colorBuffer)}expandBuffers(e){for(;e>=this.maxParticles;)this.maxParticles*=2;this.setupBuffers()}rebuildMaterial(){this.layers.mask=this.settings.layers.mask;const e={lineWidth:{value:1},map:{value:null},useMap:{value:0},alphaMap:{value:null},useAlphaMap:{value:0},resolution:{value:new de(1,1)},sizeAttenuation:{value:1},visibility:{value:1},alphaTest:{value:0}},t={USE_UV:"",USE_COLOR_ALPHA:""};if(this.settings.material.map&&(t.USE_MAP="",t.MAP_UV=Qt(this.settings.material.map.channel),e.map=new c(this.settings.material.map),e.mapTransform=new c((new J).copy(this.settings.material.map.matrix))),this.settings.material.defines&&void 0!==this.settings.material.defines.USE_COLOR_AS_ALPHA&&(t.USE_COLOR_AS_ALPHA=""),this.settings.renderMode!==Vt.Trail)throw new Error("render mode unavailable");this.material=new h({uniforms:e,defines:t,vertexShader:"\n#include <common>\n#include <tile_pars_vertex>\n#include <color_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <fog_pars_vertex>\n\nattribute vec3 previous;\nattribute vec3 next;\nattribute float side;\nattribute float width;\n\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform float sizeAttenuation;\n    \nvec2 fix(vec4 i, float aspect) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n    return res;\n}\n    \nvoid main() {\n\n    #include <tile_vertex>\n    \n    float aspect = resolution.x / resolution.y;\n\n    vColor = color;\n\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec4 finalPosition = m * vec4( position, 1.0 );\n    vec4 prevPos = m * vec4( previous, 1.0 );\n    vec4 nextPos = m * vec4( next, 1.0 );\n\n    vec2 currentP = fix( finalPosition, aspect );\n    vec2 prevP = fix( prevPos, aspect );\n    vec2 nextP = fix( nextPos, aspect );\n\n    float w = lineWidth * width;\n\n    vec2 dir;\n    if( nextP == currentP ) dir = normalize( currentP - prevP );\n    else if( prevP == currentP ) dir = normalize( nextP - currentP );\n    else {\n        vec2 dir1 = normalize( currentP - prevP );\n        vec2 dir2 = normalize( nextP - currentP );\n        dir = normalize( dir1 + dir2 );\n\n        vec2 perp = vec2( -dir1.y, dir1.x );\n        vec2 miter = vec2( -dir.y, dir.x );\n        //w = clamp( w / dot( miter, perp ), 0., 4., * lineWidth * width );\n\n    }\n\n    //vec2 normal = ( cross( vec3( dir, 0. ) vec3( 0., 0., 1. ) ) ).xy;\n    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );\n    normal.xy *= .5 * w;\n    normal *= projectionMatrix;\n    if( sizeAttenuation == 0. ) {\n        normal.xy *= finalPosition.w;\n        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;\n    }\n\n    finalPosition.xy += normal.xy * side;\n\n    gl_Position = finalPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    \n\t#include <fog_vertex>\n}",fragmentShader:"\n\n#include <common>\n#include <tile_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nuniform sampler2D alphaMap;\nuniform float useAlphaMap;\nuniform float visibility;\nuniform float alphaTest;\n\nvarying vec4 vColor;\n    \nvoid main() {\n    #include <clipping_planes_fragment>\n    #include <logdepthbuf_fragment>\n\n    vec4 diffuseColor = vColor;\n    \n    #ifdef USE_MAP\n    #include <tile_fragment>\n    #ifndef USE_COLOR_AS_ALPHA\n    #endif\n    #endif\n    if( useAlphaMap == 1. ) diffuseColor.a *= texture2D( alphaMap, vUv).a;\n    if( diffuseColor.a < alphaTest ) discard;\n    gl_FragColor = diffuseColor;\n\n    #include <fog_fragment>\n    #include <tonemapping_fragment>\n}",transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,side:this.settings.material.side,blending:this.settings.material.blending||a,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha})}update(){let e=0,t=0,i=0;this.systems.forEach((e=>{for(let t=0;t<e.particleNum;t++)i+=2*e.particles[t].previous.length})),i>this.maxParticles&&this.expandBuffers(i),this.systems.forEach((i=>{i.emitter.updateMatrixWorld&&(i.emitter.updateWorldMatrix(!0,!1),i.emitter.updateMatrixWorld(!0));const n=this.quaternion_,r=this.vector2_,s=this.vector3_;i.emitter.matrixWorld.decompose(r,n,s);const a=i.particles,o=i.particleNum,l=this.settings.uTileCount,d=this.settings.vTileCount,m=1/l,f=1/d;for(let c=0;c<o;c++){const n=a[c],r=n.uvTile%d,o=Math.floor(n.uvTile/d+.001),l=n.previous.values();let h,u=l.next(),p=u.value,v=p;u.done||(u=l.next()),h=void 0!==u.value?u.value:v;for(let a=0;a<n.previous.length;a++,e+=2){if(this.positionBuffer.setXYZ(e,v.position.x,v.position.y,v.position.z),this.positionBuffer.setXYZ(e+1,v.position.x,v.position.y,v.position.z),i.worldSpace?(this.positionBuffer.setXYZ(e,v.position.x,v.position.y,v.position.z),this.positionBuffer.setXYZ(e+1,v.position.x,v.position.y,v.position.z)):(n.parentMatrix?this.vector_.copy(v.position).applyMatrix4(n.parentMatrix):this.vector_.copy(v.position).applyMatrix4(i.emitter.matrixWorld),this.positionBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.positionBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),i.worldSpace?(this.previousBuffer.setXYZ(e,p.position.x,p.position.y,p.position.z),this.previousBuffer.setXYZ(e+1,p.position.x,p.position.y,p.position.z)):(n.parentMatrix?this.vector_.copy(p.position).applyMatrix4(n.parentMatrix):this.vector_.copy(p.position).applyMatrix4(i.emitter.matrixWorld),this.previousBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.previousBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),i.worldSpace?(this.nextBuffer.setXYZ(e,h.position.x,h.position.y,h.position.z),this.nextBuffer.setXYZ(e+1,h.position.x,h.position.y,h.position.z)):(n.parentMatrix?this.vector_.copy(h.position).applyMatrix4(n.parentMatrix):this.vector_.copy(h.position).applyMatrix4(i.emitter.matrixWorld),this.nextBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.nextBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),this.sideBuffer.setX(e,-1),this.sideBuffer.setX(e+1,1),i.worldSpace)this.widthBuffer.setX(e,v.size),this.widthBuffer.setX(e+1,v.size);else if(n.parentMatrix)this.widthBuffer.setX(e,v.size),this.widthBuffer.setX(e+1,v.size);else{const t=(Math.abs(s.x)+Math.abs(s.y)+Math.abs(s.z))/3;this.widthBuffer.setX(e,v.size*t),this.widthBuffer.setX(e+1,v.size*t)}this.uvBuffer.setXY(e,(a/n.previous.length+r)*m,(d-o-1)*f),this.uvBuffer.setXY(e+1,(a/n.previous.length+r)*m,(d-o)*f),this.colorBuffer.setXYZW(e,v.color.x,v.color.y,v.color.z,v.color.w),this.colorBuffer.setXYZW(e+1,v.color.x,v.color.y,v.color.z,v.color.w),a+1<n.previous.length&&(this.indexBuffer.setX(3*t,e),this.indexBuffer.setX(3*t+1,e+1),this.indexBuffer.setX(3*t+2,e+2),t++,this.indexBuffer.setX(3*t,e+2),this.indexBuffer.setX(3*t+1,e+1),this.indexBuffer.setX(3*t+2,e+3),t++),p=v,v=h,u.done||(u=l.next(),void 0!==u.value&&(h=u.value))}}})),this.positionBuffer.clearUpdateRanges(),this.positionBuffer.addUpdateRange(0,3*e),this.positionBuffer.needsUpdate=!0,this.previousBuffer.clearUpdateRanges(),this.previousBuffer.addUpdateRange(0,3*e),this.previousBuffer.needsUpdate=!0,this.nextBuffer.clearUpdateRanges(),this.nextBuffer.addUpdateRange(0,3*e),this.nextBuffer.needsUpdate=!0,this.sideBuffer.clearUpdateRanges(),this.sideBuffer.addUpdateRange(0,e),this.sideBuffer.needsUpdate=!0,this.widthBuffer.clearUpdateRanges(),this.widthBuffer.addUpdateRange(0,e),this.widthBuffer.needsUpdate=!0,this.uvBuffer.clearUpdateRanges(),this.uvBuffer.addUpdateRange(0,2*e),this.uvBuffer.needsUpdate=!0,this.colorBuffer.clearUpdateRanges(),this.colorBuffer.addUpdateRange(0,4*e),this.colorBuffer.needsUpdate=!0,this.indexBuffer.clearUpdateRanges(),this.indexBuffer.addUpdateRange(0,3*t),this.indexBuffer.needsUpdate=!0,this.geometry.setDrawRange(0,3*t)}dispose(){this.geometry.dispose()}}class ni{get geometry(){return this._geometry}set geometry(e){if(this._geometry=e,void 0===e)return;if("string"==typeof e)return;const t=new v;this._triangleIndexToArea.length=0;let i=0;if(!e.getIndex())return;const n=e.getIndex().array,r=n.length/3;this._triangleIndexToArea.push(0);for(let s=0;s<r;s++)t.setFromAttributeAndIndices(e.getAttribute("position"),n[3*s],n[3*s+1],n[3*s+2]),i+=t.getArea(),this._triangleIndexToArea.push(i);e.userData.triangleIndexToArea=this._triangleIndexToArea}constructor(e){this.type="mesh_surface",this._triangleIndexToArea=[],this._tempA=new g,this._tempB=new g,this._tempC=new g,e&&(this.geometry=e)}initialize(e){const t=this._geometry;if(!t||null===t.getIndex())return e.position.set(0,0,0),void e.velocity.set(0,0,1).multiplyScalar(e.startSpeed);const i=this._triangleIndexToArea.length-1;let n=0,r=i;const s=Math.random()*this._triangleIndexToArea[i];for(;n+1<r;){const e=Math.floor((n+r)/2);s<this._triangleIndexToArea[e]?r=e:n=e}let a=Math.random(),o=Math.random();a+o>1&&(a=1-a,o=1-o);const l=t.getIndex().array[3*n],d=t.getIndex().array[3*n+1],m=t.getIndex().array[3*n+2],f=t.getAttribute("position");this._tempA.fromBufferAttribute(f,l),this._tempB.fromBufferAttribute(f,d),this._tempC.fromBufferAttribute(f,m),this._tempB.sub(this._tempA),this._tempC.sub(this._tempA),this._tempA.addScaledVector(this._tempB,a).addScaledVector(this._tempC,o),e.position.copy(this._tempA),this._tempA.copy(this._tempB).cross(this._tempC).normalize(),e.velocity.copy(this._tempA).normalize().multiplyScalar(e.startSpeed)}toJSON(){return{type:"mesh_surface",mesh:this._geometry?this._geometry.uuid:""}}static fromJSON(e,t){return new ni(t.geometries[e.geometry])}clone(){return new ni(this._geometry)}update(e,t){}}oe({id:"three.quarks",initialize:()=>{},emitterShapes:[{type:"mesh_surface",params:[["geometry",["geometry"]]],constructor:ni,loadJSON:ni.fromJSON}],behaviors:[]});class ri extends e{constructor(){super(),this.batches=[],this.systemToBatchIndex=new Map,this.type="BatchedRenderer",this.depthTexture=null}static equals(e,t){return e.material.side===t.material.side&&e.material.blending===t.material.blending&&e.material.blendSrc===t.material.blendSrc&&e.material.blendDst===t.material.blendDst&&e.material.blendEquation===t.material.blendEquation&&e.material.premultipliedAlpha===t.material.premultipliedAlpha&&e.material.transparent===t.material.transparent&&e.material.depthTest===t.material.depthTest&&e.material.type===t.material.type&&e.material.alphaTest===t.material.alphaTest&&e.material.map===t.material.map&&e.renderMode===t.renderMode&&e.blendTiles===t.blendTiles&&e.softParticles===t.softParticles&&e.softFarFade===t.softFarFade&&e.softNearFade===t.softNearFade&&e.uTileCount===t.uTileCount&&e.vTileCount===t.vTileCount&&e.instancingGeometry===t.instancingGeometry&&e.renderOrder===t.renderOrder&&e.layers.mask===t.layers.mask}addSystem(e){e._renderer=this;const t=e.getRendererSettings();for(let n=0;n<this.batches.length;n++)if(ri.equals(this.batches[n].settings,t))return this.batches[n].addSystem(e),void this.systemToBatchIndex.set(e,n);let i;switch(t.renderMode){case Vt.Trail:i=new ii(t);break;case Vt.Mesh:case Vt.BillBoard:case Vt.VerticalBillBoard:case Vt.HorizontalBillBoard:case Vt.StretchedBillBoard:i=new ti(t)}this.depthTexture&&i.applyDepthTexture(this.depthTexture),i.addSystem(e),this.batches.push(i),this.systemToBatchIndex.set(e,this.batches.length-1),this.add(i)}deleteSystem(e){const t=this.systemToBatchIndex.get(e);null!=t&&(this.batches[t].removeSystem(e),this.systemToBatchIndex.delete(e))}setDepthTexture(e){this.depthTexture=e;for(const t of this.batches)t.applyDepthTexture(e)}updateSystem(e){this.deleteSystem(e),this.addSystem(e)}update(e){this.systemToBatchIndex.forEach(((t,i)=>{i.update(e)}));for(let t=0;t<this.batches.length;t++)this.batches[t].update()}}const si=ri;class ai{static runOnAllParticleEmitters(e,t){e.traverse((e=>{"ParticleEmitter"===e.type&&t(e)})),"ParticleEmitter"===e.type&&t(e)}static addToBatchRenderer(e,t){ai.runOnAllParticleEmitters(e,(e=>{t.addSystem(e.system)}))}static play(e){ai.runOnAllParticleEmitters(e,(e=>{e.system.play()}))}static stop(e){ai.runOnAllParticleEmitters(e,(e=>{e.system.stop()}))}static setAutoDestroy(e,t){ai.runOnAllParticleEmitters(e,(e=>{e.system.autoDestroy=t}))}static endEmit(e){ai.runOnAllParticleEmitters(e,(e=>{e.system.endEmit()}))}static restart(e){ai.runOnAllParticleEmitters(e,(e=>{e.system.restart()}))}static pause(e){ai.runOnAllParticleEmitters(e,(e=>{e.system.pause()}))}}Ft(),console.log("%c Particle system powered by three.quarks. https://quarks.art/","font-size: 14px; font-weight: bold;");const oi=Object.freeze(Object.defineProperty({__proto__:null,ApplyCollision:me,ApplyForce:fe,ApplySequences:ce,AxisAngleGenerator:q,BatchedParticleRenderer:si,BatchedRenderer:ri,BehaviorFromJSON:ae,BehaviorTypes:he,Bezier:ue,ChangeEmitDirection:pe,CircleEmitter:ve,ColorBySpeed:ge,ColorGeneratorFromJSON:se,ColorOverLife:ye,ColorRange:_e,ConeEmitter:Se,ConstantColor:Z,ConstantValue:Y,DEG2RAD:xe,DonutEmitter:Me,EmitSubParticleSystem:le,EmitterFromJSON:ie,get EmitterMode(){return Te},EmitterShapes:Ee,Euler:Ue,EulerGenerator:Ae,ForceOverLife:Pe,FrameOverLife:we,GeneratorFromJSON:re,Gradient:be,GravityForce:Be,GridEmitter:Ce,HemisphereEmitter:Oe,IntervalValue:Re,LimitSpeedOverLife:Ne,MathUtils:ze,Matrix3:J,Matrix4:Le,MeshSurfaceEmitter:ni,NodeParticle:Ie,Noise:Fe,OrbitOverLife:De,ParticleEmitter:Dt,ParticleMeshPhysicsMaterial:ei,ParticleMeshStandardMaterial:$t,ParticleSystem:qt,PiecewiseBezier:Ve,PiecewiseFunction:ke,Plugins:Ge,PointEmitter:He,QuarksLoader:class extends y{constructor(e){super(e)}linkReference(e){const t={};e.traverse((function(e){t[e.uuid]=e})),e.traverse((function(e){if("ParticleEmitter"===e.type){const i=e.system;i.emitterShape;for(let e=0;e<i.behaviors.length;e++)i.behaviors[e]instanceof le&&(i.behaviors[e].subParticleSystem=t[i.behaviors[e].subParticleSystem])}}))}parse(e,t){const i=super.parse(e,t);return this.linkReference(i),i}parseObject(i,n,r,s,a){let o,l,m;function f(e){return void 0===n[e]&&console.warn("THREE.ObjectLoader: Undefined geometry",e),n[e]}function c(e){if(void 0!==e){if(Array.isArray(e)){const t=[];for(let i=0,n=e.length;i<n;i++){const n=e[i];void 0===r[n]&&console.warn("THREE.ObjectLoader: Undefined material",n),t.push(r[n])}return t}return void 0===r[e]&&console.warn("THREE.ObjectLoader: Undefined material",e),r[e]}}function h(e){return void 0===s[e]&&console.warn("THREE.ObjectLoader: Undefined texture",e),s[e]}const u={textures:s,geometries:n,materials:r},p={};switch(i.type){case"ParticleEmitter":o=qt.fromJSON(i.ps,u,p).emitter;break;case"Scene":o=new k,void 0!==i.background&&(Number.isInteger(i.background)?o.background=new G(i.background):o.background=h(i.background)),void 0!==i.environment&&(o.environment=h(i.environment)),void 0!==i.fog&&("Fog"===i.fog.type?o.fog=new H(i.fog.color,i.fog.near,i.fog.far):"FogExp2"===i.fog.type&&(o.fog=new j(i.fog.color,i.fog.density)),""!==i.fog.name&&(o.fog.name=i.fog.name)),void 0!==i.backgroundBlurriness&&(o.backgroundBlurriness=i.backgroundBlurriness),void 0!==i.backgroundIntensity&&(o.backgroundIntensity=i.backgroundIntensity),void 0!==i.backgroundRotation&&o.backgroundRotation.fromArray(i.backgroundRotation),void 0!==i.environmentIntensity&&(o.environmentIntensity=i.environmentIntensity),void 0!==i.environmentRotation&&o.environmentRotation.fromArray(i.environmentRotation);break;case"PerspectiveCamera":o=new V(i.fov,i.aspect,i.near,i.far),void 0!==i.focus&&(o.focus=i.focus),void 0!==i.zoom&&(o.zoom=i.zoom),void 0!==i.filmGauge&&(o.filmGauge=i.filmGauge),void 0!==i.filmOffset&&(o.filmOffset=i.filmOffset),void 0!==i.view&&(o.view=Object.assign({},i.view));break;case"OrthographicCamera":o=new D(i.left,i.right,i.top,i.bottom,i.near,i.far),void 0!==i.zoom&&(o.zoom=i.zoom),void 0!==i.view&&(o.view=Object.assign({},i.view));break;case"AmbientLight":o=new F(i.color,i.intensity);break;case"DirectionalLight":o=new I(i.color,i.intensity);break;case"PointLight":o=new L(i.color,i.intensity,i.distance,i.decay);break;case"RectAreaLight":o=new z(i.color,i.intensity,i.width,i.height);break;case"SpotLight":o=new N(i.color,i.intensity,i.distance,i.angle,i.penumbra,i.decay);break;case"HemisphereLight":o=new R(i.color,i.groundColor,i.intensity);break;case"LightProbe":o=(new O).fromJSON(i);break;case"SkinnedMesh":l=f(i.geometry),m=c(i.material),o=new C(l,m),void 0!==i.bindMode&&(o.bindMode=i.bindMode),void 0!==i.bindMatrix&&o.bindMatrix.fromArray(i.bindMatrix),void 0!==i.skeleton&&(o.skeleton=i.skeleton);break;case"Mesh":l=f(i.geometry),m=c(i.material),o=new t(l,m);break;case"InstancedMesh":{l=f(i.geometry),m=c(i.material);const e=i.count,t=i.instanceMatrix,n=i.instanceColor;o=new B(l,m,e),o.instanceMatrix=new d(new Float32Array(t.array),16),void 0!==n&&(o.instanceColor=new d(new Float32Array(n.array),n.itemSize));break}case"BatchedMesh":l=f(i.geometry),m=c(i.material),o=new P(i.maxGeometryCount,i.maxVertexCount,i.maxIndexCount,m),o.geometry=l,o.perObjectFrustumCulled=i.perObjectFrustumCulled,o.sortObjects=i.sortObjects,o._drawRanges=i.drawRanges,o._reservedRanges=i.reservedRanges,o._visibility=i.visibility,o._active=i.active,o._bounds=i.bounds.map((e=>{const t=new w;t.min.fromArray(e.boxMin),t.max.fromArray(e.boxMax);const i=new b;return i.radius=e.sphereRadius,i.center.fromArray(e.sphereCenter),{boxInitialized:e.boxInitialized,box:t,sphereInitialized:e.sphereInitialized,sphere:i}})),o._maxGeometryCount=i.maxGeometryCount,o._maxVertexCount=i.maxVertexCount,o._maxIndexCount=i.maxIndexCount,o._geometryInitialized=i.geometryInitialized,o._geometryCount=i.geometryCount,o._matricesTexture=h(i.matricesTexture.uuid);break;case"LOD":o=new A;break;case"Line":o=new U(f(i.geometry),c(i.material));break;case"LineLoop":o=new E(f(i.geometry),c(i.material));break;case"LineSegments":o=new T(f(i.geometry),c(i.material));break;case"PointCloud":case"Points":o=new M(f(i.geometry),c(i.material));break;case"Sprite":o=new x(c(i.material));break;case"Group":o=new S;break;case"Bone":o=new _;break;default:o=new e}if(o.uuid=i.uuid,void 0!==i.name&&(o.name=i.name),void 0!==i.matrix?(o.matrix.fromArray(i.matrix),void 0!==i.matrixAutoUpdate&&(o.matrixAutoUpdate=i.matrixAutoUpdate),o.matrixAutoUpdate&&(o.matrix.decompose(o.position,o.quaternion,o.scale),isNaN(o.quaternion.x)&&o.quaternion.set(0,0,0,1))):(void 0!==i.position&&o.position.fromArray(i.position),void 0!==i.rotation&&o.rotation.fromArray(i.rotation),void 0!==i.quaternion&&o.quaternion.fromArray(i.quaternion),void 0!==i.scale&&o.scale.fromArray(i.scale)),void 0!==i.up&&o.up.fromArray(i.up),void 0!==i.castShadow&&(o.castShadow=i.castShadow),void 0!==i.receiveShadow&&(o.receiveShadow=i.receiveShadow),i.shadow&&(void 0!==i.shadow.bias&&(o.shadow.bias=i.shadow.bias),void 0!==i.shadow.normalBias&&(o.normalBias=i.shadow.normalBias),void 0!==i.shadow.radius&&(o.radius=i.shadow.radius),void 0!==i.shadow.mapSize&&o.mapSize.fromArray(i.shadow.mapSize),void 0!==i.shadow.camera&&(o.camera=this.parseObject(i.shadow.camera))),void 0!==i.visible&&(o.visible=i.visible),void 0!==i.frustumCulled&&(o.frustumCulled=i.frustumCulled),void 0!==i.renderOrder&&(o.renderOrder=i.renderOrder),void 0!==i.userData&&(o.userData=i.userData),void 0!==i.layers&&(o.layers.mask=i.layers),void 0!==i.children){const e=i.children;for(let t=0;t<e.length;t++)o.add(this.parseObject(e[t],n,r,s,a))}if(void 0!==i.animations){const e=i.animations;for(let t=0;t<e.length;t++){const i=e[t];o.animations.push(a[i])}}if("LOD"===i.type){void 0!==i.autoUpdate&&(o.autoUpdate=i.autoUpdate);const e=i.levels;for(let t=0;t<e.length;t++){const i=e[t],n=o.getObjectByProperty("uuid",i.object);void 0!==n&&o.addLevel(n,i.distance)}}return o}},QuarksUtil:ai,Quaternion:te,RAD2DEG:je,RandomColor:Xe,RandomColorBetweenGradient:We,RandomQuatGenerator:Ye,RecordState:qe,get RenderMode(){return Vt},Rotation3DOverLife:Je,RotationBySpeed:Ze,RotationGeneratorFromJSON:Ke,RotationOverLife:Qe,SequencerFromJSON:$e,SizeBySpeed:et,SizeOverLife:tt,SpeedOverLife:it,SphereEmitter:Q,SpriteBatch:ti,SpriteParticle:ee,get SubParticleEmitMode(){return nt},TextureSequencer:rt,TrailBatch:ii,TrailParticle:$,TurbulenceField:st,VFXBatch:Gt,ValueGeneratorFromJSON:ne,Vector2:de,Vector3:W,Vector3Function:at,Vector3GeneratorFromJSON:ot,Vector4:K,WebGLCoordinateSystem:lt,WebGPUCoordinateSystem:dt,WidthOverLength:mt,ceilPowerOfTwo:ft,clamp:ct,damp:ht,degToRad:ut,denormalize:pt,euclideanModulo:vt,floorPowerOfTwo:gt,generateUUID:yt,getPhysicsResolver:_t,getValueFromEmitterMode:St,inverseLerp:xt,isPowerOfTwo:Mt,lerp:Tt,loadPlugin:oe,mapLinear:Et,normalize:Ut,pingpong:At,radToDeg:Pt,randFloat:wt,randFloatSpread:bt,randInt:Bt,registerShaderChunks:Ft,seededRandom:Ct,setPhysicsResolver:Ot,setQuaternionFromProperEuler:Rt,smootherstep:Nt,smoothstep:zt,unloadPlugin:Lt},Symbol.toStringTag,{value:"Module"}));export{qt as P,Vt as R,oi as _};
