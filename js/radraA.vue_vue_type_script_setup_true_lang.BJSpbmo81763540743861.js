import{_ as e}from"./@tresjs.BCHtwiaC1763540743861.js";import{l as t,M as n,ae as o,b8 as a}from"./three.rXKzP9fQ1763540743861.js";import{d as l,a as i,w as r,a6 as s,H as f,o as g,J as u,ac as d,ao as c}from"./@vue.Co_gxueH1763540743861.js";const v=["args"],h=l({__name:"radraA",props:{size:{default:300},radius:{default:240},color:{default:"#ffff00"},opacity:{default:.9},speed:{default:300},followWidth:{default:220}},setup(l,{expose:h}){const m=l,{onBeforeRender:p}=e(),x={value:0},P=i();p(({delta:e})=>{x.value+=e});const F={transparent:!0,blending:a,depthWrite:!1,side:o,depthTest:!0,vertexShader:"\n\tvarying vec3 vPosition;\n\tvoid main() {\n\t\tvPosition = position;\n\t\tvec4 modelPosition = modelMatrix * vec4(position, 1.0);\n\t\tvec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectionPosition = projectionMatrix * viewPosition;\n    gl_Position = projectionPosition;\n  }\n  ",fragmentShader:"\n\tuniform float uRadius;     \n  uniform float uTime;            \n  uniform float uSpeed; \n  uniform float uFollowWidth; \n  varying vec3 vPosition;\n\tuniform vec3 ncolor;\n  float calcAngle(vec3 oFrag){\n    float fragAngle;\n    const vec3 ox = vec3(1,0,0);\n    float dianji = oFrag.x * ox.x + oFrag.z*ox.z;\n    float oFrag_length = length(oFrag); // length是内置函数\n    float ox_length = length(ox); // length是内置函数\n    float yuxian = dianji / (oFrag_length * ox_length);\n    fragAngle = acos(yuxian);\n    fragAngle = degrees(fragAngle);\n    if(oFrag.z > 0.0) {\n      fragAngle = -fragAngle + 360.0;\n    }\n    float scanAngle = uTime * uSpeed - floor(uTime * uSpeed / 360.0) * 360.0;\n    float angle = scanAngle - fragAngle;\n    if(angle < 0.0){\n      angle = angle + 360.0;\n    }\n    return angle;\n  }\n  void main() {\n\t\t\t// length内置函数，取向量的长度\n\t\tif(length(vPosition) == 0.0 || length(vPosition) > uRadius-2.0){\n\t\t\tgl_FragColor = vec4( ncolor, 1.0 );\n\t\t} else {\n\t\t\tfloat angle = calcAngle(vPosition);\n\t\t\tif(angle < uFollowWidth){\n\t\t\t\t// 尾焰区域\n\t\t\t\tfloat opacity =  1.0 - angle / uFollowWidth; \n\t\t\t\tgl_FragColor = vec4( ncolor, 1.0 * opacity );  \n\t\t\t} else {\n\t\t\t\t// 其他位置的像素均为透明\n\t\t\t\tgl_FragColor = vec4( ncolor, 0.0 ); \n\t\t\t}\n\t\t}\n\t}\n  ",uniforms:{uSpeed:{value:m.speed},uRadius:{value:m.radius},uTime:x,uFollowWidth:{value:m.followWidth},ncolor:{value:new t(m.color)}}};r(P,(e,t)=>{if(e&&void 0===t){const e=(new n).makeRotationX(-Math.PI/180*90);P.value.applyMatrix4(e)}});const _=i();return s(()=>{m.color&&(F.uniforms.ncolor.value=new t(m.color)),m.radius&&(F.uniforms.uRadius.value=m.radius)}),i(-Math.PI/180*90),h({MeshRef:_}),(e,t)=>(g(),f("TresMesh",{ref_key:"MeshRef",ref:_},[u("TresCircleGeometry",{ref_key:"TresCircleGeometryRef",ref:P,args:[m.size,1e3]},null,8,v),u("TresShaderMaterial",d(c(F)),null,16)],512))}});export{h as _};
