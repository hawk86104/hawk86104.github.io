import{m as n,e,a as t,o as r,f as o}from"./@tresjs.9lmhsV6t1740450466561.js";import{P as i}from"./tweakpane.yDiyAAkA1740450466561.js";import{_ as c,aW as a,s as l,l as s,r as u}from"./three.HaMTRCf61740450466561.js";import{d as f,a3 as p,b as v,o as g,f as d,u as x,g as h,j as m,al as y,r as w,N as b,aj as C,ak as R}from"./@vue.NRI7TcgI1740450466561.js";import"./@vueuse.q8gKo7tC1740450466561.js";var I="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const _=D;function M(){const n=["4897016qWQwIt","input","1118326EflSsw","water","5236700uELZYD","while (true) {}","causticTex","Mesh","exception","call","error","return (function() ",'{}.constructor("return this")( )',"light","log","FrontSide","1387530svbtLT","debu","BufferGeometry","stateObject","counter","5929952wNFmST","tiles","BufferAttribute","init","toString","gger","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","apply","table","info","pool","2593584HWTVBr","constructor","console","function *\\( *\\)","prototype","value","render","bind","5271432DtbMkM","1bSPTHC","length","test","causticsTexture","uniforms"];return(M=function(){return n})()}!function(n,e){const t=D,r=M();for(;;)try{if(781407===parseInt(t(456))/1*(parseInt(t(463))/2)+-parseInt(t(477))/3+parseInt(t(461))/4+-parseInt(t(465))/5+parseInt(t(455))/6+parseInt(t(447))/7+-parseInt(t(436))/8)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function D(n,e){const t=M();return(D=function(n,e){return t[n-=435]})(n,e)}!function(){z(this,(function(){const n=D,e=new RegExp(n(450)),t=new RegExp(n(442),"i"),r=A(n(439));e[n(458)](r+"chain")&&t[n(458)](r+n(462))?A():r("0")}))()}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[D(443)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();T(void 0,(function(){const n=D;let e;try{e=Function(n(472)+n(473)+");")()}catch(o){e=window}const t=e[n(449)]=e[n(449)]||{},r=[n(475),"warn",n(445),n(471),n(469),n(444),"trace"];for(let i=0;i<r.length;i++){const e=T[n(448)][n(451)][n(454)](T),o=r[i],c=t[o]||e;e.__proto__=T[n(454)](T),e.toString=c[n(440)][n(454)](c),t[o]=e}}))();const L=f({__name:_(446),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=_,o=t,i=new(c[r(479)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i.setAttribute("position",new(c[r(438)])(l,3)),i.setIndex(new(c[r(438)])(s,1));const u=new a({uniforms:{light:{value:o[r(474)]},tiles:{value:o[r(437)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(476)]}),f=new(c[r(468)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{const n=r;((n,e)=>{const t=r;u[t(460)][t(464)].value=n,u[t(460)][t(467)][t(452)]=e,p[t(452)][t(453)](f,v[t(452)])})(o.waterTexture,o[n(459)])})),(n,e)=>null}});function A(n){function e(n){const t=D;if("string"==typeof n)return function(n){}[t(448)](t(466)).apply(t(435));1!==(""+n/n)[t(457)]||n%20==0?function(){return!0}[t(448)](t(478)+t(441))[t(470)]("action"):function(){return!1}[t(448)](t(478)+t(441)).apply(t(480)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const F=O;function O(n,e){const t=P();return(O=function(n,e){return t[n-=495]})(n,e)}!function(n,e){const t=O,r=P();for(;;)try{if(979588===-parseInt(t(540))/1+-parseInt(t(498))/2+-parseInt(t(502))/3+-parseInt(t(497))/4+-parseInt(t(552))/5*(parseInt(t(505))/6)+parseInt(t(507))/7*(parseInt(t(496))/8)+parseInt(t(549))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[O(519)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){S(this,(function(){const n=O,e=new RegExp(n(512)),t=new RegExp(n(528),"i"),r=W("init");e[n(555)](r+"chain")&&t[n(555)](r+"input")?W():r("0")}))()}();const E=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[O(519)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();E(void 0,(function(){const n=O,e=function(){const n=O;let e;try{e=Function(n(503)+n(511)+");")()}catch(t){e=window}return e}(),t=e[n(547)]=e[n(547)]||{},r=[n(537),"warn",n(514),n(510),"exception","table",n(550)];for(let o=0;o<r[n(506)];o++){const e=E.constructor[n(557)].bind(E),i=r[o],c=t[i]||e;e[n(533)]=E[n(543)](E),e[n(546)]=c[n(546)][n(543)](c),t[i]=e}}))();const j=f({__name:F(509),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=F;let i,l;const s=r,u=s[o(501)],f=(new(c[o(521)]))[o(518)](o(542))[o(522)]([o(516),o(548),o(504),o(513),o(556),o(495)]),h=([i,l]=p((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,l(),i),m=new a({uniforms:{light:{value:s[o(530)]},tiles:{value:h},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new(c[o(539)])(u,m),w=v(null),b=new(c[o(524)])(o(500)),{renderer:C,camera:R}=n(),{onLoop:I}=e();return I((()=>{const n=o;C[n(535)][n(531)](null),C[n(535)][n(523)](b,1),C[n(535)][n(553)](),m[n(554)][n(509)].value=s[n(551)],m[n(554)][n(527)][n(535)]=s[n(508)],m[n(536)]=c[n(541)],m[n(554)][n(538)][n(535)]=!0,C[n(535)][n(499)](y,R[n(535)]),m[n(536)]=c[n(534)],m[n(554)][n(538)][n(535)]=!1,C[n(535)].render(y,R[n(535)])})),(n,e)=>{const t=o;return g(),d(L,{tiles:x(h),light:n[t(530)],waterTexture:n.waterTexture,causticsTexture:n[t(508)],ref_key:"pooRef",ref:w},null,8,[t(515),t(530),t(551),t(508)])}}});function W(n){function e(n){const t=O;if("string"==typeof n)return function(n){}[t(529)](t(520))[t(519)](t(525));1!==(""+n/n).length||n%20==0?function(){return!0}[t(529)](t(532)+t(526))[t(517)](t(544)):function(){return!1}[t(529)](t(532)+t(526))[t(519)](t(545)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function P(){const n=["underwater","Mesh","707784qtovhX","FrontSide","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","bind","action","stateObject","toString","console","neg-x.jpg","41008410xkLsXH","trace","waterTexture","15SbHYQE","clear","uniforms","test","pos-z.jpg","prototype","neg-z.jpg","20968cIuoAF","3234060TAeQcQ","892786ryUFoG","render","white","geometry","4517841gllzdL","return (function() ","pos-y.jpg","2271390RVAiZG","length","2744dEpMdc","causticsTexture","water","error",'{}.constructor("return this")( )',"function *\\( *\\)","neg-y.jpg","info","tiles","pos-x.jpg","call","setPath","apply","while (true) {}","CubeTextureLoader","load","setClearColor","Color","counter","gger","causticTex","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","constructor","light","setRenderTarget","debu","__proto__","BackSide","value","side","log"];return(P=function(){return n})()}const H=N;!function(n,e){const t=N,r=B();for(;;)try{if(607586===-parseInt(t(258))/1+parseInt(t(249))/2*(-parseInt(t(257))/3)+-parseInt(t(254))/4*(parseInt(t(235))/5)+-parseInt(t(282))/6+-parseInt(t(262))/7*(-parseInt(t(278))/8)+-parseInt(t(264))/9+-parseInt(t(283))/10*(-parseInt(t(244))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const V=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[N(276)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){V(this,(function(){const n=N,e=new RegExp(n(277)),t=new RegExp(n(234),"i"),r=G(n(271));e[n(243)](r+n(246))&&t.test(r+n(260))?G():r("0")}))()}();const k=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function N(n,e){const t=B();return(N=function(n,e){return t[n-=229]})(n,e)}k(void 0,(function(){const n=N;let e;try{e=Function(n(269)+n(280)+");")()}catch(o){e=window}const t=e[n(248)]=e[n(248)]||{},r=[n(268),n(252),n(259),"error",n(263),n(236),n(267)];for(let i=0;i<r[n(274)];i++){const e=k[n(232)][n(237)][n(281)](k),o=r[i],c=t[o]||e;e[n(255)]=k.bind(k),e[n(242)]=c[n(242)][n(281)](c),t[o]=e}}))();const Z=f({__name:H(230),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=H,o=t,i=new(c[r(229)])(0,1,1,0,0,2e3),a=new l(2,2,200,200),u=new(c[r(270)])(1024,1024),f=new s({uniforms:{light:{value:o[r(275)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new(c[r(233)])(a,f),v=new(c[r(265)])(r(256)),{renderer:w}=n(),{onBeforeLoop:b}=e();return b((()=>{const n=r;p[n(250)][n(266)].water[n(279)]=o.waterTexture,w.value[n(245)](u),w[n(279)][n(253)](v,0),w[n(279)].clear(),w[n(279)].render(p,i)})),(n,e)=>{const t=r;return g(),d(y,null,{default:h((()=>[m(j,{waterTexture:n.waterTexture,causticsTexture:x(u)[t(231)],light:n.light,geometry:x(a)},null,8,[t(251),t(240),t(275),t(241)])])),_:1})}}});function G(n){function e(n){const t=N;if(typeof n===t(272))return function(n){}.constructor(t(239))[t(276)](t(261));1!==(""+n/n)[t(274)]||n%20==0?function(){return!0}[t(232)](t(238)+"gger")[t(247)]("action"):function(){return!1}[t(232)](t(238)+t(273))[t(276)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}function B(){const n=["call","console","8uwbyWb","material","waterTexture","warn","setClearColor","2482052fpClGg","__proto__","black","144714uizFzl","361142LUPPGG","info","input","counter","7tcDWda","exception","3643569JKIFii","Color","uniforms","trace","log","return (function() ","WebGLRenderTarget","init","string","gger","length","light","apply","function *\\( *\\)","9272576VaHqiP","value",'{}.constructor("return this")( )',"bind","3481512NbZpvN","20sQnWnu","OrthographicCamera","caustics","texture","constructor","Mesh","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","5ZCQsJn","table","prototype","debu","while (true) {}","causticsTexture","geometry","toString","test","8845177CwFipF","setRenderTarget","chain"];return(B=function(){return n})()}const $=U;!function(n,e){const t=U,r=Q();for(;;)try{if(935259===parseInt(t(256))/1*(-parseInt(t(239))/2)+-parseInt(t(215))/3*(parseInt(t(206))/4)+-parseInt(t(221))/5*(parseInt(t(257))/6)+-parseInt(t(227))/7+-parseInt(t(243))/8*(parseInt(t(245))/9)+-parseInt(t(255))/10+parseInt(t(207))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[U(212)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){q(this,(function(){const n=U,e=new RegExp(n(204)),t=new RegExp(n(250),"i"),r=K(n(202));e[n(220)](r+"chain")&&t.test(r+n(217))?K():r("0")}))()}();const Y=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[U(212)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Q(){const n=["count","1580740TYSjns","17cSTthg","6KZkNam","autoClear","table","setFromCamera","PlaneGeometry","debu","material","top","setRenderTarget","setY","texture","RawShaderMaterial","FloatType","prototype","uniforms","trace","render","height","setZ","init","__proto__","function *\\( *\\)","info","2660204mYNrDK","51907064iFzjqW","width","clientY","gger","waterTexture","apply","stateObject","log","6PwgHfj","length","input","counter","domElement","test","3351895mLJymF","bind","getY","addEventListener","console","Mesh","9613723MgvvbL","removeEventListener","constructor","Vector2",'{}.constructor("return this")( )',"OrthographicCamera","toString","value","attributes","error","radius","string","15098DMrvNP","left","while (true) {}","strength","11208DEvBeO","center","792DoWpqd","clientX","light","point","action","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","waterSimulation","WebGLRenderTarget","warn"];return(Q=function(){return n})()}function U(n,e){const t=Q();return(U=function(n,e){return t[n-=186]})(n,e)}Y(void 0,(function(){const n=U;let e;try{e=Function("return (function() "+n(231)+");")()}catch(o){e=window}const t=e[n(225)]=e[n(225)]||{},r=[n(214),n(253),n(205),n(236),"exception",n(259),n(198)];for(let i=0;i<r.length;i++){const e=Y[n(229)][n(196)].bind(Y),o=r[i],c=t[o]||e;e[n(203)]=Y[n(222)](Y),e[n(233)]=c[n(233)][n(222)](c),t[o]=e}}))();const J=f({__name:$(251),props:{light:{}},setup(t,{expose:r}){const o=$,i=new(c[o(232)])(0,1,1,0,0,2e3),s=new(c[o(187)])(2,2),f=new(c[o(252)])(256,256,{type:c[o(195)]}),p=new(c[o(252)])(256,256,{type:c[o(195)]}),v=new(c[o(194)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:I,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),h=new a({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:I,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),m=new(c[o(194)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:I,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),y=new(c[o(226)])(s,v),w=new u(s,h),b=new u(s,m);let C=f;const R=(n,e)=>{const t=o,r=C,c=C===f?p:f;e.material.uniforms.texture.value=r[t(193)],n[t(191)](c),n[t(199)](e,i),C=c},{renderer:_,camera:M,raycaster:z}=n();_[o(234)][o(258)]=!1;const{onBeforeLoop:D}=e();D((()=>{const n=o;var e,t;t=_[n(234)],R(t,b),e=_[n(234)],R(e,w)}));const T=(n,e,t,r)=>{const i=o;y.material[i(197)][i(244)][i(234)]=[n,e],y[i(189)][i(197)][i(237)][i(234)]=t,y[i(189)][i(197)][i(242)].value=r,R(_[i(234)],y)},L=new(c[o(230)]),A=new l(2,2),F=A[o(235)].position;for(let n=0;n<F[o(254)];n++){const e=-F[o(223)](n);F[o(192)](n,0),F[o(201)](n,e)}F.needsUpdate=!0;const O=new(c[o(226)])(A),S={handleEvent:n=>{const e=o,t=_[e(234)][e(219)].getBoundingClientRect(),r=t[e(208)],i=t[e(200)];L.x=2*(n[e(246)]-t[e(240)])/r-1,L.y=2*-(n[e(209)]-t[e(190)])/i+1,z.value[e(186)](L,M[e(234)]);const c=z.value.intersectObject(O);for(let o of c)T(o.point.x,o[e(248)].z,.03,.04)}};return r({addDrop:T,mouseEvent:n=>{const e=o;n?_[e(234)][e(219)][e(224)]("mousemove",S):_[e(234)][e(219)][e(228)]("mousemove",S)}}),(n,e)=>{const t=o;return g(),d(Z,{lightFrontGeometry:x(s),waterTexture:x(C).texture,light:n[t(247)]},null,8,["lightFrontGeometry",t(211),"light"])}}});function K(n){function e(n){const t=U;if(typeof n===t(238))return function(n){}[t(229)](t(241))[t(212)](t(218));1!==(""+n/n)[t(216)]||n%20==0?function(){return!0}[t(229)](t(188)+"gger").call(t(249)):function(){return!1}[t(229)]("debu"+t(210)).apply(t(213)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function X(){const n=["182tyGXvP","function *\\( *\\)","113642LrhZHR","457480WArSCZ","exception","bind","toString","139912NAGrGN","manual","init","6236630csYIaD","addDrop","change","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","chain","随机增加波纹","table","log","click","stateObject","info","addButton","apply","counter","3owSVvx","gger","__proto__","3009788JKICLH","18WvsUVQ","return (function() ","debu","input","constructor","action","mouseEvent","console","4135620MELnBR",'{}.constructor("return this")( )',"点击按钮","waterSimulationRef","random","string","3389139rUglGJ","鼠标波纹","value","prototype","test","length"];return(X=function(){return n})()}!function(n,e){const t=rn,r=X();for(;;)try{if(662237===-parseInt(t(150))/1*(-parseInt(t(176))/2)+parseInt(t(168))/3+parseInt(t(153))/4+-parseInt(t(184))/5+-parseInt(t(162))/6+parseInt(t(174))/7*(parseInt(t(181))/8)+-parseInt(t(154))/9*(-parseInt(t(177))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[rn(148)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){nn(this,(function(){const n=rn,e=new RegExp(n(175)),t=new RegExp(n(187),"i"),r=on(n(183));e[n(172)](r+n(140))&&t[n(172)](r+n(157))?on():r("0")}))()}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();en(void 0,(function(){const n=rn;let e;try{e=Function(n(155)+n(163)+");")()}catch(o){e=window}const t=e[n(161)]=e[n(161)]||{},r=[n(143),"warn",n(146),"error",n(178),n(142),"trace"];for(let i=0;i<r[n(173)];i++){const e=en[n(158)][n(171)].bind(en),o=r[i],c=t[o]||e;e[n(152)]=en[n(179)](en),e[n(180)]=c[n(180)].bind(c),t[o]=e}}))();const tn=f({__name:"realWater",setup(n){const e=rn,t=w({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(182)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=v(null),l=new i;l[e(147)]({label:e(164),title:e(141)}).on(e(144),(()=>{const n=e;for(var t=0;t<10;t++)a[n(170)][n(185)](2*Math[n(166)]()-1,2*Math.random()-1,.03,1&t?.02:-.02)}));const s=v(!1);return l.addBinding(s,"value",{label:e(169)}).on(e(186),(n=>{const t=e;a[t(170)][t(160)](n[t(170)])})),(n,i)=>{const l=e;return g(),d(x(o),C(R(t)),{default:h((()=>[i[0]||(i[0]=b("TresPerspectiveCamera",{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),m(x(r)),m(J,{light:c,ref_key:l(165),ref:a},null,512)])),_:1},16)}}});function rn(n,e){const t=X();return(rn=function(n,e){return t[n-=140]})(n,e)}function on(n){function e(n){const t=rn;if(typeof n===t(167))return function(n){}.constructor("while (true) {}").apply(t(149));1!==(""+n/n)[t(173)]||n%20==0?function(){return!0}[t(158)](t(156)+t(151)).call(t(159)):function(){return!1}[t(158)](t(156)+t(151)).apply(t(145)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{tn as default};
