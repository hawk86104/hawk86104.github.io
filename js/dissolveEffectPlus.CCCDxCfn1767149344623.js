import{importShared as e}from"./3d-tiles-renderer.de6b_qgz1767149344623.js";import{Fs as t,_l as a,Kk as r}from"./index.Btae5S5d1767149344623.js";import"./index.BoSDls8p1767149344623.js";import"./skyBoxAmesh.vue_vue_type_script_setup_true_lang.DmDak4aM1767149344623.js";import"./skyBoxBmesh.vue_vue_type_script_setup_true_lang.ByvIISYy1767149344623.js";import{_sfc_main as o}from"./skyBoxDmesh.vue_vue_type_script_setup_true_lang.IFusO1T61767149344623.js";import{Pane as n}from"./tweakpane.BbuIEN141767149344623.js";import{snoise_default as i,_sfc_main as u}from"./material.vue_vue_type_script_setup_true_lang.CiQkURPP1767149344623.js";import{useTexture as l}from"./customShaderMaterial.vue_vue_type_script_setup_true_lang.C_pYeFAB1767149344623.js";import"./index.vue_vue_type_script_setup_true_lang.C9DbtXj-1767149344623.js";import{RenderPass as s,EffectComposer as d}from"./RenderPass.D5QCtMRU1767149344623.js";import{UnrealBloomPass as p}from"./UnrealBloomPass.ByzRH1Rw1767149344623.js";const{withAsyncContext:c,defineComponent:m}=await e("vue"),{unref:v,createElementVNode:f,openBlock:g,createElementBlock:w}=await e("vue"),A=["geometry"],_=["blending"],{watch:y}=await e("vue"),P=await e("three"),x=m({__name:"particlesPoints",props:{geo:{default:new P.BufferGeometry},uEdge:{default:6},uFreq:{default:.41},uAmp:{default:20},uProgress:{default:-2},uColor:{default:"#4d9bff"},uPointSize:{default:200},particleData:{default:{particleSpeedFactor:.02,velocityFactor:{x:2.5,y:2},waveAmplitude:0}}},async setup(e){let r,o;const n=e,u=n.geo.clone(),s=([r,o]=c(()=>l("./plugins/industry4/image/particle.png")),r=await r,o(),r);let d,p,m,x,b,h,B=u.attributes.position.count;!function(e){B=e.attributes.position.count,d=new Float32Array(B),p=new Float32Array(e.getAttribute("position").array),m=new Float32Array(e.getAttribute("position").array),x=new Float32Array(3*B),b=new Float32Array(B),h=new Float32Array(B);for(let t=0;t<B;t++){let e=3*t+0,a=3*t+1,r=3*t+2;d[t]=5.5*Math.random()+1.5,x[e]=.5*Math.random()+.5,x[a]=.5*Math.random()+.5,x[r]=.1*Math.random(),b[t]=.001,h[t]=Math.random()*Math.PI*2}e.setAttribute("aOffset",new P.BufferAttribute(d,1)),e.setAttribute("aCurrentPos",new P.BufferAttribute(m,3)),e.setAttribute("aVelocity",new P.BufferAttribute(x,3)),e.setAttribute("aDist",new P.BufferAttribute(b,1)),e.setAttribute("aAngle",new P.BufferAttribute(h,1))}(u);const{renderer:C}=t(),D={uTexture:{value:s},uPixelDensity:{value:C.getPixelRatio()},uProgress:{value:n.uProgress},uEdge:{value:n.uEdge},uAmp:{value:n.uAmp},uFreq:{value:n.uFreq},uBaseSize:{value:n.uPointSize},uColor:{value:new P.Color(n.uColor)}},F=`\n    ${i}\n    uniform float uPixelDensity;\n    uniform float uBaseSize;\n    uniform float uFreq;\n    uniform float uAmp;\n    uniform float uEdge;\n    uniform float uProgress;\n\n    varying float vNoise;\n    varying float vAngle;\n\n    attribute vec3 aCurrentPos;\n    attribute float aDist;\n    attribute float aAngle;\n\n    void main() {\n        vec3 pos = position;\n\n        float noise = snoise(pos * uFreq) * uAmp;\n        vNoise =noise;\n\n        vAngle = aAngle;\n\n        if( vNoise > uProgress-2.0 && vNoise < uProgress + uEdge+2.0){\n            pos = aCurrentPos;\n        }\n\n        vec4 modelPosition = modelMatrix * vec4(pos, 1.0);\n        vec4 viewPosition = viewMatrix * modelPosition;\n        vec4 projectedPosition = projectionMatrix * viewPosition;\n        gl_Position = projectedPosition;\n\n        float size = uBaseSize * uPixelDensity;\n        size = size  / (aDist + 1.0);\n        gl_PointSize = size / -viewPosition.z;\n}\n`;function M(e){let t=x[3*e+0],a=x[3*e+1],r=x[3*e+2];t*=n.particleData.velocityFactor.x,a*=n.particleData.velocityFactor.y;let{xwave:o,ywave:i}=function(e){const t=m[3*e+0],a=m[3*e+1];let r=Math.sin(2*a)*(.8+n.particleData.waveAmplitude),o=Math.sin(2*t)*(.6+n.particleData.waveAmplitude),i=Math.sin(5*a)*(.2+n.particleData.waveAmplitude),u=Math.sin(1*t)*(.9+n.particleData.waveAmplitude),l=Math.sin(8*a)*(.8+n.particleData.waveAmplitude),s=Math.sin(5*t)*(.6+n.particleData.waveAmplitude);return{xwave:r+i+l+Math.sin(3*a)*(.8+n.particleData.waveAmplitude),ywave:o+u+s+Math.sin(7*t)*(.6+n.particleData.waveAmplitude)}}(e);return t+=o,a+=i,t*=Math.abs(n.particleData.particleSpeedFactor),a*=Math.abs(n.particleData.particleSpeedFactor),r*=Math.abs(n.particleData.particleSpeedFactor),{vx:t,vy:a,vz:r}}const{onBeforeRender:S}=a();return S(()=>{!function(){for(let e=0;e<B;e++){let t=3*e+0,a=3*e+1,r=3*e+2,{vx:o,vy:n,vz:i}=M(e);m[t]+=o,m[a]+=n,m[r]+=i;const u=new P.Vector3(p[t],p[a],p[r]),l=new P.Vector3(m[t],m[a],m[r]),s=u.distanceTo(l);b[e]=s,h[e]+=.01,s>d[e]&&(m[t]=p[t],m[a]=p[a],m[r]=p[r])}u.setAttribute("aOffset",new P.BufferAttribute(d,1)),u.setAttribute("aCurrentPos",new P.BufferAttribute(m,3)),u.setAttribute("aVelocity",new P.BufferAttribute(x,3)),u.setAttribute("aDist",new P.BufferAttribute(b,1)),u.setAttribute("aAngle",new P.BufferAttribute(h,1))}()}),y(()=>[n.uColor,n.uEdge,n.uFreq,n.uAmp,n.uProgress,n.uPointSize],([e,t,a,r,o,n])=>{D.uColor.value.setStyle(e),D.uEdge.value=t,D.uFreq.value=a,D.uAmp.value=r,D.uProgress.value=o,D.uBaseSize.value=n}),(e,t)=>(g(),w("TresPoints",{geometry:v(u)},[f("TresShaderMaterial",{transparent:"",blending:P.AdditiveBlending,uniforms:D,vertexShader:F,fragmentShader:"\n    uniform vec3 uColor;\n    uniform float uEdge;\n    uniform float uProgress;\n    uniform sampler2D uTexture;\n\n    varying float vNoise;\n    varying float vAngle;\n\n    void main(){\n        if( vNoise < uProgress ) discard;\n        if( vNoise > uProgress + uEdge) discard;\n\n        vec2 coord = gl_PointCoord;\n        coord = coord - 0.5; // get the coordinate from 0-1 ot -0.5 to 0.5\n        coord = coord * mat2(cos(vAngle),sin(vAngle) , -sin(vAngle), cos(vAngle)); // apply the rotation transformaion\n        coord = coord +  0.5; // reset the coordinate to 0-1  \n\n        vec4 texture = texture2D(uTexture,coord);\n\n        gl_FragColor = vec4(vec3(uColor.xyz * texture.xyz),1.0);\n    }\n"},null,8,_)],8,A))}}),{defineComponent:b}=await e("vue"),{unref:h,mergeProps:B,createVNode:C,createElementVNode:D,Suspense:F,withCtx:M,openBlock:S,createBlock:z,createElementBlock:E}=await e("vue"),j=["geometry"],k=await e("three"),N=b({__name:"torusKnot",setup(e){const t=new k.TorusKnotGeometry(3,1,64,8,2,3);return(e,a)=>(S(),E("TresGroup",null,[D("TresMesh",{geometry:h(t)},[C(u,B({color:"#636363",metalness:2,roughness:0},e.$attrs),null,16)],8,j),(S(),z(F,null,{default:M(()=>[C(x,B({geo:h(t)},e.$attrs,{uColor:e.$attrs.uEdgeColor}),null,16,["geo","uColor"])]),_:1}))]))}}),{defineComponent:T}=await e("vue"),{watchEffect:V}=await e("vue"),q=await e("three"),K=T({__name:"bloomPass",setup(e){const{camera:r,renderer:o,scene:n,sizes:i}=t(),u=0,l=.216,c=.2;let m=null;V(()=>{i.width.value&&((e,t,a,r,o)=>{const n=new s(e,t),i=new p(new q.Vector2(r,o),l,c,u);m=new d(a),m.addPass(n),m.addPass(i)})(n.value,r.value,o,i.width.value,i.height.value)});const{onBeforeRender:v}=a();return v(()=>{m&&m.render()}),(e,t)=>null}}),{defineComponent:R}=await e("vue"),{createElementVNode:$,unref:G,createVNode:O,mergeProps:I,Suspense:U,withCtx:H,openBlock:J,createBlock:L,resolveComponent:Q,normalizeProps:W,guardReactiveProps:X}=await e("vue"),{reactive:Y}=await e("vue"),Z=await e("three"),ee=R({__name:"dissolveEffectPlus",setup(e){const t={clearColor:"#201919",windowSize:!0,toneMapping:Z.ACESFilmicToneMapping,toneMappingExposure:.8,renderMode:"manual"},a=Y({uEdgeColor:"#ff784d",uEdge:6,uFreq:.41,uAmp:20,uProgress:-4.9,uPointSize:576,particleData:{particleSpeedFactor:.02,velocityFactor:{x:2.5,y:2},waveAmplitude:0}}),i=Y({torusKnotColor:"#7a8c87"}),u=new n({title:"参数",expanded:!0});return u.addBinding(i,"torusKnotColor",{label:"torusKnotColor"}),u.addBinding(a,"uEdgeColor",{label:"边缘颜色"}),u.addBinding(a,"uEdge",{label:"边缘宽度",min:0,max:9,step:.01}),u.addBinding(a,"uFreq",{label:"密度",min:.002,max:2,step:.002}),u.addBinding(a,"uAmp",{label:"幅度",min:3,max:22,step:.01}),u.addBinding(a,"uProgress",{label:"进度",min:-25,max:20,step:.1}),u.addBinding(a,"uPointSize",{label:"粒子大小",min:10,max:800,step:5}),u.addBinding(a.particleData,"particleSpeedFactor",{label:"粒子速度",min:1e-4,max:.1,step:1e-4}),u.addBinding(a.particleData,"velocityFactor",{picker:"inline",label:"粒子飘逸方向",expanded:!0,x:{min:-10,max:10,step:.01},y:{min:-10,max:10,step:.01}}),u.addBinding(a.particleData,"waveAmplitude",{label:"粒子扰动幅度",min:0,max:5,step:.01}),(e,n)=>{const u=Q("TresCanvas");return J(),L(u,W(X(t)),{default:H(()=>[n[0]||(n[0]=$("TresPerspectiveCamera",{position:[15,15,15],fov:45,near:.1,far:1e4,"look-at":[0,0,0]},null,-1)),O(G(r),{enableDamping:""}),O(N,I(a,{color:i.torusKnotColor}),null,16,["color"]),(J(),L(U,null,{default:H(()=>[O(G(o),{texture:"https://opensource.cdn.icegl.cn/images/skyBox/workshop_blur.jpg"},null,8,["texture"])]),_:1})),O(K)]),_:1},16)}}});export{ee as default};
