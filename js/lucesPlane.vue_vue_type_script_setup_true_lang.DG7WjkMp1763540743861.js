import{_ as e}from"./@tresjs.BCHtwiaC1763540743861.js";import{d as n,H as t,o,F as a,J as i,u as r}from"./@vue.Co_gxueH1763540743861.js";import{$ as s,aj as l,b as c,A as u,ak as d,x as v,av as m}from"./three.rXKzP9fQ1763540743861.js";const g=["geometry","material"],f=["material"],p=["rotateX"],h=100,x=n({__name:"lucesPlane",props:{globalUniforms:{}},setup(n){const x=n,y=[],b=[],_=new s(1,36,18),w=(new l).copy(_);w.instanceCount=h;const D=[];for(let e=0;e<h;e++){let e=c.randFloatSpread(49),n=c.randFloatSpread(49),t=c.randFloat(.0625,.125),o=c.randFloat(1,3);D.push(e,n,t),b.push(new u(e,n,o,c.randFloat(1,2))),y.push(new u(e,n,t,o))}w.setAttribute("instData",new d(new Float32Array(D),3));const U=new v({color:16720418,onBeforeCompile:e=>{e.uniforms.noiseTex=x.globalUniforms.noise,e.vertexShader=`\n      uniform sampler2D noiseTex;\n      attribute vec4 instData;\n      ${e.vertexShader}\n    `.replace("#include <begin_vertex>","#include <begin_vertex>\n      transformed = position * instData.z;\n      \n      transformed.x += instData.x;\n      transformed.z += instData.y;\n      vec2 nUv = (vec2(instData.x, -instData.y) - vec2(-25.)) / 50.;\n      float h = texture2D(noiseTex, nUv).g;\n      h = (h - 0.5) * 4.;\n      transformed.y += h;\n      ")}}),T={luces:{value:y}},P=new m({color:2363940,onBeforeCompile:e=>{e.uniforms.luces=T.luces,e.uniforms.globalBloom=x.globalUniforms.globalBloom,e.uniforms.noiseTex=x.globalUniforms.noise,e.vertexShader=`\n      uniform float time;\n      uniform sampler2D noiseTex;\n      varying vec3 vPos;\n      varying float intensity;\n      \n      //// https://discourse.threejs.org/t/calculating-vertex-normals-after-displacement-in-the-vertex-shader/16989/8 ///\n      \n      // the function which defines the displacement\n      float displace(vec2 vUv) {\n        return (texture2D(noiseTex, vUv).g - 0.5) * 4.;\n      }\n\n      vec3 getNormal(vec2 vUv){\n        vec3 displacedPosition = position + normal * displace(vUv);\n\n        float texelSize = 1.0 / 512.0; // temporarily hardcoding texture resolution\n        float offset = 0.1;\n\n        vec3 neighbour1 = position + vec3(1., 0., 0.) * offset;\n        vec3 neighbour2 = position + vec3(0., 0., 1.) * offset;\n        vec2 neighbour1uv = vUv + vec2(-texelSize, 0);\n        vec2 neighbour2uv = vUv  + vec2(0, -texelSize);\n        vec3 displacedNeighbour1 = neighbour1 + normal * displace(neighbour1uv);\n        vec3 displacedNeighbour2 = neighbour2 + normal * displace(neighbour2uv);\n\n        // https://i.ya-webdesign.com/images/vector-normals-tangent-16.png\n        vec3 displacedTangent = displacedNeighbour1 - displacedPosition;\n        vec3 displacedBitangent = displacedNeighbour2 - displacedPosition;\n\n        // https://upload.wikimedia.org/wikipedia/commons/d/d2/Right_hand_rule_cross_product.svg\n        vec3 displacedNormal = normalize(cross(displacedBitangent, displacedTangent));\n        return displacedNormal;\n      }\n      \n      ${e.vertexShader}\n    `.replace("#include <begin_vertex>","#include <begin_vertex>\n\n        float h = texture2D(noiseTex, uv).g;\n        intensity = h;\n        h = (h - 0.5) * 4.;\n        transformed.y = h;\n        vPos = transformed;\n        transformedNormal = normalMatrix * getNormal(uv);\n      "),e.fragmentShader=`\n      uniform vec4 luces[100];\n      uniform sampler2D noiseTex;\n      uniform float globalBloom;\n      varying vec3 vPos;\n      varying float intensity;\n\n      ${e.fragmentShader}\n    `.replace("#include <fog_fragment>","\n        vec3 col = vec3(1, 0, 0)*0.75;\n        float intensity = 0.;\n        for(int i = 0;i < 100; i++){\n          vec4 lux = luces[i];\n          vec2 luxUv = (vec2(lux.x, -lux.y) - vec2(-25.)) / 50.;\n          float h = texture2D(noiseTex, luxUv).g;\n          h = (h - 0.5) * 4.;\n          vec3 lightPos = vec3(lux.x, h, lux.y);\n          float currIntensity = smoothstep(lux.z + lux.w, lux.z, distance(vPos, lightPos));\n          intensity += pow(currIntensity, 16.);\n        }\n        intensity = clamp(intensity, 0., 1.);\n        col = mix(col * 0.5, col, intensity);\n        col = mix(gl_FragColor.rgb, col, intensity);\n        col += vec3(1) * intensity * 0.01;\n        gl_FragColor = vec4( col, opacity );\n        #include <fog_fragment>\n      ").replace("#include <dithering_fragment>","#include <dithering_fragment>\n        if (globalBloom > 0.5) {\n          gl_FragColor = vec4(0);\n        }\n      ")}}),{onBeforeRender:S}=e();return S(({elapsed:e})=>{for(let n=0;n<h;n++){const t=b[n];let o=(t.y+e+25)%50-25;y[n].y=o,y[n].w=(Math.sin(e*t.w*(n%3+1))*Math.cos(e*t.w*(n%5+1))*.25+.25)*t.z+.75*t.z,w.attributes.instData.setY(n,o)}w.attributes.instData.needsUpdate=!0}),(e,n)=>(o(),t(a,null,[i("TresMesh",{geometry:r(w),material:r(U)},null,8,g),i("TresMesh",{material:r(P)},[i("TresPlaneGeometry",{args:[50,50,500,500],rotateX:.5*-Math.PI},null,8,p)],8,f)],64))}});export{x as _};
