import{importShared as t}from"./3d-tiles-renderer.DFcJBJdg1769412424343.js";const{BufferGeometry:e,FileLoader:s,Float32BufferAttribute:o,Group:i,LineBasicMaterial:n,LineSegments:r,Loader:a,Material:l,Mesh:c,MeshPhongMaterial:h,Points:u,PointsMaterial:d,Vector3:p,Color:m,SRGBColorSpace:f}=await t("three"),g=/^[og]\s*(.+)?/,b=/^mtllib /,v=/^usemtl /,y=/^usemap /,j=/\s+/,x=new p,w=new p,V=new p,I=new p,L=new p,z=new m;function A(){const t={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(t,e){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=t,void(this.object.fromDeclaration=!1!==e);const s=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:t||"",fromDeclaration:!1!==e,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(t,e){const s=this._finalize(!1);s&&(s.inherited||s.groupCount<=0)&&this.materials.splice(s.index,1);const o={index:this.materials.length,name:t||"",mtllib:Array.isArray(e)&&e.length>0?e[e.length-1]:"",smooth:void 0!==s?s.smooth:this.smooth,groupStart:void 0!==s?s.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(t){const e={index:"number"==typeof t?t:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return e.clone=this.clone.bind(e),e}};return this.materials.push(o),o},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(t){const e=this.currentMaterial();if(e&&-1===e.groupEnd&&(e.groupEnd=this.geometry.vertices.length/3,e.groupCount=e.groupEnd-e.groupStart,e.inherited=!1),t&&this.materials.length>1)for(let s=this.materials.length-1;s>=0;s--)this.materials[s].groupCount<=0&&this.materials.splice(s,1);return t&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),e}},s&&s.name&&"function"==typeof s.clone){const t=s.clone(0);t.inherited=!0,this.object.materials.push(t)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(t,e){const s=parseInt(t,10);return 3*(s>=0?s-1:s+e/3)},parseNormalIndex:function(t,e){const s=parseInt(t,10);return 3*(s>=0?s-1:s+e/3)},parseUVIndex:function(t,e){const s=parseInt(t,10);return 2*(s>=0?s-1:s+e/2)},addVertex:function(t,e,s){const o=this.vertices,i=this.object.geometry.vertices;i.push(o[t+0],o[t+1],o[t+2]),i.push(o[e+0],o[e+1],o[e+2]),i.push(o[s+0],o[s+1],o[s+2])},addVertexPoint:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addVertexLine:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addNormal:function(t,e,s){const o=this.normals,i=this.object.geometry.normals;i.push(o[t+0],o[t+1],o[t+2]),i.push(o[e+0],o[e+1],o[e+2]),i.push(o[s+0],o[s+1],o[s+2])},addFaceNormal:function(t,e,s){const o=this.vertices,i=this.object.geometry.normals;x.fromArray(o,t),w.fromArray(o,e),V.fromArray(o,s),L.subVectors(V,w),I.subVectors(x,w),L.cross(I),L.normalize(),i.push(L.x,L.y,L.z),i.push(L.x,L.y,L.z),i.push(L.x,L.y,L.z)},addColor:function(t,e,s){const o=this.colors,i=this.object.geometry.colors;void 0!==o[t]&&i.push(o[t+0],o[t+1],o[t+2]),void 0!==o[e]&&i.push(o[e+0],o[e+1],o[e+2]),void 0!==o[s]&&i.push(o[s+0],o[s+1],o[s+2])},addUV:function(t,e,s){const o=this.uvs,i=this.object.geometry.uvs;i.push(o[t+0],o[t+1]),i.push(o[e+0],o[e+1]),i.push(o[s+0],o[s+1])},addDefaultUV:function(){const t=this.object.geometry.uvs;t.push(0,0),t.push(0,0),t.push(0,0)},addUVLine:function(t){const e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])},addFace:function(t,e,s,o,i,n,r,a,l){const c=this.vertices.length;let h=this.parseVertexIndex(t,c),u=this.parseVertexIndex(e,c),d=this.parseVertexIndex(s,c);if(this.addVertex(h,u,d),this.addColor(h,u,d),void 0!==r&&""!==r){const t=this.normals.length;h=this.parseNormalIndex(r,t),u=this.parseNormalIndex(a,t),d=this.parseNormalIndex(l,t),this.addNormal(h,u,d)}else this.addFaceNormal(h,u,d);if(void 0!==o&&""!==o){const t=this.uvs.length;h=this.parseUVIndex(o,t),u=this.parseUVIndex(i,t),d=this.parseUVIndex(n,t),this.addUV(h,u,d),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(t){this.object.geometry.type="Points";const e=this.vertices.length;for(let s=0,o=t.length;s<o;s++){const o=this.parseVertexIndex(t[s],e);this.addVertexPoint(o),this.addColor(o)}},addLineGeometry:function(t,e){this.object.geometry.type="Line";const s=this.vertices.length,o=this.uvs.length;for(let i=0,n=t.length;i<n;i++)this.addVertexLine(this.parseVertexIndex(t[i],s));for(let i=0,n=e.length;i<n;i++)this.addUVLine(this.parseUVIndex(e[i],o))}};return t.startObject("",!1),t}class C extends a{constructor(t){super(t),this.materials=null}load(t,e,o,i){const n=this,r=new s(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(t,function(s){try{e(n.parse(s))}catch(o){i?i(o):console.error(o),n.manager.itemError(t)}},o,i)}setMaterials(t){return this.materials=t,this}parse(t){const s=new A;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n")),-1!==t.indexOf("\\\n")&&(t=t.replace(/\\\n/g,""));const a=t.split("\n");let p=[];for(let e=0,o=a.length;e<o;e++){const t=a[e].trimStart();if(0===t.length)continue;const o=t.charAt(0);if("#"!==o)if("v"===o){const e=t.split(j);switch(e[0]){case"v":s.vertices.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3])),e.length>=7?(z.setRGB(parseFloat(e[4]),parseFloat(e[5]),parseFloat(e[6]),f),s.colors.push(z.r,z.g,z.b)):s.colors.push(void 0,void 0,void 0);break;case"vn":s.normals.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]));break;case"vt":s.uvs.push(parseFloat(e[1]),parseFloat(e[2]))}}else if("f"===o){const e=t.slice(1).trim().split(j),o=[];for(let t=0,s=e.length;t<s;t++){const s=e[t];if(s.length>0){const t=s.split("/");o.push(t)}}const i=o[0];for(let t=1,n=o.length-1;t<n;t++){const e=o[t],n=o[t+1];s.addFace(i[0],e[0],n[0],i[1],e[1],n[1],i[2],e[2],n[2])}}else if("l"===o){const e=t.substring(1).trim().split(" ");let o=[];const i=[];if(-1===t.indexOf("/"))o=e;else for(let t=0,s=e.length;t<s;t++){const s=e[t].split("/");""!==s[0]&&o.push(s[0]),""!==s[1]&&i.push(s[1])}s.addLineGeometry(o,i)}else if("p"===o){const e=t.slice(1).trim().split(" ");s.addPointGeometry(e)}else if(null!==(p=g.exec(t))){const t=(" "+p[0].slice(1).trim()).slice(1);s.startObject(t)}else if(v.test(t))s.object.startMaterial(t.substring(7).trim(),s.materialLibraries);else if(b.test(t))s.materialLibraries.push(t.substring(7).trim());else if(y.test(t))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===o){if(p=t.split(" "),p.length>1){const t=p[1].trim().toLowerCase();s.object.smooth="0"!==t&&"off"!==t}else s.object.smooth=!0;const e=s.object.currentMaterial();e&&(e.smooth=s.object.smooth)}else{if("\0"===t)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+t+'"')}}s.finalize();const m=new i;m.materialLibraries=[].concat(s.materialLibraries);if(!0===!(1===s.objects.length&&0===s.objects[0].geometry.vertices.length))for(let i=0,f=s.objects.length;i<f;i++){const t=s.objects[i],a=t.geometry,p=t.materials,f="Line"===a.type,g="Points"===a.type;let b=!1;if(0===a.vertices.length)continue;const v=new e;v.setAttribute("position",new o(a.vertices,3)),a.normals.length>0&&v.setAttribute("normal",new o(a.normals,3)),a.colors.length>0&&(b=!0,v.setAttribute("color",new o(a.colors,3))),!0===a.hasUVIndices&&v.setAttribute("uv",new o(a.uvs,2));const y=[];for(let e=0,o=p.length;e<o;e++){const t=p[e],o=t.name+"_"+t.smooth+"_"+b;let i=s.materials[o];if(null!==this.materials)if(i=this.materials.create(t.name),!f||!i||i instanceof n){if(g&&i&&!(i instanceof d)){const t=new d({size:10,sizeAttenuation:!1});l.prototype.copy.call(t,i),t.color.copy(i.color),t.map=i.map,i=t}}else{const t=new n;l.prototype.copy.call(t,i),t.color.copy(i.color),i=t}void 0===i&&(i=f?new n:g?new d({size:1,sizeAttenuation:!1}):new h,i.name=t.name,i.flatShading=!t.smooth,i.vertexColors=b,s.materials[o]=i),y.push(i)}let j;if(y.length>1){for(let t=0,e=p.length;t<e;t++){const e=p[t];v.addGroup(e.groupStart,e.groupCount,t)}j=f?new r(v,y):g?new u(v,y):new c(v,y)}else j=f?new r(v,y[0]):g?new u(v,y[0]):new c(v,y[0]);j.name=t.name,m.add(j)}else if(s.vertices.length>0){const t=new d({size:1,sizeAttenuation:!1}),i=new e;i.setAttribute("position",new o(s.vertices,3)),s.colors.length>0&&void 0!==s.colors[0]&&(i.setAttribute("color",new o(s.colors,3)),t.vertexColors=!0);const n=new u(i,t);m.add(n)}return m}}const F=(t,e)=>new Promise((s,o)=>{e.setCrossOrigin("Anonymous"),e.load(t,t=>{s(t)},t=>{console.log(t.loaded/t.total*100+"% loaded")},t=>{console.error(t),o(t)})});export{C as OBJLoader,F as loadOBJ};
