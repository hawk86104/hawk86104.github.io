import{importShared as v}from"./3d-tiles-renderer.DZNovkLO1767148983502.js";const qn=0,Qn=1,On=2,Vs=0,Ls=1,bn=2,Gt=1.25,Pn=1,Ct=6*4+4+4,Kt=65535,Gn=Math.pow(2,-24),tn=Symbol("SKIP_GENERATION"),{BufferAttribute:te}=await v("three");function ne(e){return e.index?e.index.count:e.attributes.position.count}function mt(e){return ne(e)/3}function ee(e,t=ArrayBuffer){return e>65535?new Uint32Array(new t(4*e)):new Uint16Array(new t(2*e))}function se(e,t){if(!e.index){const n=e.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,r=ee(n,s);e.setIndex(new te(r,1));for(let a=0;a<n;a++)r[a]=a}}function kn(e,t){const n=mt(e),s=t||e.drawRange,r=s.start/3,a=(s.start+s.count)/3,i=Math.max(0,r),c=Math.min(n,a)-i;return[{offset:Math.floor(i),count:Math.floor(c)}]}function Hn(e,t){if(!e.groups||!e.groups.length)return kn(e,t);const n=[],s=new Set,r=t||e.drawRange,a=r.start/3,i=(r.start+r.count)/3;for(const o of e.groups){const p=o.start/3,u=(o.start+o.count)/3;s.add(Math.max(a,p)),s.add(Math.min(i,u))}const c=Array.from(s.values()).sort((o,p)=>o-p);for(let o=0;o<c.length-1;o++){const p=c[o],u=c[o+1];n.push({offset:Math.floor(p),count:Math.floor(u-p)})}return n}function ie(e,t){const n=mt(e),s=Hn(e,t).sort((i,c)=>i.offset-c.offset),r=s[s.length-1];r.count=Math.min(n-r.offset,r.count);let a=0;return s.forEach(({count:i})=>a+=i),n!==a}function nn(e,t,n,s,r){let a=1/0,i=1/0,c=1/0,o=-1/0,p=-1/0,u=-1/0,f=1/0,l=1/0,y=1/0,g=-1/0,T=-1/0,m=-1/0;for(let h=t*6,d=(t+n)*6;h<d;h+=6){const x=e[h+0],A=e[h+1],w=x-A,b=x+A;w<a&&(a=w),b>o&&(o=b),x<f&&(f=x),x>g&&(g=x);const B=e[h+2],M=e[h+3],P=B-M,_=B+M;P<i&&(i=P),_>p&&(p=_),B<l&&(l=B),B>T&&(T=B);const C=e[h+4],S=e[h+5],V=C-S,L=C+S;V<c&&(c=V),L>u&&(u=L),C<y&&(y=C),C>m&&(m=C)}s[0]=a,s[1]=i,s[2]=c,s[3]=o,s[4]=p,s[5]=u,r[0]=f,r[1]=l,r[2]=y,r[3]=g,r[4]=T,r[5]=m}function re(e,t=null,n=null,s=null){const r=e.attributes.position,a=e.index?e.index.array:null,i=mt(e),c=r.normalized;let o;t===null?(o=new Float32Array(i*6),n=0,s=i):(o=t,n=n||0,s=s||i);const p=r.array,u=r.offset||0;let f=3;r.isInterleavedBufferAttribute&&(f=r.data.stride);const l=["getX","getY","getZ"];for(let y=n;y<n+s;y++){const g=y*3,T=y*6;let m=g+0,h=g+1,d=g+2;a&&(m=a[m],h=a[h],d=a[d]),c||(m=m*f+u,h=h*f+u,d=d*f+u);for(let x=0;x<3;x++){let A,w,b;c?(A=r[l[x]](m),w=r[l[x]](h),b=r[l[x]](d)):(A=p[m+x],w=p[h+x],b=p[d+x]);let B=A;w<B&&(B=w),b<B&&(B=b);let M=A;w>M&&(M=w),b>M&&(M=b);const P=(M-B)/2,_=x*2;o[T+_+0]=B+P,o[T+_+1]=P+(Math.abs(B)+P)*Gn}}return o}function R(e,t,n){return n.min.x=t[e],n.min.y=t[e+1],n.min.z=t[e+2],n.max.x=t[e+3],n.max.y=t[e+4],n.max.z=t[e+5],n}function Mn(e){let t=-1,n=-1/0;for(let s=0;s<3;s++){const r=e[s+3]-e[s];r>n&&(n=r,t=s)}return t}function Sn(e,t){t.set(e)}function _n(e,t,n){let s,r;for(let a=0;a<3;a++){const i=a+3;s=e[a],r=t[a],n[a]=s<r?s:r,s=e[i],r=t[i],n[i]=s>r?s:r}}function Ft(e,t,n){for(let s=0;s<3;s++){const r=t[e+2*s],a=t[e+2*s+1],i=r-a,c=r+a;i<n[s]&&(n[s]=i),c>n[s+3]&&(n[s+3]=c)}}function At(e){const t=e[3]-e[0],n=e[4]-e[1],s=e[5]-e[2];return 2*(t*n+n*s+s*t)}const K=32,oe=(e,t)=>e.candidate-t.candidate,O=new Array(K).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Rt=new Float32Array(6);function ce(e,t,n,s,r,a){let i=-1,c=0;if(a===qn)i=Mn(t),i!==-1&&(c=(t[i]+t[i+3])/2);else if(a===Qn)i=Mn(e),i!==-1&&(c=ae(n,s,r,i));else if(a===On){const o=At(e);let p=Gt*r;const u=s*6,f=(s+r)*6;for(let l=0;l<3;l++){const y=t[l],m=(t[l+3]-y)/K;if(r<K/4){const h=[...O];h.length=r;let d=0;for(let A=u;A<f;A+=6,d++){const w=h[d];w.candidate=n[A+2*l],w.count=0;const{bounds:b,leftCacheBounds:B,rightCacheBounds:M}=w;for(let P=0;P<3;P++)M[P]=1/0,M[P+3]=-1/0,B[P]=1/0,B[P+3]=-1/0,b[P]=1/0,b[P+3]=-1/0;Ft(A,n,b)}h.sort(oe);let x=r;for(let A=0;A<x;A++){const w=h[A];for(;A+1<x&&h[A+1].candidate===w.candidate;)h.splice(A+1,1),x--}for(let A=u;A<f;A+=6){const w=n[A+2*l];for(let b=0;b<x;b++){const B=h[b];w>=B.candidate?Ft(A,n,B.rightCacheBounds):(Ft(A,n,B.leftCacheBounds),B.count++)}}for(let A=0;A<x;A++){const w=h[A],b=w.count,B=r-w.count,M=w.leftCacheBounds,P=w.rightCacheBounds;let _=0;b!==0&&(_=At(M)/o);let C=0;B!==0&&(C=At(P)/o);const S=Pn+Gt*(_*b+C*B);S<p&&(i=l,p=S,c=w.candidate)}}else{for(let x=0;x<K;x++){const A=O[x];A.count=0,A.candidate=y+m+x*m;const w=A.bounds;for(let b=0;b<3;b++)w[b]=1/0,w[b+3]=-1/0}for(let x=u;x<f;x+=6){let b=~~((n[x+2*l]-y)/m);b>=K&&(b=K-1);const B=O[b];B.count++,Ft(x,n,B.bounds)}const h=O[K-1];Sn(h.bounds,h.rightCacheBounds);for(let x=K-2;x>=0;x--){const A=O[x],w=O[x+1];_n(A.bounds,w.rightCacheBounds,A.rightCacheBounds)}let d=0;for(let x=0;x<K-1;x++){const A=O[x],w=A.count,b=A.bounds,M=O[x+1].rightCacheBounds;w!==0&&(d===0?Sn(b,Rt):_n(b,Rt,Rt)),d+=w;let P=0,_=0;d!==0&&(P=At(Rt)/o);const C=r-d;C!==0&&(_=At(M)/o);const S=Pn+Gt*(P*d+_*C);S<p&&(i=l,p=S,c=A.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:i,pos:c}}function ae(e,t,n,s){let r=0;for(let a=t,i=t+n;a<i;a++)r+=e[a*6+s*2];return r/n}class en{constructor(){this.boundingData=new Float32Array(6)}}function le(e,t,n,s,r,a){let i=s,c=s+r-1;const o=a.pos,p=a.axis*2;for(;;){for(;i<=c&&n[i*6+p]<o;)i++;for(;i<=c&&n[c*6+p]>=o;)c--;if(i<c){for(let u=0;u<3;u++){let f=t[i*3+u];t[i*3+u]=t[c*3+u],t[c*3+u]=f}for(let u=0;u<6;u++){let f=n[i*6+u];n[i*6+u]=n[c*6+u],n[c*6+u]=f}i++,c--}else return i}}function ue(e,t,n,s,r,a){let i=s,c=s+r-1;const o=a.pos,p=a.axis*2;for(;;){for(;i<=c&&n[i*6+p]<o;)i++;for(;i<=c&&n[c*6+p]>=o;)c--;if(i<c){let u=e[i];e[i]=e[c],e[c]=u;for(let f=0;f<6;f++){let l=n[i*6+f];n[i*6+f]=n[c*6+f],n[c*6+f]=l}i++,c--}else return i}}function D(e,t){return t[e+15]===65535}function N(e,t){return t[e+6]}function k(e,t){return t[e+14]}function H(e){return e+8}function X(e,t){return t[e+6]}function Xn(e,t){return t[e+7]}let jn,_t,Wt,Zn;const fe=Math.pow(2,32);function fn(e){return"count"in e?1:1+fn(e.left)+fn(e.right)}function pe(e,t,n){return jn=new Float32Array(n),_t=new Uint32Array(n),Wt=new Uint16Array(n),Zn=new Uint8Array(n),pn(e,t)}function pn(e,t){const n=e/4,s=e/2,r="count"in t,a=t.boundingData;for(let i=0;i<6;i++)jn[n+i]=a[i];if(r)if(t.buffer){const i=t.buffer;Zn.set(new Uint8Array(i),e);for(let c=e,o=e+i.byteLength;c<o;c+=Ct){const p=c/2;D(p,Wt)||(_t[c/4+6]+=n)}return e+i.byteLength}else{const i=t.offset,c=t.count;return _t[n+6]=i,Wt[s+14]=c,Wt[s+15]=Kt,e+Ct}else{const i=t.left,c=t.right,o=t.splitAxis;let p;if(p=pn(e+Ct,i),p/4>fe)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return _t[n+6]=p/4,p=pn(p,c),_t[n+7]=o,p}}function ye(e,t){const n=(e.index?e.index.count:e.attributes.position.count)/3,s=n>2**16,r=s?4:2,a=t?new SharedArrayBuffer(n*r):new ArrayBuffer(n*r),i=s?new Uint32Array(a):new Uint16Array(a);for(let c=0,o=i.length;c<o;c++)i[c]=c;return i}function de(e,t,n,s,r){const{maxDepth:a,verbose:i,maxLeafTris:c,strategy:o,onProgress:p,indirect:u}=r,f=e._indirectBuffer,l=e.geometry,y=l.index?l.index.array:null,g=u?ue:le,T=mt(l),m=new Float32Array(6);let h=!1;const d=new en;return nn(t,n,s,d.boundingData,m),A(d,n,s,m),d;function x(w){p&&p(w/T)}function A(w,b,B,M=null,P=0){if(!h&&P>=a&&(h=!0,i&&(console.warn(`MeshBVH: Max depth of ${a} reached when generating BVH. Consider increasing maxDepth.`),console.warn(l))),B<=c||P>=a)return x(b+B),w.offset=b,w.count=B,w;const _=ce(w.boundingData,M,t,b,B,o);if(_.axis===-1)return x(b+B),w.offset=b,w.count=B,w;const C=g(f,y,t,b,B,_);if(C===b||C===b+B)x(b+B),w.offset=b,w.count=B;else{w.splitAxis=_.axis;const S=new en,V=b,L=C-b;w.left=S,nn(t,V,L,S.boundingData,m),A(S,V,L,m,P+1);const U=new en,E=C,Q=B-L;w.right=U,nn(t,E,Q,U.boundingData,m),A(U,E,Q,m,P+1)}return w}}function he(e,t){const n=e.geometry;t.indirect&&(e._indirectBuffer=ye(n,t.useSharedArrayBuffer),ie(n,t.range)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),e._indirectBuffer||se(n,t);const s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,r=re(n),a=t.indirect?kn(n,t.range):Hn(n,t.range);e._roots=a.map(i=>{const c=de(e,r,i.offset,i.count,t),o=fn(c),p=new s(Ct*o);return pe(0,c,p),p})}const{Vector3:me}=await v("three");class J{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,n){let s=1/0,r=-1/0;for(let a=0,i=t.length;a<i;a++){const o=t[a][n];s=o<s?o:s,r=o>r?o:r}this.min=s,this.max=r}setFromPoints(t,n){let s=1/0,r=-1/0;for(let a=0,i=n.length;a<i;a++){const c=n[a],o=t.dot(c);s=o<s?o:s,r=o>r?o:r}this.min=s,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}J.prototype.setFromBox=function(){const e=new me;return function(n,s){const r=s.min,a=s.max;let i=1/0,c=-1/0;for(let o=0;o<=1;o++)for(let p=0;p<=1;p++)for(let u=0;u<=1;u++){e.x=r.x*o+a.x*(1-o),e.y=r.y*p+a.y*(1-p),e.z=r.z*u+a.z*(1-u);const f=n.dot(e);i=Math.min(f,i),c=Math.max(f,c)}this.min=i,this.max=c}}();const{Vector3:ot,Vector2:xe,Plane:we,Line3:Ae}=await v("three"),ge=function(){const e=new ot,t=new ot,n=new ot;return function(r,a,i){const c=r.start,o=e,p=a.start,u=t;n.subVectors(c,p),e.subVectors(r.end,r.start),t.subVectors(a.end,a.start);const f=n.dot(u),l=u.dot(o),y=u.dot(u),g=n.dot(o),m=o.dot(o)*y-l*l;let h,d;m!==0?h=(f*l-g*y)/m:h=0,d=(f+h*l)/y,i.x=h,i.y=d}}(),gn=function(){const e=new xe,t=new ot,n=new ot;return function(r,a,i,c){ge(r,a,e);let o=e.x,p=e.y;if(o>=0&&o<=1&&p>=0&&p<=1){r.at(o,i),a.at(p,c);return}else if(o>=0&&o<=1){p<0?a.at(0,c):a.at(1,c),r.closestPointToPoint(c,!0,i);return}else if(p>=0&&p<=1){o<0?r.at(0,i):r.at(1,i),a.closestPointToPoint(i,!0,c);return}else{let u;o<0?u=r.start:u=r.end;let f;p<0?f=a.start:f=a.end;const l=t,y=n;if(r.closestPointToPoint(f,!0,t),a.closestPointToPoint(u,!0,n),l.distanceToSquared(f)<=y.distanceToSquared(u)){i.copy(l),c.copy(f);return}else{i.copy(u),c.copy(y);return}}}}(),Te=function(){const e=new ot,t=new ot,n=new we,s=new Ae;return function(a,i){const{radius:c,center:o}=a,{a:p,b:u,c:f}=i;if(s.start=p,s.end=u,s.closestPointToPoint(o,!0,e).distanceTo(o)<=c||(s.start=p,s.end=f,s.closestPointToPoint(o,!0,e).distanceTo(o)<=c)||(s.start=u,s.end=f,s.closestPointToPoint(o,!0,e).distanceTo(o)<=c))return!0;const T=i.getPlane(n);if(Math.abs(T.distanceToPoint(o))<=c){const h=T.projectPoint(o,t);if(i.containsPoint(h))return!0}return!1}}(),{Triangle:Be,Vector3:q,Line3:ht,Sphere:be,Plane:Pe}=await v("three"),Me=1e-15;function sn(e){return Math.abs(e)<Me}class W extends Be{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new q),this.satBounds=new Array(4).fill().map(()=>new J),this.points=[this.a,this.b,this.c],this.sphere=new be,this.plane=new Pe,this.needsUpdate=!0}intersectsSphere(t){return Te(t,this)}update(){const t=this.a,n=this.b,s=this.c,r=this.points,a=this.satAxes,i=this.satBounds,c=a[0],o=i[0];this.getNormal(c),o.setFromPoints(c,r);const p=a[1],u=i[1];p.subVectors(t,n),u.setFromPoints(p,r);const f=a[2],l=i[2];f.subVectors(n,s),l.setFromPoints(f,r);const y=a[3],g=i[3];y.subVectors(s,t),g.setFromPoints(y,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,t),this.needsUpdate=!1}}W.prototype.closestPointToSegment=function(){const e=new q,t=new q,n=new ht;return function(r,a=null,i=null){const{start:c,end:o}=r,p=this.points;let u,f=1/0;for(let l=0;l<3;l++){const y=(l+1)%3;n.start.copy(p[l]),n.end.copy(p[y]),gn(n,r,e,t),u=e.distanceToSquared(t),u<f&&(f=u,a&&a.copy(e),i&&i.copy(t))}return this.closestPointToPoint(c,e),u=c.distanceToSquared(e),u<f&&(f=u,a&&a.copy(e),i&&i.copy(c)),this.closestPointToPoint(o,e),u=o.distanceToSquared(e),u<f&&(f=u,a&&a.copy(e),i&&i.copy(o)),Math.sqrt(f)}}();W.prototype.intersectsTriangle=function(){const e=new W,t=new Array(3),n=new Array(3),s=new J,r=new J,a=new q,i=new q,c=new q,o=new q,p=new q,u=new ht,f=new ht,l=new ht,y=new q;function g(T,m,h){const d=T.points;let x=0,A=-1;for(let w=0;w<3;w++){const{start:b,end:B}=u;b.copy(d[w]),B.copy(d[(w+1)%3]),u.delta(i);const M=sn(m.distanceToPoint(b));if(sn(m.normal.dot(i))&&M){h.copy(u),x=2;break}const P=m.intersectLine(u,y);if(!P&&M&&y.copy(b),(P||M)&&!sn(y.distanceTo(B))){if(x<=1)(x===1?h.start:h.end).copy(y),M&&(A=x);else if(x>=2){(A===1?h.start:h.end).copy(y),x=2;break}if(x++,x===2&&A===-1)break}}return x}return function(m,h=null,d=!1){this.needsUpdate&&this.update(),m.isExtendedTriangle?m.needsUpdate&&m.update():(e.copy(m),e.update(),m=e);const x=this.plane,A=m.plane;if(Math.abs(x.normal.dot(A.normal))>1-1e-10){const w=this.satBounds,b=this.satAxes;n[0]=m.a,n[1]=m.b,n[2]=m.c;for(let P=0;P<4;P++){const _=w[P],C=b[P];if(s.setFromPoints(C,n),_.isSeparated(s))return!1}const B=m.satBounds,M=m.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let P=0;P<4;P++){const _=B[P],C=M[P];if(s.setFromPoints(C,t),_.isSeparated(s))return!1}for(let P=0;P<4;P++){const _=b[P];for(let C=0;C<4;C++){const S=M[C];if(a.crossVectors(_,S),s.setFromPoints(a,t),r.setFromPoints(a,n),s.isSeparated(r))return!1}}return h&&(d||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),h.start.set(0,0,0),h.end.set(0,0,0)),!0}else{const w=g(this,A,f);if(w===1&&m.containsPoint(f.end))return h&&(h.start.copy(f.end),h.end.copy(f.end)),!0;if(w!==2)return!1;const b=g(m,x,l);if(b===1&&this.containsPoint(l.end))return h&&(h.start.copy(l.end),h.end.copy(l.end)),!0;if(b!==2)return!1;if(f.delta(c),l.delta(o),c.dot(o)<0){let V=l.start;l.start=l.end,l.end=V}const B=f.start.dot(c),M=f.end.dot(c),P=l.start.dot(c),_=l.end.dot(c),C=M<P,S=B<_;return B!==_&&P!==M&&C===S?!1:(h&&(p.subVectors(f.start,l.start),p.dot(c)>0?h.start.copy(f.start):h.start.copy(l.start),p.subVectors(f.end,l.end),p.dot(c)<0?h.end.copy(f.end):h.end.copy(l.end)),!0)}}}();W.prototype.distanceToPoint=function(){const e=new q;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}}();W.prototype.distanceToTriangle=function(){const e=new q,t=new q,n=["a","b","c"],s=new ht,r=new ht;return function(i,c=null,o=null){const p=c||o?s:null;if(this.intersectsTriangle(i,p))return(c||o)&&(c&&p.getCenter(c),o&&p.getCenter(o)),0;let u=1/0;for(let f=0;f<3;f++){let l;const y=n[f],g=i[y];this.closestPointToPoint(g,e),l=g.distanceToSquared(e),l<u&&(u=l,c&&c.copy(e),o&&o.copy(g));const T=this[y];i.closestPointToPoint(T,e),l=T.distanceToSquared(e),l<u&&(u=l,c&&c.copy(T),o&&o.copy(e))}for(let f=0;f<3;f++){const l=n[f],y=n[(f+1)%3];s.set(this[l],this[y]);for(let g=0;g<3;g++){const T=n[g],m=n[(g+1)%3];r.set(i[T],i[m]),gn(s,r,e,t);const h=e.distanceToSquared(t);h<u&&(u=h,c&&c.copy(e),o&&o.copy(t))}}return Math.sqrt(u)}}();const{Vector3:tt,Matrix4:Cn,Line3:Vn}=await v("three");class I{constructor(t,n,s){this.isOrientedBox=!0,this.min=new tt,this.max=new tt,this.matrix=new Cn,this.invMatrix=new Cn,this.points=new Array(8).fill().map(()=>new tt),this.satAxes=new Array(3).fill().map(()=>new tt),this.satBounds=new Array(3).fill().map(()=>new J),this.alignedSatBounds=new Array(3).fill().map(()=>new J),this.needsUpdate=!1,t&&this.min.copy(t),n&&this.max.copy(n),s&&this.matrix.copy(s)}set(t,n,s){this.min.copy(t),this.max.copy(n),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}I.prototype.update=function(){return function(){const t=this.matrix,n=this.min,s=this.max,r=this.points;for(let p=0;p<=1;p++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){const l=1*p|2*u|4*f,y=r[l];y.x=p?s.x:n.x,y.y=u?s.y:n.y,y.z=f?s.z:n.z,y.applyMatrix4(t)}const a=this.satBounds,i=this.satAxes,c=r[0];for(let p=0;p<3;p++){const u=i[p],f=a[p],l=1<<p,y=r[l];u.subVectors(c,y),f.setFromPoints(u,r)}const o=this.alignedSatBounds;o[0].setFromPointsField(r,"x"),o[1].setFromPointsField(r,"y"),o[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();I.prototype.intersectsBox=function(){const e=new J;return function(n){this.needsUpdate&&this.update();const s=n.min,r=n.max,a=this.satBounds,i=this.satAxes,c=this.alignedSatBounds;if(e.min=s.x,e.max=r.x,c[0].isSeparated(e)||(e.min=s.y,e.max=r.y,c[1].isSeparated(e))||(e.min=s.z,e.max=r.z,c[2].isSeparated(e)))return!1;for(let o=0;o<3;o++){const p=i[o],u=a[o];if(e.setFromBox(p,n),u.isSeparated(e))return!1}return!0}}();I.prototype.intersectsTriangle=function(){const e=new W,t=new Array(3),n=new J,s=new J,r=new tt;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(e.copy(i),e.update(),i=e);const c=this.satBounds,o=this.satAxes;t[0]=i.a,t[1]=i.b,t[2]=i.c;for(let l=0;l<3;l++){const y=c[l],g=o[l];if(n.setFromPoints(g,t),y.isSeparated(n))return!1}const p=i.satBounds,u=i.satAxes,f=this.points;for(let l=0;l<3;l++){const y=p[l],g=u[l];if(n.setFromPoints(g,f),y.isSeparated(n))return!1}for(let l=0;l<3;l++){const y=o[l];for(let g=0;g<4;g++){const T=u[g];if(r.crossVectors(y,T),n.setFromPoints(r,t),s.setFromPoints(r,f),n.isSeparated(s))return!1}}return!0}}();I.prototype.closestPointToPoint=function(){return function(t,n){return this.needsUpdate&&this.update(),n.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),n}}();I.prototype.distanceToPoint=function(){const e=new tt;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}}();I.prototype.distanceToBox=function(){const e=["x","y","z"],t=new Array(12).fill().map(()=>new Vn),n=new Array(12).fill().map(()=>new Vn),s=new tt,r=new tt;return function(i,c=0,o=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(o||p)&&(i.getCenter(r),this.closestPointToPoint(r,s),i.closestPointToPoint(s,r),o&&o.copy(s),p&&p.copy(r)),0;const u=c*c,f=i.min,l=i.max,y=this.points;let g=1/0;for(let m=0;m<8;m++){const h=y[m];r.copy(h).clamp(f,l);const d=h.distanceToSquared(r);if(d<g&&(g=d,o&&o.copy(h),p&&p.copy(r),d<u))return Math.sqrt(d)}let T=0;for(let m=0;m<3;m++)for(let h=0;h<=1;h++)for(let d=0;d<=1;d++){const x=(m+1)%3,A=(m+2)%3,w=h<<x|d<<A,b=1<<m|h<<x|d<<A,B=y[w],M=y[b];t[T].set(B,M);const _=e[m],C=e[x],S=e[A],V=n[T],L=V.start,U=V.end;L[_]=f[_],L[C]=h?f[C]:l[C],L[S]=d?f[S]:l[C],U[_]=l[_],U[C]=h?f[C]:l[C],U[S]=d?f[S]:l[C],T++}for(let m=0;m<=1;m++)for(let h=0;h<=1;h++)for(let d=0;d<=1;d++){r.x=m?l.x:f.x,r.y=h?l.y:f.y,r.z=d?l.z:f.z,this.closestPointToPoint(r,s);const x=r.distanceToSquared(s);if(x<g&&(g=x,o&&o.copy(s),p&&p.copy(r),x<u))return Math.sqrt(x)}for(let m=0;m<12;m++){const h=t[m];for(let d=0;d<12;d++){const x=n[d];gn(h,x,s,r);const A=s.distanceToSquared(r);if(A<g&&(g=A,o&&o.copy(s),p&&p.copy(r),A<u))return Math.sqrt(A)}}return Math.sqrt(g)}}();class Tn{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Se extends Tn{constructor(){super(()=>new W)}}const j=new Se;class _e{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let n=null;this.setBuffer=s=>{n&&t.push(n),n=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{n=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const F=new _e,{Box3:Ce}=await v("three");let nt,dt;const ct=[],Et=new Tn(()=>new Ce);function Ve(e,t,n,s,r,a){nt=Et.getPrimitive(),dt=Et.getPrimitive(),ct.push(nt,dt),F.setBuffer(e._roots[t]);const i=yn(0,e.geometry,n,s,r,a);F.clearBuffer(),Et.releasePrimitive(nt),Et.releasePrimitive(dt),ct.pop(),ct.pop();const c=ct.length;return c>0&&(dt=ct[c-1],nt=ct[c-2]),i}function yn(e,t,n,s,r=null,a=0,i=0){const{float32Array:c,uint16Array:o,uint32Array:p}=F;let u=e*2;if(D(u,o)){const l=N(e,p),y=k(u,o);return R(e,c,nt),s(l,y,!1,i,a+e,nt)}else{let _=function(S){const{uint16Array:V,uint32Array:L}=F;let U=S*2;for(;!D(U,V);)S=H(S),U=S*2;return N(S,L)},C=function(S){const{uint16Array:V,uint32Array:L}=F;let U=S*2;for(;!D(U,V);)S=X(S,L),U=S*2;return N(S,L)+k(U,V)};const l=H(e),y=X(e,p);let g=l,T=y,m,h,d,x;if(r&&(d=nt,x=dt,R(g,c,d),R(T,c,x),m=r(d),h=r(x),h<m)){g=y,T=l;const S=m;m=h,h=S,d=x}d||(d=nt,R(g,c,d));const A=D(g*2,o),w=n(d,A,m,i+1,a+g);let b;if(w===bn){const S=_(g),L=C(g)-S;b=s(S,L,!0,i+1,a+g,d)}else b=w&&yn(g,t,n,s,r,a,i+1);if(b)return!0;x=dt,R(T,c,x);const B=D(T*2,o),M=n(x,B,h,i+1,a+T);let P;if(M===bn){const S=_(T),L=C(T)-S;P=s(S,L,!0,i+1,a+T,x)}else P=M&&yn(T,t,n,s,r,a,i+1);return!!P}}const{Vector3:Wn}=await v("three"),gt=new Wn,rn=new Wn;function Le(e,t,n={},s=0,r=1/0){const a=s*s,i=r*r;let c=1/0,o=null;if(e.shapecast({boundsTraverseOrder:u=>(gt.copy(t).clamp(u.min,u.max),gt.distanceToSquared(t)),intersectsBounds:(u,f,l)=>l<c&&l<i,intersectsTriangle:(u,f)=>{u.closestPointToPoint(t,gt);const l=t.distanceToSquared(gt);return l<c&&(rn.copy(gt),c=l,o=f),l<a}}),c===1/0)return null;const p=Math.sqrt(c);return n.point?n.point.copy(rn):n.point=rn.clone(),n.distance=p,n.faceIndex=o,n}const{Vector3:Y,Vector2:Lt,Triangle:Tt,DoubleSide:Ue,BackSide:Fe,REVISION:Re}=await v("three"),Ee=parseInt(Re)>=169,st=new Y,it=new Y,rt=new Y,zt=new Lt,$t=new Lt,vt=new Lt,Ln=new Y,Un=new Y,Fn=new Y,Bt=new Y;function ze(e,t,n,s,r,a,i,c){let o;if(a===Fe?o=e.intersectTriangle(s,n,t,!0,r):o=e.intersectTriangle(t,n,s,a!==Ue,r),o===null)return null;const p=e.origin.distanceTo(r);return p<i||p>c?null:{distance:p,point:r.clone()}}function $e(e,t,n,s,r,a,i,c,o,p,u){st.fromBufferAttribute(t,a),it.fromBufferAttribute(t,i),rt.fromBufferAttribute(t,c);const f=ze(e,st,it,rt,Bt,o,p,u);if(f){const l=new Y;Tt.getBarycoord(Bt,st,it,rt,l),s&&(zt.fromBufferAttribute(s,a),$t.fromBufferAttribute(s,i),vt.fromBufferAttribute(s,c),f.uv=Tt.getInterpolation(Bt,st,it,rt,zt,$t,vt,new Lt)),r&&(zt.fromBufferAttribute(r,a),$t.fromBufferAttribute(r,i),vt.fromBufferAttribute(r,c),f.uv1=Tt.getInterpolation(Bt,st,it,rt,zt,$t,vt,new Lt)),n&&(Ln.fromBufferAttribute(n,a),Un.fromBufferAttribute(n,i),Fn.fromBufferAttribute(n,c),f.normal=Tt.getInterpolation(Bt,st,it,rt,Ln,Un,Fn,new Y),f.normal.dot(e.direction)>0&&f.normal.multiplyScalar(-1));const y={a,b:i,c,normal:new Y,materialIndex:0};Tt.getNormal(st,it,rt,y.normal),f.face=y,f.faceIndex=a,Ee&&(f.barycoord=l)}return f}function Jt(e,t,n,s,r,a,i){const c=s*3;let o=c+0,p=c+1,u=c+2;const f=e.index;e.index&&(o=f.getX(o),p=f.getX(p),u=f.getX(u));const{position:l,normal:y,uv:g,uv1:T}=e.attributes,m=$e(n,l,y,g,T,o,p,u,t,a,i);return m?(m.faceIndex=s,r&&r.push(m),m):null}const{Vector2:Us,Vector3:Fs,Triangle:Rs}=await v("three");function z(e,t,n,s){const r=e.a,a=e.b,i=e.c;let c=t,o=t+1,p=t+2;n&&(c=n.getX(c),o=n.getX(o),p=n.getX(p)),r.x=s.getX(c),r.y=s.getY(c),r.z=s.getZ(c),a.x=s.getX(o),a.y=s.getY(o),a.z=s.getZ(o),i.x=s.getX(p),i.y=s.getY(p),i.z=s.getZ(p)}function ve(e,t,n,s,r,a,i,c){const{geometry:o,_indirectBuffer:p}=e;for(let u=s,f=s+r;u<f;u++)Jt(o,t,n,u,a,i,c)}function Ie(e,t,n,s,r,a,i){const{geometry:c,_indirectBuffer:o}=e;let p=1/0,u=null;for(let f=s,l=s+r;f<l;f++){let y;y=Jt(c,t,n,f,null,a,i),y&&y.distance<p&&(u=y,p=y.distance)}return u}function De(e,t,n,s,r,a,i){const{geometry:c}=n,{index:o}=c,p=c.attributes.position;for(let u=e,f=t+e;u<f;u++){let l;if(l=u,z(i,l*3,o,p),i.needsUpdate=!0,s(i,l,r,a))return!0}return!1}function Ne(e,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,s=n.index?n.index.array:null,r=n.attributes.position;let a,i,c,o,p=0;const u=e._roots;for(let l=0,y=u.length;l<y;l++)a=u[l],i=new Uint32Array(a),c=new Uint16Array(a),o=new Float32Array(a),f(0,p),p+=a.byteLength;function f(l,y,g=!1){const T=l*2;if(c[T+15]===Kt){const h=i[l+6],d=c[T+14];let x=1/0,A=1/0,w=1/0,b=-1/0,B=-1/0,M=-1/0;for(let P=3*h,_=3*(h+d);P<_;P++){let C=s[P];const S=r.getX(C),V=r.getY(C),L=r.getZ(C);S<x&&(x=S),S>b&&(b=S),V<A&&(A=V),V>B&&(B=V),L<w&&(w=L),L>M&&(M=L)}return o[l+0]!==x||o[l+1]!==A||o[l+2]!==w||o[l+3]!==b||o[l+4]!==B||o[l+5]!==M?(o[l+0]=x,o[l+1]=A,o[l+2]=w,o[l+3]=b,o[l+4]=B,o[l+5]=M,!0):!1}else{const h=l+8,d=i[l+6],x=h+y,A=d+y;let w=g,b=!1,B=!1;t?w||(b=t.has(x),B=t.has(A),w=!b&&!B):(b=!0,B=!0);const M=w||b,P=w||B;let _=!1;M&&(_=f(h,y,w));let C=!1;P&&(C=f(d,y,w));const S=_||C;if(S)for(let V=0;V<3;V++){const L=h+V,U=d+V,E=o[L],Q=o[L+3],xt=o[U],wt=o[U+3];o[l+V]=E<xt?E:xt,o[l+V+3]=Q>wt?Q:wt}return S}}}function et(e,t,n,s,r){let a,i,c,o,p,u;const f=1/n.direction.x,l=1/n.direction.y,y=1/n.direction.z,g=n.origin.x,T=n.origin.y,m=n.origin.z;let h=t[e],d=t[e+3],x=t[e+1],A=t[e+3+1],w=t[e+2],b=t[e+3+2];return f>=0?(a=(h-g)*f,i=(d-g)*f):(a=(d-g)*f,i=(h-g)*f),l>=0?(c=(x-T)*l,o=(A-T)*l):(c=(A-T)*l,o=(x-T)*l),a>o||c>i||((c>a||isNaN(a))&&(a=c),(o<i||isNaN(i))&&(i=o),y>=0?(p=(w-m)*y,u=(b-m)*y):(p=(b-m)*y,u=(w-m)*y),a>u||p>i)?!1:((p>a||a!==a)&&(a=p),(u<i||i!==i)&&(i=u),a<=r&&i>=s)}function qe(e,t,n,s,r,a,i,c){const{geometry:o,_indirectBuffer:p}=e;for(let u=s,f=s+r;u<f;u++){let l=p?p[u]:u;Jt(o,t,n,l,a,i,c)}}function ke(e,t,n,s,r,a,i){const{geometry:c,_indirectBuffer:o}=e;let p=1/0,u=null;for(let f=s,l=s+r;f<l;f++){let y;y=Jt(c,t,n,o?o[f]:f,null,a,i),y&&y.distance<p&&(u=y,p=y.distance)}return u}function He(e,t,n,s,r,a,i){const{geometry:c}=n,{index:o}=c,p=c.attributes.position;for(let u=e,f=t+e;u<f;u++){let l;if(l=n.resolveTriangleIndex(u),z(i,l*3,o,p),i.needsUpdate=!0,s(i,l,r,a))return!0}return!1}function Xe(e,t,n,s,r,a,i){F.setBuffer(e._roots[t]),dn(0,e,n,s,r,a,i),F.clearBuffer()}function dn(e,t,n,s,r,a,i){const{float32Array:c,uint16Array:o,uint32Array:p}=F,u=e*2;if(D(u,o)){const l=N(e,p),y=k(u,o);ve(t,n,s,l,y,r,a,i)}else{const l=H(e);et(l,c,s,a,i)&&dn(l,t,n,s,r,a,i);const y=X(e,p);et(y,c,s,a,i)&&dn(y,t,n,s,r,a,i)}}const je=["x","y","z"];function Ze(e,t,n,s,r,a){F.setBuffer(e._roots[t]);const i=hn(0,e,n,s,r,a);return F.clearBuffer(),i}function hn(e,t,n,s,r,a){const{float32Array:i,uint16Array:c,uint32Array:o}=F;let p=e*2;if(D(p,c)){const f=N(e,o),l=k(p,c);return Ie(t,n,s,f,l,r,a)}else{const f=Xn(e,o),l=je[f],g=s.direction[l]>=0;let T,m;g?(T=H(e),m=X(e,o)):(T=X(e,o),m=H(e));const d=et(T,i,s,r,a)?hn(T,t,n,s,r,a):null;if(d){const w=d.point[l];if(g?w<=i[m+f]:w>=i[m+f+3])return d}const A=et(m,i,s,r,a)?hn(m,t,n,s,r,a):null;return d&&A?d.distance<=A.distance?d:A:d||A||null}}const{Box3:We,Matrix4:Ye}=await v("three"),It=new We,at=new W,lt=new W,bt=new Ye,Rn=new I,Dt=new I;function Ke(e,t,n,s){F.setBuffer(e._roots[t]);const r=mn(0,e,n,s);return F.clearBuffer(),r}function mn(e,t,n,s,r=null){const{float32Array:a,uint16Array:i,uint32Array:c}=F;let o=e*2;if(r===null&&(n.boundingBox||n.computeBoundingBox(),Rn.set(n.boundingBox.min,n.boundingBox.max,s),r=Rn),D(o,i)){const u=t.geometry,f=u.index,l=u.attributes.position,y=n.index,g=n.attributes.position,T=N(e,c),m=k(o,i);if(bt.copy(s).invert(),n.boundsTree)return R(e,a,Dt),Dt.matrix.copy(bt),Dt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:d=>Dt.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let x=T*3,A=(m+T)*3;x<A;x+=3)if(z(lt,x,f,l),lt.needsUpdate=!0,d.intersectsTriangle(lt))return!0;return!1}});for(let h=T*3,d=(m+T)*3;h<d;h+=3){z(at,h,f,l),at.a.applyMatrix4(bt),at.b.applyMatrix4(bt),at.c.applyMatrix4(bt),at.needsUpdate=!0;for(let x=0,A=y.count;x<A;x+=3)if(z(lt,x,y,g),lt.needsUpdate=!0,at.intersectsTriangle(lt))return!0}}else{const u=e+8,f=c[e+6];return R(u,a,It),!!(r.intersectsBox(It)&&mn(u,t,n,s,r)||(R(f,a,It),r.intersectsBox(It)&&mn(f,t,n,s,r)))}}const{Matrix4:Je,Vector3:Qt}=await v("three"),Nt=new Je,on=new I,Pt=new I,Qe=new Qt,Oe=new Qt,Ge=new Qt,ts=new Qt;function ns(e,t,n,s={},r={},a=0,i=1/0){t.boundingBox||t.computeBoundingBox(),on.set(t.boundingBox.min,t.boundingBox.max,n),on.needsUpdate=!0;const c=e.geometry,o=c.attributes.position,p=c.index,u=t.attributes.position,f=t.index,l=j.getPrimitive(),y=j.getPrimitive();let g=Qe,T=Oe,m=null,h=null;r&&(m=Ge,h=ts);let d=1/0,x=null,A=null;return Nt.copy(n).invert(),Pt.matrix.copy(Nt),e.shapecast({boundsTraverseOrder:w=>on.distanceToBox(w),intersectsBounds:(w,b,B)=>B<d&&B<i?(b&&(Pt.min.copy(w.min),Pt.max.copy(w.max),Pt.needsUpdate=!0),!0):!1,intersectsRange:(w,b)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:M=>Pt.distanceToBox(M),intersectsBounds:(M,P,_)=>_<d&&_<i,intersectsRange:(M,P)=>{for(let _=M,C=M+P;_<C;_++){z(y,3*_,f,u),y.a.applyMatrix4(n),y.b.applyMatrix4(n),y.c.applyMatrix4(n),y.needsUpdate=!0;for(let S=w,V=w+b;S<V;S++){z(l,3*S,p,o),l.needsUpdate=!0;const L=l.distanceToTriangle(y,g,m);if(L<d&&(T.copy(g),h&&h.copy(m),d=L,x=S,A=_),L<a)return!0}}}});{const B=mt(t);for(let M=0,P=B;M<P;M++){z(y,3*M,f,u),y.a.applyMatrix4(n),y.b.applyMatrix4(n),y.c.applyMatrix4(n),y.needsUpdate=!0;for(let _=w,C=w+b;_<C;_++){z(l,3*_,p,o),l.needsUpdate=!0;const S=l.distanceToTriangle(y,g,m);if(S<d&&(T.copy(g),h&&h.copy(m),d=S,x=_,A=M),S<a)return!0}}}}}),j.releasePrimitive(l),j.releasePrimitive(y),d===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=d,s.faceIndex=x,r&&(r.point?r.point.copy(h):r.point=h.clone(),r.point.applyMatrix4(Nt),T.applyMatrix4(Nt),r.distance=T.sub(r.point).length(),r.faceIndex=A),s)}function es(e,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,s=n.index?n.index.array:null,r=n.attributes.position;let a,i,c,o,p=0;const u=e._roots;for(let l=0,y=u.length;l<y;l++)a=u[l],i=new Uint32Array(a),c=new Uint16Array(a),o=new Float32Array(a),f(0,p),p+=a.byteLength;function f(l,y,g=!1){const T=l*2;if(c[T+15]===Kt){const h=i[l+6],d=c[T+14];let x=1/0,A=1/0,w=1/0,b=-1/0,B=-1/0,M=-1/0;for(let P=h,_=h+d;P<_;P++){const C=3*e.resolveTriangleIndex(P);for(let S=0;S<3;S++){let V=C+S;V=s?s[V]:V;const L=r.getX(V),U=r.getY(V),E=r.getZ(V);L<x&&(x=L),L>b&&(b=L),U<A&&(A=U),U>B&&(B=U),E<w&&(w=E),E>M&&(M=E)}}return o[l+0]!==x||o[l+1]!==A||o[l+2]!==w||o[l+3]!==b||o[l+4]!==B||o[l+5]!==M?(o[l+0]=x,o[l+1]=A,o[l+2]=w,o[l+3]=b,o[l+4]=B,o[l+5]=M,!0):!1}else{const h=l+8,d=i[l+6],x=h+y,A=d+y;let w=g,b=!1,B=!1;t?w||(b=t.has(x),B=t.has(A),w=!b&&!B):(b=!0,B=!0);const M=w||b,P=w||B;let _=!1;M&&(_=f(h,y,w));let C=!1;P&&(C=f(d,y,w));const S=_||C;if(S)for(let V=0;V<3;V++){const L=h+V,U=d+V,E=o[L],Q=o[L+3],xt=o[U],wt=o[U+3];o[l+V]=E<xt?E:xt,o[l+V+3]=Q>wt?Q:wt}return S}}}function ss(e,t,n,s,r,a,i){F.setBuffer(e._roots[t]),xn(0,e,n,s,r,a,i),F.clearBuffer()}function xn(e,t,n,s,r,a,i){const{float32Array:c,uint16Array:o,uint32Array:p}=F,u=e*2;if(D(u,o)){const l=N(e,p),y=k(u,o);qe(t,n,s,l,y,r,a,i)}else{const l=H(e);et(l,c,s,a,i)&&xn(l,t,n,s,r,a,i);const y=X(e,p);et(y,c,s,a,i)&&xn(y,t,n,s,r,a,i)}}const is=["x","y","z"];function rs(e,t,n,s,r,a){F.setBuffer(e._roots[t]);const i=wn(0,e,n,s,r,a);return F.clearBuffer(),i}function wn(e,t,n,s,r,a){const{float32Array:i,uint16Array:c,uint32Array:o}=F;let p=e*2;if(D(p,c)){const f=N(e,o),l=k(p,c);return ke(t,n,s,f,l,r,a)}else{const f=Xn(e,o),l=is[f],g=s.direction[l]>=0;let T,m;g?(T=H(e),m=X(e,o)):(T=X(e,o),m=H(e));const d=et(T,i,s,r,a)?wn(T,t,n,s,r,a):null;if(d){const w=d.point[l];if(g?w<=i[m+f]:w>=i[m+f+3])return d}const A=et(m,i,s,r,a)?wn(m,t,n,s,r,a):null;return d&&A?d.distance<=A.distance?d:A:d||A||null}}const{Box3:os,Matrix4:cs}=await v("three"),qt=new os,ut=new W,ft=new W,Mt=new cs,En=new I,kt=new I;function as(e,t,n,s){F.setBuffer(e._roots[t]);const r=An(0,e,n,s);return F.clearBuffer(),r}function An(e,t,n,s,r=null){const{float32Array:a,uint16Array:i,uint32Array:c}=F;let o=e*2;if(r===null&&(n.boundingBox||n.computeBoundingBox(),En.set(n.boundingBox.min,n.boundingBox.max,s),r=En),D(o,i)){const u=t.geometry,f=u.index,l=u.attributes.position,y=n.index,g=n.attributes.position,T=N(e,c),m=k(o,i);if(Mt.copy(s).invert(),n.boundsTree)return R(e,a,kt),kt.matrix.copy(Mt),kt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:d=>kt.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let x=T,A=m+T;x<A;x++)if(z(ft,3*t.resolveTriangleIndex(x),f,l),ft.needsUpdate=!0,d.intersectsTriangle(ft))return!0;return!1}});for(let h=T,d=m+T;h<d;h++){const x=t.resolveTriangleIndex(h);z(ut,3*x,f,l),ut.a.applyMatrix4(Mt),ut.b.applyMatrix4(Mt),ut.c.applyMatrix4(Mt),ut.needsUpdate=!0;for(let A=0,w=y.count;A<w;A+=3)if(z(ft,A,y,g),ft.needsUpdate=!0,ut.intersectsTriangle(ft))return!0}}else{const u=e+8,f=c[e+6];return R(u,a,qt),!!(r.intersectsBox(qt)&&An(u,t,n,s,r)||(R(f,a,qt),r.intersectsBox(qt)&&An(f,t,n,s,r)))}}const{Matrix4:ls,Vector3:Ot}=await v("three"),Ht=new ls,cn=new I,St=new I,us=new Ot,fs=new Ot,ps=new Ot,ys=new Ot;function ds(e,t,n,s={},r={},a=0,i=1/0){t.boundingBox||t.computeBoundingBox(),cn.set(t.boundingBox.min,t.boundingBox.max,n),cn.needsUpdate=!0;const c=e.geometry,o=c.attributes.position,p=c.index,u=t.attributes.position,f=t.index,l=j.getPrimitive(),y=j.getPrimitive();let g=us,T=fs,m=null,h=null;r&&(m=ps,h=ys);let d=1/0,x=null,A=null;return Ht.copy(n).invert(),St.matrix.copy(Ht),e.shapecast({boundsTraverseOrder:w=>cn.distanceToBox(w),intersectsBounds:(w,b,B)=>B<d&&B<i?(b&&(St.min.copy(w.min),St.max.copy(w.max),St.needsUpdate=!0),!0):!1,intersectsRange:(w,b)=>{if(t.boundsTree){const B=t.boundsTree;return B.shapecast({boundsTraverseOrder:M=>St.distanceToBox(M),intersectsBounds:(M,P,_)=>_<d&&_<i,intersectsRange:(M,P)=>{for(let _=M,C=M+P;_<C;_++){const S=B.resolveTriangleIndex(_);z(y,3*S,f,u),y.a.applyMatrix4(n),y.b.applyMatrix4(n),y.c.applyMatrix4(n),y.needsUpdate=!0;for(let V=w,L=w+b;V<L;V++){const U=e.resolveTriangleIndex(V);z(l,3*U,p,o),l.needsUpdate=!0;const E=l.distanceToTriangle(y,g,m);if(E<d&&(T.copy(g),h&&h.copy(m),d=E,x=V,A=_),E<a)return!0}}}})}else{const B=mt(t);for(let M=0,P=B;M<P;M++){z(y,3*M,f,u),y.a.applyMatrix4(n),y.b.applyMatrix4(n),y.c.applyMatrix4(n),y.needsUpdate=!0;for(let _=w,C=w+b;_<C;_++){const S=e.resolveTriangleIndex(_);z(l,3*S,p,o),l.needsUpdate=!0;const V=l.distanceToTriangle(y,g,m);if(V<d&&(T.copy(g),h&&h.copy(m),d=V,x=_,A=M),V<a)return!0}}}}}),j.releasePrimitive(l),j.releasePrimitive(y),d===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=d,s.faceIndex=x,r&&(r.point?r.point.copy(h):r.point=h.clone(),r.point.applyMatrix4(Ht),T.applyMatrix4(Ht),r.distance=T.sub(r.point).length(),r.faceIndex=A),s)}function hs(){return typeof SharedArrayBuffer<"u"}const{Box3:Ut,Matrix4:ms}=await v("three"),Vt=new F.constructor,Yt=new F.constructor,G=new Tn(()=>new Ut),pt=new Ut,yt=new Ut,an=new Ut,ln=new Ut;let un=!1;function xs(e,t,n,s){if(un)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");un=!0;const r=e._roots,a=t._roots;let i,c=0,o=0;const p=new ms().copy(n).invert();for(let u=0,f=r.length;u<f;u++){Vt.setBuffer(r[u]),o=0;const l=G.getPrimitive();R(0,Vt.float32Array,l),l.applyMatrix4(p);for(let y=0,g=a.length;y<g&&(Yt.setBuffer(a[y]),i=Z(0,0,n,p,s,c,o,0,0,l),Yt.clearBuffer(),o+=a[y].length,!i);y++);if(G.releasePrimitive(l),Vt.clearBuffer(),c+=r[u].length,i)break}return un=!1,i}function Z(e,t,n,s,r,a=0,i=0,c=0,o=0,p=null,u=!1){let f,l;u?(f=Yt,l=Vt):(f=Vt,l=Yt);const y=f.float32Array,g=f.uint32Array,T=f.uint16Array,m=l.float32Array,h=l.uint32Array,d=l.uint16Array,x=e*2,A=t*2,w=D(x,T),b=D(A,d);let B=!1;if(b&&w)u?B=r(N(t,h),k(t*2,d),N(e,g),k(e*2,T),o,i+t,c,a+e):B=r(N(e,g),k(e*2,T),N(t,h),k(t*2,d),c,a+e,o,i+t);else if(b){const M=G.getPrimitive();R(t,m,M),M.applyMatrix4(n);const P=H(e),_=X(e,g);R(P,y,pt),R(_,y,yt);const C=M.intersectsBox(pt),S=M.intersectsBox(yt);B=C&&Z(t,P,s,n,r,i,a,o,c+1,M,!u)||S&&Z(t,_,s,n,r,i,a,o,c+1,M,!u),G.releasePrimitive(M)}else{const M=H(t),P=X(t,h);R(M,m,an),R(P,m,ln);const _=p.intersectsBox(an),C=p.intersectsBox(ln);if(_&&C)B=Z(e,M,n,s,r,a,i,c,o+1,p,u)||Z(e,P,n,s,r,a,i,c,o+1,p,u);else if(_)if(w)B=Z(e,M,n,s,r,a,i,c,o+1,p,u);else{const S=G.getPrimitive();S.copy(an).applyMatrix4(n);const V=H(e),L=X(e,g);R(V,y,pt),R(L,y,yt);const U=S.intersectsBox(pt),E=S.intersectsBox(yt);B=U&&Z(M,V,s,n,r,i,a,o,c+1,S,!u)||E&&Z(M,L,s,n,r,i,a,o,c+1,S,!u),G.releasePrimitive(S)}else if(C)if(w)B=Z(e,P,n,s,r,a,i,c,o+1,p,u);else{const S=G.getPrimitive();S.copy(ln).applyMatrix4(n);const V=H(e),L=X(e,g);R(V,y,pt),R(L,y,yt);const U=S.intersectsBox(pt),E=S.intersectsBox(yt);B=U&&Z(P,V,s,n,r,i,a,o,c+1,S,!u)||E&&Z(P,L,s,n,r,i,a,o,c+1,S,!u),G.releasePrimitive(S)}}return B}const{BufferAttribute:ws,Box3:Yn,FrontSide:zn}=await v("three"),Xt=new I,$n=new Yn,As={strategy:qn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class Bn{static serialize(t,n={}){n={cloneBuffers:!0,...n};const s=t.geometry,r=t._roots,a=t._indirectBuffer,i=s.getIndex();let c;return n.cloneBuffers?c={roots:r.map(o=>o.slice()),index:i?i.array.slice():null,indirectBuffer:a?a.slice():null}:c={roots:r,index:i?i.array:null,indirectBuffer:a},c}static deserialize(t,n,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:r,roots:a,indirectBuffer:i}=t,c=new Bn(n,{...s,[tn]:!0});if(c._roots=a,c._indirectBuffer=i||null,s.setIndex){const o=n.getIndex();if(o===null){const p=new ws(t.index,1,!1);n.setIndex(p)}else o.array!==r&&(o.array.set(r),o.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(t,n={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(n=Object.assign({...As,[tn]:!1},n),n.useSharedArrayBuffer&&!hs())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,n[tn]||(he(this,n),!t.boundingBox&&n.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Yn))),this.resolveTriangleIndex=n.indirect?s=>this._indirectBuffer[s]:s=>s}refit(t=null){return(this.indirect?es:Ne)(this,t)}traverse(t,n=0){const s=this._roots[n],r=new Uint32Array(s),a=new Uint16Array(s);i(0);function i(c,o=0){const p=c*2,u=a[p+15]===Kt;if(u){const f=r[c+6],l=a[p+14];t(o,u,new Float32Array(s,c*4,6),f,l)}else{const f=c+Ct/4,l=r[c+6],y=r[c+7];t(o,u,new Float32Array(s,c*4,6),y)||(i(f,o+1),i(l,o+1))}}}raycast(t,n=zn,s=0,r=1/0){const a=this._roots,i=this.geometry,c=[],o=n.isMaterial,p=Array.isArray(n),u=i.groups,f=o?n.side:n,l=this.indirect?ss:Xe;for(let y=0,g=a.length;y<g;y++){const T=p?n[u[y].materialIndex].side:f,m=c.length;if(l(this,y,T,t,c,s,r),p){const h=u[y].materialIndex;for(let d=m,x=c.length;d<x;d++)c[d].face.materialIndex=h}}return c}raycastFirst(t,n=zn,s=0,r=1/0){const a=this._roots,i=this.geometry,c=n.isMaterial,o=Array.isArray(n);let p=null;const u=i.groups,f=c?n.side:n,l=this.indirect?rs:Ze;for(let y=0,g=a.length;y<g;y++){const T=o?n[u[y].materialIndex].side:f,m=l(this,y,T,t,s,r);m!=null&&(p==null||m.distance<p.distance)&&(p=m,o&&(m.face.materialIndex=u[y].materialIndex))}return p}intersectsGeometry(t,n){let s=!1;const r=this._roots,a=this.indirect?as:Ke;for(let i=0,c=r.length;i<c&&(s=a(this,i,t,n),!s);i++);return s}shapecast(t){const n=j.getPrimitive(),s=this.indirect?He:De;let{boundsTraverseOrder:r,intersectsBounds:a,intersectsRange:i,intersectsTriangle:c}=t;if(i&&c){const f=i;i=(l,y,g,T,m)=>f(l,y,g,T,m)?!0:s(l,y,this,c,g,T,n)}else i||(c?i=(f,l,y,g)=>s(f,l,this,c,y,g,n):i=(f,l,y)=>y);let o=!1,p=0;const u=this._roots;for(let f=0,l=u.length;f<l;f++){const y=u[f];if(o=Ve(this,f,a,i,r,p),o)break;p+=y.byteLength}return j.releasePrimitive(n),o}bvhcast(t,n,s){let{intersectsRanges:r,intersectsTriangles:a}=s;const i=j.getPrimitive(),c=this.geometry.index,o=this.geometry.attributes.position,p=this.indirect?g=>{const T=this.resolveTriangleIndex(g);z(i,T*3,c,o)}:g=>{z(i,g*3,c,o)},u=j.getPrimitive(),f=t.geometry.index,l=t.geometry.attributes.position,y=t.indirect?g=>{const T=t.resolveTriangleIndex(g);z(u,T*3,f,l)}:g=>{z(u,g*3,f,l)};if(a){const g=(T,m,h,d,x,A,w,b)=>{for(let B=h,M=h+d;B<M;B++){y(B),u.a.applyMatrix4(n),u.b.applyMatrix4(n),u.c.applyMatrix4(n),u.needsUpdate=!0;for(let P=T,_=T+m;P<_;P++)if(p(P),i.needsUpdate=!0,a(i,u,P,B,x,A,w,b))return!0}return!1};if(r){const T=r;r=function(m,h,d,x,A,w,b,B){return T(m,h,d,x,A,w,b,B)?!0:g(m,h,d,x,A,w,b,B)}}else r=g}return xs(this,t,n,r)}intersectsBox(t,n){return Xt.set(t.min,t.max,n),Xt.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Xt.intersectsBox(s),intersectsTriangle:s=>Xt.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:n=>t.intersectsBox(n),intersectsTriangle:n=>n.intersectsSphere(t)})}closestPointToGeometry(t,n,s={},r={},a=0,i=1/0){return(this.indirect?ds:ns)(this,t,n,s,r,a,i)}closestPointToPoint(t,n={},s=0,r=1/0){return Le(this,t,n,s,r)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{R(0,new Float32Array(s),$n),t.union($n)}),t}}function vn(e,t,n){return e===null?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e)}const{Ray:gs,Matrix4:Ts,Mesh:Kn,Vector3:Jn,Sphere:Bs,BatchedMesh:bs,REVISION:Es}=await v("three"),jt=new gs,In=new Jn,Dn=new Ts,Ps=Kn.prototype.raycast,Ms=bs.prototype.raycast,Nn=new Jn,$=new Kn,Zt=[];function zs(e,t){this.isBatchedMesh?Ss.call(this,e,t):_s.call(this,e,t)}function Ss(e,t){if(this.boundsTrees){const n=this.boundsTrees,s=this._drawInfo||this._instanceInfo,r=this._drawRanges||this._geometryInfo,a=this.matrixWorld;$.material=this.material,$.geometry=this.geometry;const i=$.geometry.boundsTree,c=$.geometry.drawRange;$.geometry.boundingSphere===null&&($.geometry.boundingSphere=new Bs);for(let o=0,p=s.length;o<p;o++){if(!this.getVisibleAt(o))continue;const u=s[o].geometryIndex;if($.geometry.boundsTree=n[u],this.getMatrixAt(o,$.matrixWorld).premultiply(a),!$.geometry.boundsTree){this.getBoundingBoxAt(u,$.geometry.boundingBox),this.getBoundingSphereAt(u,$.geometry.boundingSphere);const f=r[u];$.geometry.setDrawRange(f.start,f.count)}$.raycast(e,Zt);for(let f=0,l=Zt.length;f<l;f++){const y=Zt[f];y.object=this,y.batchId=o,t.push(y)}Zt.length=0}$.geometry.boundsTree=i,$.geometry.drawRange=c,$.material=null,$.geometry=null}else Ms.call(this,e,t)}function _s(e,t){if(this.geometry.boundsTree){if(this.material===void 0)return;Dn.copy(this.matrixWorld).invert(),jt.copy(e.ray).applyMatrix4(Dn),Nn.setFromMatrixScale(this.matrixWorld),In.copy(jt.direction).multiply(Nn);const n=In.length(),s=e.near/n,r=e.far/n,a=this.geometry.boundsTree;if(e.firstHitOnly===!0){const i=vn(a.raycastFirst(jt,this.material,s,r),this,e);i&&t.push(i)}else{const i=a.raycast(jt,this.material,s,r);for(let c=0,o=i.length;c<o;c++){const p=vn(i[c],this,e);p&&t.push(p)}}}else Ps.call(this,e,t)}function $s(e={}){return this.boundsTree=new Bn(this,e),this.boundsTree}function vs(){this.boundsTree=null}export{bn as CONTAINED,Ls as INTERSECTED,Vs as NOT_INTERSECTED,zs as acceleratedRaycast,$s as computeBoundsTree,vs as disposeBoundsTree};
