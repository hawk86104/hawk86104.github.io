import{B as t,V as e,bl as o,c as r}from"./three.B0XaFSnH1744863032604.js";
/**
 * @description Loop Subdivision Surface
 * @about       Smooth subdivision surface modifier for use with three.js BufferGeometry.
 * @author      Stephens Nunnally <@stevinz>
 * @license     MIT - Copyright (c) 2022 Stephens Nunnally
 * @source      https://github.com/stevinz/three-subdivide
 */
const i=new e,n=new e,s=new e,u=new e,a=new e,c=new e,f=new e,d=new e,l=new e,p=new e,m=new e,b=[new e,new e,new e],h=[new e,new e,new e],v=new o;class g{static modify(t,e=1,o={}){if(arguments.length>3&&console.warn("LoopSubdivision.modify() now uses a parameter object. See readme for more info!"),"object"!=typeof o&&(o={}),void 0===o.split&&(o.split=!0),void 0===o.uvSmooth&&(o.uvSmooth=!1),void 0===o.preserveEdges&&(o.preserveEdges=!1),void 0===o.flatOnly&&(o.flatOnly=!1),void 0===o.maxTriangles&&(o.maxTriangles=1/0),void 0===o.weight&&(o.weight=1),!isNaN(o.weight)&&isFinite(o.weight)||(o.weight=1),o.weight=Math.max(0,Math.min(1,o.weight)),!z(t))return t;let r=t.clone();if(o.split){const t=g.edgeSplit(r);r.dispose(),r=t}for(let i=0;i<e;i++){if(r.attributes.position.count/3<o.maxTriangles){let t;t=o.flatOnly?g.flat(r,o):g.smooth(r,o),r.groups.forEach((e=>{t.addGroup(4*e.start,4*e.count,e.materialIndex)})),r.dispose(),r=t}}return r}static edgeSplit(e){if(!z(e))return e;const o=null!==e.index?e.toNonIndexed():e.clone(),i=new t,a=$(o),l=o.attributes.position.count,p=o.getAttribute("position"),m=o.getAttribute("normal"),b={},h=[],g={},w=[];for(let t=0;t<l;t+=3){c.fromBufferAttribute(p,t+0),f.fromBufferAttribute(p,t+1),d.fromBufferAttribute(p,t+2),u.fromBufferAttribute(m,t);const e=A(c),o=A(f),r=A(d),i=v.set(c,f,d).getArea();if(w.push(!S(i,0)),!w[t/3]){h.push([]);continue}B(u,c,f,d);const n=A(u),s=[`${e}_${o}_${n}`,`${o}_${e}_${n}`,`${o}_${r}_${n}`,`${r}_${o}_${n}`,`${r}_${e}_${n}`,`${e}_${r}_${n}`],a=t/3;for(let t=0;t<s.length;t++)b[s[t]]||(b[s[t]]=[]),b[s[t]].push(a),g[s[t]]||(0!==t&&1!==t||(g[s[t]]=c.distanceTo(f)),2!==t&&3!==t||(g[s[t]]=f.distanceTo(d)),4!==t&&5!==t||(g[s[t]]=d.distanceTo(c)));h.push([s[0],s[2],s[4]])}a.forEach((t=>{const e=o.getAttribute(t);if(!e)return;const n=E(e,t);i.setAttribute(t,new r(n,e.itemSize))}));const y=o.morphAttributes;for(const t in y){const e=[],o=y[t];for(let i=0,n=o.length;i<n;i++){if(o[i].count!==l)continue;const n=E(o[i],t,!0);e.push(new r(n,o[i].itemSize))}i.morphAttributes[t]=e}return i.morphTargetsRelative=o.morphTargetsRelative,o.dispose(),i;function E(t,e,r=!1){const u=l*t.itemSize*4,a=new t.array.constructor(u),p="position"===e&&!r&&o.groups.length>0;let m,v,S=0,y=0,A=t.itemSize;for(let z=0;z<l;z+=3){if(!w[z/3]){y+=3;continue}c.fromBufferAttribute(t,z+0),f.fromBufferAttribute(t,z+1),d.fromBufferAttribute(t,z+2);const e=z/3,r=h[e][0],u=h[e][1],l=h[e][2],B=b[r].length,$=b[u].length,E=b[l].length,T=3*S/A/3;if(0===B+$+E-3)x(a,S,A,c,f,d),S+=3*A;else{const t=g[r],e=g[u],o=g[l];(t>e||$<=1)&&(t>o||E<=1)&&B>1?(n.copy(c).add(f).divideScalar(2),E>1?(s.copy(d).add(c).divideScalar(2),x(a,S,A,c,n,s),S+=3*A,x(a,S,A,n,d,s),S+=3*A):(x(a,S,A,c,n,d),S+=3*A),$>1?(s.copy(f).add(d).divideScalar(2),x(a,S,A,n,f,s),S+=3*A,x(a,S,A,s,d,n),S+=3*A):(x(a,S,A,f,d,n),S+=3*A)):(e>o||E<=1)&&$>1?(n.copy(f).add(d).divideScalar(2),B>1?(s.copy(c).add(f).divideScalar(2),x(a,S,A,n,s,f),S+=3*A,x(a,S,A,s,n,c),S+=3*A):(x(a,S,A,f,n,c),S+=3*A),E>1?(s.copy(d).add(c).divideScalar(2),x(a,S,A,n,d,s),S+=3*A,x(a,S,A,s,c,n),S+=3*A):(x(a,S,A,d,c,n),S+=3*A)):E>1?(n.copy(d).add(c).divideScalar(2),$>1?(s.copy(f).add(d).divideScalar(2),x(a,S,A,d,n,s),S+=3*A,x(a,S,A,n,f,s),S+=3*A):(x(a,S,A,d,n,f),S+=3*A),B>1?(s.copy(c).add(f).divideScalar(2),x(a,S,A,c,s,n),S+=3*A,x(a,S,A,s,f,n),S+=3*A):(x(a,S,A,c,f,n),S+=3*A)):(x(a,S,A,c,f,d),S+=3*A)}p&&o.groups.forEach((t=>{t.start===z-y&&(void 0!==m&&void 0!==v&&i.addGroup(m,T-m,v),m=T,v=t.materialIndex)})),y=0}const B=3*S/A,$=new t.array.constructor(B);for(let o=0;o<B;o++)$[o]=a[o];return p&&void 0!==m&&void 0!==v&&i.addGroup(m,3*S/A/3-m,v),$}}static flat(e,o={}){if(!z(e))return e;const r=null!==e.index?e.toNonIndexed():e.clone(),i=new t,n=$(r),s=r.attributes.position.count;n.forEach((t=>{const e=r.getAttribute(t);e&&i.setAttribute(t,g.flatAttribute(e,s,o))}));const u=r.morphAttributes;for(const t in u){const e=[],r=u[t];for(let t=0,i=r.length;t<i;t++)r[t].count===s&&e.push(g.flatAttribute(r[t],s,o));i.morphAttributes[t]=e}return i.morphTargetsRelative=r.morphTargetsRelative,r.dispose(),i}static flatAttribute(t,e,o={}){const i=e*t.itemSize*4,n=new t.array.constructor(i);let s=0,u=t.itemSize;for(let r=0;r<e;r+=3)c.fromBufferAttribute(t,r+0),f.fromBufferAttribute(t,r+1),d.fromBufferAttribute(t,r+2),l.copy(c).add(f).divideScalar(2),p.copy(f).add(d).divideScalar(2),m.copy(d).add(c).divideScalar(2),x(n,s,u,c,l,m),s+=3*u,x(n,s,u,f,p,l),s+=3*u,x(n,s,u,d,m,p),s+=3*u,x(n,s,u,l,p,m),s+=3*u;return new r(n,t.itemSize)}static smooth(e,o={}){if("object"!=typeof o&&(o={}),void 0===o.uvSmooth&&(o.uvSmooth=!1),void 0===o.preserveEdges&&(o.preserveEdges=!1),!z(e))return e;const n=null!==e.index?e.toNonIndexed():e.clone(),s=g.flat(n,o),u=new t,c=$(n),f=n.attributes.position.count,d=n.getAttribute("position"),v=s.getAttribute("position"),w={},S={},y={},B={};function E(t,e,o){S[t]||(S[t]={}),S[t][e]||(S[t][e]=[]),S[t][e].push(o)}function T(t,e){y[t]||(y[t]=[]),y[t].push(e)}function _(t,e){B[t]||(B[t]=new Set),B[t].add(e)}for(let t=0;t<f;t+=3){const e=A(h[0].fromBufferAttribute(d,t+0)),o=A(h[1].fromBufferAttribute(d,t+1)),r=A(h[2].fromBufferAttribute(d,t+2));E(e,o,t+1),E(e,r,t+2),E(o,e,t+0),E(o,r,t+2),E(r,e,t+0),E(r,o,t+1),l.copy(h[0]).add(h[1]).divideScalar(2),p.copy(h[1]).add(h[2]).divideScalar(2),m.copy(h[2]).add(h[0]).divideScalar(2);const i=A(l),n=A(p),s=A(m);T(i,t+2),T(n,t+0),T(s,t+1),_(e,i),_(e,s),_(o,i),_(o,n),_(r,n),_(r,s)}for(let t=0;t<s.attributes.position.count;t++){const e=A(a.fromBufferAttribute(v,t));w[e]||(w[e]=[]),w[e].push(t)}c.forEach((t=>{const e=n.getAttribute(t),o=s.getAttribute(t);if(void 0===e||void 0===o)return;const i=j(t,e,o);u.setAttribute(t,new r(i,o.itemSize))}));const G=n.morphAttributes;for(const t in G){const e=[],i=G[t];for(let n=0,s=i.length;n<s;n++){if(i[n].count!==f)continue;const s=i[n],u=g.flatAttribute(i[n],i[n].count,o),a=j(t,s,u);e.push(new r(a,u.itemSize))}u.morphAttributes[t]=e}return u.morphTargetsRelative=n.morphTargetsRelative,s.dispose(),n.dispose(),u;function j(t,e,r){const n=s.attributes.position.count*r.itemSize,u=new e.array.constructor(n);let c=0;for(let p=0;p<s.attributes.position.count;p+=3){for(let n=0;n<3;n++)if("uv"!==t||o.uvSmooth)if("normal"===t){b[n].fromBufferAttribute(v,p+n);const t=A(b[n]),e=w[t],o=Object.keys(e).length,s=.75/o,u=1-s*o;h[n].fromBufferAttribute(r,p+n),h[n].multiplyScalar(u),e.forEach((t=>{i.fromBufferAttribute(r,t),i.multiplyScalar(s),h[n].add(i)}))}else{h[n].fromBufferAttribute(r,p+n),b[n].fromBufferAttribute(v,p+n);const t=A(b[n]),s=S[t],u=y[t];if(s){if(o.preserveEdges){const e=B[t];let o=!0;for(const t of e)y[t].length%2!=0&&(o=!1);if(!o)continue}const r=Object.keys(s).length,u=1/r*(5/8-Math.pow(3/8+1/4*Math.cos(2*Math.PI/r),2)),c=(f=1/r/r,d=u,(1-(l=o.weight))*f+l*d),p=1-c*r;h[n].multiplyScalar(p);for(let t in s){const o=s[t];i.set(0,0,0);for(let t=0;t<o.length;t++)i.add(a.fromBufferAttribute(e,o[t]));i.divideScalar(o.length),i.multiplyScalar(c),h[n].add(i)}}else if(u&&2===u.length){const t=u.length,o=.125,r=1-o*t;h[n].multiplyScalar(r),u.forEach((t=>{i.fromBufferAttribute(e,t),i.multiplyScalar(o),h[n].add(i)}))}}else h[n].fromBufferAttribute(r,p+n);x(u,c,r.itemSize,h[0],h[1],h[2]),c+=3*r.itemSize}var f,d,l;return u}}}const w=Math.pow(10,2);function S(t,e,o=1e-5){return t<e+o&&t>e-o}function y(t,e=w){let o=(r=t*e)+(r>0?.5:-.5)|0;var r;return 0==o&&(o=0),`${o}`}function A(t,e=w){return`${y(t.x,e)},${y(t.y,e)},${y(t.z,e)}`}function B(t,e,o,r){a.subVectors(e,o),t.subVectors(o,r),t.cross(a).normalize()}function $(t){const e=Object.keys(t.attributes);return Array.from(new Set(["position","normal","uv"].concat(e)))}function x(t,e,o,r,i,n){o>=1&&(t[e+0+0*o]=r.x,t[e+0+1*o]=i.x,t[e+0+2*o]=n.x),o>=2&&(t[e+1+0*o]=r.y,t[e+1+1*o]=i.y,t[e+1+2*o]=n.y),o>=3&&(t[e+2+0*o]=r.z,t[e+2+1*o]=i.z,t[e+2+2*o]=n.z),o>=4&&(t[e+3+0*o]=r.w,t[e+3+1*o]=i.w,t[e+3+2*o]=n.w)}function z(t){return void 0===t?(console.warn("LoopSubdivision: Geometry provided is undefined"),!1):t.isBufferGeometry?void 0===t.attributes.position?(console.warn("LoopSubdivision: Geometry provided missing required 'position' attribute"),!1):(void 0===t.attributes.normal&&t.computeVertexNormals(),!0):(console.warn("LoopSubdivision: Geometry provided is not 'BufferGeometry' type"),!1)}export{g as L};
