import{m as n,e,a as t,o as r,f as o}from"./@tresjs.KzbsBNvc1742896998262.js";import{P as i}from"./tweakpane.ivGeiIdz1742896998262.js";import{_ as c,a_ as a,l,O as s,m as u,u as f,X as p}from"./three.0CcRceKb1742896998262.js";import{d as v,a3 as g,b as d,o as x,f as m,u as h,g as y,j as w,al as b,r as C,N as R,aj as I,ak as _}from"./@vue.L-brCdZe1742896998262.js";import"./postprocessing.JNDZZkh81742896998262.js";import"./@vueuse.AtktgvWs1742896998262.js";var z="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";function M(n,e){const t=L();return M=function(n,e){return t[n-=398]},M(n,e)}const D=M;!function(n,e){const t=M,r=L();for(;;)try{if(977380===-parseInt(t(438))/1+parseInt(t(409))/2*(-parseInt(t(430))/3)+parseInt(t(424))/4+parseInt(t(399))/5+-parseInt(t(406))/6+-parseInt(t(441))/7*(-parseInt(t(411))/8)+parseInt(t(436))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[M(410)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){T(this,(function(){const n=M,e=new RegExp(n(447)),t=new RegExp(n(405),"i"),r=S(n(439));e[n(419)](r+n(434))&&t.test(r+n(442))?S():r("0")}))()}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[M(410)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function L(){const n=["causticTex","value","table","action","trace",'{}.constructor("return this")( )',"test","warn","info","waterTexture","constructor","2568016wSFIoS","BufferGeometry","causticsTexture","position","error","water","1167bRrzOG","gger","Mesh","console","chain","RawShaderMaterial","1975455jVVczf","call","88761WKNADA","init","toString","87521yQOVsj","input","return (function() ","bind","setIndex","render","function *\\( *\\)","debu","FrontSide","2661480EHrUrl","BufferAttribute","counter","light","exception","prototype","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","8866752JSzKQv","stateObject","pool","3022rmnTXm","apply","1112SdBGAZ","string"];return(L=function(){return n})()}A(void 0,(function(){const n=M,e=function(){const n=M;let e;try{e=Function(n(443)+n(418)+");")()}catch(t){e=window}return e}(),t=e[n(433)]=e[n(433)]||{},r=["log",n(420),n(421),n(428),n(403),n(415),n(417)];for(let o=0;o<r.length;o++){const e=A[n(423)][n(404)][n(444)](A),i=r[o],c=t[i]||e;e.__proto__=A[n(444)](A),e[n(440)]=c[n(440)][n(444)](c),t[i]=e}}))();const O=v({__name:D(408),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=D,o=t,i=new(c[r(425)]),a=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),l=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i.setAttribute(r(427),new(c[r(400)])(a,3)),i[r(445)](new(c[r(400)])(l,1));const s=new(c[r(435)])({uniforms:{light:{value:o[r(402)]},tiles:{value:o.tiles},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(398)]}),u=new(c[r(432)])(i,s),{renderer:f,camera:p}=n(),{onAfterLoop:v}=e();return v((()=>{const n=r;((n,e)=>{const t=r;s.uniforms[t(429)][t(414)]=n,s.uniforms[t(413)].value=e,f.value[t(446)](u,p[t(414)])})(o[n(422)],o[n(426)])})),(n,e)=>null}});function S(n){function e(n){const t=M;if(typeof n===t(412))return function(n){}[t(423)]("while (true) {}")[t(410)](t(401));1!==(""+n/n).length||n%20==0?function(){return!0}.constructor(t(448)+t(431))[t(437)](t(416)):function(){return!1}[t(423)](t(448)+t(431))[t(410)](t(407)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const E=V;!function(n,e){const t=V,r=P();for(;;)try{if(548318===-parseInt(t(229))/1+-parseInt(t(267))/2+parseInt(t(263))/3*(-parseInt(t(270))/4)+-parseInt(t(207))/5+parseInt(t(228))/6*(-parseInt(t(244))/7)+parseInt(t(227))/8+parseInt(t(231))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){F(this,(function(){const n=V,e=new RegExp(n(217)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=k("init");e[n(220)](r+n(241))&&t[n(220)](r+n(256))?k():r("0")}))()}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[V(240)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();j(void 0,(function(){const n=V,e=function(){const n=V;let e;try{e=Function(n(221)+n(213)+");")()}catch(t){e=window}return e}(),t=e[n(268)]=e[n(268)]||{},r=[n(264),n(222),n(247),n(251),"exception",n(246),"trace"];for(let o=0;o<r[n(261)];o++){const e=j.constructor[n(224)][n(245)](j),i=r[o],c=t[i]||e;e.__proto__=j[n(245)](j),e[n(249)]=c[n(249)][n(245)](c),t[i]=e}}))();const W=v({__name:E(218),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=E;let i,s;const u=r,f=u[o(235)],p=(new(c[o(252)]))[o(219)](o(230)+o(242))[o(258)](["pos-x.jpg",o(212),"pos-y.jpg",o(248),o(255),o(243)]),v=([i,s]=g((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,s(),i),y=new a({uniforms:{light:{value:u[o(259)]},tiles:{value:v},sky:{value:p},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),w=new l(f,y),b=d(null),C=new(c[o(269)])(o(211)),{renderer:R,camera:I}=n(),{onLoop:_}=e();return _((()=>{const n=o;R[n(216)][n(239)](null),R[n(216)][n(215)](C,1),R.value[n(233)](),y[n(238)][n(218)][n(216)]=u.waterTexture,y.uniforms[n(260)].value=u[n(210)],y.side=c[n(226)],y[n(238)][n(209)][n(216)]=!0,R[n(216)][n(225)](w,I[n(216)]),y[n(232)]=c[n(223)],y[n(238)][n(209)].value=!1,R[n(216)].render(w,I[n(216)])})),(n,e)=>{const t=o;return x(),m(O,{tiles:h(v),light:n[t(259)],waterTexture:n.waterTexture,causticsTexture:n.causticsTexture,ref_key:t(208),ref:b},null,8,[t(257),t(259),t(265),t(210)])}}});function P(){const n=["counter","uniforms","setRenderTarget","apply","chain","/images/skyBox/6jpg/","neg-z.jpg","5739167yiLuSQ","bind","table","info","neg-y.jpg","toString","gger","error","CubeTextureLoader","string","resource.cos","pos-z.jpg","input","tiles","load","light","causticTex","length","debu","18LQUyrR","log","waterTexture","constructor","301518TkJiir","console","Color","153812qHUCqm","1351810DaZojV","pooRef","underwater","causticsTexture","white","neg-x.jpg",'{}.constructor("return this")( )',"call","setClearColor","value","function *\\( *\\)","water","setPath","test","return (function() ","warn","BackSide","prototype","render","FrontSide","6351160AqtYla","6xmbCQT","925704pYqwdB","https://opensource.cdn.icegl.cn","19366623JpWEkn","side","clear","stateObject","geometry","action"];return(P=function(){return n})()}function V(n,e){const t=P();return V=function(n,e){return t[n-=207]},V(n,e)}function k(n){function e(n){const t=V;if(typeof n===t(253))return function(n){}[t(266)]("while (true) {}")[t(240)](t(237));1!==(""+n/n)[t(261)]||n%20==0?function(){return!0}[t(266)](t(262)+t(250))[t(214)](t(236)):function(){return!1}.constructor(t(262)+t(250)).apply(t(234)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const H=N;!function(n,e){const t=N,r=G();for(;;)try{if(790649===-parseInt(t(479))/1+parseInt(t(447))/2+parseInt(t(464))/3*(parseInt(t(458))/4)+-parseInt(t(486))/5+parseInt(t(471))/6*(parseInt(t(493))/7)+-parseInt(t(469))/8*(parseInt(t(465))/9)+parseInt(t(484))/10*(parseInt(t(474))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[N(481)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Z(this,(function(){const n=N,e=new RegExp(n(472)),t=new RegExp(n(476),"i"),r=q(n(462));e[n(490)](r+n(470))&&t[n(490)](r+n(473))?q():r("0")}))()}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[N(481)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function G(){const n=["while (true) {}","action","stateObject","log","uniforms","2725204yPGFRI","bind","clear","string","light","black","setRenderTarget","waterTexture","console","caustics","counter","283208MdxqiQ","water","texture","call","init","material","12QFtVOv","63DtPCEC","render","error","__proto__","846416slOSOc","chain","6XbfkDx","function *\\( *\\)","input","83380BWjnVK","constructor","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","return (function() ","length","904635XZEEBj","Color","apply","value","warn","340yqbkiG","geometry","1723780ndaLSD","causticsTexture",'{}.constructor("return this")( )',"gger","test","ShaderMaterial","exception","6139868iLvMoB","table","trace","debu"];return(G=function(){return n})()}function N(n,e){const t=G();return N=function(n,e){return t[n-=444]},N(n,e)}B(void 0,(function(){const n=N,e=function(){const n=N;let e;try{e=Function(n(477)+n(488)+");")()}catch(t){e=window}return e}(),t=e[n(455)]=e.console||{},r=[n(445),n(483),"info",n(467),n(492),n(494),n(495)];for(let o=0;o<r[n(478)];o++){const e=B.constructor.prototype[n(448)](B),i=r[o],c=t[i]||e;e[n(468)]=B[n(448)](B),e.toString=c.toString[n(448)](c),t[i]=e}}))();const Q=v({__name:H(456),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=H,o=t,i=new s(0,1,1,0,0,2e3),a=new u(2,2,200,200),p=new f(1024,1024),v=new(c[r(491)])({uniforms:{light:{value:o.light},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),g=new l(a,v),d=new(c[r(480)])(r(452)),{renderer:C}=n(),{onBeforeLoop:R}=e();return R((()=>{const n=r;g[n(463)][n(446)][n(459)][n(482)]=o.waterTexture,C[n(482)][n(453)](p),C.value.setClearColor(d,0),C[n(482)][n(449)](),C[n(482)][n(466)](g,i)})),(n,e)=>{const t=r;return x(),m(b,null,{default:y((()=>[w(W,{waterTexture:n[t(454)],causticsTexture:h(p)[t(460)],light:n[t(451)],geometry:h(a)},null,8,["waterTexture",t(487),t(451),t(485)])])),_:1})}}});function q(n){function e(n){const t=N;if(typeof n===t(450))return function(n){}[t(475)](t(497))[t(481)](t(457));1!==(""+n/n)[t(478)]||n%20==0?function(){return!0}[t(475)](t(496)+t(489))[t(461)](t(498)):function(){return!1}.constructor(t(496)+t(489))[t(481)](t(444)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const $=U;!function(n,e){const t=U,r=Y();for(;;)try{if(493961===parseInt(t(166))/1*(-parseInt(t(147))/2)+-parseInt(t(192))/3*(-parseInt(t(150))/4)+-parseInt(t(170))/5+-parseInt(t(158))/6+-parseInt(t(157))/7+parseInt(t(193))/8*(parseInt(t(182))/9)+-parseInt(t(155))/10*(-parseInt(t(172))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const X=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[U(171)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){X(this,(function(){const n=U,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(142),"i"),r=nn("init");e[n(177)](r+"chain")&&t.test(r+n(137))?nn():r("0")}))()}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function U(n,e){const t=Y();return U=function(n,e){return t[n-=135]},U(n,e)}function Y(){const n=["4129905gXvtSJ","apply","2248653FjyCrh","value","uniforms","PlaneGeometry","trace","test",'{}.constructor("return this")( )',"prototype","WebGLRenderTarget","top","54wLnfmA","Mesh","debu","material","RawShaderMaterial","domElement","radius","getBoundingClientRect","point","log","7149zQWdZp","504432nDyPEp","removeEventListener","waterSimulation","FloatType","texture","setRenderTarget","constructor","while (true) {}","input","attributes","waterTexture","autoClear","left","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","light","setY","addEventListener","__proto__","1796egMHKM","width","Vector2","776mEIeCZ","error","lightFrontGeometry","setZ","clientX","160HCllzp","needsUpdate","6562122ftgOEB","5245728rqRhFk","length","mousemove","height","return (function() ","toString","bind","getY","1091AwlxEi","warn","exception","setFromCamera"];return(Y=function(){return n})()}K(void 0,(function(){const n=U,e=function(){const n=U;let e;try{e=Function(n(162)+n(178)+");")()}catch(t){e=window}return e}(),t=e.console=e.console||{},r=[n(191),n(167),"info",n(151),n(168),"table",n(176)];for(let o=0;o<r[n(159)];o++){const e=K[n(135)][n(179)][n(164)](K),i=r[o],c=t[i]||e;e[n(146)]=K.bind(K),e[n(163)]=c[n(163)][n(164)](c),t[i]=e}}))();const J=v({__name:$(195),props:{light:{}},setup(t,{expose:r}){const o=$,i=new s(0,1,1,0,0,2e3),a=new(c[o(175)])(2,2),u=new(c[o(180)])(256,256,{type:p}),f=new(c[o(180)])(256,256,{type:c[o(196)]}),v=new(c[o(186)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),g=new(c[o(186)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),d=new(c[o(186)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),y=new l(a,v),w=new(c[o(183)])(a,g),b=new(c[o(183)])(a,d);let C=u;const R=(n,e)=>{const t=o,r=C,c=C===u?f:u;e[t(185)][t(174)][t(197)][t(173)]=r[t(197)],n[t(198)](c),n.render(e,i),C=c},{renderer:I,camera:_,raycaster:M}=n();I[o(173)][o(140)]=!1;const{onBeforeLoop:D}=e();D((()=>{const n=o;var e,t;t=I[n(173)],R(t,b),e=I[n(173)],R(e,w)}));const T=(n,e,t,r)=>{const i=o;y[i(185)].uniforms.center[i(173)]=[n,e],y[i(185)].uniforms[i(188)][i(173)]=t,y.material.uniforms.strength[i(173)]=r,R(I[i(173)],y)},A=new(c[o(149)]),L=new(c[o(175)])(2,2),O=L[o(138)].position;for(let n=0;n<O.count;n++){const e=-O[o(165)](n);O[o(144)](n,0),O[o(153)](n,e)}O[o(156)]=!0;const S=new(c[o(183)])(L),E={handleEvent:n=>{const e=o,t=I[e(173)].domElement[e(189)](),r=t[e(148)],i=t[e(161)];A.x=2*(n[e(154)]-t[e(141)])/r-1,A.y=2*-(n.clientY-t[e(181)])/i+1,M.value[e(169)](A,_.value);const c=M[e(173)].intersectObject(S);for(let o of c)T(o.point.x,o[e(190)].z,.03,.04)}};return r({addDrop:T,mouseEvent:n=>{const e=o;n?I[e(173)][e(187)][e(145)](e(160),E):I[e(173)][e(187)][e(194)]("mousemove",E)}}),(n,e)=>{const t=o;return x(),m(Q,{lightFrontGeometry:h(a),waterTexture:h(C).texture,light:n[t(143)]},null,8,[t(152),t(139),t(143)])}}});function nn(n){function e(n){const t=U;if("string"==typeof n)return function(n){}.constructor(t(136))[t(171)]("counter");1!==(""+n/n)[t(159)]||n%20==0?function(){return!0}[t(135)](t(184)+"gger").call("action"):function(){return!1}[t(135)]("debugger")[t(171)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=on,r=rn();for(;;)try{if(404802===parseInt(t(128))/1+-parseInt(t(145))/2*(parseInt(t(123))/3)+parseInt(t(135))/4+-parseInt(t(132))/5*(-parseInt(t(129))/6)+parseInt(t(131))/7+parseInt(t(151))/8+parseInt(t(150))/9*(-parseInt(t(133))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){en(this,(function(){const n=on,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(140),"i"),r=an("init");e[n(124)](r+"chain")&&t[n(124)](r+n(126))?an():r("0")}))()}();const tn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(138)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function rn(){const n=["click","trace","while (true) {}","446007meCvzy","test",'{}.constructor("return this")( )',"input","counter","492792OuBmzS","353262dSrkdZ","string","2064160KavhsC","25mQCPAV","21020CuRwGz","call","2682476nCMTGj","mouseEvent","random","apply","鼠标波纹","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","constructor","点击按钮","console","value","10LXjmQT","prototype","addBinding","bind","toString","3888VkmEQO","2428280eFxqmP","waterSimulationRef","length","change","addDrop","TresPerspectiveCamera","随机增加波纹","manual","stateObject","debu","info","log","table","action","warn","error","gger","exception"];return(rn=function(){return n})()}function on(n,e){const t=rn();return on=function(n,e){return t[n-=112]},on(n,e)}tn(void 0,(function(){const n=on,e=function(){const n=on;let e;try{e=Function("return (function() "+n(125)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(143)]||{},r=[n(113),n(116),n(112),n(117),n(119),n(114),n(121)];for(let o=0;o<r[n(153)];o++){const e=tn[n(141)][n(146)][n(148)](tn),i=r[o],c=t[i]||e;e.__proto__=tn[n(148)](tn),e[n(149)]=c.toString.bind(c),t[i]=e}}))();const cn=v({__name:"realWater",setup(n){const e=on,t=C({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(158)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=d(null),l=new i;l.addButton({label:e(142),title:e(157)}).on(e(120),(()=>{const n=e;for(var t=0;t<10;t++)a.value[n(155)](2*Math[n(137)]()-1,2*Math.random()-1,.03,1&t?.02:-.02)}));const s=d(!1);return l[e(147)](s,e(144),{label:e(139)}).on(e(154),(n=>{const t=e;a[t(144)][t(136)](n[t(144)])})),(n,i)=>{const l=e;return x(),m(h(o),I(_(t)),{default:y((()=>[i[0]||(i[0]=R(l(156),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),w(h(r)),w(J,{light:c,ref_key:l(152),ref:a},null,512)])),_:1},16)}}});function an(n){function e(n){const t=on;if(typeof n===t(130))return function(n){}[t(141)](t(122))[t(138)](t(127));1!==(""+n/n).length||n%20==0?function(){return!0}[t(141)](t(160)+t(118))[t(134)](t(115)):function(){return!1}[t(141)](t(160)+t(118))[t(138)](t(159)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{cn as default};
