import{importShared as Oe}from"./3d-tiles-renderer.DZNovkLO1767148983502.js";import{ol as Zs,Kk as $s}from"./index.DTe2qqjO1767148983502.js";const f=await Oe("three"),{Ray:en,Plane:tn,MathUtils:sn,EventDispatcher:nn,Vector3:Ie,MOUSE:Qe,TOUCH:Ve,Quaternion:ss,Spherical:ns,Vector2:ve}=await Oe("three");class Ue{static idGen=0;constructor(e,s){let t,n;this.promise=new Promise((l,c)=>{t=l,n=c});const o=t.bind(this),i=n.bind(this),r=(...l)=>{o(...l)},a=l=>{i(l)};e(r.bind(this),a.bind(this)),this.abortHandler=s,this.id=Ue.idGen++}then(e){return new Ue((s,t)=>{this.promise=this.promise.then((...n)=>{const o=e(...n);o instanceof Promise||o instanceof Ue?o.then((...i)=>{s(...i)}):s(o)}).catch(n=>{t(n)})},this.abortHandler)}catch(e){return new Ue(s=>{this.promise=this.promise.then((...t)=>{s(...t)}).catch(e)},this.abortHandler)}abort(e){this.abortHandler&&this.abortHandler(e)}}class Hs extends Error{constructor(e){super(e)}}(function(){const A=new Float32Array(1),e=new Int32Array(A.buffer);return function(s){A[0]=s;const t=e[0];let n=t>>16&32768,o=t>>12&2047;const i=t>>23&255;return i<103?n:i>142?(n|=31744,n|=(i==255?0:1)&&t&8388607,n):i<113?(o|=2048,n|=(o>>114-i)+(o>>113-i&1),n):(n|=i-112<<10|o>>1,n+=o&1,n)}})();const It=function(){const A=new Float32Array(1),e=new Int32Array(A.buffer);return function(s){return A[0]=s,e[0]}}(),on=function(A,e){return A[e]+(A[e+1]<<8)+(A[e+2]<<16)+(A[e+3]<<24)},yt=function(A,e,s=!0,t){const n=new AbortController,o=n.signal;let i=!1;const r=c=>{n.abort(c),i=!0};let a=!1;const l=(c,d,u,h)=>{e&&!a&&(e(c,d,u,h),c===100&&(a=!0))};return new Ue((c,d)=>{const u={signal:o};t&&(u.headers=t),fetch(A,u).then(async h=>{if(!h.ok){const T=await h.text();d(new Error(`Fetch failed: ${h.status} ${h.statusText} ${T}`));return}const m=h.body.getReader();let p=0,g=h.headers.get("Content-Length"),C=g?parseInt(g):void 0;const S=[];for(;!i;)try{const{value:T,done:w}=await m.read();if(w){if(l(100,"100%",T,C),s){const y=new Blob(S).arrayBuffer();c(y)}else c();break}p+=T.length;let x,E;C!==void 0&&(x=p/C*100,E=`${x.toFixed(2)}%`),s&&S.push(T),l(x,E,T,C)}catch(T){d(T);return}}).catch(h=>{d(new Hs(h))})},r)},ne=function(A,e,s){return Math.max(Math.min(A,s),e)},Ne=function(){return performance.now()/1e3},We=A=>{if(A.geometry&&(A.geometry.dispose(),A.geometry=null),A.material&&(A.material.dispose(),A.material=null),A.children)for(let e of A.children)We(e)},we=(A,e)=>new Promise(s=>{window.setTimeout(()=>{s(A?A():void 0)},e?1:50)}),je=(A=0)=>{let e=0;if(A===1)e=9;else if(A===2)e=24;else if(A===3)e=45;else if(A>3)throw new Error("getSphericalHarmonicsComponentCountForDegree() -> Invalid spherical harmonics degree");return e},kt=()=>{let A,e;return{promise:new Promise((t,n)=>{A=t,e=n}),resolve:A,reject:e}},Bt=A=>{let e,s;return A||(A=()=>{}),{promise:new Ue((n,o)=>{e=n,s=o},A),resolve:e,reject:s}};class rn{constructor(e,s,t){this.major=e,this.minor=s,this.patch=t}toString(){return`${this.major}_${this.minor}_${this.patch}`}}function Lt(){const A=navigator.userAgent;return A.indexOf("iPhone")>0||A.indexOf("iPad")>0}function Us(){if(Lt()){const A=navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/);return new rn(parseInt(A[1]||0,10),parseInt(A[2]||0,10),parseInt(A[3]||0,10))}else return null}const an=14;class P{static OFFSET={X:0,Y:1,Z:2,SCALE0:3,SCALE1:4,SCALE2:5,ROTATION0:6,ROTATION1:7,ROTATION2:8,ROTATION3:9,FDC0:10,FDC1:11,FDC2:12,OPACITY:13,FRC0:14,FRC1:15,FRC2:16,FRC3:17,FRC4:18,FRC5:19,FRC6:20,FRC7:21,FRC8:22,FRC9:23,FRC10:24,FRC11:25,FRC12:26,FRC13:27,FRC14:28,FRC15:29,FRC16:30,FRC17:31,FRC18:32,FRC19:33,FRC20:34,FRC21:35,FRC22:36,FRC23:37};constructor(e=0){this.sphericalHarmonicsDegree=e,this.sphericalHarmonicsCount=je(this.sphericalHarmonicsDegree),this.componentCount=this.sphericalHarmonicsCount+an,this.defaultSphericalHarmonics=new Array(this.sphericalHarmonicsCount).fill(0),this.splats=[],this.splatCount=0}static createSplat(e=0){const s=[0,0,0,1,1,1,1,0,0,0,0,0,0,0];let t=je(e);for(let n=0;n<t;n++)s.push(0);return s}addSplat(e){this.splats.push(e),this.splatCount++}getSplat(e){return this.splats[e]}addDefaultSplat(){const e=P.createSplat(this.sphericalHarmonicsDegree);return this.addSplat(e),e}addSplatFromComonents(e,s,t,n,o,i,r,a,l,c,d,u,h,m,...p){const g=[e,s,t,n,o,i,r,a,l,c,d,u,h,m,...this.defaultSphericalHarmonics];for(let C=0;C<p.length&&C<this.sphericalHarmonicsCount;C++)g[C]=p[C];return this.addSplat(g),g}addSplatFromArray(e,s){const t=e.splats[s],n=P.createSplat(this.sphericalHarmonicsDegree);for(let o=0;o<this.componentCount&&o<t.length;o++)n[o]=t[o];this.addSplat(n)}}class j{static DefaultSplatSortDistanceMapPrecision=16;static MemoryPageSize=65536;static BytesPerFloat=4;static BytesPerInt=4;static MaxScenes=32;static ProgressiveLoadSectionSize=262144;static ProgressiveLoadSectionDelayDuration=15;static SphericalHarmonics8BitCompressionRange=3}const ln=j.SphericalHarmonics8BitCompressionRange,He=ln/2,fe=f.DataUtils.toHalfFloat.bind(f.DataUtils),Ht=f.DataUtils.fromHalfFloat.bind(f.DataUtils),se=(A,e,s=!1,t,n)=>{if(e===0)return A;if(e===1||e===2&&!s)return f.DataUtils.fromHalfFloat(A);if(e===2)return Ut(A,t,n)},et=(A,e,s)=>{A=ne(A,e,s);const t=s-e;return ne(Math.floor((A-e)/t*255),0,255)},Ut=(A,e,s)=>{const t=s-e;return A/255*t+e},zs=(A,e,s)=>et(Ht(A,e,s)),cn=(A,e,s)=>fe(Ut(A,e,s)),W=(A,e,s,t=!1)=>s===0?A.getFloat32(e*4,!0):s===1||s===2&&!t?A.getUint16(e*2,!0):A.getUint8(e,!0),dn=function(){const A=e=>e;return function(e,s,t,n=!1){if(s===t)return e;let o=A;return s===2&&n?t===1?o=cn:t==0&&(o=Ut):s===2||s===1?t===0?o=Ht:t==2&&(n?o=zs:o=A):s===0&&(t===1?o=fe:t==2&&(n?o=et:o=fe)),o(e)}}(),Ge=(A,e,s,t,n=0)=>{const o=new Uint8Array(A,e),i=new Uint8Array(s,t);for(let r=0;r<n;r++)i[r]=o[r]};class I{static CurrentMajorVersion=0;static CurrentMinorVersion=1;static CenterComponentCount=3;static ScaleComponentCount=3;static RotationComponentCount=4;static ColorComponentCount=4;static CovarianceComponentCount=6;static SplatScaleOffsetFloat=3;static SplatRotationOffsetFloat=6;static CompressionLevels={0:{BytesPerCenter:12,BytesPerScale:12,BytesPerRotation:16,BytesPerColor:4,ScaleOffsetBytes:12,RotationffsetBytes:24,ColorOffsetBytes:40,SphericalHarmonicsOffsetBytes:44,ScaleRange:1,BytesPerSphericalHarmonicsComponent:4,SphericalHarmonicsOffsetFloat:11,SphericalHarmonicsDegrees:{0:{BytesPerSplat:44},1:{BytesPerSplat:80},2:{BytesPerSplat:140}}},1:{BytesPerCenter:6,BytesPerScale:6,BytesPerRotation:8,BytesPerColor:4,ScaleOffsetBytes:6,RotationffsetBytes:12,ColorOffsetBytes:20,SphericalHarmonicsOffsetBytes:24,ScaleRange:32767,BytesPerSphericalHarmonicsComponent:2,SphericalHarmonicsOffsetFloat:12,SphericalHarmonicsDegrees:{0:{BytesPerSplat:24},1:{BytesPerSplat:42},2:{BytesPerSplat:72}}},2:{BytesPerCenter:6,BytesPerScale:6,BytesPerRotation:8,BytesPerColor:4,ScaleOffsetBytes:6,RotationffsetBytes:12,ColorOffsetBytes:20,SphericalHarmonicsOffsetBytes:24,ScaleRange:32767,BytesPerSphericalHarmonicsComponent:1,SphericalHarmonicsOffsetFloat:12,SphericalHarmonicsDegrees:{0:{BytesPerSplat:24},1:{BytesPerSplat:33},2:{BytesPerSplat:48}}}};static CovarianceSizeFloats=6;static HeaderSizeBytes=4096;static SectionHeaderSizeBytes=1024;static BucketStorageSizeBytes=12;static BucketStorageSizeFloats=3;static BucketBlockSize=5;static BucketSize=256;constructor(e,s=!0){this.constructFromBuffer(e,s)}getSplatCount(){return this.splatCount}getMaxSplatCount(){return this.maxSplatCount}getMinSphericalHarmonicsDegree(){let e=0;for(let s=0;s<this.sections.length;s++){const t=this.sections[s];(s===0||t.sphericalHarmonicsDegree<e)&&(e=t.sphericalHarmonicsDegree)}return e}getBucketIndex(e,s){let t;const n=e.fullBucketCount*e.bucketSize;if(s<n)t=Math.floor(s/e.bucketSize);else{let o=n;t=e.fullBucketCount;let i=0;for(;o<e.splatCount;){let r=e.partiallyFilledBucketLengths[i];if(s>=o&&s<o+r)break;o+=r,t++,i++}}return t}getSplatCenter(e,s,t){const n=this.globalSplatIndexToSectionMap[e],o=this.sections[n],i=e-o.splatCountOffset,r=o.bytesPerSplat*i,a=new DataView(this.bufferData,o.dataBase+r),l=W(a,0,this.compressionLevel),c=W(a,1,this.compressionLevel),d=W(a,2,this.compressionLevel);if(this.compressionLevel>=1){const h=this.getBucketIndex(o,i)*I.BucketStorageSizeFloats,m=o.compressionScaleFactor,p=o.compressionScaleRange;s.x=(l-p)*m+o.bucketArray[h],s.y=(c-p)*m+o.bucketArray[h+1],s.z=(d-p)*m+o.bucketArray[h+2]}else s.x=l,s.y=c,s.z=d;t&&s.applyMatrix4(t)}getSplatScaleAndRotation=function(){const e=new f.Matrix4,s=new f.Matrix4,t=new f.Matrix4,n=new f.Vector3,o=new f.Vector3,i=new f.Quaternion;return function(r,a,l,c,d){const u=this.globalSplatIndexToSectionMap[r],h=this.sections[u],m=r-h.splatCountOffset,p=h.bytesPerSplat*m+I.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,g=new DataView(this.bufferData,h.dataBase+p);o.set(se(W(g,0,this.compressionLevel),this.compressionLevel),se(W(g,1,this.compressionLevel),this.compressionLevel),se(W(g,2,this.compressionLevel),this.compressionLevel)),d&&(d.x!==void 0&&(o.x=d.x),d.y!==void 0&&(o.y=d.y),d.z!==void 0&&(o.z=d.z)),i.set(se(W(g,4,this.compressionLevel),this.compressionLevel),se(W(g,5,this.compressionLevel),this.compressionLevel),se(W(g,6,this.compressionLevel),this.compressionLevel),se(W(g,3,this.compressionLevel),this.compressionLevel)),c?(e.makeScale(o.x,o.y,o.z),s.makeRotationFromQuaternion(i),t.copy(e).multiply(s).multiply(c),t.decompose(n,l,a)):(a.copy(o),l.copy(i))}}();getSplatColor(e,s){const t=this.globalSplatIndexToSectionMap[e],n=this.sections[t],o=e-n.splatCountOffset,i=n.bytesPerSplat*o+I.CompressionLevels[this.compressionLevel].ColorOffsetBytes,r=new Uint8Array(this.bufferData,n.dataBase+i,4);s.set(r[0],r[1],r[2],r[3])}fillSplatCenterArray(e,s,t,n,o){const i=this.splatCount;t=t||0,n=n||i-1,o===void 0&&(o=t);const r=new f.Vector3;for(let a=t;a<=n;a++){const l=this.globalSplatIndexToSectionMap[a],c=this.sections[l],d=a-c.splatCountOffset,u=(a-t+o)*I.CenterComponentCount,h=c.bytesPerSplat*d,m=new DataView(this.bufferData,c.dataBase+h),p=W(m,0,this.compressionLevel),g=W(m,1,this.compressionLevel),C=W(m,2,this.compressionLevel);if(this.compressionLevel>=1){const T=this.getBucketIndex(c,d)*I.BucketStorageSizeFloats,w=c.compressionScaleFactor,x=c.compressionScaleRange;r.x=(p-x)*w+c.bucketArray[T],r.y=(g-x)*w+c.bucketArray[T+1],r.z=(C-x)*w+c.bucketArray[T+2]}else r.x=p,r.y=g,r.z=C;s&&r.applyMatrix4(s),e[u]=r.x,e[u+1]=r.y,e[u+2]=r.z}}fillSplatScaleRotationArray=function(){const e=new f.Matrix4,s=new f.Matrix4,t=new f.Matrix4,n=new f.Vector3,o=new f.Quaternion,i=new f.Vector3,r=a=>{const l=a.w<0?-1:1;a.x*=l,a.y*=l,a.z*=l,a.w*=l};return function(a,l,c,d,u,h,m,p){const g=this.splatCount;d=d||0,u=u||g-1,h===void 0&&(h=d);const C=(S,T)=>dn(S,T,m);for(let S=d;S<=u;S++){const T=this.globalSplatIndexToSectionMap[S],w=this.sections[T],x=S-w.splatCountOffset,E=w.bytesPerSplat*x+I.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,y=(S-d+h)*I.ScaleComponentCount,v=(S-d+h)*I.RotationComponentCount,D=new DataView(this.bufferData,w.dataBase+E),b=p&&p.x!==void 0?p.x:W(D,0,this.compressionLevel),F=p&&p.y!==void 0?p.y:W(D,1,this.compressionLevel),R=p&&p.z!==void 0?p.z:W(D,2,this.compressionLevel),k=W(D,3,this.compressionLevel),M=W(D,4,this.compressionLevel),O=W(D,5,this.compressionLevel),L=W(D,6,this.compressionLevel);n.set(se(b,this.compressionLevel),se(F,this.compressionLevel),se(R,this.compressionLevel)),o.set(se(M,this.compressionLevel),se(O,this.compressionLevel),se(L,this.compressionLevel),se(k,this.compressionLevel)).normalize(),c&&(i.set(0,0,0),e.makeScale(n.x,n.y,n.z),s.makeRotationFromQuaternion(o),t.identity().premultiply(e).premultiply(s),t.premultiply(c),t.decompose(i,o,n),o.normalize()),r(o),a&&(a[y]=C(n.x,0),a[y+1]=C(n.y,0),a[y+2]=C(n.z,0)),l&&(l[v]=C(o.x,0),l[v+1]=C(o.y,0),l[v+2]=C(o.z,0),l[v+3]=C(o.w,0))}}}();static computeCovariance=function(){const e=new f.Matrix4,s=new f.Matrix3,t=new f.Matrix3,n=new f.Matrix3,o=new f.Matrix3,i=new f.Matrix3,r=new f.Matrix3;return function(a,l,c,d,u=0,h){e.makeScale(a.x,a.y,a.z),s.setFromMatrix4(e),e.makeRotationFromQuaternion(l),t.setFromMatrix4(e),n.copy(t).multiply(s),o.copy(n).transpose().premultiply(n),c&&(i.setFromMatrix4(c),r.copy(i).transpose(),o.multiply(r),o.premultiply(i)),h>=1?(d[u]=fe(o.elements[0]),d[u+1]=fe(o.elements[3]),d[u+2]=fe(o.elements[6]),d[u+3]=fe(o.elements[4]),d[u+4]=fe(o.elements[7]),d[u+5]=fe(o.elements[8])):(d[u]=o.elements[0],d[u+1]=o.elements[3],d[u+2]=o.elements[6],d[u+3]=o.elements[4],d[u+4]=o.elements[7],d[u+5]=o.elements[8])}}();fillSplatCovarianceArray(e,s,t,n,o,i){const r=this.splatCount,a=new f.Vector3,l=new f.Quaternion;t=t||0,n=n||r-1,o===void 0&&(o=t);for(let c=t;c<=n;c++){const d=this.globalSplatIndexToSectionMap[c],u=this.sections[d],h=c-u.splatCountOffset,m=(c-t+o)*I.CovarianceComponentCount,p=u.bytesPerSplat*h+I.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,g=new DataView(this.bufferData,u.dataBase+p);a.set(se(W(g,0,this.compressionLevel),this.compressionLevel),se(W(g,1,this.compressionLevel),this.compressionLevel),se(W(g,2,this.compressionLevel),this.compressionLevel)),l.set(se(W(g,4,this.compressionLevel),this.compressionLevel),se(W(g,5,this.compressionLevel),this.compressionLevel),se(W(g,6,this.compressionLevel),this.compressionLevel),se(W(g,3,this.compressionLevel),this.compressionLevel)),I.computeCovariance(a,l,s,e,m,i)}}fillSplatColorArray(e,s,t,n,o){const i=this.splatCount;t=t||0,n=n||i-1,o===void 0&&(o=t);for(let r=t;r<=n;r++){const a=this.globalSplatIndexToSectionMap[r],l=this.sections[a],c=r-l.splatCountOffset,d=(r-t+o)*I.ColorComponentCount,u=l.bytesPerSplat*c+I.CompressionLevels[this.compressionLevel].ColorOffsetBytes,h=new Uint8Array(this.bufferData,l.dataBase+u);let m=h[3];m=m>=s?m:0,e[d]=h[0],e[d+1]=h[1],e[d+2]=h[2],e[d+3]=m}}fillSphericalHarmonicsArray=function(){for(let M=0;M<15;M++)new f.Vector3;const e=new f.Matrix3,s=new f.Matrix4,t=new f.Vector3,n=new f.Vector3,o=new f.Quaternion,i=[],r=[],a=[],l=[],c=[],d=[],u=[],h=[],m=[],p=[],g=[],C=[],S=[],T=[],w=[],x=[],E=[],y=[],v=M=>M,D=(M,O,L,U)=>{M[0]=O,M[1]=L,M[2]=U},b=(M,O,L,U,_)=>{M[0]=W(O,U,_,!0),M[1]=W(O,U+L,_,!0),M[2]=W(O,U+L+L,_,!0)},F=(M,O)=>{O[0]=M[0],O[1]=M[1],O[2]=M[2]},R=(M,O,L,U)=>{O[L]=U(M[0]),O[L+1]=U(M[1]),O[L+2]=U(M[2])},k=(M,O,L,U,_)=>(O[0]=se(M[0],L,!0,U,_),O[1]=se(M[1],L,!0,U,_),O[2]=se(M[2],L,!0,U,_),O);return function(M,O,L,U,_,H,Q){const Z=this.splatCount;U=U||0,_=_||Z-1,H===void 0&&(H=U),L&&O>=1&&(s.copy(L),s.decompose(t,o,n),o.normalize(),s.makeRotationFromQuaternion(o),e.setFromMatrix4(s),D(i,e.elements[4],-e.elements[7],e.elements[1]),D(r,-e.elements[5],e.elements[8],-e.elements[2]),D(a,e.elements[3],-e.elements[6],e.elements[0]));const ie=ee=>zs(ee,this.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff),V=ee=>et(ee,this.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff);for(let ee=U;ee<=_;ee++){const X=this.globalSplatIndexToSectionMap[ee],N=this.sections[X];O=Math.min(O,N.sphericalHarmonicsDegree);const Y=je(O),ae=ee-N.splatCountOffset,le=N.bytesPerSplat*ae+I.CompressionLevels[this.compressionLevel].SphericalHarmonicsOffsetBytes,oe=new DataView(this.bufferData,N.dataBase+le),Ae=(ee-U+H)*Y;let he=L?0:this.compressionLevel,te=v;he!==Q&&(he===1?Q===0?te=Ht:Q==2&&(te=ie):he===0&&(Q===1?te=fe:Q==2&&(te=V)));const ue=this.minSphericalHarmonicsCoeff,J=this.maxSphericalHarmonicsCoeff;O>=1&&(b(m,oe,3,0,this.compressionLevel),b(p,oe,3,1,this.compressionLevel),b(g,oe,3,2,this.compressionLevel),L?(k(m,m,this.compressionLevel,ue,J),k(p,p,this.compressionLevel,ue,J),k(g,g,this.compressionLevel,ue,J),I.rotateSphericalHarmonics3(m,p,g,i,r,a,T,w,x)):(F(m,T),F(p,w),F(g,x)),R(T,M,Ae,te),R(w,M,Ae+3,te),R(x,M,Ae+6,te),O>=2&&(b(m,oe,5,9,this.compressionLevel),b(p,oe,5,10,this.compressionLevel),b(g,oe,5,11,this.compressionLevel),b(C,oe,5,12,this.compressionLevel),b(S,oe,5,13,this.compressionLevel),L?(k(m,m,this.compressionLevel,ue,J),k(p,p,this.compressionLevel,ue,J),k(g,g,this.compressionLevel,ue,J),k(C,C,this.compressionLevel,ue,J),k(S,S,this.compressionLevel,ue,J),I.rotateSphericalHarmonics5(m,p,g,C,S,i,r,a,l,c,d,u,h,T,w,x,E,y)):(F(m,T),F(p,w),F(g,x),F(C,E),F(S,y)),R(T,M,Ae+9,te),R(w,M,Ae+12,te),R(x,M,Ae+15,te),R(E,M,Ae+18,te),R(y,M,Ae+21,te)))}}}();static dot3=(e,s,t,n,o)=>{o[0]=o[1]=o[2]=0;const i=n[0],r=n[1],a=n[2];I.addInto3(e[0]*i,e[1]*i,e[2]*i,o),I.addInto3(s[0]*r,s[1]*r,s[2]*r,o),I.addInto3(t[0]*a,t[1]*a,t[2]*a,o)};static addInto3=(e,s,t,n)=>{n[0]=n[0]+e,n[1]=n[1]+s,n[2]=n[2]+t};static dot5=(e,s,t,n,o,i,r)=>{r[0]=r[1]=r[2]=0;const a=i[0],l=i[1],c=i[2],d=i[3],u=i[4];I.addInto3(e[0]*a,e[1]*a,e[2]*a,r),I.addInto3(s[0]*l,s[1]*l,s[2]*l,r),I.addInto3(t[0]*c,t[1]*c,t[2]*c,r),I.addInto3(n[0]*d,n[1]*d,n[2]*d,r),I.addInto3(o[0]*u,o[1]*u,o[2]*u,r)};static rotateSphericalHarmonics3=(e,s,t,n,o,i,r,a,l)=>{I.dot3(e,s,t,n,r),I.dot3(e,s,t,o,a),I.dot3(e,s,t,i,l)};static rotateSphericalHarmonics5=(e,s,t,n,o,i,r,a,l,c,d,u,h,m,p,g,C,S)=>{const T=Math.sqrt(.25),w=Math.sqrt(3/4),x=Math.sqrt(1/3),E=Math.sqrt(4/3),y=Math.sqrt(1/12);l[0]=T*(a[2]*i[0]+a[0]*i[2]+(i[2]*a[0]+i[0]*a[2])),l[1]=a[1]*i[0]+i[1]*a[0],l[2]=w*(a[1]*i[1]+i[1]*a[1]),l[3]=a[1]*i[2]+i[1]*a[2],l[4]=T*(a[2]*i[2]-a[0]*i[0]+(i[2]*a[2]-i[0]*a[0])),I.dot5(e,s,t,n,o,l,m),c[0]=T*(r[2]*i[0]+r[0]*i[2]+(i[2]*r[0]+i[0]*r[2])),c[1]=r[1]*i[0]+i[1]*r[0],c[2]=w*(r[1]*i[1]+i[1]*r[1]),c[3]=r[1]*i[2]+i[1]*r[2],c[4]=T*(r[2]*i[2]-r[0]*i[0]+(i[2]*r[2]-i[0]*r[0])),I.dot5(e,s,t,n,o,c,p),d[0]=x*(r[2]*r[0]+r[0]*r[2])+-y*(a[2]*a[0]+a[0]*a[2]+(i[2]*i[0]+i[0]*i[2])),d[1]=E*r[1]*r[0]+-x*(a[1]*a[0]+i[1]*i[0]),d[2]=r[1]*r[1]+-T*(a[1]*a[1]+i[1]*i[1]),d[3]=E*r[1]*r[2]+-x*(a[1]*a[2]+i[1]*i[2]),d[4]=x*(r[2]*r[2]-r[0]*r[0])+-y*(a[2]*a[2]-a[0]*a[0]+(i[2]*i[2]-i[0]*i[0])),I.dot5(e,s,t,n,o,d,g),u[0]=T*(r[2]*a[0]+r[0]*a[2]+(a[2]*r[0]+a[0]*r[2])),u[1]=r[1]*a[0]+a[1]*r[0],u[2]=w*(r[1]*a[1]+a[1]*r[1]),u[3]=r[1]*a[2]+a[1]*r[2],u[4]=T*(r[2]*a[2]-r[0]*a[0]+(a[2]*r[2]-a[0]*r[0])),I.dot5(e,s,t,n,o,u,C),h[0]=T*(a[2]*a[0]+a[0]*a[2]-(i[2]*i[0]+i[0]*i[2])),h[1]=a[1]*a[0]-i[1]*i[0],h[2]=w*(a[1]*a[1]-i[1]*i[1]),h[3]=a[1]*a[2]-i[1]*i[2],h[4]=T*(a[2]*a[2]-a[0]*a[0]-(i[2]*i[2]-i[0]*i[0])),I.dot5(e,s,t,n,o,h,S)};static parseHeader(e){const s=new Uint8Array(e,0,I.HeaderSizeBytes),t=new Uint16Array(e,0,I.HeaderSizeBytes/2),n=new Uint32Array(e,0,I.HeaderSizeBytes/4),o=new Float32Array(e,0,I.HeaderSizeBytes/4),i=s[0],r=s[1],a=n[1],l=n[2],c=n[3],d=n[4],u=t[10],h=new f.Vector3(o[6],o[7],o[8]),m=o[9]||-He,p=o[10]||He;return{versionMajor:i,versionMinor:r,maxSectionCount:a,sectionCount:l,maxSplatCount:c,splatCount:d,compressionLevel:u,sceneCenter:h,minSphericalHarmonicsCoeff:m,maxSphericalHarmonicsCoeff:p}}static writeHeaderCountsToBuffer(e,s,t){const n=new Uint32Array(t,0,I.HeaderSizeBytes/4);n[2]=e,n[4]=s}static writeHeaderToBuffer(e,s){const t=new Uint8Array(s,0,I.HeaderSizeBytes),n=new Uint16Array(s,0,I.HeaderSizeBytes/2),o=new Uint32Array(s,0,I.HeaderSizeBytes/4),i=new Float32Array(s,0,I.HeaderSizeBytes/4);t[0]=e.versionMajor,t[1]=e.versionMinor,t[2]=0,t[3]=0,o[1]=e.maxSectionCount,o[2]=e.sectionCount,o[3]=e.maxSplatCount,o[4]=e.splatCount,n[10]=e.compressionLevel,i[6]=e.sceneCenter.x,i[7]=e.sceneCenter.y,i[8]=e.sceneCenter.z,i[9]=e.minSphericalHarmonicsCoeff||-He,i[10]=e.maxSphericalHarmonicsCoeff||He}static parseSectionHeaders(e,s,t=0,n){const o=e.compressionLevel,i=e.maxSectionCount,r=new Uint16Array(s,t,i*I.SectionHeaderSizeBytes/2),a=new Uint32Array(s,t,i*I.SectionHeaderSizeBytes/4),l=new Float32Array(s,t,i*I.SectionHeaderSizeBytes/4),c=[];let d=0,u=d/2,h=d/4,m=I.HeaderSizeBytes+e.maxSectionCount*I.SectionHeaderSizeBytes,p=0;for(let g=0;g<i;g++){const C=a[h+1],S=a[h+2],T=a[h+3],w=l[h+4],x=w/2,E=r[u+10],y=a[h+6]||I.CompressionLevels[o].ScaleRange,v=a[h+8],D=a[h+9],b=D*4,F=E*T+b,R=r[u+20],{bytesPerSplat:k}=I.calculateComponentStorage(o,R),M=k*C,O=M+F,L={bytesPerSplat:k,splatCountOffset:p,splatCount:n?C:0,maxSplatCount:C,bucketSize:S,bucketCount:T,bucketBlockSize:w,halfBucketBlockSize:x,bucketStorageSizeBytes:E,bucketsStorageSizeBytes:F,splatDataStorageSizeBytes:M,storageSizeBytes:O,compressionScaleRange:y,compressionScaleFactor:x/y,base:m,bucketsBase:m+b,dataBase:m+F,fullBucketCount:v,partiallyFilledBucketCount:D,sphericalHarmonicsDegree:R};c[g]=L,m+=O,d+=I.SectionHeaderSizeBytes,u=d/2,h=d/4,p+=C}return c}static writeSectionHeaderToBuffer(e,s,t,n=0){const o=new Uint16Array(t,n,I.SectionHeaderSizeBytes/2),i=new Uint32Array(t,n,I.SectionHeaderSizeBytes/4),r=new Float32Array(t,n,I.SectionHeaderSizeBytes/4);i[0]=e.splatCount,i[1]=e.maxSplatCount,i[2]=s>=1?e.bucketSize:0,i[3]=s>=1?e.bucketCount:0,r[4]=s>=1?e.bucketBlockSize:0,o[10]=s>=1?I.BucketStorageSizeBytes:0,i[6]=s>=1?e.compressionScaleRange:0,i[7]=e.storageSizeBytes,i[8]=s>=1?e.fullBucketCount:0,i[9]=s>=1?e.partiallyFilledBucketCount:0,o[20]=e.sphericalHarmonicsDegree}static writeSectionHeaderSplatCountToBuffer(e,s,t=0){const n=new Uint32Array(s,t,I.SectionHeaderSizeBytes/4);n[0]=e}constructFromBuffer(e,s){this.bufferData=e,this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSectionMap=[];const t=I.parseHeader(this.bufferData);this.versionMajor=t.versionMajor,this.versionMinor=t.versionMinor,this.maxSectionCount=t.maxSectionCount,this.sectionCount=s?t.maxSectionCount:0,this.maxSplatCount=t.maxSplatCount,this.splatCount=s?t.maxSplatCount:0,this.compressionLevel=t.compressionLevel,this.sceneCenter=new f.Vector3().copy(t.sceneCenter),this.minSphericalHarmonicsCoeff=t.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff=t.maxSphericalHarmonicsCoeff,this.sections=I.parseSectionHeaders(t,this.bufferData,I.HeaderSizeBytes,s),this.linkBufferArrays(),this.buildMaps()}static calculateComponentStorage(e,s){const t=I.CompressionLevels[e].BytesPerCenter,n=I.CompressionLevels[e].BytesPerScale,o=I.CompressionLevels[e].BytesPerRotation,i=I.CompressionLevels[e].BytesPerColor,r=je(s),a=I.CompressionLevels[e].BytesPerSphericalHarmonicsComponent*r,l=t+n+o+i+a;return{bytesPerCenter:t,bytesPerScale:n,bytesPerRotation:o,bytesPerColor:i,sphericalHarmonicsComponentsPerSplat:r,sphericalHarmonicsBytesPerSplat:a,bytesPerSplat:l}}linkBufferArrays(){for(let e=0;e<this.maxSectionCount;e++){const s=this.sections[e];s.bucketArray=new Float32Array(this.bufferData,s.bucketsBase,s.bucketCount*I.BucketStorageSizeFloats),s.partiallyFilledBucketCount>0&&(s.partiallyFilledBucketLengths=new Uint32Array(this.bufferData,s.base,s.partiallyFilledBucketCount))}}buildMaps(){let e=0;for(let s=0;s<this.maxSectionCount;s++){const t=this.sections[s];for(let n=0;n<t.maxSplatCount;n++){const o=e+n;this.globalSplatIndexToLocalSplatIndexMap[o]=n,this.globalSplatIndexToSectionMap[o]=s}e+=t.maxSplatCount}}updateLoadedCounts(e,s){I.writeHeaderCountsToBuffer(e,s,this.bufferData),this.sectionCount=e,this.splatCount=s}updateSectionLoadedCounts(e,s){const t=I.HeaderSizeBytes+I.SectionHeaderSizeBytes*e;I.writeSectionHeaderSplatCountToBuffer(s,this.bufferData,t),this.sections[e].splatCount=s}static writeSplatDataToSectionBuffer=function(){const e=new ArrayBuffer(12),s=new ArrayBuffer(12),t=new ArrayBuffer(16),n=new ArrayBuffer(4),o=new ArrayBuffer(256),i=new f.Quaternion,r=new f.Vector3,a=new f.Vector3,{X:l,Y:c,Z:d,SCALE0:u,SCALE1:h,SCALE2:m,ROTATION0:p,ROTATION1:g,ROTATION2:C,ROTATION3:S,FDC0:T,FDC1:w,FDC2:x,OPACITY:E,FRC0:y,FRC9:v}=P.OFFSET,D=(b,F,R)=>{const k=R*2+1;return b=Math.round(b*F)+R,ne(b,0,k)};return function(b,F,R,k,M,O,L,U,_=-He,H=He){const Q=je(M),Z=I.CompressionLevels[k].BytesPerCenter,ie=I.CompressionLevels[k].BytesPerScale,V=I.CompressionLevels[k].BytesPerRotation,ee=I.CompressionLevels[k].BytesPerColor,X=R,N=X+Z,Y=N+ie,ae=Y+V,le=ae+ee;if(b[p]!==void 0?(i.set(b[p],b[g],b[C],b[S]),i.normalize()):i.set(1,0,0,0),b[u]!==void 0?r.set(b[u]||0,b[h]||0,b[m]||0):r.set(0,0,0),k===0){const Ae=new Float32Array(F,X,I.CenterComponentCount),he=new Float32Array(F,Y,I.RotationComponentCount),te=new Float32Array(F,N,I.ScaleComponentCount);if(he.set([i.x,i.y,i.z,i.w]),te.set([r.x,r.y,r.z]),Ae.set([b[l],b[c],b[d]]),M>0){const ue=new Float32Array(F,le,Q);if(M>=1){for(let J=0;J<9;J++)ue[J]=b[y+J]||0;if(M>=2)for(let J=0;J<15;J++)ue[J+9]=b[v+J]||0}}}else{const Ae=new Uint16Array(e,0,I.CenterComponentCount),he=new Uint16Array(t,0,I.RotationComponentCount),te=new Uint16Array(s,0,I.ScaleComponentCount);if(he.set([fe(i.x),fe(i.y),fe(i.z),fe(i.w)]),te.set([fe(r.x),fe(r.y),fe(r.z)]),a.set(b[l],b[c],b[d]).sub(O),a.x=D(a.x,L,U),a.y=D(a.y,L,U),a.z=D(a.z,L,U),Ae.set([a.x,a.y,a.z]),M>0){const ue=k===1?Uint16Array:Uint8Array,J=k===1?2:1,Ee=new ue(o,0,Q);if(M>=1){for(let me=0;me<9;me++){const xe=b[y+me]||0;Ee[me]=k===1?fe(xe):et(xe,_,H)}const De=9*J;if(Ge(Ee.buffer,0,F,le,De),M>=2){for(let me=0;me<15;me++){const xe=b[v+me]||0;Ee[me+9]=k===1?fe(xe):et(xe,_,H)}Ge(Ee.buffer,De,F,le+De,15*J)}}}Ge(Ae.buffer,0,F,X,6),Ge(te.buffer,0,F,N,6),Ge(he.buffer,0,F,Y,8)}const oe=new Uint8ClampedArray(n,0,4);oe.set([b[T]||0,b[w]||0,b[x]||0]),oe[3]=b[E]||0,Ge(oe.buffer,0,F,ae,4)}}();static generateFromUncompressedSplatArrays(e,s,t,n,o,i,r=[]){let a=0;for(let x=0;x<e.length;x++){const E=e[x];a=Math.max(E.sphericalHarmonicsDegree,a)}let l,c;for(let x=0;x<e.length;x++){const E=e[x];for(let y=0;y<E.splats.length;y++){const v=E.splats[y];for(let D=P.OFFSET.FRC0;D<P.OFFSET.FRC23&&D<v.length;D++)(!l||v[D]<l)&&(l=v[D]),(!c||v[D]>c)&&(c=v[D])}}l=l||-He,c=c||He;const{bytesPerSplat:d}=I.calculateComponentStorage(t,a),u=I.CompressionLevels[t].ScaleRange,h=[],m=[];let p=0;for(let x=0;x<e.length;x++){const E=e[x],y=new P(a);for(let X=0;X<E.splatCount;X++){const N=E.splats[X];(N[P.OFFSET.OPACITY]||0)>=s&&y.addSplat(N)}const v=r[x]||{},D=(v.blockSizeFactor||1)*(o||I.BucketBlockSize),b=Math.ceil((v.bucketSizeFactor||1)*(i||I.BucketSize)),F=I.computeBucketsForUncompressedSplatArray(y,D,b),R=F.fullBuckets.length,k=F.partiallyFullBuckets.map(X=>X.splats.length),M=k.length,O=[...F.fullBuckets,...F.partiallyFullBuckets],L=y.splats.length*d,U=M*4,_=t>=1?O.length*I.BucketStorageSizeBytes+U:0,H=L+_,Q=new ArrayBuffer(H),Z=u/(D*.5),ie=new f.Vector3;let V=0;for(let X=0;X<O.length;X++){const N=O[X];ie.fromArray(N.center);for(let Y=0;Y<N.splats.length;Y++){let ae=N.splats[Y];const le=y.splats[ae],oe=_+V*d;I.writeSplatDataToSectionBuffer(le,Q,oe,t,a,ie,Z,u,l,c),V++}}if(p+=V,t>=1){const X=new Uint32Array(Q,0,k.length*4);for(let Y=0;Y<k.length;Y++)X[Y]=k[Y];const N=new Float32Array(Q,U,O.length*I.BucketStorageSizeFloats);for(let Y=0;Y<O.length;Y++){const ae=O[Y],le=Y*3;N[le]=ae.center[0],N[le+1]=ae.center[1],N[le+2]=ae.center[2]}}h.push(Q);const ee=new ArrayBuffer(I.SectionHeaderSizeBytes);I.writeSectionHeaderToBuffer({maxSplatCount:V,splatCount:V,bucketSize:b,bucketCount:O.length,bucketBlockSize:D,compressionScaleRange:u,storageSizeBytes:H,fullBucketCount:R,partiallyFilledBucketCount:M,sphericalHarmonicsDegree:a},t,ee,0),m.push(ee)}let g=0;for(let x of h)g+=x.byteLength;const C=I.HeaderSizeBytes+I.SectionHeaderSizeBytes*h.length+g,S=new ArrayBuffer(C);I.writeHeaderToBuffer({versionMajor:0,versionMinor:1,maxSectionCount:h.length,sectionCount:h.length,maxSplatCount:p,splatCount:p,compressionLevel:t,sceneCenter:n,minSphericalHarmonicsCoeff:l,maxSphericalHarmonicsCoeff:c},S);let T=I.HeaderSizeBytes;for(let x of m)new Uint8Array(S,T,I.SectionHeaderSizeBytes).set(new Uint8Array(x)),T+=I.SectionHeaderSizeBytes;for(let x of h)new Uint8Array(S,T,x.byteLength).set(new Uint8Array(x)),T+=x.byteLength;return new I(S)}static computeBucketsForUncompressedSplatArray(e,s,t){let n=e.splatCount;const o=s/2,i=new f.Vector3,r=new f.Vector3;for(let p=0;p<n;p++){const g=e.splats[p],C=[g[P.OFFSET.X],g[P.OFFSET.Y],g[P.OFFSET.Z]];(p===0||C[0]<i.x)&&(i.x=C[0]),(p===0||C[0]>r.x)&&(r.x=C[0]),(p===0||C[1]<i.y)&&(i.y=C[1]),(p===0||C[1]>r.y)&&(r.y=C[1]),(p===0||C[2]<i.z)&&(i.z=C[2]),(p===0||C[2]>r.z)&&(r.z=C[2])}const a=new f.Vector3().copy(r).sub(i),l=Math.ceil(a.y/s),c=Math.ceil(a.z/s),d=new f.Vector3,u=[],h={};for(let p=0;p<n;p++){const g=e.splats[p],C=[g[P.OFFSET.X],g[P.OFFSET.Y],g[P.OFFSET.Z]],S=Math.floor((C[0]-i.x)/s),T=Math.floor((C[1]-i.y)/s),w=Math.floor((C[2]-i.z)/s);d.x=S*s+i.x+o,d.y=T*s+i.y+o,d.z=w*s+i.z+o;const x=S*(l*c)+T*c+w;let E=h[x];E||(h[x]=E={splats:[],center:d.toArray()}),E.splats.push(p),E.splats.length>=t&&(u.push(E),h[x]=null)}const m=[];for(let p in h)if(h.hasOwnProperty(p)){const g=h[p];g&&m.push(g)}return{fullBuckets:u,partiallyFullBuckets:m}}static preallocateUncompressed(e,s){const t=I.CompressionLevels[0].SphericalHarmonicsDegrees[s],n=I.HeaderSizeBytes+I.SectionHeaderSizeBytes,o=n+t.BytesPerSplat*e,i=new ArrayBuffer(o);return I.writeHeaderToBuffer({versionMajor:I.CurrentMajorVersion,versionMinor:I.CurrentMinorVersion,maxSectionCount:1,sectionCount:1,maxSplatCount:e,splatCount:e,compressionLevel:0,sceneCenter:new f.Vector3},i),I.writeSectionHeaderToBuffer({maxSplatCount:e,splatCount:e,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0,sphericalHarmonicsDegree:s},0,i,I.HeaderSizeBytes),{splatBuffer:new I(i,!0),splatBufferDataOffsetBytes:n}}}const os=new Uint8Array([112,108,121,10]),rs=new Uint8Array([10,101,110,100,95,104,101,97,100,101,114,10]),wt="end_header",Et=new Map([["char",Int8Array],["uchar",Uint8Array],["short",Int16Array],["ushort",Uint16Array],["int",Int32Array],["uint",Uint32Array],["float",Float32Array],["double",Float64Array]]),Fe=(A,e)=>{const s=(1<<e)-1;return(A&s)/s},is=(A,e)=>{A.x=Fe(e>>>21,11),A.y=Fe(e>>>11,10),A.z=Fe(e,11)},hn=(A,e)=>{A.x=Fe(e>>>24,8),A.y=Fe(e>>>16,8),A.z=Fe(e>>>8,8),A.w=Fe(e,8)},un=(A,e)=>{const s=1/(Math.sqrt(2)*.5),t=(Fe(e>>>20,10)-.5)*s,n=(Fe(e>>>10,10)-.5)*s,o=(Fe(e,10)-.5)*s,i=Math.sqrt(1-(t*t+n*n+o*o));switch(e>>>30){case 0:A.set(i,t,n,o);break;case 1:A.set(t,i,n,o);break;case 2:A.set(t,n,i,o);break;case 3:A.set(t,n,o,i);break}},Re=(A,e,s)=>A*(1-s)+e*s,re=(A,e)=>A.properties.find(s=>s.name===e&&s.storage)?.storage;class G{static decodeHeaderText(e){let s,t,n,o;const i=e.split(`
`).filter(d=>!d.startsWith("comment "));let r=0,a=!1;for(let d=1;d<i.length;++d){const u=i[d].split(" ");switch(u[0]){case"format":if(u[1]!=="binary_little_endian")throw new Error("Unsupported ply format");break;case"element":s={name:u[1],count:parseInt(u[2],10),properties:[],storageSizeBytes:0},s.name==="chunk"?t=s:s.name==="vertex"?n=s:s.name==="sh"&&(o=s);break;case"property":{if(!Et.has(u[1]))throw new Error(`Unrecognized property data type '${u[1]}' in ply header`);const h=Et.get(u[1]),m=h.BYTES_PER_ELEMENT*s.count;s.name==="vertex"&&(r+=h.BYTES_PER_ELEMENT),s.properties.push({type:u[1],name:u[2],storage:null,byteSize:h.BYTES_PER_ELEMENT,storageSizeByes:m}),s.storageSizeBytes+=m;break}case wt:a=!0;break;default:throw new Error(`Unrecognized header value '${u[0]}' in ply header`)}if(a)break}let l=0,c=0;return o&&(c=o.properties.length,o.properties.length>=45?l=3:o.properties.length>=24?l=2:o.properties.length>=9&&(l=1)),{chunkElement:t,vertexElement:n,shElement:o,bytesPerSplat:r,headerSizeBytes:e.indexOf(wt)+wt.length+1,sphericalHarmonicsDegree:l,sphericalHarmonicsPerSplat:c}}static decodeHeader(e){const s=(h,m)=>{const p=h.length-m.length;let g,C;for(g=0;g<=p;++g){for(C=0;C<m.length&&h[g+C]===m[C];++C);if(C===m.length)return g}return-1},t=(h,m)=>{if(h.length<m.length)return!1;for(let p=0;p<m.length;++p)if(h[p]!==m[p])return!1;return!0};let n=new Uint8Array(e),o;if(n.length>=os.length&&!t(n,os))throw new Error("Invalid PLY header");if(o=s(n,rs),o===-1)throw new Error("End of PLY header not found");const i=new TextDecoder("ascii").decode(n.slice(0,o)),{chunkElement:r,vertexElement:a,shElement:l,sphericalHarmonicsDegree:c,sphericalHarmonicsPerSplat:d,bytesPerSplat:u}=G.decodeHeaderText(i);return{headerSizeBytes:o+rs.length,bytesPerSplat:u,chunkElement:r,vertexElement:a,shElement:l,sphericalHarmonicsDegree:c,sphericalHarmonicsPerSplat:d}}static readElementData(e,s,t,n,o,i=null){let r=s instanceof DataView?s:new DataView(s);n=n||0,o=o||e.count-1;for(let a=n;a<=o;++a)for(let l=0;l<e.properties.length;++l){const c=e.properties[l],d=Et.get(c.type),u=d.BYTES_PER_ELEMENT*e.count;if((!c.storage||c.storage.byteLength<u)&&(!i||i(c.name))&&(c.storage=new d(e.count)),c.storage)switch(c.type){case"char":c.storage[a]=r.getInt8(t);break;case"uchar":c.storage[a]=r.getUint8(t);break;case"short":c.storage[a]=r.getInt16(t,!0);break;case"ushort":c.storage[a]=r.getUint16(t,!0);break;case"int":c.storage[a]=r.getInt32(t,!0);break;case"uint":c.storage[a]=r.getUint32(t,!0);break;case"float":c.storage[a]=r.getFloat32(t,!0);break;case"double":c.storage[a]=r.getFloat64(t,!0);break}t+=c.byteSize}return t}static readPly(e,s=null){const t=G.decodeHeader(e);let n=G.readElementData(t.chunkElement,e,t.headerSizeBytes,null,null,s);return n=G.readElementData(t.vertexElement,e,n,null,null,s),G.readElementData(t.shElement,e,n,null,null,s),{chunkElement:t.chunkElement,vertexElement:t.vertexElement,shElement:t.shElement,sphericalHarmonicsDegree:t.sphericalHarmonicsDegree,sphericalHarmonicsPerSplat:t.sphericalHarmonicsPerSplat}}static getElementStorageArrays(e,s,t){const n={};if(s){const o=re(e,"min_r"),i=re(e,"min_g"),r=re(e,"min_b"),a=re(e,"max_r"),l=re(e,"max_g"),c=re(e,"max_b"),d=re(e,"min_x"),u=re(e,"min_y"),h=re(e,"min_z"),m=re(e,"max_x"),p=re(e,"max_y"),g=re(e,"max_z"),C=re(e,"min_scale_x"),S=re(e,"min_scale_y"),T=re(e,"min_scale_z"),w=re(e,"max_scale_x"),x=re(e,"max_scale_y"),E=re(e,"max_scale_z"),y=re(s,"packed_position"),v=re(s,"packed_rotation"),D=re(s,"packed_scale"),b=re(s,"packed_color");n.colorExtremes={minR:o,maxR:a,minG:i,maxG:l,minB:r,maxB:c},n.positionExtremes={minX:d,maxX:m,minY:u,maxY:p,minZ:h,maxZ:g},n.scaleExtremes={minScaleX:C,maxScaleX:w,minScaleY:S,maxScaleY:x,minScaleZ:T,maxScaleZ:E},n.position=y,n.rotation=v,n.scale=D,n.color=b}if(t){const o={};for(let i=0;i<45;i++){const r=`f_rest_${i}`,a=re(t,r);if(a)o[r]=a;else break}n.sh=o}return n}static decompressBaseSplat=function(){const e=new f.Vector3,s=new f.Quaternion,t=new f.Vector3,n=new f.Vector4,o=P.OFFSET;return function(i,r,a,l,c,d,u,h,m,p){p=p||P.createSplat();const g=Math.floor((r+i)/256);return is(e,a[i]),un(s,u[i]),is(t,c[i]),hn(n,m[i]),p[o.X]=Re(l.minX[g],l.maxX[g],e.x),p[o.Y]=Re(l.minY[g],l.maxY[g],e.y),p[o.Z]=Re(l.minZ[g],l.maxZ[g],e.z),p[o.ROTATION0]=s.x,p[o.ROTATION1]=s.y,p[o.ROTATION2]=s.z,p[o.ROTATION3]=s.w,p[o.SCALE0]=Math.exp(Re(d.minScaleX[g],d.maxScaleX[g],t.x)),p[o.SCALE1]=Math.exp(Re(d.minScaleY[g],d.maxScaleY[g],t.y)),p[o.SCALE2]=Math.exp(Re(d.minScaleZ[g],d.maxScaleZ[g],t.z)),h.minR&&h.maxR?p[o.FDC0]=ne(Math.round(Re(h.minR[g],h.maxR[g],n.x)*255),0,255):p[o.FDC0]=ne(Math.floor(n.x*255),0,255),h.minG&&h.maxG?p[o.FDC1]=ne(Math.round(Re(h.minG[g],h.maxG[g],n.y)*255),0,255):p[o.FDC1]=ne(Math.floor(n.y*255),0,255),h.minB&&h.maxB?p[o.FDC2]=ne(Math.round(Re(h.minB[g],h.maxB[g],n.z)*255),0,255):p[o.FDC2]=ne(Math.floor(n.z*255),0,255),p[o.OPACITY]=ne(Math.floor(n.w*255),0,255),p}}();static decompressSphericalHarmonics=function(){const e=[0,3,8,15],s=[0,1,2,9,10,11,12,13,24,25,26,27,28,29,30,3,4,5,14,15,16,17,18,31,32,33,34,35,36,37,6,7,8,19,20,21,22,23,38,39,40,41,42,43,44];return function(t,n,o,i,r){r=r||P.createSplat();let a=e[o],l=e[i];for(let c=0;c<3;++c)for(let d=0;d<15;++d){const u=s[c*15+d];d<a&&d<l&&(r[P.OFFSET.FRC0+u]=n[c*l+d][t]*(8/255)-4)}return r}}();static parseToUncompressedSplatBufferSection(e,s,t,n,o,i,r,a,l=null){G.readElementData(s,i,0,t,n,l);const c=I.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,{positionExtremes:d,scaleExtremes:u,colorExtremes:h,position:m,rotation:p,scale:g,color:C}=G.getElementStorageArrays(e,s),S=P.createSplat();for(let T=t;T<=n;++T){G.decompressBaseSplat(T,o,m,d,g,u,p,h,C,S);const w=T*c+a;I.writeSplatDataToSectionBuffer(S,r,w,0,0)}}static parseToUncompressedSplatArraySection(e,s,t,n,o,i,r,a=null){G.readElementData(s,i,0,t,n,a);const{positionExtremes:l,scaleExtremes:c,colorExtremes:d,position:u,rotation:h,scale:m,color:p}=G.getElementStorageArrays(e,s);for(let g=t;g<=n;++g){const C=P.createSplat();G.decompressBaseSplat(g,o,u,l,m,c,h,d,p,C),r.addSplat(C)}}static parseSphericalHarmonicsToUncompressedSplatArraySection(e,s,t,n,o,i,r,a,l,c=null){G.readElementData(s,o,i,t,n,c);const{sh:d}=G.getElementStorageArrays(e,void 0,s),u=Object.values(d);for(let h=t;h<=n;++h)G.decompressSphericalHarmonics(h,u,r,a,l.splats[h])}static parseToUncompressedSplatArray(e,s){const{chunkElement:t,vertexElement:n,shElement:o,sphericalHarmonicsDegree:i}=G.readPly(e);s=Math.min(s,i);const r=new P(s),{positionExtremes:a,scaleExtremes:l,colorExtremes:c,position:d,rotation:u,scale:h,color:m}=G.getElementStorageArrays(t,n);let p;if(s>0){const{sh:g}=G.getElementStorageArrays(t,void 0,o);p=Object.values(g)}for(let g=0;g<n.count;++g){r.addDefaultSplat();const C=r.getSplat(r.splatCount-1);G.decompressBaseSplat(g,0,d,a,h,l,u,c,m,C),s>0&&G.decompressSphericalHarmonics(g,p,s,i,C)}return r}static parseToUncompressedSplatBuffer(e,s){const{chunkElement:t,vertexElement:n,shElement:o,sphericalHarmonicsDegree:i}=G.readPly(e);s=Math.min(s,i);const{splatBuffer:r,splatBufferDataOffsetBytes:a}=I.preallocateUncompressed(n.count,s),{positionExtremes:l,scaleExtremes:c,colorExtremes:d,position:u,rotation:h,scale:m,color:p}=G.getElementStorageArrays(t,n);let g;if(s>0){const{sh:T}=G.getElementStorageArrays(t,void 0,o);g=Object.values(T)}const C=I.CompressionLevels[0].SphericalHarmonicsDegrees[s].BytesPerSplat,S=P.createSplat(s);for(let T=0;T<n.count;++T){G.decompressBaseSplat(T,0,u,l,m,c,h,d,p,S),s>0&&G.decompressSphericalHarmonics(T,g,s,i,S);const w=T*C+a;I.writeSplatDataToSectionBuffer(S,r.bufferData,w,0,s)}return r}}const Ce={INRIAV1:0,INRIAV2:1,PlayCanvasCompressed:2},[_s,zt,_t,Qt,Vt,Nt,Gt]=[0,1,2,3,4,5,6],as={double:_s,int:zt,uint:_t,float:Qt,short:Vt,ushort:Nt,uchar:Gt},pn={[_s]:8,[zt]:4,[_t]:4,[Qt]:4,[Vt]:2,[Nt]:2,[Gt]:1};class q{static HeaderEndToken="end_header";static decodeSectionHeader(e,s,t=0){const n=[];let o=!1,i=-1,r=0,a=!1,l=null;const c=[],d=[],u=[],h={};for(let C=t;C<e.length;C++){const S=e[C].trim();if(S.startsWith("element"))if(o){i--;break}else{o=!0,t=C,i=C;const T=S.split(" ");let w=0;for(let x of T){const E=x.trim();E.length>0&&(w++,w===2?l=E:w===3&&(r=parseInt(E)))}}else if(S.startsWith("property")){const T=S.match(/(\w+)\s+(\w+)\s+(\w+)/);if(T){const w=T[2],x=T[3];u.push(x);const E=s[x];h[x]=w;const y=as[w];E!==void 0&&(c.push(E),d[E]=y)}}if(S===q.HeaderEndToken){a=!0;break}o&&(n.push(S),i++)}const m=[];let p=0;for(let C of u){const S=h[C];if(h.hasOwnProperty(C)){const T=s[C];T!==void 0&&(m[T]=p)}p+=pn[as[S]]}const g=q.decodeSphericalHarmonicsFromSectionHeader(u,s);return{headerLines:n,headerStartLine:t,headerEndLine:i,fieldTypes:d,fieldIds:c,fieldOffsets:m,bytesPerVertex:p,vertexCount:r,dataSizeBytes:p*r,endOfHeader:a,sectionName:l,sphericalHarmonicsDegree:g.degree,sphericalHarmonicsCoefficientsPerChannel:g.coefficientsPerChannel,sphericalHarmonicsDegree1Fields:g.degree1Fields,sphericalHarmonicsDegree2Fields:g.degree2Fields}}static decodeSphericalHarmonicsFromSectionHeader(e,s){let t=0,n=0;for(let a of e)a.startsWith("f_rest")&&t++;n=t/3;let o=0;n>=3&&(o=1),n>=8&&(o=2);let i=[],r=[];for(let a=0;a<3;a++){if(o>=1)for(let l=0;l<3;l++)i.push(s["f_rest_"+(l+n*a)]);if(o>=2)for(let l=0;l<5;l++)r.push(s["f_rest_"+(l+n*a+3)])}return{degree:o,coefficientsPerChannel:n,degree1Fields:i,degree2Fields:r}}static getHeaderSectionNames(e){const s=[];for(let t of e)if(t.startsWith("element")){const n=t.split(" ");let o=0;for(let i of n){const r=i.trim();r.length>0&&(o++,o===2&&s.push(r))}}return s}static checkTextForEndHeader(e){return!!e.includes(q.HeaderEndToken)}static checkBufferForEndHeader(e,s,t,n){const o=new Uint8Array(e,Math.max(0,s-t),t),i=n.decode(o);return q.checkTextForEndHeader(i)}static extractHeaderFromBufferToText(e){const s=new TextDecoder;let t=0,n="";const o=100;for(;;){if(t+o>=e.byteLength)throw new Error("End of file reached while searching for end of header");const i=new Uint8Array(e,t,o);if(n+=s.decode(i),t+=o,q.checkBufferForEndHeader(e,t,o*2,s))break}return n}static readHeaderFromBuffer(e){const s=new TextDecoder;let t=0,n="";const o=100;for(;;){if(t+o>=e.byteLength)throw new Error("End of file reached while searching for end of header");const i=new Uint8Array(e,t,o);if(n+=s.decode(i),t+=o,q.checkBufferForEndHeader(e,t,o*2,s))break}return n}static convertHeaderTextToLines(e){const s=e.split(`
`),t=[];for(let n=0;n<s.length;n++){const o=s[n].trim();if(t.push(o),o===q.HeaderEndToken)break}return t}static determineHeaderFormatFromHeaderText(e){const s=q.convertHeaderTextToLines(e);let t=Ce.INRIAV1;for(let n=0;n<s.length;n++){const o=s[n].trim();if(o.startsWith("element chunk")||o.match(/[A-Za-z]*packed_[A-Za-z]*/))t=Ce.PlayCanvasCompressed;else if(o.startsWith("element codebook_centers"))t=Ce.INRIAV2;else if(o===q.HeaderEndToken)break}return t}static determineHeaderFormatFromPlyBuffer(e){const s=q.extractHeaderFromBufferToText(e);return q.determineHeaderFormatFromHeaderText(s)}static readVertex(e,s,t,n,o,i,r=!0){const a=t*s.bytesPerVertex+n,l=s.fieldOffsets,c=s.fieldTypes;for(let d of o){const u=c[d];u===Qt?i[d]=e.getFloat32(a+l[d],!0):u===Vt?i[d]=e.getInt16(a+l[d],!0):u===Nt?i[d]=e.getUint16(a+l[d],!0):u===zt?i[d]=e.getInt32(a+l[d],!0):u===_t?i[d]=e.getUint32(a+l[d],!0):u===Gt&&(r?i[d]=e.getUint8(a+l[d])/255:i[d]=e.getUint8(a+l[d]))}}}const Qs=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","red","green","blue","f_rest_0"],fn=Qs.map((A,e)=>e),[ls,mn,An,gn,Sn,Cn,yn,xn,Tn,In,cs,Bn,wn,ds,hs,En,vn,Dn]=fn;class Se{static decodeHeaderLines(e){let s=0;e.forEach(c=>{c.includes("f_rest_")&&s++});let t=0;s>=45?t=45:s>=24?t=24:s>=9&&(t=9);let o=Array.from(Array(Math.max(t-1,0))).map((c,d)=>`f_rest_${d+1}`);const i=[...Qs,...o],r=i.map((c,d)=>d),a=r.reduce((c,d)=>(c[i[d]]=d,c),{}),l=q.decodeSectionHeader(e,a,0);return l.splatCount=l.vertexCount,l.bytesPerSplat=l.bytesPerVertex,l.fieldsToReadIndexes=r,l}static decodeHeaderText(e){const s=q.convertHeaderTextToLines(e),t=Se.decodeHeaderLines(s);return t.headerText=e,t.headerSizeBytes=e.indexOf(q.HeaderEndToken)+q.HeaderEndToken.length+1,t}static decodeHeaderFromBuffer(e){const s=q.readHeaderFromBuffer(e);return Se.decodeHeaderText(s)}static findSplatData(e,s){return new DataView(e,s.headerSizeBytes)}static parseToUncompressedSplatBufferSection(e,s,t,n,o,i,r,a=0){a=Math.min(a,e.sphericalHarmonicsDegree);const l=I.CompressionLevels[0].SphericalHarmonicsDegrees[a].BytesPerSplat;for(let c=s;c<=t;c++){const d=Se.parseToUncompressedSplat(n,c,e,o,a),u=c*l+r;I.writeSplatDataToSectionBuffer(d,i,u,0,a)}}static parseToUncompressedSplatArraySection(e,s,t,n,o,i,r=0){r=Math.min(r,e.sphericalHarmonicsDegree);for(let a=s;a<=t;a++){const l=Se.parseToUncompressedSplat(n,a,e,o,r);i.addSplat(l)}}static decodeSectionSplatData(e,s,t,n,o=!0){if(n=Math.min(n,t.sphericalHarmonicsDegree),o){const i=new P(n);for(let r=0;r<s;r++){const a=Se.parseToUncompressedSplat(e,r,t,0,n);i.addSplat(a)}return i}else{const{splatBuffer:i,splatBufferDataOffsetBytes:r}=I.preallocateUncompressed(s,n);return Se.parseToUncompressedSplatBufferSection(t,0,s-1,e,0,i.bufferData,r,n),i}}static parseToUncompressedSplat=function(){let e=[];const s=new f.Quaternion,t=P.OFFSET.X,n=P.OFFSET.Y,o=P.OFFSET.Z,i=P.OFFSET.SCALE0,r=P.OFFSET.SCALE1,a=P.OFFSET.SCALE2,l=P.OFFSET.ROTATION0,c=P.OFFSET.ROTATION1,d=P.OFFSET.ROTATION2,u=P.OFFSET.ROTATION3,h=P.OFFSET.FDC0,m=P.OFFSET.FDC1,p=P.OFFSET.FDC2,g=P.OFFSET.OPACITY,C=[];for(let S=0;S<45;S++)C[S]=P.OFFSET.FRC0+S;return function(S,T,w,x=0,E=0){E=Math.min(E,w.sphericalHarmonicsDegree),Se.readSplat(S,w,T,x,e);const y=P.createSplat(E);if(e[ls]!==void 0?(y[i]=Math.exp(e[ls]),y[r]=Math.exp(e[mn]),y[a]=Math.exp(e[An])):(y[i]=.01,y[r]=.01,y[a]=.01),e[cs]!==void 0){const v=.28209479177387814;y[h]=(.5+v*e[cs])*255,y[m]=(.5+v*e[Bn])*255,y[p]=(.5+v*e[wn])*255}else e[hs]!==void 0?(y[h]=e[hs]*255,y[m]=e[En]*255,y[p]=e[vn]*255):(y[h]=0,y[m]=0,y[p]=0);if(e[ds]!==void 0&&(y[g]=1/(1+Math.exp(-e[ds]))*255),y[h]=ne(Math.floor(y[h]),0,255),y[m]=ne(Math.floor(y[m]),0,255),y[p]=ne(Math.floor(y[p]),0,255),y[g]=ne(Math.floor(y[g]),0,255),E>=1&&e[Dn]!==void 0){for(let v=0;v<9;v++)y[C[v]]=e[w.sphericalHarmonicsDegree1Fields[v]];if(E>=2)for(let v=0;v<15;v++)y[C[9+v]]=e[w.sphericalHarmonicsDegree2Fields[v]]}return s.set(e[gn],e[Sn],e[Cn],e[yn]),s.normalize(),y[l]=s.x,y[c]=s.y,y[d]=s.z,y[u]=s.w,y[t]=e[xn],y[n]=e[Tn],y[o]=e[In],y}}();static readSplat(e,s,t,n,o){return q.readVertex(e,s,t,n,s.fieldsToReadIndexes,o,!0)}static parseToUncompressedSplatArray(e,s=0){const{header:t,splatCount:n,splatData:o}=us(e);return Se.decodeSectionSplatData(o,n,t,s,!0)}static parseToUncompressedSplatBuffer(e,s=0){const{header:t,splatCount:n,splatData:o}=us(e);return Se.decodeSectionSplatData(o,n,t,s,!1)}}function us(A){const e=Se.decodeHeaderFromBuffer(A),s=e.splatCount,t=Se.findSplatData(A,e);return{header:e,splatCount:s,splatData:t}}const Vs=["features_dc","features_rest_0","features_rest_1","features_rest_2","features_rest_3","features_rest_4","features_rest_5","features_rest_6","features_rest_7","features_rest_8","features_rest_9","features_rest_10","features_rest_11","features_rest_12","features_rest_13","features_rest_14","opacity","scaling","rotation_re","rotation_im"],lt=Vs.map((A,e)=>e),[ct,Fn,bn,ps,dt,Mn,vt]=[0,1,4,16,17,18,19],Ns=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","red","green","blue","f_rest_0","f_rest_1","f_rest_2","f_rest_3","f_rest_4","f_rest_5","f_rest_6","f_rest_7","f_rest_8","f_rest_9","f_rest_10","f_rest_11","f_rest_12","f_rest_13","f_rest_14","f_rest_15","f_rest_16","f_rest_17","f_rest_18","f_rest_19","f_rest_20","f_rest_21","f_rest_22","f_rest_23","f_rest_24","f_rest_25","f_rest_26","f_rest_27","f_rest_28","f_rest_29","f_rest_30","f_rest_31","f_rest_32","f_rest_33","f_rest_34","f_rest_35","f_rest_36","f_rest_37","f_rest_38","f_rest_39","f_rest_40","f_rest_41","f_rest_42","f_rest_43","f_rest_44","f_rest_45"],Pt=Ns.map((A,e)=>e),[fs,Rn,Pn,On,kn,Ln,Hn,Un,zn,_n,Ot,Gs,qs,ms]=Pt,As=Ot,Qn=Gs,Vn=qs,ht=A=>{const e=(31744&A)>>10,s=1023&A;return(A>>15?-1:1)*(e?e===31?s?NaN:1/0:Math.pow(2,e-15)*(1+s/1024):s/1024*6103515625e-14)};class Be{static decodeSectionHeadersFromHeaderLines(e){const s=Pt.reduce((c,d)=>(c[Ns[d]]=d,c),{}),t=lt.reduce((c,d)=>(c[Vs[d]]=d,c),{}),n=q.getHeaderSectionNames(e);let o;for(let c=0;c<n.length;c++)n[c]==="codebook_centers"&&(o=c);let i=0,r=!1;const a=[];let l=0;for(;!r;){let c;l===o?c=q.decodeSectionHeader(e,t,i):c=q.decodeSectionHeader(e,s,i),r=c.endOfHeader,i=c.headerEndLine+1,r||(c.splatCount=c.vertexCount,c.bytesPerSplat=c.bytesPerVertex),a.push(c),l++}return a}static decodeSectionHeadersFromHeaderText(e){const s=q.convertHeaderTextToLines(e);return Be.decodeSectionHeadersFromHeaderLines(s)}static getSplatCountFromSectionHeaders(e){let s=0;for(let t of e)t.sectionName!=="codebook_centers"&&(s+=t.vertexCount);return s}static decodeHeaderFromHeaderText(e){const s=e.indexOf(q.HeaderEndToken)+q.HeaderEndToken.length+1,t=Be.decodeSectionHeadersFromHeaderText(e),n=Be.getSplatCountFromSectionHeaders(t);return{headerSizeBytes:s,sectionHeaders:t,splatCount:n}}static decodeHeaderFromBuffer(e){const s=q.readHeaderFromBuffer(e);return Be.decodeHeaderFromHeaderText(s)}static findVertexData(e,s,t){let n=s.headerSizeBytes;for(let o=0;o<t&&o<s.sectionHeaders.length;o++){const i=s.sectionHeaders[o];n+=i.dataSizeBytes}return new DataView(e,n,s.sectionHeaders[t].dataSizeBytes)}static decodeCodeBook(e,s){const t=[],n=[];for(let o=0;o<s.vertexCount;o++){q.readVertex(e,s,o,0,lt,t);for(let i of lt){const r=lt[i];let a=n[r];a||(n[r]=a=[]),a.push(t[i])}}for(let o=0;o<n.length;o++){const i=n[o],r=.28209479177387814;for(let a=0;a<i.length;a++){const l=ht(i[a]);o===ps?i[a]=Math.round(1/(1+Math.exp(-l))*255):o===ct?i[a]=Math.round((.5+r*l)*255):o===dt?i[a]=Math.exp(l):i[a]=l}}return n}static decodeSectionSplatData(e,s,t,n,o){o=Math.min(o,t.sphericalHarmonicsDegree);const i=new P(o);for(let r=0;r<s;r++){const a=Be.parseToUncompressedSplat(e,r,t,n,0,o);i.addSplat(a)}return i}static parseToUncompressedSplat=function(){let e=[];const s=new f.Quaternion,t=P.OFFSET.X,n=P.OFFSET.Y,o=P.OFFSET.Z,i=P.OFFSET.SCALE0,r=P.OFFSET.SCALE1,a=P.OFFSET.SCALE2,l=P.OFFSET.ROTATION0,c=P.OFFSET.ROTATION1,d=P.OFFSET.ROTATION2,u=P.OFFSET.ROTATION3,h=P.OFFSET.FDC0,m=P.OFFSET.FDC1,p=P.OFFSET.FDC2,g=P.OFFSET.OPACITY,C=[];for(let S=0;S<45;S++)C[S]=P.OFFSET.FRC0+S;return function(S,T,w,x,E=0,y=0){y=Math.min(y,w.sphericalHarmonicsDegree),Be.readSplat(S,w,T,E,e);const v=P.createSplat(y);if(e[fs]!==void 0?(v[i]=x[dt][e[fs]],v[r]=x[dt][e[Rn]],v[a]=x[dt][e[Pn]]):(v[i]=.01,v[r]=.01,v[a]=.01),e[Ot]!==void 0?(v[h]=x[ct][e[Ot]],v[m]=x[ct][e[Gs]],v[p]=x[ct][e[qs]]):e[As]!==void 0?(v[h]=e[As]*255,v[m]=e[Qn]*255,v[p]=e[Vn]*255):(v[h]=0,v[m]=0,v[p]=0),e[ms]!==void 0&&(v[g]=x[ps][e[ms]]),v[h]=ne(Math.floor(v[h]),0,255),v[m]=ne(Math.floor(v[m]),0,255),v[p]=ne(Math.floor(v[p]),0,255),v[g]=ne(Math.floor(v[g]),0,255),y>=1&&w.sphericalHarmonicsDegree>=1){for(let k=0;k<9;k++){const M=x[Fn+k%3];v[C[k]]=M[e[w.sphericalHarmonicsDegree1Fields[k]]]}if(y>=2&&w.sphericalHarmonicsDegree>=2)for(let k=0;k<15;k++){const M=x[bn+k%5];v[C[9+k]]=M[e[w.sphericalHarmonicsDegree2Fields[k]]]}}const D=x[Mn][e[On]],b=x[vt][e[kn]],F=x[vt][e[Ln]],R=x[vt][e[Hn]];return s.set(D,b,F,R),s.normalize(),v[l]=s.x,v[c]=s.y,v[d]=s.z,v[u]=s.w,v[t]=ht(e[Un]),v[n]=ht(e[zn]),v[o]=ht(e[_n]),v}}();static readSplat(e,s,t,n,o){return q.readVertex(e,s,t,n,Pt,o,!1)}static parseToUncompressedSplatArray(e,s=0){const t=[],n=Be.decodeHeaderFromBuffer(e,s);let o;for(let r=0;r<n.sectionHeaders.length;r++){const a=n.sectionHeaders[r];if(a.sectionName==="codebook_centers"){const l=Be.findVertexData(e,n,r);o=Be.decodeCodeBook(l,a)}}for(let r=0;r<n.sectionHeaders.length;r++){const a=n.sectionHeaders[r];if(a.sectionName!=="codebook_centers"){const l=a.vertexCount,c=Be.findVertexData(e,n,r),d=Be.decodeSectionSplatData(c,l,a,o,s);t.push(d)}}const i=new P(s);for(let r of t)for(let a of r.splats)i.addSplat(a);return i}}class gs{static parseToUncompressedSplatArray(e,s=0){const t=q.determineHeaderFormatFromPlyBuffer(e);if(t===Ce.PlayCanvasCompressed)return G.parseToUncompressedSplatArray(e,s);if(t===Ce.INRIAV1)return Se.parseToUncompressedSplatArray(e,s);if(t===Ce.INRIAV2)return Be.parseToUncompressedSplatArray(e,s)}static parseToUncompressedSplatBuffer(e,s=0){const t=q.determineHeaderFormatFromPlyBuffer(e);if(t===Ce.PlayCanvasCompressed)return G.parseToUncompressedSplatBuffer(e,s);if(t===Ce.INRIAV1)return Se.parseToUncompressedSplatBuffer(e,s);if(t===Ce.INRIAV2)throw new Error("parseToUncompressedSplatBuffer() is not implemented for INRIA V2 PLY files")}}class qt{constructor(e,s,t,n){this.sectionCount=e,this.sectionFilters=s,this.groupingParameters=t,this.partitionGenerator=n}partitionUncompressedSplatArray(e){let s,t,n;if(this.partitionGenerator){const i=this.partitionGenerator(e);s=i.groupingParameters,t=i.sectionCount,n=i.sectionFilters}else s=this.groupingParameters,t=this.sectionCount,n=this.sectionFilters;const o=[];for(let i=0;i<t;i++){const r=new P(e.sphericalHarmonicsDegree),a=n[i];for(let l=0;l<e.splatCount;l++)a(l)&&r.addSplat(e.splats[l]);o.push(r)}return{splatArrays:o,parameters:s}}static getStandardPartitioner(e=0,s=new f.Vector3,t=I.BucketBlockSize,n=I.BucketSize){const o=i=>{const r=P.OFFSET.X,a=P.OFFSET.Y,l=P.OFFSET.Z;e<=0&&(e=i.splatCount);const c=new f.Vector3,d=.5,u=C=>{C.x=Math.floor(C.x/d)*d,C.y=Math.floor(C.y/d)*d,C.z=Math.floor(C.z/d)*d};i.splats.forEach(C=>{c.set(C[r],C[a],C[l]).sub(s),u(c),C.centerDist=c.lengthSq()}),i.splats.sort((C,S)=>{let T=C.centerDist,w=S.centerDist;return T>w?1:-1});const h=[],m=[];e=Math.min(i.splatCount,e);const p=Math.ceil(i.splatCount/e);let g=0;for(let C=0;C<p;C++){let S=g;h.push(T=>T>=S&&T<S+e),m.push({blocksSize:t,bucketSize:n}),g+=e}return{sectionCount:h.length,sectionFilters:h,groupingParameters:m}};return new qt(void 0,void 0,void 0,o)}}class rt{constructor(e,s,t,n,o,i,r){this.splatPartitioner=e,this.alphaRemovalThreshold=s,this.compressionLevel=t,this.sectionSize=n,this.sceneCenter=o?new f.Vector3().copy(o):void 0,this.blockSize=i,this.bucketSize=r}generateFromUncompressedSplatArray(e){const s=this.splatPartitioner.partitionUncompressedSplatArray(e);return I.generateFromUncompressedSplatArrays(s.splatArrays,this.alphaRemovalThreshold,this.compressionLevel,this.sceneCenter,this.blockSize,this.bucketSize,s.parameters)}static getStandardGenerator(e=1,s=1,t=0,n=new f.Vector3,o=I.BucketBlockSize,i=I.BucketSize){const r=qt.getStandardPartitioner(t,n,o,i);return new rt(r,e,s,t,n,o,i)}}const de={Downloading:0,Processing:1,Done:2};class At extends Error{constructor(e){super(e)}}const $={ProgressiveToSplatBuffer:0,ProgressiveToSplatArray:1,DownloadBeforeProcessing:2};function Ss(A,e){let s=0;for(let n of A)s+=n.sizeBytes;(!e||e.byteLength<s)&&(e=new ArrayBuffer(s));let t=0;for(let n of A)new Uint8Array(e,t,n.sizeBytes).set(n.data),t+=n.sizeBytes;return e}function Cs(A,e,s,t,n,o,i,r){return e?rt.getStandardGenerator(s,t,n,o,i,r).generateFromUncompressedSplatArray(A):I.generateFromUncompressedSplatArrays([A],s,0,new f.Vector3)}class Wt{static loadFromURL(e,s,t,n,o,i,r=!0,a=0,l,c,d,u,h){let m;!t&&!r?m=$.DownloadBeforeProcessing:r?m=$.ProgressiveToSplatArray:m=$.ProgressiveToSplatBuffer;const p=j.ProgressiveLoadSectionSize,g=I.HeaderSizeBytes+I.SectionHeaderSizeBytes,C=1;let S,T,w,x,E,y=0,v=0,D=0,b=!1,F=!1,R=!1;const k=kt();let M=0,O=0,L=0,U=0,_="",H=null,Q=[],Z;const ie=new TextDecoder,V=(ee,X,N)=>{const Y=ee>=100;if(N&&(Q.push({data:N,sizeBytes:N.byteLength,startBytes:L,endBytes:L+N.byteLength}),L+=N.byteLength),m===$.DownloadBeforeProcessing)Y&&k.resolve(Q);else{if(b){if(S===Ce.PlayCanvasCompressed&&!F){const ae=H.headerSizeBytes+H.chunkElement.storageSizeBytes;E=Ss(Q,E),E.byteLength>=ae&&(G.readElementData(H.chunkElement,E,H.headerSizeBytes),M=ae,O=ae,F=!0)}}else if(_+=ie.decode(N),q.checkTextForEndHeader(_)){if(S=q.determineHeaderFormatFromHeaderText(_),S===Ce.INRIAV1)H=Se.decodeHeaderText(_),a=Math.min(a,H.sphericalHarmonicsDegree),y=H.splatCount,F=!0,U=H.headerSizeBytes+H.bytesPerSplat*y;else if(S===Ce.PlayCanvasCompressed){if(H=G.decodeHeaderText(_),a=Math.min(a,H.sphericalHarmonicsDegree),m===$.ProgressiveToSplatBuffer&&a>0)throw new At("PlyLoader.loadFromURL() -> Selected PLY format has spherical harmonics data that cannot be progressively loaded.");y=H.vertexElement.count,U=H.headerSizeBytes+H.bytesPerSplat*y+H.chunkElement.storageSizeBytes}else{if(m===$.ProgressiveToSplatBuffer)throw new At("PlyLoader.loadFromURL() -> Selected PLY format cannot be progressively loaded.");m=$.DownloadBeforeProcessing;return}if(m===$.ProgressiveToSplatBuffer){const ae=I.CompressionLevels[0].SphericalHarmonicsDegrees[a],le=g+ae.BytesPerSplat*y;w=new ArrayBuffer(le),I.writeHeaderToBuffer({versionMajor:I.CurrentMajorVersion,versionMinor:I.CurrentMinorVersion,maxSectionCount:C,sectionCount:C,maxSplatCount:y,splatCount:0,compressionLevel:0,sceneCenter:new f.Vector3},w)}else Z=new P(a);M=H.headerSizeBytes,O=H.headerSizeBytes,b=!0}if(b&&F&&Q.length>0&&(T=Ss(Q,T),L-M>p||L>=U&&!R||Y)){const le=R?H.sphericalHarmonicsPerSplat:H.bytesPerSplat,Ae=(R?L:Math.min(U,L))-O,he=Math.floor(Ae/le),te=he*le,ue=L-O-te,J=O-Q[0].startBytes,Ee=new DataView(T,J,te);if(R)S===Ce.PlayCanvasCompressed&&m===$.ProgressiveToSplatArray&&(G.parseSphericalHarmonicsToUncompressedSplatArraySection(H.chunkElement,H.shElement,D,D+he-1,Ee,0,a,H.sphericalHarmonicsDegree,Z),D+=he);else{if(m===$.ProgressiveToSplatBuffer){const De=I.CompressionLevels[0].SphericalHarmonicsDegrees[a],me=v*De.BytesPerSplat+g;S===Ce.PlayCanvasCompressed?G.parseToUncompressedSplatBufferSection(H.chunkElement,H.vertexElement,0,he-1,v,Ee,w,me):Se.parseToUncompressedSplatBufferSection(H,0,he-1,Ee,0,w,me,a)}else S===Ce.PlayCanvasCompressed?G.parseToUncompressedSplatArraySection(H.chunkElement,H.vertexElement,0,he-1,v,Ee,Z):Se.parseToUncompressedSplatArraySection(H,0,he-1,Ee,0,Z,a);v+=he,m===$.ProgressiveToSplatBuffer&&(x||(I.writeSectionHeaderToBuffer({maxSplatCount:y,splatCount:v,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0,sphericalHarmonicsDegree:a},0,w,I.HeaderSizeBytes),x=new I(w,!1)),x.updateLoadedCounts(1,v)),L>=U&&(R=!0)}if(ue===0)Q=[];else{let De=[],me=0;for(let xe=Q.length-1;xe>=0;xe--){const ke=Q[xe];if(me+=ke.sizeBytes,De.unshift(ke),me>=ue)break}Q=De}M+=p,O+=te}n&&x&&n(x,Y),Y&&(m===$.ProgressiveToSplatBuffer?k.resolve(x):k.resolve(Z))}s&&s(ee,X,de.Downloading)};return s&&s(0,"0%",de.Downloading),yt(e,V,!1,l).then(()=>(s&&s(0,"0%",de.Processing),k.promise.then(ee=>{if(s&&s(100,"100%",de.Done),m===$.DownloadBeforeProcessing){const X=Q.map(N=>N.data);return new Blob(X).arrayBuffer().then(N=>Wt.loadFromFileData(N,o,i,r,a,c,d,u,h))}else return m===$.ProgressiveToSplatBuffer?ee:we(()=>Cs(ee,r,o,i,c,d,u,h))})))}static loadFromFileData(e,s,t,n,o=0,i,r,a,l){return n?we(()=>gs.parseToUncompressedSplatArray(e,o)).then(c=>Cs(c,n,s,t,i,r,a,l)):we(()=>gs.parseToUncompressedSplatBuffer(e,o))}}const Nn=A=>new ReadableStream({async start(e){e.enqueue(A),e.close()}});async function Gn(A){try{const e=Nn(A);if(!e)throw new Error("Failed to create stream from data");return await qn(e)}catch(e){throw console.error("Error decompressing gzipped data:",e),e}}async function qn(A){const e=A.pipeThrough(new DecompressionStream("gzip")),t=await new Response(e).arrayBuffer();return new Uint8Array(t)}const Wn=1347635022,Kn=1,jn=.15;function Yn(A){const e=A>>15&1,s=A>>10&31,t=A&1023,n=e===1?-1:1;return s===0?n*Math.pow(2,-14)*t/1024:s===31?t!==0?NaN:n*(1/0):n*Math.pow(2,s-15)*(1+t/1024)}function Xn(A){return(A-128)/128}function ze(A){switch(A){case 0:return 0;case 1:return 3;case 2:return 8;case 3:return 15;default:return console.error(`[SPZ: ERROR] Unsupported SH degree: ${A}`),0}}const Jn=function(){let A=[];const e=new f.Quaternion,s=P.OFFSET.X,t=P.OFFSET.Y,n=P.OFFSET.Z,o=P.OFFSET.SCALE0,i=P.OFFSET.SCALE1,r=P.OFFSET.SCALE2,a=P.OFFSET.ROTATION0,l=P.OFFSET.ROTATION1,c=P.OFFSET.ROTATION2,d=P.OFFSET.ROTATION3,u=P.OFFSET.FDC0,h=P.OFFSET.FDC1,m=P.OFFSET.FDC2,p=P.OFFSET.OPACITY,g=[ze(0),ze(1),ze(2),ze(3)],C=[0,1,2,9,10,11,12,13,24,25,26,27,28,29,30,3,4,5,14,15,16,17,18,31,32,33,34,35,36,37,6,7,8,19,20,21,22,23,38,39,40,41,42,43,44];return function(S,T,w){w=Math.min(T,w);const x=P.createSplat(w);S.scale[0]!==void 0?(x[o]=S.scale[0],x[i]=S.scale[1],x[r]=S.scale[2]):(x[o]=.01,x[i]=.01,x[r]=.01),S.color[0]!==void 0?(x[u]=S.color[0],x[h]=S.color[1],x[m]=S.color[2]):A[RED]!==void 0?(x[u]=A[RED]*255,x[h]=A[GREEN]*255,x[m]=A[BLUE]*255):(x[u]=0,x[h]=0,x[m]=0),S.alpha!==void 0&&(x[p]=S.alpha),x[u]=ne(Math.floor(x[u]),0,255),x[h]=ne(Math.floor(x[h]),0,255),x[m]=ne(Math.floor(x[m]),0,255),x[p]=ne(Math.floor(x[p]),0,255);let E=g[w],y=g[T];for(let v=0;v<3;++v)for(let D=0;D<15;++D){const b=C[v*15+D];D<E&&D<y&&(x[P.OFFSET.FRC0+b]=S.sh[v*y+D])}return e.set(S.rotation[3],S.rotation[0],S.rotation[1],S.rotation[2]),e.normalize(),x[a]=e.x,x[l]=e.y,x[c]=e.z,x[d]=e.w,x[s]=S.position[0],x[t]=S.position[1],x[n]=S.position[2],x}}();function Zn(A,e,s,t){return!(A.positions.length!==e*3*(t?2:3)||A.scales.length!==e*3||A.rotations.length!==e*3||A.alphas.length!==e||A.colors.length!==e*3||A.sh.length!==e*s*3)}function ys(A,e,s,t,n){e=Math.min(e,A.shDegree);const o=A.numPoints,i=ze(A.shDegree),r=A.positions.length===o*3*2;if(!Zn(A,o,i,r))return null;const a={position:[],scale:[],rotation:[],alpha:void 0,color:[],sh:[]};let l;r&&(l=new Uint16Array(A.positions.buffer,A.positions.byteOffset,o*3));const c=1/(1<<A.fractionalBits),d=ze(A.shDegree),u=.28209479177387814;for(let h=0;h<o;h++){if(r)for(let S=0;S<3;S++)a.position[S]=Yn(l[h*3+S]);else for(let S=0;S<3;S++){const T=h*9+S*3;let w=A.positions[T];w|=A.positions[T+1]<<8,w|=A.positions[T+2]<<16,w|=w&8388608?4278190080:0,a.position[S]=w*c}for(let S=0;S<3;S++)a.scale[S]=Math.exp(A.scales[h*3+S]/16-10);const m=A.rotations.subarray(h*3,h*3+3),p=[m[0]/127.5-1,m[1]/127.5-1,m[2]/127.5-1];a.rotation[0]=p[0],a.rotation[1]=p[1],a.rotation[2]=p[2];const g=p[0]*p[0]+p[1]*p[1]+p[2]*p[2];a.rotation[3]=Math.sqrt(Math.max(0,1-g)),a.alpha=Math.floor(A.alphas[h]);for(let S=0;S<3;S++)a.color[S]=Math.floor(((A.colors[h*3+S]/255-.5)/jn*u+.5)*255);for(let S=0;S<3;S++)for(let T=0;T<d;T++)a.sh[S*d+T]=Xn(A.sh[d*3*h+T*3+S]);const C=Jn(a,A.shDegree,e);if(s){const S=I.CompressionLevels[0].SphericalHarmonicsDegrees[e].BytesPerSplat,T=h*S+n;I.writeSplatDataToSectionBuffer(C,t,T,0,e)}else t.addSplat(C)}}const $n=16,eo=1e7;function to(A){const e=new DataView(A);let s=0;const t={magic:e.getUint32(s,!0),version:e.getUint32(s+4,!0),numPoints:e.getUint32(s+8,!0),shDegree:e.getUint8(s+12),fractionalBits:e.getUint8(s+13),flags:e.getUint8(s+14),reserved:e.getUint8(s+15)};if(s+=$n,t.magic!==Wn)return console.error("[SPZ ERROR] deserializePackedGaussians: header not found"),null;if(t.version<1||t.version>2)return console.error(`[SPZ ERROR] deserializePackedGaussians: version not supported: ${t.version}`),null;if(t.numPoints>eo)return console.error(`[SPZ ERROR] deserializePackedGaussians: Too many points: ${t.numPoints}`),null;if(t.shDegree>3)return console.error(`[SPZ ERROR] deserializePackedGaussians: Unsupported SH degree: ${t.shDegree}`),null;const n=t.numPoints,o=ze(t.shDegree),i=t.version===1,r={numPoints:n,shDegree:t.shDegree,fractionalBits:t.fractionalBits,antialiased:(t.flags&Kn)!==0,positions:new Uint8Array(n*3*(i?2:3)),scales:new Uint8Array(n*3),rotations:new Uint8Array(n*3),alphas:new Uint8Array(n),colors:new Uint8Array(n*3),sh:new Uint8Array(n*o*3)};try{const a=new Uint8Array(A);let l=r.positions.length,c=s;if(r.positions.set(a.slice(c,c+l)),c+=l,r.alphas.set(a.slice(c,c+r.alphas.length)),c+=r.alphas.length,r.colors.set(a.slice(c,c+r.colors.length)),c+=r.colors.length,r.scales.set(a.slice(c,c+r.scales.length)),c+=r.scales.length,r.rotations.set(a.slice(c,c+r.rotations.length)),c+=r.rotations.length,r.sh.set(a.slice(c,c+r.sh.length)),c+r.sh.length!==A.byteLength)return console.error("[SPZ ERROR] deserializePackedGaussians: incorrect buffer size"),null}catch(a){return console.error("[SPZ ERROR] deserializePackedGaussians: read error",a),null}return r}async function so(A){try{const e=await Gn(A);return to(e.buffer)}catch(e){return console.error("[SPZ ERROR] loadSpzPacked: decompression error",e),null}}class Kt{static loadFromURL(e,s,t,n,o=!0,i=0,r,a,l,c,d){return s&&s(0,"0%",de.Downloading),yt(e,s,!0,r).then(u=>(s&&s(0,"0%",de.Processing),Kt.loadFromFileData(u,t,n,o,i,a,l,c,d)))}static async loadFromFileData(e,s,t,n,o=0,i,r,a,l){await we();const c=await so(e);o=Math.min(c.shDegree,o);const d=new P(o);if(n)return ys(c,o,!1,d,0),rt.getStandardGenerator(s,t,i,r,a,l).generateFromUncompressedSplatArray(d);{const{splatBuffer:u,splatBufferDataOffsetBytes:h}=I.preallocateUncompressed(c.numPoints,o);return ys(c,o,!0,u.bufferData,h),u}}}class K{static RowSizeBytes=32;static CenterSizeBytes=12;static ScaleSizeBytes=12;static RotationSizeBytes=4;static ColorSizeBytes=4;static parseToUncompressedSplatBufferSection(e,s,t,n,o,i){const r=I.CompressionLevels[0].BytesPerCenter,a=I.CompressionLevels[0].BytesPerScale,l=I.CompressionLevels[0].BytesPerRotation,c=I.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat;for(let d=e;d<=s;d++){const u=d*K.RowSizeBytes+n,h=new Float32Array(t,u,3),m=new Float32Array(t,u+K.CenterSizeBytes,3),p=new Uint8Array(t,u+K.CenterSizeBytes+K.ScaleSizeBytes,4),g=new Uint8Array(t,u+K.CenterSizeBytes+K.ScaleSizeBytes+K.RotationSizeBytes,4),C=new f.Quaternion((g[1]-128)/128,(g[2]-128)/128,(g[3]-128)/128,(g[0]-128)/128);C.normalize();const S=d*c+i,T=new Float32Array(o,S,3),w=new Float32Array(o,S+r,3),x=new Float32Array(o,S+r+a,4),E=new Uint8Array(o,S+r+a+l,4);T[0]=h[0],T[1]=h[1],T[2]=h[2],w[0]=m[0],w[1]=m[1],w[2]=m[2],x[0]=C.w,x[1]=C.x,x[2]=C.y,x[3]=C.z,E[0]=p[0],E[1]=p[1],E[2]=p[2],E[3]=p[3]}}static parseToUncompressedSplatArraySection(e,s,t,n,o){for(let i=e;i<=s;i++){const r=i*K.RowSizeBytes+n,a=new Float32Array(t,r,3),l=new Float32Array(t,r+K.CenterSizeBytes,3),c=new Uint8Array(t,r+K.CenterSizeBytes+K.ScaleSizeBytes,4),d=new Uint8Array(t,r+K.CenterSizeBytes+K.ScaleSizeBytes+K.RotationSizeBytes,4),u=new f.Quaternion((d[1]-128)/128,(d[2]-128)/128,(d[3]-128)/128,(d[0]-128)/128);u.normalize(),o.addSplatFromComonents(a[0],a[1],a[2],l[0],l[1],l[2],u.w,u.x,u.y,u.z,c[0],c[1],c[2],c[3])}}static parseStandardSplatToUncompressedSplatArray(e){const s=e.byteLength/K.RowSizeBytes,t=new P;for(let n=0;n<s;n++){const o=n*K.RowSizeBytes,i=new Float32Array(e,o,3),r=new Float32Array(e,o+K.CenterSizeBytes,3),a=new Uint8Array(e,o+K.CenterSizeBytes+K.ScaleSizeBytes,4),l=new Uint8Array(e,o+K.CenterSizeBytes+K.ScaleSizeBytes+K.ColorSizeBytes,4),c=new f.Quaternion((l[1]-128)/128,(l[2]-128)/128,(l[3]-128)/128,(l[0]-128)/128);c.normalize(),t.addSplatFromComonents(i[0],i[1],i[2],r[0],r[1],r[2],c.w,c.x,c.y,c.z,a[0],a[1],a[2],a[3])}return t}}function xs(A,e,s,t,n,o,i,r){return e?rt.getStandardGenerator(s,t,n,o,i,r).generateFromUncompressedSplatArray(A):I.generateFromUncompressedSplatArrays([A],s,0,new f.Vector3)}class jt{static loadFromURL(e,s,t,n,o,i,r=!0,a,l,c,d,u){let h=t?$.ProgressiveToSplatBuffer:$.ProgressiveToSplatArray;r&&(h=$.ProgressiveToSplatArray);const m=I.HeaderSizeBytes+I.SectionHeaderSizeBytes,p=j.ProgressiveLoadSectionSize,g=1;let C,S,T,w=0,x=0,E;const y=kt();let v=0,D=0,b=[];const F=(R,k,M,O)=>{const L=R>=100;if(M&&b.push(M),h===$.DownloadBeforeProcessing){L&&y.resolve(b);return}if(!O){if(t)throw new At("Cannon directly load .splat because no file size info is available.");h=$.DownloadBeforeProcessing;return}if(!C){w=O/K.RowSizeBytes,C=new ArrayBuffer(O);const U=I.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,_=m+U*w;h===$.ProgressiveToSplatBuffer?(S=new ArrayBuffer(_),I.writeHeaderToBuffer({versionMajor:I.CurrentMajorVersion,versionMinor:I.CurrentMinorVersion,maxSectionCount:g,sectionCount:g,maxSplatCount:w,splatCount:x,compressionLevel:0,sceneCenter:new f.Vector3},S)):E=new P(0)}if(M){new Uint8Array(C,D,M.byteLength).set(new Uint8Array(M)),D+=M.byteLength;const U=D-v;if(U>p||L){const H=(L?U:p)/K.RowSizeBytes,Q=x+H;h===$.ProgressiveToSplatBuffer?K.parseToUncompressedSplatBufferSection(x,Q-1,C,0,S,m):K.parseToUncompressedSplatArraySection(x,Q-1,C,0,E),x=Q,h===$.ProgressiveToSplatBuffer&&(T||(I.writeSectionHeaderToBuffer({maxSplatCount:w,splatCount:x,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0},0,S,I.HeaderSizeBytes),T=new I(S,!1)),T.updateLoadedCounts(1,x),n&&n(T,L)),v+=p}}L&&(h===$.ProgressiveToSplatBuffer?y.resolve(T):y.resolve(E)),s&&s(R,k,de.Downloading)};return s&&s(0,"0%",de.Downloading),yt(e,F,!1,a).then(()=>(s&&s(0,"0%",de.Processing),y.promise.then(R=>(s&&s(100,"100%",de.Done),h===$.DownloadBeforeProcessing?new Blob(b).arrayBuffer().then(k=>jt.loadFromFileData(k,o,i,r,l,c,d,u)):h===$.ProgressiveToSplatBuffer?R:we(()=>xs(R,r,o,i,l,c,d,u))))))}static loadFromFileData(e,s,t,n,o,i,r,a){return we(()=>{const l=K.parseStandardSplatToUncompressedSplatArray(e);return xs(l,n,s,t,o,i,r,a)})}}class tt{static checkVersion(e){const s=I.CurrentMajorVersion,t=I.CurrentMinorVersion,n=I.parseHeader(e);if(n.versionMajor===s&&n.versionMinor>=t||n.versionMajor>s)return!0;throw new Error(`KSplat version not supported: v${n.versionMajor}.${n.versionMinor}. Minimum required: v${s}.${t}`)}static loadFromURL(e,s,t,n,o){let i,r,a,l,c=!1,d=!1,u,h=[],m=!1,p=!1,g=0,C=0,S=0,T=!1,w=!1,x=!1,E=[];const y=kt(),v=()=>{!c&&!d&&g>=I.HeaderSizeBytes&&(d=!0,new Blob(E).arrayBuffer().then(O=>{a=new ArrayBuffer(I.HeaderSizeBytes),new Uint8Array(a).set(new Uint8Array(O,0,I.HeaderSizeBytes)),tt.checkVersion(a),d=!1,c=!0,l=I.parseHeader(a),window.setTimeout(()=>{F()},1)}))};let D=0;const b=()=>{D===0&&(D++,window.setTimeout(()=>{D--,R()},1))},F=()=>{const M=()=>{p=!0,new Blob(E).arrayBuffer().then(L=>{p=!1,m=!0,u=new ArrayBuffer(l.maxSectionCount*I.SectionHeaderSizeBytes),new Uint8Array(u).set(new Uint8Array(L,I.HeaderSizeBytes,l.maxSectionCount*I.SectionHeaderSizeBytes)),h=I.parseSectionHeaders(l,u,0,!1);let U=0;for(let H=0;H<l.maxSectionCount;H++)U+=h[H].storageSizeBytes;const _=I.HeaderSizeBytes+l.maxSectionCount*I.SectionHeaderSizeBytes+U;if(!i){i=new ArrayBuffer(_);let H=0;for(let Q=0;Q<E.length;Q++){const Z=E[Q];new Uint8Array(i,H,Z.byteLength).set(new Uint8Array(Z)),H+=Z.byteLength}}S=I.HeaderSizeBytes+I.SectionHeaderSizeBytes*l.maxSectionCount;for(let H=0;H<=h.length&&H<l.maxSectionCount;H++)S+=h[H].storageSizeBytes;b()})};!p&&!m&&c&&g>=I.HeaderSizeBytes+I.SectionHeaderSizeBytes*l.maxSectionCount&&M()},R=()=>{if(x)return;x=!0;const M=()=>{if(x=!1,m){if(w)return;if(T=g>=S,g-C>j.ProgressiveLoadSectionSize||T){C+=j.ProgressiveLoadSectionSize,w=C>=S,r||(r=new I(i,!1));const L=I.HeaderSizeBytes+I.SectionHeaderSizeBytes*l.maxSectionCount;let U=0,_=0,H=0;for(let ie=0;ie<l.maxSectionCount;ie++){const V=h[ie],ee=U+V.partiallyFilledBucketCount*4+V.bucketStorageSizeBytes*V.bucketCount,X=L+ee;if(C>=X){_++;const N=C-X,le=I.CompressionLevels[l.compressionLevel].SphericalHarmonicsDegrees[V.sphericalHarmonicsDegree].BytesPerSplat;let oe=Math.floor(N/le);oe=Math.min(oe,V.maxSplatCount),H+=oe,r.updateLoadedCounts(_,H),r.updateSectionLoadedCounts(ie,oe)}else break;U+=V.storageSizeBytes}n(r,w);const Q=C/S*100,Z=Q.toFixed(2)+"%";s&&s(Q,Z,de.Downloading),w?y.resolve(r):R()}}};window.setTimeout(M,j.ProgressiveLoadSectionDelayDuration)};return yt(e,(M,O,L)=>{L&&(E.push(L),i&&new Uint8Array(i,g,L.byteLength).set(new Uint8Array(L)),g+=L.byteLength),t?(v(),F(),R()):s&&s(M,O,de.Downloading)},!t,o).then(M=>(s&&s(0,"0%",de.Processing),(t?y.promise:tt.loadFromFileData(M)).then(L=>(s&&s(100,"100%",de.Done),L))))}static loadFromFileData(e){return we(()=>(tt.checkVersion(e),new I(e)))}static downloadFile=function(){let e;return function(s,t){const n=new Blob([s.bufferData],{type:"application/octet-stream"});e||(e=document.createElement("a"),document.body.appendChild(e)),e.download=t,e.href=URL.createObjectURL(n),e.click()}}()}const ye={Splat:0,KSplat:1,Ply:2,Spz:3},Ts=A=>A.endsWith(".ply")?ye.Ply:A.endsWith(".splat")?ye.Splat:A.endsWith(".ksplat")?ye.KSplat:A.endsWith(".spz")?ye.Spz:null,Is={type:"change"},Dt={type:"start"},Bs={type:"end"},ut=new en,ws=new tn,no=Math.cos(70*sn.DEG2RAD);class pt extends nn{constructor(e,s){super(),this.object=e,this.domElement=s,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new Ie,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"KeyA",UP:"KeyW",RIGHT:"KeyD",BOTTOM:"KeyS"},this.mouseButtons={LEFT:Qe.ROTATE,MIDDLE:Qe.DOLLY,RIGHT:Qe.PAN},this.touches={ONE:Ve.ROTATE,TWO:Ve.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return r.phi},this.getAzimuthalAngle=function(){return r.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(B){B.addEventListener("keydown",xt),this._domElementKeyEvents=B},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",xt),this._domElementKeyEvents=null},this.saveState=function(){t.target0.copy(t.target),t.position0.copy(t.object.position),t.zoom0=t.object.zoom},this.reset=function(){t.target.copy(t.target0),t.object.position.copy(t.position0),t.object.zoom=t.zoom0,this.clearDampedRotation(),this.clearDampedPan(),t.object.updateProjectionMatrix(),t.dispatchEvent(Is),t.update(),o=n.NONE},this.clearDampedRotation=function(){a.theta=0,a.phi=0},this.clearDampedPan=function(){c.set(0,0,0)},this.update=function(){const B=new Ie,z=new ss().setFromUnitVectors(e.up,new Ie(0,1,0)),ce=z.clone().invert(),pe=new Ie,Te=new ss,_e=new Ie,Le=2*Math.PI;return function(){z.setFromUnitVectors(e.up,new Ie(0,1,0)),ce.copy(z).invert();const ts=t.object.position;B.copy(ts).sub(t.target),B.applyQuaternion(z),r.setFromVector3(B),t.autoRotate&&o===n.NONE&&F(D()),t.enableDamping?(r.theta+=a.theta*t.dampingFactor,r.phi+=a.phi*t.dampingFactor):(r.theta+=a.theta,r.phi+=a.phi);let be=t.minAzimuthAngle,Me=t.maxAzimuthAngle;isFinite(be)&&isFinite(Me)&&(be<-Math.PI?be+=Le:be>Math.PI&&(be-=Le),Me<-Math.PI?Me+=Le:Me>Math.PI&&(Me-=Le),be<=Me?r.theta=Math.max(be,Math.min(Me,r.theta)):r.theta=r.theta>(be+Me)/2?Math.max(be,r.theta):Math.min(Me,r.theta)),r.phi=Math.max(t.minPolarAngle,Math.min(t.maxPolarAngle,r.phi)),r.makeSafe(),t.enableDamping===!0?t.target.addScaledVector(c,t.dampingFactor):t.target.add(c),t.zoomToCursor&&E||t.object.isOrthographicCamera?r.radius=H(r.radius):r.radius=H(r.radius*l),B.setFromSpherical(r),B.applyQuaternion(ce),ts.copy(t.target).add(B),t.object.lookAt(t.target),t.enableDamping===!0?(a.theta*=1-t.dampingFactor,a.phi*=1-t.dampingFactor,c.multiplyScalar(1-t.dampingFactor)):(a.set(0,0,0),c.set(0,0,0));let it=!1;if(t.zoomToCursor&&E){let Ze=null;if(t.object.isPerspectiveCamera){const $e=B.length();Ze=H($e*l);const at=$e-Ze;t.object.position.addScaledVector(w,at),t.object.updateMatrixWorld()}else if(t.object.isOrthographicCamera){const $e=new Ie(x.x,x.y,0);$e.unproject(t.object),t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom/l)),t.object.updateProjectionMatrix(),it=!0;const at=new Ie(x.x,x.y,0);at.unproject(t.object),t.object.position.sub(at).add($e),t.object.updateMatrixWorld(),Ze=B.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),t.zoomToCursor=!1;Ze!==null&&(this.screenSpacePanning?t.target.set(0,0,-1).transformDirection(t.object.matrix).multiplyScalar(Ze).add(t.object.position):(ut.origin.copy(t.object.position),ut.direction.set(0,0,-1).transformDirection(t.object.matrix),Math.abs(t.object.up.dot(ut.direction))<no?e.lookAt(t.target):(ws.setFromNormalAndCoplanarPoint(t.object.up,t.target),ut.intersectPlane(ws,t.target))))}else t.object.isOrthographicCamera&&(t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom/l)),t.object.updateProjectionMatrix(),it=!0);return l=1,E=!1,it||pe.distanceToSquared(t.object.position)>i||8*(1-Te.dot(t.object.quaternion))>i||_e.distanceToSquared(t.target)>0?(t.dispatchEvent(Is),pe.copy(t.object.position),Te.copy(t.object.quaternion),_e.copy(t.target),it=!1,!0):!1}}(),this.dispose=function(){t.domElement.removeEventListener("contextmenu",$t),t.domElement.removeEventListener("pointerdown",me),t.domElement.removeEventListener("pointercancel",ke),t.domElement.removeEventListener("wheel",Zt),t.domElement.removeEventListener("pointermove",xe),t.domElement.removeEventListener("pointerup",ke),t._domElementKeyEvents!==null&&(t._domElementKeyEvents.removeEventListener("keydown",xt),t._domElementKeyEvents=null)};const t=this,n={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let o=n.NONE;const i=1e-6,r=new ns,a=new ns;let l=1;const c=new Ie,d=new ve,u=new ve,h=new ve,m=new ve,p=new ve,g=new ve,C=new ve,S=new ve,T=new ve,w=new Ie,x=new ve;let E=!1;const y=[],v={};function D(){return 2*Math.PI/60/60*t.autoRotateSpeed}function b(){return Math.pow(.95,t.zoomSpeed)}function F(B){a.theta-=B}function R(B){a.phi-=B}const k=function(){const B=new Ie;return function(ce,pe){B.setFromMatrixColumn(pe,0),B.multiplyScalar(-ce),c.add(B)}}(),M=function(){const B=new Ie;return function(ce,pe){t.screenSpacePanning===!0?B.setFromMatrixColumn(pe,1):(B.setFromMatrixColumn(pe,0),B.crossVectors(t.object.up,B)),B.multiplyScalar(ce),c.add(B)}}(),O=function(){const B=new Ie;return function(ce,pe){const Te=t.domElement;if(t.object.isPerspectiveCamera){const _e=t.object.position;B.copy(_e).sub(t.target);let Le=B.length();Le*=Math.tan(t.object.fov/2*Math.PI/180),k(2*ce*Le/Te.clientHeight,t.object.matrix),M(2*pe*Le/Te.clientHeight,t.object.matrix)}else t.object.isOrthographicCamera?(k(ce*(t.object.right-t.object.left)/t.object.zoom/Te.clientWidth,t.object.matrix),M(pe*(t.object.top-t.object.bottom)/t.object.zoom/Te.clientHeight,t.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),t.enablePan=!1)}}();function L(B){t.object.isPerspectiveCamera||t.object.isOrthographicCamera?l/=B:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function U(B){t.object.isPerspectiveCamera||t.object.isOrthographicCamera?l*=B:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function _(B){if(!t.zoomToCursor)return;E=!0;const z=t.domElement.getBoundingClientRect(),ce=B.clientX-z.left,pe=B.clientY-z.top,Te=z.width,_e=z.height;x.x=ce/Te*2-1,x.y=-(pe/_e)*2+1,w.set(x.x,x.y,1).unproject(e).sub(e.position).normalize()}function H(B){return Math.max(t.minDistance,Math.min(t.maxDistance,B))}function Q(B){d.set(B.clientX,B.clientY)}function Z(B){_(B),C.set(B.clientX,B.clientY)}function ie(B){m.set(B.clientX,B.clientY)}function V(B){u.set(B.clientX,B.clientY),h.subVectors(u,d).multiplyScalar(t.rotateSpeed);const z=t.domElement;F(2*Math.PI*h.x/z.clientHeight),R(2*Math.PI*h.y/z.clientHeight),d.copy(u),t.update()}function ee(B){S.set(B.clientX,B.clientY),T.subVectors(S,C),T.y>0?L(b()):T.y<0&&U(b()),C.copy(S),t.update()}function X(B){p.set(B.clientX,B.clientY),g.subVectors(p,m).multiplyScalar(t.panSpeed),O(g.x,g.y),m.copy(p),t.update()}function N(B){_(B),B.deltaY<0?U(b()):B.deltaY>0&&L(b()),t.update()}function Y(B){let z=!1;switch(B.code){case t.keys.UP:B.ctrlKey||B.metaKey||B.shiftKey?R(2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):O(0,t.keyPanSpeed),z=!0;break;case t.keys.BOTTOM:B.ctrlKey||B.metaKey||B.shiftKey?R(-2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):O(0,-t.keyPanSpeed),z=!0;break;case t.keys.LEFT:B.ctrlKey||B.metaKey||B.shiftKey?F(2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):O(t.keyPanSpeed,0),z=!0;break;case t.keys.RIGHT:B.ctrlKey||B.metaKey||B.shiftKey?F(-2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):O(-t.keyPanSpeed,0),z=!0;break}z&&(B.preventDefault(),t.update())}function ae(){if(y.length===1)d.set(y[0].pageX,y[0].pageY);else{const B=.5*(y[0].pageX+y[1].pageX),z=.5*(y[0].pageY+y[1].pageY);d.set(B,z)}}function le(){if(y.length===1)m.set(y[0].pageX,y[0].pageY);else{const B=.5*(y[0].pageX+y[1].pageX),z=.5*(y[0].pageY+y[1].pageY);m.set(B,z)}}function oe(){const B=y[0].pageX-y[1].pageX,z=y[0].pageY-y[1].pageY,ce=Math.sqrt(B*B+z*z);C.set(0,ce)}function Ae(){t.enableZoom&&oe(),t.enablePan&&le()}function he(){t.enableZoom&&oe(),t.enableRotate&&ae()}function te(B){if(y.length==1)u.set(B.pageX,B.pageY);else{const ce=Tt(B),pe=.5*(B.pageX+ce.x),Te=.5*(B.pageY+ce.y);u.set(pe,Te)}h.subVectors(u,d).multiplyScalar(t.rotateSpeed);const z=t.domElement;F(2*Math.PI*h.x/z.clientHeight),R(2*Math.PI*h.y/z.clientHeight),d.copy(u)}function ue(B){if(y.length===1)p.set(B.pageX,B.pageY);else{const z=Tt(B),ce=.5*(B.pageX+z.x),pe=.5*(B.pageY+z.y);p.set(ce,pe)}g.subVectors(p,m).multiplyScalar(t.panSpeed),O(g.x,g.y),m.copy(p)}function J(B){const z=Tt(B),ce=B.pageX-z.x,pe=B.pageY-z.y,Te=Math.sqrt(ce*ce+pe*pe);S.set(0,Te),T.set(0,Math.pow(S.y/C.y,t.zoomSpeed)),L(T.y),C.copy(S)}function Ee(B){t.enableZoom&&J(B),t.enablePan&&ue(B)}function De(B){t.enableZoom&&J(B),t.enableRotate&&te(B)}function me(B){t.enabled!==!1&&(y.length===0&&(t.domElement.setPointerCapture(B.pointerId),t.domElement.addEventListener("pointermove",xe),t.domElement.addEventListener("pointerup",ke)),Xs(B),B.pointerType==="touch"?js(B):Ws(B))}function xe(B){t.enabled!==!1&&(B.pointerType==="touch"?Ys(B):Ks(B))}function ke(B){Js(B),y.length===0&&(t.domElement.releasePointerCapture(B.pointerId),t.domElement.removeEventListener("pointermove",xe),t.domElement.removeEventListener("pointerup",ke)),t.dispatchEvent(Bs),o=n.NONE}function Ws(B){let z;switch(B.button){case 0:z=t.mouseButtons.LEFT;break;case 1:z=t.mouseButtons.MIDDLE;break;case 2:z=t.mouseButtons.RIGHT;break;default:z=-1}switch(z){case Qe.DOLLY:if(t.enableZoom===!1)return;Z(B),o=n.DOLLY;break;case Qe.ROTATE:if(B.ctrlKey||B.metaKey||B.shiftKey){if(t.enablePan===!1)return;ie(B),o=n.PAN}else{if(t.enableRotate===!1)return;Q(B),o=n.ROTATE}break;case Qe.PAN:if(B.ctrlKey||B.metaKey||B.shiftKey){if(t.enableRotate===!1)return;Q(B),o=n.ROTATE}else{if(t.enablePan===!1)return;ie(B),o=n.PAN}break;default:o=n.NONE}o!==n.NONE&&t.dispatchEvent(Dt)}function Ks(B){switch(o){case n.ROTATE:if(t.enableRotate===!1)return;V(B);break;case n.DOLLY:if(t.enableZoom===!1)return;ee(B);break;case n.PAN:if(t.enablePan===!1)return;X(B);break}}function Zt(B){t.enabled===!1||t.enableZoom===!1||o!==n.NONE||(B.preventDefault(),t.dispatchEvent(Dt),N(B),t.dispatchEvent(Bs))}function xt(B){t.enabled===!1||t.enablePan===!1||Y(B)}function js(B){switch(es(B),y.length){case 1:switch(t.touches.ONE){case Ve.ROTATE:if(t.enableRotate===!1)return;ae(),o=n.TOUCH_ROTATE;break;case Ve.PAN:if(t.enablePan===!1)return;le(),o=n.TOUCH_PAN;break;default:o=n.NONE}break;case 2:switch(t.touches.TWO){case Ve.DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;Ae(),o=n.TOUCH_DOLLY_PAN;break;case Ve.DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;he(),o=n.TOUCH_DOLLY_ROTATE;break;default:o=n.NONE}break;default:o=n.NONE}o!==n.NONE&&t.dispatchEvent(Dt)}function Ys(B){switch(es(B),o){case n.TOUCH_ROTATE:if(t.enableRotate===!1)return;te(B),t.update();break;case n.TOUCH_PAN:if(t.enablePan===!1)return;ue(B),t.update();break;case n.TOUCH_DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;Ee(B),t.update();break;case n.TOUCH_DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;De(B),t.update();break;default:o=n.NONE}}function $t(B){t.enabled!==!1&&B.preventDefault()}function Xs(B){y.push(B)}function Js(B){delete v[B.pointerId];for(let z=0;z<y.length;z++)if(y[z].pointerId==B.pointerId){y.splice(z,1);return}}function es(B){let z=v[B.pointerId];z===void 0&&(z=new ve,v[B.pointerId]=z),z.set(B.pageX,B.pageY)}function Tt(B){const z=B.pointerId===y[0].pointerId?y[1]:y[0];return v[z.pointerId]}t.domElement.addEventListener("contextmenu",$t),t.domElement.addEventListener("pointerdown",me),t.domElement.addEventListener("pointercancel",ke),t.domElement.addEventListener("wheel",Zt,{passive:!1}),this.update()}}const oo=(A,e,s,t,n)=>{const o=performance.now();let i=A.style.display==="none"?0:parseFloat(A.style.opacity);isNaN(i)&&(i=1);const r=window.setInterval(()=>{const l=performance.now()-o;let c=Math.min(l/t,1);c>.999&&(c=1);let d;e?(d=(1-c)*i,d<1e-4&&(d=0)):d=(1-i)*c+i,d>0?(A.style.display=s,A.style.opacity=d):A.style.display="none",c>=1&&(n&&n(),window.clearInterval(r))},16);return r},ro=500;class Yt{static elementIDGen=0;constructor(e,s){this.taskIDGen=0,this.elementID=Yt.elementIDGen++,this.tasks=[],this.message=e||"Loading...",this.container=s||document.body,this.spinnerContainerOuter=document.createElement("div"),this.spinnerContainerOuter.className=`spinnerOuterContainer${this.elementID}`,this.spinnerContainerOuter.style.display="none",this.spinnerContainerPrimary=document.createElement("div"),this.spinnerContainerPrimary.className=`spinnerContainerPrimary${this.elementID}`,this.spinnerPrimary=document.createElement("div"),this.spinnerPrimary.classList.add(`spinner${this.elementID}`,`spinnerPrimary${this.elementID}`),this.messageContainerPrimary=document.createElement("div"),this.messageContainerPrimary.classList.add(`messageContainer${this.elementID}`,`messageContainerPrimary${this.elementID}`),this.messageContainerPrimary.innerHTML=this.message,this.spinnerContainerMin=document.createElement("div"),this.spinnerContainerMin.className=`spinnerContainerMin${this.elementID}`,this.spinnerMin=document.createElement("div"),this.spinnerMin.classList.add(`spinner${this.elementID}`,`spinnerMin${this.elementID}`),this.messageContainerMin=document.createElement("div"),this.messageContainerMin.classList.add(`messageContainer${this.elementID}`,`messageContainerMin${this.elementID}`),this.messageContainerMin.innerHTML=this.message,this.spinnerContainerPrimary.appendChild(this.spinnerPrimary),this.spinnerContainerPrimary.appendChild(this.messageContainerPrimary),this.spinnerContainerOuter.appendChild(this.spinnerContainerPrimary),this.spinnerContainerMin.appendChild(this.spinnerMin),this.spinnerContainerMin.appendChild(this.messageContainerMin),this.spinnerContainerOuter.appendChild(this.spinnerContainerMin);const t=document.createElement("style");t.innerHTML=`

            .spinnerOuterContainer${this.elementID} {
                width: 100%;
                height: 100%;
                margin: 0;
                top: 0;
                left: 0;
                position: absolute;
                pointer-events: none;
            }

            .messageContainer${this.elementID} {
                height: 20px;
                font-family: arial;
                font-size: 12pt;
                color: #ffffff;
                text-align: center;
                vertical-align: middle;
            }

            .spinner${this.elementID} {
                padding: 15px;
                background: #07e8d6;
                z-index:99999;
            
                aspect-ratio: 1;
                border-radius: 50%;
                --_m: 
                    conic-gradient(#0000,#000),
                    linear-gradient(#000 0 0) content-box;
                -webkit-mask: var(--_m);
                    mask: var(--_m);
                -webkit-mask-composite: source-out;
                    mask-composite: subtract;
                box-sizing: border-box;
                animation: load 1s linear infinite;
            }

            .spinnerContainerPrimary${this.elementID} {
                z-index:99999;
                background-color: rgba(128, 128, 128, 0.75);
                border: #666666 1px solid;
                border-radius: 5px;
                padding-top: 20px;
                padding-bottom: 10px;
                margin: 0;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-80px, -80px);
                width: 180px;
                pointer-events: auto;
            }

            .spinnerPrimary${this.elementID} {
                width: 120px;
                margin-left: 30px;
            }

            .messageContainerPrimary${this.elementID} {
                padding-top: 15px;
            }

            .spinnerContainerMin${this.elementID} {
                z-index:99999;
                background-color: rgba(128, 128, 128, 0.75);
                border: #666666 1px solid;
                border-radius: 5px;
                padding-top: 20px;
                padding-bottom: 15px;
                margin: 0;
                position: absolute;
                bottom: 50px;
                left: 50%;
                transform: translate(-50%, 0);
                display: flex;
                flex-direction: left;
                pointer-events: auto;
                min-width: 250px;
            }

            .messageContainerMin${this.elementID} {
                margin-right: 15px;
            }

            .spinnerMin${this.elementID} {
                width: 50px;
                height: 50px;
                margin-left: 15px;
                margin-right: 25px;
            }

            .messageContainerMin${this.elementID} {
                padding-top: 15px;
            }
            
            @keyframes load {
                to{transform: rotate(1turn)}
            }

        `,this.spinnerContainerOuter.appendChild(t),this.container.appendChild(this.spinnerContainerOuter),this.setMinimized(!1,!0),this.fadeTransitions=[]}addTask(e){const s={message:e,id:this.taskIDGen++};return this.tasks.push(s),this.update(),s.id}removeTask(e){let s=0;for(let t of this.tasks){if(t.id===e){this.tasks.splice(s,1);break}s++}this.update()}removeAllTasks(){this.tasks=[],this.update()}setMessageForTask(e,s){for(let t of this.tasks)if(t.id===e){t.message=s;break}this.update()}update(){this.tasks.length>0?(this.show(),this.setMessage(this.tasks[this.tasks.length-1].message)):this.hide()}show(){this.spinnerContainerOuter.style.display="block",this.visible=!0}hide(){this.spinnerContainerOuter.style.display="none",this.visible=!1}setContainer(e){this.container&&this.spinnerContainerOuter.parentElement===this.container&&this.container.removeChild(this.spinnerContainerOuter),e&&(this.container=e,this.container.appendChild(this.spinnerContainerOuter),this.spinnerContainerOuter.style.zIndex=this.container.style.zIndex+1)}setMinimized(e,s){const t=(n,o,i,r,a)=>{i?n.style.display=o?r:"none":this.fadeTransitions[a]=oo(n,!o,r,ro,()=>{this.fadeTransitions[a]=null})};t(this.spinnerContainerPrimary,!e,s,"block",0),t(this.spinnerContainerMin,e,s,"flex",1),this.minimized=e}setMessage(e){this.messageContainerPrimary.innerHTML=e,this.messageContainerMin.innerHTML=e}}class io{constructor(e){this.idGen=0,this.tasks=[],this.container=e||document.body,this.progressBarContainerOuter=document.createElement("div"),this.progressBarContainerOuter.className="progressBarOuterContainer",this.progressBarContainerOuter.style.display="none",this.progressBarBox=document.createElement("div"),this.progressBarBox.className="progressBarBox",this.progressBarBackground=document.createElement("div"),this.progressBarBackground.className="progressBarBackground",this.progressBar=document.createElement("div"),this.progressBar.className="progressBar",this.progressBarBackground.appendChild(this.progressBar),this.progressBarBox.appendChild(this.progressBarBackground),this.progressBarContainerOuter.appendChild(this.progressBarBox);const s=document.createElement("style");s.innerHTML=`

            .progressBarOuterContainer {
                width: 100%;
                height: 100%;
                margin: 0;
                top: 0;
                left: 0;
                position: absolute;
                pointer-events: none;
            }

            .progressBarBox {
                z-index:99999;
                padding: 7px 9px 5px 7px;
                background-color: rgba(190, 190, 190, 0.75);
                border: #555555 1px solid;
                border-radius: 15px;
                margin: 0;
                position: absolute;
                bottom: 50px;
                left: 50%;
                transform: translate(-50%, 0);
                width: 180px;
                height: 30px;
                pointer-events: auto;
            }

            .progressBarBackground {
                width: 100%;
                height: 25px;
                border-radius:10px;
                background-color: rgba(128, 128, 128, 0.75);
                border: #444444 1px solid;
                box-shadow: inset 0 0 10px #333333;
            }

            .progressBar {
                height: 25px;
                width: 0px;
                border-radius:10px;
                background-color: rgba(0, 200, 0, 0.75);
                box-shadow: inset 0 0 10px #003300;
            }

        `,this.progressBarContainerOuter.appendChild(s),this.container.appendChild(this.progressBarContainerOuter)}show(){this.progressBarContainerOuter.style.display="block"}hide(){this.progressBarContainerOuter.style.display="none"}setProgress(e){this.progressBar.style.width=e+"%"}setContainer(e){this.container&&this.progressBarContainerOuter.parentElement===this.container&&this.container.removeChild(this.progressBarContainerOuter),e&&(this.container=e,this.container.appendChild(this.progressBarContainerOuter),this.progressBarContainerOuter.style.zIndex=this.container.style.zIndex+1)}}class ao{constructor(e){this.container=e||document.body,this.infoCells={};const s=[["Camera position","cameraPosition"],["Camera look-at","cameraLookAt"],["Camera up","cameraUp"],["Camera mode","orthographicCamera"],["Cursor position","cursorPosition"],["FPS","fps"],["Rendering:","renderSplatCount"],["Sort time","sortTime"],["Render window","renderWindow"],["Focal adjustment","focalAdjustment"],["Splat scale","splatScale"],["Point cloud mode","pointCloudMode"]];this.infoPanelContainer=document.createElement("div");const t=document.createElement("style");t.innerHTML=`

            .infoPanel {
                width: 430px;
                padding: 10px;
                background-color: rgba(50, 50, 50, 0.85);
                border: #555555 2px solid;
                color: #dddddd;
                border-radius: 10px;
                z-index: 9999;
                font-family: arial;
                font-size: 11pt;
                text-align: left;
                margin: 0;
                top: 10px;
                left:10px;
                position: absolute;
                pointer-events: auto;
            }

            .info-panel-cell {
                margin-bottom: 5px;
                padding-bottom: 2px;
            }

            .label-cell {
                font-weight: bold;
                font-size: 12pt;
                width: 140px;
            }

        `,this.infoPanelContainer.append(t),this.infoPanel=document.createElement("div"),this.infoPanel.className="infoPanel";const n=document.createElement("div");n.style.display="table";for(let o of s){const i=document.createElement("div");i.style.display="table-row",i.className="info-panel-row";const r=document.createElement("div");r.style.display="table-cell",r.innerHTML=`${o[0]}: `,r.classList.add("info-panel-cell","label-cell");const a=document.createElement("div");a.style.display="table-cell",a.style.width="10px",a.innerHTML=" ",a.className="info-panel-cell";const l=document.createElement("div");l.style.display="table-cell",l.innerHTML="",l.className="info-panel-cell",this.infoCells[o[1]]=l,i.appendChild(r),i.appendChild(a),i.appendChild(l),n.appendChild(i)}this.infoPanel.appendChild(n),this.infoPanelContainer.append(this.infoPanel),this.infoPanelContainer.style.display="none",this.container.appendChild(this.infoPanelContainer),this.visible=!1}update=function(e,s,t,n,o,i,r,a,l,c,d,u,h,m){const p=`${s.x.toFixed(5)}, ${s.y.toFixed(5)}, ${s.z.toFixed(5)}`;if(this.infoCells.cameraPosition.innerHTML!==p&&(this.infoCells.cameraPosition.innerHTML=p),t){const C=t,S=`${C.x.toFixed(5)}, ${C.y.toFixed(5)}, ${C.z.toFixed(5)}`;this.infoCells.cameraLookAt.innerHTML!==S&&(this.infoCells.cameraLookAt.innerHTML=S)}const g=`${n.x.toFixed(5)}, ${n.y.toFixed(5)}, ${n.z.toFixed(5)}`;if(this.infoCells.cameraUp.innerHTML!==g&&(this.infoCells.cameraUp.innerHTML=g),this.infoCells.orthographicCamera.innerHTML=o?"Orthographic":"Perspective",i){const C=i,S=`${C.x.toFixed(5)}, ${C.y.toFixed(5)}, ${C.z.toFixed(5)}`;this.infoCells.cursorPosition.innerHTML=S}else this.infoCells.cursorPosition.innerHTML="N/A";this.infoCells.fps.innerHTML=r,this.infoCells.renderWindow.innerHTML=`${e.x} x ${e.y}`,this.infoCells.renderSplatCount.innerHTML=`${l} splats out of ${a} (${c.toFixed(2)}%)`,this.infoCells.sortTime.innerHTML=`${d.toFixed(3)} ms`,this.infoCells.focalAdjustment.innerHTML=`${u.toFixed(3)}`,this.infoCells.splatScale.innerHTML=`${h.toFixed(3)}`,this.infoCells.pointCloudMode.innerHTML=`${m}`};setContainer(e){this.container&&this.infoPanelContainer.parentElement===this.container&&this.container.removeChild(this.infoPanelContainer),e&&(this.container=e,this.container.appendChild(this.infoPanelContainer),this.infoPanelContainer.style.zIndex=this.container.style.zIndex+1)}show(){this.infoPanelContainer.style.display="block",this.visible=!0}hide(){this.infoPanelContainer.style.display="none",this.visible=!1}}const Es=new f.Vector3;class lo extends f.Object3D{constructor(e=new f.Vector3(0,0,1),s=new f.Vector3(0,0,0),t=1,n=.1,o=16776960,i=t*.2,r=i*.2){super(),this.type="ArrowHelper";const a=new f.CylinderGeometry(n,n,t,32);a.translate(0,t/2,0);const l=new f.CylinderGeometry(0,r,i,32);l.translate(0,t,0),this.position.copy(s),this.line=new f.Mesh(a,new f.MeshBasicMaterial({color:o,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new f.Mesh(l,new f.MeshBasicMaterial({color:o,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{Es.set(e.z,0,-e.x).normalize();const s=Math.acos(e.y);this.quaternion.setFromAxisAngle(Es,s)}}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class st{constructor(e){this.threeScene=e,this.splatRenderTarget=null,this.renderTargetCopyQuad=null,this.renderTargetCopyCamera=null,this.meshCursor=null,this.focusMarker=null,this.controlPlane=null,this.debugRoot=null,this.secondaryDebugRoot=null}updateSplatRenderTargetForRenderDimensions(e,s){this.destroySplatRendertarget(),this.splatRenderTarget=new f.WebGLRenderTarget(e,s,{format:f.RGBAFormat,stencilBuffer:!1,depthBuffer:!0}),this.splatRenderTarget.depthTexture=new f.DepthTexture(e,s),this.splatRenderTarget.depthTexture.format=f.DepthFormat,this.splatRenderTarget.depthTexture.type=f.UnsignedIntType}destroySplatRendertarget(){this.splatRenderTarget&&(this.splatRenderTarget=null)}setupRenderTargetCopyObjects(){const e={sourceColorTexture:{type:"t",value:null},sourceDepthTexture:{type:"t",value:null}},s=new f.ShaderMaterial({vertexShader:`
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4( position.xy, 0.0, 1.0 );    
                }
            `,fragmentShader:`
                #include <common>
                #include <packing>
                varying vec2 vUv;
                uniform sampler2D sourceColorTexture;
                uniform sampler2D sourceDepthTexture;
                void main() {
                    vec4 color = texture2D(sourceColorTexture, vUv);
                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;
                    gl_FragDepth = fragDepth;
                    gl_FragColor = vec4(color.rgb, color.a * 2.0);
              }
            `,uniforms:e,depthWrite:!1,depthTest:!1,transparent:!0,blending:f.CustomBlending,blendSrc:f.SrcAlphaFactor,blendSrcAlpha:f.SrcAlphaFactor,blendDst:f.OneMinusSrcAlphaFactor,blendDstAlpha:f.OneMinusSrcAlphaFactor});s.extensions.fragDepth=!0,this.renderTargetCopyQuad=new f.Mesh(new f.PlaneGeometry(2,2),s),this.renderTargetCopyCamera=new f.OrthographicCamera(-1,1,1,-1,0,1)}destroyRenderTargetCopyObjects(){this.renderTargetCopyQuad&&(We(this.renderTargetCopyQuad),this.renderTargetCopyQuad=null)}setupMeshCursor(){if(!this.meshCursor){const e=new f.ConeGeometry(.5,1.5,32),s=new f.MeshBasicMaterial({color:16777215}),t=new f.Mesh(e,s);t.rotation.set(0,0,Math.PI),t.position.set(0,1,0);const n=new f.Mesh(e,s);n.position.set(0,-1,0);const o=new f.Mesh(e,s);o.rotation.set(0,0,Math.PI/2),o.position.set(1,0,0);const i=new f.Mesh(e,s);i.rotation.set(0,0,-Math.PI/2),i.position.set(-1,0,0),this.meshCursor=new f.Object3D,this.meshCursor.add(t),this.meshCursor.add(n),this.meshCursor.add(o),this.meshCursor.add(i),this.meshCursor.scale.set(.1,.1,.1),this.threeScene.add(this.meshCursor),this.meshCursor.visible=!1}}destroyMeshCursor(){this.meshCursor&&(We(this.meshCursor),this.threeScene.remove(this.meshCursor),this.meshCursor=null)}setMeshCursorVisibility(e){this.meshCursor.visible=e}getMeschCursorVisibility(){return this.meshCursor.visible}setMeshCursorPosition(e){this.meshCursor.position.copy(e)}positionAndOrientMeshCursor(e,s){this.meshCursor.position.copy(e),this.meshCursor.up.copy(s.up),this.meshCursor.lookAt(s.position)}setupFocusMarker(){if(!this.focusMarker){const e=new f.SphereGeometry(.5,32,32),s=st.buildFocusMarkerMaterial();s.depthTest=!1,s.depthWrite=!1,s.transparent=!0,this.focusMarker=new f.Mesh(e,s)}}destroyFocusMarker(){this.focusMarker&&(We(this.focusMarker),this.focusMarker=null)}updateFocusMarker=function(){const e=new f.Vector3,s=new f.Matrix4,t=new f.Vector3;return function(n,o,i){s.copy(o.matrixWorld).invert(),e.copy(n).applyMatrix4(s),e.normalize().multiplyScalar(10),e.applyMatrix4(o.matrixWorld),t.copy(o.position).sub(n);const r=t.length();this.focusMarker.position.copy(n),this.focusMarker.scale.set(r,r,r),this.focusMarker.material.uniforms.realFocusPosition.value.copy(n),this.focusMarker.material.uniforms.viewport.value.copy(i),this.focusMarker.material.uniformsNeedUpdate=!0}}();setFocusMarkerVisibility(e){this.focusMarker.visible=e}setFocusMarkerOpacity(e){this.focusMarker.material.uniforms.opacity.value=e,this.focusMarker.material.uniformsNeedUpdate=!0}getFocusMarkerOpacity(){return this.focusMarker.material.uniforms.opacity.value}setupControlPlane(){if(!this.controlPlane){const e=new f.PlaneGeometry(1,1);e.rotateX(-Math.PI/2);const s=new f.MeshBasicMaterial({color:16777215});s.transparent=!0,s.opacity=.6,s.depthTest=!1,s.depthWrite=!1,s.side=f.DoubleSide;const t=new f.Mesh(e,s),n=new f.Vector3(0,1,0);n.normalize();const o=new f.Vector3(0,0,0),i=.5,r=.01,a=56576,l=new lo(n,o,i,r,a,.1,.03);this.controlPlane=new f.Object3D,this.controlPlane.add(t),this.controlPlane.add(l)}}destroyControlPlane(){this.controlPlane&&(We(this.controlPlane),this.controlPlane=null)}setControlPlaneVisibility(e){this.controlPlane.visible=e}positionAndOrientControlPlane=function(){const e=new f.Quaternion,s=new f.Vector3(0,1,0);return function(t,n){e.setFromUnitVectors(s,n),this.controlPlane.position.copy(t),this.controlPlane.quaternion.copy(e)}}();addDebugMeshes(){this.debugRoot=this.createDebugMeshes(),this.secondaryDebugRoot=this.createSecondaryDebugMeshes(),this.threeScene.add(this.debugRoot),this.threeScene.add(this.secondaryDebugRoot)}destroyDebugMeshes(){for(let e of[this.debugRoot,this.secondaryDebugRoot])e&&(We(e),this.threeScene.remove(e));this.debugRoot=null,this.secondaryDebugRoot=null}createDebugMeshes(e){const s=new f.SphereGeometry(1,32,32),t=new f.Object3D,n=(o,i)=>{let r=new f.Mesh(s,st.buildDebugMaterial(o));r.renderOrder=e,t.add(r),r.position.fromArray(i)};return n(16711680,[-50,0,0]),n(16711680,[50,0,0]),n(65280,[0,0,-50]),n(65280,[0,0,50]),n(16755200,[5,0,5]),t}createSecondaryDebugMeshes(e){const s=new f.BoxGeometry(3,3,3),t=new f.Object3D;let n=12303291;const o=r=>{let a=new f.Mesh(s,st.buildDebugMaterial(n));a.renderOrder=e,t.add(a),a.position.fromArray(r)};let i=10;return o([-i,0,-i]),o([-i,0,i]),o([i,0,-i]),o([i,0,i]),t}static buildDebugMaterial(e){const s=`
            #include <common>
            varying float ndcDepth;

            void main() {
                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);
                ndcDepth = gl_Position.z / gl_Position.w;
                gl_Position.x = gl_Position.x / gl_Position.w;
                gl_Position.y = gl_Position.y / gl_Position.w;
                gl_Position.z = 0.0;
                gl_Position.w = 1.0;
    
            }
        `,t=`
            #include <common>
            uniform vec3 color;
            varying float ndcDepth;
            void main() {
                gl_FragDepth = (ndcDepth + 1.0) / 2.0;
                gl_FragColor = vec4(color.rgb, 0.0);
            }
        `,n={color:{type:"v3",value:new f.Color(e)}},o=new f.ShaderMaterial({uniforms:n,vertexShader:s,fragmentShader:t,transparent:!1,depthTest:!0,depthWrite:!0,side:f.FrontSide});return o.extensions.fragDepth=!0,o}static buildFocusMarkerMaterial(e){const s=`
            #include <common>

            uniform vec2 viewport;
            uniform vec3 realFocusPosition;

            varying vec4 ndcPosition;
            varying vec4 ndcCenter;
            varying vec4 ndcFocusPosition;

            void main() {
                float radius = 0.01;

                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);
                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);

                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);

                ndcPosition = projectionMatrix * viewPosition;
                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);
                ndcCenter = projectionMatrix * viewCenter;
                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);

                ndcFocusPosition = projectionMatrix * viewFocusPosition;
                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);

                gl_Position = projectionMatrix * viewPosition;

            }
        `,t=`
            #include <common>
            uniform vec3 color;
            uniform vec2 viewport;
            uniform float opacity;

            varying vec4 ndcPosition;
            varying vec4 ndcCenter;
            varying vec4 ndcFocusPosition;

            void main() {
                vec2 screenPosition = vec2(ndcPosition) * viewport;
                vec2 screenCenter = vec2(ndcCenter) * viewport;

                vec2 screenVec = screenPosition - screenCenter;

                float projectedRadius = length(screenVec);

                float lineWidth = 0.0005 * viewport.y;
                float aaRange = 0.0025 * viewport.y;
                float radius = 0.06 * viewport.y;
                float radDiff = abs(projectedRadius - radius) - lineWidth;
                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); 

                gl_FragColor = vec4(color.rgb, alpha * opacity);
            }
        `,n={color:{type:"v3",value:new f.Color(e)},realFocusPosition:{type:"v3",value:new f.Vector3},viewport:{type:"v2",value:new f.Vector2},opacity:{value:0}};return new f.ShaderMaterial({uniforms:n,vertexShader:s,fragmentShader:t,transparent:!0,depthTest:!1,depthWrite:!1,side:f.FrontSide})}dispose(){this.destroyMeshCursor(),this.destroyFocusMarker(),this.destroyDebugMeshes(),this.destroyControlPlane(),this.destroyRenderTargetCopyObjects(),this.destroySplatRendertarget()}}const co=new f.Vector3(1,0,0),ho=new f.Vector3(0,1,0),uo=new f.Vector3(0,0,1);class Ft{constructor(e=new f.Vector3,s=new f.Vector3){this.origin=new f.Vector3,this.direction=new f.Vector3,this.setParameters(e,s)}setParameters(e,s){this.origin.copy(e),this.direction.copy(s).normalize()}boxContainsPoint(e,s,t){return!(s.x<e.min.x-t||s.x>e.max.x+t||s.y<e.min.y-t||s.y>e.max.y+t||s.z<e.min.z-t||s.z>e.max.z+t)}intersectBox=function(){const e=new f.Vector3,s=[],t=[],n=[];return function(o,i){if(t[0]=this.origin.x,t[1]=this.origin.y,t[2]=this.origin.z,n[0]=this.direction.x,n[1]=this.direction.y,n[2]=this.direction.z,this.boxContainsPoint(o,this.origin,1e-4))return i&&(i.origin.copy(this.origin),i.normal.set(0,0,0),i.distance=-1),!0;for(let r=0;r<3;r++){if(n[r]==0)continue;const a=r==0?co:r==1?ho:uo,l=n[r]<0?o.max:o.min;let c=-Math.sign(n[r]);s[0]=r==0?l.x:r==1?l.y:l.z;let d=s[0]-t[r];if(d*c<0){const u=(r+1)%3,h=(r+2)%3;if(s[2]=n[u]/n[r]*d+t[u],s[1]=n[h]/n[r]*d+t[h],e.set(s[r],s[h],s[u]),this.boxContainsPoint(o,e,1e-4))return i&&(i.origin.copy(e),i.normal.copy(a).multiplyScalar(c),i.distance=e.sub(this.origin).length()),!0}}return!1}}();intersectSphere=function(){const e=new f.Vector3;return function(s,t,n){e.copy(s).sub(this.origin);const o=e.dot(this.direction),i=o*o,a=e.dot(e)-i,l=t*t;if(a>l)return!1;const c=Math.sqrt(l-a),d=o-c,u=o+c;if(u<0)return!1;let h=d<0?u:d;return n&&(n.origin.copy(this.origin).addScaledVector(this.direction,h),n.normal.copy(n.origin).sub(s).normalize(),n.distance=h),!0}}()}class Xt{constructor(){this.origin=new f.Vector3,this.normal=new f.Vector3,this.distance=0,this.splatIndex=0}set(e,s,t,n){this.origin.copy(e),this.normal.copy(s),this.distance=t,this.splatIndex=n}clone(){const e=new Xt;return e.origin.copy(this.origin),e.normal.copy(this.normal),e.distance=this.distance,e.splatIndex=this.splatIndex,e}}const Pe={ThreeD:0,TwoD:1};class po{constructor(e,s,t=!1){this.ray=new Ft(e,s),this.raycastAgainstTrueSplatEllipsoid=t}setFromCameraAndScreenPosition=function(){const e=new f.Vector2;return function(s,t,n){if(e.x=t.x/n.x*2-1,e.y=(n.y-t.y)/n.y*2-1,s.isPerspectiveCamera)this.ray.origin.setFromMatrixPosition(s.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(s).sub(this.ray.origin).normalize(),this.camera=s;else if(s.isOrthographicCamera)this.ray.origin.set(e.x,e.y,(s.near+s.far)/(s.near-s.far)).unproject(s),this.ray.direction.set(0,0,-1).transformDirection(s.matrixWorld),this.camera=s;else throw new Error("Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type")}}();intersectSplatMesh=function(){const e=new f.Matrix4,s=new f.Matrix4,t=new f.Matrix4,n=new Ft,o=new f.Vector3;return function(i,r=[]){const a=i.getSplatTree();if(a){for(let l=0;l<a.subTrees.length;l++){const c=a.subTrees[l];s.copy(i.matrixWorld),i.dynamicMode&&(i.getSceneTransform(l,t),s.multiply(t)),e.copy(s).invert(),n.origin.copy(this.ray.origin).applyMatrix4(e),n.direction.copy(this.ray.origin).add(this.ray.direction),n.direction.applyMatrix4(e).sub(n.origin).normalize();const d=[];c.rootNode&&this.castRayAtSplatTreeNode(n,a,c.rootNode,d),d.forEach(u=>{u.origin.applyMatrix4(s),u.normal.applyMatrix4(s).normalize(),u.distance=o.copy(u.origin).sub(this.ray.origin).length()}),r.push(...d)}return r.sort((l,c)=>l.distance>c.distance?1:-1),r}}}();castRayAtSplatTreeNode=function(){const e=new f.Vector4,s=new f.Vector3,t=new f.Vector3,n=new f.Quaternion,o=new Xt,i=1e-7,r=new f.Vector3(0,0,0),a=new f.Matrix4,l=new f.Matrix4,c=new f.Matrix4,d=new f.Matrix4,u=new f.Matrix4,h=new Ft;return function(m,p,g,C=[]){if(m.intersectBox(g.boundingBox)){if(g.data&&g.data.indexes&&g.data.indexes.length>0)for(let S=0;S<g.data.indexes.length;S++){const T=g.data.indexes[S],w=p.splatMesh.getSceneIndexForSplat(T);if(p.splatMesh.getScene(w).visible&&(p.splatMesh.getSplatColor(T,e),p.splatMesh.getSplatCenter(T,s),p.splatMesh.getSplatScaleAndRotation(T,t,n),!(t.x<=i||t.y<=i||p.splatMesh.splatRenderMode===Pe.ThreeD&&t.z<=i)))if(this.raycastAgainstTrueSplatEllipsoid){l.makeScale(t.x,t.y,t.z),c.makeRotationFromQuaternion(n);const E=Math.log10(e.w)*2;if(a.makeScale(E,E,E),u.copy(a).multiply(c).multiply(l),d.copy(u).invert(),h.origin.copy(m.origin).sub(s).applyMatrix4(d),h.direction.copy(m.origin).add(m.direction).sub(s),h.direction.applyMatrix4(d).sub(h.origin).normalize(),h.intersectSphere(r,1,o)){const y=o.clone();y.splatIndex=T,y.origin.applyMatrix4(u).add(s),C.push(y)}}else{let E=t.x+t.y,y=2;if(p.splatMesh.splatRenderMode===Pe.ThreeD&&(E+=t.z,y=3),E=E/y,m.intersectSphere(s,E,o)){const v=o.clone();v.splatIndex=T,C.push(v)}}}if(g.children&&g.children.length>0)for(let S of g.children)this.castRayAtSplatTreeNode(m,p,S,C);return C}}}()}class Ye{static buildVertexShaderBase(e=!1,s=!1,t=0,n=""){let o=`
        precision highp float;
        #include <common>

        attribute uint splatIndex;
        uniform highp usampler2D centersColorsTexture;
        uniform highp sampler2D sphericalHarmonicsTexture;
        uniform highp sampler2D sphericalHarmonicsTextureR;
        uniform highp sampler2D sphericalHarmonicsTextureG;
        uniform highp sampler2D sphericalHarmonicsTextureB;

        uniform highp usampler2D sceneIndexesTexture;
        uniform vec2 sceneIndexesTextureSize;
        uniform int sceneCount;
    `;return s&&(o+=`
            uniform float sceneOpacity[${j.MaxScenes}];
            uniform int sceneVisibility[${j.MaxScenes}];
        `),e&&(o+=`
            uniform highp mat4 transforms[${j.MaxScenes}];
        `),o+=`
        ${n}
        uniform vec2 focal;
        uniform float orthoZoom;
        uniform int orthographicMode;
        uniform int pointCloudModeEnabled;
        uniform float inverseFocalAdjustment;
        uniform vec2 viewport;
        uniform vec2 basisViewport;
        uniform vec2 centersColorsTextureSize;
        uniform int sphericalHarmonicsDegree;
        uniform vec2 sphericalHarmonicsTextureSize;
        uniform int sphericalHarmonics8BitMode;
        uniform int sphericalHarmonicsMultiTextureMode;
        uniform float visibleRegionRadius;
        uniform float visibleRegionFadeStartRadius;
        uniform float firstRenderTime;
        uniform float currentTime;
        uniform int fadeInComplete;
        uniform vec3 sceneCenter;
        uniform float splatScale;
        uniform float sphericalHarmonics8BitCompressionRangeMin[${j.MaxScenes}];
        uniform float sphericalHarmonics8BitCompressionRangeMax[${j.MaxScenes}];

        varying vec4 vColor;
        varying vec2 vUv;
        varying vec2 vPosition;

        mat3 quaternionToRotationMatrix(float x, float y, float z, float w) {
            float s = 1.0 / sqrt(w * w + x * x + y * y + z * z);
        
            return mat3(
                1. - 2. * (y * y + z * z),
                2. * (x * y + w * z),
                2. * (x * z - w * y),
                2. * (x * y - w * z),
                1. - 2. * (x * x + z * z),
                2. * (y * z + w * x),
                2. * (x * z + w * y),
                2. * (y * z - w * x),
                1. - 2. * (x * x + y * y)
            );
        }

        const float sqrt8 = sqrt(8.0);
        const float minAlpha = 1.0 / 255.0;

        const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);
        const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));
        const uvec4 shift4 = uvec4(0, 8, 16, 24);
        vec4 uintToRGBAVec (uint u) {
           uvec4 urgba = mask4 & u;
           urgba = urgba >> shift4;
           vec4 rgba = vec4(urgba) * encodeNorm4;
           return rgba;
        }

        vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {
            vec2 samplerUV = vec2(0.0, 0.0);
            float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;
            samplerUV.y = float(floor(d)) / dimensions.y;
            samplerUV.x = fract(d);
            return samplerUV;
        }

        vec2 getDataUVF(in uint sIndex, in float stride, in uint offset, in vec2 dimensions) {
            vec2 samplerUV = vec2(0.0, 0.0);
            float d = float(uint(float(sIndex) * stride) + offset) / dimensions.x;
            samplerUV.y = float(floor(d)) / dimensions.y;
            samplerUV.x = fract(d);
            return samplerUV;
        }

        const float SH_C1 = 0.4886025119029199f;
        const float[5] SH_C2 = float[](1.0925484, -1.0925484, 0.3153916, -1.0925484, 0.5462742);

        void main () {

            uint oddOffset = splatIndex & uint(0x00000001);
            uint doubleOddOffset = oddOffset * uint(2);
            bool isEven = oddOffset == uint(0);
            uint nearestEvenIndex = splatIndex - oddOffset;
            float fOddOffset = float(oddOffset);

            uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));
            vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));

            uint sceneIndex = uint(0);
            if (sceneCount > 1) {
                sceneIndex = texture(sceneIndexesTexture, getDataUV(1, 0, sceneIndexesTextureSize)).r;
            }
            `,s&&(o+=`
                float splatOpacityFromScene = sceneOpacity[sceneIndex];
                int sceneVisible = sceneVisibility[sceneIndex];
                if (splatOpacityFromScene <= 0.01 || sceneVisible == 0) {
                    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
                    return;
                }
            `),e?o+=`
                mat4 transform = transforms[sceneIndex];
                mat4 transformModelViewMatrix = viewMatrix * transform;
            `:o+="mat4 transformModelViewMatrix = modelViewMatrix;",o+=`
            float sh8BitCompressionRangeMinForScene = sphericalHarmonics8BitCompressionRangeMin[sceneIndex];
            float sh8BitCompressionRangeMaxForScene = sphericalHarmonics8BitCompressionRangeMax[sceneIndex];
            float sh8BitCompressionRangeForScene = sh8BitCompressionRangeMaxForScene - sh8BitCompressionRangeMinForScene;
            float sh8BitCompressionHalfRangeForScene = sh8BitCompressionRangeForScene / 2.0;
            vec3 vec8BitSHShift = vec3(sh8BitCompressionRangeMinForScene);

            vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);

            vec4 clipCenter = projectionMatrix * viewCenter;

            float clip = 1.2 * clipCenter.w;
            if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {
                gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
                return;
            }

            vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

            vPosition = position.xy;
            vColor = uintToRGBAVec(sampledCenterColor.r);
        `,t>=1&&(o+=`   
            if (sphericalHarmonicsDegree >= 1) {
            `,e?o+=`
                    vec3 worldViewDir = normalize(splatCenter - vec3(inverse(transform) * vec4(cameraPosition, 1.0)));
                `:o+=`
                    vec3 worldViewDir = normalize(splatCenter - cameraPosition);
                `,o+=`
                vec3 sh1;
                vec3 sh2;
                vec3 sh3;
            `,t>=2&&(o+=`
                    vec3 sh4;
                    vec3 sh5;
                    vec3 sh6;
                    vec3 sh7;
                    vec3 sh8;
                `),t===1?o+=`
                    if (sphericalHarmonicsMultiTextureMode == 0) {
                        vec2 shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset, sphericalHarmonicsTextureSize);
                        vec4 sampledSH0123 = texture(sphericalHarmonicsTexture, shUV);
                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(1), sphericalHarmonicsTextureSize);
                        vec4 sampledSH4567 = texture(sphericalHarmonicsTexture, shUV);
                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(2), sphericalHarmonicsTextureSize);
                        vec4 sampledSH891011 = texture(sphericalHarmonicsTexture, shUV);
                        sh1 = vec3(sampledSH0123.rgb) * (1.0 - fOddOffset) + vec3(sampledSH0123.ba, sampledSH4567.r) * fOddOffset;
                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg) * (1.0 - fOddOffset) + vec3(sampledSH4567.gba) * fOddOffset;
                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r) * (1.0 - fOddOffset) + vec3(sampledSH891011.rgb) * fOddOffset;
                    } else {
                        vec2 sampledSH01R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH23R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH01G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH23G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH01B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH23B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;
                        sh1 = vec3(sampledSH01R.rg, sampledSH23R.r);
                        sh2 = vec3(sampledSH01G.rg, sampledSH23G.r);
                        sh3 = vec3(sampledSH01B.rg, sampledSH23B.r);
                    }
                `:t===2&&(o+=`
                    vec4 sampledSH0123;
                    vec4 sampledSH4567;
                    vec4 sampledSH891011;

                    vec4 sampledSH0123R;
                    vec4 sampledSH0123G;
                    vec4 sampledSH0123B;

                    if (sphericalHarmonicsMultiTextureMode == 0) {
                        sampledSH0123 = texture(sphericalHarmonicsTexture, getDataUV(6, 0, sphericalHarmonicsTextureSize));
                        sampledSH4567 = texture(sphericalHarmonicsTexture, getDataUV(6, 1, sphericalHarmonicsTextureSize));
                        sampledSH891011 = texture(sphericalHarmonicsTexture, getDataUV(6, 2, sphericalHarmonicsTextureSize));
                        sh1 = sampledSH0123.rgb;
                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg);
                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r);
                    } else {
                        sampledSH0123R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize));
                        sampledSH0123G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize));
                        sampledSH0123B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize));
                        sh1 = vec3(sampledSH0123R.rgb);
                        sh2 = vec3(sampledSH0123G.rgb);
                        sh3 = vec3(sampledSH0123B.rgb);
                    }
                `),o+=`
                    if (sphericalHarmonics8BitMode == 1) {
                        sh1 = sh1 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                        sh2 = sh2 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                        sh3 = sh3 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                    }
                    float x = worldViewDir.x;
                    float y = worldViewDir.y;
                    float z = worldViewDir.z;
                    vColor.rgb += SH_C1 * (-sh1 * y + sh2 * z - sh3 * x);
            `,t>=2&&(o+=`
                    if (sphericalHarmonicsDegree >= 2) {
                        float xx = x * x;
                        float yy = y * y;
                        float zz = z * z;
                        float xy = x * y;
                        float yz = y * z;
                        float xz = x * z;
                `,t===2&&(o+=`
                        if (sphericalHarmonicsMultiTextureMode == 0) {
                            vec4 sampledSH12131415 = texture(sphericalHarmonicsTexture, getDataUV(6, 3, sphericalHarmonicsTextureSize));
                            vec4 sampledSH16171819 = texture(sphericalHarmonicsTexture, getDataUV(6, 4, sphericalHarmonicsTextureSize));
                            vec4 sampledSH20212223 = texture(sphericalHarmonicsTexture, getDataUV(6, 5, sphericalHarmonicsTextureSize));
                            sh4 = sampledSH891011.gba;
                            sh5 = sampledSH12131415.rgb;
                            sh6 = vec3(sampledSH12131415.a, sampledSH16171819.rg);
                            sh7 = vec3(sampledSH16171819.ba, sampledSH20212223.r);
                            sh8 = sampledSH20212223.gba;
                        } else {
                            vec4 sampledSH4567R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize));
                            vec4 sampledSH4567G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize));
                            vec4 sampledSH4567B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize));
                            sh4 = vec3(sampledSH0123R.a, sampledSH4567R.rg);
                            sh5 = vec3(sampledSH4567R.ba, sampledSH0123G.a);
                            sh6 = vec3(sampledSH4567G.rgb);
                            sh7 = vec3(sampledSH4567G.a, sampledSH0123B.a, sampledSH4567B.r);
                            sh8 = vec3(sampledSH4567B.gba);
                        }
                    `),o+=`
                        if (sphericalHarmonics8BitMode == 1) {
                            sh4 = sh4 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh5 = sh5 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh6 = sh6 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh7 = sh7 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh8 = sh8 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                        }

                        vColor.rgb +=
                            (SH_C2[0] * xy) * sh4 +
                            (SH_C2[1] * yz) * sh5 +
                            (SH_C2[2] * (2.0 * zz - xx - yy)) * sh6 +
                            (SH_C2[3] * xz) * sh7 +
                            (SH_C2[4] * (xx - yy)) * sh8;
                    }
                `),o+=`

                vColor.rgb = clamp(vColor.rgb, vec3(0.), vec3(1.));

            }

            `),o}static getVertexShaderFadeIn(){return`
            if (fadeInComplete == 0) {
                float opacityAdjust = 1.0;
                float centerDist = length(splatCenter - sceneCenter);
                float renderTime = max(currentTime - firstRenderTime, 0.0);

                float fadeDistance = 0.75;
                float distanceLoadFadeInFactor = step(visibleRegionFadeStartRadius, centerDist);
                distanceLoadFadeInFactor = (1.0 - distanceLoadFadeInFactor) +
                                        (1.0 - clamp((centerDist - visibleRegionFadeStartRadius) / fadeDistance, 0.0, 1.0)) *
                                        distanceLoadFadeInFactor;
                opacityAdjust *= distanceLoadFadeInFactor;
                vColor.a *= opacityAdjust;
            }
        `}static getUniforms(e=!1,s=!1,t=0,n=1,o=!1){const i={sceneCenter:{type:"v3",value:new f.Vector3},fadeInComplete:{type:"i",value:0},orthographicMode:{type:"i",value:0},visibleRegionFadeStartRadius:{type:"f",value:0},visibleRegionRadius:{type:"f",value:0},currentTime:{type:"f",value:0},firstRenderTime:{type:"f",value:0},centersColorsTexture:{type:"t",value:null},sphericalHarmonicsTexture:{type:"t",value:null},sphericalHarmonicsTextureR:{type:"t",value:null},sphericalHarmonicsTextureG:{type:"t",value:null},sphericalHarmonicsTextureB:{type:"t",value:null},sphericalHarmonics8BitCompressionRangeMin:{type:"f",value:[]},sphericalHarmonics8BitCompressionRangeMax:{type:"f",value:[]},focal:{type:"v2",value:new f.Vector2},orthoZoom:{type:"f",value:1},inverseFocalAdjustment:{type:"f",value:1},viewport:{type:"v2",value:new f.Vector2},basisViewport:{type:"v2",value:new f.Vector2},debugColor:{type:"v3",value:new f.Color},centersColorsTextureSize:{type:"v2",value:new f.Vector2(1024,1024)},sphericalHarmonicsDegree:{type:"i",value:t},sphericalHarmonicsTextureSize:{type:"v2",value:new f.Vector2(1024,1024)},sphericalHarmonics8BitMode:{type:"i",value:0},sphericalHarmonicsMultiTextureMode:{type:"i",value:0},splatScale:{type:"f",value:n},pointCloudModeEnabled:{type:"i",value:o?1:0},sceneIndexesTexture:{type:"t",value:null},sceneIndexesTextureSize:{type:"v2",value:new f.Vector2(1024,1024)},sceneCount:{type:"i",value:1}};for(let r=0;r<j.MaxScenes;r++)i.sphericalHarmonics8BitCompressionRangeMin.value.push(-3/2),i.sphericalHarmonics8BitCompressionRangeMax.value.push(j.SphericalHarmonics8BitCompressionRange/2);if(s){const r=[];for(let l=0;l<j.MaxScenes;l++)r.push(1);i.sceneOpacity={type:"f",value:r};const a=[];for(let l=0;l<j.MaxScenes;l++)a.push(1);i.sceneVisibility={type:"i",value:a}}if(e){const r=[];for(let a=0;a<j.MaxScenes;a++)r.push(new f.Matrix4);i.transforms={type:"mat4",value:r}}return i}}class gt{static build(e=!1,s=!1,t=!1,n=2048,o=1,i=!1,r=0,a=.3){let c=Ye.buildVertexShaderBase(e,s,r,`
            uniform vec2 covariancesTextureSize;
            uniform highp sampler2D covariancesTexture;
            uniform highp usampler2D covariancesTextureHalfFloat;
            uniform int covariancesAreHalfFloat;

            void fromCovarianceHalfFloatV4(uvec4 val, out vec4 first, out vec4 second) {
                vec2 r = unpackHalf2x16(val.r);
                vec2 g = unpackHalf2x16(val.g);
                vec2 b = unpackHalf2x16(val.b);

                first = vec4(r.x, r.y, g.x, g.y);
                second = vec4(b.x, b.y, 0.0, 0.0);
            }
        `);c+=gt.buildVertexShaderProjection(t,s,n,a);const d=gt.buildFragmentShader(),u=Ye.getUniforms(e,s,r,o,i);return u.covariancesTextureSize={type:"v2",value:new f.Vector2(1024,1024)},u.covariancesTexture={type:"t",value:null},u.covariancesTextureHalfFloat={type:"t",value:null},u.covariancesAreHalfFloat={type:"i",value:0},new f.ShaderMaterial({uniforms:u,vertexShader:c,fragmentShader:d,transparent:!0,alphaTest:1,blending:f.NormalBlending,depthTest:!0,depthWrite:!1,side:f.DoubleSide})}static buildVertexShaderProjection(e,s,t,n){let o=`

            vec4 sampledCovarianceA;
            vec4 sampledCovarianceB;
            vec3 cov3D_M11_M12_M13;
            vec3 cov3D_M22_M23_M33;
            if (covariancesAreHalfFloat == 0) {
                sampledCovarianceA = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset,
                                                                            covariancesTextureSize));
                sampledCovarianceB = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset + uint(1),
                                                                            covariancesTextureSize));

                cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rgb) * (1.0 - fOddOffset) +
                                    vec3(sampledCovarianceA.ba, sampledCovarianceB.r) * fOddOffset;
                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg) * (1.0 - fOddOffset) +
                                    vec3(sampledCovarianceB.gba) * fOddOffset;
            } else {
                uvec4 sampledCovarianceU = texture(covariancesTextureHalfFloat, getDataUV(1, 0, covariancesTextureSize));
                fromCovarianceHalfFloatV4(sampledCovarianceU, sampledCovarianceA, sampledCovarianceB);
                cov3D_M11_M12_M13 = sampledCovarianceA.rgb;
                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg);
            }
        
            // Construct the 3D covariance matrix
            mat3 Vrk = mat3(
                cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,
                cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,
                cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z
            );

            mat3 J;
            if (orthographicMode == 1) {
                // Since the projection is linear, we don't need an approximation
                J = transpose(mat3(orthoZoom, 0.0, 0.0,
                                0.0, orthoZoom, 0.0,
                                0.0, 0.0, 0.0));
            } else {
                // Construct the Jacobian of the affine approximation of the projection matrix. It will be used to transform the
                // 3D covariance matrix instead of using the actual projection matrix because that transformation would
                // require a non-linear component (perspective division) which would yield a non-gaussian result.
                float s = 1.0 / (viewCenter.z * viewCenter.z);
                J = mat3(
                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,
                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,
                    0., 0., 0.
                );
            }

            // Concatenate the projection approximation with the model-view transformation
            mat3 W = transpose(mat3(transformModelViewMatrix));
            mat3 T = W * J;

            // Transform the 3D covariance matrix (Vrk) to compute the 2D covariance matrix
            mat3 cov2Dm = transpose(T) * Vrk * T;
            `;return e?o+=`
                float detOrig = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];
                cov2Dm[0][0] += ${n};
                cov2Dm[1][1] += ${n};
                float detBlur = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];
                vColor.a *= sqrt(max(detOrig / detBlur, 0.0));
                if (vColor.a < minAlpha) return;
            `:o+=`
                cov2Dm[0][0] += ${n};
                cov2Dm[1][1] += ${n};
            `,o+=`

            // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because
            // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],
            // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't
            // need cov2Dm[1][0] because it is a symetric matrix.
            vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);

            // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix
            // so that we can determine the 2D basis for the splat. This is done using the method described
            // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
            // After calculating the eigen-values and eigen-vectors, we calculate the basis for rendering the splat
            // by normalizing the eigen-vectors and then multiplying them by (sqrt(8) * sqrt(eigen-value)), which is
            // equal to scaling them by sqrt(8) standard deviations.
            //
            // This is a different approach than in the original work at INRIA. In that work they compute the
            // max extents of the projected splat in screen space to form a screen-space aligned bounding rectangle
            // which forms the geometry that is actually rasterized. The dimensions of that bounding box are 3.0
            // times the square root of the maximum eigen-value, or 3 standard deviations. They then use the inverse
            // 2D covariance matrix (called 'conic') in the CUDA rendering thread to determine fragment opacity by
            // calculating the full gaussian: exp(-0.5 * (X - mean) * conic * (X - mean)) * splat opacity
            float a = cov2Dv.x;
            float d = cov2Dv.z;
            float b = cov2Dv.y;
            float D = a * d - b * b;
            float trace = a + d;
            float traceOver2 = 0.5 * trace;
            float term2 = sqrt(max(0.1f, traceOver2 * traceOver2 - D));
            float eigenValue1 = traceOver2 + term2;
            float eigenValue2 = traceOver2 - term2;

            if (pointCloudModeEnabled == 1) {
                eigenValue1 = eigenValue2 = 0.2;
            }

            if (eigenValue2 <= 0.0) return;

            vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));
            // since the eigen vectors are orthogonal, we derive the second one from the first
            vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);

            // We use sqrt(8) standard deviations instead of 3 to eliminate more of the splat with a very low opacity.
            vec2 basisVector1 = eigenVector1 * splatScale * min(sqrt8 * sqrt(eigenValue1), ${parseInt(t)}.0);
            vec2 basisVector2 = eigenVector2 * splatScale * min(sqrt8 * sqrt(eigenValue2), ${parseInt(t)}.0);
            `,s&&(o+=`
                vColor.a *= splatOpacityFromScene;
            `),o+=`
            vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) *
                             basisViewport * 2.0 * inverseFocalAdjustment;

            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
            gl_Position = quadPos;

            // Scale the position data we send to the fragment shader
            vPosition *= sqrt8;
        `,o+=Ye.getVertexShaderFadeIn(),o+="}",o}static buildFragmentShader(){let e=`
            precision highp float;
            #include <common>
 
            uniform vec3 debugColor;

            varying vec4 vColor;
            varying vec2 vUv;
            varying vec2 vPosition;
        `;return e+=`
            void main () {
                // Compute the positional squared distance from the center of the splat to the current fragment.
                float A = dot(vPosition, vPosition);
                // Since the positional data in vPosition has been scaled by sqrt(8), the squared result will be
                // scaled by a factor of 8. If the squared result is larger than 8, it means it is outside the ellipse
                // defined by the rectangle formed by vPosition. It also means it's farther
                // away than sqrt(8) standard deviations from the mean.
                if (A > 8.0) discard;
                vec3 color = vColor.rgb;

                // Since the rendered splat is scaled by sqrt(8), the inverse covariance matrix that is part of
                // the gaussian formula becomes the identity matrix. We're then left with (X - mean) * (X - mean),
                // and since 'mean' is zero, we have X * X, which is the same as A:
                float opacity = exp(-0.5 * A) * vColor.a;

                gl_FragColor = vec4(color.rgb, opacity);
            }
        `,e}}class St{static build(e=!1,s=!1,t=1,n=!1,o=0){let r=Ye.buildVertexShaderBase(e,s,o,`
            uniform vec2 scaleRotationsTextureSize;
            uniform highp sampler2D scaleRotationsTexture;
            varying mat3 vT;
            varying vec2 vQuadCenter;
            varying vec2 vFragCoord;
        `);r+=St.buildVertexShaderProjection();const a=St.buildFragmentShader(),l=Ye.getUniforms(e,s,o,t,n);return l.scaleRotationsTexture={type:"t",value:null},l.scaleRotationsTextureSize={type:"v2",value:new f.Vector2(1024,1024)},new f.ShaderMaterial({uniforms:l,vertexShader:r,fragmentShader:a,transparent:!0,alphaTest:1,blending:f.NormalBlending,depthTest:!0,depthWrite:!1,side:f.DoubleSide})}static buildVertexShaderProjection(){let e=`

            vec4 scaleRotationA = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,
                                                                            oddOffset, scaleRotationsTextureSize));
            vec4 scaleRotationB = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,
                                                                            oddOffset + uint(1), scaleRotationsTextureSize));

            vec3 scaleRotation123 = vec3(scaleRotationA.rgb) * (1.0 - fOddOffset) +
                                    vec3(scaleRotationA.ba, scaleRotationB.r) * fOddOffset;
            vec3 scaleRotation456 = vec3(scaleRotationA.a, scaleRotationB.rg) * (1.0 - fOddOffset) +
                                    vec3(scaleRotationB.gba) * fOddOffset;

            float missingW = sqrt(1.0 - scaleRotation456.x * scaleRotation456.x - scaleRotation456.y *
                                    scaleRotation456.y - scaleRotation456.z * scaleRotation456.z);
            mat3 R = quaternionToRotationMatrix(scaleRotation456.r, scaleRotation456.g, scaleRotation456.b, missingW);
            mat3 S = mat3(scaleRotation123.r, 0.0, 0.0,
                            0.0, scaleRotation123.g, 0.0,
                            0.0, 0.0, scaleRotation123.b);
            
            mat3 L = R * S;

            mat3x4 splat2World = mat3x4(vec4(L[0], 0.0),
                                        vec4(L[1], 0.0),
                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));

            mat4 world2ndc = transpose(projectionMatrix * transformModelViewMatrix);

            mat3x4 ndc2pix = mat3x4(vec4(viewport.x / 2.0, 0.0, 0.0, (viewport.x - 1.0) / 2.0),
                                    vec4(0.0, viewport.y / 2.0, 0.0, (viewport.y - 1.0) / 2.0),
                                    vec4(0.0, 0.0, 0.0, 1.0));

            mat3 T = transpose(splat2World) * world2ndc * ndc2pix;
            vec3 normal = vec3(viewMatrix * vec4(L[0][2], L[1][2], L[2][2], 0.0));
        `;return e+=`

                mat4 splat2World4 = mat4(vec4(L[0], 0.0),
                                        vec4(L[1], 0.0),
                                        vec4(L[2], 0.0),
                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));

                mat4 Tt = transpose(transpose(splat2World4) * world2ndc);

                vec4 tempPoint1 = Tt * vec4(1.0, 0.0, 0.0, 1.0);
                tempPoint1 /= tempPoint1.w;

                vec4 tempPoint2 = Tt * vec4(0.0, 1.0, 0.0, 1.0);
                tempPoint2 /= tempPoint2.w;

                vec4 center = Tt * vec4(0.0, 0.0, 0.0, 1.0);
                center /= center.w;

                vec2 basisVector1 = tempPoint1.xy - center.xy;
                vec2 basisVector2 = tempPoint2.xy - center.xy;

                vec2 basisVector1Screen = basisVector1 * 0.5 * viewport;
                vec2 basisVector2Screen = basisVector2 * 0.5 * viewport;

                const float minPix = 1.;
                if (length(basisVector1Screen) < minPix || length(basisVector2Screen) < minPix) {
                    
            vec3 T0 = vec3(T[0][0], T[0][1], T[0][2]);
            vec3 T1 = vec3(T[1][0], T[1][1], T[1][2]);
            vec3 T3 = vec3(T[2][0], T[2][1], T[2][2]);

            vec3 tempPoint = vec3(1.0, 1.0, -1.0);
            float distance = (T3.x * T3.x * tempPoint.x) + (T3.y * T3.y * tempPoint.y) + (T3.z * T3.z * tempPoint.z);
            vec3 f = (1.0 / distance) * tempPoint;
            if (abs(distance) < 0.00001) return;

            float pointImageX = (T0.x * T3.x * f.x) + (T0.y * T3.y * f.y) + (T0.z * T3.z * f.z);
            float pointImageY = (T1.x * T3.x * f.x) + (T1.y * T3.y * f.y) + (T1.z * T3.z * f.z);
            vec2 pointImage = vec2(pointImageX, pointImageY);

            float tempX = (T0.x * T0.x * f.x) + (T0.y * T0.y * f.y) + (T0.z * T0.z * f.z);
            float tempY = (T1.x * T1.x * f.x) + (T1.y * T1.y * f.y) + (T1.z * T1.z * f.z);
            vec2 temp = vec2(tempX, tempY);

            vec2 halfExtend = pointImage * pointImage - temp;
            vec2 extent = sqrt(max(vec2(0.0001), halfExtend));
            float radius = max(extent.x, extent.y);

            vec2 ndcOffset = ((position.xy * radius * 3.0) * basisViewport * 2.0);

            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
            gl_Position = quadPos;

            vT = T;
            vQuadCenter = pointImage;
            vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;
        
                } else {
                    vec2 ndcOffset = vec2(position.x * basisVector1 + position.y * basisVector2) * 3.0 * inverseFocalAdjustment;
                    vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
                    gl_Position = quadPos;

                    vT = T;
                    vQuadCenter = center.xy;
                    vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;
                }
            `,e+=Ye.getVertexShaderFadeIn(),e+="}",e}static buildFragmentShader(){return`
            precision highp float;
            #include <common>

            uniform vec3 debugColor;

            varying vec4 vColor;
            varying vec2 vUv;
            varying vec2 vPosition;
            varying mat3 vT;
            varying vec2 vQuadCenter;
            varying vec2 vFragCoord;

            void main () {

                const float FilterInvSquare = 2.0;
                const float near_n = 0.2;
                const float T = 1.0;

                vec2 xy = vQuadCenter;
                vec3 Tu = vT[0];
                vec3 Tv = vT[1];
                vec3 Tw = vT[2];
                vec3 k = vFragCoord.x * Tw - Tu;
                vec3 l = vFragCoord.y * Tw - Tv;
                vec3 p = cross(k, l);
                if (p.z == 0.0) discard;
                vec2 s = vec2(p.x / p.z, p.y / p.z);
                float rho3d = (s.x * s.x + s.y * s.y); 
                vec2 d = vec2(xy.x - vFragCoord.x, xy.y - vFragCoord.y);
                float rho2d = FilterInvSquare * (d.x * d.x + d.y * d.y); 

                // compute intersection and depth
                float rho = min(rho3d, rho2d);
                float depth = (rho3d <= rho2d) ? (s.x * Tw.x + s.y * Tw.y) + Tw.z : Tw.z; 
                if (depth < near_n) discard;
                //  vec4 nor_o = collected_normal_opacity[j];
                //  float normal[3] = {nor_o.x, nor_o.y, nor_o.z};
                float opa = vColor.a;

                float power = -0.5f * rho;
                if (power > 0.0f) discard;

                // Eq. (2) from 3D Gaussian splatting paper.
                // Obtain alpha by multiplying with Gaussian opacity
                // and its exponential falloff from mean.
                // Avoid numerical instabilities (see paper appendix). 
                float alpha = min(0.99f, opa * exp(power));
                if (alpha < 1.0f / 255.0f) discard;
                float test_T = T * (1.0 - alpha);
                if (test_T < 0.0001)discard;

                float w = alpha * T;
                gl_FragColor = vec4(vColor.rgb, w);
            }
        `}}class fo{static build(e){const s=new f.BufferGeometry;s.setIndex([0,1,2,0,2,3]);const t=new Float32Array(4*3),n=new f.BufferAttribute(t,3);s.setAttribute("position",n),n.setXYZ(0,-1,-1,0),n.setXYZ(1,-1,1,0),n.setXYZ(2,1,1,0),n.setXYZ(3,1,-1,0),n.needsUpdate=!0;const o=new f.InstancedBufferGeometry().copy(s),i=new Uint32Array(e),r=new f.InstancedBufferAttribute(i,1,!1);return r.setUsage(f.DynamicDrawUsage),o.setAttribute("splatIndex",r),o.instanceCount=0,o}}class mo extends f.Object3D{constructor(e,s=new f.Vector3,t=new f.Quaternion,n=new f.Vector3(1,1,1),o=1,i=1,r=!0){super(),this.splatBuffer=e,this.position.copy(s),this.quaternion.copy(t),this.scale.copy(n),this.transform=new f.Matrix4,this.minimumAlpha=o,this.opacity=i,this.visible=r}copyTransformData(e){this.position.copy(e.position),this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.transform.copy(e.transform)}updateTransform(e){e?(this.matrixWorldAutoUpdate&&this.updateWorldMatrix(!0,!1),this.transform.copy(this.matrixWorld)):(this.matrixAutoUpdate&&this.updateMatrix(),this.transform.copy(this.matrix))}}class Jt{static idGen=0;constructor(e,s,t,n){this.min=new f.Vector3().copy(e),this.max=new f.Vector3().copy(s),this.boundingBox=new f.Box3(this.min,this.max),this.center=new f.Vector3().copy(this.max).sub(this.min).multiplyScalar(.5).add(this.min),this.depth=t,this.children=[],this.data=null,this.id=n||Jt.idGen++}}class nt{constructor(e,s){this.maxDepth=e,this.maxCentersPerNode=s,this.sceneDimensions=new f.Vector3,this.sceneMin=new f.Vector3,this.sceneMax=new f.Vector3,this.rootNode=null,this.nodesWithIndexes=[],this.splatMesh=null}static convertWorkerSubTreeNode(e){const s=new f.Vector3().fromArray(e.min),t=new f.Vector3().fromArray(e.max),n=new Jt(s,t,e.depth,e.id);if(e.data.indexes){n.data={indexes:[]};for(let o of e.data.indexes)n.data.indexes.push(o)}if(e.children)for(let o of e.children)n.children.push(nt.convertWorkerSubTreeNode(o));return n}static convertWorkerSubTree(e,s){const t=new nt(e.maxDepth,e.maxCentersPerNode);t.sceneMin=new f.Vector3().fromArray(e.sceneMin),t.sceneMax=new f.Vector3().fromArray(e.sceneMax),t.splatMesh=s,t.rootNode=nt.convertWorkerSubTreeNode(e.rootNode);const n=(o,i)=>{o.children.length===0&&i(o);for(let r of o.children)n(r,i)};return t.nodesWithIndexes=[],n(t.rootNode,o=>{o.data&&o.data.indexes&&o.data.indexes.length>0&&t.nodesWithIndexes.push(o)}),t}}function Ao(A){let e=0;class s{constructor(a,l){this.min=[a[0],a[1],a[2]],this.max=[l[0],l[1],l[2]]}containsPoint(a){return a[0]>=this.min[0]&&a[0]<=this.max[0]&&a[1]>=this.min[1]&&a[1]<=this.max[1]&&a[2]>=this.min[2]&&a[2]<=this.max[2]}}class t{constructor(a,l){this.maxDepth=a,this.maxCentersPerNode=l,this.sceneDimensions=[],this.sceneMin=[],this.sceneMax=[],this.rootNode=null,this.addedIndexes={},this.nodesWithIndexes=[],this.splatMesh=null,this.disposed=!1}}class n{constructor(a,l,c,d){this.min=[a[0],a[1],a[2]],this.max=[l[0],l[1],l[2]],this.center=[(l[0]-a[0])*.5+a[0],(l[1]-a[1])*.5+a[1],(l[2]-a[2])*.5+a[2]],this.depth=c,this.children=[],this.data=null,this.id=d||e++}}processSplatTreeNode=function(r,a,l,c){const d=a.data.indexes.length;if(d<r.maxCentersPerNode||a.depth>r.maxDepth){const S=[];for(let T=0;T<a.data.indexes.length;T++)r.addedIndexes[a.data.indexes[T]]||(S.push(a.data.indexes[T]),r.addedIndexes[a.data.indexes[T]]=!0);a.data.indexes=S,a.data.indexes.sort((T,w)=>T>w?1:-1),r.nodesWithIndexes.push(a);return}const u=[a.max[0]-a.min[0],a.max[1]-a.min[1],a.max[2]-a.min[2]],h=[u[0]*.5,u[1]*.5,u[2]*.5],m=[a.min[0]+h[0],a.min[1]+h[1],a.min[2]+h[2]],p=[new s([m[0]-h[0],m[1],m[2]-h[2]],[m[0],m[1]+h[1],m[2]]),new s([m[0],m[1],m[2]-h[2]],[m[0]+h[0],m[1]+h[1],m[2]]),new s([m[0],m[1],m[2]],[m[0]+h[0],m[1]+h[1],m[2]+h[2]]),new s([m[0]-h[0],m[1],m[2]],[m[0],m[1]+h[1],m[2]+h[2]]),new s([m[0]-h[0],m[1]-h[1],m[2]-h[2]],[m[0],m[1],m[2]]),new s([m[0],m[1]-h[1],m[2]-h[2]],[m[0]+h[0],m[1],m[2]]),new s([m[0],m[1]-h[1],m[2]],[m[0]+h[0],m[1],m[2]+h[2]]),new s([m[0]-h[0],m[1]-h[1],m[2]],[m[0],m[1],m[2]+h[2]])],g=[];for(let S=0;S<p.length;S++)g[S]=[];const C=[0,0,0];for(let S=0;S<d;S++){const T=a.data.indexes[S],w=l[T];C[0]=c[w],C[1]=c[w+1],C[2]=c[w+2];for(let x=0;x<p.length;x++)p[x].containsPoint(C)&&g[x].push(T)}for(let S=0;S<p.length;S++){const T=new n(p[S].min,p[S].max,a.depth+1);T.data={indexes:g[S]},a.children.push(T)}a.data={};for(let S of a.children)processSplatTreeNode(r,S,l,c)};const o=(r,a,l)=>{const c=[0,0,0],d=[0,0,0],u=[],h=Math.floor(r.length/4);for(let p=0;p<h;p++){const g=p*4,C=r[g],S=r[g+1],T=r[g+2],w=Math.round(r[g+3]);(p===0||C<c[0])&&(c[0]=C),(p===0||C>d[0])&&(d[0]=C),(p===0||S<c[1])&&(c[1]=S),(p===0||S>d[1])&&(d[1]=S),(p===0||T<c[2])&&(c[2]=T),(p===0||T>d[2])&&(d[2]=T),u.push(w)}const m=new t(a,l);return m.sceneMin=c,m.sceneMax=d,m.rootNode=new n(m.sceneMin,m.sceneMax,0),m.rootNode.data={indexes:u},m};function i(r,a,l){const c=[];for(let u of r){const h=Math.floor(u.length/4);for(let m=0;m<h;m++){const p=m*4,g=Math.round(u[p+3]);c[g]=p}}const d=[];for(let u of r){const h=o(u,a,l);d.push(h),processSplatTreeNode(h,h.rootNode,c,u)}A.postMessage({subTrees:d})}A.onmessage=r=>{r.data.process&&i(r.data.process.centers,r.data.process.maxDepth,r.data.process.maxCentersPerNode)}}function go(A,e,s,t,n){A.postMessage({process:{centers:e,maxDepth:t,maxCentersPerNode:n}},s)}function So(){return new Worker(URL.createObjectURL(new Blob(["(",Ao.toString(),")(self)"],{type:"application/javascript"})))}class Co{constructor(e,s){this.maxDepth=e,this.maxCentersPerNode=s,this.subTrees=[],this.splatMesh=null}dispose(){this.diposeSplatTreeWorker(),this.disposed=!0}diposeSplatTreeWorker(){this.splatTreeWorker&&this.splatTreeWorker.terminate(),this.splatTreeWorker=null}processSplatMesh=function(e,s=()=>!0,t,n){this.splatTreeWorker||(this.splatTreeWorker=So()),this.splatMesh=e,this.subTrees=[];const o=new f.Vector3,i=(r,a)=>{const l=new Float32Array(a*4);let c=0;for(let d=0;d<a;d++){const u=d+r;if(s(u)){e.getSplatCenter(u,o);const h=c*4;l[h]=o.x,l[h+1]=o.y,l[h+2]=o.z,l[h+3]=u,c++}}return l};return new Promise(r=>{const a=()=>this.disposed?(this.diposeSplatTreeWorker(),r(),!0):!1;t&&t(!1),we(()=>{if(a())return;const l=[];if(e.dynamicMode){let c=0;for(let d=0;d<e.scenes.length;d++){const h=e.getScene(d).splatBuffer.getSplatCount(),m=i(c,h);l.push(m),c+=h}}else{const c=i(0,e.getSplatCount());l.push(c)}this.splatTreeWorker.onmessage=c=>{a()||c.data.subTrees&&(n&&n(!1),we(()=>{if(!a()){for(let d of c.data.subTrees){const u=nt.convertWorkerSubTree(d,e);this.subTrees.push(u)}this.diposeSplatTreeWorker(),n&&n(!0),we(()=>{r()})}}))},we(()=>{if(a())return;t&&t(!0);const c=l.map(d=>d.buffer);go(this.splatTreeWorker,l,c,this.maxDepth,this.maxCentersPerNode)})})})};countLeaves(){let e=0;return this.visitLeaves(()=>{e++}),e}visitLeaves(e){const s=(t,n)=>{t.children.length===0&&n(t);for(let o of t.children)s(o,n)};for(let t of this.subTrees)s(t.rootNode,e)}}function yo(A){const e={};function s(t){if(e[t]!==void 0)return e[t];let n;switch(t){case"WEBGL_depth_texture":n=A.getExtension("WEBGL_depth_texture")||A.getExtension("MOZ_WEBGL_depth_texture")||A.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=A.getExtension("EXT_texture_filter_anisotropic")||A.getExtension("MOZ_EXT_texture_filter_anisotropic")||A.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=A.getExtension("WEBGL_compressed_texture_s3tc")||A.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||A.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=A.getExtension("WEBGL_compressed_texture_pvrtc")||A.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=A.getExtension(t)}return e[t]=n,n}return{has:function(t){return s(t)!==null},init:function(t){t.isWebGL2?(s("EXT_color_buffer_float"),s("WEBGL_clip_cull_distance")):(s("WEBGL_depth_texture"),s("OES_texture_float"),s("OES_texture_half_float"),s("OES_texture_half_float_linear"),s("OES_standard_derivatives"),s("OES_element_index_uint"),s("OES_vertex_array_object"),s("ANGLE_instanced_arrays")),s("OES_texture_float_linear"),s("EXT_color_buffer_half_float"),s("WEBGL_multisampled_render_to_texture")},get:function(t){const n=s(t);return n===null&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),n}}}function xo(A,e,s){let t;function n(){if(t!==void 0)return t;if(e.has("EXT_texture_filter_anisotropic")===!0){const y=e.get("EXT_texture_filter_anisotropic");t=A.getParameter(y.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else t=0;return t}function o(y){if(y==="highp"){if(A.getShaderPrecisionFormat(A.VERTEX_SHADER,A.HIGH_FLOAT).precision>0&&A.getShaderPrecisionFormat(A.FRAGMENT_SHADER,A.HIGH_FLOAT).precision>0)return"highp";y="mediump"}return y==="mediump"&&A.getShaderPrecisionFormat(A.VERTEX_SHADER,A.MEDIUM_FLOAT).precision>0&&A.getShaderPrecisionFormat(A.FRAGMENT_SHADER,A.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const i=typeof WebGL2RenderingContext<"u"&&A.constructor.name==="WebGL2RenderingContext";let r=s.precision!==void 0?s.precision:"highp";const a=o(r);a!==r&&(console.warn("THREE.WebGLRenderer:",r,"not supported, using",a,"instead."),r=a);const l=i||e.has("WEBGL_draw_buffers"),c=s.logarithmicDepthBuffer===!0,d=A.getParameter(A.MAX_TEXTURE_IMAGE_UNITS),u=A.getParameter(A.MAX_VERTEX_TEXTURE_IMAGE_UNITS),h=A.getParameter(A.MAX_TEXTURE_SIZE),m=A.getParameter(A.MAX_CUBE_MAP_TEXTURE_SIZE),p=A.getParameter(A.MAX_VERTEX_ATTRIBS),g=A.getParameter(A.MAX_VERTEX_UNIFORM_VECTORS),C=A.getParameter(A.MAX_VARYING_VECTORS),S=A.getParameter(A.MAX_FRAGMENT_UNIFORM_VECTORS),T=u>0,w=i||e.has("OES_texture_float"),x=T&&w,E=i?A.getParameter(A.MAX_SAMPLES):0;return{isWebGL2:i,drawBuffers:l,getMaxAnisotropy:n,getMaxPrecision:o,precision:r,logarithmicDepthBuffer:c,maxTextures:d,maxVertexTextures:u,maxTextureSize:h,maxCubemapSize:m,maxAttributes:p,maxVertexUniforms:g,maxVaryings:C,maxFragmentUniforms:S,vertexTextures:T,floatFragmentTextures:w,floatVertexTextures:x,maxSamples:E}}const ot={Default:0,Instant:2},Xe={None:0,Info:3},vs=new f.BufferGeometry,To=new f.MeshBasicMaterial,ft=6,Io=4,Bo=4,wo=4,Eo=6,vo=8,bt=4,Mt=4,Ds=1,Do=.012,Fo=.003,Fs=1,bs=16777216;class ge extends f.Mesh{constructor(e=Pe.ThreeD,s=!1,t=!1,n=!1,o=1,i=!0,r=!1,a=!1,l=1024,c=Xe.None,d=0,u=1,h=.3){super(vs,To),this.renderer=void 0,this.splatRenderMode=e,this.dynamicMode=s,this.enableOptionalEffects=t,this.halfPrecisionCovariancesOnGPU=n,this.devicePixelRatio=o,this.enableDistancesComputationOnGPU=i,this.integerBasedDistancesComputation=r,this.antialiased=a,this.kernel2DSize=h,this.maxScreenSpaceSplatSize=l,this.logLevel=c,this.sphericalHarmonicsDegree=d,this.minSphericalHarmonicsDegree=0,this.sceneFadeInRateMultiplier=u,this.scenes=[],this.splatTree=null,this.baseSplatTree=null,this.splatDataTextures={},this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,sceneIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,sceneIndexesLoc:-1,transformsLocs:[]},this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[],this.lastBuildSplatCount=0,this.lastBuildScenes=[],this.lastBuildMaxSplatCount=0,this.lastBuildSceneCount=0,this.firstRenderTime=-1,this.finalBuild=!1,this.webGLUtils=null,this.boundingBox=new f.Box3,this.calculatedSceneCenter=new f.Vector3,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.visibleRegionChanging=!1,this.splatScale=1,this.pointCloudModeEnabled=!1,this.disposed=!1,this.lastRenderer=null,this.visible=!1}static buildScenes(e,s,t){const n=[];n.length=s.length;for(let o=0;o<s.length;o++){const i=s[o],r=t[o]||{};let a=r.position||[0,0,0],l=r.rotation||[0,0,0,1],c=r.scale||[1,1,1];const d=new f.Vector3().fromArray(a),u=new f.Quaternion().fromArray(l),h=new f.Vector3().fromArray(c),m=ge.createScene(i,d,u,h,r.splatAlphaRemovalThreshold||1,r.opacity,r.visible);e.add(m),n[o]=m}return n}static createScene(e,s,t,n,o,i=1,r=!0){return new mo(e,s,t,n,o,i,r)}static buildSplatIndexMaps(e){const s=[],t=[];let n=0;for(let o=0;o<e.length;o++){const r=e[o].getMaxSplatCount();for(let a=0;a<r;a++)s[n]=a,t[n]=o,n++}return{localSplatIndexMap:s,sceneIndexMap:t}}buildSplatTree=function(e=[],s,t){return new Promise(n=>{this.disposeSplatTree(),this.baseSplatTree=new Co(8,1e3);const o=performance.now(),i=new f.Vector4;this.baseSplatTree.processSplatMesh(this,r=>{this.getSplatColor(r,i);const a=this.getSceneIndexForSplat(r),l=e[a]||1;return i.w>=l},s,t).then(()=>{const r=performance.now()-o;if(this.logLevel>=Xe.Info&&console.log("SplatTree build: "+r+" ms"),this.disposed)n();else{this.splatTree=this.baseSplatTree,this.baseSplatTree=null;let a=0,l=0,c=0;this.splatTree.visitLeaves(d=>{const u=d.data.indexes.length;u>0&&(l+=u,c++,a++)}),this.logLevel>=Xe.Info&&(console.log(`SplatTree leaves: ${this.splatTree.countLeaves()}`),console.log(`SplatTree leaves with splats:${a}`),l=l/c,console.log(`Avg splat count per node: ${l}`),console.log(`Total splat count: ${this.getSplatCount()}`)),n()}})})};build(e,s,t=!0,n=!1,o,i,r=!0){this.sceneOptions=s,this.finalBuild=n;const a=ge.getTotalMaxSplatCountForSplatBuffers(e),l=ge.buildScenes(this,e,s);if(t)for(let p=0;p<this.scenes.length&&p<l.length;p++){const g=l[p],C=this.getScene(p);g.copyTransformData(C)}this.scenes=l;let c=3;for(let p of e){const g=p.getMinSphericalHarmonicsDegree();g<c&&(c=g)}this.minSphericalHarmonicsDegree=Math.min(c,this.sphericalHarmonicsDegree);let d=!1;if(e.length!==this.lastBuildScenes.length)d=!0;else for(let p=0;p<e.length;p++)if(e[p]!==this.lastBuildScenes[p].splatBuffer){d=!0;break}let u=!0;if((this.scenes.length!==1||this.lastBuildSceneCount!==this.scenes.length||this.lastBuildMaxSplatCount!==a||d)&&(u=!1),!u){this.boundingBox=new f.Box3,r||(this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.firstRenderTime=-1),this.lastBuildScenes=[],this.lastBuildSplatCount=0,this.lastBuildMaxSplatCount=0,this.disposeMeshData(),this.geometry=fo.build(a),this.splatRenderMode===Pe.ThreeD?this.material=gt.build(this.dynamicMode,this.enableOptionalEffects,this.antialiased,this.maxScreenSpaceSplatSize,this.splatScale,this.pointCloudModeEnabled,this.minSphericalHarmonicsDegree,this.kernel2DSize):this.material=St.build(this.dynamicMode,this.enableOptionalEffects,this.splatScale,this.pointCloudModeEnabled,this.minSphericalHarmonicsDegree);const p=ge.buildSplatIndexMaps(e);this.globalSplatIndexToLocalSplatIndexMap=p.localSplatIndexMap,this.globalSplatIndexToSceneIndexMap=p.sceneIndexMap}const h=this.getSplatCount(!0);this.enableDistancesComputationOnGPU&&this.setupDistancesComputationTransformFeedback();const m=this.refreshGPUDataFromSplatBuffers(u);for(let p=0;p<this.scenes.length;p++)this.lastBuildScenes[p]=this.scenes[p];return this.lastBuildSplatCount=h,this.lastBuildMaxSplatCount=this.getMaxSplatCount(),this.lastBuildSceneCount=this.scenes.length,n&&this.scenes.length>0&&this.buildSplatTree(s.map(p=>p.splatAlphaRemovalThreshold||1),o,i).then(()=>{this.onSplatTreeReadyCallback&&this.onSplatTreeReadyCallback(this.splatTree),this.onSplatTreeReadyCallback=null}),this.visible=this.scenes.length>0,m}freeIntermediateSplatData(){const e=s=>{delete s.source.data,delete s.image,s.onUpdate=null};delete this.splatDataTextures.baseData.covariances,delete this.splatDataTextures.baseData.centers,delete this.splatDataTextures.baseData.colors,delete this.splatDataTextures.baseData.sphericalHarmonics,delete this.splatDataTextures.centerColors.data,delete this.splatDataTextures.covariances.data,this.splatDataTextures.sphericalHarmonics&&delete this.splatDataTextures.sphericalHarmonics.data,this.splatDataTextures.sceneIndexes&&delete this.splatDataTextures.sceneIndexes.data,this.splatDataTextures.centerColors.texture.needsUpdate=!0,this.splatDataTextures.centerColors.texture.onUpdate=()=>{e(this.splatDataTextures.centerColors.texture)},this.splatDataTextures.covariances.texture.needsUpdate=!0,this.splatDataTextures.covariances.texture.onUpdate=()=>{e(this.splatDataTextures.covariances.texture)},this.splatDataTextures.sphericalHarmonics&&(this.splatDataTextures.sphericalHarmonics.texture?(this.splatDataTextures.sphericalHarmonics.texture.needsUpdate=!0,this.splatDataTextures.sphericalHarmonics.texture.onUpdate=()=>{e(this.splatDataTextures.sphericalHarmonics.texture)}):this.splatDataTextures.sphericalHarmonics.textures.forEach(s=>{s.needsUpdate=!0,s.onUpdate=()=>{e(s)}})),this.splatDataTextures.sceneIndexes&&(this.splatDataTextures.sceneIndexes.texture.needsUpdate=!0,this.splatDataTextures.sceneIndexes.texture.onUpdate=()=>{e(this.splatDataTextures.sceneIndexes.texture)})}dispose(){this.disposeMeshData(),this.disposeTextures(),this.disposeSplatTree(),this.enableDistancesComputationOnGPU&&(this.computeDistancesOnGPUSyncTimeout&&(clearTimeout(this.computeDistancesOnGPUSyncTimeout),this.computeDistancesOnGPUSyncTimeout=null),this.disposeDistancesComputationGPUResources()),this.scenes=[],this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,sceneIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,sceneIndexesLoc:-1,transformsLocs:[]},this.renderer=null,this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[],this.lastBuildSplatCount=0,this.lastBuildScenes=[],this.lastBuildMaxSplatCount=0,this.lastBuildSceneCount=0,this.firstRenderTime=-1,this.finalBuild=!1,this.webGLUtils=null,this.boundingBox=new f.Box3,this.calculatedSceneCenter=new f.Vector3,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.visibleRegionChanging=!1,this.splatScale=1,this.pointCloudModeEnabled=!1,this.disposed=!0,this.lastRenderer=null,this.visible=!1}disposeMeshData(){this.geometry&&this.geometry!==vs&&(this.geometry.dispose(),this.geometry=null),this.material&&(this.material.dispose(),this.material=null)}disposeTextures(){for(let e in this.splatDataTextures)if(this.splatDataTextures.hasOwnProperty(e)){const s=this.splatDataTextures[e];s.texture&&(s.texture.dispose(),s.texture=null)}this.splatDataTextures=null}disposeSplatTree(){this.splatTree&&(this.splatTree.dispose(),this.splatTree=null),this.baseSplatTree&&(this.baseSplatTree.dispose(),this.baseSplatTree=null)}getSplatTree(){return this.splatTree}onSplatTreeReady(e){this.onSplatTreeReadyCallback=e}getDataForDistancesComputation(e,s){const t=this.integerBasedDistancesComputation?this.getIntegerCenters(e,s,!0):this.getFloatCenters(e,s,!0),n=this.getSceneIndexes(e,s);return{centers:t,sceneIndexes:n}}refreshGPUDataFromSplatBuffers(e){const s=this.getSplatCount(!0);this.refreshDataTexturesFromSplatBuffers(e);const t=e?this.lastBuildSplatCount:0,{centers:n,sceneIndexes:o}=this.getDataForDistancesComputation(t,s-1);return this.enableDistancesComputationOnGPU&&this.refreshGPUBuffersForDistancesComputation(n,o,e),{from:t,to:s-1,count:s-t,centers:n,sceneIndexes:o}}refreshGPUBuffersForDistancesComputation(e,s,t=!1){const n=t?this.lastBuildSplatCount:0;this.updateGPUCentersBufferForDistancesComputation(t,e,n),this.updateGPUTransformIndexesBufferForDistancesComputation(t,s,n)}refreshDataTexturesFromSplatBuffers(e){const s=this.getSplatCount(!0),t=this.lastBuildSplatCount,n=s-1;e?this.updateBaseDataFromSplatBuffers(t,n):(this.setupDataTextures(),this.updateBaseDataFromSplatBuffers()),this.updateDataTexturesFromBaseData(t,n),this.updateVisibleRegion(e)}setupDataTextures(){const e=this.getMaxSplatCount(),s=this.getSplatCount(!0);this.disposeTextures();const t=(y,v)=>{const D=new f.Vector2(4096,1024);for(;D.x*D.y*y<e*v;)D.y*=2;return D},n=y=>y>=1?Eo:Bo,o=y=>{const v=n(y),D=t(v,6);return{elementsPerTexelStored:v,texSize:D}};let i=this.getTargetCovarianceCompressionLevel();const r=0,a=this.getTargetSphericalHarmonicsCompressionLevel();let l,c,d;if(this.splatRenderMode===Pe.ThreeD){const y=o(i);y.texSize.x*y.texSize.y>bs&&i===0&&(i=1),l=new Float32Array(e*ft)}else c=new Float32Array(e*3),d=new Float32Array(e*4);const u=new Float32Array(e*3),h=new Uint8Array(e*4);let m=Float32Array;a===1?m=Uint16Array:a===2&&(m=Uint8Array);const p=je(this.minSphericalHarmonicsDegree),g=this.minSphericalHarmonicsDegree?new m(e*p):void 0,C=t(Mt,4),S=new Uint32Array(C.x*C.y*Mt);ge.updateCenterColorsPaddedData(0,s-1,u,h,S);const T=new f.DataTexture(S,C.x,C.y,f.RGBAIntegerFormat,f.UnsignedIntType);if(T.internalFormat="RGBA32UI",T.needsUpdate=!0,this.material.uniforms.centersColorsTexture.value=T,this.material.uniforms.centersColorsTextureSize.value.copy(C),this.material.uniformsNeedUpdate=!0,this.splatDataTextures={baseData:{covariances:l,scales:c,rotations:d,centers:u,colors:h,sphericalHarmonics:g},centerColors:{data:S,texture:T,size:C}},this.splatRenderMode===Pe.ThreeD){const y=o(i),v=y.elementsPerTexelStored,D=y.texSize;let b=i>=1?Uint32Array:Float32Array;const F=i>=1?vo:wo,R=new b(D.x*D.y*F);i===0?R.set(l):ge.updatePaddedCompressedCovariancesTextureData(l,R,0,0,l.length);let k;if(i>=1)k=new f.DataTexture(R,D.x,D.y,f.RGBAIntegerFormat,f.UnsignedIntType),k.internalFormat="RGBA32UI",this.material.uniforms.covariancesTextureHalfFloat.value=k;else{k=new f.DataTexture(R,D.x,D.y,f.RGBAFormat,f.FloatType),this.material.uniforms.covariancesTexture.value=k;const M=new f.DataTexture(new Uint32Array(32),2,2,f.RGBAIntegerFormat,f.UnsignedIntType);M.internalFormat="RGBA32UI",this.material.uniforms.covariancesTextureHalfFloat.value=M,M.needsUpdate=!0}k.needsUpdate=!0,this.material.uniforms.covariancesAreHalfFloat.value=i>=1?1:0,this.material.uniforms.covariancesTextureSize.value.copy(D),this.splatDataTextures.covariances={data:R,texture:k,size:D,compressionLevel:i,elementsPerTexelStored:v,elementsPerTexelAllocated:F}}else{const v=t(bt,6);let D=Float32Array,b=f.FloatType;const F=new D(v.x*v.y*bt);ge.updateScaleRotationsPaddedData(0,s-1,c,d,F);const R=new f.DataTexture(F,v.x,v.y,f.RGBAFormat,b);R.needsUpdate=!0,this.material.uniforms.scaleRotationsTexture.value=R,this.material.uniforms.scaleRotationsTextureSize.value.copy(v),this.splatDataTextures.scaleRotations={data:F,texture:R,size:v,compressionLevel:r}}if(g){const y=a===2?f.UnsignedByteType:f.HalfFloatType;let v=p;v%2!==0&&v++;const D=4,b=f.RGBAFormat;let F=t(D,v);if(F.x*F.y<=bs){const R=F.x*F.y*D,k=new m(R);for(let O=0;O<s;O++){const L=p*O,U=v*O;for(let _=0;_<p;_++)k[U+_]=g[L+_]}const M=new f.DataTexture(k,F.x,F.y,b,y);M.needsUpdate=!0,this.material.uniforms.sphericalHarmonicsTexture.value=M,this.splatDataTextures.sphericalHarmonics={componentCount:p,paddedComponentCount:v,data:k,textureCount:1,texture:M,size:F,compressionLevel:a,elementsPerTexel:D}}else{const R=p/3;v=R,v%2!==0&&v++,F=t(D,v);const k=F.x*F.y*D,M=[this.material.uniforms.sphericalHarmonicsTextureR,this.material.uniforms.sphericalHarmonicsTextureG,this.material.uniforms.sphericalHarmonicsTextureB],O=[],L=[];for(let U=0;U<3;U++){const _=new m(k);O.push(_);for(let Q=0;Q<s;Q++){const Z=p*Q,ie=v*Q;if(R>=3){for(let V=0;V<3;V++)_[ie+V]=g[Z+U*3+V];if(R>=8)for(let V=0;V<5;V++)_[ie+3+V]=g[Z+9+U*5+V]}}const H=new f.DataTexture(_,F.x,F.y,b,y);L.push(H),H.needsUpdate=!0,M[U].value=H}this.material.uniforms.sphericalHarmonicsMultiTextureMode.value=1,this.splatDataTextures.sphericalHarmonics={componentCount:p,componentCountPerChannel:R,paddedComponentCount:v,data:O,textureCount:3,textures:L,size:F,compressionLevel:a,elementsPerTexel:D}}this.material.uniforms.sphericalHarmonicsTextureSize.value.copy(F),this.material.uniforms.sphericalHarmonics8BitMode.value=a===2?1:0;for(let R=0;R<this.scenes.length;R++){const k=this.scenes[R].splatBuffer;this.material.uniforms.sphericalHarmonics8BitCompressionRangeMin.value[R]=k.minSphericalHarmonicsCoeff,this.material.uniforms.sphericalHarmonics8BitCompressionRangeMax.value[R]=k.maxSphericalHarmonicsCoeff}this.material.uniformsNeedUpdate=!0}const w=t(Ds,4),x=new Uint32Array(w.x*w.y*Ds);for(let y=0;y<s;y++)x[y]=this.globalSplatIndexToSceneIndexMap[y];const E=new f.DataTexture(x,w.x,w.y,f.RedIntegerFormat,f.UnsignedIntType);E.internalFormat="R32UI",E.needsUpdate=!0,this.material.uniforms.sceneIndexesTexture.value=E,this.material.uniforms.sceneIndexesTextureSize.value.copy(w),this.material.uniformsNeedUpdate=!0,this.splatDataTextures.sceneIndexes={data:x,texture:E,size:w},this.material.uniforms.sceneCount.value=this.scenes.length}updateBaseDataFromSplatBuffers(e,s){const t=this.splatDataTextures.covariances,n=t?t.compressionLevel:void 0,o=this.splatDataTextures.scaleRotations,i=o?o.compressionLevel:void 0,r=this.splatDataTextures.sphericalHarmonics,a=r?r.compressionLevel:0;this.fillSplatDataArrays(this.splatDataTextures.baseData.covariances,this.splatDataTextures.baseData.scales,this.splatDataTextures.baseData.rotations,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,this.splatDataTextures.baseData.sphericalHarmonics,void 0,n,i,a,e,s,e)}updateDataTexturesFromBaseData(e,s){const t=this.splatDataTextures.covariances,n=t?t.compressionLevel:void 0,o=this.splatDataTextures.scaleRotations,i=o?o.compressionLevel:void 0,r=this.splatDataTextures.sphericalHarmonics,a=r?r.compressionLevel:0,l=this.splatDataTextures.centerColors,c=l.data,d=l.texture;ge.updateCenterColorsPaddedData(e,s,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,c);const u=this.renderer?this.renderer.properties.get(d):null;if(!u||!u.__webglTexture?d.needsUpdate=!0:this.updateDataTexture(c,l.texture,l.size,u,Mt,Io,4,e,s),t){const S=t.texture,T=e*ft,w=s*ft;if(n===0)for(let E=T;E<=w;E++){const y=this.splatDataTextures.baseData.covariances[E];t.data[E]=y}else ge.updatePaddedCompressedCovariancesTextureData(this.splatDataTextures.baseData.covariances,t.data,e*t.elementsPerTexelAllocated,T,w);const x=this.renderer?this.renderer.properties.get(S):null;!x||!x.__webglTexture?S.needsUpdate=!0:n===0?this.updateDataTexture(t.data,t.texture,t.size,x,t.elementsPerTexelStored,ft,4,e,s):this.updateDataTexture(t.data,t.texture,t.size,x,t.elementsPerTexelAllocated,t.elementsPerTexelAllocated,2,e,s)}if(o){const S=o.data,T=o.texture,w=6,x=i===0?4:2;ge.updateScaleRotationsPaddedData(e,s,this.splatDataTextures.baseData.scales,this.splatDataTextures.baseData.rotations,S);const E=this.renderer?this.renderer.properties.get(T):null;!E||!E.__webglTexture?T.needsUpdate=!0:this.updateDataTexture(S,o.texture,o.size,E,bt,w,x,e,s)}const h=this.splatDataTextures.baseData.sphericalHarmonics;if(h){let S=4;a===1?S=2:a===2&&(S=1);const T=(E,y,v,D,b)=>{const F=this.renderer?this.renderer.properties.get(E):null;!F||!F.__webglTexture?E.needsUpdate=!0:this.updateDataTexture(D,E,y,F,v,b,S,e,s)},w=r.componentCount,x=r.paddedComponentCount;if(r.textureCount===1){const E=r.data;for(let y=e;y<=s;y++){const v=w*y,D=x*y;for(let b=0;b<w;b++)E[D+b]=h[v+b]}T(r.texture,r.size,r.elementsPerTexel,E,x)}else{const E=r.componentCountPerChannel;for(let y=0;y<3;y++){const v=r.data[y];for(let D=e;D<=s;D++){const b=w*D,F=x*D;if(E>=3){for(let R=0;R<3;R++)v[F+R]=h[b+y*3+R];if(E>=8)for(let R=0;R<5;R++)v[F+3+R]=h[b+9+y*5+R]}}T(r.textures[y],r.size,r.elementsPerTexel,v,x)}}}const m=this.splatDataTextures.sceneIndexes,p=m.data;for(let S=this.lastBuildSplatCount;S<=s;S++)p[S]=this.globalSplatIndexToSceneIndexMap[S];const g=m.texture,C=this.renderer?this.renderer.properties.get(g):null;!C||!C.__webglTexture?g.needsUpdate=!0:this.updateDataTexture(p,m.texture,m.size,C,1,1,1,this.lastBuildSplatCount,s)}getTargetCovarianceCompressionLevel(){return this.halfPrecisionCovariancesOnGPU?1:0}getTargetSphericalHarmonicsCompressionLevel(){return Math.max(1,this.getMaximumSplatBufferCompressionLevel())}getMaximumSplatBufferCompressionLevel(){let e;for(let s=0;s<this.scenes.length;s++){const n=this.getScene(s).splatBuffer;(s===0||n.compressionLevel>e)&&(e=n.compressionLevel)}return e}getMinimumSplatBufferCompressionLevel(){let e;for(let s=0;s<this.scenes.length;s++){const n=this.getScene(s).splatBuffer;(s===0||n.compressionLevel<e)&&(e=n.compressionLevel)}return e}static computeTextureUpdateRegion(e,s,t,n,o){const i=o/n,r=e*i,a=Math.floor(r/t),l=a*t*n,c=s*i,d=Math.floor(c/t),u=d*t*n+t*n;return{dataStart:l,dataEnd:u,startRow:a,endRow:d}}updateDataTexture(e,s,t,n,o,i,r,a,l){const c=this.renderer.getContext(),d=ge.computeTextureUpdateRegion(a,l,t.x,o,i),u=d.dataEnd-d.dataStart,h=new e.constructor(e.buffer,d.dataStart*r,u),m=d.endRow-d.startRow+1,p=this.webGLUtils.convert(s.type),g=this.webGLUtils.convert(s.format,s.colorSpace),C=c.getParameter(c.TEXTURE_BINDING_2D);c.bindTexture(c.TEXTURE_2D,n.__webglTexture),c.texSubImage2D(c.TEXTURE_2D,0,0,d.startRow,t.x,m,g,p,h),c.bindTexture(c.TEXTURE_2D,C)}static updatePaddedCompressedCovariancesTextureData(e,s,t,n,o){let i=new DataView(s.buffer),r=t,a=0;for(let l=n;l<=o;l+=2)i.setUint16(r*2,e[l],!0),i.setUint16(r*2+2,e[l+1],!0),r+=2,a++,a>=3&&(r+=2,a=0)}static updateCenterColorsPaddedData(e,s,t,n,o){for(let i=e;i<=s;i++){const r=i*4,a=i*3,l=i*4;o[l]=on(n,r),o[l+1]=It(t[a]),o[l+2]=It(t[a+1]),o[l+3]=It(t[a+2])}}static updateScaleRotationsPaddedData(e,s,t,n,o){for(let r=e;r<=s;r++){const a=r*3,l=r*4,c=r*6;o[c]=t[a],o[c+1]=t[a+1],o[c+2]=t[a+2],o[c+3]=n[l],o[c+4]=n[l+1],o[c+5]=n[l+2]}}updateVisibleRegion(e){const s=this.getSplatCount(!0),t=new f.Vector3;if(!e){const o=new f.Vector3;this.scenes.forEach(i=>{o.add(i.splatBuffer.sceneCenter)}),o.multiplyScalar(1/this.scenes.length),this.calculatedSceneCenter.copy(o),this.material.uniforms.sceneCenter.value.copy(this.calculatedSceneCenter),this.material.uniformsNeedUpdate=!0}const n=e?this.lastBuildSplatCount:0;for(let o=n;o<s;o++){this.getSplatCenter(o,t,!0);const i=t.sub(this.calculatedSceneCenter).length();i>this.maxSplatDistanceFromSceneCenter&&(this.maxSplatDistanceFromSceneCenter=i)}this.maxSplatDistanceFromSceneCenter-this.visibleRegionBufferRadius>Fs&&(this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter,this.visibleRegionRadius=Math.max(this.visibleRegionBufferRadius-Fs,0)),this.finalBuild&&(this.visibleRegionRadius=this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter),this.updateVisibleRegionFadeDistance()}updateVisibleRegionFadeDistance(e=ot.Default){const s=Do*this.sceneFadeInRateMultiplier,t=Fo*this.sceneFadeInRateMultiplier,n=this.finalBuild?s:t,o=e===ot.Default?n:t;this.visibleRegionFadeStartRadius=(this.visibleRegionRadius-this.visibleRegionFadeStartRadius)*o+this.visibleRegionFadeStartRadius;const r=(this.visibleRegionBufferRadius>0?this.visibleRegionFadeStartRadius/this.visibleRegionBufferRadius:0)>.99,a=r||e===ot.Instant?1:0;this.material.uniforms.visibleRegionFadeStartRadius.value=this.visibleRegionFadeStartRadius,this.material.uniforms.visibleRegionRadius.value=this.visibleRegionRadius,this.material.uniforms.firstRenderTime.value=this.firstRenderTime,this.material.uniforms.currentTime.value=performance.now(),this.material.uniforms.fadeInComplete.value=a,this.material.uniformsNeedUpdate=!0,this.visibleRegionChanging=!r}updateRenderIndexes(e,s){const t=this.geometry;t.attributes.splatIndex.set(e),t.attributes.splatIndex.needsUpdate=!0,s>0&&this.firstRenderTime===-1&&(this.firstRenderTime=performance.now()),t.instanceCount=s,t.setDrawRange(0,s)}updateTransforms(){for(let e=0;e<this.scenes.length;e++)this.getScene(e).updateTransform(this.dynamicMode)}updateUniforms=function(){const e=new f.Vector2;return function(s,t,n,o,i,r){if(this.getSplatCount()>0){if(e.set(s.x*this.devicePixelRatio,s.y*this.devicePixelRatio),this.material.uniforms.viewport.value.copy(e),this.material.uniforms.basisViewport.value.set(1/e.x,1/e.y),this.material.uniforms.focal.value.set(t,n),this.material.uniforms.orthographicMode.value=o?1:0,this.material.uniforms.orthoZoom.value=i,this.material.uniforms.inverseFocalAdjustment.value=r,this.dynamicMode)for(let l=0;l<this.scenes.length;l++)this.material.uniforms.transforms.value[l].copy(this.getScene(l).transform);if(this.enableOptionalEffects)for(let l=0;l<this.scenes.length;l++)this.material.uniforms.sceneOpacity.value[l]=ne(this.getScene(l).opacity,0,1),this.material.uniforms.sceneVisibility.value[l]=this.getScene(l).visible?1:0,this.material.uniformsNeedUpdate=!0;this.material.uniformsNeedUpdate=!0}}}();setSplatScale(e=1){this.splatScale=e,this.material.uniforms.splatScale.value=e,this.material.uniformsNeedUpdate=!0}getSplatScale(){return this.splatScale}setPointCloudModeEnabled(e){this.pointCloudModeEnabled=e,this.material.uniforms.pointCloudModeEnabled.value=e?1:0,this.material.uniformsNeedUpdate=!0}getPointCloudModeEnabled(){return this.pointCloudModeEnabled}getSplatDataTextures(){return this.splatDataTextures}getSplatCount(e=!1){return e?ge.getTotalSplatCountForScenes(this.scenes):this.lastBuildSplatCount}static getTotalSplatCountForScenes(e){let s=0;for(let t of e)t&&t.splatBuffer&&(s+=t.splatBuffer.getSplatCount());return s}static getTotalSplatCountForSplatBuffers(e){let s=0;for(let t of e)s+=t.getSplatCount();return s}getMaxSplatCount(){return ge.getTotalMaxSplatCountForScenes(this.scenes)}static getTotalMaxSplatCountForScenes(e){let s=0;for(let t of e)t&&t.splatBuffer&&(s+=t.splatBuffer.getMaxSplatCount());return s}static getTotalMaxSplatCountForSplatBuffers(e){let s=0;for(let t of e)s+=t.getMaxSplatCount();return s}disposeDistancesComputationGPUResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.vao&&(e.deleteVertexArray(this.distancesTransformFeedback.vao),this.distancesTransformFeedback.vao=null),this.distancesTransformFeedback.program&&(e.deleteProgram(this.distancesTransformFeedback.program),e.deleteShader(this.distancesTransformFeedback.vertexShader),e.deleteShader(this.distancesTransformFeedback.fragmentShader),this.distancesTransformFeedback.program=null,this.distancesTransformFeedback.vertexShader=null,this.distancesTransformFeedback.fragmentShader=null),this.disposeDistancesComputationGPUBufferResources(),this.distancesTransformFeedback.id&&(e.deleteTransformFeedback(this.distancesTransformFeedback.id),this.distancesTransformFeedback.id=null)}disposeDistancesComputationGPUBufferResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.centersBuffer&&(this.distancesTransformFeedback.centersBuffer=null,e.deleteBuffer(this.distancesTransformFeedback.centersBuffer)),this.distancesTransformFeedback.outDistancesBuffer&&(e.deleteBuffer(this.distancesTransformFeedback.outDistancesBuffer),this.distancesTransformFeedback.outDistancesBuffer=null)}setRenderer(e){if(e!==this.renderer){this.renderer=e;const s=this.renderer.getContext(),t=new yo(s),n=new xo(s,t,{});if(t.init(n),this.webGLUtils=new f.WebGLUtils(s,t,n),this.enableDistancesComputationOnGPU&&this.getSplatCount()>0){this.setupDistancesComputationTransformFeedback();const{centers:o,sceneIndexes:i}=this.getDataForDistancesComputation(0,this.getSplatCount()-1);this.refreshGPUBuffersForDistancesComputation(o,i)}}}setupDistancesComputationTransformFeedback=function(){let e;return function(){const s=this.getMaxSplatCount();if(!this.renderer)return;const t=this.lastRenderer!==this.renderer,n=e!==s;if(!t&&!n)return;t?this.disposeDistancesComputationGPUResources():n&&this.disposeDistancesComputationGPUBufferResources();const o=this.renderer.getContext(),i=(u,h,m)=>{const p=u.createShader(h);if(!p)return console.error("Fatal error: gl could not create a shader object."),null;if(u.shaderSource(p,m),u.compileShader(p),!u.getShaderParameter(p,u.COMPILE_STATUS)){let C="unknown";h===u.VERTEX_SHADER?C="vertex shader":h===u.FRAGMENT_SHADER&&(C="fragement shader");const S=u.getShaderInfoLog(p);return console.error("Failed to compile "+C+" with these errors:"+S),u.deleteShader(p),null}return p};let r;this.integerBasedDistancesComputation?(r=`#version 300 es
                in ivec4 center;
                flat out int distance;`,this.dynamicMode?r+=`
                        in uint sceneIndex;
                        uniform ivec4 transforms[${j.MaxScenes}];
                        void main(void) {
                            ivec4 transform = transforms[sceneIndex];
                            distance = center.x * transform.x + center.y * transform.y + center.z * transform.z + transform.w * center.w;
                        }
                    `:r+=`
                        uniform ivec3 modelViewProj;
                        void main(void) {
                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;
                        }
                    `):(r=`#version 300 es
                in vec4 center;
                flat out float distance;`,this.dynamicMode?r+=`
                        in uint sceneIndex;
                        uniform mat4 transforms[${j.MaxScenes}];
                        void main(void) {
                            vec4 transformedCenter = transforms[sceneIndex] * vec4(center.xyz, 1.0);
                            distance = transformedCenter.z;
                        }
                    `:r+=`
                        uniform vec3 modelViewProj;
                        void main(void) {
                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;
                        }
                    `);const a=`#version 300 es
                precision lowp float;
                out vec4 fragColor;
                void main(){}
            `,l=o.getParameter(o.VERTEX_ARRAY_BINDING),c=o.getParameter(o.CURRENT_PROGRAM),d=c?o.getProgramParameter(c,o.DELETE_STATUS):!1;if(t&&(this.distancesTransformFeedback.vao=o.createVertexArray()),o.bindVertexArray(this.distancesTransformFeedback.vao),t){const u=o.createProgram(),h=i(o,o.VERTEX_SHADER,r),m=i(o,o.FRAGMENT_SHADER,a);if(!h||!m)throw new Error("Could not compile shaders for distances computation on GPU.");if(o.attachShader(u,h),o.attachShader(u,m),o.transformFeedbackVaryings(u,["distance"],o.SEPARATE_ATTRIBS),o.linkProgram(u),!o.getProgramParameter(u,o.LINK_STATUS)){const g=o.getProgramInfoLog(u);throw console.error("Fatal error: Failed to link program: "+g),o.deleteProgram(u),o.deleteShader(m),o.deleteShader(h),new Error("Could not link shaders for distances computation on GPU.")}this.distancesTransformFeedback.program=u,this.distancesTransformFeedback.vertexShader=h,this.distancesTransformFeedback.vertexShader=m}if(o.useProgram(this.distancesTransformFeedback.program),this.distancesTransformFeedback.centersLoc=o.getAttribLocation(this.distancesTransformFeedback.program,"center"),this.dynamicMode){this.distancesTransformFeedback.sceneIndexesLoc=o.getAttribLocation(this.distancesTransformFeedback.program,"sceneIndex");for(let u=0;u<this.scenes.length;u++)this.distancesTransformFeedback.transformsLocs[u]=o.getUniformLocation(this.distancesTransformFeedback.program,`transforms[${u}]`)}else this.distancesTransformFeedback.modelViewProjLoc=o.getUniformLocation(this.distancesTransformFeedback.program,"modelViewProj");(t||n)&&(this.distancesTransformFeedback.centersBuffer=o.createBuffer(),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),o.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?o.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,o.INT,0,0):o.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,4,o.FLOAT,!1,0,0),this.dynamicMode&&(this.distancesTransformFeedback.sceneIndexesBuffer=o.createBuffer(),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),o.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),o.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc,1,o.UNSIGNED_INT,0,0))),(t||n)&&(this.distancesTransformFeedback.outDistancesBuffer=o.createBuffer()),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),o.bufferData(o.ARRAY_BUFFER,s*4,o.STATIC_READ),t&&(this.distancesTransformFeedback.id=o.createTransformFeedback()),o.bindTransformFeedback(o.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),o.bindBufferBase(o.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),c&&d!==!0&&o.useProgram(c),l&&o.bindVertexArray(l),this.lastRenderer=this.renderer,e=s}}();updateGPUCentersBufferForDistancesComputation(e,s,t){if(!this.renderer)return;const n=this.renderer.getContext(),o=n.getParameter(n.VERTEX_ARRAY_BINDING);n.bindVertexArray(this.distancesTransformFeedback.vao);const i=this.integerBasedDistancesComputation?Uint32Array:Float32Array,r=16,a=t*r;if(n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),e)n.bufferSubData(n.ARRAY_BUFFER,a,s);else{const l=new i(this.getMaxSplatCount()*r);l.set(s),n.bufferData(n.ARRAY_BUFFER,l,n.STATIC_DRAW)}n.bindBuffer(n.ARRAY_BUFFER,null),o&&n.bindVertexArray(o)}updateGPUTransformIndexesBufferForDistancesComputation(e,s,t){if(!this.renderer||!this.dynamicMode)return;const n=this.renderer.getContext(),o=n.getParameter(n.VERTEX_ARRAY_BINDING);n.bindVertexArray(this.distancesTransformFeedback.vao);const i=t*4;if(n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),e)n.bufferSubData(n.ARRAY_BUFFER,i,s);else{const r=new Uint32Array(this.getMaxSplatCount()*4);r.set(s),n.bufferData(n.ARRAY_BUFFER,r,n.STATIC_DRAW)}n.bindBuffer(n.ARRAY_BUFFER,null),o&&n.bindVertexArray(o)}getSceneIndexes(e,s){let t;const n=s-e+1;t=new Uint32Array(n);for(let o=e;o<=s;o++)t[o]=this.globalSplatIndexToSceneIndexMap[o];return t}fillTransformsArray=function(){const e=[];return function(s){e.length!==s.length&&(e.length=s.length);for(let t=0;t<this.scenes.length;t++){const o=this.getScene(t).transform.elements;for(let i=0;i<16;i++)e[t*16+i]=o[i]}s.set(e)}}();computeDistancesOnGPU=function(){const e=new f.Matrix4;return function(s,t){if(!this.renderer)return;const n=this.renderer.getContext(),o=n.getParameter(n.VERTEX_ARRAY_BINDING),i=n.getParameter(n.CURRENT_PROGRAM),r=i?n.getProgramParameter(i,n.DELETE_STATUS):!1;if(n.bindVertexArray(this.distancesTransformFeedback.vao),n.useProgram(this.distancesTransformFeedback.program),n.enable(n.RASTERIZER_DISCARD),this.dynamicMode)for(let c=0;c<this.scenes.length;c++)if(e.copy(this.getScene(c).transform),e.premultiply(s),this.integerBasedDistancesComputation){const d=ge.getIntegerMatrixArray(e),u=[d[2],d[6],d[10],d[14]];n.uniform4i(this.distancesTransformFeedback.transformsLocs[c],u[0],u[1],u[2],u[3])}else n.uniformMatrix4fv(this.distancesTransformFeedback.transformsLocs[c],!1,e.elements);else if(this.integerBasedDistancesComputation){const c=ge.getIntegerMatrixArray(s),d=[c[2],c[6],c[10]];n.uniform3i(this.distancesTransformFeedback.modelViewProjLoc,d[0],d[1],d[2])}else{const c=[s.elements[2],s.elements[6],s.elements[10]];n.uniform3f(this.distancesTransformFeedback.modelViewProjLoc,c[0],c[1],c[2])}n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),n.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?n.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,n.INT,0,0):n.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,4,n.FLOAT,!1,0,0),this.dynamicMode&&(n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),n.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),n.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc,1,n.UNSIGNED_INT,0,0)),n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),n.beginTransformFeedback(n.POINTS),n.drawArrays(n.POINTS,0,this.getSplatCount()),n.endTransformFeedback(),n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER,0,null),n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,null),n.disable(n.RASTERIZER_DISCARD);const a=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush();const l=new Promise(c=>{const d=()=>{if(this.disposed)c();else switch(n.clientWaitSync(a,0,0)){case n.TIMEOUT_EXPIRED:return this.computeDistancesOnGPUSyncTimeout=setTimeout(d),this.computeDistancesOnGPUSyncTimeout;case n.WAIT_FAILED:throw new Error("should never get here");default:this.computeDistancesOnGPUSyncTimeout=null,n.deleteSync(a);const p=n.getParameter(n.VERTEX_ARRAY_BINDING);n.bindVertexArray(this.distancesTransformFeedback.vao),n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),n.getBufferSubData(n.ARRAY_BUFFER,0,t),n.bindBuffer(n.ARRAY_BUFFER,null),p&&n.bindVertexArray(p),c()}};this.computeDistancesOnGPUSyncTimeout=setTimeout(d)});return i&&r!==!0&&n.useProgram(i),o&&n.bindVertexArray(o),l}}();getLocalSplatParameters(e,s,t){t==null&&(t=!this.dynamicMode),s.splatBuffer=this.getSplatBufferForSplat(e),s.localIndex=this.getSplatLocalIndex(e),s.sceneTransform=t?this.getSceneTransformForSplat(e):null}fillSplatDataArrays(e,s,t,n,o,i,r,a=0,l=0,c=1,d,u,h=0,m){const p=new f.Vector3;p.x=void 0,p.y=void 0,this.splatRenderMode===Pe.ThreeD?p.z=void 0:p.z=1;const g=new f.Matrix4;let C=0,S=this.scenes.length-1;m!=null&&m>=0&&m<=this.scenes.length&&(C=m,S=m);for(let T=C;T<=S;T++){r==null&&(r=!this.dynamicMode);const w=this.getScene(T),x=w.splatBuffer;let E;if(r&&(this.getSceneTransform(T,g),E=g),e&&x.fillSplatCovarianceArray(e,E,d,u,h,a),s||t){if(!s||!t)throw new Error('SplatMesh::fillSplatDataArrays() -> "scales" and "rotations" must both be valid.');x.fillSplatScaleRotationArray(s,t,E,d,u,h,l,p)}n&&x.fillSplatCenterArray(n,E,d,u,h),o&&x.fillSplatColorArray(o,w.minimumAlpha,d,u,h),i&&x.fillSphericalHarmonicsArray(i,this.minSphericalHarmonicsDegree,E,d,u,h,c),h+=x.getSplatCount()}}getIntegerCenters(e,s,t=!1){const n=s-e+1,o=new Float32Array(n*3);this.fillSplatDataArrays(null,null,null,o,null,null,void 0,void 0,void 0,void 0,e);let i,r=t?4:3;i=new Int32Array(n*r);for(let a=0;a<n;a++){for(let l=0;l<3;l++)i[a*r+l]=Math.round(o[a*3+l]*1e3);t&&(i[a*r+3]=1e3)}return i}getFloatCenters(e,s,t=!1){const n=s-e+1,o=new Float32Array(n*3);if(this.fillSplatDataArrays(null,null,null,o,null,null,void 0,void 0,void 0,void 0,e),!t)return o;let i=new Float32Array(n*4);for(let r=0;r<n;r++){for(let a=0;a<3;a++)i[r*4+a]=o[r*3+a];i[r*4+3]=1}return i}getSplatCenter=function(){const e={};return function(s,t,n){this.getLocalSplatParameters(s,e,n),e.splatBuffer.getSplatCenter(e.localIndex,t,e.sceneTransform)}}();getSplatScaleAndRotation=function(){const e={},s=new f.Vector3;return function(t,n,o,i){this.getLocalSplatParameters(t,e,i),s.x=void 0,s.y=void 0,s.z=void 0,this.splatRenderMode===Pe.TwoD&&(s.z=0),e.splatBuffer.getSplatScaleAndRotation(e.localIndex,n,o,e.sceneTransform,s)}}();getSplatColor=function(){const e={};return function(s,t){this.getLocalSplatParameters(s,e),e.splatBuffer.getSplatColor(e.localIndex,t)}}();getSceneTransform(e,s){const t=this.getScene(e);t.updateTransform(this.dynamicMode),s.copy(t.transform)}getScene(e){if(e<0||e>=this.scenes.length)throw new Error("SplatMesh::getScene() -> Invalid scene index.");return this.scenes[e]}getSceneCount(){return this.scenes.length}getSplatBufferForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).splatBuffer}getSceneIndexForSplat(e){return this.globalSplatIndexToSceneIndexMap[e]}getSceneTransformForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).transform}getSplatLocalIndex(e){return this.globalSplatIndexToLocalSplatIndexMap[e]}static getIntegerMatrixArray(e){const s=e.elements,t=[];for(let n=0;n<16;n++)t[n]=Math.round(s[n]*1e3);return t}computeBoundingBox(e=!1,s){let t=this.getSplatCount();if(s!=null){if(s<0||s>=this.scenes.length)throw new Error("SplatMesh::computeBoundingBox() -> Invalid scene index.");t=this.scenes[s].splatBuffer.getSplatCount()}const n=new Float32Array(t*3);this.fillSplatDataArrays(null,null,null,n,null,null,e,void 0,void 0,void 0,void 0,s);const o=new f.Vector3,i=new f.Vector3;for(let r=0;r<t;r++){const a=r*3,l=n[a],c=n[a+1],d=n[a+2];(r===0||l<o.x)&&(o.x=l),(r===0||c<o.y)&&(o.y=c),(r===0||d<o.z)&&(o.z=d),(r===0||l>i.x)&&(i.x=l),(r===0||c>i.y)&&(i.y=c),(r===0||d>i.z)&&(i.z=d)}return new f.Box3(o,i)}}var bo="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",Ms="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",Mo="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",Ro="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";function Po(A){let e,s,t,n,o,i,r,a,l,c,d,u,h,m,p,g,C,S,T,w;function x(E,y,v,D,b,F,R){const k=performance.now();if(!t&&(new Uint32Array(s,r,b.byteLength/w.BytesPerInt).set(b),new Float32Array(s,c,R.byteLength/w.BytesPerFloat).set(R),D)){let _;n?_=new Int32Array(s,d,F.byteLength/w.BytesPerInt):_=new Float32Array(s,d,F.byteLength/w.BytesPerFloat),_.set(F)}g||(g=new Uint32Array(S)),new Float32Array(s,p,16).set(v),new Uint32Array(s,h,S).set(g),e.exports.sortIndexes(r,m,d,u,h,p,a,l,c,S,E,y,i,D,n,o);const M={sortDone:!0,splatSortCount:E,splatRenderCount:y,sortTime:0};if(!t){const L=new Uint32Array(s,a,y);(!C||C.length<y)&&(C=new Uint32Array(y)),C.set(L),M.sortedIndexes=C}const O=performance.now();M.sortTime=O-k,A.postMessage(M)}A.onmessage=E=>{if(E.data.centers)centers=E.data.centers,sceneIndexes=E.data.sceneIndexes,n?new Int32Array(s,m+E.data.range.from*w.BytesPerInt*4,E.data.range.count*4).set(new Int32Array(centers)):new Float32Array(s,m+E.data.range.from*w.BytesPerFloat*4,E.data.range.count*4).set(new Float32Array(centers)),o&&new Uint32Array(s,l+E.data.range.from*4,E.data.range.count).set(new Uint32Array(sceneIndexes)),T=E.data.range.from+E.data.range.count;else if(E.data.sort){const y=Math.min(E.data.sort.splatRenderCount||0,T),v=Math.min(E.data.sort.splatSortCount||0,T),D=E.data.sort.usePrecomputedDistances;let b,F,R;t||(b=E.data.sort.indexesToSort,R=E.data.sort.transforms,D&&(F=E.data.sort.precomputedDistances)),x(v,y,E.data.sort.modelViewProj,D,b,F,R)}else if(E.data.init){w=E.data.init.Constants,i=E.data.init.splatCount,t=E.data.init.useSharedMemory,n=E.data.init.integerBasedSort,o=E.data.init.dynamicMode,S=E.data.init.distanceMapRange,T=0;const y=n?w.BytesPerInt*4:w.BytesPerFloat*4,v=new Uint8Array(E.data.init.sorterWasmBytes),D=16*w.BytesPerFloat,b=i*w.BytesPerInt,F=i*y,R=D,k=n?i*w.BytesPerInt:i*w.BytesPerFloat,M=i*w.BytesPerInt,O=i*w.BytesPerInt,L=n?S*w.BytesPerInt*2:S*w.BytesPerFloat*2,U=o?i*w.BytesPerInt:0,_=o?w.MaxScenes*D:0,H=w.MemoryPageSize*32,Q=b+F+R+k+M+L+O+U+_+H,Z=Math.floor(Q/w.MemoryPageSize)+1,ie={module:{},env:{memory:new WebAssembly.Memory({initial:Z,maximum:Z,shared:!0})}};WebAssembly.compile(v).then(V=>WebAssembly.instantiate(V,ie)).then(V=>{e=V,r=0,m=r+b,p=m+F,d=p+R,u=d+k,h=u+M,a=h+L,l=a+O,c=l+U,s=ie.env.memory.buffer,t?A.postMessage({sortSetupPhase1Complete:!0,indexesToSortBuffer:s,indexesToSortOffset:r,sortedIndexesBuffer:s,sortedIndexesOffset:a,precomputedDistancesBuffer:s,precomputedDistancesOffset:d,transformsBuffer:s,transformsOffset:c}):A.postMessage({sortSetupPhase1Complete:!0})})}}}function Oo(A,e,s,t,n,o=j.DefaultSplatSortDistanceMapPrecision){const i=new Worker(URL.createObjectURL(new Blob(["(",Po.toString(),")(self)"],{type:"application/javascript"})));let r=bo;const a=Lt()?Us():null;!s&&!e?(r=Ms,a&&a.major<=16&&a.minor<4&&(r=Ro)):s?e||a&&a.major<=16&&a.minor<4&&(r=Mo):r=Ms;const l=atob(r),c=new Uint8Array(l.length);for(let d=0;d<l.length;d++)c[d]=l.charCodeAt(d);return i.postMessage({init:{sorterWasmBytes:c.buffer,splatCount:A,useSharedMemory:e,integerBasedSort:t,dynamicMode:n,distanceMapRange:1<<o,Constants:{BytesPerFloat:j.BytesPerFloat,BytesPerInt:j.BytesPerInt,MemoryPageSize:j.MemoryPageSize,MaxScenes:j.MaxScenes}}}),i}const qe={None:0,VR:1,AR:2};class Je{static createButton(e,s={}){const t=document.createElement("button");function n(){let l=null;async function c(h){h.addEventListener("end",d),await e.xr.setSession(h),t.textContent="EXIT VR",l=h}function d(){l.removeEventListener("end",d),t.textContent="ENTER VR",l=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="ENTER VR";const u={...s,optionalFeatures:["local-floor","bounded-floor","layers",...s.optionalFeatures||[]]};t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){l===null?navigator.xr.requestSession("immersive-vr",u).then(c):(l.end(),navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-vr",u).then(c).catch(h=>{console.warn(h)}))},navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-vr",u).then(c).catch(h=>{console.warn(h)})}function o(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function i(){o(),t.textContent="VR NOT SUPPORTED"}function r(l){o(),console.warn("Exception when trying to call xr.isSessionSupported",l),t.textContent="VR NOT ALLOWED"}function a(l){l.style.position="absolute",l.style.bottom="20px",l.style.padding="12px 6px",l.style.border="1px solid #fff",l.style.borderRadius="4px",l.style.background="rgba(0,0,0,0.1)",l.style.color="#fff",l.style.font="normal 13px sans-serif",l.style.textAlign="center",l.style.opacity="0.5",l.style.outline="none",l.style.zIndex="999"}if("xr"in navigator)return t.id="VRButton",t.style.display="none",a(t),navigator.xr.isSessionSupported("immersive-vr").then(function(l){l?n():i(),l&&Je.xrSessionIsGranted&&t.click()}).catch(r),t;{const l=document.createElement("a");return window.isSecureContext===!1?(l.href=document.location.href.replace(/^http:/,"https:"),l.innerHTML="WEBXR NEEDS HTTPS"):(l.href="https://immersiveweb.dev/",l.innerHTML="WEBXR NOT AVAILABLE"),l.style.left="calc(50% - 90px)",l.style.width="180px",l.style.textDecoration="none",a(l),l}}static registerSessionGrantedListener(){if(typeof navigator<"u"&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",()=>{Je.xrSessionIsGranted=!0})}}}Je.xrSessionIsGranted=!1;Je.registerSessionGrantedListener();class ko{static createButton(e,s={}){const t=document.createElement("button");function n(){if(s.domOverlay===void 0){const u=document.createElement("div");u.style.display="none",document.body.appendChild(u);const h=document.createElementNS("http://www.w3.org/2000/svg","svg");h.setAttribute("width",38),h.setAttribute("height",38),h.style.position="absolute",h.style.right="20px",h.style.top="20px",h.addEventListener("click",function(){l.end()}),u.appendChild(h);const m=document.createElementNS("http://www.w3.org/2000/svg","path");m.setAttribute("d","M 12,12 L 28,28 M 28,12 12,28"),m.setAttribute("stroke","#fff"),m.setAttribute("stroke-width",2),h.appendChild(m),s.optionalFeatures===void 0&&(s.optionalFeatures=[]),s.optionalFeatures.push("dom-overlay"),s.domOverlay={root:u}}let l=null;async function c(u){u.addEventListener("end",d),e.xr.setReferenceSpaceType("local"),await e.xr.setSession(u),t.textContent="STOP AR",s.domOverlay.root.style.display="",l=u}function d(){l.removeEventListener("end",d),t.textContent="START AR",s.domOverlay.root.style.display="none",l=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="START AR",t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){l===null?navigator.xr.requestSession("immersive-ar",s).then(c):(l.end(),navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-ar",s).then(c).catch(u=>{console.warn(u)}))},navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-ar",s).then(c).catch(u=>{console.warn(u)})}function o(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function i(){o(),t.textContent="AR NOT SUPPORTED"}function r(l){o(),console.warn("Exception when trying to call xr.isSessionSupported",l),t.textContent="AR NOT ALLOWED"}function a(l){l.style.position="absolute",l.style.bottom="20px",l.style.padding="12px 6px",l.style.border="1px solid #fff",l.style.borderRadius="4px",l.style.background="rgba(0,0,0,0.1)",l.style.color="#fff",l.style.font="normal 13px sans-serif",l.style.textAlign="center",l.style.opacity="0.5",l.style.outline="none",l.style.zIndex="999"}if("xr"in navigator)return t.id="ARButton",t.style.display="none",a(t),navigator.xr.isSessionSupported("immersive-ar").then(function(l){l?n():i()}).catch(r),t;{const l=document.createElement("a");return window.isSecureContext===!1?(l.href=document.location.href.replace(/^http:/,"https:"),l.innerHTML="WEBXR NEEDS HTTPS"):(l.href="https://immersiveweb.dev/",l.innerHTML="WEBXR NOT AVAILABLE"),l.style.left="calc(50% - 90px)",l.style.width="180px",l.style.textDecoration="none",a(l),l}}}const Rt={Always:0,Never:2},Lo=50,Ho=.75,Uo=15e5,zo=10,_o=2.5,Qo=60;class Ke{constructor(e={}){if(e.cameraUp||(e.cameraUp=[0,1,0]),this.cameraUp=new f.Vector3().fromArray(e.cameraUp),e.initialCameraPosition||(e.initialCameraPosition=[0,10,15]),this.initialCameraPosition=new f.Vector3().fromArray(e.initialCameraPosition),e.initialCameraLookAt||(e.initialCameraLookAt=[0,0,0]),this.initialCameraLookAt=new f.Vector3().fromArray(e.initialCameraLookAt),this.dropInMode=e.dropInMode||!1,(e.selfDrivenMode===void 0||e.selfDrivenMode===null)&&(e.selfDrivenMode=!0),this.selfDrivenMode=e.selfDrivenMode&&!this.dropInMode,this.selfDrivenUpdateFunc=this.selfDrivenUpdate.bind(this),e.useBuiltInControls===void 0&&(e.useBuiltInControls=!0),this.useBuiltInControls=e.useBuiltInControls,this.rootElement=e.rootElement,this.ignoreDevicePixelRatio=e.ignoreDevicePixelRatio||!1,this.devicePixelRatio=this.ignoreDevicePixelRatio?1:window.devicePixelRatio||1,this.halfPrecisionCovariancesOnGPU=e.halfPrecisionCovariancesOnGPU||!1,this.threeScene=e.threeScene,this.renderer=e.renderer,this.camera=e.camera,this.gpuAcceleratedSort=e.gpuAcceleratedSort||!1,(e.integerBasedSort===void 0||e.integerBasedSort===null)&&(e.integerBasedSort=!0),this.integerBasedSort=e.integerBasedSort,(e.sharedMemoryForWorkers===void 0||e.sharedMemoryForWorkers===null)&&(e.sharedMemoryForWorkers=!0),this.sharedMemoryForWorkers=e.sharedMemoryForWorkers,this.dynamicScene=!!e.dynamicScene,this.antialiased=e.antialiased||!1,this.kernel2DSize=e.kernel2DSize===void 0?.3:e.kernel2DSize,this.webXRMode=e.webXRMode||qe.None,this.webXRMode!==qe.None&&(this.gpuAcceleratedSort=!1),this.webXRActive=!1,this.webXRSessionInit=e.webXRSessionInit||{},this.renderMode=e.renderMode||Rt.Always,this.sceneRevealMode=e.sceneRevealMode||ot.Default,this.focalAdjustment=e.focalAdjustment||1,this.maxScreenSpaceSplatSize=e.maxScreenSpaceSplatSize||1024,this.logLevel=e.logLevel||Xe.None,this.sphericalHarmonicsDegree=e.sphericalHarmonicsDegree||0,this.enableOptionalEffects=e.enableOptionalEffects||!1,(e.enableSIMDInSort===void 0||e.enableSIMDInSort===null)&&(e.enableSIMDInSort=!0),this.enableSIMDInSort=e.enableSIMDInSort,(e.inMemoryCompressionLevel===void 0||e.inMemoryCompressionLevel===null)&&(e.inMemoryCompressionLevel=0),this.inMemoryCompressionLevel=e.inMemoryCompressionLevel,(e.optimizeSplatData===void 0||e.optimizeSplatData===null)&&(e.optimizeSplatData=!0),this.optimizeSplatData=e.optimizeSplatData,(e.freeIntermediateSplatData===void 0||e.freeIntermediateSplatData===null)&&(e.freeIntermediateSplatData=!1),this.freeIntermediateSplatData=e.freeIntermediateSplatData,Lt()){const t=Us();t.major<17&&(this.enableSIMDInSort=!1),t.major<16&&(this.sharedMemoryForWorkers=!1)}(e.splatRenderMode===void 0||e.splatRenderMode===null)&&(e.splatRenderMode=Pe.ThreeD),this.splatRenderMode=e.splatRenderMode,this.sceneFadeInRateMultiplier=e.sceneFadeInRateMultiplier||1,this.splatSortDistanceMapPrecision=e.splatSortDistanceMapPrecision||j.DefaultSplatSortDistanceMapPrecision;const s=this.integerBasedSort?20:24;this.splatSortDistanceMapPrecision=ne(this.splatSortDistanceMapPrecision,10,s),this.onSplatMeshChangedCallback=null,this.createSplatMesh(),this.controls=null,this.perspectiveControls=null,this.orthographicControls=null,this.orthographicCamera=null,this.perspectiveCamera=null,this.showMeshCursor=!1,this.showControlPlane=!1,this.showInfo=!1,this.sceneHelper=null,this.sortWorker=null,this.sortRunning=!1,this.splatRenderCount=0,this.splatSortCount=0,this.lastSplatSortCount=0,this.sortWorkerIndexesToSort=null,this.sortWorkerSortedIndexes=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.preSortMessages=[],this.runAfterNextSort=[],this.selfDrivenModeRunning=!1,this.splatRenderReady=!1,this.raycaster=new po,this.infoPanel=null,this.startInOrthographicMode=!1,this.currentFPS=0,this.lastSortTime=0,this.consecutiveRenderFrames=0,this.previousCameraTarget=new f.Vector3,this.nextCameraTarget=new f.Vector3,this.mousePosition=new f.Vector2,this.mouseDownPosition=new f.Vector2,this.mouseDownTime=null,this.resizeObserver=null,this.mouseMoveListener=null,this.mouseDownListener=null,this.mouseUpListener=null,this.keyDownListener=null,this.sortPromise=null,this.sortPromiseResolver=null,this.splatSceneDownloadPromises={},this.splatSceneDownloadAndBuildPromise=null,this.splatSceneRemovalPromise=null,this.loadingSpinner=new Yt(null,this.rootElement||document.body),this.loadingSpinner.hide(),this.loadingProgressBar=new io(this.rootElement||document.body),this.loadingProgressBar.hide(),this.infoPanel=new ao(this.rootElement||document.body),this.infoPanel.hide(),this.usingExternalCamera=!!(this.dropInMode||this.camera),this.usingExternalRenderer=!!(this.dropInMode||this.renderer),this.initialized=!1,this.disposing=!1,this.disposed=!1,this.disposePromise=null,this.dropInMode||this.init()}createSplatMesh(){this.splatMesh=new ge(this.splatRenderMode,this.dynamicScene,this.enableOptionalEffects,this.halfPrecisionCovariancesOnGPU,this.devicePixelRatio,this.gpuAcceleratedSort,this.integerBasedSort,this.antialiased,this.maxScreenSpaceSplatSize,this.logLevel,this.sphericalHarmonicsDegree,this.sceneFadeInRateMultiplier,this.kernel2DSize),this.splatMesh.frustumCulled=!1,this.onSplatMeshChangedCallback&&this.onSplatMeshChangedCallback()}init(){this.initialized||(this.rootElement||(this.usingExternalRenderer?this.rootElement=this.renderer.domElement||document.body:(this.rootElement=document.createElement("div"),this.rootElement.style.width="100%",this.rootElement.style.height="100%",this.rootElement.style.position="absolute",document.body.appendChild(this.rootElement))),this.setupCamera(),this.setupRenderer(),this.setupWebXR(this.webXRSessionInit),this.setupControls(),this.setupEventHandlers(),this.threeScene=this.threeScene||new f.Scene,this.sceneHelper=new st(this.threeScene),this.sceneHelper.setupMeshCursor(),this.sceneHelper.setupFocusMarker(),this.sceneHelper.setupControlPlane(),this.loadingProgressBar.setContainer(this.rootElement),this.loadingSpinner.setContainer(this.rootElement),this.infoPanel.setContainer(this.rootElement),this.initialized=!0)}setupCamera(){if(!this.usingExternalCamera){const e=new f.Vector2;this.getRenderDimensions(e),this.perspectiveCamera=new f.PerspectiveCamera(Lo,e.x/e.y,.1,1e3),this.orthographicCamera=new f.OrthographicCamera(e.x/-2,e.x/2,e.y/2,e.y/-2,.1,1e3),this.camera=this.startInOrthographicMode?this.orthographicCamera:this.perspectiveCamera,this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt)}}setupRenderer(){if(!this.usingExternalRenderer){const e=new f.Vector2;this.getRenderDimensions(e),this.renderer=new f.WebGLRenderer({antialias:!1,precision:"highp"}),this.renderer.setPixelRatio(this.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(new f.Color(0),0),this.renderer.setSize(e.x,e.y),this.resizeObserver=new ResizeObserver(()=>{this.getRenderDimensions(e),this.renderer.setSize(e.x,e.y),this.forceRenderNextFrame()}),this.resizeObserver.observe(this.rootElement),this.rootElement.appendChild(this.renderer.domElement)}}setupWebXR(e){this.webXRMode&&(this.webXRMode===qe.VR?this.rootElement.appendChild(Je.createButton(this.renderer,e)):this.webXRMode===qe.AR&&this.rootElement.appendChild(ko.createButton(this.renderer,e)),this.renderer.xr.addEventListener("sessionstart",s=>{this.webXRActive=!0}),this.renderer.xr.addEventListener("sessionend",s=>{this.webXRActive=!1}),this.renderer.xr.enabled=!0,this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt))}setupControls(){if(this.useBuiltInControls&&this.webXRMode===qe.None){this.usingExternalCamera?this.camera.isOrthographicCamera?this.orthographicControls=new pt(this.camera,this.renderer.domElement):this.perspectiveControls=new pt(this.camera,this.renderer.domElement):(this.perspectiveControls=new pt(this.perspectiveCamera,this.renderer.domElement),this.orthographicControls=new pt(this.orthographicCamera,this.renderer.domElement));for(let e of[this.orthographicControls,this.perspectiveControls])e&&(e.listenToKeyEvents(window),e.rotateSpeed=.5,e.maxPolarAngle=Math.PI*.75,e.minPolarAngle=.1,e.enableDamping=!0,e.dampingFactor=.05,e.target.copy(this.initialCameraLookAt),e.update());this.controls=this.camera.isOrthographicCamera?this.orthographicControls:this.perspectiveControls,this.controls.update()}}setupEventHandlers(){this.useBuiltInControls&&this.webXRMode===qe.None&&(this.mouseMoveListener=this.onMouseMove.bind(this),this.renderer.domElement.addEventListener("pointermove",this.mouseMoveListener,!1),this.mouseDownListener=this.onMouseDown.bind(this),this.renderer.domElement.addEventListener("pointerdown",this.mouseDownListener,!1),this.mouseUpListener=this.onMouseUp.bind(this),this.renderer.domElement.addEventListener("pointerup",this.mouseUpListener,!1),this.keyDownListener=this.onKeyDown.bind(this),window.addEventListener("keydown",this.keyDownListener,!1))}removeEventHandlers(){this.useBuiltInControls&&(this.renderer.domElement.removeEventListener("pointermove",this.mouseMoveListener),this.mouseMoveListener=null,this.renderer.domElement.removeEventListener("pointerdown",this.mouseDownListener),this.mouseDownListener=null,this.renderer.domElement.removeEventListener("pointerup",this.mouseUpListener),this.mouseUpListener=null,window.removeEventListener("keydown",this.keyDownListener),this.keyDownListener=null)}setRenderMode(e){this.renderMode=e}setActiveSphericalHarmonicsDegrees(e){this.splatMesh.material.uniforms.sphericalHarmonicsDegree.value=e,this.splatMesh.material.uniformsNeedUpdate=!0}onSplatMeshChanged(e){this.onSplatMeshChangedCallback=e}onKeyDown=function(){const e=new f.Vector3,s=new f.Matrix4,t=new f.Matrix4;return function(n){switch(e.set(0,0,-1),e.transformDirection(this.camera.matrixWorld),s.makeRotationAxis(e,Math.PI/128),t.makeRotationAxis(e,-Math.PI/128),n.code){case"KeyG":this.focalAdjustment+=.02,this.forceRenderNextFrame();break;case"KeyF":this.focalAdjustment-=.02,this.forceRenderNextFrame();break;case"ArrowLeft":this.camera.up.transformDirection(s);break;case"ArrowRight":this.camera.up.transformDirection(t);break;case"KeyC":this.showMeshCursor=!this.showMeshCursor;break;case"KeyU":this.showControlPlane=!this.showControlPlane;break;case"KeyI":this.showInfo=!this.showInfo,this.showInfo?this.infoPanel.show():this.infoPanel.hide();break;case"KeyO":this.usingExternalCamera||this.setOrthographicMode(!this.camera.isOrthographicCamera);break;case"KeyP":this.usingExternalCamera||this.splatMesh.setPointCloudModeEnabled(!this.splatMesh.getPointCloudModeEnabled());break;case"Equal":this.usingExternalCamera||this.splatMesh.setSplatScale(this.splatMesh.getSplatScale()+.05);break;case"Minus":this.usingExternalCamera||this.splatMesh.setSplatScale(Math.max(this.splatMesh.getSplatScale()-.05,0));break}}}();onMouseMove(e){this.mousePosition.set(e.offsetX,e.offsetY)}onMouseDown(){this.mouseDownPosition.copy(this.mousePosition),this.mouseDownTime=Ne()}onMouseUp=function(){const e=new f.Vector2;return function(s){e.copy(this.mousePosition).sub(this.mouseDownPosition),Ne()-this.mouseDownTime<.5&&e.length()<2&&this.onMouseClick(s)}}();onMouseClick(e){this.mousePosition.set(e.offsetX,e.offsetY),this.checkForFocalPointChange()}checkForFocalPointChange=function(){const e=new f.Vector2,s=new f.Vector3,t=[];return function(){if(!this.transitioningCameraTarget&&(this.getRenderDimensions(e),t.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,e),this.raycaster.intersectSplatMesh(this.splatMesh,t),t.length>0)){const o=t[0].origin;s.copy(o).sub(this.camera.position),s.length()>Ho&&(this.previousCameraTarget.copy(this.controls.target),this.nextCameraTarget.copy(o),this.transitioningCameraTarget=!0,this.transitioningCameraTargetStartTime=Ne())}}}();getRenderDimensions(e){this.rootElement?(e.x=this.rootElement.offsetWidth,e.y=this.rootElement.offsetHeight):this.renderer.getSize(e)}setOrthographicMode(e){if(e===this.camera.isOrthographicCamera)return;const s=this.camera,t=e?this.orthographicCamera:this.perspectiveCamera;if(t.position.copy(s.position),t.up.copy(s.up),t.rotation.copy(s.rotation),t.quaternion.copy(s.quaternion),t.matrix.copy(s.matrix),this.camera=t,this.controls){const n=r=>{r.saveState(),r.reset()},o=this.controls,i=e?this.orthographicControls:this.perspectiveControls;n(i),n(o),i.target.copy(o.target),e?Ke.setCameraZoomFromPosition(t,s,o):Ke.setCameraPositionFromZoom(t,s,i),this.controls=i,this.camera.lookAt(this.controls.target)}}static setCameraPositionFromZoom=function(){const e=new f.Vector3;return function(s,t,n){const o=1/(t.zoom*.001);e.copy(n.target).sub(s.position).normalize().multiplyScalar(o).negate(),s.position.copy(n.target).add(e)}}();static setCameraZoomFromPosition=function(){const e=new f.Vector3;return function(s,t,n){const o=e.copy(n.target).sub(t.position).length();s.zoom=1/(o*.001)}}();updateSplatMesh=function(){const e=new f.Vector2;return function(){if(!this.splatMesh)return;if(this.splatMesh.getSplatCount()>0){this.splatMesh.updateVisibleRegionFadeDistance(this.sceneRevealMode),this.splatMesh.updateTransforms(),this.getRenderDimensions(e);const t=this.camera.projectionMatrix.elements[0]*.5*this.devicePixelRatio*e.x,n=this.camera.projectionMatrix.elements[5]*.5*this.devicePixelRatio*e.y,o=this.camera.isOrthographicCamera?1/this.devicePixelRatio:1,i=this.focalAdjustment*o,r=1/i;this.adjustForWebXRStereo(e),this.splatMesh.updateUniforms(e,t*i,n*i,this.camera.isOrthographicCamera,this.camera.zoom||1,r)}}}();adjustForWebXRStereo(e){if(this.camera&&this.webXRActive){const t=this.renderer.xr.getCamera().projectionMatrix.elements[0],n=this.camera.projectionMatrix.elements[0];e.x*=n/t}}isLoadingOrUnloading(){return Object.keys(this.splatSceneDownloadPromises).length>0||this.splatSceneDownloadAndBuildPromise!==null||this.splatSceneRemovalPromise!==null}isDisposingOrDisposed(){return this.disposing||this.disposed}addSplatSceneDownloadPromise(e){this.splatSceneDownloadPromises[e.id]=e}removeSplatSceneDownloadPromise(e){delete this.splatSceneDownloadPromises[e.id]}setSplatSceneDownloadAndBuildPromise(e){this.splatSceneDownloadAndBuildPromise=e}clearSplatSceneDownloadAndBuildPromise(){this.splatSceneDownloadAndBuildPromise=null}addSplatScene(e,s={}){if(this.isLoadingOrUnloading())throw new Error("Cannot add splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");s.progressiveLoad&&this.splatMesh.scenes&&this.splatMesh.scenes.length>0&&(console.log('addSplatScene(): "progressiveLoad" option ignore because there are multiple splat scenes'),s.progressiveLoad=!1);const t=s.format!==void 0&&s.format!==null?s.format:Ts(e),n=Ke.isProgressivelyLoadable(t)&&s.progressiveLoad,o=s.showLoadingUI!==void 0&&s.showLoadingUI!==null?s.showLoadingUI:!0;let i=null;o&&(this.loadingSpinner.removeAllTasks(),i=this.loadingSpinner.addTask("Downloading..."));const r=()=>{this.loadingProgressBar.hide(),this.loadingSpinner.removeAllTasks()},a=(p,g,C)=>{if(o)if(C===de.Downloading)if(p==100)this.loadingSpinner.setMessageForTask(i,"Download complete!");else if(n)this.loadingSpinner.setMessageForTask(i,"Downloading splats...");else{const S=g?`: ${g}`:"...";this.loadingSpinner.setMessageForTask(i,`Downloading${S}`)}else C===de.Processing&&this.loadingSpinner.setMessageForTask(i,"Processing splats...")};let l=!1,c=0;const d=(p,g)=>{o&&((p&&n||g&&!n)&&(this.loadingSpinner.removeTask(i),!g&&!l&&this.loadingProgressBar.show()),n&&(g?(l=!0,this.loadingProgressBar.hide()):this.loadingProgressBar.setProgress(c)))},u=(p,g,C)=>{c=p,a(p,g,C),s.onProgress&&s.onProgress(p,g,C)},h=(p,g,C)=>{!n&&s.onProgress&&s.onProgress(0,"0%",de.Processing);const S={rotation:s.rotation||s.orientation,position:s.position,scale:s.scale,splatAlphaRemovalThreshold:s.splatAlphaRemovalThreshold};return this.addSplatBuffers([p],[S],C,g&&o,o,n,n).then(()=>{!n&&s.onProgress&&s.onProgress(100,"100%",de.Processing),d(g,C)})};return(n?this.downloadAndBuildSingleSplatSceneProgressiveLoad.bind(this):this.downloadAndBuildSingleSplatSceneStandardLoad.bind(this))(e,t,s.splatAlphaRemovalThreshold,h.bind(this),u,r.bind(this),s.headers)}downloadAndBuildSingleSplatSceneStandardLoad(e,s,t,n,o,i,r){const a=this.downloadSplatSceneToSplatBuffer(e,t,o,!1,void 0,s,r),l=Bt(a.abortHandler);return a.then(c=>(this.removeSplatSceneDownloadPromise(a),n(c,!0,!0).then(()=>{l.resolve(),this.clearSplatSceneDownloadAndBuildPromise()}))).catch(c=>{i&&i(),this.clearSplatSceneDownloadAndBuildPromise(),this.removeSplatSceneDownloadPromise(a),l.reject(this.updateError(c,`Viewer::addSplatScene -> Could not load file ${e}`))}),this.addSplatSceneDownloadPromise(a),this.setSplatSceneDownloadAndBuildPromise(l.promise),l.promise}downloadAndBuildSingleSplatSceneProgressiveLoad(e,s,t,n,o,i,r){let a=0,l=!1;const c=[],d=()=>{if(c.length>0&&!l&&!this.isDisposingOrDisposed()){l=!0;const g=c.shift();n(g.splatBuffer,g.firstBuild,g.finalBuild).then(()=>{l=!1,g.firstBuild?m.resolve():g.finalBuild&&(p.resolve(),this.clearSplatSceneDownloadAndBuildPromise()),c.length>0&&we(()=>d())})}},u=(g,C)=>{this.isDisposingOrDisposed()||(C||c.length===0||g.getSplatCount()>c[0].splatBuffer.getSplatCount())&&(c.push({splatBuffer:g,firstBuild:a===0,finalBuild:C}),a++,d())},h=this.downloadSplatSceneToSplatBuffer(e,t,o,!0,u,s,r),m=Bt(h.abortHandler),p=Bt();return this.addSplatSceneDownloadPromise(h),this.setSplatSceneDownloadAndBuildPromise(p.promise),h.then(()=>{this.removeSplatSceneDownloadPromise(h)}).catch(g=>{this.clearSplatSceneDownloadAndBuildPromise(),this.removeSplatSceneDownloadPromise(h);const C=this.updateError(g,"Viewer::addSplatScene -> Could not load one or more scenes");m.reject(C),i&&i(C)}),m.promise}addSplatScenes(e,s=!0,t=void 0){if(this.isLoadingOrUnloading())throw new Error("Cannot add splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");const n=e.length,o=[];let i;s&&(this.loadingSpinner.removeAllTasks(),i=this.loadingSpinner.addTask("Downloading..."));const r=(d,u,h,m)=>{o[d]=u;let p=0;for(let g=0;g<n;g++)p+=o[g]||0;p=p/n,h=`${p.toFixed(2)}%`,s&&m===de.Downloading&&this.loadingSpinner.setMessageForTask(i,p==100?"Download complete!":`Downloading: ${h}`),t&&t(p,h,m)},a=[],l=[];for(let d=0;d<e.length;d++){const u=e[d],h=u.format!==void 0&&u.format!==null?u.format:Ts(u.path),m=this.downloadSplatSceneToSplatBuffer(u.path,u.splatAlphaRemovalThreshold,r.bind(this,d),!1,void 0,h,u.headers);a.push(m),l.push(m.promise)}const c=new Ue((d,u)=>{Promise.all(l).then(h=>{s&&this.loadingSpinner.removeTask(i),t&&t(0,"0%",de.Processing),this.addSplatBuffers(h,e,!0,s,s,!1,!1).then(()=>{t&&t(100,"100%",de.Processing),this.clearSplatSceneDownloadAndBuildPromise(),d()})}).catch(h=>{s&&this.loadingSpinner.removeTask(i),this.clearSplatSceneDownloadAndBuildPromise(),u(this.updateError(h,"Viewer::addSplatScenes -> Could not load one or more splat scenes."))}).finally(()=>{this.removeSplatSceneDownloadPromise(c)})},d=>{for(let u of a)u.abort(d)});return this.addSplatSceneDownloadPromise(c),this.setSplatSceneDownloadAndBuildPromise(c),c}downloadSplatSceneToSplatBuffer(e,s=1,t=void 0,n=!1,o=void 0,i,r){try{if(i===ye.Splat||i===ye.KSplat||i===ye.Ply){const a=n?!1:this.optimizeSplatData;if(i===ye.Splat)return jt.loadFromURL(e,t,n,o,s,this.inMemoryCompressionLevel,a,r);if(i===ye.KSplat)return tt.loadFromURL(e,t,n,o,r);if(i===ye.Ply)return Wt.loadFromURL(e,t,n,o,s,this.inMemoryCompressionLevel,a,this.sphericalHarmonicsDegree,r)}else if(i===ye.Spz)return Kt.loadFromURL(e,t,s,this.inMemoryCompressionLevel,this.optimizeSplatData,this.sphericalHarmonicsDegree,r)}catch(a){throw this.updateError(a,null)}throw new Error(`Viewer::downloadSplatSceneToSplatBuffer -> File format not supported: ${e}`)}static isProgressivelyLoadable(e){return e===ye.Splat||e===ye.KSplat||e===ye.Ply}addSplatBuffers=function(){return function(e,s=[],t=!0,n=!0,o=!0,i=!1,r=!1,a=!0){if(this.isDisposingOrDisposed())return Promise.resolve();let l=null;const c=()=>{l!==null&&(this.loadingSpinner.removeTask(l),l=null)};return this.splatRenderReady=!1,new Promise(d=>{n&&(l=this.loadingSpinner.addTask("Processing splats...")),we(()=>{if(this.isDisposingOrDisposed())d();else{const u=this.addSplatBuffersToMesh(e,s,t,o,i,a),h=this.splatMesh.getMaxSplatCount();this.sortWorker&&this.sortWorker.maxSplatCount!==h&&this.disposeSortWorker(),this.gpuAcceleratedSort||this.preSortMessages.push({centers:u.centers.buffer,sceneIndexes:u.sceneIndexes.buffer,range:{from:u.from,to:u.to,count:u.count}}),(!this.sortWorker&&h>0?this.setupSortWorker(this.splatMesh):Promise.resolve()).then(()=>{this.isDisposingOrDisposed()||this.runSplatSort(!0,!0).then(p=>{!this.sortWorker||!p?(this.splatRenderReady=!0,c(),d()):(r?this.splatRenderReady=!0:this.runAfterNextSort.push(()=>{this.splatRenderReady=!0}),this.runAfterNextSort.push(()=>{c(),d()}))})})}},!0)})}}();addSplatBuffersToMesh=function(){let e;return function(s,t,n=!0,o=!1,i=!1,r=!0){if(this.isDisposingOrDisposed())return;let a=[],l=[];i||(a=this.splatMesh.scenes.map(h=>h.splatBuffer)||[],l=this.splatMesh.sceneOptions?this.splatMesh.sceneOptions.map(h=>h):[]),a.push(...s),l.push(...t),this.renderer&&this.splatMesh.setRenderer(this.renderer);const c=h=>{if(this.isDisposingOrDisposed())return;const m=this.splatMesh.getSplatCount();o&&m>=Uo&&!h&&!e&&(this.loadingSpinner.setMinimized(!0,!0),e=this.loadingSpinner.addTask("Optimizing data structures..."))},d=h=>{this.isDisposingOrDisposed()||h&&e&&(this.loadingSpinner.removeTask(e),e=null)},u=this.splatMesh.build(a,l,!0,n,c,d,r);return n&&this.freeIntermediateSplatData&&this.splatMesh.freeIntermediateSplatData(),u}}();setupSortWorker(e){if(!this.isDisposingOrDisposed())return new Promise(s=>{const t=this.integerBasedSort?Int32Array:Float32Array,n=e.getSplatCount(),o=e.getMaxSplatCount();this.sortWorker=Oo(o,this.sharedMemoryForWorkers,this.enableSIMDInSort,this.integerBasedSort,this.splatMesh.dynamicMode,this.splatSortDistanceMapPrecision),this.sortWorker.onmessage=i=>{if(i.data.sortDone){if(this.sortRunning=!1,this.sharedMemoryForWorkers)this.splatMesh.updateRenderIndexes(this.sortWorkerSortedIndexes,i.data.splatRenderCount);else{const r=new Uint32Array(i.data.sortedIndexes.buffer,0,i.data.splatRenderCount);this.splatMesh.updateRenderIndexes(r,i.data.splatRenderCount)}this.lastSplatSortCount=this.splatSortCount,this.lastSortTime=i.data.sortTime,this.sortPromiseResolver(),this.sortPromiseResolver=null,this.forceRenderNextFrame(),this.runAfterNextSort.length>0&&(this.runAfterNextSort.forEach(r=>{r()}),this.runAfterNextSort.length=0)}else if(i.data.sortCanceled)this.sortRunning=!1;else if(i.data.sortSetupPhase1Complete){this.logLevel>=Xe.Info&&console.log("Sorting web worker WASM setup complete."),this.sharedMemoryForWorkers?(this.sortWorkerSortedIndexes=new Uint32Array(i.data.sortedIndexesBuffer,i.data.sortedIndexesOffset,o),this.sortWorkerIndexesToSort=new Uint32Array(i.data.indexesToSortBuffer,i.data.indexesToSortOffset,o),this.sortWorkerPrecomputedDistances=new t(i.data.precomputedDistancesBuffer,i.data.precomputedDistancesOffset,o),this.sortWorkerTransforms=new Float32Array(i.data.transformsBuffer,i.data.transformsOffset,j.MaxScenes*16)):(this.sortWorkerIndexesToSort=new Uint32Array(o),this.sortWorkerPrecomputedDistances=new t(o),this.sortWorkerTransforms=new Float32Array(j.MaxScenes*16));for(let r=0;r<n;r++)this.sortWorkerIndexesToSort[r]=r;if(this.sortWorker.maxSplatCount=o,this.logLevel>=Xe.Info){console.log("Sorting web worker ready.");const r=this.splatMesh.getSplatDataTextures(),a=r.covariances.size,l=r.centerColors.size;console.log("Covariances texture size: "+a.x+" x "+a.y),console.log("Centers/colors texture size: "+l.x+" x "+l.y)}s()}}})}updateError(e,s){return e instanceof Hs?e:e instanceof At?new Error("File type or server does not support progressive loading."):s?new Error(s):e}disposeSortWorker(){this.sortWorker&&this.sortWorker.terminate(),this.sortWorker=null,this.sortPromise=null,this.sortPromiseResolver&&(this.sortPromiseResolver(),this.sortPromiseResolver=null),this.preSortMessages=[],this.sortRunning=!1}removeSplatScene(e,s=!0){return this.removeSplatScenes([e],s)}removeSplatScenes(e,s=!0){if(this.isLoadingOrUnloading())throw new Error("Cannot remove splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot remove splat scene after dispose() is called.");let t;return this.splatSceneRemovalPromise=new Promise((n,o)=>{let i;s&&(this.loadingSpinner.removeAllTasks(),this.loadingSpinner.show(),i=this.loadingSpinner.addTask("Removing splat scene..."));const r=()=>{s&&(this.loadingSpinner.hide(),this.loadingSpinner.removeTask(i))},a=c=>{r(),this.splatSceneRemovalPromise=null,c?o(c):n()},l=()=>this.isDisposingOrDisposed()?(a(),!0):!1;t=this.sortPromise||Promise.resolve(),t.then(()=>{if(l())return;const c=[],d=[],u=[];for(let h=0;h<this.splatMesh.scenes.length;h++){let m=!1;for(let p of e)if(p===h){m=!0;break}if(!m){const p=this.splatMesh.scenes[h];c.push(p.splatBuffer),d.push(this.splatMesh.sceneOptions[h]),u.push({position:p.position.clone(),quaternion:p.quaternion.clone(),scale:p.scale.clone()})}}this.disposeSortWorker(),this.splatMesh.dispose(),this.sceneRevealMode=ot.Instant,this.createSplatMesh(),this.addSplatBuffers(c,d,!0,!1,!0).then(()=>{l()||(r(),this.splatMesh.scenes.forEach((h,m)=>{h.position.copy(u[m].position),h.quaternion.copy(u[m].quaternion),h.scale.copy(u[m].scale)}),this.splatMesh.updateTransforms(),this.splatRenderReady=!1,this.runSplatSort(!0).then(()=>{if(l()){this.splatRenderReady=!0;return}t=this.sortPromise||Promise.resolve(),t.then(()=>{this.splatRenderReady=!0,a()})}))}).catch(h=>{a(h)})})}),this.splatSceneRemovalPromise}start(){if(this.selfDrivenMode)this.webXRMode?this.renderer.setAnimationLoop(this.selfDrivenUpdateFunc):this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc),this.selfDrivenModeRunning=!0;else throw new Error("Cannot start viewer unless it is in self driven mode.")}stop(){this.selfDrivenMode&&this.selfDrivenModeRunning&&(this.webXRMode?this.renderer.setAnimationLoop(null):cancelAnimationFrame(this.requestFrameId),this.selfDrivenModeRunning=!1)}async dispose(){if(this.isDisposingOrDisposed())return this.disposePromise;let e=[],s=[];for(let t in this.splatSceneDownloadPromises)if(this.splatSceneDownloadPromises.hasOwnProperty(t)){const n=this.splatSceneDownloadPromises[t];s.push(n),e.push(n.promise)}return this.sortPromise&&e.push(this.sortPromise),this.disposing=!0,this.disposePromise=Promise.all(e).finally(()=>{this.stop(),this.orthographicControls&&(this.orthographicControls.dispose(),this.orthographicControls=null),this.perspectiveControls&&(this.perspectiveControls.dispose(),this.perspectiveControls=null),this.controls=null,this.splatMesh&&(this.splatMesh.dispose(),this.splatMesh=null),this.sceneHelper&&(this.sceneHelper.dispose(),this.sceneHelper=null),this.resizeObserver&&(this.resizeObserver.unobserve(this.rootElement),this.resizeObserver=null),this.disposeSortWorker(),this.removeEventHandlers(),this.loadingSpinner.removeAllTasks(),this.loadingSpinner.setContainer(null),this.loadingProgressBar.hide(),this.loadingProgressBar.setContainer(null),this.infoPanel.setContainer(null),this.camera=null,this.threeScene=null,this.splatRenderReady=!1,this.initialized=!1,this.renderer&&(this.usingExternalRenderer||(this.rootElement.removeChild(this.renderer.domElement),this.renderer.dispose()),this.renderer=null),this.usingExternalRenderer||document.body.removeChild(this.rootElement),this.sortWorkerSortedIndexes=null,this.sortWorkerIndexesToSort=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.disposed=!0,this.disposing=!1,this.disposePromise=null}),s.forEach(t=>{t.abort("Scene disposed")}),this.disposePromise}selfDrivenUpdate(){this.selfDrivenMode&&!this.webXRMode&&(this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc)),this.update(),this.shouldRender()?(this.render(),this.consecutiveRenderFrames++):this.consecutiveRenderFrames=0,this.renderNextFrame=!1}forceRenderNextFrame(){this.renderNextFrame=!0}shouldRender=function(){let e=0;const s=new f.Vector3,t=new f.Quaternion,n=1e-4;return function(){if(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())return!1;let o=!1,i=!1;if(this.camera){const r=this.camera.position,a=this.camera.quaternion;i=Math.abs(r.x-s.x)>n||Math.abs(r.y-s.y)>n||Math.abs(r.z-s.z)>n||Math.abs(a.x-t.x)>n||Math.abs(a.y-t.y)>n||Math.abs(a.z-t.z)>n||Math.abs(a.w-t.w)>n}return o=this.renderMode!==Rt.Never&&(e===0||this.splatMesh.visibleRegionChanging||i||this.renderMode===Rt.Always||this.dynamicMode===!0||this.renderNextFrame),this.camera&&(s.copy(this.camera.position),t.copy(this.camera.quaternion)),e++,o}}();render=function(){return function(){if(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())return;const e=t=>{for(let n of t.children)if(n.visible)return!0;return!1},s=this.renderer.autoClear;e(this.threeScene)&&(this.renderer.render(this.threeScene,this.camera),this.renderer.autoClear=!1),this.renderer.render(this.splatMesh,this.camera),this.renderer.autoClear=!1,this.sceneHelper.getFocusMarkerOpacity()>0&&this.renderer.render(this.sceneHelper.focusMarker,this.camera),this.showControlPlane&&this.renderer.render(this.sceneHelper.controlPlane,this.camera),this.renderer.autoClear=s}}();update(e,s){this.dropInMode&&this.updateForDropInMode(e,s),!(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())&&(this.controls&&(this.controls.update(),this.camera.isOrthographicCamera&&!this.usingExternalCamera&&Ke.setCameraPositionFromZoom(this.camera,this.camera,this.controls)),this.runSplatSort(),this.updateForRendererSizeChanges(),this.updateSplatMesh(),this.updateMeshCursor(),this.updateFPS(),this.timingSensitiveUpdates(),this.updateInfoPanel(),this.updateControlPlane())}updateForDropInMode(e,s){this.renderer=e,this.splatMesh&&this.splatMesh.setRenderer(this.renderer),this.camera=s,this.controls&&(this.controls.object=s),this.init()}updateFPS=function(){let e=Ne(),s=0;return function(){if(this.consecutiveRenderFrames>Qo){const t=Ne();t-e>=1?(this.currentFPS=s,s=0,e=t):s++}else this.currentFPS=null}}();updateForRendererSizeChanges=function(){const e=new f.Vector2,s=new f.Vector2;let t;return function(){this.usingExternalCamera||(this.renderer.getSize(s),(t===void 0||t!==this.camera.isOrthographicCamera||s.x!==e.x||s.y!==e.y)&&(this.camera.isOrthographicCamera?(this.camera.left=-s.x/2,this.camera.right=s.x/2,this.camera.top=s.y/2,this.camera.bottom=-s.y/2):this.camera.aspect=s.x/s.y,this.camera.updateProjectionMatrix(),e.copy(s),t=this.camera.isOrthographicCamera))}}();timingSensitiveUpdates=function(){let e;return function(){const s=Ne();e||(e=s);const t=s-e;this.updateCameraTransition(s),this.updateFocusMarker(t),e=s}}();updateCameraTransition=function(){let e=new f.Vector3,s=new f.Vector3,t=new f.Vector3;return function(n){if(this.transitioningCameraTarget){s.copy(this.previousCameraTarget).sub(this.camera.position).normalize(),t.copy(this.nextCameraTarget).sub(this.camera.position).normalize();const o=Math.acos(s.dot(t)),r=(o/(Math.PI/3)*.65+.3)/o*(n-this.transitioningCameraTargetStartTime);e.copy(this.previousCameraTarget).lerp(this.nextCameraTarget,r),this.camera.lookAt(e),this.controls.target.copy(e),r>=1&&(this.transitioningCameraTarget=!1)}}}();updateFocusMarker=function(){const e=new f.Vector2;let s=!1;return function(t){if(this.getRenderDimensions(e),this.transitioningCameraTarget){this.sceneHelper.setFocusMarkerVisibility(!0);const n=Math.max(this.sceneHelper.getFocusMarkerOpacity(),0);let o=Math.min(n+zo*t,1);this.sceneHelper.setFocusMarkerOpacity(o),this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e),s=!0,this.forceRenderNextFrame()}else{let n;if(s?n=1:n=Math.min(this.sceneHelper.getFocusMarkerOpacity(),1),n>0){this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e);let o=Math.max(n-_o*t,0);this.sceneHelper.setFocusMarkerOpacity(o),o===0&&this.sceneHelper.setFocusMarkerVisibility(!1)}n>0&&this.forceRenderNextFrame(),s=!1}}}();updateMeshCursor=function(){const e=[],s=new f.Vector2;return function(){this.showMeshCursor?(this.forceRenderNextFrame(),this.getRenderDimensions(s),e.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,s),this.raycaster.intersectSplatMesh(this.splatMesh,e),e.length>0?(this.sceneHelper.setMeshCursorVisibility(!0),this.sceneHelper.positionAndOrientMeshCursor(e[0].origin,this.camera)):this.sceneHelper.setMeshCursorVisibility(!1)):(this.sceneHelper.getMeschCursorVisibility()&&this.forceRenderNextFrame(),this.sceneHelper.setMeshCursorVisibility(!1))}}();updateInfoPanel=function(){const e=new f.Vector2;return function(){if(!this.showInfo)return;const s=this.splatMesh.getSplatCount();this.getRenderDimensions(e);const t=this.controls?this.controls.target:null,n=this.showMeshCursor?this.sceneHelper.meshCursor.position:null,o=s>0?this.splatRenderCount/s*100:0;this.infoPanel.update(e,this.camera.position,t,this.camera.up,this.camera.isOrthographicCamera,n,this.currentFPS||"N/A",s,this.splatRenderCount,o,this.lastSortTime,this.focalAdjustment,this.splatMesh.getSplatScale(),this.splatMesh.getPointCloudModeEnabled())}}();updateControlPlane(){this.showControlPlane?(this.sceneHelper.setControlPlaneVisibility(!0),this.sceneHelper.positionAndOrientControlPlane(this.controls.target,this.camera.up)):this.sceneHelper.setControlPlaneVisibility(!1)}runSplatSort=function(){const e=new f.Matrix4,s=[],t=new f.Vector3(0,0,-1),n=new f.Vector3(0,0,-1),o=new f.Vector3,i=new f.Vector3,r=[],a=[{angleThreshold:.55,sortFractions:[.125,.33333,.75]},{angleThreshold:.65,sortFractions:[.33333,.66667]},{angleThreshold:.8,sortFractions:[.5]}];return function(l=!1,c=!1){if(!this.initialized)return Promise.resolve(!1);if(this.sortRunning)return Promise.resolve(!0);if(this.splatMesh.getSplatCount()<=0)return this.splatRenderCount=0,Promise.resolve(!1);let d=0,u=0,h=!1,m=!1;if(n.set(0,0,-1).applyQuaternion(this.camera.quaternion),d=n.dot(t),u=i.copy(this.camera.position).sub(o).length(),!l&&!this.splatMesh.dynamicMode&&r.length===0&&(d<=.99&&(h=!0),u>=1&&(m=!0),!h&&!m))return Promise.resolve(!1);this.sortRunning=!0;let{splatRenderCount:p,shouldSortAll:g}=this.gatherSceneNodesForSort();g=g||c,this.splatRenderCount=p,e.copy(this.camera.matrixWorld).invert();const C=this.perspectiveCamera||this.camera;e.premultiply(C.projectionMatrix),this.splatMesh.dynamicMode||e.multiply(this.splatMesh.matrixWorld);let S=Promise.resolve(!0);return this.gpuAcceleratedSort&&(r.length<=1||r.length%2===0)&&(S=this.splatMesh.computeDistancesOnGPU(e,this.sortWorkerPrecomputedDistances)),S.then(()=>{if(r.length===0)if(this.splatMesh.dynamicMode||g)r.push(this.splatRenderCount);else{for(let x of a)if(d<x.angleThreshold){for(let E of x.sortFractions)r.push(Math.floor(this.splatRenderCount*E));break}r.push(this.splatRenderCount)}let T=Math.min(r.shift(),this.splatRenderCount);this.splatSortCount=T,s[0]=this.camera.position.x,s[1]=this.camera.position.y,s[2]=this.camera.position.z;const w={modelViewProj:e.elements,cameraPosition:s,splatRenderCount:this.splatRenderCount,splatSortCount:T,usePrecomputedDistances:this.gpuAcceleratedSort};return this.splatMesh.dynamicMode&&this.splatMesh.fillTransformsArray(this.sortWorkerTransforms),this.sharedMemoryForWorkers||(w.indexesToSort=this.sortWorkerIndexesToSort,w.transforms=this.sortWorkerTransforms,this.gpuAcceleratedSort&&(w.precomputedDistances=this.sortWorkerPrecomputedDistances)),this.sortPromise=new Promise(x=>{this.sortPromiseResolver=x}),this.preSortMessages.length>0&&(this.preSortMessages.forEach(x=>{this.sortWorker.postMessage(x)}),this.preSortMessages=[]),this.sortWorker.postMessage({sort:w}),r.length===0&&(o.copy(this.camera.position),t.copy(n)),!0}),S}}();gatherSceneNodesForSort=function(){const e=[];let s=null;const t=new f.Vector3,n=new f.Vector3,o=new f.Vector3,i=new f.Matrix4,r=new f.Matrix4,a=new f.Matrix4,l=new f.Vector3,c=new f.Vector3(0,0,-1),d=new f.Vector3,u=h=>d.copy(h.max).sub(h.min).length();return function(h=!1){this.getRenderDimensions(l);const m=l.y/2/Math.tan(this.camera.fov/2*f.MathUtils.DEG2RAD),p=Math.atan(l.x/2/m),g=Math.atan(l.y/2/m),C=Math.cos(p),S=Math.cos(g),T=this.splatMesh.getSplatTree();if(T){r.copy(this.camera.matrixWorld).invert(),this.splatMesh.dynamicMode||r.multiply(this.splatMesh.matrixWorld);let w=0,x=0;for(let y=0;y<T.subTrees.length;y++){const v=T.subTrees[y];i.copy(r),this.splatMesh.dynamicMode&&(this.splatMesh.getSceneTransform(y,a),i.multiply(a));const D=v.nodesWithIndexes.length;for(let b=0;b<D;b++){const F=v.nodesWithIndexes[b];if(!F.data||!F.data.indexes||F.data.indexes.length===0)continue;o.copy(F.center).applyMatrix4(i);const R=o.length();o.normalize(),t.copy(o).setX(0).normalize(),n.copy(o).setY(0).normalize();const k=c.dot(n),M=c.dot(t),O=u(F),L=M<S-.6,U=k<C-.6;!h&&(U||L)&&R>O||(x+=F.data.indexes.length,e[w]=F,F.data.distanceToNode=R,w++)}}e.length=w,e.sort((y,v)=>y.data.distanceToNode<v.data.distanceToNode?-1:1);let E=x*j.BytesPerInt;for(let y=0;y<w;y++){const v=e[y],D=v.data.indexes.length,b=D*j.BytesPerInt;new Uint32Array(this.sortWorkerIndexesToSort.buffer,E-b,D).set(v.data.indexes),E-=b}return{splatRenderCount:x,shouldSortAll:!1}}else{const w=this.splatMesh.getSplatCount();if(!s||s.length!==w){s=new Uint32Array(w);for(let x=0;x<w;x++)s[x]=x}return this.sortWorkerIndexesToSort.set(s),{splatRenderCount:w,shouldSortAll:!0}}}}();getSplatMesh(){return this.splatMesh}getSplatScene(e){return this.splatMesh.getScene(e)}getSceneCount(){return this.splatMesh.getSceneCount()}isMobile(){return navigator.userAgent.includes("Mobi")}}class Ct extends f.Group{constructor(e={}){super(),e.selfDrivenMode=!1,e.useBuiltInControls=!1,e.rootElement=null,e.dropInMode=!0,e.camera=void 0,e.renderer=void 0,this.viewer=new Ke(e),this.splatMesh=null,this.updateSplatMesh(),this.callbackMesh=Ct.createCallbackMesh(),this.add(this.callbackMesh),this.callbackMesh.onBeforeRender=Ct.onBeforeRender.bind(this,this.viewer),this.viewer.onSplatMeshChanged(()=>{this.updateSplatMesh()})}updateSplatMesh(){this.splatMesh!==this.viewer.splatMesh&&(this.splatMesh&&this.remove(this.splatMesh),this.splatMesh=this.viewer.splatMesh,this.add(this.viewer.splatMesh))}addSplatScene(e,s={}){return s.showLoadingUI!==!1&&(s.showLoadingUI=!0),this.viewer.addSplatScene(e,s)}addSplatScenes(e,s){return s!==!1&&(s=!0),this.viewer.addSplatScenes(e,s)}getSplatScene(e){return this.viewer.getSplatScene(e)}removeSplatScene(e,s=!0){return this.viewer.removeSplatScene(e,s)}removeSplatScenes(e,s=!0){return this.viewer.removeSplatScenes(e,s)}getSceneCount(){return this.viewer.getSceneCount()}setActiveSphericalHarmonicsDegrees(e){this.viewer.setActiveSphericalHarmonicsDegrees(e)}async dispose(){return await this.viewer.dispose()}static onBeforeRender(e,s,t,n){e.update(s,n)}static createCallbackMesh(){const e=new f.SphereGeometry(1,8,8),s=new f.MeshBasicMaterial;s.colorWrite=!1,s.depthWrite=!1;const t=new f.Mesh(e,s);return t.frustumCulled=!1,t}}const{defineComponent:Vo}=await Oe("vue"),{openBlock:No,createElementBlock:Go}=await Oe("vue"),qo=["rotate-y"],{ref:Wo,watch:Ko}=await Oe("vue"),jo=Vo({__name:"gs3Dcom",setup(A){const e=new Ct({sharedMemoryForWorkers:!1,dynamicScene:!0});e.addSplatScenes([{path:"./plugins/gaussianSplatting/model/luigi.ply",splatAlphaRemovalThreshold:5}],!0);const s=Wo(null);return Ko(s,t=>{e.children[0].geometry.setAttribute("position",[]),t.add(e)}),(t,n)=>(No(),Go("TresGroup",{ref_key:"tgRef",ref:s,"rotate-y":Math.PI},null,8,qo))}}),{defineComponent:Yo}=await Oe("vue"),{createElementVNode:mt,unref:Rs,createVNode:Ps,Suspense:Xo,withCtx:Os,openBlock:ks,createBlock:Ls,mergeProps:Jo}=await Oe("vue"),{SRGBColorSpace:Zo,BasicShadowMap:$o,NoToneMapping:er}=await Oe("three"),{reactive:tr}=await Oe("vue"),rr=Yo({__name:"gs3DcomPage",setup(A){const e=tr({clearColor:"#ffffff",alpha:!1,shadowMapType:$o,outputColorSpace:Zo,toneMapping:er});return(s,t)=>(ks(),Ls(Rs(Zs),Jo(e,{"window-size":""}),{default:Os(()=>[t[0]||(t[0]=mt("TresPerspectiveCamera",{position:[3,3,3],fov:45,near:.1,far:1e3,"look-at":[0,0,0]},null,-1)),Ps(Rs($s)),t[1]||(t[1]=mt("TresAmbientLight",{intensity:3},null,-1)),(ks(),Ls(Xo,null,{default:Os(()=>[Ps(jo,{position:[0,.7,0]})]),_:1})),t[2]||(t[2]=mt("TresDirectionalLight",{position:[6,2,4],intensity:2},null,-1)),t[3]||(t[3]=mt("TresGridHelper",null,null,-1))]),_:1},16))}});export{rr as default};
