import{o as e,F as t,_ as n,K as o}from"./@tresjs.MD0a_GHJ1763541780170.js";import"./lamina.CkbQJGmr1763541780170.js";import"./three-custom-shader-material.CEYdA4hW1763541780170.js";import"./shapeConfigurator.vue_vue_type_style_index_1_scoped_abbf0cc1_lang.D34gkB8O1763541780170.js";import"./Resource.Cw8OnALu1763541780170.js";import{_ as a}from"./skyBoxDmesh.vue_vue_type_script_setup_true_lang.C3bJ9pRD1763541780170.js";import{P as r}from"./tweakpane.CqZAnw7f1763541780170.js";import{d as s,w as i,b as l,o as u,u as d,ac as c,G as p,I as v,h as m,m as g,ah as f,e as x,a3 as y,r as w,g as h,a9 as P,aa as A}from"./@vue.D9fSGD371763541780170.js";import{ar as b,k as z,a6 as _,i as C,bK as D,j as F,V as j,dw as E,cV as M,cW as S,d as q,cX as B,a0 as k}from"./three.F31Lz30M1763541780170.js";import{u as T}from"./utils.5F_t4e-P1763541780170.js";import"./postprocessing.CQ_CcmSv1763541780170.js";import"./@vueuse.C5rlNtd31763541780170.js";import"./glsl-tokenizer.OjCjHwkS1763541780170.js";import"./@amap.fjyZdsU91763541780170.js";import"./glsl-token-descope.C_0NLqRb1763541780170.js";import"./glsl-token-depth.Duvdnvlt1763541780170.js";import"./glsl-token-scope.BdCfdvWe1763541780170.js";import"./glsl-token-properties.DKXemF9b1763541780170.js";import"./glsl-token-assignments.Ctx_yUgS1763541780170.js";import"./glsl-token-string.BOQ5VJZe1763541780170.js";import"./glsl-token-functions.ub9vNSz51763541780170.js";import"./object-hash.Bg6hZt921763541780170.js";import"./jszip.DlMTIJ0v1763541780170.js";var K="vec4 permute(vec4 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    \n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    \n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    \n    i = mod(i, 289.0);\n    vec4 p = permute(permute(permute(\n                    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    \n    \n    float n_ = 1.0 / 7.0; \n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); \n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_); \n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    \n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    \n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\n                dot(p2, x2), dot(p3, x3)));\n}";const N=s({__name:"material",props:{baseMaterial:{default:new b},uEdgeColor:{default:"#4d9bff"},uEdge:{default:6},uFreq:{default:.41},uAmp:{default:20},uProgress:{default:-2}},setup(t){const n=t,o={uEdgeColor:{value:new z(n.uEdgeColor)},uFreq:{value:n.uFreq},uAmp:{value:n.uAmp},uProgress:{value:n.uProgress},uEdge:{value:n.uEdge}},a=`\n  varying vec3 vPos;\n\n  uniform float uFreq;\n  uniform float uAmp;\n  uniform float uProgress;\n  uniform float uEdge;\n  uniform vec3 uEdgeColor;\n\n  ${K}\n\n\tvoid main() {\n\t\tfloat noise = snoise(vPos * uFreq) * uAmp; // calculate snoise in fragment shader for smooth dissolve edges\n\n    if(noise < uProgress) discard; // discard any fragment where noise is lower than progress\n\n    float edgeWidth = uProgress + uEdge;\n\n    if(noise > uProgress && noise < edgeWidth){\n        csm_DiffuseColor = vec4(vec3(uEdgeColor),noise); // colors the edge\n    }else{\n\t\t\t\tcsm_DiffuseColor = vec4(csm_DiffuseColor.xyz,1.0);\n\t\t}\n\t}\n`;return i(()=>[n.uEdgeColor,n.uEdge,n.uFreq,n.uAmp,n.uProgress],([e,t,n,a,r])=>{o.uEdgeColor.value.setStyle(e),o.uEdge.value=t,o.uFreq.value=n,o.uAmp.value=a,o.uProgress.value=r}),(n,r)=>(u(),l(d(e),{baseMaterial:t.baseMaterial,vertexShader:"\n\tvarying vec3 vPos;\n\tvoid main() {\n\t\tvPos = position;\n\t}\n",side:_,fragmentShader:a,uniforms:o},null,8,["baseMaterial","side"]))}}),$=["geometry"],I=["blending"],R=s({__name:"particlesPoints",props:{geo:{default:new C},uEdge:{default:6},uFreq:{default:.41},uAmp:{default:20},uProgress:{default:-2},uColor:{default:"#4d9bff"},uPointSize:{default:200},particleData:{default:{particleSpeedFactor:.02,velocityFactor:{x:2.5,y:2},waveAmplitude:0}}},async setup(e){let o,a;const r=e,s=r.geo.clone(),l=([o,a]=c(()=>T("./plugins/industry4/image/particle.png")),o=await o,a(),o);let m,g,f,x,y,w,h=s.attributes.position.count;!function(e){h=e.attributes.position.count,m=new Float32Array(h),g=new Float32Array(e.getAttribute("position").array),f=new Float32Array(e.getAttribute("position").array),x=new Float32Array(3*h),y=new Float32Array(h),w=new Float32Array(h);for(let t=0;t<h;t++){let e=3*t+0,n=3*t+1,o=3*t+2;m[t]=5.5*Math.random()+1.5,x[e]=.5*Math.random()+.5,x[n]=.5*Math.random()+.5,x[o]=.1*Math.random(),y[t]=.001,w[t]=Math.random()*Math.PI*2}e.setAttribute("aOffset",new F(m,1)),e.setAttribute("aCurrentPos",new F(f,3)),e.setAttribute("aVelocity",new F(x,3)),e.setAttribute("aDist",new F(y,1)),e.setAttribute("aAngle",new F(w,1))}(s);const{renderer:P}=t(),A={uTexture:{value:l},uPixelDensity:{value:P.getPixelRatio()},uProgress:{value:r.uProgress},uEdge:{value:r.uEdge},uAmp:{value:r.uAmp},uFreq:{value:r.uFreq},uBaseSize:{value:r.uPointSize},uColor:{value:new z(r.uColor)}},b=`\n    ${K}\n    uniform float uPixelDensity;\n    uniform float uBaseSize;\n    uniform float uFreq;\n    uniform float uAmp;\n    uniform float uEdge;\n    uniform float uProgress;\n\n    varying float vNoise;\n    varying float vAngle;\n\n    attribute vec3 aCurrentPos;\n    attribute float aDist;\n    attribute float aAngle;\n\n    void main() {\n        vec3 pos = position;\n\n        float noise = snoise(pos * uFreq) * uAmp;\n        vNoise =noise;\n\n        vAngle = aAngle;\n\n        if( vNoise > uProgress-2.0 && vNoise < uProgress + uEdge+2.0){\n            pos = aCurrentPos;\n        }\n\n        vec4 modelPosition = modelMatrix * vec4(pos, 1.0);\n        vec4 viewPosition = viewMatrix * modelPosition;\n        vec4 projectedPosition = projectionMatrix * viewPosition;\n        gl_Position = projectedPosition;\n\n        float size = uBaseSize * uPixelDensity;\n        size = size  / (aDist + 1.0);\n        gl_PointSize = size / -viewPosition.z;\n}\n`;function _(e){let t=x[3*e+0],n=x[3*e+1],o=x[3*e+2];t*=r.particleData.velocityFactor.x,n*=r.particleData.velocityFactor.y;let{xwave:a,ywave:s}=function(e){const t=f[3*e+0],n=f[3*e+1];let o=Math.sin(2*n)*(.8+r.particleData.waveAmplitude),a=Math.sin(2*t)*(.6+r.particleData.waveAmplitude),s=Math.sin(5*n)*(.2+r.particleData.waveAmplitude),i=Math.sin(1*t)*(.9+r.particleData.waveAmplitude),l=Math.sin(8*n)*(.8+r.particleData.waveAmplitude),u=Math.sin(5*t)*(.6+r.particleData.waveAmplitude);return{xwave:o+s+l+Math.sin(3*n)*(.8+r.particleData.waveAmplitude),ywave:a+i+u+Math.sin(7*t)*(.6+r.particleData.waveAmplitude)}}(e);return t+=a,n+=s,t*=Math.abs(r.particleData.particleSpeedFactor),n*=Math.abs(r.particleData.particleSpeedFactor),o*=Math.abs(r.particleData.particleSpeedFactor),{vx:t,vy:n,vz:o}}const{onBeforeRender:C}=n();return C(()=>{!function(){for(let e=0;e<h;e++){let t=3*e+0,n=3*e+1,o=3*e+2,{vx:a,vy:r,vz:s}=_(e);f[t]+=a,f[n]+=r,f[o]+=s;const i=new j(g[t],g[n],g[o]),l=new j(f[t],f[n],f[o]),u=i.distanceTo(l);y[e]=u,w[e]+=.01,u>m[e]&&(f[t]=g[t],f[n]=g[n],f[o]=g[o])}s.setAttribute("aOffset",new F(m,1)),s.setAttribute("aCurrentPos",new F(f,3)),s.setAttribute("aVelocity",new F(x,3)),s.setAttribute("aDist",new F(y,1)),s.setAttribute("aAngle",new F(w,1))}()}),i(()=>[r.uColor,r.uEdge,r.uFreq,r.uAmp,r.uProgress,r.uPointSize],([e,t,n,o,a,r])=>{A.uColor.value.setStyle(e),A.uEdge.value=t,A.uFreq.value=n,A.uAmp.value=o,A.uProgress.value=a,A.uBaseSize.value=r}),(e,t)=>(u(),p("TresPoints",{geometry:d(s)},[v("TresShaderMaterial",{transparent:"",blending:D,uniforms:A,vertexShader:b,fragmentShader:"\n    uniform vec3 uColor;\n    uniform float uEdge;\n    uniform float uProgress;\n    uniform sampler2D uTexture;\n\n    varying float vNoise;\n    varying float vAngle;\n\n    void main(){\n        if( vNoise < uProgress ) discard;\n        if( vNoise > uProgress + uEdge) discard;\n\n        vec2 coord = gl_PointCoord;\n        coord = coord - 0.5; // get the coordinate from 0-1 ot -0.5 to 0.5\n        coord = coord * mat2(cos(vAngle),sin(vAngle) , -sin(vAngle), cos(vAngle)); // apply the rotation transformaion\n        coord = coord +  0.5; // reset the coordinate to 0-1  \n\n        vec4 texture = texture2D(uTexture,coord);\n\n        gl_FragColor = vec4(vec3(uColor.xyz * texture.xyz),1.0);\n    }\n"},null,8,I)],8,$))}}),V=["geometry"],G=s({__name:"torusKnot",setup(e){const t=new E(3,1,64,8,2,3);return(e,n)=>(u(),p("TresGroup",null,[v("TresMesh",{geometry:d(t)},[m(N,g({color:"#636363",metalness:2,roughness:0},e.$attrs),null,16)],8,V),(u(),l(f,null,{default:x(()=>[m(R,g({geo:d(t)},e.$attrs,{uColor:e.$attrs.uEdgeColor}),null,16,["geo","uColor"])]),_:1}))]))}}),W=s({__name:"bloomPass",setup(e){const{camera:o,renderer:a,scene:r,sizes:s}=t(),i=0,l=.216,u=.2;let d=null;y(()=>{s.width.value&&((e,t,n,o,a)=>{const r=new M(e,t),s=new S(new q(o,a),l,u,i);d=new B(n),d.addPass(r),d.addPass(s)})(r.value,o.value,a,s.width.value,s.height.value)});const{onBeforeRender:c}=n();return c(()=>{d&&d.render()}),(e,t)=>null}}),O=s({__name:"dissolveEffectPlus",setup(e){const t={clearColor:"#201919",windowSize:!0,toneMapping:k,toneMappingExposure:.8,renderMode:"manual"},n=w({uEdgeColor:"#ff784d",uEdge:6,uFreq:.41,uAmp:20,uProgress:-4.9,uPointSize:576,particleData:{particleSpeedFactor:.02,velocityFactor:{x:2.5,y:2},waveAmplitude:0}}),s=w({torusKnotColor:"#7a8c87"}),i=new r({title:"参数",expanded:!0});return i.addBinding(s,"torusKnotColor",{label:"torusKnotColor"}),i.addBinding(n,"uEdgeColor",{label:"边缘颜色"}),i.addBinding(n,"uEdge",{label:"边缘宽度",min:0,max:9,step:.01}),i.addBinding(n,"uFreq",{label:"密度",min:.002,max:2,step:.002}),i.addBinding(n,"uAmp",{label:"幅度",min:3,max:22,step:.01}),i.addBinding(n,"uProgress",{label:"进度",min:-25,max:20,step:.1}),i.addBinding(n,"uPointSize",{label:"粒子大小",min:10,max:800,step:5}),i.addBinding(n.particleData,"particleSpeedFactor",{label:"粒子速度",min:1e-4,max:.1,step:1e-4}),i.addBinding(n.particleData,"velocityFactor",{picker:"inline",label:"粒子飘逸方向",expanded:!0,x:{min:-10,max:10,step:.01},y:{min:-10,max:10,step:.01}}),i.addBinding(n.particleData,"waveAmplitude",{label:"粒子扰动幅度",min:0,max:5,step:.01}),(e,r)=>{const i=h("TresCanvas");return u(),l(i,P(A(t)),{default:x(()=>[r[0]||(r[0]=v("TresPerspectiveCamera",{position:[15,15,15],fov:45,near:.1,far:1e4,"look-at":[0,0,0]},null,-1)),m(d(o),{enableDamping:""}),m(G,g(n,{color:s.torusKnotColor}),null,16,["color"]),(u(),l(f,null,{default:x(()=>[m(d(a),{texture:"https://opensource.cdn.icegl.cn/images/skyBox/workshop_blur.jpg"},null,8,["texture"])]),_:1})),m(W)]),_:1},16)}}});export{O as default};
