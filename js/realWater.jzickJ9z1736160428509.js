import{m as n,e,b as t,c as r,U as o}from"./@tresjs.8MtVPQyb1736160428509.js";import{P as i}from"./tweakpane.yHWGBmom1736160428509.js";import{_ as c,a,s as l,W as s,m as u,O as f,ay as p,t as v}from"./three.rmsIv-u_1736160428509.js";import{d as g,a6 as d,b as x,o as h,f as m,u as y,g as w,al as b,j as I,r as C,aj as R,ak as _,J as M}from"./@vue.4u_eOGex1736160428509.js";import"./@vueuse.GObPVvIB1736160428509.js";var z="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const D=O;function T(){const n=["5004015cWcTrp","10888482JVxgJv","tiles","light","trace","function *\\( *\\)","8839300qicOQf","setAttribute","gger","error","3789260lQbTte","apply","water","2OMymZa","3447374FYZFBa","waterTexture","value","return (function() ","toString","5PbycVT","chain","test","log","uniforms",'{}.constructor("return this")( )',"init","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","position","Mesh","console","counter","info","setIndex","constructor","701368UQYbER","FrontSide","debu","pool","BufferGeometry","exception","stateObject","while (true) {}","99mbuVIU","table","bind","length","1176986zLNWeb","RawShaderMaterial","action"];return(T=function(){return n})()}!function(n,e){const t=O,r=T();for(;;)try{if(979416===parseInt(t(503))/1*(-parseInt(t(536))/2)+parseInt(t(539))/3+parseInt(t(500))/4*(parseInt(t(509))/5)+-parseInt(t(540))/6+-parseInt(t(504))/7+parseInt(t(524))/8*(parseInt(t(532))/9)+parseInt(t(496))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){L(this,(function(){const n=O,e=new RegExp(n(495)),t=new RegExp(n(516),"i"),r=E(n(515));e[n(511)](r+n(510))&&t.test(r+"input")?E():r("0")}))()}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[O(501)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function O(n,e){const t=T();return(O=function(n,e){return t[n-=492]})(n,e)}A(void 0,(function(){const n=O;let e;try{e=Function(n(507)+n(514)+");")()}catch(o){e=window}const t=e[n(519)]=e[n(519)]||{},r=[n(512),"warn",n(521),n(499),n(529),n(533),n(494)];for(let i=0;i<r[n(535)];i++){const e=A[n(523)].prototype[n(534)](A),o=r[i],c=t[o]||e;e.__proto__=A[n(534)](A),e[n(508)]=c[n(508)][n(534)](c),t[o]=e}}))();const F=g({__name:D(527),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=D,o=t,i=new(c[r(528)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(497)](r(517),new a(l,3)),i[r(522)](new a(s,1));const u=new(c[r(537)])({uniforms:{light:{value:o[r(493)]},tiles:{value:o[r(492)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(525)]}),f=new(c[r(518)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{((n,e)=>{const t=r;u.uniforms[t(502)].value=n,u[t(513)].causticTex[t(506)]=e,p[t(506)].render(f,v[t(506)])})(o[r(505)],o.causticsTexture)})),(n,e)=>null}});function E(n){function e(n){const t=O;if("string"==typeof n)return function(n){}[t(523)](t(531))[t(501)](t(520));1!==(""+n/n)[t(535)]||n%20==0?function(){return!0}[t(523)](t(526)+t(498)).call(t(538)):function(){return!1}[t(523)](t(526)+t(498))[t(501)](t(530)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const S=j;function j(n,e){const t=V();return(j=function(n,e){return t[n-=283]})(n,e)}!function(n,e){const t=j,r=V();for(;;)try{if(464548===parseInt(t(328))/1+-parseInt(t(287))/2+parseInt(t(341))/3+parseInt(t(321))/4+parseInt(t(300))/5+parseInt(t(301))/6*(-parseInt(t(318))/7)+parseInt(t(293))/8*(-parseInt(t(312))/9))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[j(329)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){W(this,(function(){const n=j,e=new RegExp(n(313)),t=new RegExp(n(330),"i"),r=H(n(298));e[n(296)](r+n(311))&&t[n(296)](r+"input")?H():r("0")}))()}();const P=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[j(329)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function V(){const n=["underwater","return (function() ","pos-x.jpg","length","213459rLdbsD","FrontSide","load","string","causticsTexture","618498IDlHvx","prototype","pooRef","table","error","debu","10352mqzYZt","neg-x.jpg","__proto__","test","bind","init","tiles","4291730utvXwY","4342326IbmuIA","gger","render","setClearColor","uniforms","constructor","light","toString","console","RawShaderMaterial","chain","2493wTLJQq","function *\\( *\\)","trace","waterTexture","stateObject","counter","7tOpaPc","side","water","2502972QqaHKF","BackSide","pos-z.jpg","exception","white","setPath","Color","300714oErKmy","apply","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","warn","call","CubeTextureLoader","action","causticTex","value"];return(V=function(){return n})()}P(void 0,(function(){const n=j,e=function(){const n=j;let e;try{e=Function(n(338)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(309)]=e.console||{},r=["log",n(331),"info",n(291),n(324),n(290),n(314)];for(let o=0;o<r.length;o++){const e=P.constructor[n(288)].bind(P),i=r[o],c=t[i]||e;e[n(295)]=P[n(297)](P),e[n(308)]=c[n(308)][n(297)](c),t[i]=e}}))();const Z=g({__name:S(320),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=S;let i,a;const s=r,u=s.geometry,f=(new(c[o(333)]))[o(326)]("https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/")[o(284)]([o(339),o(294),"pos-y.jpg","neg-y.jpg",o(323),"neg-z.jpg"]),p=([i,a]=d((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),v=new(c[o(310)])({uniforms:{light:{value:s[o(307)]},tiles:{value:p},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),g=new l(u,v),w=x(null),b=new(c[o(327)])(o(325)),{renderer:I,camera:C}=n(),{onLoop:R}=e();return R((()=>{const n=o;I[n(336)].setRenderTarget(null),I.value[n(304)](b,1),I.value.clear(),v.uniforms[n(320)][n(336)]=s.waterTexture,v[n(305)][n(335)][n(336)]=s[n(286)],v.side=c[n(283)],v.uniforms.underwater[n(336)]=!0,I.value.render(g,C.value),v[n(319)]=c[n(322)],v.uniforms[n(337)].value=!1,I[n(336)][n(303)](g,C[n(336)])})),(n,e)=>{const t=o;return h(),m(F,{tiles:y(p),light:n[t(307)],waterTexture:n[t(315)],causticsTexture:n[t(286)],ref_key:t(289),ref:w},null,8,[t(299),"light",t(315),t(286)])}}});function H(n){function e(n){const t=j;if(typeof n===t(285))return function(n){}[t(306)]("while (true) {}")[t(329)](t(317));1!==(""+n/n)[t(340)]||n%20==0?function(){return!0}[t(306)](t(292)+t(302))[t(332)](t(334)):function(){return!1}[t(306)](t(292)+t(302))[t(329)](t(316)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const k=q;!function(n,e){const t=q,r=Y();for(;;)try{if(211850===-parseInt(t(395))/1+-parseInt(t(401))/2*(-parseInt(t(419))/3)+parseInt(t(409))/4*(-parseInt(t(383))/5)+parseInt(t(385))/6*(-parseInt(t(415))/7)+-parseInt(t(387))/8*(-parseInt(t(382))/9)+-parseInt(t(394))/10*(-parseInt(t(402))/11)+-parseInt(t(400))/12*(-parseInt(t(403))/13))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const N=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(377)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){N(this,(function(){const n=q,e=new RegExp(n(379)),t=new RegExp(n(380),"i"),r=Q("init");e[n(412)](r+n(425))&&t[n(412)](r+n(392))?Q():r("0")}))()}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(377)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();B(void 0,(function(){const n=q,e=function(){const n=q;let e;try{e=Function(n(430)+n(405)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(420)]||{},r=[n(410),n(376),n(375),"error",n(413),n(384),"trace"];for(let o=0;o<r[n(429)];o++){const e=B[n(374)][n(423)][n(406)](B),i=r[o],c=t[i]||e;e[n(390)]=B[n(406)](B),e[n(404)]=c[n(404)][n(406)](c),t[i]=e}}))();const G=g({__name:k(424),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=k,o=t,i=new(c[r(398)])(0,1,1,0,0,2e3),a=new(c[r(396)])(2,2,200,200),l=new s(1024,1024),f=new u({uniforms:{light:{value:o[r(386)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new(c[r(408)])(a,f),v=new(c[r(414)])(r(378)),{renderer:g}=n(),{onBeforeLoop:d}=e();return d((()=>{const n=r;p.material[n(417)].water[n(428)]=o.waterTexture,g.value[n(426)](l),g.value[n(397)](v,0),g[n(428)][n(416)](),g[n(428)][n(421)](p,i)})),(n,e)=>{const t=r;return h(),m(b,null,{default:w((()=>[I(Z,{waterTexture:n[t(427)],causticsTexture:y(l)[t(407)],light:n.light,geometry:y(a)},null,8,[t(427),t(388),t(386),t(399)])])),_:1})}}});function Y(){const n=["19137xgOjXL","console","render","string","prototype","caustics","chain","setRenderTarget","waterTexture","value","length","return (function() ","constructor","info","warn","apply","black","function *\\( *\\)","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","gger","14940ZfLLnM","15VgQZCS","table","6KIqBaw","light","232ZwNZWQ","causticsTexture","stateObject","__proto__","counter","input","while (true) {}","130fOpKwl","421098vyzrCT","PlaneGeometry","setClearColor","OrthographicCamera","geometry","2743452bPYwfs","28MJMIzS","330517FwgHdu","13QcIHKq","toString",'{}.constructor("return this")( )',"bind","texture","Mesh","110032FENXrG","log","call","test","exception","Color","288442gEYAWU","clear","uniforms","debu"];return(Y=function(){return n})()}function q(n,e){const t=Y();return(q=function(n,e){return t[n-=374]})(n,e)}function Q(n){function e(n){const t=q;if(typeof n===t(422))return function(n){}[t(374)](t(393)).apply(t(391));1!==(""+n/n)[t(429)]||n%20==0?function(){return!0}.constructor(t(418)+"gger")[t(411)]("action"):function(){return!1}.constructor("debu"+t(381))[t(377)](t(389)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const $=K;!function(n,e){const t=K,r=U();for(;;)try{if(259330===parseInt(t(234))/1+-parseInt(t(248))/2*(parseInt(t(236))/3)+parseInt(t(217))/4*(-parseInt(t(249))/5)+parseInt(t(226))/6+-parseInt(t(221))/7+parseInt(t(262))/8*(parseInt(t(243))/9)+parseInt(t(201))/10*(parseInt(t(223))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const J=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){J(this,(function(){const n=K,e=new RegExp(n(220)),t=new RegExp(n(256),"i"),r=en(n(266));e[n(246)](r+n(227))&&t[n(246)](r+n(263))?en():r("0")}))()}();const X=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[K(230)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function U(){const n=["RawShaderMaterial","log","Vector2","setRenderTarget","length","height","40ZreAtV","exception","clientY","function *\\( *\\)","1566691PBGHCR","addEventListener","737GGPMLy","debu","while (true) {}","2652474xleZSp","chain","console","setZ","apply","strength","uniforms","intersectObject","392916zXPpHY","radius","3IeJJIu","info","gger","render","error","FloatType","texture","36LMpLYp","action","setFromCamera","test","string","384950VTVBae","194725WMtfWk","lightFrontGeometry","WebGLRenderTarget","domElement","material","toString",'{}.constructor("return this")( )',"\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","__proto__","left","prototype","bind","Mesh","439912WRIdBq","input","warn","light","init","point","mousemove","PlaneGeometry","trace","value","return (function() ","1510aZDTGm","needsUpdate","waterSimulation","center","getBoundingClientRect","constructor","setY","clientX","count","top"];return(U=function(){return n})()}function K(n,e){const t=U();return(K=function(n,e){return t[n-=196]})(n,e)}X(void 0,(function(){const n=K,e=function(){const n=K;let e;try{e=Function(n(200)+n(255)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(228)]||{},r=[n(212),n(264),n(237),n(240),n(218),"table",n(198)];for(let o=0;o<r.length;o++){const e=X.constructor[n(259)][n(260)](X),i=r[o],c=t[i]||e;e[n(257)]=X[n(260)](X),e.toString=c[n(254)].bind(c),t[i]=e}}))();const nn=g({__name:$(203),props:{light:{}},setup(t,{expose:r}){const o=$,i=new f(0,1,1,0,0,2e3),a=new(c[o(197)])(2,2),l=new(c[o(251)])(256,256,{type:c[o(241)]}),u=new s(256,256,{type:c[o(241)]}),g=new p({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),d=new(c[o(211)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),x=new(c[o(211)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),w=new(c[o(261)])(a,g),b=new(c[o(261)])(a,d),I=new(c[o(261)])(a,x);let C=l;const R=(n,e)=>{const t=o,r=C,c=C===l?u:l;e[t(253)][t(232)].texture[t(199)]=r[t(242)],n[t(214)](c),n[t(239)](e,i),C=c},{renderer:_,camera:M,raycaster:D}=n();_.value.autoClear=!1;const{onBeforeLoop:T}=e();T((()=>{var n,e;e=_[o(199)],R(e,I),n=_.value,R(n,b)}));const L=(n,e,t,r)=>{const i=o;w.material.uniforms[i(204)][i(199)]=[n,e],w[i(253)].uniforms[i(235)][i(199)]=t,w[i(253)][i(232)][i(231)][i(199)]=r,R(_[i(199)],w)},A=new(c[o(213)]),O=new v(2,2),F=O.attributes.position;for(let n=0;n<F[o(209)];n++){const e=-F.getY(n);F[o(207)](n,0),F[o(229)](n,e)}F[o(202)]=!0;const E=new(c[o(261)])(O),S={handleEvent:n=>{const e=o,t=_[e(199)][e(252)][e(205)](),r=t.width,i=t[e(216)];A.x=2*(n[e(208)]-t[e(258)])/r-1,A.y=2*-(n[e(219)]-t[e(210)])/i+1,D[e(199)][e(245)](A,M[e(199)]);const c=D[e(199)][e(233)](E);for(let o of c)L(o[e(267)].x,o[e(267)].z,.03,.04)}};return r({addDrop:L,mouseEvent:n=>{const e=o;n?_[e(199)][e(252)][e(222)](e(196),S):_[e(199)][e(252)].removeEventListener(e(196),S)}}),(n,e)=>{const t=o;return h(),m(G,{lightFrontGeometry:y(a),waterTexture:y(C)[t(242)],light:n[t(265)]},null,8,[t(250),"waterTexture","light"])}}});function en(n){function e(n){const t=K;if(typeof n===t(247))return function(n){}.constructor(t(225))[t(230)]("counter");1!==(""+n/n)[t(215)]||n%20==0?function(){return!0}.constructor("debu"+t(238)).call(t(244)):function(){return!1}[t(206)](t(224)+"gger")[t(230)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const tn=on;!function(n,e){const t=on,r=an();for(;;)try{if(875413===-parseInt(t(144))/1+parseInt(t(160))/2*(-parseInt(t(139))/3)+-parseInt(t(157))/4+parseInt(t(178))/5+parseInt(t(169))/6+parseInt(t(155))/7+-parseInt(t(171))/8*(-parseInt(t(154))/9))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[on(166)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function on(n,e){const t=an();return(on=function(n,e){return t[n-=138]})(n,e)}!function(){rn(this,(function(){const n=on,e=new RegExp(n(170)),t=new RegExp(n(174),"i"),r=sn(n(146));e.test(r+n(168))&&t.test(r+n(140))?sn():r("0")}))()}();const cn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function an(){const n=["return (function() ","debu","855627uoQjmT","stateObject","init","realWater","bind","鼠标波纹","gger","click","string","toString","1332EzjeVV","6556144iXxoIn","error","6597820YqynER","warn","waterSimulationRef","194574IvVOLC","constructor","点击按钮","__proto__","addDrop",'{}.constructor("return this")( )',"apply","addButton","chain","5394534ipMXiC","function *\\( *\\)","93368NdlQiw","log","addBinding","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","call","change","length","1519705eZDDSm","counter","console","TresPerspectiveCamera","table","trace","15AuzOvA","input","value"];return(an=function(){return n})()}cn(void 0,(function(){const n=on,e=function(){const n=on;let e;try{e=Function(n(142)+n(165)+");")()}catch(t){e=window}return e}(),t=e[n(180)]=e[n(180)]||{},r=[n(172),n(158),"info",n(156),"exception",n(182),n(138)];for(let o=0;o<r[n(177)];o++){const e=cn[n(161)].prototype[n(148)](cn),i=r[o],c=t[i]||e;e[n(163)]=cn[n(148)](cn),e[n(153)]=c[n(153)].bind(c),t[i]=e}}))();const ln=g({__name:tn(147),setup(n){const e=tn,t=C({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:"manual"}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=x(null),l=new i;l[e(167)]({label:e(162),title:"随机增加波纹"}).on(e(151),(()=>{const n=e;for(var t=0;t<10;t++)a[n(141)][n(164)](2*Math.random()-1,2*Math.random()-1,.03,1&t?.02:-.02)}));const s=x(!1);return l[e(173)](s,e(141),{label:e(149)}).on(e(176),(n=>{const t=e;a[t(141)].mouseEvent(n[t(141)])})),(n,i)=>{const l=e;return h(),m(y(r),R(_(t)),{default:w((()=>[i[0]||(i[0]=M(l(181),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),I(y(o)),I(nn,{light:c,ref_key:l(159),ref:a},null,512)])),_:1},16)}}});function sn(n){function e(n){const t=on;if(typeof n===t(152))return function(n){}[t(161)]("while (true) {}")[t(166)](t(179));1!==(""+n/n)[t(177)]||n%20==0?function(){return!0}.constructor(t(143)+t(150))[t(175)]("action"):function(){return!1}.constructor(t(143)+t(150))[t(166)](t(145)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{ln as default};
