import{_ as e,N as n,K as i}from"./@tresjs.DqJWjmrH1761100244891.js";import{q as o,bX as a,k as r,C as l,bJ as s,aV as t,a6 as m,u as c,ap as u,cQ as d,cC as v,cR as f}from"./three.DvmzhRS91761100244891.js";import{B as p}from"./three-custom-shader-material.BR24gUv-1761100244891.js";import{r as g,i as h,s as y}from"./utils.Cw0sHfqi1761100244891.js";import{b as _,a as x}from"./buildingsCustomShaderMaterial.DyBo--wu1761100244891.js";import{d as b,a as w,w as j,ad as S,G as C,o as O,H as k,b as B,F as z,g as M,e as T,I as P,h as N,u as U,ap as W}from"./@vue.CKlgtJke1761100244891.js";import{_ as A}from"./roadLight.vue_vue_type_script_setup_true_lang._MtsS0hO1761100244891.js";import"./postprocessing.CYU4Fj-U1761100244891.js";import"./@vueuse.mZcBai3M1761100244891.js";import"./@fesjs.DbrjsIBT1761100244891.js";import"./vue-router.AUgVvTqV1761100244891.js";import"./lodash-es.DWe8oqPO1761100244891.js";import"./pinia.-nSLzXOT1761100244891.js";import"./@qlin.y-0Z8WnK1761100244891.js";import"./@babel.BPq7uOAK1761100244891.js";import"./@floating-ui.Bhq4ibgf1761100244891.js";import"./@juggle.Vc7cP4_P1761100244891.js";import"./vanilla.esm.5.5.0.CsbunUBT1761100244891.js";import"./object-hash.zo7S6bgL1761100244891.js";import"./@amap.fjyZdsU91761100244891.js";import"./jszip.DTlig5CR1761100244891.js";import"./Resource.mX5inOAT1761100244891.js";import"./useTexture.6Wyv_tgl1761100244891.js";import"./three-mesh-bvh.-a2uGGuV1761100244891.js";class V extends o{constructor(e={}){super(),this.vertexShader="\n      #define STANDARD\n      varying vec3 vViewPosition;\n      #ifdef USE_TRANSMISSION\n      varying vec3 vWorldPosition;\n      #endif\n    \n      varying vec2 vUv;\n      varying vec4 vPos;\n      varying vec3 vNormalW;\n      varying vec3 vPositionW;\n\n      #include <common>\n      #include <uv_pars_vertex>\n      #include <envmap_pars_vertex>\n      #include <color_pars_vertex>\n      #include <fog_pars_vertex>\n      #include <morphtarget_pars_vertex>\n      #include <skinning_pars_vertex>\n      #include <logdepthbuf_pars_vertex>\n      #include <clipping_planes_pars_vertex>\n\n      void main() {\n        \n        #include <uv_vertex>\n        #include <color_vertex>\n        #include <morphcolor_vertex>\n      \n        #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n      \n          #include <beginnormal_vertex>\n          #include <morphnormal_vertex>\n          #include <skinbase_vertex>\n          #include <skinnormal_vertex>\n          #include <defaultnormal_vertex>\n      \n        #endif\n      \n        #include <begin_vertex>\n        #include <morphtarget_vertex>\n        #include <skinning_vertex>\n        #include <project_vertex>\n        #include <logdepthbuf_vertex>\n        #include <clipping_planes_vertex>\n      \n        #include <worldpos_vertex>\n        #include <envmap_vertex>\n        #include <fog_vertex>\n\n        mat4 modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;\n\n        vUv = uv;\n        vPos = projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 );\n        vPositionW = vec3( vec4( transformed, 1.0 ) * modelMatrix);\n        vNormalW = normalize( vec3( vec4( normal, 0.0 ) * modelMatrix ) );\n        \n        gl_Position = modelViewProjectionMatrix * vec4( transformed, 1.0 );\n\n      }",this.fragmentShader=" \n      varying vec2 vUv;\n      varying vec3 vPositionW;\n      varying vec4 vPos;\n      varying vec3 vNormalW;\n      \n      uniform float time;\n      uniform float fresnelOpacity;\n      uniform float scanlineSize;\n      uniform float fresnelAmount;\n      uniform float signalSpeed;\n      uniform float hologramBrightness;\n      uniform float hologramOpacity;\n      uniform bool blinkFresnelOnly;\n      uniform bool enableBlinking;\n      uniform vec3 hologramColor;\n\n      float flicker( float amt, float time ) {return clamp( fract( cos( time ) * 43758.5453123 ), amt, 1.0 );}\n      float random(in float a, in float b) { return fract((cos(dot(vec2(a,b) ,vec2(12.9898,78.233))) * 43758.5453)); }\n\n      void main() {\n        vec2 vCoords = vPos.xy;\n        vCoords /= vPos.w;\n        vCoords = vCoords * 0.5 + 0.5;\n        vec2 myUV = fract( vCoords );\n\n        // Defines hologram main color\n        vec4 hologramColor = vec4(hologramColor, mix(hologramBrightness, vUv.y, 0.5));\n\n        // Add scanlines\n        float scanlines = 10.;\n        scanlines += 20. * sin(time *signalSpeed * 20.8 - myUV.y * 60. * scanlineSize);\n        scanlines *= smoothstep(1.3 * cos(time *signalSpeed + myUV.y * scanlineSize), 0.78, 0.9);\n        scanlines *= max(0.25, sin(time *signalSpeed) * 1.0);        \n        \n        // Scanlines offsets\n        float r = random(vUv.x, vUv.y);\n        float g = random(vUv.y * 20.2, \tvUv.y * .2);\n        float b = random(vUv.y * .9, \tvUv.y * .2);\n\n        // Scanline composition\n        hologramColor += vec4(r*scanlines, b*scanlines, r, 1.0) / 84.;\n        vec4 scanlineMix = mix(vec4(0.0), hologramColor, hologramColor.a);\n\n        // Calculates fresnel\n        vec3 viewDirectionW = normalize(cameraPosition - vPositionW);\n        float fresnelEffect = dot(viewDirectionW, vNormalW) * (1.6 - fresnelOpacity/2.);\n        fresnelEffect = clamp(fresnelAmount - fresnelEffect, 0., fresnelOpacity);\n\n        // Blinkin effect\n        //Suggested by Octano - https://x.com/OtanoDesign?s=20\n        float blinkValue = enableBlinking ? 0.6 - signalSpeed : 1.0;\n        float blink = flicker(blinkValue, time * signalSpeed * .02);\n    \n        // Final shader composition\n        vec3 finalColor;\n\n        if(blinkFresnelOnly){\n          // finalColor = vec3(1.0,1.0,0);\n          finalColor = scanlineMix.rgb + fresnelEffect * blink;\n        }else{\n          finalColor = scanlineMix.rgb * blink + fresnelEffect;\n        }\n\n        gl_FragColor = vec4( finalColor, hologramOpacity);\n\n      }",this.uniforms={time:new a(0),fresnelOpacity:new a(void 0!==e.fresnelOpacity?e.fresnelOpacity:1),fresnelAmount:new a(void 0!==e.fresnelAmount?e.fresnelAmount:.45),scanlineSize:new a(void 0!==e.scanlineSize?e.scanlineSize:8),hologramBrightness:new a(void 0!==e.hologramBrightness?e.hologramBrightness:1),signalSpeed:new a(void 0!==e.signalSpeed?e.signalSpeed:1),hologramColor:new a(void 0!==e.hologramColor?new r(e.hologramColor):new r("#00d5ff")),enableBlinking:new a(void 0===e.enableBlinking||e.enableBlinking),blinkFresnelOnly:new a(void 0===e.blinkFresnelOnly||e.blinkFresnelOnly),hologramOpacity:new a(void 0!==e.hologramOpacity?e.hologramOpacity:1)},this.clock=new l,this.setValues(e),this.depthTest=void 0!==e.depthTest&&e.depthTest,this.blending=void 0!==e.blendMode?e.blendMode:s,this.transparent=!0,this.side=void 0!==e.side?e.side:t}update(){this.uniforms.time.value=this.clock.getElapsedTime()}}const E=b({__name:"importantBuildings",props:{group:{}},setup(n){const i=n,o=0,a=0,l=15,t=1.3,c="#e05b0f",u=new V({blendMode:s,hologramBrightness:2.5,side:m});u.uniforms.fresnelAmount.value=o,u.uniforms.scanlineSize.value=l,u.uniforms.signalSpeed.value=t,u.uniforms.fresnelOpacity.value=a,u.uniforms.hologramColor.value=new r(c),u.uniforms.enableBlinking.value=!1,u.depthTest=!0;let d,v,f=null;(()=>{const e=i.group.getObjectByName("02-huanqiujinrongzhongxin_huanqiujinrongzhongxin_0");e.name="环球金融中心",e.material.dispose(),g(e.geometry),e.material=u,d=i.group.getObjectByName("01-shanghaizhongxindasha_shanghaizhongxindasha_0"),d.name="上海中心",d.material.dispose(),g(d.geometry),d.material=u.clone(),d.material.uniforms.hologramColor.value=new r("#006cf9"),d.material.uniforms.fresnelAmount.value=1,d.material.uniforms.scanlineSize.value=2.1,d.material.uniforms.signalSpeed.value=.4,v=i.group.getObjectByName("03-jinmaodasha_jjinmaodasha_0"),v.name="金茂大厦",v.material.dispose(),g(v.geometry),v.material=u.clone(),v.material.uniforms.hologramColor.value=new r("#5e0fe0"),v.material.uniforms.scanlineSize.value=15,v.material.uniforms.signalSpeed.value=.18,f=i.group.getObjectByName("04-dongfangmingzhu_dongfangmingzhu_0"),f.name="东方明珠塔",f.material.dispose(),g(f.geometry),f.material=u.clone(),f.material.uniforms.scanlineSize.value=5,f.material.uniforms.signalSpeed.value=1.3,f.material.uniforms.hologramColor.value=new r("#e00f0f"),f.material.uniforms.fresnelOpacity.value=.1})();const{onBeforeRender:p}=e();return p(()=>{u.update(),d.material.update(),v.material.update(),f.material.update()}),(e,n)=>null}}),D=["object"],F=b({__name:"buildingsMode",setup(i){h();const{state:o}=n("https://opensource.cdn.icegl.cn/model/digitalCity/shanghaiDraco/shanghaiDraco.gltf",{draco:!0,decoderPath:"./draco/"}),a=w(null);j(()=>o.value,e=>{e?.scene&&(a.value=e.scene.clone(),a.value.traverse(async e=>{if(e.isMesh&&(-1!==e.name.indexOf("Shanghai")||-1!==e.name.indexOf("Object")))if(-1!==e.name.indexOf("Floor"));else if(-1!==e.name.indexOf("River")){const n=await y(S(e));n.position.set(0,0,1800),e.add(n)}else s(S(e)),t(S(e))}))});const l=w(0),s=e=>{const{geometry:n}=e;n.computeBoundingBox(),n.computeBoundingSphere(),n.computeBoundsTree();const{max:i,min:o}=n.boundingBox,a=new p({baseMaterial:c,vertexShader:x,fragmentShader:_,silent:!0,uniforms:{uMax:{value:i},uMin:{value:o},uBorderWidth:{value:.006},uCircleTime:{value:3},uColor:{value:new r("#005c58")},uOpacity:{value:.8},uLightColor:{value:new r("#990")},uTopColor:{value:new r("#888800")},uTime:l,uGradient:{value:!0}},depthWrite:!0,depthTest:!0,transparent:!0,side:m});e.material.dispose(),e.material=a},t=e=>{const n=new u(e.geometry,1e3);let i=(new d).fromEdgesGeometry(n);i.computeBoundsTree();let o=new v({color:new r("#000"),linewidth:.8,opacity:.6,transparent:!0,depthWrite:!0,depthTest:!0});o.resolution.set(window.innerWidth,window.innerHeight),e.add(new f(i,o))},{onBeforeRender:g}=e();return g(({delta:e})=>{l.value+=e}),(e,n)=>(O(),C(z,null,[a.value?(O(),C("primitive",{key:0,object:S(a.value),position:[1,0,1]},null,8,D)):k("",!0),a.value?(O(),B(E,{key:1,group:S(a.value)},null,8,["group"])):k("",!0)],64))}}),R=b({__name:"city2",setup:e=>(e,n)=>{const o=M("TresCanvas");return O(),B(o,{shadows:"","window-size":"",clearColor:"#333"},{default:T(()=>[n[0]||(n[0]=P("TresPerspectiveCamera",{position:[.5,2,1.5],fov:45,near:.1,far:1e5},null,-1)),N(U(i)),n[1]||(n[1]=P("TresAmbientLight",{color:"#ffffff"},null,-1)),n[2]||(n[2]=P("TresDirectionalLight",{position:[0,3,3],intensity:2,color:"#ffffff","cast-shadow":"","shadow-mapSize-width":1024,"shadow-mapSize-height":1024},null,-1)),(O(),B(W,null,{default:T(()=>[N(F)]),_:1})),(O(),B(W,null,{default:T(()=>[N(A,{color:"#ffffff",radius:1,speed:1,geoJson:"plugins/digitalCity/geojson/secondarySmall.geojson","rotation-y":1.3826597599330712,scale:.001025905404044292,position:[-1.877460474821603,.01,-1.5464791950519081]})]),_:1})),n[3]||(n[3]=P("TresGridHelper",{args:[6,10],position:[0,0,0]},null,-1))]),_:1})}});export{R as default};
