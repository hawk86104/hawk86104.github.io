import{importShared as e}from"./3d-tiles-renderer.6uaxtGOi1769565599278.js";import{useLoop as t,useTres as o,OrbitControls_default as r,component_default$18 as i,Box_default as n}from"./index.CG-C7MIu1769565599278.js";import{Pane as a}from"./tweakpane.BbuIEN141769565599278.js";
/**
 * @description Loop Subdivision Surface
 * @about       Smooth subdivision surface modifier for use with three.js BufferGeometry.
 * @author      Stephens Nunnally <@stevinz>
 * @license     MIT - Copyright (c) 2022 Stephens Nunnally
 * @source      https://github.com/stevinz/three-subdivide
 */
const s=await e("three"),l=new s.Vector3,u=new s.Vector3,c=new s.Vector3,d=new s.Vector3,f=new s.Vector3,p=new s.Vector3,m=new s.Vector3,v=new s.Vector3,h=new s.Vector3,g=new s.Vector3,b=new s.Vector3,w=[new s.Vector3,new s.Vector3,new s.Vector3],y=[new s.Vector3,new s.Vector3,new s.Vector3],S=new s.Triangle;class B{static modify(e,t=1,o={}){if(arguments.length>3&&console.warn("LoopSubdivision.modify() now uses a parameter object. See readme for more info!"),"object"!=typeof o&&(o={}),void 0===o.split&&(o.split=!0),void 0===o.uvSmooth&&(o.uvSmooth=!1),void 0===o.preserveEdges&&(o.preserveEdges=!1),void 0===o.flatOnly&&(o.flatOnly=!1),void 0===o.maxTriangles&&(o.maxTriangles=1/0),void 0===o.weight&&(o.weight=1),!isNaN(o.weight)&&isFinite(o.weight)||(o.weight=1),o.weight=Math.max(0,Math.min(1,o.weight)),!E(e))return e;let r=e.clone();if(o.split){const e=B.edgeSplit(r);r.dispose(),r=e}for(let i=0;i<t;i++){if(r.attributes.position.count/3<o.maxTriangles){let e;e=o.flatOnly?B.flat(r,o):B.smooth(r,o),r.groups.forEach(t=>{e.addGroup(4*t.start,4*t.count,t.materialIndex)}),r.dispose(),r=e}}return r}static edgeSplit(e){if(!E(e))return e;const t=null!==e.index?e.toNonIndexed():e.clone(),o=new s.BufferGeometry,r=z(t),i=t.attributes.position.count,n=t.getAttribute("position"),a=t.getAttribute("normal"),l={},f=[],h={},g=[];for(let s=0;s<i;s+=3){p.fromBufferAttribute(n,s+0),m.fromBufferAttribute(n,s+1),v.fromBufferAttribute(n,s+2),d.fromBufferAttribute(a,s);const e=T(p),t=T(m),o=T(v),r=S.set(p,m,v).getArea();if(g.push(!x(r,0)),!g[s/3]){f.push([]);continue}_(d,p,m,v);const i=T(d),u=[`${e}_${t}_${i}`,`${t}_${e}_${i}`,`${t}_${o}_${i}`,`${o}_${t}_${i}`,`${o}_${e}_${i}`,`${e}_${o}_${i}`],c=s/3;for(let n=0;n<u.length;n++)l[u[n]]||(l[u[n]]=[]),l[u[n]].push(c),h[u[n]]||(0!==n&&1!==n||(h[u[n]]=p.distanceTo(m)),2!==n&&3!==n||(h[u[n]]=m.distanceTo(v)),4!==n&&5!==n||(h[u[n]]=v.distanceTo(p)));f.push([u[0],u[2],u[4]])}r.forEach(e=>{const r=t.getAttribute(e);if(!r)return;const i=w(r,e);o.setAttribute(e,new s.BufferAttribute(i,r.itemSize))});const b=t.morphAttributes;for(const u in b){const e=[],t=b[u];for(let o=0,r=t.length;o<r;o++){if(t[o].count!==i)continue;const r=w(t[o],u,!0);e.push(new s.BufferAttribute(r,t[o].itemSize))}o.morphAttributes[u]=e}return o.morphTargetsRelative=t.morphTargetsRelative,t.dispose(),o;function w(e,r,n=!1){const a=i*e.itemSize*4,s=new e.array.constructor(a),d="position"===r&&!n&&t.groups.length>0;let b,w,y=0,S=0,B=e.itemSize;for(let M=0;M<i;M+=3){if(!g[M/3]){S+=3;continue}p.fromBufferAttribute(e,M+0),m.fromBufferAttribute(e,M+1),v.fromBufferAttribute(e,M+2);const r=M/3,i=f[r][0],n=f[r][1],a=f[r][2],A=l[i].length,x=l[n].length,T=l[a].length,V=3*y/B/3;if(0===A+x+T-3)$(s,y,B,p,m,v),y+=3*B;else{const e=h[i],t=h[n],o=h[a];(e>t||x<=1)&&(e>o||T<=1)&&A>1?(u.copy(p).add(m).divideScalar(2),T>1?(c.copy(v).add(p).divideScalar(2),$(s,y,B,p,u,c),y+=3*B,$(s,y,B,u,v,c),y+=3*B):($(s,y,B,p,u,v),y+=3*B),x>1?(c.copy(m).add(v).divideScalar(2),$(s,y,B,u,m,c),y+=3*B,$(s,y,B,c,v,u),y+=3*B):($(s,y,B,m,v,u),y+=3*B)):(t>o||T<=1)&&x>1?(u.copy(m).add(v).divideScalar(2),A>1?(c.copy(p).add(m).divideScalar(2),$(s,y,B,u,c,m),y+=3*B,$(s,y,B,c,u,p),y+=3*B):($(s,y,B,m,u,p),y+=3*B),T>1?(c.copy(v).add(p).divideScalar(2),$(s,y,B,u,v,c),y+=3*B,$(s,y,B,c,p,u),y+=3*B):($(s,y,B,v,p,u),y+=3*B)):T>1?(u.copy(v).add(p).divideScalar(2),x>1?(c.copy(m).add(v).divideScalar(2),$(s,y,B,v,u,c),y+=3*B,$(s,y,B,u,m,c),y+=3*B):($(s,y,B,v,u,m),y+=3*B),A>1?(c.copy(p).add(m).divideScalar(2),$(s,y,B,p,c,u),y+=3*B,$(s,y,B,c,m,u),y+=3*B):($(s,y,B,p,m,u),y+=3*B)):($(s,y,B,p,m,v),y+=3*B)}d&&t.groups.forEach(e=>{e.start===M-S&&(void 0!==b&&void 0!==w&&o.addGroup(b,V-b,w),b=V,w=e.materialIndex)}),S=0}const A=3*y/B,x=new e.array.constructor(A);for(let t=0;t<A;t++)x[t]=s[t];return d&&void 0!==b&&void 0!==w&&o.addGroup(b,3*y/B/3-b,w),x}}static flat(e,t={}){if(!E(e))return e;const o=null!==e.index?e.toNonIndexed():e.clone(),r=new s.BufferGeometry,i=z(o),n=o.attributes.position.count;i.forEach(e=>{const i=o.getAttribute(e);i&&r.setAttribute(e,B.flatAttribute(i,n,t))});const a=o.morphAttributes;for(const s in a){const e=[],o=a[s];for(let r=0,i=o.length;r<i;r++)o[r].count===n&&e.push(B.flatAttribute(o[r],n,t));r.morphAttributes[s]=e}return r.morphTargetsRelative=o.morphTargetsRelative,o.dispose(),r}static flatAttribute(e,t,o={}){const r=t*e.itemSize*4,i=new e.array.constructor(r);let n=0,a=e.itemSize;for(let s=0;s<t;s+=3)p.fromBufferAttribute(e,s+0),m.fromBufferAttribute(e,s+1),v.fromBufferAttribute(e,s+2),h.copy(p).add(m).divideScalar(2),g.copy(m).add(v).divideScalar(2),b.copy(v).add(p).divideScalar(2),$(i,n,a,p,h,b),n+=3*a,$(i,n,a,m,g,h),n+=3*a,$(i,n,a,v,b,g),n+=3*a,$(i,n,a,h,g,b),n+=3*a;return new s.BufferAttribute(i,e.itemSize)}static smooth(e,t={}){if("object"!=typeof t&&(t={}),void 0===t.uvSmooth&&(t.uvSmooth=!1),void 0===t.preserveEdges&&(t.preserveEdges=!1),!E(e))return e;const o=null!==e.index?e.toNonIndexed():e.clone(),r=B.flat(o,t),i=new s.BufferGeometry,n=z(o),a=o.attributes.position.count,u=o.getAttribute("position"),c=r.getAttribute("position"),d={},p={},m={},v={};function S(e,t,o){p[e]||(p[e]={}),p[e][t]||(p[e][t]=[]),p[e][t].push(o)}function A(e,t){m[e]||(m[e]=[]),m[e].push(t)}function x(e,t){v[e]||(v[e]=new Set),v[e].add(t)}for(let s=0;s<a;s+=3){const e=T(y[0].fromBufferAttribute(u,s+0)),t=T(y[1].fromBufferAttribute(u,s+1)),o=T(y[2].fromBufferAttribute(u,s+2));S(e,t,s+1),S(e,o,s+2),S(t,e,s+0),S(t,o,s+2),S(o,e,s+0),S(o,t,s+1),h.copy(y[0]).add(y[1]).divideScalar(2),g.copy(y[1]).add(y[2]).divideScalar(2),b.copy(y[2]).add(y[0]).divideScalar(2);const r=T(h),i=T(g),n=T(b);A(r,s+2),A(i,s+0),A(n,s+1),x(e,r),x(e,n),x(t,r),x(t,i),x(o,i),x(o,n)}for(let s=0;s<r.attributes.position.count;s++){const e=T(f.fromBufferAttribute(c,s));d[e]||(d[e]=[]),d[e].push(s)}n.forEach(e=>{const t=o.getAttribute(e),n=r.getAttribute(e);if(void 0===t||void 0===n)return;const a=_(e,t,n);i.setAttribute(e,new s.BufferAttribute(a,n.itemSize))});const M=o.morphAttributes;for(const l in M){const e=[],o=M[l];for(let r=0,i=o.length;r<i;r++){if(o[r].count!==a)continue;const i=o[r],n=B.flatAttribute(o[r],o[r].count,t),u=_(l,i,n);e.push(new s.BufferAttribute(u,n.itemSize))}i.morphAttributes[l]=e}return i.morphTargetsRelative=o.morphTargetsRelative,r.dispose(),o.dispose(),i;function _(e,o,i){const n=r.attributes.position.count*i.itemSize,a=new o.array.constructor(n);let s=0;for(let u=0;u<r.attributes.position.count;u+=3){for(let r=0;r<3;r++)if("uv"!==e||t.uvSmooth)if("normal"===e){w[r].fromBufferAttribute(c,u+r);const e=T(w[r]),t=d[e],o=Object.keys(t).length,n=.75/o,a=1-n*o;y[r].fromBufferAttribute(i,u+r),y[r].multiplyScalar(a),t.forEach(e=>{l.fromBufferAttribute(i,e),l.multiplyScalar(n),y[r].add(l)})}else{y[r].fromBufferAttribute(i,u+r),w[r].fromBufferAttribute(c,u+r);const e=T(w[r]),n=p[e],a=m[e];if(n){if(t.preserveEdges){const t=v[e];let o=!0;for(const e of t)m[e].length%2!=0&&(o=!1);if(!o)continue}const i=Object.keys(n).length,a=V(1/i/i,1/i*(5/8-Math.pow(3/8+1/4*Math.cos(2*Math.PI/i),2)),t.weight),s=1-a*i;y[r].multiplyScalar(s);for(let e in n){const t=n[e];l.set(0,0,0);for(let e=0;e<t.length;e++)l.add(f.fromBufferAttribute(o,t[e]));l.divideScalar(t.length),l.multiplyScalar(a),y[r].add(l)}}else if(a&&2===a.length){const e=a.length,t=.125,i=1-t*e;y[r].multiplyScalar(i),a.forEach(e=>{l.fromBufferAttribute(o,e),l.multiplyScalar(t),y[r].add(l)})}}else y[r].fromBufferAttribute(i,u+r);$(a,s,i.itemSize,y[0],y[1],y[2]),s+=3*i.itemSize}return a}}}const A=Math.pow(10,2);function x(e,t,o=1e-5){return e<t+o&&e>t-o}function M(e,t=A){let o=(r=e*t)+(r>0?.5:-.5)|0;var r;return 0==o&&(o=0),`${o}`}function T(e,t=A){return`${M(e.x,t)},${M(e.y,t)},${M(e.z,t)}`}function V(e,t,o){return(1-o)*e+o*t}function _(e,t,o,r){f.subVectors(t,o),e.subVectors(o,r),e.cross(f).normalize()}function z(e){const t=Object.keys(e.attributes);return Array.from(new Set(["position","normal","uv"].concat(t)))}function $(e,t,o,r,i,n){o>=1&&(e[t+0+0*o]=r.x,e[t+0+1*o]=i.x,e[t+0+2*o]=n.x),o>=2&&(e[t+1+0*o]=r.y,e[t+1+1*o]=i.y,e[t+1+2*o]=n.y),o>=3&&(e[t+2+0*o]=r.z,e[t+2+1*o]=i.z,e[t+2+2*o]=n.z),o>=4&&(e[t+3+0*o]=r.w,e[t+3+1*o]=i.w,e[t+3+2*o]=n.w)}function E(e){return void 0===e?(console.warn("LoopSubdivision: Geometry provided is undefined"),!1):e.isBufferGeometry?void 0===e.attributes.position?(console.warn("LoopSubdivision: Geometry provided missing required 'position' attribute"),!1):(void 0===e.attributes.normal&&e.computeVertexNormals(),!0):(console.warn("LoopSubdivision: Geometry provided is not 'BufferGeometry' type"),!1)}const{defineComponent:N}=await e("vue"),{normalizeProps:k,guardReactiveProps:C,createElementVNode:G,openBlock:j,createElementBlock:R}=await e("vue"),F=["scale"],I=await e("three"),{ref:O,watchEffect:P,watch:L}=await e("vue"),D=N({__name:"shineShader",props:{srcMesh:{},scale:{default:1.2},color:{default:"#ffff00"},subdivision:{type:Boolean,default:!0},c:{default:1.1},p:{default:1.4},side:{default:I.FrontSide},blending:{default:I.AdditiveBlending}},setup(e){const r=e,i=O(),n={uniforms:{c:{type:"f",value:r.c},p:{type:"f",value:r.p},glowColor:{type:"c",value:new I.Color(r.color)},viewVector:{type:"v3",value:{x:0,y:0,z:0}}},vertexShader:"\n          uniform vec3 viewVector;\n          uniform float c;\n          uniform float p;\n          varying float intensity;\n          void main() {\n            vec3 vNormal = normalize( normalMatrix * normal);\n            vec3 vNormel = normalize( normalMatrix * viewVector);\n            intensity = pow( c - dot(vNormal, vNormel), p );\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0);\n          }\n            ",fragmentShader:"\n          uniform vec3 glowColor;\n          varying float intensity;\n          void main() \n          {\n          \tvec3 glow = glowColor * intensity;\n\t\t\t\t\t\tif(intensity < 1.0){\n            \tgl_FragColor = vec4( glow, 1.0 );\n\t\t\t\t\t\t}\n          }\n        ",side:r.side,transparent:!0,depthWrite:!1,depthTest:!0,blending:r.blending};P(()=>{if(r.srcMesh&&i.value&&!i.value.geometry.attributes.position){let e=r.srcMesh.geometry.clone();r.subdivision&&(e=B.modify(e,2)),i.value.geometry=e,i.value.position.copy(r.srcMesh.position)}r.color&&(n.uniforms.glowColor.value=new I.Color(r.color)),r.c&&(n.uniforms.c.value=r.c),r.p&&(n.uniforms.p.value=r.p)}),L(()=>r.subdivision,e=>{let t=r.srcMesh.geometry.clone();e&&(t=B.modify(t,2)),i.value.geometry=t}),L(()=>r.side,e=>{i.value.material.side=e}),L(()=>r.blending,e=>{i.value.material.blending=e});const{onRender:a}=t(),{camera:s}=o();return a(()=>{s.value&&i.value&&(n.uniforms.viewVector.value=(new I.Vector3).subVectors(s.value.position,i.value.position))}),(e,t)=>(j(),R("TresMesh",{ref_key:"TSGref",ref:i,scale:r.scale},[G("TresShaderMaterial",k(C(n)),null,16)],8,F))}}),{defineComponent:q}=await e("vue"),{createElementVNode:H,unref:W,createVNode:J,withCtx:K,mergeProps:Q,openBlock:U,createBlock:X,createCommentVNode:Y,resolveComponent:Z}=await e("vue"),ee=["map"],te=["map"],oe=await e("three"),{reactive:re,ref:ie}=await e("vue"),ne=q({__name:"shader",setup(e){const t={clearColor:"#222"},o=ie(),s=ie(),l=ie(),u=re({scale:1.6,color:"#00dfff",subdivision:!0,c:1.1,p:1.4,side:oe.FrontSide,blending:oe.AdditiveBlending}),c=new a({title:"参数",expanded:!0});return c.addBinding(u,"color",{label:"颜色"}),c.addBinding(u,"scale",{label:"大小",min:1,max:3,step:.2}),c.addBinding(u,"subdivision",{label:"边缘处理"}),c.addBinding(u,"c",{label:"c",min:0,max:2,step:.1}),c.addBinding(u,"p",{label:"p",min:0,max:8,step:.2}),c.addBinding(u,"side",{options:{FrontSide:oe.FrontSide,BackSide:oe.BackSide,DoubleSide:oe.DoubleSide}}),c.addBinding(u,"blending",{options:{AdditiveBlending:oe.AdditiveBlending,NormalBlending:oe.NormalBlending}}),(e,a)=>{const c=Z("TresCanvas");return U(),X(c,Q(t,{"window-size":""}),{default:K(()=>[a[2]||(a[2]=H("TresPerspectiveCamera",{position:[5,5,5]},null,-1)),a[3]||(a[3]=H("TresAmbientLight",{intensity:1},null,-1)),J(W(r)),a[4]||(a[4]=H("TresGridHelper",{args:[10,10]},null,-1)),J(W(i),{path:"./plugins/earthSample/image/earthA/earth.jpg"},{default:K(({state:e})=>[H("TresMesh",{ref_key:"TresMeshRefA",ref:o,position:[-2,1,0]},[a[0]||(a[0]=H("TresSphereGeometry",{args:[1,32,16]},null,-1)),H("TresMeshBasicMaterial",{map:e},null,8,ee)],512)]),_:1}),J(D,Q({srcMesh:o.value},u),null,16,["srcMesh"]),J(W(i),{path:"./logo.png"},{default:K(({state:e})=>[J(W(n),{ref_key:"TreBoxRef",ref:l,args:[1,1,1],position:[2,1,0]},{default:K(()=>[H("TresMeshBasicMaterial",{map:e},null,8,te)]),_:2},1536)]),_:1}),l.value&&l.value.instance?(U(),X(D,Q({key:0,srcMesh:l.value.instance},u),null,16,["srcMesh"])):Y("",!0),H("TresMesh",{ref_key:"TresMeshRefB",ref:s,position:[0,1,-2]},[...a[1]||(a[1]=[H("TresBoxGeometry",{args:[1,1,1,1,1]},null,-1),H("TresMeshBasicMaterial",{color:"#0ff"},null,-1)])],512),J(D,Q({srcMesh:s.value},u),null,16,["srcMesh"])]),_:1},16)}}});export{ne as default};
