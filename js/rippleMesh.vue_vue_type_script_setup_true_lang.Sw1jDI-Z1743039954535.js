import{_ as t,C as n}from"./three.XuMWWlrU1743039954535.js";import{e as o}from"./@tresjs.05J-Im0t1743039954535.js";import{g as e}from"./utils.PeWXTIGY1743039954535.js";import{d as r,b as i,a2 as s,w as c,o as a,H as u,N as l,u as f,aj as p,ak as v}from"./@vue.C4dqouNn1743039954535.js";const m=h;!function(t,n){const o=h,e=y();for(;;)try{if(246447===parseInt(o(547))/1*(parseInt(o(512))/2)+-parseInt(o(523))/3+parseInt(o(521))/4+-parseInt(o(531))/5+parseInt(o(530))/6*(-parseInt(o(501))/7)+-parseInt(o(502))/8*(-parseInt(o(516))/9)+parseInt(o(508))/10)break;e.push(e.shift())}catch(r){e.push(e.shift())}}();const d=function(){let t=!0;return function(n,o){const e=t?function(){if(o){const t=o[h(509)](n,arguments);return o=null,t}}:function(){};return t=!1,e}}();function y(){const t=["call",'{}.constructor("return this")( )',"trace","info","warn","gger","log","__proto__","test","console","set","counter","init","7APIbmj","8968cdhZRY","color","ShaderChunk","length","TresMesh","return (function() ","2268170oBmOjl","apply","num","tresMeshRef","4HvvZvs","prototype","\n}\n","fog_vertex","657wEmdDL","DoubleSide","height","pv2","uniforms","1926780tGDWNS","speed","835677qiZBJw","positionSrc","TresShaderMaterial","action","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","stateObject","debu","2585994JKLoLx","913250GvPVRH","function *\\( *\\)","\nprecision lowp float;\nprecision lowp int;\nuniform float time;\nuniform float opacity;\nuniform vec3 color;\nuniform float num;\nuniform float speed;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 fragColor = vec4(0.);\n\tfloat sin = sin((vUv.y - time * speed) * 10. * num);\n\tfloat high = 0.92;\n\tfloat medium = 0.4;\n\tif (sin > high) {\n\t\tfragColor = vec4(mix(vec3(.8, 1., 1.), color, (1. - sin) / (1. - high)), 1.);\n\t} else if(sin > medium) {\n\t\tfragColor = vec4(color, mix(1., 0., 1.-(sin - medium) / (high - medium)));\n\t} else {\n\t\tfragColor = vec4(color, 0.);\n\t}\n\tvec3 fade = mix(color, vec3(0., 0., 0.), vUv.y);\n\tfragColor = mix(fragColor, vec4(fade, 1.), 0.85);\n\tgl_FragColor = vec4(fragColor.rgb, fragColor.a * opacity * (1. - vUv.y));\n}\n","error","\nprecision lowp float;\nprecision lowp int;\n","rippleMesh","opacity","#ffff00","exception","toString","Color","time","while (true) {}","chain","bind","value","174155YXnimB","position","string","uvs","table","constructor"];return(y=function(){return t})()}function h(t,n){const o=y();return h=function(t,n){return o[t-=489]},h(t,n)}!function(){d(this,(function(){const t=h,n=new RegExp(t(532)),o=new RegExp(t(527),"i"),e=_(t(500));n[t(496)](e+t(544))&&o[t(496)](e+"input")?_():e("0")}))()}();const g=function(){let t=!0;return function(n,o){const e=t?function(){if(o){const t=o[h(509)](n,arguments);return o=null,t}}:function(){};return t=!1,e}}();g(void 0,(function(){const t=h;let n;try{n=Function(t(507)+t(489)+");")()}catch(r){n=window}const o=n[t(497)]=n[t(497)]||{},e=[t(494),t(492),t(491),t(534),t(539),t(551),t(490)];for(let i=0;i<e[t(505)];i++){const n=g[t(552)][t(513)][t(545)](g),r=e[i],s=o[r]||n;n[t(495)]=g.bind(g),n[t(540)]=s[t(540)][t(545)](s),o[r]=n}}))();const x=[m(548),"uv"],w=r({__name:m(536),props:{positionSrc:{default:[{x:0,y:0},{x:10,y:10}]},color:{default:m(538)},opacity:{default:.8},height:{default:100},num:{default:8},speed:{default:.15}},setup(r){const d=m,y=r,h=i(),g={side:t[d(517)],transparent:!0,depthWrite:!1,depthTest:!0,vertexShader:d(535)+t[d(504)].fog_pars_vertex+"\nvarying vec2 vUv;\nvoid main() {\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t"+t[d(504)][d(515)]+d(514),fragmentShader:d(533),uniforms:{time:{type:d(519),value:0},color:{type:d(550),value:new n(y[d(503)])},opacity:{type:d(519),value:y[d(537)]},num:{type:d(519),value:y.num},speed:{type:"pv2",value:y.speed}}};let w=null,_=null;function C(t=[],n){const o=d,e=[],r=[];for(let i=0,s=e[o(505)],c=r[o(505)];i<t[o(505)]-1;i++){let o=1,a=t[i],u=t[i+1];e[s++]=a.x,e[s++]=0,e[s++]=a.y,r[c++]=0,r[c++]=0,e[s++]=u.x,e[s++]=0,e[s++]=u.y,r[c++]=1,r[c++]=0,e[s++]=a.x,e[s++]=n,e[s++]=a.y,r[c++]=0,r[c++]=o,e[s++]=a.x,e[s++]=n,e[s++]=a.y,r[c++]=0,r[c++]=o,e[s++]=u.x,e[s++]=0,e[s++]=u.y,r[c++]=1,r[c++]=0,e[s++]=u.x,e[s++]=n,e[s++]=u.y,r[c++]=1,r[c++]=o}w=new Float32Array(e),_=new Float32Array(r)}let{centerPoint:I,points:b}=e(y[d(524)]);C(b,y.height);const{onLoop:j}=o();return j((({delta:t})=>{const n=d;g[n(520)][n(542)][n(546)]+=t})),s((()=>{const n=d;y[n(503)]&&(g.uniforms.color[n(546)]=new(t[n(541)])(y.color)),y.opacity&&(g[n(520)][n(537)].value=y[n(537)]),y.num&&(g.uniforms[n(510)][n(546)]=y[n(510)]),y[n(522)]&&(g[n(520)][n(522)][n(546)]=y.speed),h[n(546)]&&h.value[n(548)][n(498)](I.x,h[n(546)][n(548)].y,I.y)})),c((()=>y[d(524)]),(t=>{const n=d,{centerPoint:o,points:r}=e(t);I=o,b=r,C(b,y[n(518)]),h[n(546)]&&h.value[n(548)].set(I.x,h[n(546)].position.y,I.y)})),(t,n)=>{const o=d;return a(),u(o(506),{renderOrder:2200,ref_key:o(511),ref:h},[l("TresBufferGeometry",{position:[f(w),3],uv:[f(_),2]},null,8,x),l(o(525),p(v(g)),null,16)],512)}}});function _(t){function n(t){const o=h;if(typeof t===o(549))return function(t){}.constructor(o(543)).apply(o(499));1!==(""+t/t)[o(505)]||t%20==0?function(){return!0}[o(552)](o(529)+o(493))[o(553)](o(526)):function(){return!1}[o(552)](o(529)+o(493)).apply(o(528)),n(++t)}try{if(t)return n;n(0)}catch(o){}}export{w as _};
