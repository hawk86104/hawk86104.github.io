import{_ as t}from"./@tresjs.BCHtwiaC1763540743861.js";import{d as e,w as n,H as r,o,J as a,ac as u,ao as i}from"./@vue.Co_gxueH1763540743861.js";import{l as s,f as l}from"./three.rXKzP9fQ1763540743861.js";const c=e({__name:"pointsScan",props:{color:{default:"#FFFFFF"},opacity:{default:1},speed:{default:1}},setup(e){const c=e,v={uniforms:{uTime:{value:0},pointNum:{value:new l(32,16)},uColor:{value:new s(c.color)},uOpacity:{value:c.opacity}},transparent:!0,vertexShader:"\n\t\t\t\t\tvarying vec2 vUv;\n                    void main(){\n\t\t\t\t\t\tvUv=uv;\n\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                    }",fragmentShader:"\n\t\t\t\t\tfloat PI = acos(-1.0);\n                    uniform vec3 uColor;\n                    uniform vec2 pointNum;\n                    uniform float uTime;\n                    varying vec2 vUv;\n\t\t\t\t\tuniform float uOpacity;\n                    void main(){\n\t\t\t\t\t\tvec2 uv = vUv+ vec2(0.0, uTime);\n\t\t\t\t\t\tfloat current = abs(sin(uv.y * PI));\n\t\t\t\t\t\tif(current < sin(0.4714*PI)) {\n\t\t\t\t\t\t\tcurrent=current*0.5;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfloat d = distance(fract(uv * pointNum*2.0), vec2(0.5, 0.5));\n\n\t\t\t\t\t\tif(d > current*0.2 ) {\n\t\t\t\t\t\t\tdiscard;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgl_FragColor =vec4(uColor,current*uOpacity);\n\t\t\t\t\t\t}\n                    }"};n(()=>[c.color,c.opacity],([t,e])=>{v.uniforms.uColor.value=new s(t),v.uniforms.uOpacity.value=e});const{onBeforeRender:m}=t();return m(({delta:t})=>{v.uniforms.uTime.value+=.1*t*c.speed}),(t,e)=>(o(),r("TresMesh",null,[e[0]||(e[0]=a("TresSphereGeometry",{args:[1,32,32]},null,-1)),a("TresShaderMaterial",u(i(v)),null,16)]))}});export{c as _};
