import{be as W,bB as H,cv as V,ct as P,bh as J,ba as v,aQ as K,aD as I,bm as G,bq as O,bi as X,a5 as T,aH as Y,bk as Z,ao as tt,B as et,aa as at,o as F,c as nt,T as st,ad as ot,a6 as it,au as rt,C as R,J as q,ak as lt,a as dt,ac as ct,a1 as ut}from"./vendor.iBV-vwSJ1717643756855.js";import{_ as ft}from"./pagesShow.vue_vue_type_script_setup_true_lang.npo1X2P01717643756855.js";import"./vanilla.iZfocbTj1717643756855.js";import"./object_hash.O7Sw-hlw1717643756855.js";import"./_commonjsHelpers.5-cIlDoe1717643756855.js";import"./_commonjs-dynamic-modules.h-SxKiO41717643756855.js";import"./builtins-300es.Tm_BdSQ71717643756855.js";import"./LineSegments2.tMHX4TFt1717643756855.js";const k=(f,t)=>{"updateRanges"in f?f.updateRanges[0]=t:f.updateRange=t},E=new G,D=new v,U=new O,L=new v,N=new O,S=new v,pt=f=>class extends f{constructor(){super();const t=parseInt(X.replace(/\D+/g,""))>=154?"opaque_fragment":"output_fragment";this.onBeforeCompile=n=>{n.vertexShader="attribute float opacity;\n               varying float vOpacity;\n              "+n.vertexShader.replace("#include <fog_vertex>","#include <fog_vertex>\n                 vOpacity = opacity;\n                "),n.fragmentShader="varying float vOpacity;\n              "+n.fragmentShader.replace("#include <".concat(t,">"),"#include <".concat(t,">\n                 gl_FragColor = vec4(outgoingLight, diffuseColor.a * vOpacity);\n                "))}}};class mt extends W{constructor({limit:t=200,range:n,material:e=K,texture:x,frustumCulled:p=!0}={}){super(),this.name="Clouds",this.ref=this;const o=this,m=new H(1,1),w=new Float32Array(Array.from({length:t},()=>1)),C=new Float32Array(Array.from({length:t},()=>[1,1,1]).flat()),l=new V(w,1);l.setUsage(P),m.setAttribute("opacity",l);const h=pt(e),c=new h;c.map=x,c.transparent=!0,c.depthWrite=!1,c.needsUpdate=!0,this.cloudMaterial=c,this.instance=new J(m,c,t);const i=this.instance;i.matrixAutoUpdate=!1,i.frustumCulled=p,i.instanceColor=new V(C,3),i.instanceColor.setUsage(P),o.add(i);const g=[],b=()=>{const d=g.length;let z=0;for(let y=0;y<this.ref.children.length;y++){const u=this.ref.children[y];u.cloudStateArray&&(z+=u.cloudStateArray.length)}if(d===z)return g;g.length=0;for(let y=0;y<this.ref.children.length;y++){const u=this.ref.children[y];u.cloudStateArray&&g.push(...u.cloudStateArray)}return a(),g},a=()=>{const d=Math.min(t,n!==void 0?n:t,g.length);i.count=d,k(i.instanceMatrix,{offset:0,count:d*16}),i.instanceColor&&k(i.instanceColor,{offset:0,count:d*3}),k(i.geometry.attributes.opacity,{offset:0,count:d})};let B=0,r=0,s;const _=new O,A=new v(0,0,1),M=new v;this.update=(d,z,y)=>{B=z,E.copy(i.matrixWorld).invert(),d.matrixWorld.decompose(L,N,S);const u=b();for(r=0;r<u.length;r++)s=u[r],s.ref.matrixWorld.decompose(D,U,S),D.add(M.copy(s.position).applyQuaternion(U).multiply(S)),U.copy(N).multiply(_.setFromAxisAngle(A,s.rotation+=y*s.rotationFactor)),S.multiplyScalar(s.volume+(1+Math.sin(B*s.density*s.speed))/2*s.growth),s.matrix.compose(D,U,S).premultiply(E),s.dist=D.distanceTo(L);for(u.sort(($,j)=>j.dist-$.dist),r=0;r<u.length;r++)s=u[r],w[r]=s.opacity*(s.dist<s.fade-1?s.dist/s.fade:1),i.setMatrixAt(r,s.matrix),i.setColorAt(r,s.color);i.geometry.attributes.opacity.needsUpdate=!0,i.instanceMatrix.needsUpdate=!0,i.instanceColor&&(i.instanceColor.needsUpdate=!0)}}}let ht=0;class Q extends W{constructor({opacity:t=1,speed:n=0,bounds:e=new v().fromArray([5,1,1]),segments:x=20,color:p=new I("#ffffff"),fade:o=10,volume:m=6,smallestVolume:w=.25,distribute:C=null,growth:l=4,concentrate:h="inside",seed:c=Math.random()}={}){super(),this.name="cloud_"+ht++,this.seed=c,this.segments=x,this.bounds=e,this.concentrate=h,this.volume=m,this.smallestVolume=w,this.distribute=C,this.growth=l,this.speed=n,this.fade=o,this.opacity=t,this.color=p,this.ref=this,this.cloudStateArray=[],this.updateCloud()}updateCloudStateArray(){if(this.cloudStateArray.length===this.segments)return;const{segments:t,uuid:n}=this;if(this.cloudStateArray.length>this.segments)this.cloudStateArray.splice(0,this.cloudStateArray.length-this.segments);else for(let e=this.cloudStateArray.length;e<t;e++)this.cloudStateArray.push({segments:t,bounds:new v(1,1,1),position:new v,uuid:n,index:e,ref:this,dist:0,matrix:new G,volume:0,length:0,speed:0,growth:0,opacity:1,fade:0,density:0,rotation:e*(Math.PI/t),rotationFactor:0,color:new I})}updateCloud(){const{volume:t,color:n,speed:e,growth:x,opacity:p,fade:o,bounds:m,seed:w,cloudStateArray:C,distribute:l,segments:h,concentrate:c,smallestVolume:i}=this;this.updateCloudStateArray();let g=0;function b(){const a=Math.sin(w+g)*1e4;return g++,a-Math.floor(a)}C.forEach((a,B)=>{a.segments=h,a.volume=t,a.color=n,a.speed=e,a.growth=x,a.opacity=p,a.fade=o,a.bounds.copy(m),a.density=Math.max(.5,b()),a.rotationFactor=Math.max(.2,.5*b())*e;const r=l==null?void 0:l(a,B);if(r||h>1){var s;a.position.copy(a.bounds).multiply((s=r==null?void 0:r.point)!==null&&s!==void 0?s:{x:b()*2-1,y:b()*2-1,z:b()*2-1})}const _=Math.abs(a.position.x),A=Math.abs(a.position.y),M=Math.abs(a.position.z),d=Math.max(_,A,M);a.length=1,_===d&&(a.length-=_/a.bounds.x),A===d&&(a.length-=A/a.bounds.y),M===d&&(a.length-=M/a.bounds.z),a.volume=((r==null?void 0:r.volume)!==void 0?r.volume:Math.max(Math.max(0,i),c==="random"?b():c==="inside"?a.length:1-a.length))*t})}}const gt=["object"],yt=T({__name:"cloudsMesh",props:{color:{default:"#ffffff"},segments:{default:20},volume:{default:6},opacity:{default:1},seed:{default:0},fade:{default:10},growth:{default:4},speed:{default:0},bounds:{default:{x:5,y:1,z:1}}},async setup(f){let t,n;const e=f,x=([t,n]=Y(()=>Z(["./plugins/digitalCity/image/cloud.png"])),t=await t,n(),t),p=new mt({texture:x}),o=new Q({color:new I(e.color)});p.add(o);const m=new Q({color:new I("pink")});m.position.set(20,0,10),p.add(m);const{camera:w}=tt(),{onBeforeLoop:C}=ot();return C(({delta:l,elapsed:h})=>{p.update(w.value,h,l)}),et(()=>e.color,l=>{o.color.set(l)}),at(()=>{e.segments&&(o.segments=e.segments),e.volume&&(o.volume=e.volume),e.opacity&&(o.opacity=e.opacity),e.seed&&(o.seed=e.seed),e.fade&&(o.fade=e.fade),e.growth&&(o.growth=e.growth),e.speed&&(o.speed=e.speed),e.bounds&&(o.bounds.x=e.bounds.x,o.bounds.y=e.bounds.y,o.bounds.z=e.bounds.z),o.updateCloud()}),(l,h)=>(F(),nt("primitive",{object:st(p),renderOrder:3e3},null,8,gt))}}),xt=ut("TresDirectionalLight",{position:[200,100,0],intensity:1.5,color:"#ffffff"},null,-1),Bt=T({__name:"clouds2",setup(f){const t=it({color:"#ffffff",segments:20,volume:6,opacity:1,seed:0,fade:10,growth:4,speed:0,bounds:{x:5,y:1,z:1}}),n=new rt({title:"云彩效果",expanded:!0});return n.addBinding(t,"color",{label:"颜色"}),n.addBinding(t,"seed",{label:"seed",min:0,max:100,step:.1}),n.addBinding(t,"segments",{label:"segments",min:1,max:80,step:.1}),n.addBinding(t,"volume",{label:"volume",min:0,max:100,step:.1}),n.addBinding(t,"opacity",{label:"opacity",min:0,max:1,step:.01}),n.addBinding(t,"fade",{label:"fade",min:0,max:4e3,step:10}),n.addBinding(t,"growth",{label:"growth",min:0,max:20,step:.1}),n.addBinding(t,"speed",{label:"speed",min:0,max:1,step:.01}),n.addBinding(t,"bounds",{x:{min:0,max:25},y:{min:0,max:25},z:{min:0,max:25}}),(e,x)=>(F(),R(ft,null,{ability:q(()=>[xt,(F(),R(lt,null,{default:q(()=>[dt(yt,ct({position:[10,200,0],scale:20},t),null,16)]),_:1}))]),_:1}))}});export{Bt as default};
