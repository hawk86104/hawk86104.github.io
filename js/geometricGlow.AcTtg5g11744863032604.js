import{a as e}from"./@tresjs.DDZ0vesk1744863032604.js";import{P as o}from"./tweakpane.C0HtAJSg1744863032604.js";import{d as r,w as n,H as t,o as i,J as a,m as s,u as l,r as c,h as u,e as f,f as m,j as p}from"./@vue.DK6ok9LJ1744863032604.js";import{V as d,C as g,bq as v,a4 as w,cu as y}from"./three.B0XaFSnH1744863032604.js";import"./postprocessing.DMK_Mhe01744863032604.js";import"./@vueuse.aRlY5CPe1744863032604.js";!function(){const e=T,o=M();for(;;)try{if(160374===-parseInt(e(404))/1+parseInt(e(397))/2+parseInt(e(396))/3+-parseInt(e(394))/4+-parseInt(e(419))/5*(-parseInt(e(426))/6)+-parseInt(e(395))/7*(parseInt(e(400))/8)+parseInt(e(401))/9*(parseInt(e(399))/10))break;o.push(o.shift())}catch(r){o.push(o.shift())}}();const C=function(){let e=!0;return function(o,r){const n=e?function(){if(r){const e=r.apply(o,arguments);return r=null,e}}:function(){};return e=!1,n}}();!function(){C(this,(function(){const e=T,o=new RegExp(e(412)),r=new RegExp(e(429),"i"),n=b("init");o[e(398)](n+e(410))&&r.test(n+"input")?b():n("0")}))()}();const h=function(){let e=!0;return function(o,r){const n=e?function(){if(r){const e=r.apply(o,arguments);return r=null,e}}:function(){};return e=!1,n}}();function x(e,o){const r=T;if(!e.isBufferGeometry)return void console.error(r(425));!e[r(406)][r(417)]&&e[r(427)]();const n=e[r(406)].position,t=e[r(406)][r(417)],i=n.array,a=t[r(422)];for(let s=0;s<n[r(407)];s++){const e=3*s;i[e]+=a[e]*o,i[e+1]+=a[e+1]*o,i[e+2]+=a[e+2]*o}n[r(423)]=!0}function M(){const e=["bind","action","715980mlRRWj","7ZlnzXb","579909oLLlCe","261758QylCnE","test","30seVFUs","1255016Qqzwfu","330903gfLisU","length",'{}.constructor("return this")( )',"24820yQHtod","trace","attributes","count","table","toString","chain","stateObject","function *\\( *\\)","__proto__","apply","console","log","normal","info","20615waSmBZ","debu","while (true) {}","array","needsUpdate","constructor","The geometry must be a BufferGeometry.","126hjomap","computeVertexNormals","return (function() ","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)"];return(M=function(){return e})()}function T(e,o){const r=M();return T=function(e,o){return r[e-=394]},T(e,o)}function b(e){function o(e){const r=T;if("string"==typeof e)return function(e){}[r(424)](r(421))[r(414)]("counter");1!==(""+e/e)[r(402)]||e%20==0?function(){return!0}[r(424)](r(420)+"gger").call(r(431)):function(){return!1}[r(424)](r(420)+"gger")[r(414)](r(411)),o(++e)}try{if(e)return o;o(0)}catch(r){}}h(void 0,(function(){const e=T;let o;try{o=Function(e(428)+e(403)+");")()}catch(t){o=window}const r=o.console=o[e(415)]||{},n=[e(416),"warn",e(418),"error","exception",e(408),e(405)];for(let i=0;i<n.length;i++){const o=h[e(424)].prototype[e(430)](h),t=n[i],a=r[t]||o;o[e(413)]=h.bind(h),o[e(409)]=a.toString[e(430)](a),r[t]=o}}))();var V="varying vec3 vVertexWorldPosition;\nvarying vec3 vVertexNormal;\nvarying vec4 vFragColor;\nvoid main() {\n  vVertexNormal = normalize(normalMatrix * normal);\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",P="uniform vec3 glowColor;\nuniform float coeficient;\nuniform float power;\nvarying vec3 vVertexNormal;\nvarying vec3 vVertexWorldPosition;\nvarying vec4 vFragColor;\nvoid main() {\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\n  vec3 viewCameraToVertex = (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\n  viewCameraToVertex = normalize(viewCameraToVertex);\n  float intensity =\n      pow(coeficient + dot(vVertexNormal, viewCameraToVertex), power);\n  gl_FragColor = vec4(glowColor, intensity);\n}";const j=["geometry"],_=["blending","side"],B=["geometry"],I=["blending","side"],z=r({__name:"geometricGlowMesh",props:{geometry:Object,inColor:{default:"hotpink"},outColor:{default:"hotpink"},inPower:{default:1.4},outPower:{default:1.2},inCoeficient:{default:1.1},outCoeficient:{default:.1}},setup(e){const o=e,r=o.geometry.clone();x(r,.01);const c=o.geometry.clone();x(c,.2);const u={uniforms:{coeficient:{value:o.inCoeficient},power:{value:o.inPower},glowColor:{value:new g(o.inColor)},viewVector:{value:new d(0,0,1)}},vertexShader:V,fragmentShader:P},f={uniforms:{coeficient:{value:o.outCoeficient},power:{value:o.outPower},glowColor:{value:new g(o.outColor)},viewVector:{value:new d(0,0,1)}},vertexShader:V,fragmentShader:P};return n((()=>[o.inColor,o.outColor]),(([e,o])=>{u.uniforms.glowColor.value.set(e),f.uniforms.glowColor.value.set(o)})),n((()=>[o.inPower,o.outPower,o.inCoeficient,o.outCoeficient]),(([e,o,r,n])=>{u.uniforms.power.value=e,f.uniforms.power.value=o,u.uniforms.coeficient.value=r,f.uniforms.coeficient.value=n})),(e,o)=>(i(),t("TresGroup",null,[a("TresMesh",{geometry:l(r)},[a("TresShaderMaterial",s(u,{blending:v,transparent:"",depthWrite:!1,side:void 0}),null,16,_)],8,j),a("TresMesh",{geometry:l(c),visible:!0},[a("TresShaderMaterial",s(f,{blending:v,transparent:"",depthWrite:!1,side:w}),null,16,I)],8,B)]))}}),S=["geometry"],N=["geometry"],W=["geometry"],k=["geometry"],G=["geometry"],F=r({__name:"geometricGlow",setup(r){const n=new y(.75,.25,64),t=n.clone();x(t,-.1);const d=n.clone();x(d,.1);const g=c({inColor:"#0078ff",outColor:"#ff00ba",inPower:1.4,outPower:1.2,inCoeficient:1.1,outCoeficient:.1}),v=new o;return v.addBinding(g,"inColor",{label:"内发光色"}),v.addBinding(g,"inPower",{label:"内发光强度",step:.01,min:0,max:4}),v.addBinding(g,"inCoeficient",{step:.01,min:0,max:4}),v.addBinding(g,"outColor",{label:"外发光色"}),v.addBinding(g,"outPower",{label:"外发光强度",step:.01,min:0,max:6}),v.addBinding(g,"outCoeficient",{step:.01,min:0,max:4}),(o,r)=>{const c=u("TresCanvas");return i(),f(c,{"window-size":"",clearColor:"#333333"},{default:m((()=>[r[5]||(r[5]=a("TresPerspectiveCamera",{position:[5,5,5]},null,-1)),p(l(e)),a("TresMesh",{position:[0,1,-4],geometry:l(n)},[r[1]||(r[1]=a("TresMeshNormalMaterial",{transparent:"",opacity:.8},null,-1)),a("TresMesh",{geometry:l(t)},r[0]||(r[0]=[a("TresMeshBasicMaterial",{wireframe:"",color:"#000"},null,-1)]),8,N)],8,S),a("TresMesh",{position:[0,1,4],geometry:l(n)},[r[3]||(r[3]=a("TresMeshNormalMaterial",{transparent:"",opacity:.9},null,-1)),a("TresMesh",{geometry:l(d)},r[2]||(r[2]=[a("TresMeshBasicMaterial",{wireframe:"",color:"#000"},null,-1)]),8,k)],8,W),a("TresMesh",{position:[0,1,0],geometry:l(n),renderOrder:1},[r[4]||(r[4]=a("TresMeshBasicMaterial",{color:"gray"},null,-1)),p(z,s({geometry:l(n)},g),null,16,["geometry"])],8,G),r[6]||(r[6]=a("TresGridHelper",{args:[10,10]},null,-1))])),_:1})}}});export{F as default};
