var I=Object.defineProperty;var y=Object.getOwnPropertySymbols;var C=Object.prototype.hasOwnProperty,N=Object.prototype.propertyIsEnumerable;var g=(t,e,a)=>e in t?I(t,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[e]=a,u=(t,e)=>{for(var a in e||(e={}))C.call(e,a)&&g(t,a,e[a]);if(y)for(var a of y(e))N.call(e,a)&&g(t,a,e[a]);return t};var v=(t,e,a)=>(g(t,typeof e!="symbol"?e+"":e,a),a);import{aG as O,bt as H,aw as G,aH as z,b6 as F,az as R,ax as f,aB as Q,aC as _,aT as M}from"./vendor.3BxC2K2I1713186250808.js";var X=Object.defineProperty,Y=(t,e,a)=>e in t?X(t,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[e]=a,d=(t,e,a)=>(Y(t,typeof e!="symbol"?e+"":e,a),a);class E{constructor(e){d(this,"camera",new O(-1,1,1,-1,0,1)),d(this,"geometry",new H(2,2)),d(this,"mesh"),this.mesh=new G(this.geometry,e)}get material(){return this.mesh.material}set material(e){this.mesh.material=e}dispose(){this.mesh.geometry.dispose()}render(e){e.render(this.mesh,this.camera)}}const W={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","	vUv = uv;","	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","	vec4 texel = texture2D( tDiffuse, vUv );","	gl_FragColor = opacity * texel;","}"].join("\n")},k='\n\n	// Without original size argument for power of two targets\n	vec4 packedTexture2DLOD( sampler2D tex, vec2 uv, int level ) {\n\n		// the fraction of the uv space used by the target mip\n		float targetSubview = 1.0 / pow( 2.0, float( level ) );\n		float widthRatio = 2.0 / 3.0;\n		vec2 scaledDimensions = vec2( targetSubview * widthRatio, targetSubview );\n\n		// all levels > 0 are on the right third of the texture\n		// y is offset from the bottom\n		vec2 offset = vec2(\n			level > 0 ? widthRatio : 0.0,\n			level > 0 ? targetSubview : 0.0\n		);\n\n		vec2 samplePoint = mix( offset, offset + scaledDimensions, uv );\n		return texture2D( tex, samplePoint );\n\n	}\n\n	vec4 packedTexture2DLOD( sampler2D tex, vec2 uv, float level ) {\n\n		float ratio = mod( level, 1.0 );\n		int minLevel = int( floor( level ) );\n		int maxLevel = int( ceil( level ) );\n\n		vec4 minValue = packedTexture2DLOD( tex, uv, minLevel );\n		vec4 maxValue = packedTexture2DLOD( tex, uv, maxLevel );\n\n		return mix( minValue, maxValue, ratio );\n\n	}\n\n	// With original size argument\n	vec4 packedTexture2DLOD( sampler2D tex, vec2 uv, int level, vec2 originalPixelSize ) {\n\n		float floatLevel = float( level );\n		vec2 atlasSize;\n		atlasSize.x = floor( originalPixelSize.x * 1.5 );\n		atlasSize.y = originalPixelSize.y;\n\n		// we stop making mip maps when one dimension == 1\n		float maxLevel = min( floor( log2( originalPixelSize.x ) ), floor( log2( originalPixelSize.y ) ) );\n		floatLevel = min( floatLevel, maxLevel );\n\n		// use inverse pow of 2 to simulate right bit shift operator\n		vec2 currentPixelDimensions = floor( originalPixelSize / pow( 2.0, floatLevel ) );\n		vec2 pixelOffset = vec2(\n			floatLevel > 0.0 ? originalPixelSize.x : 0.0,\n			floatLevel > 0.0 ? currentPixelDimensions.y : 0.0\n		);\n\n		// "minPixel / atlasSize" samples the top left piece of the first pixel\n		// "maxPixel / atlasSize" samples the bottom right piece of the last pixel\n		vec2 minPixel = pixelOffset;\n		vec2 maxPixel = pixelOffset + currentPixelDimensions;\n		vec2 samplePoint = mix( minPixel, maxPixel, uv );\n		samplePoint /= atlasSize;\n\n		vec2 halfPixelSize = 1.0 / ( 2.0 * atlasSize );\n		samplePoint = min( samplePoint, maxPixel / atlasSize - halfPixelSize );\n		samplePoint = max( samplePoint, minPixel / atlasSize + halfPixelSize );\n\n		return texture2D( tex, samplePoint );\n\n	}\n\n	vec4 packedTexture2DLOD( sampler2D tex, vec2 uv, float level, vec2 originalPixelSize ) {\n\n		float ratio = mod( level, 1.0 );\n		int minLevel = int( floor( level ) );\n		int maxLevel = int( ceil( level ) );\n\n		vec4 minValue = packedTexture2DLOD( tex, uv, minLevel, originalPixelSize );\n		vec4 maxValue = packedTexture2DLOD( tex, uv, maxLevel, originalPixelSize );\n\n		return mix( minValue, maxValue, ratio );\n\n	}\n\n';function c(t){const e=u({},t);return"defines"in t&&(e.defines=u({},t.defines)),"uniforms"in t&&(e.uniforms=F.clone(t.uniforms)),e}const j={defines:{X_IS_EVEN:1,Y_IS_EVEN:1},uniforms:{map:{value:null},originalMapSize:{value:new z},parentMapSize:{value:new z},parentLevel:{value:0}},vertexShader:"\n		varying vec2 vUv;\n		void main() {\n\n			#include <begin_vertex>\n			#include <project_vertex>\n			vUv = uv;\n\n		}\n	",fragmentShader:"\n		varying vec2 vUv;\n		uniform sampler2D map;\n		uniform int parentLevel;\n		uniform vec2 parentMapSize;\n		uniform vec2 originalMapSize;\n\n		".concat(k,"\n\n		#if X_IS_EVEN && Y_IS_EVEN\n\n		#define SAMPLES 4\n		#define WIDTH 2\n		#define HEIGHT 2\n\n		#elif X_IS_EVEN\n\n		#define SAMPLES 6\n		#define WIDTH 2\n		#define HEIGHT 3\n\n		#elif Y_IS_EVEN\n\n		#define SAMPLES 6\n		#define WIDTH 3\n		#define HEIGHT 2\n\n		#else\n\n		#define SAMPLES 9\n		#define WIDTH 3\n		#define HEIGHT 3\n\n		#endif\n\n		vec4 sampleAt( vec2 uv ) {\n\n			return packedTexture2DLOD( map, uv, parentLevel, originalMapSize );\n\n		}\n\n		void main() {\n\n			vec2 childMapSize = parentMapSize / 2.0;\n			// vec2 childPixelSize = 1.0 / childMapSize;\n			// vec2 halfChildPixelSize = childPixelSize / 2.0;\n			vec2 childPixelPos = floor( vUv * childMapSize );\n\n			vec2 parentPixelSize = 1.0 / parentMapSize;\n			vec2 halfParentPixelSize = parentPixelSize / 2.0;\n			vec2 parentPixelPos = childPixelPos * 2.0;\n\n			vec2 baseUv = ( parentPixelPos / parentMapSize ) + halfParentPixelSize;\n\n			vec4 samples[ SAMPLES ];\n			float weights[ SAMPLES ];\n\n			#if X_IS_EVEN && Y_IS_EVEN\n\n			samples[ 0 ] = sampleAt( baseUv );\n			samples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );\n			samples[ 2 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );\n			samples[ 3 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );\n\n			weights[ 0 ] = 0.25;\n			weights[ 1 ] = 0.25;\n			weights[ 2 ] = 0.25;\n			weights[ 3 ] = 0.25;\n\n			#elif X_IS_EVEN\n\n			float wx0 = 0.5;\n			float wx1 = 0.5;\n\n			float yden = 2.0 * parentMapSize.y + 1.0;\n			float wy0 = ( parentMapSize.y - parentPixelPos.y ) / yden;\n			float wy1 = ( parentMapSize.y ) / yden;\n			float wy2 = ( parentPixelPos.y + 1.0 ) / yden;\n\n			samples[ 0 ] = sampleAt( baseUv );\n			samples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );\n\n			samples[ 2 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );\n			samples[ 3 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );\n\n			samples[ 4 ] = sampleAt( baseUv + vec2( 0.0, 2.0 * parentPixelSize.y ) );\n			samples[ 5 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 2.0 * parentPixelSize.y ) );\n\n			weights[ 0 ] = wx0 * wy0;\n			weights[ 1 ] = wx1 * wy0;\n\n			weights[ 2 ] = wx0 * wy1;\n			weights[ 3 ] = wx1 * wy1;\n\n			weights[ 4 ] = wx0 * wy2;\n			weights[ 5 ] = wx1 * wy2;\n\n			#elif Y_IS_EVEN\n\n			float xden = 2.0 * parentMapSize.x + 1.0;\n			float wx0 = ( parentMapSize.x - parentPixelPos.x ) / xden;\n			float wx1 = ( parentMapSize.x ) / xden;\n			float wx2 = ( parentPixelPos.x + 1.0 ) / xden;\n\n			float wy0 = 0.5;\n			float wy1 = 0.5;\n\n			samples[ 0 ] = sampleAt( baseUv );\n			samples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );\n			samples[ 2 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 0.0 ) );\n\n			samples[ 3 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );\n			samples[ 4 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );\n			samples[ 5 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, parentPixelSize.y ) );\n\n			weights[ 0 ] = wx0 * wy0;\n			weights[ 1 ] = wx1 * wy0;\n			weights[ 2 ] = wx2 * wy0;\n\n			weights[ 3 ] = wx0 * wy1;\n			weights[ 4 ] = wx1 * wy1;\n			weights[ 5 ] = wx2 * wy1;\n\n			#else\n\n			float xden = 2.0 * parentMapSize.x + 1.0;\n			float wx0 = ( parentMapSize.x - parentPixelPos.x ) / xden;\n			float wx1 = ( parentMapSize.x ) / xden;\n			float wx2 = ( parentPixelPos.x + 1.0 ) / xden;\n\n			float yden = 2.0 * parentMapSize.y + 1.0;\n			float wy0 = ( parentMapSize.y - parentPixelPos.y ) / yden;\n			float wy1 = ( parentMapSize.y ) / yden;\n			float wy2 = ( parentPixelPos.y + 1.0 ) / yden;\n\n			samples[ 0 ] = sampleAt( baseUv );\n			samples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );\n			samples[ 2 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 0.0 ) );\n\n			samples[ 3 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );\n			samples[ 4 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );\n			samples[ 5 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, parentPixelSize.y ) );\n\n			samples[ 6 ] = sampleAt( baseUv + vec2( 0.0, 2.0 * parentPixelSize.y ) );\n			samples[ 7 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 2.0 * parentPixelSize.y ) );\n			samples[ 8 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 2.0 * parentPixelSize.y ) );\n\n			weights[ 0 ] = wx0 * wy0;\n			weights[ 1 ] = wx1 * wy0;\n			weights[ 2 ] = wx2 * wy0;\n\n			weights[ 3 ] = wx0 * wy1;\n			weights[ 4 ] = wx1 * wy1;\n			weights[ 5 ] = wx2 * wy1;\n\n			weights[ 6 ] = wx0 * wy2;\n			weights[ 7 ] = wx1 * wy2;\n			weights[ 8 ] = wx2 * wy2;\n\n			#endif\n\n			<mipmap_logic>\n\n		}\n	")},b=new R;class K{constructor(e){v(this,"_swapTarget");v(this,"_copyQuad");v(this,"_mipQuad");v(this,"_mipMaterials");e||(e="\n\n				#pragma unroll_loop\n				for ( int i = 0; i < SAMPLES; i ++ ) {\n\n					gl_FragColor += samples[ i ] * weights[ i ];\n\n				}\n\n			");const a=c(j);a.fragmentShader=a.fragmentShader.replace(/<mipmap_logic>/g,e);const i=new Array(4);i[0]=new f(c(a)),i[0].defines.X_IS_EVEN=0,i[0].defines.Y_IS_EVEN=0,i[1]=new f(c(a)),i[1].defines.X_IS_EVEN=1,i[1].defines.Y_IS_EVEN=0,i[2]=new f(c(a)),i[2].defines.X_IS_EVEN=0,i[2].defines.Y_IS_EVEN=1,i[3]=new f(c(a)),i[3].defines.X_IS_EVEN=1,i[3].defines.Y_IS_EVEN=1;const m=new Q;m.texture.minFilter=_,m.texture.magFilter=_,this._swapTarget=m,this._copyQuad=new E(new f(W)),this._mipQuad=new E(null),this._mipMaterials=i}update(e,a,i,m=!1){e.isWebGLRenderTarget&&(e=e.texture);const A=i.autoClear,D=i.getClearAlpha(),L=i.getRenderTarget();i.getClearColor(b);const w=this._copyQuad,S=this._mipQuad,l=this._swapTarget,U=this._mipMaterials;let s,o;m?(s=M.floorPowerOfTwo(e.image.width),o=M.floorPowerOfTwo(e.image.height)):(s=Math.floor(e.image.width),o=Math.floor(e.image.height));const h=Math.floor(s*1.5),x=Math.floor(o);a.setSize(h,x),l.texture.type!==a.texture.type?(l.dispose(),l.copy(a),l.texture.image=u({},l.texture.image)):l.setSize(h,x),i.autoClear=!1,i.setClearColor(0),i.setClearAlpha(),w.material.uniforms.tDiffuse.value=e,w.camera.setViewOffset(s,o,0,0,h,x),i.setRenderTarget(a),i.clear(),w.render(i),i.setRenderTarget(l),i.clear(),w.render(i);let r=s,n=o,P=0;for(;r>1&&n>1;){const T=(r%2===0?1:0)|(n%2===0?2:0),p=U[T];p.uniforms.map.value=l.texture,p.uniforms.parentLevel.value=P,p.uniforms.parentMapSize.value.set(r,n),p.uniforms.originalMapSize.value.set(s,o),S.material=p,r=Math.floor(r/2),n=Math.floor(n/2);const V=x-2*n;i.setRenderTarget(a),S.camera.setViewOffset(r,n,-s,-V,h,x),S.render(i),i.setRenderTarget(l),p.uniforms.map.value=a.texture,S.render(i),P++}return i.setRenderTarget(L),i.setClearAlpha(D),i.setClearColor(b),i.autoClear=A,P+1}dispose(){this._swapTarget.dispose(),this._mipQuad.dispose(),this._copyQuad.dispose(),this._mipMaterials.forEach(e=>e.dispose())}}export{K as P};
