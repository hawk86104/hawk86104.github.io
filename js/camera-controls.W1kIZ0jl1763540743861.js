/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const t=1,e=2,s=4,i=Object.freeze({NONE:0,ROTATE:1,TRUCK:2,SCREEN_PAN:4,OFFSET:8,DOLLY:16,ZOOM:32,TOUCH_ROTATE:64,TOUCH_TRUCK:128,TOUCH_SCREEN_PAN:256,TOUCH_OFFSET:512,TOUCH_DOLLY:1024,TOUCH_ZOOM:2048,TOUCH_DOLLY_TRUCK:4096,TOUCH_DOLLY_SCREEN_PAN:8192,TOUCH_DOLLY_OFFSET:16384,TOUCH_DOLLY_ROTATE:32768,TOUCH_ZOOM_TRUCK:65536,TOUCH_ZOOM_OFFSET:131072,TOUCH_ZOOM_SCREEN_PAN:262144,TOUCH_ZOOM_ROTATE:524288}),o=0,h=1,r=-1;function n(t){return t.isPerspectiveCamera}function a(t){return t.isOrthographicCamera}const l=2*Math.PI,_=Math.PI/2,c=Math.PI/180;function d(t,e,s){return Math.max(e,Math.min(s,t))}function m(t,e=1e-5){return Math.abs(t)<e}function p(t,e,s=1e-5){return m(t-e,s)}function u(t,e){return Math.round(t/e)*e}function O(t){return isFinite(t)?t:t<0?-Number.MAX_VALUE:Number.MAX_VALUE}function E(t){return Math.abs(t)<Number.MAX_VALUE?t:t*(1/0)}function T(t,e,s,i,o=1/0,h){const r=2/(i=Math.max(1e-4,i)),n=r*h,a=1/(1+n+.48*n*n+.235*n*n*n);let l=t-e;const _=e,c=o*i;l=d(l,-c,c),e=t-l;const m=(s.value+r*l)*h;s.value=(s.value-r*m)*a;let p=e+(l+m)*a;return _-t>0==p>_&&(p=_,s.value=(p-_)/h),p}function g(t,e,s,i,o=1/0,h,r){const n=2/(i=Math.max(1e-4,i)),a=n*h,l=1/(1+a+.48*a*a+.235*a*a*a);let _=e.x,c=e.y,d=e.z,m=t.x-_,p=t.y-c,u=t.z-d;const O=_,E=c,T=d,g=o*i,y=m*m+p*p+u*u;if(y>g*g){const t=Math.sqrt(y);m=m/t*g,p=p/t*g,u=u/t*g}_=t.x-m,c=t.y-p,d=t.z-u;const f=(s.x+n*m)*h,C=(s.y+n*p)*h,U=(s.z+n*u)*h;s.x=(s.x-n*f)*l,s.y=(s.y-n*C)*l,s.z=(s.z-n*U)*l,r.x=_+(m+f)*l,r.y=c+(p+C)*l,r.z=d+(u+U)*l;const v=O-t.x,A=E-t.y,x=T-t.z;return v*(r.x-O)+A*(r.y-E)+x*(r.z-T)>0&&(r.x=O,r.y=E,r.z=T,s.x=(r.x-O)/h,s.y=(r.y-E)/h,s.z=(r.z-T)/h),r}function y(t,e){e.set(0,0),t.forEach(t=>{e.x+=t.clientX,e.y+=t.clientY}),e.x/=t.length,e.y/=t.length}function f(t,e){return!!a(t)&&(console.warn(`${e} is not supported in OrthographicCamera`),!0)}class C{constructor(){this._listeners={}}addEventListener(t,e){const s=this._listeners;void 0===s[t]&&(s[t]=[]),-1===s[t].indexOf(e)&&s[t].push(e)}hasEventListener(t,e){const s=this._listeners;return void 0!==s[t]&&-1!==s[t].indexOf(e)}removeEventListener(t,e){const s=this._listeners[t];if(void 0!==s){const t=s.indexOf(e);-1!==t&&s.splice(t,1)}}removeAllEventListeners(t){t?Array.isArray(this._listeners[t])&&(this._listeners[t].length=0):this._listeners={}}dispatchEvent(t){const e=this._listeners[t.type];if(void 0!==e){t.target=this;const s=e.slice(0);for(let e=0,i=s.length;e<i;e++)s[e].call(this,t)}}}var U;const v=1/8,A=/Mac/.test(null===(U=null===globalThis||void 0===globalThis?void 0:globalThis.navigator)||void 0===U?void 0:U.platform);let x,L,S,D,R,P,z,w,F,H,M,b,N,Y,k,V,Z,B,I,K,X,Q,j;class q extends C{static install(t){x=t.THREE,L=Object.freeze(new x.Vector3(0,0,0)),S=Object.freeze(new x.Vector3(0,1,0)),D=Object.freeze(new x.Vector3(0,0,1)),R=new x.Vector2,P=new x.Vector3,z=new x.Vector3,w=new x.Vector3,F=new x.Vector3,H=new x.Vector3,M=new x.Vector3,b=new x.Vector3,N=new x.Vector3,Y=new x.Vector3,k=new x.Spherical,V=new x.Spherical,Z=new x.Box3,B=new x.Box3,I=new x.Sphere,K=new x.Quaternion,X=new x.Quaternion,Q=new x.Matrix4,j=new x.Raycaster}static get ACTION(){return i}set verticalDragToForward(t){console.warn("camera-controls: `verticalDragToForward` was removed. Use `mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.")}constructor(h,r){super(),this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.minDistance=Number.EPSILON,this.maxDistance=1/0,this.infinityDolly=!1,this.minZoom=.01,this.maxZoom=1/0,this.smoothTime=.25,this.draggingSmoothTime=.125,this.maxSpeed=1/0,this.azimuthRotateSpeed=1,this.polarRotateSpeed=1,this.dollySpeed=1,this.dollyDragInverted=!1,this.truckSpeed=2,this.dollyToCursor=!1,this.dragToOffset=!1,this.boundaryFriction=0,this.restThreshold=.01,this.colliderMeshes=[],this.cancel=()=>{},this._enabled=!0,this._state=i.NONE,this._viewport=null,this._changedDolly=0,this._changedZoom=0,this._hasRested=!0,this._boundaryEnclosesCamera=!1,this._needsUpdate=!0,this._updatedLastTime=!1,this._elementRect=new DOMRect,this._isDragging=!1,this._dragNeedsUpdate=!0,this._activePointers=[],this._lockedPointer=null,this._interactiveArea=new DOMRect(0,0,1,1),this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._isUserControllingOffset=!1,this._isUserControllingZoom=!1,this._lastDollyDirection=o,this._thetaVelocity={value:0},this._phiVelocity={value:0},this._radiusVelocity={value:0},this._targetVelocity=new x.Vector3,this._focalOffsetVelocity=new x.Vector3,this._zoomVelocity={value:0},this._truckInternal=(t,e,s,i)=>{let o,h;if(n(this._camera)){const s=P.copy(this._camera.position).sub(this._target),i=this._camera.getEffectiveFOV()*c,r=s.length()*Math.tan(.5*i);o=this.truckSpeed*t*r/this._elementRect.height,h=this.truckSpeed*e*r/this._elementRect.height}else{if(!a(this._camera))return;{const s=this._camera;o=this.truckSpeed*t*(s.right-s.left)/s.zoom/this._elementRect.width,h=this.truckSpeed*e*(s.top-s.bottom)/s.zoom/this._elementRect.height}}i?(s?this.setFocalOffset(this._focalOffsetEnd.x+o,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(o,0,!0),this.forward(-h,!0)):s?this.setFocalOffset(this._focalOffsetEnd.x+o,this._focalOffsetEnd.y+h,this._focalOffsetEnd.z,!0):this.truck(o,h,!0)},this._rotateInternal=(t,e)=>{const s=l*this.azimuthRotateSpeed*t/this._elementRect.height,i=l*this.polarRotateSpeed*e/this._elementRect.height;this.rotate(s,i,!0)},this._dollyInternal=(t,e,s)=>{const i=Math.pow(.95,-t*this.dollySpeed),o=this._sphericalEnd.radius,h=this._sphericalEnd.radius*i,r=d(h,this.minDistance,this.maxDistance),n=r-h;this.infinityDolly&&this.dollyToCursor?this._dollyToNoClamp(h,!0):this.infinityDolly&&!this.dollyToCursor?(this.dollyInFixed(n,!0),this._dollyToNoClamp(r,!0)):this._dollyToNoClamp(r,!0),this.dollyToCursor&&(this._changedDolly+=(this.infinityDolly?h:r)-o,this._dollyControlCoord.set(e,s)),this._lastDollyDirection=Math.sign(-t)},this._zoomInternal=(t,e,s)=>{const i=Math.pow(.95,t*this.dollySpeed),o=this._zoom,h=this._zoom*i;this.zoomTo(h,!0),this.dollyToCursor&&(this._changedZoom+=h-o,this._dollyControlCoord.set(e,s))},void 0===x&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=h,this._yAxisUpSpace=(new x.Quaternion).setFromUnitVectors(this._camera.up,S),this._yAxisUpSpaceInverse=this._yAxisUpSpace.clone().invert(),this._state=i.NONE,this._target=new x.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new x.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=(new x.Spherical).setFromVector3(P.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._lastDistance=this._spherical.radius,this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._lastZoom=this._zoom,this._nearPlaneCorners=[new x.Vector3,new x.Vector3,new x.Vector3,new x.Vector3],this._updateNearPlaneCorners(),this._boundary=new x.Box3(new x.Vector3(-1/0,-1/0,-1/0),new x.Vector3(1/0,1/0,1/0)),this._cameraUp0=this._camera.up.clone(),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlCoord=new x.Vector2,this.mouseButtons={left:i.ROTATE,middle:i.DOLLY,right:i.TRUCK,wheel:n(this._camera)?i.DOLLY:a(this._camera)?i.ZOOM:i.NONE},this.touches={one:i.TOUCH_ROTATE,two:n(this._camera)?i.TOUCH_DOLLY_TRUCK:a(this._camera)?i.TOUCH_ZOOM_TRUCK:i.NONE,three:i.TOUCH_TRUCK};const _=new x.Vector2,m=new x.Vector2,p=new x.Vector2,u=i=>{if(!this._enabled||!this._domElement)return;if(0!==this._interactiveArea.left||0!==this._interactiveArea.top||1!==this._interactiveArea.width||1!==this._interactiveArea.height){const t=this._domElement.getBoundingClientRect(),e=i.clientX/t.width,s=i.clientY/t.height;if(e<this._interactiveArea.left||e>this._interactiveArea.right||s<this._interactiveArea.top||s>this._interactiveArea.bottom)return}const o="mouse"!==i.pointerType?null:(i.buttons&t)===t?t:(i.buttons&s)===s?s:(i.buttons&e)===e?e:null;if(null!==o){const t=this._findPointerByMouseButton(o);t&&this._disposePointer(t)}if((i.buttons&t)===t&&this._lockedPointer)return;const h={pointerId:i.pointerId,clientX:i.clientX,clientY:i.clientY,deltaX:0,deltaY:0,mouseButton:o};this._activePointers.push(h),this._domElement.ownerDocument.removeEventListener("pointermove",O,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",E),this._domElement.ownerDocument.addEventListener("pointermove",O,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",E),this._isDragging=!0,C(i)},O=i=>{i.cancelable&&i.preventDefault();const o=i.pointerId,h=this._lockedPointer||this._findPointerById(o);if(h){if(h.clientX=i.clientX,h.clientY=i.clientY,h.deltaX=i.movementX,h.deltaY=i.movementY,this._state=0,"touch"===i.pointerType)switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}else(!this._isDragging&&this._lockedPointer||this._isDragging&&(i.buttons&t)===t)&&(this._state=this._state|this.mouseButtons.left),this._isDragging&&(i.buttons&s)===s&&(this._state=this._state|this.mouseButtons.middle),this._isDragging&&(i.buttons&e)===e&&(this._state=this._state|this.mouseButtons.right);U()}},E=t=>{const e=this._findPointerById(t.pointerId);if(!e||e!==this._lockedPointer){if(e&&this._disposePointer(e),"touch"===t.pointerType)switch(this._activePointers.length){case 0:this._state=i.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}else this._state=i.NONE;L()}};let T=-1;const g=t=>{if(!this._domElement)return;if(!this._enabled||this.mouseButtons.wheel===i.NONE)return;if(0!==this._interactiveArea.left||0!==this._interactiveArea.top||1!==this._interactiveArea.width||1!==this._interactiveArea.height){const e=this._domElement.getBoundingClientRect(),s=t.clientX/e.width,i=t.clientY/e.height;if(s<this._interactiveArea.left||s>this._interactiveArea.right||i<this._interactiveArea.top||i>this._interactiveArea.bottom)return}if(t.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===i.ROTATE||this.mouseButtons.wheel===i.TRUCK){const t=performance.now();T-t<1e3&&this._getClientRect(this._elementRect),T=t}const e=A?-1:-3,s=1===t.deltaMode||t.ctrlKey?t.deltaY/e:t.deltaY/(10*e),o=this.dollyToCursor?(t.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,h=this.dollyToCursor?(t.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(this.mouseButtons.wheel){case i.ROTATE:this._rotateInternal(t.deltaX,t.deltaY),this._isUserControllingRotate=!0;break;case i.TRUCK:this._truckInternal(t.deltaX,t.deltaY,!1,!1),this._isUserControllingTruck=!0;break;case i.SCREEN_PAN:this._truckInternal(t.deltaX,t.deltaY,!1,!0),this._isUserControllingTruck=!0;break;case i.OFFSET:this._truckInternal(t.deltaX,t.deltaY,!0,!1),this._isUserControllingOffset=!0;break;case i.DOLLY:this._dollyInternal(-s,o,h),this._isUserControllingDolly=!0;break;case i.ZOOM:this._zoomInternal(-s,o,h),this._isUserControllingZoom=!0}this.dispatchEvent({type:"control"})},f=t=>{if(this._domElement&&this._enabled){if(this.mouseButtons.right===q.ACTION.NONE){const e=t instanceof PointerEvent?t.pointerId:0,s=this._findPointerById(e);return s&&this._disposePointer(s),this._domElement.ownerDocument.removeEventListener("pointermove",O,{passive:!1}),void this._domElement.ownerDocument.removeEventListener("pointerup",E)}t.preventDefault()}},C=o=>{if(!this._enabled)return;y(this._activePointers,R),this._getClientRect(this._elementRect),_.copy(R),m.copy(R);if(this._activePointers.length>=2){const t=R.x-this._activePointers[1].clientX,e=R.y-this._activePointers[1].clientY,s=Math.sqrt(t*t+e*e);p.set(0,s);const i=.5*(this._activePointers[0].clientX+this._activePointers[1].clientX),o=.5*(this._activePointers[0].clientY+this._activePointers[1].clientY);m.set(i,o)}if(this._state=0,o)if("pointerType"in o&&"touch"===o.pointerType)switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}else this._lockedPointer||(o.buttons&t)!==t||(this._state=this._state|this.mouseButtons.left),(o.buttons&s)===s&&(this._state=this._state|this.mouseButtons.middle),(o.buttons&e)===e&&(this._state=this._state|this.mouseButtons.right);else this._lockedPointer&&(this._state=this._state|this.mouseButtons.left);(this._state&i.ROTATE)!==i.ROTATE&&(this._state&i.TOUCH_ROTATE)!==i.TOUCH_ROTATE&&(this._state&i.TOUCH_DOLLY_ROTATE)!==i.TOUCH_DOLLY_ROTATE&&(this._state&i.TOUCH_ZOOM_ROTATE)!==i.TOUCH_ZOOM_ROTATE||(this._sphericalEnd.theta=this._spherical.theta,this._sphericalEnd.phi=this._spherical.phi,this._thetaVelocity.value=0,this._phiVelocity.value=0),(this._state&i.TRUCK)!==i.TRUCK&&(this._state&i.SCREEN_PAN)!==i.SCREEN_PAN&&(this._state&i.TOUCH_TRUCK)!==i.TOUCH_TRUCK&&(this._state&i.TOUCH_SCREEN_PAN)!==i.TOUCH_SCREEN_PAN&&(this._state&i.TOUCH_DOLLY_TRUCK)!==i.TOUCH_DOLLY_TRUCK&&(this._state&i.TOUCH_DOLLY_SCREEN_PAN)!==i.TOUCH_DOLLY_SCREEN_PAN&&(this._state&i.TOUCH_ZOOM_TRUCK)!==i.TOUCH_ZOOM_TRUCK&&(this._state&i.TOUCH_ZOOM_SCREEN_PAN)!==i.TOUCH_DOLLY_SCREEN_PAN||(this._targetEnd.copy(this._target),this._targetVelocity.set(0,0,0)),(this._state&i.DOLLY)!==i.DOLLY&&(this._state&i.TOUCH_DOLLY)!==i.TOUCH_DOLLY&&(this._state&i.TOUCH_DOLLY_TRUCK)!==i.TOUCH_DOLLY_TRUCK&&(this._state&i.TOUCH_DOLLY_SCREEN_PAN)!==i.TOUCH_DOLLY_SCREEN_PAN&&(this._state&i.TOUCH_DOLLY_OFFSET)!==i.TOUCH_DOLLY_OFFSET&&(this._state&i.TOUCH_DOLLY_ROTATE)!==i.TOUCH_DOLLY_ROTATE||(this._sphericalEnd.radius=this._spherical.radius,this._radiusVelocity.value=0),(this._state&i.ZOOM)!==i.ZOOM&&(this._state&i.TOUCH_ZOOM)!==i.TOUCH_ZOOM&&(this._state&i.TOUCH_ZOOM_TRUCK)!==i.TOUCH_ZOOM_TRUCK&&(this._state&i.TOUCH_ZOOM_SCREEN_PAN)!==i.TOUCH_ZOOM_SCREEN_PAN&&(this._state&i.TOUCH_ZOOM_OFFSET)!==i.TOUCH_ZOOM_OFFSET&&(this._state&i.TOUCH_ZOOM_ROTATE)!==i.TOUCH_ZOOM_ROTATE||(this._zoomEnd=this._zoom,this._zoomVelocity.value=0),(this._state&i.OFFSET)!==i.OFFSET&&(this._state&i.TOUCH_OFFSET)!==i.TOUCH_OFFSET&&(this._state&i.TOUCH_DOLLY_OFFSET)!==i.TOUCH_DOLLY_OFFSET&&(this._state&i.TOUCH_ZOOM_OFFSET)!==i.TOUCH_ZOOM_OFFSET||(this._focalOffsetEnd.copy(this._focalOffset),this._focalOffsetVelocity.set(0,0,0)),this.dispatchEvent({type:"controlstart"})},U=()=>{if(!this._enabled||!this._dragNeedsUpdate)return;this._dragNeedsUpdate=!1,y(this._activePointers,R);const t=this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement?this._lockedPointer||this._activePointers[0]:null,e=t?-t.deltaX:m.x-R.x,s=t?-t.deltaY:m.y-R.y;if(m.copy(R),(this._state&i.ROTATE)!==i.ROTATE&&(this._state&i.TOUCH_ROTATE)!==i.TOUCH_ROTATE&&(this._state&i.TOUCH_DOLLY_ROTATE)!==i.TOUCH_DOLLY_ROTATE&&(this._state&i.TOUCH_ZOOM_ROTATE)!==i.TOUCH_ZOOM_ROTATE||(this._rotateInternal(e,s),this._isUserControllingRotate=!0),(this._state&i.DOLLY)===i.DOLLY||(this._state&i.ZOOM)===i.ZOOM){const t=this.dollyToCursor?(_.x-this._elementRect.x)/this._elementRect.width*2-1:0,e=this.dollyToCursor?(_.y-this._elementRect.y)/this._elementRect.height*-2+1:0,o=this.dollyDragInverted?-1:1;(this._state&i.DOLLY)===i.DOLLY?(this._dollyInternal(o*s*v,t,e),this._isUserControllingDolly=!0):(this._zoomInternal(o*s*v,t,e),this._isUserControllingZoom=!0)}if((this._state&i.TOUCH_DOLLY)===i.TOUCH_DOLLY||(this._state&i.TOUCH_ZOOM)===i.TOUCH_ZOOM||(this._state&i.TOUCH_DOLLY_TRUCK)===i.TOUCH_DOLLY_TRUCK||(this._state&i.TOUCH_ZOOM_TRUCK)===i.TOUCH_ZOOM_TRUCK||(this._state&i.TOUCH_DOLLY_SCREEN_PAN)===i.TOUCH_DOLLY_SCREEN_PAN||(this._state&i.TOUCH_ZOOM_SCREEN_PAN)===i.TOUCH_ZOOM_SCREEN_PAN||(this._state&i.TOUCH_DOLLY_OFFSET)===i.TOUCH_DOLLY_OFFSET||(this._state&i.TOUCH_ZOOM_OFFSET)===i.TOUCH_ZOOM_OFFSET||(this._state&i.TOUCH_DOLLY_ROTATE)===i.TOUCH_DOLLY_ROTATE||(this._state&i.TOUCH_ZOOM_ROTATE)===i.TOUCH_ZOOM_ROTATE){const t=R.x-this._activePointers[1].clientX,e=R.y-this._activePointers[1].clientY,s=Math.sqrt(t*t+e*e),o=p.y-s;p.set(0,s);const h=this.dollyToCursor?(m.x-this._elementRect.x)/this._elementRect.width*2-1:0,r=this.dollyToCursor?(m.y-this._elementRect.y)/this._elementRect.height*-2+1:0;(this._state&i.TOUCH_DOLLY)===i.TOUCH_DOLLY||(this._state&i.TOUCH_DOLLY_ROTATE)===i.TOUCH_DOLLY_ROTATE||(this._state&i.TOUCH_DOLLY_TRUCK)===i.TOUCH_DOLLY_TRUCK||(this._state&i.TOUCH_DOLLY_SCREEN_PAN)===i.TOUCH_DOLLY_SCREEN_PAN||(this._state&i.TOUCH_DOLLY_OFFSET)===i.TOUCH_DOLLY_OFFSET?(this._dollyInternal(o*v,h,r),this._isUserControllingDolly=!0):(this._zoomInternal(o*v,h,r),this._isUserControllingZoom=!0)}(this._state&i.TRUCK)!==i.TRUCK&&(this._state&i.TOUCH_TRUCK)!==i.TOUCH_TRUCK&&(this._state&i.TOUCH_DOLLY_TRUCK)!==i.TOUCH_DOLLY_TRUCK&&(this._state&i.TOUCH_ZOOM_TRUCK)!==i.TOUCH_ZOOM_TRUCK||(this._truckInternal(e,s,!1,!1),this._isUserControllingTruck=!0),(this._state&i.SCREEN_PAN)!==i.SCREEN_PAN&&(this._state&i.TOUCH_SCREEN_PAN)!==i.TOUCH_SCREEN_PAN&&(this._state&i.TOUCH_DOLLY_SCREEN_PAN)!==i.TOUCH_DOLLY_SCREEN_PAN&&(this._state&i.TOUCH_ZOOM_SCREEN_PAN)!==i.TOUCH_ZOOM_SCREEN_PAN||(this._truckInternal(e,s,!1,!0),this._isUserControllingTruck=!0),(this._state&i.OFFSET)!==i.OFFSET&&(this._state&i.TOUCH_OFFSET)!==i.TOUCH_OFFSET&&(this._state&i.TOUCH_DOLLY_OFFSET)!==i.TOUCH_DOLLY_OFFSET&&(this._state&i.TOUCH_ZOOM_OFFSET)!==i.TOUCH_ZOOM_OFFSET||(this._truckInternal(e,s,!0,!1),this._isUserControllingOffset=!0),this.dispatchEvent({type:"control"})},L=()=>{y(this._activePointers,R),m.copy(R),this._dragNeedsUpdate=!1,(0===this._activePointers.length||1===this._activePointers.length&&this._activePointers[0]===this._lockedPointer)&&(this._isDragging=!1),0===this._activePointers.length&&this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointermove",O,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",E),this.dispatchEvent({type:"controlend"}))};this.lockPointer=()=>{this._enabled&&this._domElement&&(this.cancel(),this._lockedPointer={pointerId:-1,clientX:0,clientY:0,deltaX:0,deltaY:0,mouseButton:null},this._activePointers.push(this._lockedPointer),this._domElement.ownerDocument.removeEventListener("pointermove",O,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",E),this._domElement.requestPointerLock(),this._domElement.ownerDocument.addEventListener("pointerlockchange",D),this._domElement.ownerDocument.addEventListener("pointerlockerror",z),this._domElement.ownerDocument.addEventListener("pointermove",O,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",E),C())},this.unlockPointer=()=>{var t,e,s;null!==this._lockedPointer&&(this._disposePointer(this._lockedPointer),this._lockedPointer=null),null===(t=this._domElement)||void 0===t||t.ownerDocument.exitPointerLock(),null===(e=this._domElement)||void 0===e||e.ownerDocument.removeEventListener("pointerlockchange",D),null===(s=this._domElement)||void 0===s||s.ownerDocument.removeEventListener("pointerlockerror",z),this.cancel()};const D=()=>{this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement||this.unlockPointer()},z=()=>{this.unlockPointer()};this._addAllEventListeners=t=>{this._domElement=t,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._domElement.addEventListener("pointerdown",u),this._domElement.addEventListener("pointercancel",E),this._domElement.addEventListener("wheel",g,{passive:!1}),this._domElement.addEventListener("contextmenu",f)},this._removeAllEventListeners=()=>{this._domElement&&(this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="",this._domElement.removeEventListener("pointerdown",u),this._domElement.removeEventListener("pointercancel",E),this._domElement.removeEventListener("wheel",g,{passive:!1}),this._domElement.removeEventListener("contextmenu",f),this._domElement.ownerDocument.removeEventListener("pointermove",O,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",E),this._domElement.ownerDocument.removeEventListener("pointerlockchange",D),this._domElement.ownerDocument.removeEventListener("pointerlockerror",z))},this.cancel=()=>{this._state!==i.NONE&&(this._state=i.NONE,this._activePointers.length=0,L())},r&&this.connect(r),this.update(0)}get camera(){return this._camera}set camera(t){this._camera=t,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._domElement&&(t?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect=""))}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(t){this._spherical.radius===t&&this._sphericalEnd.radius===t||(this._spherical.radius=t,this._sphericalEnd.radius=t,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(t){this._spherical.theta===t&&this._sphericalEnd.theta===t||(this._spherical.theta=t,this._sphericalEnd.theta=t,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(t){this._spherical.phi===t&&this._sphericalEnd.phi===t||(this._spherical.phi=t,this._sphericalEnd.phi=t,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(t){this._boundaryEnclosesCamera=t,this._needsUpdate=!0}set interactiveArea(t){this._interactiveArea.width=d(t.width,0,1),this._interactiveArea.height=d(t.height,0,1),this._interactiveArea.x=d(t.x,0,1-this._interactiveArea.width),this._interactiveArea.y=d(t.y,0,1-this._interactiveArea.height)}addEventListener(t,e){super.addEventListener(t,e)}removeEventListener(t,e){super.removeEventListener(t,e)}rotate(t,e,s=!1){return this.rotateTo(this._sphericalEnd.theta+t,this._sphericalEnd.phi+e,s)}rotateAzimuthTo(t,e=!1){return this.rotateTo(t,this._sphericalEnd.phi,e)}rotatePolarTo(t,e=!1){return this.rotateTo(this._sphericalEnd.theta,t,e)}rotateTo(t,e,s=!1){this._isUserControllingRotate=!1;const i=d(t,this.minAzimuthAngle,this.maxAzimuthAngle),o=d(e,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=i,this._sphericalEnd.phi=o,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,s||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const h=!s||p(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&p(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(h)}dolly(t,e=!1){return this.dollyTo(this._sphericalEnd.radius-t,e)}dollyTo(t,e=!1){return this._isUserControllingDolly=!1,this._lastDollyDirection=o,this._changedDolly=0,this._dollyToNoClamp(d(t,this.minDistance,this.maxDistance),e)}_dollyToNoClamp(t,e=!1){const s=this._sphericalEnd.radius;if(this.colliderMeshes.length>=1){const e=this._collisionTest(),i=p(e,this._spherical.radius);if(!(s>t)&&i)return Promise.resolve();this._sphericalEnd.radius=Math.min(t,e)}else this._sphericalEnd.radius=t;this._needsUpdate=!0,e||(this._spherical.radius=this._sphericalEnd.radius);const i=!e||p(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(i)}dollyInFixed(t,e=!1){this._targetEnd.add(this._getCameraDirection(F).multiplyScalar(t)),e||this._target.copy(this._targetEnd);const s=!e||p(this._target.x,this._targetEnd.x,this.restThreshold)&&p(this._target.y,this._targetEnd.y,this.restThreshold)&&p(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(s)}zoom(t,e=!1){return this.zoomTo(this._zoomEnd+t,e)}zoomTo(t,e=!1){this._isUserControllingZoom=!1,this._zoomEnd=d(t,this.minZoom,this.maxZoom),this._needsUpdate=!0,e||(this._zoom=this._zoomEnd);const s=!e||p(this._zoom,this._zoomEnd,this.restThreshold);return this._changedZoom=0,this._createOnRestPromise(s)}pan(t,e,s=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(t,e,s)}truck(t,e,s=!1){this._camera.updateMatrix(),H.setFromMatrixColumn(this._camera.matrix,0),M.setFromMatrixColumn(this._camera.matrix,1),H.multiplyScalar(t),M.multiplyScalar(-e);const i=P.copy(H).add(M),o=z.copy(this._targetEnd).add(i);return this.moveTo(o.x,o.y,o.z,s)}forward(t,e=!1){P.setFromMatrixColumn(this._camera.matrix,0),P.crossVectors(this._camera.up,P),P.multiplyScalar(t);const s=z.copy(this._targetEnd).add(P);return this.moveTo(s.x,s.y,s.z,e)}elevate(t,e=!1){return P.copy(this._camera.up).multiplyScalar(t),this.moveTo(this._targetEnd.x+P.x,this._targetEnd.y+P.y,this._targetEnd.z+P.z,e)}moveTo(t,e,s,i=!1){this._isUserControllingTruck=!1;const o=P.set(t,e,s).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,o,this.boundaryFriction),this._needsUpdate=!0,i||this._target.copy(this._targetEnd);const h=!i||p(this._target.x,this._targetEnd.x,this.restThreshold)&&p(this._target.y,this._targetEnd.y,this.restThreshold)&&p(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(h)}lookInDirectionOf(t,e,s,i=!1){const o=P.set(t,e,s).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);return this.setPosition(o.x,o.y,o.z,i)}fitToBox(t,e,{cover:s=!1,paddingLeft:i=0,paddingRight:o=0,paddingBottom:h=0,paddingTop:r=0}={}){const l=[],c=t.isBox3?Z.copy(t):Z.setFromObject(t);c.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const d=u(this._sphericalEnd.theta,_),m=u(this._sphericalEnd.phi,_);l.push(this.rotateTo(d,m,e));const O=P.setFromSpherical(this._sphericalEnd).normalize(),E=K.setFromUnitVectors(O,D),T=p(Math.abs(O.y),1);T&&E.multiply(X.setFromAxisAngle(S,d)),E.multiply(this._yAxisUpSpaceInverse);const g=B.makeEmpty();z.copy(c.min).applyQuaternion(E),g.expandByPoint(z),z.copy(c.min).setX(c.max.x).applyQuaternion(E),g.expandByPoint(z),z.copy(c.min).setY(c.max.y).applyQuaternion(E),g.expandByPoint(z),z.copy(c.max).setZ(c.min.z).applyQuaternion(E),g.expandByPoint(z),z.copy(c.min).setZ(c.max.z).applyQuaternion(E),g.expandByPoint(z),z.copy(c.max).setY(c.min.y).applyQuaternion(E),g.expandByPoint(z),z.copy(c.max).setX(c.min.x).applyQuaternion(E),g.expandByPoint(z),z.copy(c.max).applyQuaternion(E),g.expandByPoint(z),g.min.x-=i,g.min.y-=h,g.max.x+=o,g.max.y+=r,E.setFromUnitVectors(D,O),T&&E.premultiply(X.invert()),E.premultiply(this._yAxisUpSpace);const y=g.getSize(P),f=g.getCenter(z).applyQuaternion(E);if(n(this._camera)){const t=this.getDistanceToFitBox(y.x,y.y,y.z,s);l.push(this.moveTo(f.x,f.y,f.z,e)),l.push(this.dollyTo(t,e)),l.push(this.setFocalOffset(0,0,0,e))}else if(a(this._camera)){const t=this._camera,i=t.right-t.left,o=t.top-t.bottom,h=s?Math.max(i/y.x,o/y.y):Math.min(i/y.x,o/y.y);l.push(this.moveTo(f.x,f.y,f.z,e)),l.push(this.zoomTo(h,e)),l.push(this.setFocalOffset(0,0,0,e))}return Promise.all(l)}fitToSphere(t,e){const s=[],i="isObject3D"in t?q.createBoundingSphere(t,I):I.copy(t);if(s.push(this.moveTo(i.center.x,i.center.y,i.center.z,e)),n(this._camera)){const t=this.getDistanceToFitSphere(i.radius);s.push(this.dollyTo(t,e))}else if(a(this._camera)){const t=this._camera.right-this._camera.left,o=this._camera.top-this._camera.bottom,h=2*i.radius,r=Math.min(t/h,o/h);s.push(this.zoomTo(r,e))}return s.push(this.setFocalOffset(0,0,0,e)),Promise.all(s)}setLookAt(t,e,s,i,h,r,n=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=o,this._changedDolly=0;const a=z.set(i,h,r),l=P.set(t,e,s);this._targetEnd.copy(a),this._sphericalEnd.setFromVector3(l.sub(a).applyQuaternion(this._yAxisUpSpace)),this.normalizeRotations(),this._needsUpdate=!0,n||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const _=!n||p(this._target.x,this._targetEnd.x,this.restThreshold)&&p(this._target.y,this._targetEnd.y,this.restThreshold)&&p(this._target.z,this._targetEnd.z,this.restThreshold)&&p(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&p(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&p(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(_)}lerpLookAt(t,e,s,i,h,r,n,a,l,_,c,d,m,u=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=o,this._changedDolly=0;const O=P.set(i,h,r),E=z.set(t,e,s);k.setFromVector3(E.sub(O).applyQuaternion(this._yAxisUpSpace));const T=w.set(_,c,d),g=z.set(n,a,l);V.setFromVector3(g.sub(T).applyQuaternion(this._yAxisUpSpace)),this._targetEnd.copy(O.lerp(T,m));const y=V.theta-k.theta,f=V.phi-k.phi,C=V.radius-k.radius;this._sphericalEnd.set(k.radius+C*m,k.phi+f*m,k.theta+y*m),this.normalizeRotations(),this._needsUpdate=!0,u||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const U=!u||p(this._target.x,this._targetEnd.x,this.restThreshold)&&p(this._target.y,this._targetEnd.y,this.restThreshold)&&p(this._target.z,this._targetEnd.z,this.restThreshold)&&p(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&p(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&p(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(U)}setPosition(t,e,s,i=!1){return this.setLookAt(t,e,s,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,i)}setTarget(t,e,s,i=!1){const o=this.getPosition(P),h=this.setLookAt(o.x,o.y,o.z,t,e,s,i);return this._sphericalEnd.phi=d(this._sphericalEnd.phi,this.minPolarAngle,this.maxPolarAngle),h}setFocalOffset(t,e,s,i=!1){this._isUserControllingOffset=!1,this._focalOffsetEnd.set(t,e,s),this._needsUpdate=!0,i||this._focalOffset.copy(this._focalOffsetEnd);const o=!i||p(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&p(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&p(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(o)}setOrbitPoint(t,e,s){this._camera.updateMatrixWorld(),H.setFromMatrixColumn(this._camera.matrixWorldInverse,0),M.setFromMatrixColumn(this._camera.matrixWorldInverse,1),b.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const i=P.set(t,e,s),o=i.distanceTo(this._camera.position),h=i.sub(this._camera.position);H.multiplyScalar(h.x),M.multiplyScalar(h.y),b.multiplyScalar(h.z),P.copy(H).add(M).add(b),P.z=P.z+o,this.dollyTo(o,!1),this.setFocalOffset(-P.x,P.y,-P.z,!1),this.moveTo(t,e,s,!1)}setBoundary(t){if(!t)return this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),void(this._needsUpdate=!0);this._boundary.copy(t),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(t,e,s,i){null!==t?(this._viewport=this._viewport||new x.Vector4,"number"==typeof t?this._viewport.set(t,e,s,i):this._viewport.copy(t)):this._viewport=null}getDistanceToFitBox(t,e,s,i=!1){if(f(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const o=t/e,h=this._camera.getEffectiveFOV()*c,r=this._camera.aspect;return.5*((i?o>r:o<r)?e:t/r)/Math.tan(.5*h)+.5*s}getDistanceToFitSphere(t){if(f(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const e=this._camera.getEffectiveFOV()*c,s=2*Math.atan(Math.tan(.5*e)*this._camera.aspect),i=1<this._camera.aspect?e:s;return t/Math.sin(.5*i)}getTarget(t,e=!0){return(t&&t.isVector3?t:new x.Vector3).copy(e?this._targetEnd:this._target)}getPosition(t,e=!0){return(t&&t.isVector3?t:new x.Vector3).setFromSpherical(e?this._sphericalEnd:this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(e?this._targetEnd:this._target)}getSpherical(t,e=!0){return(t||new x.Spherical).copy(e?this._sphericalEnd:this._spherical)}getFocalOffset(t,e=!0){return(t&&t.isVector3?t:new x.Vector3).copy(e?this._focalOffsetEnd:this._focalOffset)}normalizeRotations(){this._sphericalEnd.theta=this._sphericalEnd.theta%l,this._sphericalEnd.theta<0&&(this._sphericalEnd.theta+=l),this._spherical.theta+=l*Math.round((this._sphericalEnd.theta-this._spherical.theta)/l)}stop(){this._focalOffset.copy(this._focalOffsetEnd),this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd),this._zoom=this._zoomEnd}reset(t=!1){if(!p(this._camera.up.x,this._cameraUp0.x)||!p(this._camera.up.y,this._cameraUp0.y)||!p(this._camera.up.z,this._cameraUp0.z)){this._camera.up.copy(this._cameraUp0);const t=this.getPosition(P);this.updateCameraUp(),this.setPosition(t.x,t.y,t.z)}const e=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,t),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,t),this.zoomTo(this._zoom0,t)];return Promise.all(e)}saveState(){this._cameraUp0.copy(this._camera.up),this.getTarget(this._target0),this.getPosition(this._position0),this._zoom0=this._zoom,this._focalOffset0.copy(this._focalOffset)}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,S),this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()}applyCameraUp(){const t=P.subVectors(this._target,this._camera.position).normalize(),e=z.crossVectors(t,this._camera.up);this._camera.up.crossVectors(e,t).normalize(),this._camera.updateMatrixWorld();const s=this.getPosition(P);this.updateCameraUp(),this.setPosition(s.x,s.y,s.z)}update(t){const e=this._sphericalEnd.theta-this._spherical.theta,s=this._sphericalEnd.phi-this._spherical.phi,i=this._sphericalEnd.radius-this._spherical.radius,o=N.subVectors(this._targetEnd,this._target),l=Y.subVectors(this._focalOffsetEnd,this._focalOffset),_=this._zoomEnd-this._zoom;if(m(e))this._thetaVelocity.value=0,this._spherical.theta=this._sphericalEnd.theta;else{const e=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.theta=T(this._spherical.theta,this._sphericalEnd.theta,this._thetaVelocity,e,1/0,t),this._needsUpdate=!0}if(m(s))this._phiVelocity.value=0,this._spherical.phi=this._sphericalEnd.phi;else{const e=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.phi=T(this._spherical.phi,this._sphericalEnd.phi,this._phiVelocity,e,1/0,t),this._needsUpdate=!0}if(m(i))this._radiusVelocity.value=0,this._spherical.radius=this._sphericalEnd.radius;else{const e=this._isUserControllingDolly?this.draggingSmoothTime:this.smoothTime;this._spherical.radius=T(this._spherical.radius,this._sphericalEnd.radius,this._radiusVelocity,e,this.maxSpeed,t),this._needsUpdate=!0}if(m(o.x)&&m(o.y)&&m(o.z))this._targetVelocity.set(0,0,0),this._target.copy(this._targetEnd);else{const e=this._isUserControllingTruck?this.draggingSmoothTime:this.smoothTime;g(this._target,this._targetEnd,this._targetVelocity,e,this.maxSpeed,t,this._target),this._needsUpdate=!0}if(m(l.x)&&m(l.y)&&m(l.z))this._focalOffsetVelocity.set(0,0,0),this._focalOffset.copy(this._focalOffsetEnd);else{const e=this._isUserControllingOffset?this.draggingSmoothTime:this.smoothTime;g(this._focalOffset,this._focalOffsetEnd,this._focalOffsetVelocity,e,this.maxSpeed,t,this._focalOffset),this._needsUpdate=!0}if(m(_))this._zoomVelocity.value=0,this._zoom=this._zoomEnd;else{const e=this._isUserControllingZoom?this.draggingSmoothTime:this.smoothTime;this._zoom=T(this._zoom,this._zoomEnd,this._zoomVelocity,e,1/0,t)}if(this.dollyToCursor)if(n(this._camera)&&0!==this._changedDolly){const t=this._spherical.radius-this._lastDistance,e=this._camera,s=this._getCameraDirection(F),i=P.copy(s).cross(e.up).normalize();0===i.lengthSq()&&(i.x=1);const o=z.crossVectors(i,s),n=this._sphericalEnd.radius*Math.tan(e.getEffectiveFOV()*c*.5),a=(this._sphericalEnd.radius-t-this._sphericalEnd.radius)/this._sphericalEnd.radius,l=w.copy(this._targetEnd).add(i.multiplyScalar(this._dollyControlCoord.x*n*e.aspect)).add(o.multiplyScalar(this._dollyControlCoord.y*n)),_=P.copy(this._targetEnd).lerp(l,a),d=this._lastDollyDirection===h&&this._spherical.radius<=this.minDistance,p=this._lastDollyDirection===r&&this.maxDistance<=this._spherical.radius;if(this.infinityDolly&&(d||p)){this._sphericalEnd.radius-=t,this._spherical.radius-=t;const e=z.copy(s).multiplyScalar(-t);_.add(e)}this._boundary.clampPoint(_,_);const u=z.subVectors(_,this._targetEnd);this._targetEnd.copy(_),this._target.add(u),this._changedDolly-=t,m(this._changedDolly)&&(this._changedDolly=0)}else if(a(this._camera)&&0!==this._changedZoom){const t=this._zoom-this._lastZoom,e=this._camera,s=P.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(e.near+e.far)/(e.near-e.far)).unproject(e),i=z.set(0,0,-1).applyQuaternion(e.quaternion),o=w.copy(s).add(i.multiplyScalar(-s.dot(e.up))),h=-(this._zoom-t-this._zoom)/this._zoom,r=this._getCameraDirection(F),n=this._targetEnd.dot(r),a=P.copy(this._targetEnd).lerp(o,h),l=a.dot(r),_=r.multiplyScalar(l-n);a.sub(_),this._boundary.clampPoint(a,a);const c=z.subVectors(a,this._targetEnd);this._targetEnd.copy(a),this._target.add(c),this._changedZoom-=t,m(this._changedZoom)&&(this._changedZoom=0)}this._camera.zoom!==this._zoom&&(this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0),this._dragNeedsUpdate=!0;const d=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,d),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target);(!m(this._focalOffset.x)||!m(this._focalOffset.y)||!m(this._focalOffset.z))&&(H.setFromMatrixColumn(this._camera.matrix,0),M.setFromMatrixColumn(this._camera.matrix,1),b.setFromMatrixColumn(this._camera.matrix,2),H.multiplyScalar(this._focalOffset.x),M.multiplyScalar(-this._focalOffset.y),b.multiplyScalar(this._focalOffset.z),P.copy(H).add(M).add(b),this._camera.position.add(P),this._camera.updateMatrixWorld()),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),P.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const p=this._needsUpdate;return p&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):p?(this.dispatchEvent({type:"update"}),m(e,this.restThreshold)&&m(s,this.restThreshold)&&m(i,this.restThreshold)&&m(o.x,this.restThreshold)&&m(o.y,this.restThreshold)&&m(o.z,this.restThreshold)&&m(l.x,this.restThreshold)&&m(l.y,this.restThreshold)&&m(l.z,this.restThreshold)&&m(_,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!p&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._lastDistance=this._spherical.radius,this._lastZoom=this._zoom,this._updatedLastTime=p,this._needsUpdate=!1,p}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:O(this.maxDistance),minZoom:this.minZoom,maxZoom:O(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:O(this.maxPolarAngle),minAzimuthAngle:O(this.minAzimuthAngle),maxAzimuthAngle:O(this.maxAzimuthAngle),smoothTime:this.smoothTime,draggingSmoothTime:this.draggingSmoothTime,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,target:this._targetEnd.toArray(),position:P.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(t,e=!1){const s=JSON.parse(t);this.enabled=s.enabled,this.minDistance=s.minDistance,this.maxDistance=E(s.maxDistance),this.minZoom=s.minZoom,this.maxZoom=E(s.maxZoom),this.minPolarAngle=s.minPolarAngle,this.maxPolarAngle=E(s.maxPolarAngle),this.minAzimuthAngle=E(s.minAzimuthAngle),this.maxAzimuthAngle=E(s.maxAzimuthAngle),this.smoothTime=s.smoothTime,this.draggingSmoothTime=s.draggingSmoothTime,this.dollySpeed=s.dollySpeed,this.truckSpeed=s.truckSpeed,this.dollyToCursor=s.dollyToCursor,this._target0.fromArray(s.target0),this._position0.fromArray(s.position0),this._zoom0=s.zoom0,this._focalOffset0.fromArray(s.focalOffset0),this.moveTo(s.target[0],s.target[1],s.target[2],e),k.setFromVector3(P.fromArray(s.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(k.theta,k.phi,e),this.dollyTo(k.radius,e),this.zoomTo(s.zoom,e),this.setFocalOffset(s.focalOffset[0],s.focalOffset[1],s.focalOffset[2],e),this._needsUpdate=!0}connect(t){this._domElement?console.warn("camera-controls is already connected."):(t.setAttribute("data-camera-controls-version","2.10.1"),this._addAllEventListeners(t),this._getClientRect(this._elementRect))}disconnect(){this.cancel(),this._removeAllEventListeners(),this._domElement&&(this._domElement.removeAttribute("data-camera-controls-version"),this._domElement=void 0)}dispose(){this.removeAllEventListeners(),this.disconnect()}_getTargetDirection(t){return t.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)}_getCameraDirection(t){return this._getTargetDirection(t).negate()}_findPointerById(t){return this._activePointers.find(e=>e.pointerId===t)}_findPointerByMouseButton(t){return this._activePointers.find(e=>e.mouseButton===t)}_disposePointer(t){this._activePointers.splice(this._activePointers.indexOf(t),1)}_encloseToBoundary(t,e,s){const i=e.lengthSq();if(0===i)return t;const o=z.copy(e).add(t),h=this._boundary.clampPoint(o,w).sub(o),r=h.lengthSq();if(0===r)return t.add(e);if(r===i)return t;if(0===s)return t.add(e).add(h);{const i=1+s*r/e.dot(h);return t.add(z.copy(e).multiplyScalar(i)).add(h.multiplyScalar(1-s))}}_updateNearPlaneCorners(){if(n(this._camera)){const t=this._camera,e=t.near,s=t.getEffectiveFOV()*c,i=Math.tan(.5*s)*e,o=i*t.aspect;this._nearPlaneCorners[0].set(-o,-i,0),this._nearPlaneCorners[1].set(o,-i,0),this._nearPlaneCorners[2].set(o,i,0),this._nearPlaneCorners[3].set(-o,i,0)}else if(a(this._camera)){const t=this._camera,e=1/t.zoom,s=t.left*e,i=t.right*e,o=t.top*e,h=t.bottom*e;this._nearPlaneCorners[0].set(s,o,0),this._nearPlaneCorners[1].set(i,o,0),this._nearPlaneCorners[2].set(i,h,0),this._nearPlaneCorners[3].set(s,h,0)}}_collisionTest(){let t=1/0;if(!(this.colliderMeshes.length>=1))return t;if(f(this._camera,"_collisionTest"))return t;const e=this._getTargetDirection(F);Q.lookAt(L,e,this._camera.up);for(let s=0;s<4;s++){const i=z.copy(this._nearPlaneCorners[s]);i.applyMatrix4(Q);const o=w.addVectors(this._target,i);j.set(o,e),j.far=this._spherical.radius+1;const h=j.intersectObjects(this.colliderMeshes);0!==h.length&&h[0].distance<t&&(t=h[0].distance)}return t}_getClientRect(t){if(!this._domElement)return;const e=this._domElement.getBoundingClientRect();return t.x=e.left,t.y=e.top,this._viewport?(t.x+=this._viewport.x,t.y+=e.height-this._viewport.w-this._viewport.y,t.width=this._viewport.z,t.height=this._viewport.w):(t.width=e.width,t.height=e.height),t}_createOnRestPromise(t){return t?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise(t=>{const e=()=>{this.removeEventListener("rest",e),t()};this.addEventListener("rest",e)}))}_addAllEventListeners(t){}_removeAllEventListeners(){}get dampingFactor(){return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."),0}set dampingFactor(t){console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.")}get draggingDampingFactor(){return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."),0}set draggingDampingFactor(t){console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.")}static createBoundingSphere(t,e=new x.Sphere){const s=e,i=s.center;Z.makeEmpty(),t.traverseVisible(t=>{t.isMesh&&Z.expandByObject(t)}),Z.getCenter(i);let o=0;return t.traverseVisible(t=>{if(!t.isMesh)return;const e=t;if(!e.geometry)return;const s=e.geometry.clone();s.applyMatrix4(e.matrixWorld);const h=s.attributes.position;for(let r=0,n=h.count;r<n;r++)P.fromBufferAttribute(h,r),o=Math.max(o,i.distanceToSquared(P))}),s.radius=Math.sqrt(o),s}}export{q as C};
