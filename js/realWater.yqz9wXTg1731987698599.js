import{m as n,e,b as t,U as r,c as o}from"./@tresjs.juy9qkLz1731987698599.js";import{P as i}from"./tweakpane.yHWGBmom1731987698599.js";import{_ as c,a,s as l,aA as s,O as u}from"./three.3RwiW87x1731987698599.js";import{d as f,a6 as p,b as v,o as g,f as d,u as x,g as h,j as m,al as y,r as w,J as b,aj as I,ak as R}from"./@vue.-THQH3GC1731987698599.js";import"./@vueuse.R8VPJfVr1731987698599.js";var C="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const _=z;!function(n,e){const t=z,r=A();for(;;)try{if(877135===-parseInt(t(278))/1+-parseInt(t(258))/2+parseInt(t(254))/3+-parseInt(t(291))/4*(parseInt(t(261))/5)+parseInt(t(276))/6*(parseInt(t(267))/7)+-parseInt(t(296))/8+parseInt(t(264))/9*(parseInt(t(283))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const M=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[z(292)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function z(n,e){const t=A();return(z=function(n,e){return t[n-=254]})(n,e)}!function(){M(this,(function(){const n=z,e=new RegExp(n(295)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=L(n(263));e.test(r+n(284))&&t[n(268)](r+"input")?L():r("0")}))()}();const D=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[z(292)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function A(){const n=["log","table","476508UPWfng","console","636798UIOPNT","trace","uniforms",'{}.constructor("return this")( )',"constructor","14298050dmWocW","chain","pool","length","while (true) {}","BufferAttribute","counter","waterTexture","116COdoct","apply","RawShaderMaterial","__proto__","function *\\( *\\)","3454312gnYXFr","bind","render","info","3784551KCofWc","BufferGeometry","setAttribute","position","869734NjSblc","stateObject","debu","204195PhvGPA","call","init","9ZJnzEb","warn","light","77adtRhv","test","value","gger","toString","FrontSide","exception"];return(A=function(){return n})()}D(void 0,(function(){const n=z;let e;try{e=Function("return (function() "+n(281)+");")()}catch(o){e=window}const t=e[n(277)]=e[n(277)]||{},r=[n(274),n(265),n(299),"error",n(273),n(275),n(279)];for(let i=0;i<r.length;i++){const e=D[n(282)].prototype[n(297)](D),o=r[i],c=t[o]||e;e[n(294)]=D[n(297)](D),e[n(271)]=c[n(271)].bind(c),t[o]=e}}))();const T=f({__name:_(285),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=_,o=t,i=new(c[r(255)]),s=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),u=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(256)](r(257),new(c[r(288)])(s,3)),i.setIndex(new a(u,1));const f=new(c[r(293)])({uniforms:{light:{value:o[r(266)]},tiles:{value:o.tiles},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(272)]}),p=new l(i,f),{renderer:v,camera:g}=n(),{onAfterLoop:d}=e();return d((()=>{((n,e)=>{const t=r;f[t(280)].water[t(269)]=n,f.uniforms.causticTex[t(269)]=e,v.value[t(298)](p,g[t(269)])})(o[r(290)],o.causticsTexture)})),(n,e)=>null}});function L(n){function e(n){const t=z;if("string"==typeof n)return function(n){}[t(282)](t(287)).apply(t(289));1!==(""+n/n)[t(286)]||n%20==0?function(){return!0}.constructor(t(260)+t(270))[t(262)]("action"):function(){return!1}[t(282)](t(260)+t(270))[t(292)](t(259)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const O=E;!function(n,e){const t=E,r=j();for(;;)try{if(341465===parseInt(t(520))/1*(parseInt(t(524))/2)+-parseInt(t(511))/3+-parseInt(t(494))/4*(-parseInt(t(490))/5)+-parseInt(t(493))/6+parseInt(t(529))/7*(parseInt(t(513))/8)+-parseInt(t(503))/9+parseInt(t(510))/10*(parseInt(t(506))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[E(514)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function E(n,e){const t=j();return(E=function(n,e){return t[n-=488]})(n,e)}!function(){S(this,(function(){const n=E,e=new RegExp(n(530)),t=new RegExp(n(491),"i"),r=P(n(521));e[n(526)](r+n(544))&&t[n(526)](r+n(496))?P():r("0")}))()}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[E(514)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function j(){const n=["Color","input","counter","trace","stateObject","underwater","Mesh","neg-z.jpg","3748581YkApkn","pos-x.jpg","BackSide","48323vGXqWs","light","load","CubeTextureLoader","2290UHPJGT","1245942lHcOpH","uniforms","2216QMenEM","apply","error","prototype","toString","pos-z.jpg","tiles","1ZPBtrS","init","return (function() ","white","783858RDThqI","warn","test","table","debu","3514gaWwxA","function *\\( *\\)","FrontSide","pos-y.jpg","info","side","constructor","action","waterTexture","geometry","bind","gger","setPath","render","value","chain","causticsTexture","setRenderTarget","causticTex","console","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","water","pooRef","5Vowbpl","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","neg-y.jpg","2247636rAKrCo","43656JlLnSS"];return(j=function(){return n})()}F(void 0,(function(){const n=E,e=function(){const n=E;let e;try{e=Function(n(522)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(548)]=e[n(548)]||{},r=["log",n(525),n(533),n(515),"exception",n(527),n(498)];for(let o=0;o<r.length;o++){const e=F.constructor[n(516)].bind(F),i=r[o],c=t[i]||e;e.__proto__=F[n(539)](F),e[n(517)]=c[n(517)][n(539)](c),t[i]=e}}))();const W=f({__name:O(488),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=O;let i,a;const l=r,u=l[o(538)],f=(new(c[o(509)]))[o(541)](o(549))[o(508)]([o(504),"neg-x.jpg",o(532),o(492),o(518),o(502)]),h=([i,a]=p((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),m=new s({uniforms:{light:{value:l.light},tiles:{value:h},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new(c[o(501)])(u,m),w=v(null),b=new(c[o(495)])(o(523)),{renderer:I,camera:R}=n(),{onLoop:C}=e();return C((()=>{const n=o;I.value[n(546)](null),I[n(543)].setClearColor(b,1),I[n(543)].clear(),m[n(512)][n(488)][n(543)]=l[n(537)],m[n(512)][n(547)][n(543)]=l[n(545)],m.side=c[n(531)],m[n(512)][n(500)].value=!0,I[n(543)][n(542)](y,R[n(543)]),m[n(534)]=c[n(505)],m[n(512)][n(500)][n(543)]=!1,I[n(543)][n(542)](y,R[n(543)])})),(n,e)=>{const t=o;return g(),d(T,{tiles:x(h),light:n[t(507)],waterTexture:n[t(537)],causticsTexture:n[t(545)],ref_key:t(489),ref:w},null,8,[t(519),t(507),t(537),t(545)])}}});function P(n){function e(n){const t=E;if("string"==typeof n)return function(n){}[t(535)]("while (true) {}")[t(514)](t(497));1!==(""+n/n).length||n%20==0?function(){return!0}[t(535)](t(528)+t(540)).call(t(536)):function(){return!1}[t(535)](t(528)+"gger")[t(514)](t(499)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function V(n,e){const t=G();return(V=function(n,e){return t[n-=404]})(n,e)}const H=V;!function(n,e){const t=V,r=G();for(;;)try{if(533927===parseInt(t(414))/1*(-parseInt(t(406))/2)+-parseInt(t(435))/3*(-parseInt(t(409))/4)+parseInt(t(424))/5*(parseInt(t(447))/6)+parseInt(t(405))/7+-parseInt(t(448))/8*(parseInt(t(419))/9)+-parseInt(t(456))/10*(parseInt(t(437))/11)+-parseInt(t(407))/12*(-parseInt(t(436))/13))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const k=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function G(){const n=["input","prototype","123OtnQuQ","1092pepUJV","11suAbzT","log","__proto__","texture","info","value","light","trace","test","render","6GFyQiC","4184IryRGi","counter","geometry","action","table","setClearColor","caustics","call","477370gzpVqT","waterTexture","bind","394583yaILHy","8tjGOid","13656EWFBPY","WebGLRenderTarget","62508nXvrRj","string","apply","water","PlaneGeometry","53089SZqvij","toString","constructor","gger","black","15381ncDaMu","setRenderTarget","length","debu","material","4475795xXzBzu","exception","console","init","return (function() ","while (true) {}","Color","chain","ShaderMaterial"];return(G=function(){return n})()}!function(){k(this,(function(){const n=V,e=new RegExp("function *\\( *\\)"),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=N(n(427));e[n(445)](r+n(431))&&t.test(r+n(433))?N():r("0")}))()}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();Z(void 0,(function(){const n=V,e=function(){const n=V;let e;try{e=Function(n(428)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(426)]=e.console||{},r=[n(438),"warn",n(441),"error",n(425),n(452),n(444)];for(let o=0;o<r[n(421)];o++){const e=Z[n(416)][n(434)][n(404)](Z),i=r[o],c=t[i]||e;e[n(439)]=Z[n(404)](Z),e[n(415)]=c[n(415)][n(404)](c),t[i]=e}}))();const B=f({__name:H(454),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=H,o=t,i=new u(0,1,1,0,0,2e3),a=new(c[r(413)])(2,2,200,200),s=new(c[r(408)])(1024,1024),f=new(c[r(432)])({uniforms:{light:{value:o[r(443)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new l(a,f),v=new(c[r(430)])(r(418)),{renderer:w}=n(),{onBeforeLoop:b}=e();return b((()=>{const n=r;p[n(423)].uniforms[n(412)][n(442)]=o[n(457)],w.value[n(420)](s),w[n(442)][n(453)](v,0),w.value.clear(),w.value[n(446)](p,i)})),(n,e)=>{const t=r;return g(),d(y,null,{default:h((()=>[m(W,{waterTexture:n[t(457)],causticsTexture:x(s)[t(440)],light:n.light,geometry:x(a)},null,8,[t(457),"causticsTexture",t(443),t(450)])])),_:1})}}});function N(n){function e(n){const t=V;if(typeof n===t(410))return function(n){}.constructor(t(429))[t(411)](t(449));1!==(""+n/n).length||n%20==0?function(){return!0}[t(416)](t(422)+t(417))[t(455)](t(451)):function(){return!1}[t(416)]("debugger")[t(411)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const q=Y;!function(n,e){const t=Y,r=J();for(;;)try{if(116941===-parseInt(t(533))/1+parseInt(t(491))/2+-parseInt(t(488))/3*(parseInt(t(492))/4)+-parseInt(t(495))/5+parseInt(t(494))/6+-parseInt(t(529))/7*(parseInt(t(520))/8)+parseInt(t(524))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const $=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Y(538)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){$(this,(function(){const n=Y,e=new RegExp(n(512)),t=new RegExp(n(515),"i"),r=X(n(489));e.test(r+"chain")&&t.test(r+n(546))?X():r("0")}))()}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Y(538)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Y(n,e){const t=J();return(Y=function(n,e){return t[n-=478]})(n,e)}function J(){const n=["126225IhMryA","log","toString","clientX","action","apply","gger","attributes","point","render","exception","center","domElement","input","PlaneGeometry","clientY","top","console",'{}.constructor("return this")( )',"light","length","setRenderTarget","FloatType","bind","string","counter","416037rLsGpA","init","waterSimulation","70948lEGiuQ","4qyqecB","texture","1011828RTScgM","370890kOSVYx","mousemove","RawShaderMaterial","height","strength","stateObject","setZ","intersectObject","Mesh","Vector2","warn","trace","getY","getBoundingClientRect","material","OrthographicCamera","__proto__","function *\\( *\\)","radius","addEventListener","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","uniforms","autoClear","left","prototype","88KSppqI","width","constructor","call","2948220bxuRAY","removeEventListener","value","lightFrontGeometry","position","48153aRHhei","setFromCamera","WebGLRenderTarget","return (function() "];return(J=function(){return n})()}U(void 0,(function(){const n=Y;let e;try{e=Function(n(532)+n(480)+");")()}catch(o){e=window}const t=e[n(479)]=e.console||{},r=[n(534),n(505),"info","error",n(543),"table",n(506)];for(let i=0;i<r[n(482)];i++){const e=U.constructor[n(519)][n(485)](U),o=r[i],c=t[o]||e;e[n(511)]=U[n(485)](U),e[n(535)]=c.toString.bind(c),t[o]=e}}))();const Q=f({__name:q(490),props:{light:{}},setup(t,{expose:r}){const o=q,i=new(c[o(510)])(0,1,1,0,0,2e3),a=new(c[o(547)])(2,2),s=new(c[o(531)])(256,256,{type:c[o(484)]}),u=new(c[o(531)])(256,256,{type:c[o(484)]}),f=new(c[o(497)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:C,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),p=new(c[o(497)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:C,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),v=new(c[o(497)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:C,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),h=new(c[o(503)])(a,f),m=new(c[o(503)])(a,p),y=new(c[o(503)])(a,v);let w=s;const b=(n,e)=>{const t=o,r=w,c=w===s?u:s;e[t(509)][t(516)][t(493)][t(526)]=r[t(493)],n[t(483)](c),n[t(542)](e,i),w=c},{renderer:I,camera:R,raycaster:_}=n();I[o(526)][o(517)]=!1;const{onBeforeLoop:M}=e();M((()=>{const n=o;var e,t;t=I[n(526)],b(t,y),e=I[n(526)],b(e,m)}));const z=(n,e,t,r)=>{const i=o;h[i(509)].uniforms[i(544)][i(526)]=[n,e],h[i(509)][i(516)][i(513)][i(526)]=t,h.material[i(516)][i(499)][i(526)]=r,b(I[i(526)],h)},D=new(c[o(504)]),A=new(c[o(547)])(2,2),T=A[o(540)][o(528)];for(let n=0;n<T.count;n++){const e=-T[o(507)](n);T.setY(n,0),T[o(501)](n,e)}T.needsUpdate=!0;const L=new l(A),O={handleEvent:n=>{const e=o,t=I[e(526)].domElement[e(508)](),r=t[e(521)],i=t[e(498)];D.x=2*(n[e(536)]-t[e(518)])/r-1,D.y=2*-(n[e(548)]-t[e(478)])/i+1,_[e(526)][e(530)](D,R.value);const c=_.value[e(502)](L);for(let o of c)z(o[e(541)].x,o[e(541)].z,.03,.04)}};return r({addDrop:z,mouseEvent:n=>{const e=o;n?I[e(526)][e(545)][e(514)](e(496),O):I[e(526)][e(545)][e(525)](e(496),O)}}),(n,e)=>{const t=o;return g(),d(B,{lightFrontGeometry:x(a),waterTexture:x(w)[t(493)],light:n.light},null,8,[t(527),"waterTexture",t(481)])}}});function X(n){function e(n){const t=Y;if(typeof n===t(486))return function(n){}.constructor("while (true) {}")[t(538)](t(487));1!==(""+n/n)[t(482)]||n%20==0?function(){return!0}[t(522)]("debu"+t(539))[t(523)](t(537)):function(){return!1}[t(522)]("debugger")[t(538)](t(500)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const K=nn;function nn(n,e){const t=en();return(nn=function(n,e){return t[n-=269]})(n,e)}function en(){const n=["3415PnEbDU","addDrop","TresPerspectiveCamera","test","init","116EACODS","length","value","50EJeITY","error","warn","info","9516HINhAr","function *\\( *\\)","103728GqOoHZ","input","toString","5159ctWGgZ","console","random","975123OdVMlz","constructor","536JabNrr","debu","mouseEvent","log","鼠标波纹","addBinding","return (function() ","change","bind","__proto__","addButton","realWater","trace","table","apply","7139LVLoxu","4UPZkoi","stateObject","waterSimulationRef",'{}.constructor("return this")( )',"3281226JEVBKu","counter","946551QtaHOt","gger","click","manual"];return(en=function(){return n})()}!function(n,e){const t=nn,r=en();for(;;)try{if(647154===-parseInt(t(300))/1*(parseInt(t(276))/2)+parseInt(t(282))/3+parseInt(t(291))/4*(-parseInt(t(286))/5)+-parseInt(t(280))/6+parseInt(t(303))/7*(parseInt(t(308))/8)+parseInt(t(306))/9*(parseInt(t(294))/10)+parseInt(t(275))/11*(parseInt(t(298))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const tn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[nn(274)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){tn(this,(function(){const n=nn,e=new RegExp(n(299)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=cn(n(290));e[n(289)](r+"chain")&&t[n(289)](r+n(301))?cn():r("0")}))()}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[nn(274)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();rn(void 0,(function(){const n=nn,e=function(){const n=nn;let e;try{e=Function(n(314)+n(279)+");")()}catch(t){e=window}return e}(),t=e[n(304)]=e[n(304)]||{},r=[n(311),n(296),n(297),n(295),"exception",n(273),n(272)];for(let o=0;o<r.length;o++){const e=rn[n(307)].prototype[n(316)](rn),i=r[o],c=t[i]||e;e[n(269)]=rn[n(316)](rn),e[n(302)]=c[n(302)].bind(c),t[i]=e}}))();const on=f({__name:K(271),setup(n){const e=K,t=w({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(285)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=v(null),l=new i;l[e(270)]({label:"点击按钮",title:"随机增加波纹"}).on(e(284),(()=>{const n=e;for(var t=0;t<10;t++)a.value[n(287)](2*Math[n(305)]()-1,2*Math[n(305)]()-1,.03,1&t?.02:-.02)}));const s=v(!1);return l[e(313)](s,e(293),{label:e(312)}).on(e(315),(n=>{const t=e;a[t(293)][t(310)](n.value)})),(n,i)=>{const l=e;return g(),d(x(o),I(R(t)),{default:h((()=>[i[0]||(i[0]=b(l(288),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),m(x(r)),m(Q,{light:c,ref_key:l(278),ref:a},null,512)])),_:1},16)}}});function cn(n){function e(n){const t=nn;if("string"==typeof n)return function(n){}[t(307)]("while (true) {}")[t(274)](t(281));1!==(""+n/n)[t(292)]||n%20==0?function(){return!0}.constructor(t(309)+t(283)).call("action"):function(){return!1}[t(307)](t(309)+t(283)).apply(t(277)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{on as default};
