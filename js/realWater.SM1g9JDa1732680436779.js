import{m as n,e,b as t,U as r,c as o}from"./@tresjs.ozxSQdlw1732680436779.js";import{P as i}from"./tweakpane.yHWGBmom1732680436779.js";import{_ as c,a,ay as l,C as s,t as u}from"./three.HQIWXjA-1732680436779.js";import{d as f,a6 as p,b as v,o as g,f as d,u as x,g as h,j as m,al as y,r as w,J as b,aj as I,ak as R}from"./@vue.u2cBPEWn1732680436779.js";import"./@vueuse.OVEejUj91732680436779.js";var C="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";function _(n,e){const t=D();return(_=function(n,e){return t[n-=489]})(n,e)}!function(n,e){const t=_,r=D();for(;;)try{if(829539===-parseInt(t(513))/1*(parseInt(t(526))/2)+parseInt(t(515))/3*(-parseInt(t(531))/4)+-parseInt(t(512))/5+parseInt(t(518))/6*(-parseInt(t(506))/7)+parseInt(t(527))/8+parseInt(t(504))/9+parseInt(t(524))/10*(parseInt(t(496))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const M=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[_(508)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){M(this,(function(){const n=_,e=new RegExp("function *\\( *\\)"),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=L(n(503));e[n(522)](r+n(519))&&t[n(522)](r+"input")?L():r("0")}))()}();const z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[_(508)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function D(){const n=["while (true) {}","log","57270oBvICL","chain","position","water","test","render","12860Rtasjw","warn","35930uIMwOW","5381584yUKquJ","__proto__","gger","toString","2308sqUjjG","info","tiles","exception","table","console","call","BufferGeometry","Mesh","constructor","13486NysjLV","trace","FrontSide","light","value","setIndex",'{}.constructor("return this")( )',"init","8421021guZcer","uniforms","343GVCXTp","stateObject","apply","causticTex","error","BufferAttribute","7342335FjWGmj","5BMYBJm","debu","1713LEzkxP"];return(D=function(){return n})()}z(void 0,(function(){const n=_,e=function(){const n=_;let e;try{e=Function("return (function() "+n(502)+");")()}catch(t){e=window}return e}(),t=e[n(491)]=e.console||{},r=[n(517),n(525),n(532),n(510),n(489),n(490),n(497)];for(let o=0;o<r.length;o++){const e=z[n(495)].prototype.bind(z),i=r[o],c=t[i]||e;e[n(528)]=z.bind(z),e.toString=c[n(530)].bind(c),t[i]=e}}))();const T=f({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=_,o=t,i=new(c[r(493)]),s=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),u=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i.setAttribute(r(520),new(c[r(511)])(s,3)),i[r(501)](new a(u,1));const f=new l({uniforms:{light:{value:o[r(499)]},tiles:{value:o[r(533)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(498)]}),p=new(c[r(494)])(i,f),{renderer:v,camera:g}=n(),{onAfterLoop:d}=e();return d((()=>{((n,e)=>{const t=r;f[t(505)][t(521)].value=n,f[t(505)][t(509)][t(500)]=e,v[t(500)][t(523)](p,g[t(500)])})(o.waterTexture,o.causticsTexture)})),(n,e)=>null}});function L(n){function e(n){const t=_;if("string"==typeof n)return function(n){}[t(495)](t(516)).apply("counter");1!==(""+n/n).length||n%20==0?function(){return!0}.constructor("debu"+t(529))[t(492)]("action"):function(){return!1}[t(495)](t(514)+t(529))[t(508)](t(507)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const A=E;function O(){const n=["while (true) {}","load","2634xvvEtH","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","console","render","1540CmDnsT","call","trace","exception","test","clear","chain","init","Mesh","setRenderTarget","warn","549906nUkCBm","tiles","input","prototype","causticsTexture","pos-z.jpg","stateObject","33040cJMJBm","function *\\( *\\)","debu","side","toString","BackSide","light","pooRef","counter","waterTexture","string","gger","geometry","length","bind","constructor","underwater","setPath","CubeTextureLoader","apply","pos-x.jpg","log","2498967ChNUXV","716435IiWGxg","neg-y.jpg","10tnEsWM","setClearColor","water","__proto__","neg-z.jpg","926871wwFSVE","value","427946oPSXtb","uniforms","error","RawShaderMaterial","616PqMqza","FrontSide","1bFbtZF","info","return (function() ","white"];return(O=function(){return n})()}!function(n,e){const t=E,r=O();for(;;)try{if(224997===-parseInt(t(161))/1*(parseInt(t(155))/2)+-parseInt(t(167))/3*(parseInt(t(172))/4)+parseInt(t(213))/5+-parseInt(t(183))/6+-parseInt(t(159))/7*(-parseInt(t(190))/8)+-parseInt(t(212))/9*(-parseInt(t(215))/10)+parseInt(t(153))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[E(209)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){F(this,(function(){const n=E,e=new RegExp(n(191)),t=new RegExp(n(168),"i"),r=W(n(179));e[n(176)](r+n(178))&&t[n(176)](r+n(185))?W():r("0")}))()}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[E(209)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();j(void 0,(function(){const n=E;let e;try{e=Function(n(163)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(170)]=e.console||{},r=[n(211),n(182),n(162),n(157),n(175),"table",n(174)];for(let i=0;i<r[n(203)];i++){const e=j[n(205)][n(186)][n(204)](j),o=r[i],c=t[o]||e;e[n(151)]=j.bind(j),e[n(194)]=c.toString.bind(c),t[o]=e}}))();const S=f({__name:A(150),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=A;let i,a;const l=r,u=l[o(202)],f=(new(c[o(208)]))[o(207)](o(169))[o(166)]([o(210),"neg-x.jpg","pos-y.jpg",o(214),o(188),o(152)]),h=([i,a]=p((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),m=new(c[o(158)])({uniforms:{light:{value:l[o(196)]},tiles:{value:h},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new(c[o(180)])(u,m),w=v(null),b=new s(o(164)),{renderer:I,camera:R}=n(),{onLoop:C}=e();return C((()=>{const n=o;I[n(154)][n(181)](null),I[n(154)][n(216)](b,1),I.value[n(177)](),m[n(156)][n(150)][n(154)]=l.waterTexture,m[n(156)].causticTex[n(154)]=l[n(187)],m[n(193)]=c[n(160)],m.uniforms[n(206)][n(154)]=!0,I.value.render(y,R[n(154)]),m[n(193)]=c[n(195)],m.uniforms[n(206)][n(154)]=!1,I[n(154)][n(171)](y,R[n(154)])})),(n,e)=>{const t=o;return g(),d(T,{tiles:x(h),light:n[t(196)],waterTexture:n.waterTexture,causticsTexture:n[t(187)],ref_key:t(197),ref:w},null,8,[t(184),"light",t(199),t(187)])}}});function E(n,e){const t=O();return(E=function(n,e){return t[n-=150]})(n,e)}function W(n){function e(n){const t=E;if(typeof n===t(200))return function(n){}[t(205)](t(165)).apply(t(198));1!==(""+n/n)[t(203)]||n%20==0?function(){return!0}[t(205)](t(192)+t(201))[t(173)]("action"):function(){return!1}[t(205)]("debu"+t(201))[t(209)](t(189)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const P=H;!function(n,e){const t=H,r=B();for(;;)try{if(328443===parseInt(t(382))/1+parseInt(t(394))/2*(parseInt(t(409))/3)+-parseInt(t(386))/4*(parseInt(t(378))/5)+parseInt(t(407))/6+parseInt(t(397))/7*(-parseInt(t(401))/8)+parseInt(t(428))/9*(-parseInt(t(384))/10)+parseInt(t(393))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const V=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){V(this,(function(){const n=H,e=new RegExp(n(406)),t=new RegExp(n(387),"i"),r=N(n(418));e[n(416)](r+"chain")&&t[n(416)](r+"input")?N():r("0")}))()}();const k=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function B(){const n=["causticsTexture","texture","clear","toString","3208216IYczmd","6wXrVUr","return (function() ","material","2441194dwWLVz","uniforms","debu","warn","8RnhdrQ","waterTexture","length","stateObject","ShaderMaterial","function *\\( *\\)","863496RmajfS","info","540732OPEOiL","string","render","prototype","OrthographicCamera","WebGLRenderTarget","console","test","Mesh","init","log","action","value","error","while (true) {}","water","light",'{}.constructor("return this")( )',"gger","5615721NsRhSs","caustics","constructor","265pHUoiA","exception","bind","setClearColor","502241dsNoNv","setRenderTarget","10MIkqLC","geometry","13388otjzOa","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","Color"];return(B=function(){return n})()}function H(n,e){const t=B();return(H=function(n,e){return t[n-=377]})(n,e)}k(void 0,(function(){const n=H,e=function(){const n=H;let e;try{e=Function(n(395)+n(426)+");")()}catch(t){e=window}return e}(),t=e[n(415)]=e[n(415)]||{},r=[n(419),n(400),n(408),n(422),n(379),"table","trace"];for(let o=0;o<r[n(403)];o++){const e=k[n(377)][n(412)][n(380)](k),i=r[o],c=t[i]||e;e.__proto__=k.bind(k),e[n(392)]=c[n(392)][n(380)](c),t[i]=e}}))();const Z=f({__name:P(429),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=P,o=t,i=new(c[r(413)])(0,1,1,0,0,2e3),a=new u(2,2,200,200),l=new(c[r(414)])(1024,1024),s=new(c[r(405)])({uniforms:{light:{value:o[r(425)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),f=new(c[r(417)])(a,s),p=new(c[r(388)])("black"),{renderer:v}=n(),{onBeforeLoop:w}=e();return w((()=>{const n=r;f[n(396)][n(398)][n(424)][n(421)]=o[n(402)],v[n(421)][n(383)](l),v[n(421)][n(381)](p,0),v[n(421)][n(391)](),v[n(421)][n(411)](f,i)})),(n,e)=>{const t=r;return g(),d(y,null,{default:h((()=>[m(S,{waterTexture:n[t(402)],causticsTexture:x(l)[t(390)],light:n[t(425)],geometry:x(a)},null,8,[t(402),t(389),t(425),t(385)])])),_:1})}}});function N(n){function e(n){const t=H;if(typeof n===t(410))return function(n){}[t(377)](t(423)).apply("counter");1!==(""+n/n).length||n%20==0?function(){return!0}[t(377)](t(399)+"gger").call(t(420)):function(){return!1}.constructor(t(399)+t(427)).apply(t(404)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=$,r=U();for(;;)try{if(480694===-parseInt(t(211))/1*(parseInt(t(210))/2)+-parseInt(t(191))/3*(parseInt(t(171))/4)+parseInt(t(188))/5+parseInt(t(217))/6*(-parseInt(t(193))/7)+-parseInt(t(203))/8*(parseInt(t(202))/9)+-parseInt(t(165))/10*(-parseInt(t(212))/11)+parseInt(t(158))/12)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[$(207)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){q(this,(function(){const n=$,e=new RegExp("function *\\( *\\)"),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=X(n(194));e.test(r+n(220))&&t.test(r+n(189))?X():r("0")}))()}();const G=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function U(){const n=["action","toString","center","30475hFbVRp","input","left","147mJkfID",'{}.constructor("return this")( )',"12068gUmqAZ","init","PlaneGeometry","getBoundingClientRect","setFromCamera","stateObject","warn","return (function() ","getY","45dWntmD","766672FGbbgc","addEventListener","WebGLRenderTarget","autoClear","apply","width","call","2dnznAt","354961BKDjIb","473qAKRXC","length","value","lightFrontGeometry","waterTexture","3030gVJTan","bind","Vector2","chain","gger","radius","log","top","removeEventListener","exception","24713688clOeLa","OrthographicCamera","material","RawShaderMaterial","debu","mousemove","console","98290LAPBcq","render","point","clientY","count","setY","24716QMKewR","constructor","counter","uniforms","setRenderTarget","light","Mesh","prototype","intersectObject","needsUpdate","FloatType","texture","domElement","setZ"];return(U=function(){return n})()}function $(n,e){const t=U();return($=function(n,e){return t[n-=152]})(n,e)}G(void 0,(function(){const n=$;let e;try{e=Function(n(200)+n(192)+");")()}catch(o){e=window}const t=e[n(164)]=e[n(164)]||{},r=[n(154),n(199),"info","error",n(157),"table","trace"];for(let i=0;i<r[n(213)];i++){const e=G[n(172)][n(178)][n(218)](G),o=r[i],c=t[o]||e;e.__proto__=G[n(218)](G),e.toString=c[n(186)][n(218)](c),t[o]=e}}))();const J=f({__name:"waterSimulation",props:{light:{}},setup(t,{expose:r}){const o=$,i=new(c[o(159)])(0,1,1,0,0,2e3),a=new(c[o(195)])(2,2),s=new(c[o(205)])(256,256,{type:c[o(181)]}),u=new(c[o(205)])(256,256,{type:c[o(181)]}),f=new(c[o(161)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:C,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),p=new l({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:C,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),v=new(c[o(161)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:C,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),h=new(c[o(177)])(a,f),m=new(c[o(177)])(a,p),y=new(c[o(177)])(a,v);let w=s;const b=(n,e)=>{const t=o,r=w,c=w===s?u:s;e.material[t(174)][t(182)][t(214)]=r[t(182)],n[t(175)](c),n[t(166)](e,i),w=c},{renderer:I,camera:R,raycaster:_}=n();I.value[o(206)]=!1;const{onBeforeLoop:M}=e();M((()=>{const n=o;var e,t;t=I[n(214)],b(t,y),e=I[n(214)],b(e,m)}));const z=(n,e,t,r)=>{const i=o;h.material[i(174)][i(187)][i(214)]=[n,e],h[i(160)][i(174)][i(153)][i(214)]=t,h[i(160)][i(174)].strength[i(214)]=r,b(I[i(214)],h)},D=new(c[o(219)]),T=new(c[o(195)])(2,2),L=T.attributes.position;for(let n=0;n<L[o(169)];n++){const e=-L[o(201)](n);L[o(170)](n,0),L[o(184)](n,e)}L[o(180)]=!0;const A=new(c[o(177)])(T),O={handleEvent:n=>{const e=o,t=I[e(214)][e(183)][e(196)](),r=t[e(208)],i=t.height;D.x=2*(n.clientX-t[e(190)])/r-1,D.y=2*-(n[e(168)]-t[e(155)])/i+1,_[e(214)][e(197)](D,R[e(214)]);const c=_[e(214)][e(179)](A);for(let o of c)z(o[e(167)].x,o[e(167)].z,.03,.04)}};return r({addDrop:z,mouseEvent:n=>{const e=o;n?I[e(214)][e(183)][e(204)](e(163),O):I[e(214)][e(183)][e(156)](e(163),O)}}),(n,e)=>{const t=o;return g(),d(Z,{lightFrontGeometry:x(a),waterTexture:x(w)[t(182)],light:n[t(176)]},null,8,[t(215),t(216),"light"])}}});function X(n){function e(n){const t=$;if("string"==typeof n)return function(n){}[t(172)]("while (true) {}")[t(207)](t(173));1!==(""+n/n)[t(213)]||n%20==0?function(){return!0}[t(172)]("debu"+t(152))[t(209)](t(185)):function(){return!1}.constructor(t(162)+t(152)).apply(t(198)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const K=en;!function(n,e){const t=en,r=nn();for(;;)try{if(822024===-parseInt(t(481))/1*(-parseInt(t(486))/2)+parseInt(t(475))/3*(-parseInt(t(485))/4)+-parseInt(t(467))/5*(-parseInt(t(463))/6)+-parseInt(t(496))/7*(-parseInt(t(489))/8)+parseInt(t(502))/9*(parseInt(t(483))/10)+parseInt(t(499))/11+-parseInt(t(490))/12*(parseInt(t(465))/13))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Y=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[en(478)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Y(this,(function(){const n=en,e=new RegExp(n(488)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=rn(n(459));e[n(472)](r+"chain")&&t[n(472)](r+n(469))?rn():r("0")}))()}();const Q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[en(478)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function nn(){const n=["table","随机增加波纹","28XeOzMi","constructor","stateObject","12997050QKmfUB","debu","trace","67761uTSIXF","点击按钮","bind","length","init",'{}.constructor("return this")( )',"realWater","click","132oYEywS","prototype","637gMOJhn","while (true) {}","175285iWKwTS","toString","input","action","counter","test","manual","mouseEvent","67725gAkjhI","console","call","apply","鼠标波纹","value","125566rAawbZ","gger","1110oluFyf","addBinding","52ZLfeKB","10bsTntR","error","function *\\( *\\)","874728OPevjB","670584qpvHOr","warn","TresPerspectiveCamera","random"];return(nn=function(){return n})()}function en(n,e){const t=nn();return(en=function(n,e){return t[n-=458]})(n,e)}Q(void 0,(function(){const n=en;let e;try{e=Function("return (function() "+n(460)+");")()}catch(o){e=window}const t=e[n(476)]=e.console||{},r=["log",n(491),"info",n(487),"exception",n(494),n(501)];for(let i=0;i<r[n(458)];i++){const e=Q.constructor[n(464)][n(504)](Q),o=r[i],c=t[o]||e;e.__proto__=Q[n(504)](Q),e[n(468)]=c.toString[n(504)](c),t[o]=e}}))();const tn=f({__name:K(461),setup(n){const e=K,t=w({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(473)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=v(null),l=new i;l.addButton({label:e(503),title:e(495)}).on(e(462),(()=>{const n=e;for(var t=0;t<10;t++)a[n(480)].addDrop(2*Math[n(493)]()-1,2*Math[n(493)]()-1,.03,1&t?.02:-.02)}));const s=v(!1);return l[e(484)](s,"value",{label:e(479)}).on("change",(n=>{const t=e;a[t(480)][t(474)](n[t(480)])})),(n,i)=>{const l=e;return g(),d(x(o),I(R(t)),{default:h((()=>[i[0]||(i[0]=b(l(492),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),m(x(r)),m(J,{light:c,ref_key:"waterSimulationRef",ref:a},null,512)])),_:1},16)}}});function rn(n){function e(n){const t=en;if("string"==typeof n)return function(n){}[t(497)](t(466)).apply(t(471));1!==(""+n/n)[t(458)]||n%20==0?function(){return!0}[t(497)](t(500)+t(482))[t(477)](t(470)):function(){return!1}[t(497)](t(500)+t(482))[t(478)](t(498)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{tn as default};
