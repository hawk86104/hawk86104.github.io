import{a1 as d,a2 as u,r as m,o as p,x as _,E as f,a8 as h,a9 as v,a as P,L as t,ac as g,Y as o,aa as T,ab as w,aA as x}from"./vendor.lj85K5ev1716383888730.js";const C=o("TresPerspectiveCamera",{position:[5,5,5],fov:45,near:.1,far:1e3,"look-at":[-8,3,-3]},null,-1),S=o("TresAmbientLight",{intensity:.5},null,-1),M={position:[-2,-2,-2]},y=["position","a-scale"],z=o("TresDirectionalLight",{position:[0,2,4],intensity:1,"cast-shadow":""},null,-1),A=o("TresGridHelper",null,null,-1),i=3e3,k=d({__name:"shaderParticles",setup(b){const r=u({clearColor:"black",shadows:!0,alpha:!1}),n={transparent:!0,blending:x,depthWrite:!1,vertexShader:"\n  uniform float uPixelRatio;\n  uniform float uSize;\n  uniform float uTime;\n  attribute float aScale;\n\n  void main()\n  {\n      vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n      modelPosition.y += sin(uTime + modelPosition.x * 100.0) * aScale * 0.2;\n      vec4 viewPosition = viewMatrix * modelPosition;\n      vec4 projectionPosition = projectionMatrix * viewPosition;\n\n      gl_Position = projectionPosition;\n      gl_PointSize = aScale * uSize * uPixelRatio;\n      gl_PointSize *= (1.0 / - viewPosition.z);\n  }\n  ",fragmentShader:"\n  void main()\n    {\n      float distanceToCenter = distance(gl_PointCoord, vec2(0.5));\n      float strength = 0.05 / distanceToCenter - 0.1;\n\n      gl_FragColor = vec4(1.0, 1.0, 1.0, strength);\n    }\n  ",uniforms:{uSize:{value:100},uPixelRatio:{value:Math.min(window.devicePixelRatio,2)},uTime:{value:0}}},a=new Float32Array(i*3),s=new Float32Array(i);for(let e=0;e<i;e++)a[e*3+0]=Math.random()*4,a[e*3+1]=Math.random()*4,a[e*3+2]=Math.random()*4,s[e]=Math.random();const{onLoop:l}=v();return l(({elapsed:e})=>{n.uniforms.uTime.value=e}),(e,B)=>{const c=m("TresCanvas");return p(),_(c,h(r,{"window-size":""}),{default:f(()=>[C,P(t(g)),S,o("TresPoints",M,[o("TresBufferGeometry",{position:[t(a),3],"a-scale":[t(s),1]},null,8,y),o("TresShaderMaterial",T(w(n)),null,16)]),z,A]),_:1},16)}}});export{k as default};
