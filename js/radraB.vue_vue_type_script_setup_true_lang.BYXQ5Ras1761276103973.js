import{_ as e}from"./@tresjs.B_KjVy0E1761276103973.js";import{k as o,M as n,a6 as a,bJ as t,ab as r,V as i}from"./three.Bhn4-0ry1761276103973.js";import{d as l,a as s,w as u,a3 as d,G as f,o as c,I as v,a9 as g,aa as m}from"./@vue.CKlgtJke1761276103973.js";const p=["args"],h=l({__name:"radraA",props:{size:{default:300},radius:{default:240},color:{default:"#ffff00"},opacity:{default:.9},speed:{default:300},followWidth:{default:220}},setup(r,{expose:i}){const l=r,{onBeforeRender:h}=e(),x={value:0},M=s();h(({delta:e})=>{x.value+=e});const y={transparent:!0,blending:t,depthWrite:!1,side:a,depthTest:!0,vertexShader:"\n\tvarying vec3 vPosition;\n\tvoid main() {\n\t\tvPosition = position;\n\t\tvec4 modelPosition = modelMatrix * vec4(position, 1.0);\n\t\tvec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectionPosition = projectionMatrix * viewPosition;\n    gl_Position = projectionPosition;\n  }\n  ",fragmentShader:"\n\tuniform float uRadius;     \n  uniform float uTime;            \n  uniform float uSpeed; \n  uniform float uFollowWidth; \n  varying vec3 vPosition;\n\tuniform vec3 ncolor;\n  float calcAngle(vec3 oFrag){\n    float fragAngle;\n    const vec3 ox = vec3(1,0,0);\n    float dianji = oFrag.x * ox.x + oFrag.z*ox.z;\n    float oFrag_length = length(oFrag); // length是内置函数\n    float ox_length = length(ox); // length是内置函数\n    float yuxian = dianji / (oFrag_length * ox_length);\n    fragAngle = acos(yuxian);\n    fragAngle = degrees(fragAngle);\n    if(oFrag.z > 0.0) {\n      fragAngle = -fragAngle + 360.0;\n    }\n    float scanAngle = uTime * uSpeed - floor(uTime * uSpeed / 360.0) * 360.0;\n    float angle = scanAngle - fragAngle;\n    if(angle < 0.0){\n      angle = angle + 360.0;\n    }\n    return angle;\n  }\n  void main() {\n\t\t\t// length内置函数，取向量的长度\n\t\tif(length(vPosition) == 0.0 || length(vPosition) > uRadius-2.0){\n\t\t\tgl_FragColor = vec4( ncolor, 1.0 );\n\t\t} else {\n\t\t\tfloat angle = calcAngle(vPosition);\n\t\t\tif(angle < uFollowWidth){\n\t\t\t\t// 尾焰区域\n\t\t\t\tfloat opacity =  1.0 - angle / uFollowWidth; \n\t\t\t\tgl_FragColor = vec4( ncolor, 1.0 * opacity );  \n\t\t\t} else {\n\t\t\t\t// 其他位置的像素均为透明\n\t\t\t\tgl_FragColor = vec4( ncolor, 0.0 ); \n\t\t\t}\n\t\t}\n\t}\n  ",uniforms:{uSpeed:{value:l.speed},uRadius:{value:l.radius},uTime:x,uFollowWidth:{value:l.followWidth},ncolor:{value:new o(l.color)}}};u(M,(e,o)=>{if(e&&void 0===o){const e=(new n).makeRotationX(-Math.PI/180*90);M.value.applyMatrix4(e)}});const w=s();return d(()=>{l.color&&(y.uniforms.ncolor.value=new o(l.color)),l.radius&&(y.uniforms.uRadius.value=l.radius)}),s(-Math.PI/180*90),i({MeshRef:w}),(e,o)=>(c(),f("TresMesh",{ref_key:"MeshRef",ref:w},[v("TresCircleGeometry",{ref_key:"TresCircleGeometryRef",ref:M,args:[l.size,1e3]},null,8,p),v("TresShaderMaterial",g(m(y)),null,16)],512))}}),x=["args"],M=l({__name:"radraB",props:{radius:{default:10},maxRadius:{default:200},color:{default:"#ffff00"},opacity:{default:.5},period:{default:2},height:{default:100}},setup(t,{expose:l}){const p=t,h=s(),M=s(1),y=s(.1),w={color:p.color,opacity:p.opacity,transparent:!0,depthWrite:!1,depthTest:!0,side:a,vertexShader:"\n\tvarying vec4 vPosition;\n  void main() {\n    vPosition = modelMatrix * vec4(position,1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n  ",fragmentShader:"\n\tuniform vec3 uColor; // 光墙半径        \n  uniform vec3 uMax; \n  uniform vec3 uMin;\n  uniform mat4 modelMatrix; // 世界矩阵\n  varying vec4 vPosition; // 接收顶点着色传递进来的位置数据\n  void main() {\n    // 转世界坐标\n    vec4 uMax_world = modelMatrix * vec4(uMax,1.0);\n    vec4 uMin_world = modelMatrix * vec4(uMin,1.0);\n    // 根据像素点世界坐标的y轴高度,设置透明度\n    float opacity =1.0 - (vPosition.y - uMin_world.y) / (uMax_world.y -uMin_world.y) ; \n    gl_FragColor = vec4( uColor, opacity);\n  }\n  ",uniforms:{uMax:M,uMin:y,uColor:{value:new o(p.color)}}},_=s();let P=null;u(_,(e,o)=>{e&&void 0===o&&(_.value.computeBoundingBox(),M.value=_.value.boundingBox.max,y.value=_.value.boundingBox.min,P=h.value.scale.clone())});const T=s(new r(new i(0,0,0),new i(0,p.height,0)));d(()=>{p.color&&(w.uniforms.uColor.value=new o(p.color))});const{onBeforeRender:F}=e(),R={value:0};return F(({delta:e})=>{R.value+=e;const o=(R.value%p.period/p.period*(p.maxRadius-p.radius)+p.radius)/p.radius,a=(new n).makeScale(o,1,o);P&&(h.value.scale.copy(P.clone().applyMatrix4(a)),h.value.updateMatrix())}),l({MeshRef:h}),(e,o)=>(c(),f("TresMesh",{ref_key:"MeshRef",ref:h,renderOrder:2e3},[v("TresTubeGeometry",{ref_key:"TresTubeGeometryRef",ref:_,args:[T.value,20,p.radius,100,!1]},null,8,x),v("TresShaderMaterial",g(m(w)),null,16)],512))}});export{h as _,M as a};
