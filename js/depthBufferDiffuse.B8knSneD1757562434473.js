import"./@fesjs.B-eV0iDW1757562434473.js";import"./Resource.BowyBt9V1757562434473.js";/* empty css                                                                             */import{_ as e}from"./default.vue_vue_type_script_setup_true_lang.BwWcSjXh1757562434473.js";import"./three-mesh-ui.module.CVvu0VoA1757562434473.js";/* empty css                                                              */import{m as r,e as o}from"./@tresjs.Cox_Ej0K1757562434473.js";import"./vanilla.esm.5.5.0.zQhKIMxa1757562434473.js";import{u as t}from"./index.CNFNX6R31757562434473.js";import{d as a,ab as i,w as n,G as s,o as l,I as u,a7 as m,a8 as d,r as f,v as p,a2 as v,j as h,u as c,f as g,m as _,F as j}from"./@vue.pEDXJ_3Z1757562434473.js";import{C,a as b,a3 as y,bd as x}from"./three.CMHPKQCP1757562434473.js";import"./SPE.B4anIgvN1757562434473.js";import"./HeightCorrection.Bq98L9tL1757562434473.js";import"./three-custom-shader-material.Bhmd8dgL1757562434473.js";import{P as D}from"./tweakpane.C0HtAJSg1757562434473.js";import{b as w}from"./pagesShow.vue_vue_type_script_setup_true_lang.BGzjAXLZ1757562434473.js";import"./vue-router.DJjrSDwT1757562434473.js";import"./lodash-es.C7pWAXPe1757562434473.js";import"./pinia.BfnF9Own1757562434473.js";import"./@qlin.q6OWdsQV1757562434473.js";import"./@babel.BPq7uOAK1757562434473.js";import"./@floating-ui.BFjFSAYt1757562434473.js";import"./@juggle.CcBCnTIR1757562434473.js";import"./postprocessing.mBO420ZZ1757562434473.js";import"./@vueuse.CO9YPEko1757562434473.js";import"./object-hash.DtRjQrUi1757562434473.js";import"./@amap.CGUF9xH41757562434473.js";import"./jszip.BxydWdhH1757562434473.js";import"./buildingsCustomShaderMaterial.DyBo--wu1757562434473.js";const z={renderOrder:2200},N=["args"],R=a({__name:"depthBufferDiffuse",props:{radius:{default:100},shieldColor:{default:"#ffff00"},rimColor:{default:"#ffffff"},threshold:{default:.005}},setup(e){const a=e,{sizes:f,camera:p}=r(),v=f.aspectRatio.value,h=f.width.value,c=f.height.value,g=t({height:h*v,width:c*v,depth:!0,isLoop:!0}),_={blending:x,transparent:!0,depthWrite:!1,depthTest:!0,side:y,vertexShader:"\n\tvarying vec2 vUv;\n\tvarying vec3 vNormal;\n\tvarying vec3 vPosition;\n\tvoid main() {\n\t\tvUv = uv;\n\t\tvec4 worldPos = modelMatrix * vec4(position, 1.0);\n\t\tvec4 modelNormal = modelMatrix * vec4(normal, 0.0);\n\t\tvec4 mvPosition = viewMatrix * worldPos;\n\t\tgl_Position = projectionMatrix * mvPosition;\n\t\tvNormal = modelNormal.xyz;\n\t\tvPosition = worldPos.xyz;\n\t}\n  ",fragmentShader:"\nuniform sampler2D uDepthTexture; \nuniform vec2 uResolution;\nuniform float uNear;\nuniform float uFar;\nuniform float uThreshold;\nuniform vec3 uShieldColor;\nuniform vec3 uRimColor;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\n#include <packing>\n\nfloat LinearizeDepth(float depth) {\n\tfloat zNdc = 2.0 * depth - 1.0;\n\tfloat zEye = (2.0 * uFar * uNear) / ((uFar + uNear) - zNdc * (uFar - uNear));\n\tfloat linearDepth = (zEye - uNear) / (uFar - uNear);\n\treturn linearDepth;\n}\n\nvoid main() {\n\n  vec3 normal = normalize(vNormal);\n  if(gl_FrontFacing) {\n    normal *= -1.0;\n  }\n\n  vec3 viewDirection = normalize(cameraPosition - vPosition);\n  float fresnel = 1. + dot(normal, viewDirection);\n  fresnel = pow(fresnel, 4.0);\n\n  vec2 worldCoords = gl_FragCoord.xy/uResolution;\n\n  float sceneDepth = LinearizeDepth(texture2D(uDepthTexture, worldCoords).r);\n  float bubbleDepth = LinearizeDepth(gl_FragCoord.z);\n\n  float difference = abs( sceneDepth - bubbleDepth);\n  float normalizedDistance = clamp(difference / uThreshold, 0.0, 1.0);\n  vec4 intersection = mix(vec4(1.0), vec4(0.0), normalizedDistance) ;\n  intersection.rgb *= uRimColor;\n  vec4 color = vec4(uShieldColor, 0.3);\n  gl_FragColor = color + intersection + vec4(uRimColor, 1.0) * fresnel ;\n}\n  ",uniforms:{uDepthTexture:{value:i(g?.value?.depthTexture)},uResolution:{value:new b(h,c)},uNear:{value:1},uFar:{value:1e4},uThreshold:{value:.005},uShieldColor:{value:new C(a.shieldColor)},uRimColor:{value:new C(a.rimColor)}}},{onLoop:j}=o();return j((()=>{})),n((()=>[a.rimColor,a.shieldColor,a.threshold]),(([e,r,o])=>{_.uniforms.uRimColor.value.setStyle(e),_.uniforms.uShieldColor.value.setStyle(r),_.uniforms.uThreshold.value=o})),(e,r)=>(l(),s("TresMesh",z,[u("TresSphereGeometry",{args:[a.radius,64,64]},null,8,N),u("TresShaderMaterial",m(d(_)),null,16)]))}}),P=a({__name:"depthBufferDiffuse",setup(r){const o=f({shieldColor:"#ffff00",rimColor:"#ffffff",threshold:.005,radius:100}),t=new D;t.addBinding(o,"shieldColor",{label:"圈颜色"}),t.addBinding(o,"rimColor",{label:"条颜色"}),t.addBinding(o,"threshold",{label:"线条参数",min:1e-5,max:.01,step:1e-5}),t.addBinding(o,"radius",{label:"大小",min:10,max:200,step:1});const a=p(null);return v((()=>{a.value&&(a.value.$refs.tcRef?a.value.$refs.tcRef.context.camera.value.position.set(-135,250,320):a.value.$refs.perspectiveCameraRef&&a.value.$refs.perspectiveCameraRef.position.set(-135,250,320))})),(r,t)=>(l(),s(j,null,[h(c(e)),h(w,{ref_key:"pagesShowRef",ref:a},{ability:g((()=>[h(c(R),_({position:[0,30,0]},o),null,16)])),_:1},512)],64))}});export{P as default};
