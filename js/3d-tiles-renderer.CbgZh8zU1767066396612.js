import{e as t,G as e,F as s}from"./three.BD1hRFgo1767066396612.js";import{s as i}from"./@originjs.DdrgKBO31767066396612.js";const n={},r={vue:{get:()=>()=>l(new URL("__federation_shared_vue.jxZXTrWx1767066396612.js",import.meta.url).href),import:!0},three:{get:()=>()=>l(new URL("__federation_shared_three.wTUqrITB1767066396612.js",import.meta.url).href),import:!0}},o=Object.create(null);async function a(t,e="default"){return o[t]?new Promise(e=>e(o[t])):await async function(t,e){let s=null;if(globalThis?.__federation_shared__?.[e]?.[t]){const n=globalThis.__federation_shared__[e][t],o=r[t]?.requiredVersion;if(!!o){const e=Object.keys(n).find(t=>i(t,o));if(e){const t=n[e];s=await(await t.get())()}else console.log(`provider support ${t}(${e}) is not satisfied requiredVersion(\${moduleMap[name].requiredVersion})`)}else{const t=n[Object.keys(n)[0]];s=await(await t.get())()}}if(s)return c(s,t)}(t,e)||async function(t){if(r[t]?.import){return c(await(await r[t].get())(),t)}console.error("consumer config import=false,so cant use callback shared module")}(t)}async function l(t){return n[t]??=import(t),n[t]}function c(t,e){return"function"==typeof t.default?(Object.keys(t).forEach(e=>{"default"!==e&&(t.default[e]=t[e])}),o[e]=t.default,t.default):(t.default&&(t=Object.assign({},t.default,t)),o[e]=t,t)}let h=class{get unloadPriorityCallback(){return this._unloadPriorityCallback}set unloadPriorityCallback(t){1===t.length?(console.warn('LRUCache: "unloadPriorityCallback" function has been changed to take two arguments.'),this._unloadPriorityCallback=(e,s)=>{const i=t(e),n=t(s);return i<n?-1:i>n?1:0}):this._unloadPriorityCallback=t}constructor(){this.minSize=6e3,this.maxSize=8e3,this.minBytesSize=322122547.2,this.maxBytesSize=429496729.6,this.unloadPercent=.05,this.autoMarkUnused=!0,this.itemSet=new Map,this.itemList=[],this.usedSet=new Set,this.callbacks=new Map,this.unloadingHandle=-1,this.cachedBytes=0,this.bytesMap=new Map,this.loadedSet=new Set,this._unloadPriorityCallback=null;const t=this.itemSet;this.defaultPriorityCallback=e=>t.get(e)}isFull(){return this.itemSet.size>=this.maxSize||this.cachedBytes>=this.maxBytesSize}getMemoryUsage(t){return this.bytesMap.get(t)||0}setMemoryUsage(t,e){const{bytesMap:s,itemSet:i}=this;i.has(t)&&(this.cachedBytes-=s.get(t)||0,s.set(t,e),this.cachedBytes+=e)}add(t,e){const s=this.itemSet;if(s.has(t)||this.isFull())return!1;const i=this.usedSet,n=this.itemList,r=this.callbacks;return n.push(t),i.add(t),s.set(t,Date.now()),r.set(t,e),!0}has(t){return this.itemSet.has(t)}remove(t){const e=this.usedSet,s=this.itemSet,i=this.itemList,n=this.bytesMap,r=this.callbacks,o=this.loadedSet;if(s.has(t)){this.cachedBytes-=n.get(t)||0,n.delete(t),r.get(t)(t);const a=i.indexOf(t);return i.splice(a,1),e.delete(t),s.delete(t),r.delete(t),o.delete(t),!0}return!1}setLoaded(t,e){const{itemSet:s,loadedSet:i}=this;s.has(t)&&(!0===e?i.add(t):i.delete(t))}markUsed(t){const e=this.itemSet,s=this.usedSet;e.has(t)&&!s.has(t)&&(e.set(t,Date.now()),s.add(t))}markUnused(t){this.usedSet.delete(t)}markAllUnused(){this.usedSet.clear()}unloadUnusedContent(){const{unloadPercent:t,minSize:e,maxSize:s,itemList:i,itemSet:n,usedSet:r,loadedSet:o,callbacks:a,bytesMap:l,minBytesSize:c,maxBytesSize:h}=this,u=i.length-r.size,d=i.length-o.size,p=Math.max(Math.min(i.length-e,u),0),m=this.cachedBytes-c,g=this.unloadPriorityCallback||this.defaultPriorityCallback;let f=!1;const y=p>0&&u>0||d&&i.length>s;if(u&&this.cachedBytes>c||d&&this.cachedBytes>h||y){i.sort((t,e)=>{const s=r.has(t);if(s===r.has(e)){const s=o.has(t);return s===o.has(e)?-g(t,e):s?1:-1}return s?1:-1});const d=Math.max(e*t,p*t),y=Math.ceil(Math.min(d,u,p)),b=Math.max(t*m,t*c),x=Math.min(b,m);let _=0,T=0;for(;this.cachedBytes-T>h||i.length-_>s;){const t=i[_],e=l.get(t)||0;if(r.has(t)&&o.has(t)||this.cachedBytes-T-e<h&&i.length-_<=s)break;T+=e,_++}for(;T<x||_<y;){const t=i[_],e=l.get(t)||0;if(r.has(t)||this.cachedBytes-T-e<c&&_>=y)break;T+=e,_++}i.splice(0,_).forEach(t=>{this.cachedBytes-=l.get(t)||0,a.get(t)(t),l.delete(t),n.delete(t),a.delete(t),o.delete(t),r.delete(t)}),f=_<p||T<m&&_<u,f=f&&_>0}f&&(this.unloadingHandle=requestAnimationFrame(()=>this.scheduleUnload()))}scheduleUnload(){cancelAnimationFrame(this.unloadingHandle),this.scheduled||(this.scheduled=!0,queueMicrotask(()=>{this.scheduled=!1,this.unloadUnusedContent()}))}},u=class{get running(){return 0!==this.items.length||0!==this.currJobs}constructor(){this.maxJobs=6,this.items=[],this.callbacks=new Map,this.currJobs=0,this.scheduled=!1,this.autoUpdate=!0,this.priorityCallback=null,this.schedulingCallback=t=>{requestAnimationFrame(t)},this._runjobs=()=>{this.scheduled=!1,this.tryRunJobs()}}sort(){const t=this.priorityCallback,e=this.items;null!==t&&e.sort(t)}has(t){return this.callbacks.has(t)}add(t,e){const s={callback:e,reject:null,resolve:null,promise:null};return s.promise=new Promise((e,i)=>{const n=this.items,r=this.callbacks;s.resolve=e,s.reject=i,n.unshift(t),r.set(t,s),this.autoUpdate&&this.scheduleJobRun()}),s.promise}remove(t){const e=this.items,s=this.callbacks,i=e.indexOf(t);if(-1!==i){const n=s.get(t);n.promise.catch(()=>{}),n.reject(new Error("PriorityQueue: Item removed.")),e.splice(i,1),s.delete(t)}}removeByFilter(t){const{items:e}=this;for(let s=0;s<e.length;s++){const i=e[s];t(i)&&this.remove(i)}}tryRunJobs(){this.sort();const t=this.items,e=this.callbacks,s=this.maxJobs;let i=0;const n=()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()};for(;s>this.currJobs&&t.length>0&&i<s;){this.currJobs++,i++;const s=t.pop(),{callback:r,resolve:o,reject:a}=e.get(s);let l;e.delete(s);try{l=r(s)}catch(Y){a(Y),n()}l instanceof Promise?l.then(o).catch(a).finally(n):(o(l),n())}}scheduleJobRun(){this.scheduled||(this.schedulingCallback(this._runjobs),this.scheduled=!0)}};const d=-1,p=6378137;function m(t,e=null,s=null){const i=[];for(i.push(t),i.push(null),i.push(0);i.length>0;){const t=i.pop(),n=i.pop(),r=i.pop();if(e&&e(r,n,t))return void(s&&s(r,n,t));const o=r.children;if(o)for(let e=o.length-1;e>=0;e--)i.push(o[e]),i.push(r),i.push(t+1);s&&s(r,n,t)}}function g(t){if(null===t||t.byteLength<4)return"";let e;if(e=t instanceof DataView?t:new DataView(t),"{"===String.fromCharCode(e.getUint8(0)))return null;let s="";for(let i=0;i<4;i++)s+=String.fromCharCode(e.getUint8(i));return s}const f=new TextDecoder;function y(t){return f.decode(t)}function b(t){return t.replace(/[\\/][^\\/]+$/,"")+"/"}let x=class{constructor(){this.fetchOptions={},this.workingPath=""}load(...t){return console.warn('Loader: "load" function has been deprecated in favor of "loadAsync".'),this.loadAsync(...t)}loadAsync(t){return fetch(t,this.fetchOptions).then(e=>{if(!e.ok)throw new Error(`Failed to load file "${t}" with status ${e.status} : ${e.statusText}`);return e.arrayBuffer()}).then(e=>(""===this.workingPath&&(this.workingPath=b(t)),this.parse(e)))}resolveExternalURL(t){return new URL(t,this.workingPath).href}parse(t){throw new Error("LoaderBase: Parse not implemented.")}};function _(t){if(!t)return null;let e=t.length;const s=t.indexOf("?"),i=t.indexOf("#");-1!==s&&(e=Math.min(e,s)),-1!==i&&(e=Math.min(e,i));const n=t.lastIndexOf(".",e),r=t.lastIndexOf("/",e),o=t.indexOf("://");return-1!==o&&o+2===r||-1===n||n<r?null:t.substring(n+1,e)||null}const T={inView:!1,error:1/0,distanceFromCamera:1/0};function v(t){return 3===t||t===d}function w(t,e){return t.__lastFrameVisited===e&&t.__used}function P(t){return t.__childrenProcessed===t.children.length}function M(t,e){t.__lastFrameVisited!==e.frameCount&&(t.__lastFrameVisited=e.frameCount,t.__used=!1,t.__inFrustum=!1,t.__isLeaf=!1,t.__visible=!1,t.__active=!1,t.__error=1/0,t.__distanceFromCamera=1/0,t.__allChildrenLoaded=!1,e.calculateTileViewError(t,T),t.__inFrustum=T.inView,t.__error=T.error,t.__distanceFromCamera=T.distanceFromCamera)}function C(t,e){if(e.ensureChildrenArePreprocessed(t),M(t,e),A(t,e),t.__hasUnrenderableContent&&P(t)){const s=t.children;for(let t=0,i=s.length;t<i;t++)C(s[t],e)}}function S(t,e){if(e.ensureChildrenArePreprocessed(t),w(t,e.frameCount)&&(t.__hasContent&&e.queueTileForDownload(t),P(t))){const s=t.children;for(let t=0,i=s.length;t<i;t++)S(s[t],e)}}function A(t,e){t.__used||(t.__used=!0,e.markTileUsed(t),e.stats.used++,!0===t.__inFrustum&&e.stats.inFrustum++)}function E(t,e){if(e.ensureChildrenArePreprocessed(t),M(t,e),!t.__inFrustum)return;if(!function(t,e){return!(t.__error<=e.errorTarget&&!t.__hasUnrenderableContent||e.maxDepth>0&&t.__depth+1>=e.maxDepth||!P(t))}(t,e))return void A(t,e);let s=!1,i=!1;const n=t.children;for(let r=0,o=n.length;r<o;r++){const t=n[r];E(t,e),s=s||w(t,e.frameCount),i=i||t.__inFrustum}if(A(t,e),s&&"REPLACE"===t.refine&&(t.__depth,1))for(let r=0,o=n.length;r<o;r++){C(n[r],e)}}function L(t,e){const s=e.frameCount;if(!w(t,s))return;const i=t.children;let n=!1;for(let r=0,o=i.length;r<o;r++){const t=i[r];n=n||w(t,s)}if(n){let n=!0;for(let t=0,r=i.length;t<r;t++){const r=i[t];if(L(r,e),w(r,s)){const t=r.__allChildrenLoaded||!r.__hasContent||r.__hasRenderableContent&&v(r.__loadingState)||r.__hasUnrenderableContent&&r.__loadingState===d;n=n&&t}}t.__allChildrenLoaded=n}else t.__isLeaf=!0}function U(t,e){const s=e.stats;if(!w(t,e.frameCount))return;if(t.__isLeaf)return void(3===t.__loadingState?(t.__inFrustum&&(t.__visible=!0,s.visible++),t.__active=!0,s.active++):t.__hasContent&&e.queueTileForDownload(t));const i=t.children,n=t.__hasContent,r=v(t.__loadingState)&&n,o=(e.errorTarget+1)*e.errorThreshold,a=t.__error<=o,l="ADD"===t.refine,c=t.__allChildrenLoaded||0===t.__depth&&!1;if(n&&(a||l)&&e.queueTileForDownload(t),(a&&r&&!c||r&&l)&&(t.__inFrustum&&(t.__visible=!0,s.visible++),t.__active=!0,s.active++),l||!a||c)for(let h=0,u=i.length;h<u;h++)U(i[h],e);else for(let h=0,u=i.length;h<u;h++){const t=i[h];w(t,e.frameCount)&&S(t,e)}}function R(t,e){const s=w(t,e.frameCount);if(s||t.__usedLastFrame){let i=!1,n=!1;s?(i=t.__active,n=e.displayActiveTiles&&t.__active||t.__visible):M(t,e),t.__hasRenderableContent&&3===t.__loadingState&&(t.__wasSetActive!==i&&e.invokeOnePlugin(e=>e.setTileActive&&e.setTileActive(t,i)),t.__wasSetVisible!==n&&e.invokeOnePlugin(e=>e.setTileVisible&&e.setTileVisible(t,n))),t.__wasSetActive=i,t.__wasSetVisible=n,t.__usedLastFrame=s;const r=t.children;for(let t=0,s=r.length;t<s;t++){R(r[t],e)}}}const D=Symbol("PLUGIN_REGISTERED"),F=(t,e)=>{const s=t.priority||0,i=e.priority||0;return s!==i?s>i?1:-1:t.__used!==e.__used?t.__used?1:-1:t.__error!==e.__error?t.__error>e.__error?1:-1:t.__distanceFromCamera!==e.__distanceFromCamera?t.__distanceFromCamera>e.__distanceFromCamera?-1:1:t.__depthFromRenderedParent!==e.__depthFromRenderedParent?t.__depthFromRenderedParent>e.__depthFromRenderedParent?-1:1:0},I=(t,e)=>{const s=t.priority||0,i=e.priority||0;return s!==i?s>i?1:-1:t.__lastFrameVisited!==e.__lastFrameVisited?t.__lastFrameVisited>e.__lastFrameVisited?-1:1:t.__depthFromRenderedParent!==e.__depthFromRenderedParent?t.__depthFromRenderedParent>e.__depthFromRenderedParent?1:-1:t.__loadingState!==e.__loadingState?t.__loadingState>e.__loadingState?-1:1:t.__hasUnrenderableContent!==e.__hasUnrenderableContent?t.__hasUnrenderableContent?-1:1:t.__error!==e.__error?t.__error>e.__error?-1:1:0};let k=class{get root(){const t=this.rootTileSet;return t?t.root:null}get loadProgress(){const{stats:t,isLoading:e}=this,s=t.downloading+t.parsing,i=t.inCacheSinceLoad+(e?1:0);return 0===i?1:1-s/i}get errorThreshold(){return this._errorThreshold}set errorThreshold(t){console.warn('TilesRenderer: The "errorThreshold" option has been deprecated.'),this._errorThreshold=t}constructor(t=null){this.rootLoadingState=0,this.rootTileSet=null,this.rootURL=t,this.fetchOptions={},this.plugins=[],this.queuedTiles=[],this.cachedSinceLoadComplete=new Set,this.isLoading=!1;const e=new h;e.unloadPriorityCallback=I;const s=new u;s.maxJobs=25,s.priorityCallback=F;const i=new u;i.maxJobs=5,i.priorityCallback=F;const n=new u;n.maxJobs=25,this.processedTiles=new WeakSet,this.visibleTiles=new Set,this.activeTiles=new Set,this.usedSet=new Set,this.lruCache=e,this.downloadQueue=s,this.parseQueue=i,this.processNodeQueue=n,this.stats={inCacheSinceLoad:0,inCache:0,parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0,this._dispatchNeedsUpdateEvent=function(t){let e=null;return()=>{null===e&&(e=requestAnimationFrame(()=>{e=null,t()}))}}(()=>{this.dispatchEvent({type:"needs-update"})}),this.errorTarget=16,this._errorThreshold=1/0,this.displayActiveTiles=!1,this.maxDepth=1/0}registerPlugin(t){if(!0===t[D])throw new Error("TilesRendererBase: A plugin can only be registered to a single tile set");const e=this.plugins,s=t.priority||0;let i=e.length;for(let n=0;n<e.length;n++)if((e[n].priority||0)>s){i=n;break}e.splice(i,0,t),t[D]=!0,t.init&&t.init(this)}unregisterPlugin(t){const e=this.plugins;if("string"==typeof t&&(t=this.getPluginByName(name)),e.includes(t)){const s=e.indexOf(t);return e.splice(s,1),t.dispose&&t.dispose(),!0}return!1}getPluginByName(t){return this.plugins.find(e=>e.name===t)||null}traverse(t,e,s=!0){this.root&&m(this.root,(e,...i)=>(s&&this.ensureChildrenArePreprocessed(e,!0),!!t&&t(e,...i)),e)}queueTileForDownload(t){0!==t.__loadingState||this.lruCache.isFull()||this.queuedTiles.push(t)}markTileUsed(t){this.usedSet.add(t),this.lruCache.markUsed(t)}update(){const{lruCache:t,usedSet:e,stats:s,root:i,downloadQueue:n,parseQueue:r,processNodeQueue:o}=this;if(0===this.rootLoadingState&&(this.rootLoadingState=1,this.invokeOnePlugin(t=>t.loadRootTileSet&&t.loadRootTileSet()).then(t=>{let e=this.rootURL;null!==e&&this.invokeAllPlugins(t=>e=t.preprocessURL?t.preprocessURL(e,null):e),this.rootLoadingState=3,this.rootTileSet=t,this.dispatchEvent({type:"needs-update"}),this.dispatchEvent({type:"load-content"}),this.dispatchEvent({type:"load-tile-set",tileSet:t,url:e})}).catch(t=>{this.rootLoadingState=d,console.error(t),this.rootTileSet=null,this.dispatchEvent({type:"load-error",tile:null,error:t,url:this.rootURL})})),!i)return;s.inFrustum=0,s.used=0,s.active=0,s.visible=0,this.frameCount++,e.forEach(e=>t.markUnused(e)),e.clear(),E(i,this),L(i,this),U(i,this),R(i,this);const a=this.queuedTiles;a.sort(t.unloadPriorityCallback);for(let l=0,c=a.length;l<c&&!t.isFull();l++)this.requestTileContents(a[l]);a.length=0,t.scheduleUnload(),!1===(n.running||r.running||o.running)&&!0===this.isLoading&&(this.cachedSinceLoadComplete.clear(),s.inCacheSinceLoad=0,this.dispatchEvent({type:"tiles-load-end"}),this.isLoading=!1)}resetFailedTiles(){this.rootLoadingState===d&&(this.rootLoadingState=0);const t=this.stats;0!==t.failed&&(this.traverse(t=>{t.__loadingState===d&&(t.__loadingState=0)},null,!1),t.failed=0)}dispose(){[...this.plugins].forEach(t=>{this.unregisterPlugin(t)});const t=this.lruCache,e=[];this.traverse(t=>(e.push(t),!1),null,!1);for(let s=0,i=e.length;s<i;s++)t.remove(e[s]);this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0}calculateBytesUsed(t,e){return 0}dispatchEvent(t){}fetchData(t,e){return fetch(t,e)}parseTile(t,e,s){return null}disposeTile(t){t.__visible&&(this.invokeOnePlugin(e=>e.setTileVisible&&e.setTileVisible(t,!1)),t.__visible=!1),t.__active&&(this.invokeOnePlugin(e=>e.setTileActive&&e.setTileActive(t,!1)),t.__active=!1)}preprocessNode(t,e,s=null){var i;if(this.processedTiles.add(t),t.content&&(!("uri"in t.content)&&"url"in t.content&&(t.content.uri=t.content.url,delete t.content.url),t.content.boundingVolume&&!("box"in t.content.boundingVolume||"sphere"in t.content.boundingVolume||"region"in t.content.boundingVolume)&&delete t.content.boundingVolume),t.parent=s,t.children=t.children||[],null!=(i=t.content)&&i.uri){const e=_(t.content.uri);t.__hasContent=!0,t.__hasUnrenderableContent=!(!e||!/json$/.test(e)),t.__hasRenderableContent=!t.__hasUnrenderableContent}else t.__hasContent=!1,t.__hasUnrenderableContent=!1,t.__hasRenderableContent=!1;t.__childrenProcessed=0,s&&s.__childrenProcessed++,t.__distanceFromCamera=1/0,t.__error=1/0,t.__inFrustum=!1,t.__isLeaf=!1,t.__usedLastFrame=!1,t.__used=!1,t.__wasSetVisible=!1,t.__visible=!1,t.__allChildrenLoaded=!1,t.__wasSetActive=!1,t.__active=!1,t.__loadingState=0,null===s?(t.__depth=0,t.__depthFromRenderedParent=t.__hasRenderableContent?1:0,t.refine=t.refine||"REPLACE"):(t.__depth=s.__depth+1,t.__depthFromRenderedParent=s.__depthFromRenderedParent+(t.__hasRenderableContent?1:0),t.refine=t.refine||s.refine),t.__basePath=e,t.__lastFrameVisited=-1,this.invokeAllPlugins(i=>{i!==this&&i.preprocessNode&&i.preprocessNode(t,e,s)})}setTileActive(t,e){e?this.activeTiles.add(t):this.activeTiles.delete(t)}setTileVisible(t,e){e?this.visibleTiles.add(t):this.visibleTiles.delete(t)}calculateTileViewError(t,e){}ensureChildrenArePreprocessed(t,e=!1){const s=t.children;for(let i=0,n=s.length;i<n;i++){const n=s[i];if("__depth"in n)break;e?(this.processNodeQueue.remove(n),this.preprocessNode(n,t.__basePath,t)):this.processNodeQueue.has(n)||this.processNodeQueue.add(n,e=>{this.preprocessNode(e,t.__basePath,t),this._dispatchNeedsUpdateEvent()})}}getBytesUsed(t){let e=0;return this.invokeAllPlugins(s=>{s.calculateBytesUsed&&(e+=s.calculateBytesUsed(t,t.cached.scene)||0)}),e}recalculateBytesUsed(t=null){const{lruCache:e,processedTiles:s}=this;null===t?e.itemSet.forEach(t=>{s.has(t)&&e.setMemoryUsage(t,this.getBytesUsed(t))}):e.setMemoryUsage(t,this.getBytesUsed(t))}preprocessTileSet(t,e,s=null){const i=t.asset.version,[n,r]=i.split(".").map(t=>parseInt(t));console.assert(n<=1,"TilesRenderer: asset.version is expected to be a 1.x or a compatible version."),1===n&&r>0&&console.warn("TilesRenderer: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.");let o=e.replace(/\/[^/]*$/,"");o=new URL(o,window.location.href).toString(),this.preprocessNode(t.root,o,s)}loadRootTileSet(){let t=this.rootURL;return this.invokeAllPlugins(e=>t=e.preprocessURL?e.preprocessURL(t,null):t),this.invokeOnePlugin(e=>e.fetchData&&e.fetchData(t,this.fetchOptions)).then(e=>{if(e instanceof Response){if(e.ok)return e.json();throw new Error(`TilesRenderer: Failed to load tileset "${t}" with status ${e.status} : ${e.statusText}`)}return e}).then(e=>(this.preprocessTileSet(e,t),e))}requestTileContents(t){if(0!==t.__loadingState)return;let e=!1,s=null,i=new URL(t.content.uri,t.__basePath+"/").toString();this.invokeAllPlugins(e=>i=e.preprocessURL?e.preprocessURL(i,t):i);const n=this.stats,r=this.lruCache,o=this.downloadQueue,a=this.parseQueue,l=_(i),c=new AbortController,h=c.signal;return r.add(t,s=>{c.abort(),e?(s.children.length=0,s.__childrenProcessed=0):this.invokeAllPlugins(t=>{t.disposeTile&&t.disposeTile(s)}),n.inCache--,this.cachedSinceLoadComplete.has(t)&&(this.cachedSinceLoadComplete.delete(t),n.inCacheSinceLoad--),1===s.__loadingState?n.downloading--:2===s.__loadingState&&n.parsing--,s.__loadingState=0,a.remove(s),o.remove(s)})?(this.isLoading||(this.isLoading=!0,this.dispatchEvent({type:"tiles-load-start"})),r.setMemoryUsage(t,this.getBytesUsed(t)),this.cachedSinceLoadComplete.add(t),n.inCacheSinceLoad++,n.inCache++,n.downloading++,t.__loadingState=1,o.add(t,e=>{if(h.aborted)return Promise.resolve();const s=this.invokeOnePlugin(t=>t.fetchData&&t.fetchData(i,{...this.fetchOptions,signal:h}));return this.dispatchEvent({type:"tile-download-start",tile:t}),s}).then(t=>{if(!h.aborted){if(t instanceof Response){if(t.ok)return"json"===l?t.json():t.arrayBuffer();throw new Error(`Failed to load model with error code ${t.status}`)}return t}}).then(r=>{if(!h.aborted)return n.downloading--,n.parsing++,t.__loadingState=2,a.add(t,n=>h.aborted?Promise.resolve():"json"===l&&r.root?(this.preprocessTileSet(r,i,t),t.children.push(r.root),s=r,e=!0,Promise.resolve()):this.invokeOnePlugin(t=>t.parseTile&&t.parseTile(r,n,l,i,h)))}).then(()=>{if(h.aborted)return;n.parsing--,t.__loadingState=3,r.setLoaded(t,!0);const o=this.getBytesUsed(t);0===r.getMemoryUsage(t)&&o>0&&r.isFull()?r.remove(t):(r.setMemoryUsage(t,o),this.dispatchEvent({type:"needs-update"}),this.dispatchEvent({type:"load-content"}),e&&this.dispatchEvent({type:"load-tile-set",tileSet:s,url:i}),t.cached.scene&&this.dispatchEvent({type:"load-model",scene:t.cached.scene,tile:t}))}).catch(e=>{h.aborted||("AbortError"!==e.name?(a.remove(t),o.remove(t),2===t.__loadingState?n.parsing--:1===t.__loadingState&&n.downloading--,n.failed++,console.error(`TilesRenderer : Failed to load tile at url "${t.content.uri}".`),console.error(e),t.__loadingState=d,r.setLoaded(t,!0),this.dispatchEvent({type:"load-error",tile:t,error:e,url:i})):r.remove(t))})):void 0}getAttributions(t=[]){return this.invokeAllPlugins(e=>e!==this&&e.getAttributions&&e.getAttributions(t)),t}invokeOnePlugin(t){const e=[...this.plugins,this];for(let s=0;s<e.length;s++){const i=t(e[s]);if(i)return i}return null}invokeAllPlugins(t){const e=[...this.plugins,this],s=[];for(let i=0;i<e.length;i++){const n=t(e[i]);n&&s.push(n)}return 0===s.length?null:Promise.all(s)}};function O(t,e,s,i,n,r){let o,a;switch(i){case"SCALAR":o=1;break;case"VEC2":o=2;break;case"VEC3":o=3;break;case"VEC4":o=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${r}".`)}const l=s*o;switch(n){case"BYTE":a=new Int8Array(t,e,l);break;case"UNSIGNED_BYTE":a=new Uint8Array(t,e,l);break;case"SHORT":a=new Int16Array(t,e,l);break;case"UNSIGNED_SHORT":a=new Uint16Array(t,e,l);break;case"INT":a=new Int32Array(t,e,l);break;case"UNSIGNED_INT":a=new Uint32Array(t,e,l);break;case"FLOAT":a=new Float32Array(t,e,l);break;case"DOUBLE":a=new Float64Array(t,e,l);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${r}".`)}return a}class V{constructor(t,e,s,i){this.buffer=t,this.binOffset=e+s,this.binLength=i;let n=null;if(0!==s){const i=new Uint8Array(t,e,s);n=JSON.parse(y(i))}else n={};this.header=n}getKeys(){return Object.keys(this.header).filter(t=>"extensions"!==t)}getData(t,e,s=null,i=null){const n=this.header;if(!(t in n))return null;const r=n[t];if(r instanceof Object){if(Array.isArray(r))return r;{const{buffer:n,binOffset:o,binLength:a}=this,l=r.byteOffset||0,c=r.type||i,h=r.componentType||s;if("type"in r&&i&&r.type!==i)throw new Error("FeatureTable: Specified type does not match expected type.");const u=o+l,d=O(n,u,e,c,h,t);if(u+d.byteLength>o+a)throw new Error("FeatureTable: Feature data read outside binary body length.");return d}}return r}getBuffer(t,e){const{buffer:s,binOffset:i}=this;return s.slice(i+t,i+t+e)}}let z=class{constructor(t){this.batchTable=t;const e=t.header.extensions["3DTILES_batch_table_hierarchy"];this.classes=e.classes;for(const i of this.classes){const t=i.instances;for(const e in t)i.instances[e]=this._parseProperty(t[e],i.length,e)}if(this.instancesLength=e.instancesLength,this.classIds=this._parseProperty(e.classIds,this.instancesLength,"classIds"),e.parentCounts?this.parentCounts=this._parseProperty(e.parentCounts,this.instancesLength,"parentCounts"):this.parentCounts=new Array(this.instancesLength).fill(1),e.parentIds){const t=this.parentCounts.reduce((t,e)=>t+e,0);this.parentIds=this._parseProperty(e.parentIds,t,"parentIds")}else this.parentIds=null;this.instancesIds=[];const s={};for(const i of this.classIds)s[i]=s[i]??0,this.instancesIds.push(s[i]),s[i]++}_parseProperty(t,e,s){if(Array.isArray(t))return t;{const{buffer:i,binOffset:n}=this.batchTable;return O(i,n+t.byteOffset,e,"SCALAR",t.componentType||"UNSIGNED_SHORT",s)}}getDataFromId(t,e={}){const s=this.parentCounts[t];if(this.parentIds&&s>0){let i=0;for(let e=0;e<t;e++)i+=this.parentCounts[e];for(let n=0;n<s;n++){const s=this.parentIds[i+n];s!==t&&this.getDataFromId(s,e)}}const i=this.classIds[t],n=this.classes[i].instances,r=this.classes[i].name,o=this.instancesIds[t];for(const a in n)e[r]=e[r]||{},e[r][a]=n[a][o];return e}},B=class extends V{get batchSize(){return console.warn("BatchTable.batchSize has been deprecated and replaced with BatchTable.count."),this.count}constructor(t,e,s,i,n){super(t,s,i,n),this.count=e,this.extensions={};const r=this.header.extensions;r&&r["3DTILES_batch_table_hierarchy"]&&(this.extensions["3DTILES_batch_table_hierarchy"]=new z(this))}getData(t,e=null,s=null){return console.warn("BatchTable: BatchTable.getData is deprecated. Use BatchTable.getDataFromId to get allproperties for an id or BatchTable.getPropertyArray for getting an array of value for a property."),super.getData(t,this.count,e,s)}getDataFromId(t,e={}){if(t<0||t>=this.count)throw new Error(`BatchTable: id value "${t}" out of bounds for "${this.count}" features number.`);for(const s of this.getKeys())e[s]=super.getData(s,this.count)[t];for(const s in this.extensions){const i=this.extensions[s];i.getDataFromId instanceof Function&&(e[s]=e[s]||{},i.getDataFromId(t,e[s]))}return e}getPropertyArray(t){return super.getData(t,this.count)}},N=class extends x{parse(t){const e=new DataView(t),s=g(e);console.assert("b3dm"===s);const i=e.getUint32(4,!0);console.assert(1===i);const n=e.getUint32(8,!0);console.assert(n===t.byteLength);const r=e.getUint32(12,!0),o=e.getUint32(16,!0),a=e.getUint32(20,!0),l=e.getUint32(24,!0),c=t.slice(28,28+r+o),h=new V(c,0,r,o),u=28+r+o,d=t.slice(u,u+a+l),p=new B(d,h.getData("BATCH_LENGTH"),0,a,l),m=u+a+l;return{version:i,featureTable:h,batchTable:p,glbBytes:new Uint8Array(t,m,n-m)}}},j=class extends x{parse(t){const e=new DataView(t),s=g(e);console.assert("i3dm"===s);const i=e.getUint32(4,!0);console.assert(1===i);const n=e.getUint32(8,!0);console.assert(n===t.byteLength);const r=e.getUint32(12,!0),o=e.getUint32(16,!0),a=e.getUint32(20,!0),l=e.getUint32(24,!0),c=e.getUint32(28,!0),h=t.slice(32,32+r+o),u=new V(h,0,r,o),d=32+r+o,p=t.slice(d,d+a+l),m=new B(p,u.getData("INSTANCES_LENGTH"),0,a,l),f=d+a+l,x=new Uint8Array(t,f,n-f);let _=null,T=null,v=null;if(c)_=x,T=Promise.resolve();else{const t=this.resolveExternalURL(y(x));v=b(t),T=fetch(t,this.fetchOptions).then(e=>{if(!e.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${t}" with status ${e.status} : ${e.statusText}`);return e.arrayBuffer()}).then(t=>{_=new Uint8Array(t)})}return T.then(()=>({version:i,featureTable:u,batchTable:m,glbBytes:_,gltfWorkingPath:v}))}},W=class extends x{parse(t){const e=new DataView(t),s=g(e);console.assert("pnts"===s);const i=e.getUint32(4,!0);console.assert(1===i);const n=e.getUint32(8,!0);console.assert(n===t.byteLength);const r=e.getUint32(12,!0),o=e.getUint32(16,!0),a=e.getUint32(20,!0),l=e.getUint32(24,!0),c=t.slice(28,28+r+o),h=new V(c,0,r,o),u=28+r+o,d=t.slice(u,u+a+l),p=new B(d,h.getData("BATCH_LENGTH")||h.getData("POINTS_LENGTH"),0,a,l);return Promise.resolve({version:i,featureTable:h,batchTable:p})}},G=class extends x{parse(t){const e=new DataView(t),s=g(e);console.assert("cmpt"===s,'CMPTLoader: The magic bytes equal "cmpt".');const i=e.getUint32(4,!0);console.assert(1===i,'CMPTLoader: The version listed in the header is "1".');const n=e.getUint32(8,!0);console.assert(n===t.byteLength,"CMPTLoader: The contents buffer length listed in the header matches the file.");const r=e.getUint32(12,!0),o=[];let a=16;for(let l=0;l<r;l++){const e=new DataView(t,a,12),s=g(e),i=e.getUint32(4,!0),n=e.getUint32(8,!0),r=new Uint8Array(t,a,n);o.push({type:s,buffer:r,version:i}),a+=n}return{version:i,tiles:o}}};const H=await a("three"),{MathUtils:q,Spherical:Z,Vector3:Y,Matrix4:$,Sphere:X,Ray:Q,Euler:J,Box3:K,Plane:tt}=await a("three");new Z,new Y;const et=new Z,st=new Y,it=new Y,nt=new Y,rt=new $,ot=new $,at=new $,lt=new X,ct=new J,ht=new Y,ut=new Y,dt=new Y,pt=new Y,mt=new Q;let gt=class{constructor(t=1,e=1,s=1){this.name="",this.radius=new Y(t,e,s)}intersectRay(t,e){return rt.makeScale(...this.radius).invert(),lt.center.set(0,0,0),lt.radius=1,mt.copy(t).applyMatrix4(rt),mt.intersectSphere(lt,e)?(rt.makeScale(...this.radius),e.applyMatrix4(rt),e):null}getEastNorthUpFrame(t,e,s,i){return s.isMatrix4&&(i=s,s=0,console.warn('Ellipsoid: The signature for "getEastNorthUpFrame" has changed.')),this.getEastNorthUpAxes(t,e,ht,ut,dt),this.getCartographicToPosition(t,e,s,pt),i.makeBasis(ht,ut,dt).setPosition(pt)}getOrientedEastNorthUpFrame(t,e,s,i,n,r,o){return this.getObjectFrame(t,e,s,i,n,r,o,0)}getObjectFrame(t,e,s,i,n,r,o,a=2){return this.getEastNorthUpFrame(t,e,s,rt),ct.set(n,r,-i,"ZXY"),o.makeRotationFromEuler(ct).premultiply(rt),1===a?(ct.set(Math.PI/2,0,0,"XYZ"),ot.makeRotationFromEuler(ct),o.multiply(ot)):2===a&&(ct.set(-Math.PI/2,0,Math.PI,"XYZ"),ot.makeRotationFromEuler(ct),o.multiply(ot)),o}getCartographicFromObjectFrame(t,e,s=2){return 1===s?(ct.set(-Math.PI/2,0,0,"XYZ"),ot.makeRotationFromEuler(ct).premultiply(t)):2===s?(ct.set(-Math.PI/2,0,Math.PI,"XYZ"),ot.makeRotationFromEuler(ct).premultiply(t)):ot.copy(t),pt.setFromMatrixPosition(ot),this.getPositionToCartographic(pt,e),this.getEastNorthUpFrame(e.lat,e.lon,0,rt).invert(),ot.premultiply(rt),ct.setFromRotationMatrix(ot,"ZXY"),e.azimuth=-ct.z,e.elevation=ct.x,e.roll=ct.y,e}getEastNorthUpAxes(t,e,s,i,n,r=pt){this.getCartographicToPosition(t,e,0,r),this.getCartographicToNormal(t,e,n),s.set(-r.y,r.x,0).normalize(),i.crossVectors(n,s).normalize()}getAzElRollFromRotationMatrix(t,e,s,i,n=0){return console.warn('Ellipsoid: "getAzElRollFromRotationMatrix" is deprecated. Use "getCartographicFromObjectFrame", instead.'),this.getCartographicToPosition(t,e,0,pt),at.copy(s).setPosition(pt),this.getCartographicFromObjectFrame(at,i,n),delete i.height,delete i.lat,delete i.lon,i}getRotationMatrixFromAzElRoll(t,e,s,i,n,r,o=0){return console.warn('Ellipsoid: "getRotationMatrixFromAzElRoll" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(t,e,0,s,i,n,r,o),r.setPosition(0,0,0),r}getFrame(t,e,s,i,n,r,o,a=0){return console.warn('Ellipsoid: "getFrame" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(t,e,r,s,i,n,o,a)}getCartographicToPosition(t,e,s,i){this.getCartographicToNormal(t,e,st);const n=this.radius;it.copy(st),it.x*=n.x**2,it.y*=n.y**2,it.z*=n.z**2;const r=Math.sqrt(st.dot(it));return it.divideScalar(r),i.copy(it).addScaledVector(st,s)}getPositionToCartographic(t,e){this.getPositionToSurfacePoint(t,it),this.getPositionToNormal(t,st);const s=nt.subVectors(t,it);return e.lon=Math.atan2(st.y,st.x),e.lat=Math.asin(st.z),e.height=Math.sign(s.dot(t))*s.length(),e}getCartographicToNormal(t,e,s){return et.set(1,-t+Math.PI/2,e),s.setFromSpherical(et).normalize(),function(t){const{x:e,y:s,z:i}=t;t.x=i,t.y=e,t.z=s}(s),s}getPositionToNormal(t,e){const s=this.radius;return e.copy(t),e.x/=s.x**2,e.y/=s.y**2,e.z/=s.z**2,e.normalize(),e}getPositionToSurfacePoint(t,e){const s=this.radius,i=1/s.x**2,n=1/s.y**2,r=1/s.z**2,o=t.x*t.x*i,a=t.y*t.y*n,l=t.z*t.z*r,c=o+a+l,h=Math.sqrt(1/c),u=it.copy(t).multiplyScalar(h);if(c<.1)return isFinite(h)?e.copy(u):null;const d=nt.set(u.x*i*2,u.y*n*2,u.z*r*2);let p,m,g,f,y,b,x,_,T,v,w,P=(1-h)*t.length()/(.5*d.length()),M=0;do{P-=M,g=1/(1+P*i),f=1/(1+P*n),y=1/(1+P*r),b=g*g,x=f*f,_=y*y,T=b*g,v=x*f,w=_*y,p=o*b+a*x+l*_-1,m=o*T*i+a*v*n+l*w*r;M=p/(-2*m)}while(Math.abs(p)>1e-12);return e.set(t.x*g,t.y*f,t.z*y)}calculateHorizonDistance(t,e){const s=this.calculateEffectiveRadius(t);return Math.sqrt(2*s*e+e**2)}calculateEffectiveRadius(t){const e=this.radius.x,s=1-this.radius.z**2/e**2,i=t*q.DEG2RAD,n=Math.sin(i)**2;return e/Math.sqrt(1-s*n)}getPositionElevation(t){this.getPositionToSurfacePoint(t,it);const e=nt.subVectors(t,it);return Math.sign(e.dot(t))*e.length()}closestPointToRayEstimate(t,e){return this.intersectRay(t,e)?e:(rt.makeScale(...this.radius).invert(),mt.copy(t).applyMatrix4(rt),it.set(0,0,0),mt.closestPointToPoint(it,e).normalize(),rt.makeScale(...this.radius),e.applyMatrix4(rt))}copy(t){return this.radius.copy(t.radius),this}clone(){return(new this.constructor).copy(this)}};const ft=new Y,yt=new Y,bt=new Y,xt=new Q;let _t=class{constructor(t=new K,e=new $){this.box=t.clone(),this.transform=e.clone(),this.inverseTransform=new $,this.points=new Array(8).fill().map(()=>new Y),this.planes=new Array(6).fill().map(()=>new tt)}copy(t){return this.box.copy(t.box),this.transform.copy(t.transform),this.update(),this}clone(){return(new this.constructor).copy(this)}clampPoint(t,e){return e.copy(t).applyMatrix4(this.inverseTransform).clamp(this.box.min,this.box.max).applyMatrix4(this.transform)}distanceToPoint(t){return this.clampPoint(t,bt).distanceTo(t)}containsPoint(t){return bt.copy(t).applyMatrix4(this.inverseTransform),this.box.containsPoint(bt)}intersectsRay(t){return xt.copy(t).applyMatrix4(this.inverseTransform),xt.intersectsBox(this.box)}intersectRay(t,e){return xt.copy(t).applyMatrix4(this.inverseTransform),xt.intersectBox(this.box,e)?(e.applyMatrix4(this.transform),e):null}update(){const{points:t,inverseTransform:e,transform:s,box:i}=this;e.copy(s).invert();const{min:n,max:r}=i;let o=0;for(let a=-1;a<=1;a+=2)for(let e=-1;e<=1;e+=2)for(let i=-1;i<=1;i+=2)t[o].set(a<0?n.x:r.x,e<0?n.y:r.y,i<0?n.z:r.z).applyMatrix4(s),o++;this.updatePlanes()}updatePlanes(){ft.copy(this.box.min).applyMatrix4(this.transform),yt.copy(this.box.max).applyMatrix4(this.transform),bt.set(0,0,1).transformDirection(this.transform),this.planes[0].setFromNormalAndCoplanarPoint(bt,ft),this.planes[1].setFromNormalAndCoplanarPoint(bt,yt).negate(),bt.set(0,1,0).transformDirection(this.transform),this.planes[2].setFromNormalAndCoplanarPoint(bt,ft),this.planes[3].setFromNormalAndCoplanarPoint(bt,yt).negate(),bt.set(1,0,0).transformDirection(this.transform),this.planes[4].setFromNormalAndCoplanarPoint(bt,ft),this.planes[5].setFromNormalAndCoplanarPoint(bt,yt).negate()}intersectsSphere(t){return this.clampPoint(t.center,bt),bt.distanceToSquared(t.center)<=t.radius*t.radius}intersectsFrustum(t){return this._intersectsPlaneShape(t.planes,t.points)}intersectsOBB(t){return this._intersectsPlaneShape(t.planes,t.points)}_intersectsPlaneShape(t,e){const s=this.points,i=this.planes;for(let n=0;n<6;n++){const e=t[n];let i=-1/0;for(let t=0;t<8;t++){const n=s[t],r=e.distanceToPoint(n);i=i<r?r:i}if(i<0)return!1}for(let n=0;n<6;n++){const t=i[n];let s=-1/0;for(let i=0;i<8;i++){const n=e[i],r=t.distanceToPoint(n);s=s<r?r:s}if(s<0)return!1}return!0}};const Tt=Math.PI,vt=Tt/2,wt=new Y,Pt=new Y,Mt=new Y,Ct=new $;let St=0;const At=[];function Et(t=!1){return t?(At[St]||(At[St]=new Y),St++,At[St-1]):new Y}function Lt(){St=0}let Ut=class extends gt{constructor(t,e,s,i=-vt,n=vt,r=0,o=2*Tt,a=0,l=0){super(t,e,s),this.latStart=i,this.latEnd=n,this.lonStart=r,this.lonEnd=o,this.heightStart=a,this.heightEnd=l}_getPoints(t=!1){const{latStart:e,latEnd:s,lonStart:i,lonEnd:n,heightStart:r,heightEnd:o}=this,a=q.mapLinear(.5,0,1,e,s),l=q.mapLinear(.5,0,1,i,n),c=Math.floor(i/vt)*vt,h=[[-Tt/2,0],[Tt/2,0],[0,c],[0,c+Tt/2],[0,c+Tt],[0,c+3*Tt/2],[e,n],[s,n],[e,i],[s,i],[0,i],[0,n],[a,l],[e,l],[s,l],[a,i],[a,n]],u=[],d=h.length;for(let p=0;p<=1;p++){const a=q.mapLinear(p,0,1,r,o);for(let r=0,o=d;r<o;r++){const[o,l]=h[r];if(o>=e&&o<=s&&l>=i&&l<=n){const e=Et(t);u.push(e),this.getCartographicToPosition(o,l,a,e)}}}return u}getBoundingBox(t,e){Lt();const{latStart:s,latEnd:i,lonStart:n,lonEnd:r}=this;if(i-s<Tt/2){const t=q.mapLinear(.5,0,1,s,i),o=q.mapLinear(.5,0,1,n,r);this.getCartographicToNormal(t,o,Mt),Pt.set(0,0,1),wt.crossVectors(Pt,Mt),Pt.crossVectors(wt,Mt),e.makeBasis(wt,Pt,Mt)}else wt.set(1,0,0),Pt.set(0,1,0),Mt.set(0,0,1),e.makeBasis(wt,Pt,Mt);Ct.copy(e).invert();const o=this._getPoints(!0);for(let a=0,l=o.length;a<l;a++)o[a].applyMatrix4(Ct);t.makeEmpty(),t.setFromPoints(o)}getBoundingSphere(t,e){Lt();const s=this._getPoints(!0);t.makeEmpty(),t.setFromPoints(s,e)}};function Rt(t){const{TextureUtils:e}=H;if(!e||!t)return 0;const{format:s,type:i,image:n}=t,{width:r,height:o}=n;let a=e.getByteLength(r,o,s,i);return a*=t.generateMipmaps?4/3:1,a}const{DefaultLoadingManager:Dt,Matrix4:Ft,Vector3:It,Vector2:kt,MathUtils:Ot,PointsMaterial:Vt,BufferGeometry:zt,BufferAttribute:Bt,Color:Nt,Points:jt,InstancedMesh:Wt,Quaternion:Gt,Group:Ht,Ray:qt,Sphere:Zt,Frustum:Yt,Matrix3:$t,LoadingManager:Xt,EventDispatcher:Qt,Euler:Jt,Mesh:Kt,PlaneGeometry:te,ShaderMaterial:ee,Plane:se,Raycaster:ie,Clock:ne,PerspectiveCamera:re,OrthographicCamera:oe}=await a("three");let ae=class extends N{constructor(t=Dt){super(),this.manager=t,this.adjustmentTransform=new Ft}parse(t){const s=super.parse(t),i=s.glbBytes.slice().buffer;return new Promise((t,n)=>{const r=this.manager,o=this.fetchOptions,a=r.getHandler("path.gltf")||new e(r);"include"===o.credentials&&"cors"===o.mode&&a.setCrossOrigin("use-credentials"),"credentials"in o&&a.setWithCredentials("include"===o.credentials),o.headers&&a.setRequestHeader(o.headers);let l=this.workingPath;!/[\\/]$/.test(l)&&l.length&&(l+="/");const c=this.adjustmentTransform;a.parse(i,l,e=>{const{batchTable:i,featureTable:n}=s,{scene:r}=e,o=n.getData("RTC_CENTER",1,"FLOAT","VEC3");o&&(r.position.x+=o[0],r.position.y+=o[1],r.position.z+=o[2]),e.scene.updateMatrix(),e.scene.matrix.multiply(c),e.scene.matrix.decompose(e.scene.position,e.scene.quaternion,e.scene.scale),e.batchTable=i,e.featureTable=n,r.batchTable=i,r.featureTable=n,t(e)},n)})}};function le(t){const e=t>>11,s=t>>5&63,i=31&t;return[Math.round(e/31*255),Math.round(s/63*255),Math.round(i/31*255)]}const ce=new kt;function he(t,e,s=new It){ce.set(t,e).divideScalar(256).multiplyScalar(2).subScalar(1),s.set(ce.x,ce.y,1-Math.abs(ce.x)-Math.abs(ce.y));const i=Ot.clamp(-s.z,0,1);return s.x>=0?s.setX(s.x-i):s.setX(s.x+i),s.y>=0?s.setY(s.y-i):s.setY(s.y+i),s.normalize(),s}const ue={RGB:"color",POSITION:"position"};class de extends W{constructor(t=Dt){super(),this.manager=t}parse(t){return super.parse(t).then(async t=>{const{featureTable:e,batchTable:s}=t,i=new Vt,n=e.header.extensions,r=new It;let o;if(n&&n["3DTILES_draco_point_compression"]){const{byteOffset:t,byteLength:s,properties:r}=n["3DTILES_draco_point_compression"],a=this.manager.getHandler("draco.drc");if(null==a)throw new Error("PNTSLoader: dracoLoader not available.");const l={};for(const e in r)if(e in ue&&e in r){l[ue[e]]=r[e]}const c={attributeIDs:l,attributeTypes:{position:"Float32Array",color:"Uint8Array"},useUniqueIDs:!0},h=e.getBuffer(t,s);o=await a.decodeGeometry(h,c),o.attributes.color&&(i.vertexColors=!0)}else{const t=e.getData("POINTS_LENGTH"),s=e.getData("POSITION",t,"FLOAT","VEC3"),n=e.getData("NORMAL",t,"FLOAT","VEC3"),a=e.getData("NORMAL",t,"UNSIGNED_BYTE","VEC2"),l=e.getData("RGB",t,"UNSIGNED_BYTE","VEC3"),c=e.getData("RGBA",t,"UNSIGNED_BYTE","VEC4"),h=e.getData("RGB565",t,"UNSIGNED_SHORT","SCALAR"),u=e.getData("CONSTANT_RGBA",t,"UNSIGNED_BYTE","VEC4"),d=e.getData("POSITION_QUANTIZED",t,"UNSIGNED_SHORT","VEC3"),p=e.getData("QUANTIZED_VOLUME_SCALE",t,"FLOAT","VEC3"),m=e.getData("QUANTIZED_VOLUME_OFFSET",t,"FLOAT","VEC3");if(o=new zt,d){const e=new Float32Array(3*t);for(let s=0;s<t;s++)for(let t=0;t<3;t++){const i=3*s+t;e[i]=d[i]/65535*p[t]}r.x=m[0],r.y=m[1],r.z=m[2],o.setAttribute("position",new Bt(e,3,!1))}else o.setAttribute("position",new Bt(s,3,!1));if(null!==n)o.setAttribute("normal",new Bt(n,3,!1));else if(null!==a){const e=new Float32Array(3*t),s=new It;for(let i=0;i<t;i++){const t=he(a[2*i],a[2*i+1],s);e[3*i]=t.x,e[3*i+1]=t.y,e[3*i+2]=t.z}o.setAttribute("normal",new Bt(e,3,!1))}if(null!==c)o.setAttribute("color",new Bt(c,4,!0)),i.vertexColors=!0,i.transparent=!0,i.depthWrite=!1;else if(null!==l)o.setAttribute("color",new Bt(l,3,!0)),i.vertexColors=!0;else if(null!==h){const e=new Uint8Array(3*t);for(let s=0;s<t;s++){const t=le(h[s]);for(let i=0;i<3;i++){e[3*s+i]=t[i]}}o.setAttribute("color",new Bt(e,3,!0)),i.vertexColors=!0}else if(null!==u){const t=new Nt(u[0],u[1],u[2]);i.color=t;const e=u[3]/255;e<1&&(i.opacity=e,i.transparent=!0,i.depthWrite=!1)}}const a=new jt(o,i);a.position.copy(r),t.scene=a,t.scene.featureTable=e,t.scene.batchTable=s;const l=e.getData("RTC_CENTER",1,"FLOAT","VEC3");return l&&(t.scene.position.x+=l[0],t.scene.position.y+=l[1],t.scene.position.z+=l[2]),t})}}const pe=new gt(p,p,6356752.314245179);pe.name="WGS84 Earth";const me=new It,ge=new It,fe=new It,ye=new It,be=new Gt,xe=new It,_e=new Ft,Te=new Ft,ve=new It,we=new Ft,Pe=new Gt,Me={};let Ce=class extends j{constructor(t=Dt){super(),this.manager=t,this.adjustmentTransform=new Ft,this.ellipsoid=pe.clone()}resolveExternalURL(t){return this.manager.resolveURL(super.resolveExternalURL(t))}parse(t){return super.parse(t).then(t=>{const{featureTable:s,batchTable:i}=t,n=t.glbBytes.slice().buffer;return new Promise((r,o)=>{const a=this.fetchOptions,l=this.manager,c=l.getHandler("path.gltf")||new e(l);"include"===a.credentials&&"cors"===a.mode&&c.setCrossOrigin("use-credentials"),"credentials"in a&&c.setWithCredentials("include"===a.credentials),a.headers&&c.setRequestHeader(a.headers);let h=t.gltfWorkingPath??this.workingPath;/[\\/]$/.test(h)||(h+="/");const u=this.adjustmentTransform;c.parse(n,h,t=>{const e=s.getData("INSTANCES_LENGTH"),n=s.getData("POSITION",e,"FLOAT","VEC3"),o=s.getData("NORMAL_UP",e,"FLOAT","VEC3"),a=s.getData("NORMAL_RIGHT",e,"FLOAT","VEC3"),l=s.getData("SCALE_NON_UNIFORM",e,"FLOAT","VEC3"),c=s.getData("SCALE",e,"FLOAT","SCALAR"),h=s.getData("RTC_CENTER",1,"FLOAT","VEC3"),d=s.getData("EAST_NORTH_UP");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach(t=>{t in s.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${t}" detected.`)});const p=new It;for(let s=0;s<e;s++)p.x+=n[3*s+0]/e,p.y+=n[3*s+1]/e,p.z+=n[3*s+2]/e;const m=[],g=[];t.scene.updateMatrixWorld(),t.scene.traverse(t=>{if(t.isMesh){g.push(t);const{geometry:s,material:i}=t,n=new Wt(s,i,e);n.position.copy(p),h&&(n.position.x+=h[0],n.position.y+=h[1],n.position.z+=h[2]),m.push(n)}});for(let s=0;s<e;s++){ye.set(n[3*s+0]-p.x,n[3*s+1]-p.y,n[3*s+2]-p.z),be.identity(),o&&(ge.set(o[3*s+0],o[3*s+1],o[3*s+2]),fe.set(a[3*s+0],a[3*s+1],a[3*s+2]),me.crossVectors(fe,ge).normalize(),_e.makeBasis(fe,ge,me),be.setFromRotationMatrix(_e)),xe.set(1,1,1),l&&xe.set(l[3*s+0],l[3*s+1],l[3*s+2]),c&&xe.multiplyScalar(c[s]);for(let t=0,e=m.length;t<e;t++){const e=m[t];Pe.copy(be),d&&(e.updateMatrixWorld(),ve.copy(ye).applyMatrix4(e.matrixWorld),this.ellipsoid.getPositionToCartographic(ve,Me),this.ellipsoid.getEastNorthUpFrame(Me.lat,Me.lon,we),Pe.setFromRotationMatrix(we)),_e.compose(ye,Pe,xe).multiply(u);const i=g[t];Te.multiplyMatrices(_e,i.matrixWorld),e.setMatrixAt(s,Te)}}t.scene.clear(),t.scene.add(...m),t.batchTable=i,t.featureTable=s,t.scene.batchTable=i,t.scene.featureTable=s,r(t)},o)})})}},Se=class extends G{constructor(t=Dt){super(),this.manager=t,this.adjustmentTransform=new Ft,this.ellipsoid=pe.clone()}parse(t){const e=super.parse(t),{manager:s,ellipsoid:i,adjustmentTransform:n}=this,r=[];for(const o in e.tiles){const{type:t,buffer:a}=e.tiles[o];switch(t){case"b3dm":{const t=a.slice(),e=new ae(s);e.workingPath=this.workingPath,e.fetchOptions=this.fetchOptions,e.adjustmentTransform.copy(n);const i=e.parse(t.buffer);r.push(i);break}case"pnts":{const t=a.slice(),e=new de(s);e.workingPath=this.workingPath,e.fetchOptions=this.fetchOptions;const i=e.parse(t.buffer);r.push(i);break}case"i3dm":{const t=a.slice(),e=new Ce(s);e.workingPath=this.workingPath,e.fetchOptions=this.fetchOptions,e.ellipsoid.copy(i),e.adjustmentTransform.copy(n);const o=e.parse(t.buffer);r.push(o);break}}}return Promise.all(r).then(t=>{const e=new Ht;return t.forEach(t=>{e.add(t.scene)}),{tiles:t,scene:e}})}};const Ae=new Ft;let Ee=class extends Ht{constructor(t){super(),this.isTilesGroup=!0,this.name="TilesRenderer.TilesGroup",this.tilesRenderer=t,this.matrixWorldInverse=new Ft}raycast(t,e){return!this.tilesRenderer.optimizeRaycast||(this.tilesRenderer.raycast(t,e),!1)}updateMatrixWorld(t){if(this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldNeedsUpdate||t){null===this.parent?Ae.copy(this.matrix):Ae.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1;const t=Ae.elements,e=this.matrixWorld.elements;let s=!1;for(let i=0;i<16;i++){const n=t[i],r=e[i];if(Math.abs(n-r)>Number.EPSILON){s=!0;break}}if(s){this.matrixWorld.copy(Ae),this.matrixWorldInverse.copy(Ae).invert();const t=this.children;for(let e=0,s=t.length;e<s;e++)t[e].updateMatrixWorld()}}}updateWorldMatrix(t,e){this.parent&&t&&this.parent.updateWorldMatrix(t,!1),this.updateMatrixWorld(!0)}};const Le=new qt,Ue=new It,Re=[];function De(t,e){return t.distance-e.distance}function Fe(t,e,s,i){const{scene:n}=t.cached;s.invokeOnePlugin(s=>s.raycastTile&&s.raycastTile(t,n,e,i))||e.intersectObject(n,!0,i)}function Ie(t){return"__used"in t}function ke(t,e,s,i=null){const{group:n,activeTiles:r}=t;null===i&&(i=Le).copy(s.ray).applyMatrix4(n.matrixWorldInverse);const o=[],a=e.children;for(let h=0,u=a.length;h<u;h++){const t=a[h];Ie(t)&&t.__used&&(null!==t.cached.boundingVolume.intersectRay(i,Ue)&&(Ue.applyMatrix4(n.matrixWorld),o.push({distance:Ue.distanceToSquared(s.ray.origin),tile:t})))}o.sort(De);let l=null,c=1/0;if(r.has(e)){const i=function(t,e,s){Fe(t,e,s,Re),Re.sort(De);const i=Re[0]||null;return Re.length=0,i}(e,s,t);i&&(l=i,c=i.distance*i.distance)}for(let h=0,u=o.length;h<u;h++){const e=o[h],n=e.distance,r=e.tile;if(n>c)break;const a=ke(t,r,s,i);if(a){const t=a.distance*a.distance;t<c&&(l=a,c=t)}}return l}function Oe(t,e,s,i,n=null){if(!Ie(e))return;const{group:r,activeTiles:o}=t,{boundingVolume:a}=e.cached;if(null===n&&(n=Le).copy(s.ray).applyMatrix4(r.matrixWorldInverse),!e.__used||!a.intersectsRay(n))return;o.has(e)&&Fe(e,s,t,i);const l=e.children;for(let c=0,h=l.length;c<h;c++)Oe(t,l[c],s,i,n)}const Ve=new It,ze=new It,Be=new It,Ne=new It,je=new It;class We{constructor(){this.sphere=null,this.obb=null,this.region=null,this.regionObb=null}intersectsRay(t){const e=this.sphere,s=this.obb||this.regionObb;return!(e&&!t.intersectsSphere(e)||s&&!s.intersectsRay(t))}intersectRay(t,e=null){const s=this.sphere,i=this.obb||this.regionObb;let n=-1/0,r=-1/0;s&&t.intersectSphere(s,Ne)&&(n=s.containsPoint(t.origin)?0:t.origin.distanceToSquared(Ne)),i&&i.intersectRay(t,je)&&(r=i.containsPoint(t.origin)?0:t.origin.distanceToSquared(je));const o=Math.max(n,r);return o===-1/0?null:(t.at(Math.sqrt(o),e),e)}distanceToPoint(t){const e=this.sphere,s=this.obb||this.regionObb;let i=-1/0,n=-1/0;return e&&(i=Math.max(e.distanceToPoint(t),0)),s&&(n=s.distanceToPoint(t)),i>n?i:n}intersectsFrustum(t){const e=this.obb||this.regionObb,s=this.sphere;return!(s&&!t.intersectsSphere(s)||e&&!e.intersectsFrustum(t))&&!(!s&&!e)}intersectsSphere(t){const e=this.obb||this.regionObb,s=this.sphere;return!(s&&!s.intersectsSphere(t)||e&&!e.intersectsSphere(t))&&!(!s&&!e)}intersectsOBB(t){const e=this.obb||this.regionObb,s=this.sphere;return!(s&&!t.intersectsSphere(s)||e&&!e.intersectsOBB(t))&&!(!s&&!e)}getOBB(t,e){const s=this.obb||this.regionObb;s?(t.copy(s.box),e.copy(s.transform)):(this.getAABB(t),e.identity())}getAABB(t){if(this.sphere)this.sphere.getBoundingBox(t);else{const e=this.obb||this.regionObb;t.copy(e.box).applyMatrix4(e.transform)}}getSphere(t){if(this.sphere)t.copy(this.sphere);else if(this.region)this.region.getBoundingSphere(t);else{const e=this.obb||this.regionObb;e.box.getBoundingSphere(t),t.applyMatrix4(e.transform)}}setObbData(t,e){const s=new _t;Ve.set(t[3],t[4],t[5]),ze.set(t[6],t[7],t[8]),Be.set(t[9],t[10],t[11]);const i=Ve.length(),n=ze.length(),r=Be.length();Ve.normalize(),ze.normalize(),Be.normalize(),0===i&&Ve.crossVectors(ze,Be),0===n&&ze.crossVectors(Ve,Be),0===r&&Be.crossVectors(Ve,ze),s.transform.set(Ve.x,ze.x,Be.x,t[0],Ve.y,ze.y,Be.y,t[1],Ve.z,ze.z,Be.z,t[2],0,0,0,1).premultiply(e),s.box.min.set(-i,-n,-r),s.box.max.set(i,n,r),s.update(),this.obb=s}setSphereData(t,e,s,i,n){const r=new Zt;r.center.set(t,e,s),r.radius=i,r.applyMatrix4(n),this.sphere=r}setRegionData(t,e,s,i,n,r,o){const a=new Ut(...t.radius,s,n,e,i,r,o),l=new _t;a.getBoundingBox(l.box,l.transform),l.update(),this.region=a,this.regionObb=l}}const Ge=new $t;class He extends Yt{constructor(){super(),this.points=Array(8).fill().map(()=>new It)}setFromProjectionMatrix(t,e){return super.setFromProjectionMatrix(t,e),this.calculateFrustumPoints(),this}calculateFrustumPoints(){const{planes:t,points:e}=this;[[t[0],t[3],t[4]],[t[1],t[3],t[4]],[t[0],t[2],t[4]],[t[1],t[2],t[4]],[t[0],t[3],t[5]],[t[1],t[3],t[5]],[t[0],t[2],t[5]],[t[1],t[2],t[5]]].forEach((t,s)=>{!function(t,e,s,i){const n=Ge.set(t.normal.x,t.normal.y,t.normal.z,e.normal.x,e.normal.y,e.normal.z,s.normal.x,s.normal.y,s.normal.z);i.set(-t.constant,-e.constant,-s.constant),i.applyMatrix3(n.invert())}(t[0],t[1],t[2],e[s])})}}const qe=new Ft,Ze=new Jt,Ye=Symbol("INITIAL_FRUSTUM_CULLED"),$e=new Ft,Xe=new It,Qe=new kt,Je={inView:!1,error:1/0},Ke=new It(1,0,0),ts=new It(0,1,0);function es(t,e){t.traverse(t=>{t.frustumCulled=t[Ye]&&e})}let ss=class extends k{get autoDisableRendererCulling(){return this._autoDisableRendererCulling}set autoDisableRendererCulling(t){this._autoDisableRendererCulling!==t&&(super._autoDisableRendererCulling=t,this.forEachLoadedModel(e=>{es(e,!t)}))}get optimizeRaycast(){return this._optimizeRaycast}set optimizeRaycast(t){console.warn('TilesRenderer: The "optimizeRaycast" option has been deprecated.'),this._optimizeRaycast=t}constructor(...t){super(...t),this.group=new Ee(this),this.ellipsoid=pe.clone(),this.cameras=[],this.cameraMap=new Map,this.cameraInfo=[],this._optimizeRaycast=!0,this._upRotationMatrix=new Ft,this._bytesUsed=new WeakMap,this._autoDisableRendererCulling=!0;const e=new Xt;e.setURLModifier(t=>this.preprocessURL?this.preprocessURL(t):t),this.manager=e,this._listeners={}}addEventListener(...t){Qt.prototype.addEventListener.call(this,...t)}hasEventListener(...t){Qt.prototype.hasEventListener.call(this,...t)}removeEventListener(...t){Qt.prototype.removeEventListener.call(this,...t)}dispatchEvent(...t){Qt.prototype.dispatchEvent.call(this,...t)}getBoundingBox(t){if(!this.root)return!1;const e=this.root.cached.boundingVolume;return!!e&&(e.getAABB(t),!0)}getOrientedBoundingBox(t,e){if(!this.root)return!1;const s=this.root.cached.boundingVolume;return!!s&&(s.getOBB(t,e),!0)}getBoundingSphere(t){if(!this.root)return!1;const e=this.root.cached.boundingVolume;return!!e&&(e.getSphere(t),!0)}forEachLoadedModel(t){this.traverse(e=>{const s=e.cached&&e.cached.scene;s&&t(s,e)},null,!1)}raycast(t,e){if(this.root)if(t.firstHitOnly){const s=ke(this,this.root,t);s&&e.push(s)}else Oe(this,this.root,t,e)}hasCamera(t){return this.cameraMap.has(t)}setCamera(t){const e=this.cameras,s=this.cameraMap;return!s.has(t)&&(s.set(t,new kt),e.push(t),this.dispatchEvent({type:"add-camera",camera:t}),!0)}setResolution(t,e,s){const i=this.cameraMap;if(!i.has(t))return!1;const n=e.isVector2?e.x:e,r=e.isVector2?e.y:s,o=i.get(t);return(o.width!==n||o.height!==r)&&(o.set(n,r),this.dispatchEvent({type:"camera-resolution-change"})),!0}setResolutionFromRenderer(t,e){return e.getSize(Qe),this.setResolution(t,Qe.x,Qe.y)}deleteCamera(t){const e=this.cameras,s=this.cameraMap;if(s.has(t)){const i=e.indexOf(t);return e.splice(i,1),s.delete(t),this.dispatchEvent({type:"delete-camera",camera:t}),!0}return!1}loadRootTileSet(...t){return super.loadRootTileSet(...t).then(t=>{const{asset:e,extensions:s={}}=t;switch((e&&e.gltfUpAxis||"y").toLowerCase()){case"x":this._upRotationMatrix.makeRotationAxis(ts,-Math.PI/2);break;case"y":this._upRotationMatrix.makeRotationAxis(Ke,Math.PI/2)}if("3DTILES_ellipsoid"in s){const t=s["3DTILES_ellipsoid"],{ellipsoid:e}=this;e.name=t.body,t.radii?e.radius.set(...t.radii):e.radius.set(1,1,1)}return t})}update(){let t=null;if(this.invokeAllPlugins(e=>{if(e.doTilesNeedUpdate){const s=e.doTilesNeedUpdate();t=null===t?s:!(!t&&!s)}}),!1===t)return this.dispatchEvent({type:"update-before"}),void this.dispatchEvent({type:"update-after"});this.dispatchEvent({type:"update-before"});const e=this.group,s=this.cameras,i=this.cameraMap,n=this.cameraInfo;for(;n.length>s.length;)n.pop();for(;n.length<s.length;)n.push({frustum:new He,isOrthographic:!1,sseDenominator:-1,position:new It,invScale:-1,pixelSize:0});Xe.setFromMatrixScale(e.matrixWorldInverse),Math.abs(Math.max(Xe.x-Xe.y,Xe.x-Xe.z))>1e-6&&console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.");for(let r=0,o=n.length;r<o;r++){const t=s[r],o=n[r],a=o.frustum,l=o.position,c=i.get(t);(0===c.width||0===c.height)&&console.warn("TilesRenderer: resolution for camera error calculation is not set.");const h=t.projectionMatrix.elements;if(o.isOrthographic=1===h[15],o.isOrthographic){const t=2/h[0],e=2/h[5];o.pixelSize=Math.max(e/c.height,t/c.width)}else o.sseDenominator=2/h[5]/c.height;$e.copy(e.matrixWorld),$e.premultiply(t.matrixWorldInverse),$e.premultiply(t.projectionMatrix),a.setFromProjectionMatrix($e),l.set(0,0,0),l.applyMatrix4(t.matrixWorld),l.applyMatrix4(e.matrixWorldInverse)}if(super.update(),this.dispatchEvent({type:"update-after"}),0===s.length&&this.root){let t=!1;this.invokeAllPlugins(e=>t=t||!(e===this||!e.calculateTileViewError)),!1===t&&console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles.")}}preprocessNode(t,e,s=null){super.preprocessNode(t,e,s);const i=new Ft;if(t.transform){const e=t.transform;for(let t=0;t<16;t++)i.elements[t]=e[t]}s&&i.premultiply(s.cached.transform);const n=(new Ft).copy(i).invert(),r=new We;"sphere"in t.boundingVolume&&r.setSphereData(...t.boundingVolume.sphere,i),"box"in t.boundingVolume&&r.setObbData(t.boundingVolume.box,i),"region"in t.boundingVolume&&r.setRegionData(this.ellipsoid,...t.boundingVolume.region),t.cached={transform:i,transformInverse:n,active:!1,boundingVolume:r,metadata:null,scene:null,geometry:null,materials:null,textures:null}}async parseTile(t,s,i,n,r){const o=s.cached,a=b(n),l=this.fetchOptions,c=this.manager;let h=null;const u=o.transform,d=this._upRotationMatrix,p=(g(t)||i).toLowerCase();switch(p){case"b3dm":{const e=new ae(c);e.workingPath=a,e.fetchOptions=l,e.adjustmentTransform.copy(d),h=e.parse(t);break}case"pnts":{const e=new de(c);e.workingPath=a,e.fetchOptions=l,h=e.parse(t);break}case"i3dm":{const e=new Ce(c);e.workingPath=a,e.fetchOptions=l,e.adjustmentTransform.copy(d),e.ellipsoid.copy(this.ellipsoid),h=e.parse(t);break}case"cmpt":{const e=new Se(c);e.workingPath=a,e.fetchOptions=l,e.adjustmentTransform.copy(d),e.ellipsoid.copy(this.ellipsoid),h=e.parse(t).then(t=>t.scene);break}case"gltf":case"glb":{const s=c.getHandler("path.gltf")||c.getHandler("path.glb")||new e(c);s.setWithCredentials("include"===l.credentials),s.setRequestHeader(l.headers||{}),"include"===l.credentials&&"cors"===l.mode&&s.setCrossOrigin("use-credentials");let i=s.resourcePath||s.path||a;!/[\\/]$/.test(i)&&i.length&&(i+="/"),h=s.parseAsync(t,i).then(t=>{t.scene=t.scene||new Ht;const{scene:e}=t;return e.updateMatrix(),e.matrix.multiply(d).decompose(e.position,e.quaternion,e.scale),t});break}default:h=this.invokeOnePlugin(e=>e.parseToMesh&&e.parseToMesh(t,s,i,n,r))}const m=await h;if(null===m)throw new Error(`TilesRenderer: Content type "${p}" not supported.`);let f,y;m.isObject3D?(f=m,y=null):(f=m.scene,y=m),f.updateMatrix(),f.matrix.premultiply(u),f.matrix.decompose(f.position,f.quaternion,f.scale),await this.invokeAllPlugins(t=>t.processTileModel&&t.processTileModel(f,s)),f.traverse(t=>{t[Ye]=t.frustumCulled}),es(f,!this.autoDisableRendererCulling);const x=[],_=[],T=[];if(f.traverse(t=>{if(t.geometry&&_.push(t.geometry),t.material){const e=t.material;x.push(t.material);for(const t in e){const s=e[t];s&&s.isTexture&&T.push(s)}}}),r.aborted)for(let e=0,g=T.length;e<g;e++){const t=T[e];t.image instanceof ImageBitmap&&t.image.close(),t.dispose()}else o.materials=x,o.geometry=_,o.textures=T,o.scene=f,o.metadata=y}disposeTile(t){super.disposeTile(t);const e=t.cached;if(e.scene){const s=e.materials,i=e.geometry,n=e.textures,r=e.scene.parent;e.scene.traverse(t=>{t.userData.meshFeatures&&t.userData.meshFeatures.dispose(),t.userData.structuralMetadata&&t.userData.structuralMetadata.dispose()});for(let t=0,e=i.length;t<e;t++)i[t].dispose();for(let t=0,e=s.length;t<e;t++)s[t].dispose();for(let t=0,e=n.length;t<e;t++){const e=n[t];e.image instanceof ImageBitmap&&e.image.close(),e.dispose()}r&&r.remove(e.scene),this.dispatchEvent({type:"dispose-model",scene:e.scene,tile:t}),e.scene=null,e.materials=null,e.textures=null,e.geometry=null,e.metadata=null}}setTileVisible(t,e){const s=t.cached.scene,i=this.group;e?s&&(i.add(s),s.updateMatrixWorld(!0)):s&&i.remove(s),super.setTileVisible(t,e),this.dispatchEvent({type:"tile-visibility-change",scene:s,tile:t,visible:e})}calculateBytesUsed(e,s){const i=this._bytesUsed;return!i.has(e)&&s&&i.set(e,function(e){const s=new Set;let i=0;return e.traverse(e=>{if(e.geometry&&!s.has(e.geometry)&&(i+=t(e.geometry),s.add(e.geometry)),e.material){const t=e.material;for(const e in t){const n=t[e];n&&n.isTexture&&!s.has(n)&&(i+=Rt(n),s.add(n))}}}),i}(s)),i.get(e)??null}calculateTileViewError(t,e){const s=t.cached,i=this.cameras,n=this.cameraInfo,r=s.boundingVolume;let o=!1,a=-1/0,l=1/0,c=-1/0,h=1/0;for(let u=0,d=i.length;u<d;u++){const e=n[u];let s,i;if(e.isOrthographic){const n=e.pixelSize;s=t.geometricError/n,i=1/0}else{const n=e.sseDenominator;i=r.distanceToPoint(e.position),s=0===i?1/0:t.geometricError/(i*n)}const d=n[u].frustum;r.intersectsFrustum(d)&&(o=!0,a=Math.max(a,s),l=Math.min(l,i)),c=Math.max(c,s),h=Math.min(h,i)}this.invokeAllPlugins(e=>{e!==this&&e.calculateTileViewError&&(e.calculateTileViewError(t,Je),Je.inView&&(o=!0,a=Math.max(a,Je.error)),c=Math.max(c,Je.error))}),o?(e.inView=!0,e.error=a,e.distanceFromCamera=l):(e.inView=!1,e.error=c,e.distanceFromCamera=h)}setLatLonToYUp(t,e){console.warn("TilesRenderer: setLatLonToYUp is deprecated. Use the ReorientationPlugin, instead.");const{ellipsoid:s,group:i}=this;Ze.set(Math.PI/2,Math.PI/2,0),qe.makeRotationFromEuler(Ze),s.getEastNorthUpFrame(t,e,0,i.matrix).multiply(qe).invert().decompose(i.position,i.quaternion,i.scale),i.updateMatrixWorld(!0)}dispose(){super.dispose(),this.group.removeFromParent()}};class is extends Kt{constructor(){super(new te(0,0),new ns),this.renderOrder=1/0}onBeforeRender(t){const e=this.material.uniforms;t.getSize(e.resolution.value)}updateMatrixWorld(){this.matrixWorld.makeTranslation(this.position)}dispose(){this.geometry.dispose(),this.material.dispose()}}class ns extends ee{constructor(){super({depthWrite:!1,depthTest:!1,transparent:!0,uniforms:{resolution:{value:new kt},size:{value:15},thickness:{value:2},opacity:{value:1}},vertexShader:"\n\n\t\t\t\tuniform float pixelRatio;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\t\t\t\t\tvec2 offset = uv * 2.0 - vec2( 1.0 );\n\t\t\t\t\toffset.y *= aspect;\n\n\t\t\t\t\tvec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tscreenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;\n\n\t\t\t\t\tgl_Position = screenPoint;\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat ht = 0.5 * thickness;\n\t\t\t\t\tfloat planeDim = size + thickness;\n\t\t\t\t\tfloat offset = ( planeDim - ht - 2.0 ) / planeDim;\n\t\t\t\t\tfloat texelThickness = ht / planeDim;\n\n\t\t\t\t\tvec2 vec = vUv * 2.0 - vec2( 1.0 );\n\t\t\t\t\tfloat dist = abs( length( vec ) - offset );\n\t\t\t\t\tfloat fw = fwidth( dist ) * 0.5;\n\t\t\t\t\tfloat a = smoothstep( texelThickness - fw, texelThickness + fw, dist );\n\n\t\t\t\t\tgl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );\n\n\t\t\t\t}\n\t\t\t"})}}const rs=new kt,os=new kt;let as=class{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new kt,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new kt,this.hoverSet=!1}updateFrame(){const{previousPositions:t,pointerPositions:e}=this;for(const s in e)t[s].copy(e[s])}setHoverEvent(t){("mouse"===t.pointerType||"wheel"===t.type)&&(this.getAdjustedPointer(t,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(t){return null!==this.pointerType?(this.getCenterPoint(t),t):this.hoverSet?(t.copy(this.hoverPosition),t):null}getAdjustedPointer(t,e){const s=(this.domElement?this.domElement:t.target).getBoundingClientRect(),i=t.clientX-s.left,n=t.clientY-s.top;e.set(i,n)}addPointer(t){const e=t.pointerId,s=new kt;this.getAdjustedPointer(t,s),this.pointerOrder.push(e),this.pointerPositions[e]=s,this.previousPositions[e]=s.clone(),this.startPositions[e]=s.clone(),1===this.getPointerCount()&&(this.pointerType=t.pointerType,this.buttons=t.buttons)}updatePointer(t){const e=t.pointerId;return e in this.pointerPositions&&(this.getAdjustedPointer(t,this.pointerPositions[e]),!0)}deletePointer(t){const e=t.pointerId,s=this.pointerOrder;s.splice(s.indexOf(e),1),delete this.pointerPositions[e],delete this.previousPositions[e],delete this.startPositions[e],0===this.getPointerCount.length&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(t,e=this.pointerPositions){const s=this.pointerOrder;if(1===this.getPointerCount()||"mouse"===this.getPointerType()){const i=s[0];return t.copy(e[i]),t}if(2===this.getPointerCount()){const s=this.pointerOrder[0],i=this.pointerOrder[1],n=e[s],r=e[i];return t.addVectors(n,r).multiplyScalar(.5),t}return null}getPreviousCenterPoint(t){return this.getCenterPoint(t,this.previousPositions)}getStartCenterPoint(t){return this.getCenterPoint(t,this.startPositions)}getMoveDistance(){return this.getCenterPoint(rs),this.getPreviousCenterPoint(os),rs.sub(os).length()}getTouchPointerDistance(t=this.pointerPositions){if(this.getPointerCount()<=1||"mouse"===this.getPointerType())return 0;const{pointerOrder:e}=this,s=e[0],i=e[1],n=t[s],r=t[i];return n.distanceTo(r)}getPreviousTouchPointerDistance(){return this.getTouchPointerDistance(this.previousPositions)}getStartTouchPointerDistance(){return this.getTouchPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return"touch"===this.getPointerType()}getPointerButtons(){return this.buttons}isLeftClicked(){return!!(1&this.buttons)}isRightClicked(){return!!(2&this.buttons)}};const ls=new Ft;function cs(t,e,s){return s.makeTranslation(-t.x,-t.y,-t.z),ls.makeRotationFromQuaternion(e),s.premultiply(ls),ls.makeTranslation(t.x,t.y,t.z),s.premultiply(ls),s}function hs(t,e,s,i){i.x=(t-s.offsetLeft)/s.clientWidth*2-1,i.y=-(e-s.offsetTop)/s.clientHeight*2+1,i.isVector3&&(i.z=0)}function us(t,e,s){const i=t instanceof qt?t:t.ray,{origin:n,direction:r}=i;n.set(e.x,e.y,-1).unproject(s),r.set(e.x,e.y,1).unproject(s).sub(n),t.isRay||(t.near=0,t.far=r.length(),t.camera=s),r.normalize()}new It;const ds=.05,ps=.025,ms=new Ft,gs=new Ft,fs=new It,ys=new It,bs=new It,xs=new It,_s=new It,Ts=new It,vs=new It,ws=new It,Ps=new Gt,Ms=new se,Cs=new It,Ss=new It,As=new It,Es=new Gt,Ls=new qt,Us=new kt,Rs=new kt,Ds=new kt,Fs=new kt,Is=new kt,ks=new kt,Os={type:"change"},Vs={type:"start"},zs={type:"end"};class Bs extends Qt{get enabled(){return this._enabled}set enabled(t){t!==this.enabled&&(this._enabled=t,this.resetState(),this.pointerTracker.reset(),this.enabled||(this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0)))}constructor(t=null,e=null,s=null,i=null){super(),this.isEnvironmentControls=!0,this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.enableDamping=!1,this.dampingFactor=.15,this.fallbackPlane=new se(new It(0,1,0),0),this.useFallbackPlane=!0,this.scaleZoomOrientationAtEdges=!1,this.autoAdjustCameraRotation=!0,this.state=0,this.pointerTracker=new as,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new It,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new It,this.zoomPoint=new It,this.zoomDelta=0,this.rotationInertiaPivot=new It,this.rotationInertia=new kt,this.dragInertia=new It,this.inertiaTargetDistance=1/0,this.inertiaStableFrames=0,this.pivotMesh=new is,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new ie,this.raycaster.firstHitOnly=!0,this.up=new It(0,1,0),this.clock=new ne,this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=0,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,s&&this.attach(s),e&&this.setCamera(e),t&&this.setScene(t),i&&this.setTilesRenderer(i)}setScene(t){this.scene=t}setCamera(t){this.camera=t,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.raycaster.camera=t,this.resetState()}setTilesRenderer(t){console.warn('EnvironmentControls: "setTilesRenderer" has been deprecated. Use "setScene" and "setEllipsoid", instead.'),this.tilesRenderer=t,null!==this.tilesRenderer&&this.setScene(this.tilesRenderer.group)}attach(t){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=t,this.pointerTracker.domElement=t,t.style.touchAction="none";const e=t=>{this.enabled&&t.preventDefault()},s=t=>{if(!this.enabled)return;t.preventDefault();const{camera:e,raycaster:s,domElement:i,up:n,pivotMesh:r,pointerTracker:o,scene:a,pivotPoint:l,enabled:c}=this;if(o.addPointer(t),this.needsUpdate=!0,o.isPointerTouch())if(r.visible=!1,0===o.getPointerCount())i.setPointerCapture(t.pointerId);else if(o.getPointerCount()>2)return void this.resetState();o.getCenterPoint(Rs),hs(Rs.x,Rs.y,i,Rs),us(s,Rs,e);const h=Math.abs(s.ray.direction.dot(n));if(h<ds||h<ps)return;const u=this._raycast(s);u&&(2===o.getPointerCount()||o.isRightClicked()||o.isLeftClicked()&&t.shiftKey?(this.setState(o.isPointerTouch()?4:2),l.copy(u.point),r.position.copy(u.point),r.visible=!o.isPointerTouch()&&c,r.updateMatrixWorld(),a.add(r)):o.isLeftClicked()&&(this.setState(1),l.copy(u.point),r.position.copy(u.point),r.updateMatrixWorld(),a.add(r)))};let i=!1;const n=t=>{const{pointerTracker:e}=this;if(!this.enabled)return;t.preventDefault();const{pivotMesh:s,enabled:n}=this;this.zoomDirectionSet=!1,this.zoomPointSet=!1,0!==this.state&&(this.needsUpdate=!0),e.setHoverEvent(t),e.updatePointer(t)&&(e.isPointerTouch()&&2===e.getPointerCount()&&(i||(i=!0,queueMicrotask(()=>{i=!1,e.getCenterPoint(Is);const t=e.getStartTouchPointerDistance(),r=e.getTouchPointerDistance(),o=r-t;if(0===this.state||4===this.state){e.getCenterPoint(Is),e.getStartCenterPoint(ks);const t=2*window.devicePixelRatio,s=Is.distanceTo(ks);(Math.abs(o)>t||s>t)&&(Math.abs(o)>s?(this.setState(3),this.zoomDirectionSet=!1):this.setState(2))}if(3===this.state){const t=e.getPreviousTouchPointerDistance();this.zoomDelta+=r-t,s.visible=!1}else 2===this.state&&(s.visible=n)}))),this.dispatchEvent(Os))},r=e=>{const{pointerTracker:s}=this;!this.enabled||0===s.getPointerCount()||(s.deletePointer(e),"touch"===s.getPointerType()&&0===s.getPointerCount()&&t.releasePointerCapture(e.pointerId),this.resetState(),this.needsUpdate=!0)},o=t=>{if(!this.enabled)return;t.preventDefault();const{pointerTracker:e}=this;let s;switch(e.setHoverEvent(t),e.updatePointer(t),this.dispatchEvent(Vs),t.deltaMode){case 2:s=800*t.deltaY;break;case 1:s=40*t.deltaY;break;case 0:s=t.deltaY}const i=Math.sign(s),n=Math.abs(s);this.zoomDelta-=.25*i*n,this.needsUpdate=!0,this._lastUsedState=3,this.dispatchEvent(zs)},a=t=>{this.enabled&&this.resetState()};t.addEventListener("contextmenu",e),t.addEventListener("pointerdown",s),t.addEventListener("wheel",o,{passive:!1});const l=t.getRootNode();l.addEventListener("pointermove",n),l.addEventListener("pointerup",r),l.addEventListener("pointerleave",a),this._detachCallback=()=>{t.removeEventListener("contextmenu",e),t.removeEventListener("pointerdown",s),t.removeEventListener("wheel",o),l.removeEventListener("pointermove",n),l.removeEventListener("pointerup",r),l.removeEventListener("pointerleave",a)}}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}getUpDirection(t,e){e.copy(this.up)}getCameraUpDirection(t){this.getUpDirection(this.camera.position,t)}getPivotPoint(t){let e=null;3===this._lastUsedState?this._zoomPointWasSet&&(e=t.copy(this.zoomPoint)):(2===this._lastUsedState||1===this._lastUsedState)&&(e=t.copy(this.pivotPoint));const{camera:s,raycaster:i}=this;null!==e&&(ys.copy(e).project(s),(ys.x<-1||ys.x>1||ys.y<-1||ys.y>1)&&(e=null)),us(i,{x:0,y:0},s);const n=this._raycast(i);return n&&(null===e||n.distance<e.distanceTo(i.ray.origin))&&(e=t.copy(n.point)),e}resetState(){0!==this.state&&this.dispatchEvent(zs),this.state=0,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=this.enabled,this.actionHeightOffset=0,this.pointerTracker.reset()}setState(t=this.state,e=!0){this.state!==t&&(0===this.state&&e&&this.dispatchEvent(Vs),this.pivotMesh.visible=this.enabled,this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0),this.inertiaStableFrames=0,this.state=t,0!==t&&4!==t&&(this._lastUsedState=t))}update(t=Math.min(this.clock.getDelta(),.064)){if(!this.enabled||!this.camera||0===t)return;const{camera:e,cameraRadius:s,pivotPoint:i,up:n,state:r,adjustHeight:o,autoAdjustCameraRotation:a}=this;e.updateMatrixWorld(),this.getCameraUpDirection(Cs),this._upInitialized||(this._upInitialized=!0,this.up.copy(Cs)),this.zoomPointSet=!1;const l=this._inertiaNeedsUpdate(),c=this.needsUpdate||l;if(this.needsUpdate||l){const s=this.zoomDelta;this._updateZoom(),this._updatePosition(t),this._updateRotation(t),1===r||2===r?(_s.set(0,0,-1).transformDirection(e.matrixWorld),this.inertiaTargetDistance=ys.copy(i).sub(e.position).dot(_s)):0===r&&this._updateInertia(t),(0!==r||0!==s||l)&&this.dispatchEvent(Os),this.needsUpdate=!1}const h=e.isOrthographicCamera?null:o&&this._getPointBelowCamera()||null;if(this.getCameraUpDirection(Cs),this._setFrame(Cs),(1===this.state||2===this.state)&&0!==this.actionHeightOffset){const{actionHeightOffset:t}=this;e.position.addScaledVector(n,-t),i.addScaledVector(n,-t),h&&(h.distance-=t)}if(this.actionHeightOffset=0,h){const t=h.distance;if(t<s){const r=s-t;e.position.addScaledVector(n,r),i.addScaledVector(n,r),this.actionHeightOffset=r}}this.pointerTracker.updateFrame(),c&&a&&(this.getCameraUpDirection(Cs),this._alignCameraUp(Cs,1),this.getCameraUpDirection(Cs),this._clampRotation(Cs))}adjustCamera(t){const{adjustHeight:e,cameraRadius:s}=this;if(t.isPerspectiveCamera){this.getUpDirection(t.position,Cs);const i=e&&this._getPointBelowCamera(t.position,Cs)||null;if(i){const e=i.distance;e<s&&t.position.addScaledVector(Cs,s-e)}}}dispose(){this.detach()}_updateInertia(t){const{rotationInertia:e,pivotPoint:s,dragInertia:i,enableDamping:n,dampingFactor:r,camera:o,cameraRadius:a,minDistance:l,inertiaTargetDistance:c}=this;if(!this.enableDamping||this.inertiaStableFrames>1)return i.set(0,0,0),void e.set(0,0,0);const h=Math.pow(2,-t/r),u=Math.max(o.near,a,l,c),d=25e-5;if(e.lengthSq()>0){us(Ls,ys.set(0,0,-1),o),Ls.applyMatrix4(o.matrixWorldInverse),Ls.direction.normalize(),Ls.recast(-Ls.direction.dot(Ls.origin)).at(u/Ls.direction.z,ys),ys.applyMatrix4(o.matrixWorld),us(Ls,fs.set(d,d,-1),o),Ls.applyMatrix4(o.matrixWorldInverse),Ls.direction.normalize(),Ls.recast(-Ls.direction.dot(Ls.origin)).at(u/Ls.direction.z,fs),fs.applyMatrix4(o.matrixWorld),ys.sub(s).normalize(),fs.sub(s).normalize();const i=ys.angleTo(fs)/t;e.multiplyScalar(h),(e.lengthSq()<i**2||!n)&&e.set(0,0)}if(i.lengthSq()>0){us(Ls,ys.set(0,0,-1),o),Ls.applyMatrix4(o.matrixWorldInverse),Ls.direction.normalize(),Ls.recast(-Ls.direction.dot(Ls.origin)).at(u/Ls.direction.z,ys),ys.applyMatrix4(o.matrixWorld),us(Ls,fs.set(d,d,-1),o),Ls.applyMatrix4(o.matrixWorldInverse),Ls.direction.normalize(),Ls.recast(-Ls.direction.dot(Ls.origin)).at(u/Ls.direction.z,fs),fs.applyMatrix4(o.matrixWorld);const e=ys.distanceTo(fs)/t;i.multiplyScalar(h),(i.lengthSq()<e**2||!n)&&i.set(0,0,0)}e.lengthSq()>0&&this._applyRotation(e.x*t,e.y*t,s),i.lengthSq()>0&&(o.position.addScaledVector(i,t),o.updateMatrixWorld())}_inertiaNeedsUpdate(){const{rotationInertia:t,dragInertia:e}=this;return 0!==t.lengthSq()||0!==e.lengthSq()}_updateZoom(){const{zoomPoint:t,zoomDirection:e,camera:s,minDistance:i,maxDistance:n,pointerTracker:r,domElement:o,minZoom:a,maxZoom:l,zoomSpeed:c,state:h}=this;let u=this.zoomDelta;if(this.zoomDelta=0,r.getLatestPoint(Rs)&&(0!==u||3===h))if(this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),s.isOrthographicCamera){this._updateZoomDirection();const t=this.zoomPointSet||this._updateZoomPoint();Ss.unproject(s);const e=Math.pow(.95,Math.abs(.05*u));let i=u>0?1/Math.abs(e):e;i*=c,i>1?l<s.zoom*i&&(i=1):a>s.zoom*i&&(i=1),s.zoom*=i,s.updateProjectionMatrix(),t&&(hs(Rs.x,Rs.y,o,As),As.unproject(s),s.position.sub(As).add(Ss),s.updateMatrixWorld())}else{this._updateZoomDirection();const r=ys.copy(e);if(this.zoomPointSet||this._updateZoomPoint()){const r=t.distanceTo(s.position);if(u<0){const t=Math.min(0,r-n);u=u*r*c*.0025,u=Math.max(u,t)}else{const t=Math.max(0,r-i);u=u*Math.max(r-i,0)*c*.0025,u=Math.min(u,t)}s.position.addScaledVector(e,u),s.updateMatrixWorld()}else{const t=this._getPointBelowCamera();if(t){const e=t.distance;r.set(0,0,-1).transformDirection(s.matrixWorld),s.position.addScaledVector(r,u*e*.01),s.updateMatrixWorld()}}}}_updateZoomDirection(){if(this.zoomDirectionSet)return;const{domElement:t,raycaster:e,camera:s,zoomDirection:i,pointerTracker:n}=this;n.getLatestPoint(Rs),hs(Rs.x,Rs.y,t,Ss),us(e,Ss,s),i.copy(e.ray.direction).normalize(),this.zoomDirectionSet=!0}_updateZoomPoint(){const{camera:t,zoomDirectionSet:e,zoomDirection:s,raycaster:i,zoomPoint:n,pointerTracker:r,domElement:o}=this;if(this._zoomPointWasSet=!1,!e)return!1;t.isOrthographicCamera&&r.getLatestPoint(Us)?(hs(Us.x,Us.y,o,Us),us(i,Us,t)):(i.ray.origin.copy(t.position),i.ray.direction.copy(s),i.near=0,i.far=1/0);const a=this._raycast(i);return!!a&&(n.copy(a.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0)}_getPointBelowCamera(t=this.camera.position,e=this.up){const{raycaster:s}=this;s.ray.direction.copy(e).multiplyScalar(-1),s.ray.origin.copy(t).addScaledVector(e,1e5),s.near=0,s.far=1/0;const i=this._raycast(s);return i&&(i.distance-=1e5),i}_updatePosition(t){const{raycaster:e,camera:s,pivotPoint:i,up:n,pointerTracker:r,domElement:o,state:a,dragInertia:l}=this;if(1===a){if(r.getCenterPoint(Rs),hs(Rs.x,Rs.y,o,Rs),Ms.setFromNormalAndCoplanarPoint(n,i),us(e,Rs,s),Math.abs(e.ray.direction.dot(n))<ds){const t=Math.acos(ds);ws.crossVectors(e.ray.direction,n).normalize(),e.ray.direction.copy(n).applyAxisAngle(ws,t).multiplyScalar(-1)}if(this.getUpDirection(i,Cs),Math.abs(e.ray.direction.dot(Cs))<ps){const t=Math.acos(ps);ws.crossVectors(e.ray.direction,Cs).normalize(),e.ray.direction.copy(Cs).applyAxisAngle(ws,t).multiplyScalar(-1)}e.ray.intersectPlane(Ms,ys)&&(fs.subVectors(i,ys),s.position.add(fs),s.updateMatrixWorld(),fs.multiplyScalar(1/t),r.getMoveDistance()/t<2*window.devicePixelRatio?this.inertiaStableFrames++:(l.copy(fs),this.inertiaStableFrames=0))}}_updateRotation(t){const{pivotPoint:e,pointerTracker:s,domElement:i,state:n,rotationInertia:r}=this;2===n&&(s.getCenterPoint(Rs),s.getPreviousCenterPoint(Ds),Fs.subVectors(Rs,Ds).multiplyScalar(2*Math.PI/i.clientHeight),this._applyRotation(Fs.x,Fs.y,e),Fs.multiplyScalar(1/t),s.getMoveDistance()/t<2*window.devicePixelRatio?this.inertiaStableFrames++:(r.copy(Fs),this.inertiaStableFrames=0))}_applyRotation(t,e,s){if(0===t&&0===e)return;const{camera:i,minAltitude:n,maxAltitude:r,rotationSpeed:o}=this,a=-t*o;let l,c=e*o;_s.set(0,0,1).transformDirection(i.matrixWorld),Ts.set(1,0,0).transformDirection(i.matrixWorld),this.getUpDirection(s,Cs),Cs.dot(_s)>1-1e-10?l=0:(ys.crossVectors(Cs,_s).normalize(),l=Math.sign(ys.dot(Ts))*Cs.angleTo(_s)),c>0?(c=Math.min(l-n,c),c=Math.max(0,c)):(c=Math.max(l-r,c),c=Math.min(0,c)),Ps.setFromAxisAngle(Cs,a),cs(s,Ps,ms),i.matrixWorld.premultiply(ms),Ts.set(1,0,0).transformDirection(i.matrixWorld),Ps.setFromAxisAngle(Ts,-c),cs(s,Ps,ms),i.matrixWorld.premultiply(ms),i.matrixWorld.decompose(i.position,i.quaternion,ys)}_setFrame(t){const{up:e,camera:s,zoomPoint:i,zoomDirectionSet:n,zoomPointSet:r,scaleZoomOrientationAtEdges:o}=this;if(n&&(r||this._updateZoomPoint())){if(Ps.setFromUnitVectors(e,t),o){this.getUpDirection(i,ys);let t=Math.max(ys.dot(e)-.6,0)/.4;t=Ot.mapLinear(t,0,.5,0,1),t=Math.min(t,1),s.isOrthographicCamera&&(t*=.1),Ps.slerp(Es,1-t)}cs(i,Ps,ms),s.updateMatrixWorld(),s.matrixWorld.premultiply(ms),s.matrixWorld.decompose(s.position,s.quaternion,ys),this.zoomDirectionSet=!1,this._updateZoomDirection()}e.copy(t),s.updateMatrixWorld()}_raycast(t){const{scene:e,useFallbackPlane:s,fallbackPlane:i}=this,n=t.intersectObject(e)[0]||null;if(n)return n;if(s){const e=i;if(t.ray.intersectPlane(e,ys))return{point:ys.clone(),distance:t.ray.origin.distanceTo(ys)}}return null}_alignCameraUp(t,e=1){const{camera:s,state:i,pivotPoint:n,zoomPoint:r,zoomPointSet:o}=this;s.updateMatrixWorld(),_s.set(0,0,-1).transformDirection(s.matrixWorld),Ts.set(-1,0,0).transformDirection(s.matrixWorld);let a=Ot.mapLinear(1-Math.abs(_s.dot(t)),0,.2,0,1);a=Ot.clamp(a,0,1),e*=a,vs.crossVectors(t,_s),vs.lerp(Ts,1-e).normalize(),Ps.setFromUnitVectors(Ts,vs),s.quaternion.premultiply(Ps);let l=null;1===i||2===i?l=bs.copy(n):o&&(l=bs.copy(r)),l&&(gs.copy(s.matrixWorld).invert(),ys.copy(l).applyMatrix4(gs),s.updateMatrixWorld(),ys.applyMatrix4(s.matrixWorld),xs.subVectors(l,ys),s.position.add(xs)),s.updateMatrixWorld()}_clampRotation(t){const{camera:e,minAltitude:s,maxAltitude:i,state:n,pivotPoint:r,zoomPoint:o,zoomPointSet:a}=this;let l,c;if(e.updateMatrixWorld(),_s.set(0,0,1).transformDirection(e.matrixWorld),Ts.set(1,0,0).transformDirection(e.matrixWorld),t.dot(_s)>1-1e-10?l=0:(ys.crossVectors(t,_s),l=Math.sign(ys.dot(Ts))*t.angleTo(_s)),l>i)c=i;else{if(!(l<s))return;c=s}_s.copy(t),Ps.setFromAxisAngle(Ts,c),_s.applyQuaternion(Ps).normalize(),ys.crossVectors(_s,Ts).normalize(),ms.makeBasis(Ts,ys,_s),e.quaternion.setFromRotationMatrix(ms);let h=null;1===n||2===n?h=bs.copy(r):a&&(h=bs.copy(o)),h&&(gs.copy(e.matrixWorld).invert(),ys.copy(h).applyMatrix4(gs),e.updateMatrixWorld(),ys.applyMatrix4(e.matrixWorld),xs.subVectors(h,ys),e.position.add(xs)),e.updateMatrixWorld()}}const Ns=new Ft,js=new Ft,Ws=new It,Gs=new It,Hs=new It,qs=new It,Zs=new It,Ys=new It,$s=new Gt,Xs=new It,Qs=new It,Js=new qt,Ks=new gt,ti=new kt,ei={};let si=class extends Bs{get tilesGroup(){return console.warn('GlobeControls: "tilesGroup" has been deprecated. Use "ellipsoidGroup", instead.'),this.ellipsoidFrame}get ellipsoidFrame(){return this.ellipsoidGroup.matrixWorld}get ellipsoidFrameInverse(){const{ellipsoidGroup:t,ellipsoidFrame:e,_ellipsoidFrameInverse:s}=this;return t.matrixWorldInverse?t.matrixWorldInverse:s.copy(e).invert()}constructor(t=null,e=null,s=null,i=null){super(t,e,s),this.isGlobeControls=!0,this._dragMode=0,this._rotationMode=0,this.maxZoom=.01,this.nearMargin=.25,this.farMargin=0,this.useFallbackPlane=!1,this.autoAdjustCameraRotation=!1,this.globeInertia=new Gt,this.globeInertiaFactor=0,this.ellipsoid=pe.clone(),this.ellipsoidGroup=new Ht,this._ellipsoidFrameInverse=new Ft,null!==i&&this.setTilesRenderer(i)}setTilesRenderer(t){super.setTilesRenderer(t),null!==t&&this.setEllipsoid(t.ellipsoid,t.group)}setEllipsoid(t,e){this.ellipsoid=t||pe.clone(),this.ellipsoidGroup=e||new Ht}getPivotPoint(t){const{camera:e,ellipsoidFrame:s,ellipsoidFrameInverse:i,ellipsoid:n}=this;return qs.set(0,0,-1).transformDirection(e.matrixWorld),Js.origin.copy(e.position),Js.direction.copy(qs),Js.applyMatrix4(i),n.closestPointToRayEstimate(Js,Gs).applyMatrix4(s),(null===super.getPivotPoint(t)||Ws.subVectors(t,Js.origin).dot(Js.direction)>Ws.subVectors(Gs,Js.origin).dot(Js.direction))&&t.copy(Gs),t}getVectorToCenter(t){const{ellipsoidFrame:e,camera:s}=this;return t.setFromMatrixPosition(e).sub(s.position)}getDistanceToCenter(){return this.getVectorToCenter(Gs).length()}getUpDirection(t,e){const{ellipsoidFrame:s,ellipsoidFrameInverse:i,ellipsoid:n}=this;Gs.copy(t).applyMatrix4(i),n.getPositionToNormal(Gs,e),e.transformDirection(s)}getCameraUpDirection(t){const{ellipsoidFrame:e,ellipsoidFrameInverse:s,ellipsoid:i,camera:n}=this;n.isOrthographicCamera?(this._getVirtualOrthoCameraPosition(Gs),Gs.applyMatrix4(s),i.getPositionToNormal(Gs,t),t.transformDirection(e)):this.getUpDirection(n.position,t)}update(t=Math.min(this.clock.getDelta(),.064)){if(!this.enabled||!this.camera||0===t)return;const{camera:e,pivotMesh:s}=this;this._isNearControls()?this.scaleZoomOrientationAtEdges=this.zoomDelta<0:(0!==this.state&&1!==this._dragMode&&1!==this._rotationMode&&(s.visible=!1),this.scaleZoomOrientationAtEdges=!1);const i=this.needsUpdate||this._inertiaNeedsUpdate();super.update(t),this.adjustCamera(e),i&&this._isNearControls()&&(this.getCameraUpDirection(Ys),this._alignCameraUp(Ys,1),this.getCameraUpDirection(Ys),this._clampRotation(Ys))}adjustCamera(t){super.adjustCamera(t);const{ellipsoidFrame:e,ellipsoidFrameInverse:s,ellipsoid:i,nearMargin:n,farMargin:r}=this,o=Math.max(...i.radius);if(t.isPerspectiveCamera){const a=Gs.setFromMatrixPosition(e).sub(t.position).length(),l=n*o,c=Ot.clamp((a-o)/l,0,1),h=Ot.lerp(1,1e3,c);t.near=Math.max(h,a-o-l),Ws.copy(t.position).applyMatrix4(s),i.getPositionToCartographic(Ws,ei);const u=Math.max(i.getPositionElevation(Ws),2550),d=i.calculateHorizonDistance(ei.lat,u);t.far=d+.1+o*r,t.updateProjectionMatrix()}else{this._getVirtualOrthoCameraPosition(t.position,t),t.updateMatrixWorld(),Ns.copy(t.matrixWorld).invert(),Gs.setFromMatrixPosition(e).applyMatrix4(Ns);const s=-Gs.z;t.near=s-o*(1+n),t.far=s+.1+o*r,t.position.addScaledVector(qs,t.near),t.far-=t.near,t.near=0,t.updateProjectionMatrix(),t.updateMatrixWorld()}}setState(...t){super.setState(...t),this._dragMode=0,this._rotationMode=0}_updateInertia(t){super._updateInertia(t);const{globeInertia:e,enableDamping:s,dampingFactor:i,camera:n,cameraRadius:r,minDistance:o,inertiaTargetDistance:a,ellipsoidFrame:l}=this;if(!this.enableDamping||this.inertiaStableFrames>1)return this.globeInertiaFactor=0,void this.globeInertia.identity();const c=Math.pow(2,-t/i),h=Math.max(n.near,r,o,a),u=25e-5;if(Hs.setFromMatrixPosition(l),0!==this.globeInertiaFactor){us(Js,Gs.set(0,0,-1),n),Js.applyMatrix4(n.matrixWorldInverse),Js.direction.normalize(),Js.recast(-Js.direction.dot(Js.origin)).at(h/Js.direction.z,Gs),Gs.applyMatrix4(n.matrixWorld),us(Js,Ws.set(u,u,-1),n),Js.applyMatrix4(n.matrixWorldInverse),Js.direction.normalize(),Js.recast(-Js.direction.dot(Js.origin)).at(h/Js.direction.z,Ws),Ws.applyMatrix4(n.matrixWorld),Gs.sub(Hs).normalize(),Ws.sub(Hs).normalize(),this.globeInertiaFactor*=c;const i=Gs.angleTo(Ws)/t;(2*Math.acos(e.w)*this.globeInertiaFactor<i||!s)&&(this.globeInertiaFactor=0,e.identity())}0!==this.globeInertiaFactor&&(1===e.w&&(0!==e.x||0!==e.y||0!==e.z)&&(e.w=Math.min(e.w,1-1e-9)),Hs.setFromMatrixPosition(l),$s.identity().slerp(e,this.globeInertiaFactor*t),cs(Hs,$s,js),n.matrixWorld.premultiply(js),n.matrixWorld.decompose(n.position,n.quaternion,Gs))}_inertiaNeedsUpdate(){return super._inertiaNeedsUpdate()||0!==this.globeInertiaFactor}_updatePosition(t){if(1===this.state){0===this._dragMode&&(this._dragMode=this._isNearControls()?1:-1);const{raycaster:e,camera:s,pivotPoint:i,pointerTracker:n,domElement:r,ellipsoidFrame:o,ellipsoidFrameInverse:a}=this,l=Ws,c=Zs;n.getCenterPoint(ti),hs(ti.x,ti.y,r,ti),us(e,ti,s),e.ray.applyMatrix4(a);const h=Gs.copy(i).applyMatrix4(a).length();if(Ks.radius.setScalar(h),!Ks.intersectRay(e.ray,Gs))return this.resetState(),void this._updateInertia(t);Gs.applyMatrix4(o),Hs.setFromMatrixPosition(o),l.subVectors(i,Hs).normalize(),c.subVectors(Gs,Hs).normalize(),$s.setFromUnitVectors(c,l),cs(Hs,$s,js),s.matrixWorld.premultiply(js),s.matrixWorld.decompose(s.position,s.quaternion,Gs),n.getMoveDistance()/t<2*window.devicePixelRatio?this.inertiaStableFrames++:(this.globeInertia.copy($s),this.globeInertiaFactor=1/t,this.inertiaStableFrames=0)}}_updateRotation(...t){1===this._rotationMode||this._isNearControls()?(this._rotationMode=1,super._updateRotation(...t)):(this.pivotMesh.visible=!1,this._rotationMode=-1)}_updateZoom(){const{zoomDelta:t,ellipsoid:e,zoomSpeed:s,zoomPoint:i,camera:n,maxZoom:r,state:o}=this;if(3!==o&&0===t)return;this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),this.globeInertia.identity(),this.globeInertiaFactor=0;const a=Ot.clamp(Ot.mapLinear(Math.abs(t),0,20,0,1),0,1);if(this._isNearControls()||t>0){if(this._updateZoomDirection(),t<0&&(this.zoomPointSet||this._updateZoomPoint())){qs.set(0,0,-1).transformDirection(n.matrixWorld).normalize(),Qs.copy(this.up).multiplyScalar(-1),this.getUpDirection(i,Xs);const t=Ot.clamp(Ot.mapLinear(-Xs.dot(Qs),1,.95,0,1),0,1),e=1-qs.dot(Qs),s=n.isOrthographicCamera?.05:1,r=Ot.clamp(3*a,0,1),o=Math.min(t*e*s*r,.1);Qs.lerpVectors(qs,Qs,o).normalize(),$s.setFromUnitVectors(qs,Qs),cs(i,$s,js),n.matrixWorld.premultiply(js),n.matrixWorld.decompose(n.position,n.quaternion,Qs),this.zoomDirection.subVectors(i,n.position).normalize()}super._updateZoom()}else if(n.isPerspectiveCamera){const i=this._getPerspectiveTransitionDistance(),n=this._getMaxPerspectiveDistance(),r=Ot.mapLinear(this.getDistanceToCenter(),i,n,0,1);this._tiltTowardsCenter(Ot.lerp(0,.4,r*a)),this._alignCameraUpToNorth(Ot.lerp(0,.2,r*a));const o=t*(this.getDistanceToCenter()-e.radius.x)*s*.0025,l=Math.max(o,Math.min(this.getDistanceToCenter()-n,0));this.getVectorToCenter(Gs).normalize(),this.camera.position.addScaledVector(Gs,l),this.camera.updateMatrixWorld(),this.zoomDelta=0}else{const t=this._getOrthographicTransitionZoom(),e=this._getMinOrthographicZoom(),i=Ot.mapLinear(n.zoom,t,e,0,1);this._tiltTowardsCenter(Ot.lerp(0,.4,i*a)),this._alignCameraUpToNorth(Ot.lerp(0,.2,i*a));const o=this.zoomDelta,l=Math.pow(.95,Math.abs(.05*o)),c=o>0?1/Math.abs(l):l,h=e/n.zoom,u=Math.max(c*s,Math.min(h,1));n.zoom=Math.min(r,n.zoom*u),n.updateProjectionMatrix(),this.zoomDelta=0,this.zoomDirectionSet=!1}}_alignCameraUpToNorth(t){const{ellipsoidFrame:e}=this;Ys.set(0,0,1).transformDirection(e),this._alignCameraUp(Ys,t)}_tiltTowardsCenter(t){const{camera:e,ellipsoidFrame:s}=this;qs.set(0,0,-1).transformDirection(e.matrixWorld).normalize(),Gs.setFromMatrixPosition(s).sub(e.position).normalize(),Gs.lerp(qs,1-t).normalize(),$s.setFromUnitVectors(qs,Gs),e.quaternion.premultiply($s),e.updateMatrixWorld()}_getPerspectiveTransitionDistance(){const{camera:t,ellipsoid:e}=this;if(!t.isPerspectiveCamera)throw new Error;const s=Math.max(...e.radius),i=2*Math.atan(Math.tan(Ot.DEG2RAD*t.fov*.5)*t.aspect),n=s/Math.tan(Ot.DEG2RAD*t.fov*.5),r=s/Math.tan(.5*i);return Math.max(n,r)}_getMaxPerspectiveDistance(){const{camera:t,ellipsoid:e}=this;if(!t.isPerspectiveCamera)throw new Error;const s=Math.max(...e.radius),i=2*Math.atan(Math.tan(Ot.DEG2RAD*t.fov*.5)*t.aspect),n=s/Math.tan(Ot.DEG2RAD*t.fov*.5),r=s/Math.tan(.5*i);return 2*Math.max(n,r)}_getOrthographicTransitionZoom(){const{camera:t,ellipsoid:e}=this;if(!t.isOrthographicCamera)throw new Error;const s=t.top-t.bottom,i=t.right-t.left;return 2*Math.max(s,i)/(2*Math.max(...e.radius))}_getMinOrthographicZoom(){const{camera:t,ellipsoid:e}=this;if(!t.isOrthographicCamera)throw new Error;const s=t.top-t.bottom,i=t.right-t.left;return.7*Math.min(s,i)/(2*Math.max(...e.radius))}_getVirtualOrthoCameraPosition(t,e=this.camera){const{ellipsoidFrame:s,ellipsoidFrameInverse:i,ellipsoid:n}=this;if(!e.isOrthographicCamera)throw new Error;Js.origin.copy(e.position),Js.direction.set(0,0,-1).transformDirection(e.matrixWorld),Js.applyMatrix4(i),n.closestPointToRayEstimate(Js,Ws).applyMatrix4(s);const r=e.top-e.bottom,o=e.right-e.left,a=Math.max(r,o)/e.zoom;qs.set(0,0,-1).transformDirection(e.matrixWorld);const l=Ws.sub(e.position).dot(qs);t.copy(e.position).addScaledVector(qs,l-4*a)}_isNearControls(){const{camera:t}=this;return t.isPerspectiveCamera?this.getDistanceToCenter()<this._getPerspectiveTransitionDistance():t.zoom>this._getOrthographicTransitionZoom()}_raycast(t){const e=super._raycast(t);if(null===e){const{ellipsoid:e,ellipsoidFrame:s,ellipsoidFrameInverse:i}=this;Js.copy(t.ray).applyMatrix4(i);const n=e.intersectRay(Js,Gs);return null!==n?(n.applyMatrix4(s),{point:n.clone(),distance:n.distanceTo(t.ray.origin)}):null}return e}};const ii=new It,ni=new It,ri=new oe,oi=new It,ai=new It,li=new It,ci=new Gt,hi=new Gt;class ui extends Qt{get animating(){return 0!==this._alpha&&1!==this._alpha}get alpha(){return 0===this._target?1-this._alpha:this._alpha}get camera(){return 0===this._alpha?this.perspectiveCamera:1===this._alpha?this.orthographicCamera:this.transitionCamera}get mode(){return 0===this._target?"perspective":"orthographic"}set mode(t){if(t===this.mode)return;const e=this.camera;"perspective"===t?(this._target=0,this._alpha=0):(this._target=1,this._alpha=1),this.dispatchEvent({type:"camera-change",camera:this.camera,prevCamera:e})}constructor(t=new re,e=new oe){super(),this.perspectiveCamera=t,this.orthographicCamera=e,this.transitionCamera=new re,this.orthographicPositionalZoom=!0,this.orthographicOffset=50,this.fixedPoint=new It,this.duration=200,this.autoSync=!0,this.easeFunction=t=>t,this._target=0,this._alpha=0,this._clock=new ne}toggle(){this._target=1===this._target?0:1,this._clock.getDelta(),this.dispatchEvent({type:"toggle"})}update(t=Math.min(this._clock.getDelta(),.064)){this.autoSync&&this.syncCameras();const{perspectiveCamera:e,orthographicCamera:s,transitionCamera:i,camera:n}=this,r=1e3*t;if(this._alpha!==this._target){const t=Math.sign(this._target-this._alpha)*r/this.duration;this._alpha=Ot.clamp(this._alpha+t,0,1),this.dispatchEvent({type:"change",alpha:this.alpha})}const o=n;let a=null;0===this._alpha?a=e:1===this._alpha?a=s:(a=i,this._updateTransitionCamera()),o!==a&&(a===i&&this.dispatchEvent({type:"transition-start"}),this.dispatchEvent({type:"camera-change",camera:a,prevCamera:o}),o===i&&this.dispatchEvent({type:"transition-end"}))}syncCameras(){const t=this._getFromCamera(),{perspectiveCamera:e,orthographicCamera:s,transitionCamera:i,fixedPoint:n}=this;if(ii.set(0,0,-1).transformDirection(t.matrixWorld).normalize(),t.isPerspectiveCamera){if(this.orthographicPositionalZoom)s.position.copy(e.position).addScaledVector(ii,-this.orthographicOffset),s.rotation.copy(e.rotation),s.updateMatrixWorld();else{const t=ni.subVectors(n,s.position).dot(ii),i=ni.subVectors(n,e.position).dot(ii);ni.copy(e.position).addScaledVector(ii,i),s.rotation.copy(e.rotation),s.position.copy(ni).addScaledVector(ii,-t),s.updateMatrixWorld()}const t=Math.abs(ni.subVectors(e.position,n).dot(ii)),i=2*Math.tan(Ot.DEG2RAD*e.fov*.5)*t,r=s.top-s.bottom;s.zoom=r/i,s.updateProjectionMatrix()}else{const t=Math.abs(ni.subVectors(s.position,n).dot(ii)),i=(s.top-s.bottom)/s.zoom*.5/Math.tan(Ot.DEG2RAD*e.fov*.5);e.rotation.copy(s.rotation),e.position.copy(s.position).addScaledVector(ii,t).addScaledVector(ii,-i),e.updateMatrixWorld(),this.orthographicPositionalZoom&&(s.position.copy(e.position).addScaledVector(ii,-this.orthographicOffset),s.updateMatrixWorld())}i.position.copy(e.position),i.rotation.copy(e.rotation)}_getTransitionDirection(){return Math.sign(this._target-this._alpha)}_getToCamera(){const t=this._getTransitionDirection();return 0===t?0===this._target?this.perspectiveCamera:this.orthographicCamera:t>0?this.orthographicCamera:this.perspectiveCamera}_getFromCamera(){const t=this._getTransitionDirection();return 0===t?0===this._target?this.perspectiveCamera:this.orthographicCamera:t>0?this.perspectiveCamera:this.orthographicCamera}_updateTransitionCamera(){const{perspectiveCamera:t,orthographicCamera:e,transitionCamera:s,fixedPoint:i}=this,n=this.easeFunction(this._alpha);ii.set(0,0,-1).transformDirection(e.matrixWorld).normalize(),ri.copy(e),ri.position.addScaledVector(ii,e.near),e.far-=e.near,e.near=0,ii.set(0,0,-1).transformDirection(t.matrixWorld).normalize();const r=Math.abs(ni.subVectors(t.position,i).dot(ii)),o=2*Math.tan(Ot.DEG2RAD*t.fov*.5)*r,a=hi.slerpQuaternions(t.quaternion,ri.quaternion,n),l=Ot.lerp(t.fov,1,n),c=.5*o/Math.tan(Ot.DEG2RAD*l*.5),h=li.copy(ri.position).sub(i).applyQuaternion(ci.copy(ri.quaternion).invert()),u=ai.copy(t.position).sub(i).applyQuaternion(ci.copy(t.quaternion).invert()),d=oi.lerpVectors(u,h,n);d.z-=Math.abs(d.z)-c;const p=-(u.z-d.z),m=-(h.z-d.z),g=Ot.lerp(p+t.near,m+ri.near,n),f=Ot.lerp(p+t.far,m+ri.far,n),y=Math.max(f,0)-Math.max(g,0);s.aspect=t.aspect,s.fov=l,s.near=Math.max(g,1e-5*y),s.far=f,s.position.copy(d).applyQuaternion(a).add(i),s.quaternion.copy(a),s.updateProjectionMatrix(),s.updateMatrixWorld()}}const di="https://tile.googleapis.com/v1/createSession";let pi=class{get isMapTilesSession(){return this.authURL===di}constructor(t={}){const{apiToken:e,sessionOptions:s=null,autoRefreshToken:i=!1}=t;this.apiToken=e,this.autoRefreshToken=i,this.authURL=di,this.sessionToken=null,this.sessionOptions=s,this._tokenRefreshPromise=null}async fetch(t,e){null===this.sessionToken&&this.isMapTilesSession&&this.refreshToken(e),await this._tokenRefreshPromise;const s=new URL(t);s.searchParams.set("key",this.apiToken),this.sessionToken&&s.searchParams.set("session",this.sessionToken);let i=await fetch(s,e);return i.status>=400&&i.status<=499&&this.autoRefreshToken&&(await this.refreshToken(e),this.sessionToken&&s.searchParams.set("session",this.sessionToken),i=await fetch(s,e)),null!==this.sessionToken||this.isMapTilesSession?i:i.json().then(t=>(this.sessionToken=mi(t),t))}refreshToken(t){if(null===this._tokenRefreshPromise){const e=new URL(this.authURL);e.searchParams.set("key",this.apiToken);const s={...t};this.isMapTilesSession&&(s.method="POST",s.body=JSON.stringify(this.sessionOptions),s.headers=s.headers||{},s.headers={...s.headers,"Content-Type":"application/json"}),this._tokenRefreshPromise=fetch(e,s).then(t=>{if(!t.ok)throw new Error(`GoogleCloudAuth: Failed to load data with error code ${t.status}`);return t.json()}).then(t=>(this.sessionToken=mi(t),this._tokenRefreshPromise=null,t))}return this._tokenRefreshPromise}};function mi(t){if("session"in t)return t.session;{let e=null;return m(t.root,t=>{if(t.content&&t.content.uri){const[,s]=t.content.uri.split("?");return e=new URLSearchParams(s).get("session"),!0}return!1}),e}}let gi=class{constructor(t={}){const{apiToken:e,autoRefreshToken:s=!1}=t;this.apiToken=e,this.autoRefreshToken=s,this.authURL=null,this._tokenRefreshPromise=null,this._bearerToken=null}async fetch(t,e){await this._tokenRefreshPromise;const s={...e};s.headers=s.headers||{},s.headers={...s.headers,Authorization:this._bearerToken};const i=await fetch(t,s);return i.status>=400&&i.status<=499&&this.autoRefreshToken?(await this.refreshToken(e),s.headers.Authorization=this._bearerToken,fetch(t,s)):i}refreshToken(t){if(null===this._tokenRefreshPromise){const e=new URL(this.authURL);e.searchParams.set("access_token",this.apiToken),this._tokenRefreshPromise=fetch(e,t).then(t=>{if(!t.ok)throw new Error(`CesiumIonAuthPlugin: Failed to load data with error code ${t.status}`);return t.json()}).then(t=>(this._bearerToken=`Bearer ${t.accessToken}`,this._tokenRefreshPromise=null,t))}return this._tokenRefreshPromise}};function fi(t){return t>>1^-(1&t)}let yi=class extends x{constructor(...t){super(...t),this.fetchOptions.header={Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9"}}loadAsync(...t){const{fetchOptions:e}=this;return e.header=e.header||{},e.header.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",e.header.Accept+=";extensions=octvertexnormals-watermask-metadata",super.loadAsync(...t)}parse(t){let e=0;const s=new DataView(t),i=()=>{const t=s.getFloat64(e,!0);return e+=8,t},n=()=>{const t=s.getFloat32(e,!0);return e+=4,t},r=()=>{const t=s.getUint32(e,!0);return e+=4,t},o=()=>{const t=s.getUint8(e);return e+=1,t},a=(s,i)=>{const n=new i(t,e,s);return e+=s*i.BYTES_PER_ELEMENT,n},l={center:[i(),i(),i()],minHeight:n(),maxHeight:n(),sphereCenter:[i(),i(),i()],sphereRadius:i(),horizonOcclusionPoint:[i(),i(),i()]},c=r(),h=a(c,Uint16Array),u=a(c,Uint16Array),d=a(c,Uint16Array),p=new Float32Array(c),m=new Float32Array(c),g=new Float32Array(c);let f=0,y=0,b=0;const x=32767;for(let D=0;D<c;++D)f+=fi(h[D]),y+=fi(u[D]),b+=fi(d[D]),p[D]=f/x,m[D]=y/x,g[D]=b/x;const _=c>65536,T=_?Uint32Array:Uint16Array;e=_?4*Math.ceil(e/4):2*Math.ceil(e/2);const v=a(3*r(),T);let w=0;for(var P=0;P<v.length;++P){const t=v[P];v[P]=w-t,0===t&&++w}const M=(t,e)=>m[e]-m[t],C=(t,e)=>p[t]-p[e],S=a(r(),T);S.sort(M);const A=a(r(),T);A.sort(C);const E=a(r(),T);E.sort((t,e)=>-M(t,e));const L=a(r(),T);L.sort((t,e)=>-C(t,e));const U={westIndices:S,southIndices:A,eastIndices:E,northIndices:L},R={};for(;e<s.byteLength;){const t=o(),e=r();if(1===t){const e=a(2*c,Uint8Array),s=new Float32Array(3*c);for(let t=0;t<c;t++){let i=e[2*t+0]/255*2-1,n=e[2*t+1]/255*2-1;const r=1-(Math.abs(i)+Math.abs(n));if(r<0){const t=i;i=(1-Math.abs(n))*bi(t),n=(1-Math.abs(t))*bi(n)}const o=Math.sqrt(i*i+n*n+r*r);s[3*t+0]=i/o,s[3*t+1]=n/o,s[3*t+2]=r/o}R.octvertexnormals={extensionId:t,normals:s}}else if(2===t){const s=1===e?1:256,i=a(s*s,Uint8Array);R.watermask={extensionId:t,mask:i,size:s}}else if(4===t){const e=a(r(),Uint8Array),s=(new TextDecoder).decode(e);R.metadata={extensionId:t,json:JSON.parse(s)}}}return{header:l,indices:v,vertexData:{u:p,v:m,height:g},edgeIndices:U,extensions:R}}};function bi(t){return t<0?-1:1}const xi=await a("three"),{PlaneGeometry:_i,Mesh:Ti,MeshBasicMaterial:vi,Vector2:wi,MathUtils:Pi,Vector3:Mi,Sphere:Ci,Texture:Si,SRGBColorSpace:Ai,DefaultLoadingManager:Ei,BufferGeometry:Li,MeshStandardMaterial:Ui,BufferAttribute:Ri,DataTexture:Di,RGFormat:Fi,UnsignedByteType:Ii,LinearMipMapLinearFilter:ki,LinearFilter:Oi,Triangle:Vi,Vector4:zi,Matrix4:Bi,Matrix3:Ni,Matrix2:ji,WebGLRenderer:Wi,WebGLRenderTarget:Gi,ShaderMaterial:Hi,OneFactor:qi,ZeroFactor:Zi,CustomBlending:Yi,Box2:$i,FileLoader:Xi,Quaternion:Qi,BatchedMesh:Ji,Source:Ki,Box3:tn,REVISION:en,WebGLArrayRenderTarget:sn,Raycaster:nn,DoubleSide:rn,OrthographicCamera:on,Color:an,CanvasTexture:ln,Ray:cn,LineSegments:hn,LineBasicMaterial:un,EdgesGeometry:dn,BoxGeometry:pn,Group:mn,Box3Helper:gn,PointsMaterial:fn}=await a("three");class yn{constructor(){this.creditsCount={}}_adjustAttributions(t,e){const s=this.creditsCount,i=t.split(/;/g);for(let n=0,r=i.length;n<r;n++){const t=i[n];t in s||(s[t]=0),s[t]+=e?1:-1,s[t]<=0&&delete s[t]}}addAttributions(t){this._adjustAttributions(t,!0)}removeAttributions(t){this._adjustAttributions(t,!1)}toString(){return Object.entries(this.creditsCount).sort((t,e)=>{const s=t[1];return e[1]-s}).map(t=>t[0]).join("; ")}}class bn{constructor({apiToken:t,sessionOptions:e=null,autoRefreshToken:s=!1,logoUrl:i=null,useRecommendedSettings:n=!0}){this.name="GOOGLE_CLOUD_AUTH_PLUGIN",this.apiToken=t,this.useRecommendedSettings=n,this.logoUrl=i,this.auth=new pi({apiToken:t,autoRefreshToken:s,sessionOptions:e}),this.tiles=null,this._visibilityChangeCallback=null,this._attributionsManager=new yn,this._logoAttribution={value:"",type:"image",collapsible:!1},this._attribution={value:"",type:"string",collapsible:!0}}init(t){const{useRecommendedSettings:e,auth:s}=this;t.resetFailedTiles(),null==t.rootURL&&(t.rootURL="https://tile.googleapis.com/v1/3dtiles/root.json"),s.sessionOptions||(s.authURL=t.rootURL),e&&!s.isMapTilesSession&&(t.errorTarget=20),this.tiles=t,this._visibilityChangeCallback=({tile:t,visible:e})=>{var s,i;const n=(null==(i=null==(s=t.cached.metadata)?void 0:s.asset)?void 0:i.copyright)||"";e?this._attributionsManager.addAttributions(n):this._attributionsManager.removeAttributions(n)},t.addEventListener("tile-visibility-change",this._visibilityChangeCallback)}getAttributions(t){this.tiles.visibleTiles.size>0&&(this.logoUrl&&(this._logoAttribution.value=this.logoUrl,t.push(this._logoAttribution)),this._attribution.value=this._attributionsManager.toString(),t.push(this._attribution))}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._visibilityChangeCallback)}async fetchData(t,e){return this.auth.fetch(t,e)}}const xn=new wi,_n=Symbol("TILE_X"),Tn=Symbol("TILE_Y"),vn=Symbol("TILE_LEVEL");class wn{get tiling(){return this.imageSource.tiling}constructor(t={}){const{pixelSize:e=null,center:s=!1,useRecommendedSettings:i=!0,imageSource:n=null}=t;this.priority=-10,this.tiles=null,this.imageSource=n,this.pixelSize=e,this.center=s,this.useRecommendedSettings=i,null!==e&&console.warn('ImageFormatPlugin: "pixelSize" has been deprecated in favor of scaling the tiles root.')}init(t){this.useRecommendedSettings&&(t.errorTarget=1),this.tiles=t,this.imageSource.fetchOptions=t.fetchOptions,this.imageSource.fetchData=(e,s)=>(t.invokeAllPlugins(t=>e=t.preprocessURL?t.preprocessURL(e,null):e),t.invokeOnePlugin(t=>t!==this&&t.fetchData&&t.fetchData(e,s)))}async loadRootTileSet(){const{tiles:t,imageSource:e}=this;return e.url=e.url||t.rootURL,t.invokeAllPlugins(t=>e.url=t.preprocessURL?t.preprocessURL(e.url,null):e.url),await e.init(),t.rootURL=e.url,this.getTileset(e.url)}async parseToMesh(t,e,s,i,n){if(n.aborted)return null;const{imageSource:r}=this,o=e[_n],a=e[Tn],l=e[vn],c=await r.processBufferToTexture(t);if(n.aborted)return c.dispose(),c.image.close(),null;r.setData(o,a,l,c);let h=1,u=1,d=0,p=0,m=0;const g=e.boundingVolume.box;g&&([d,p,m]=g,h=g[3],u=g[7]);const f=new _i(2*h,2*u),y=new Ti(f,new vi({map:c,transparent:!0}));y.position.set(d,p,m);const b=r.tiling.getTileContentUVBounds(o,a,l),{uv:x}=f.attributes;for(let _=0;_<x.count;_++)xn.fromBufferAttribute(x,_),xn.x=Pi.mapLinear(xn.x,0,1,b[0],b[2]),xn.y=Pi.mapLinear(xn.y,0,1,b[1],b[3]),x.setXY(_,xn.x,xn.y);return y}preprocessNode(t){const{tiling:e}=this,s=e.maxLevel;t[vn]<s&&null!==t.parent&&this.expandChildren(t)}disposeTile(t){const e=t[_n],s=t[Tn],i=t[vn],{imageSource:n}=this;n.has(e,s,i)&&n.release(e,s,i)}getTileset(t){const{tiling:e,tiles:s}=this,i=e.minLevel,{tileCountX:n,tileCountY:r}=e.getLevel(i),o=[];for(let l=0;l<n;l++)for(let t=0;t<r;t++){const e=this.createChild(l,t,i);null!==e&&o.push(e)}const a={asset:{version:"1.1"},geometricError:1e5,root:{refine:"REPLACE",geometricError:1e5,boundingVolume:this.createBoundingVolume(0,0,-1),children:o,[vn]:-1,[_n]:0,[Tn]:0}};return s.preprocessTileSet(a,t),a}getUrl(t,e,s){return this.imageSource.getUrl(t,e,s)}createBoundingVolume(t,e,s){const{center:i,pixelSize:n,tiling:r}=this,{pixelWidth:o,pixelHeight:a}=r.getLevel(r.maxLevel),[l,c,h,u]=-1===s?r.getContentBounds(!0):r.getTileBounds(t,e,s,!0);let d=(h-l)/2,p=(u-c)/2,m=l+d,g=c+p;return i&&(m-=.5,g-=.5),n?(m*=o*n,d*=o*n,g*=a*n,p*=a*n):(m*=r.aspectRatio,d*=r.aspectRatio),{box:[m,g,0,d,0,0,0,p,0,0,0,0]}}createChild(t,e,s){const{pixelSize:i,tiling:n}=this;if(!n.getTileExists(t,e,s))return null;const{pixelWidth:r,pixelHeight:o}=n.getLevel(n.maxLevel),{pixelWidth:a,pixelHeight:l}=n.getLevel(s);let c=Math.max(1/a,1/l);return i&&(c*=i*Math.max(r,o)),{refine:"REPLACE",geometricError:c,boundingVolume:this.createBoundingVolume(t,e,s),content:{uri:this.getUrl(t,e,s)},children:[],[_n]:t,[Tn]:e,[vn]:s}}expandChildren(t){const e=t[vn],s=t[_n],i=t[Tn];for(let n=0;n<2;n++)for(let r=0;r<2;r++){const o=this.createChild(2*s+n,2*i+r,e+1);o&&t.children.push(o)}}}const Pn=new Mi,Mn=new Mi;const Cn=new Mi,Sn=new Mi,An=new wi,En=new Ci;class Ln extends wn{get projection(){return this.tiling.projection}constructor(t={}){const{shape:e="planar",endCaps:s=!0,...i}=t;super(i),this.shape=e,this.endCaps=s}async parseToMesh(t,e,...s){const i=await super.parseToMesh(t,e,...s),{shape:n,projection:r,tiles:o,tiling:a}=this;if("ellipsoid"===n){const t=o.ellipsoid,s=e[vn],n=e[_n],l=e[Tn],[c,h,u,d]=e.boundingVolume.region,p=Math.ceil((d-h)*Pi.RAD2DEG*.25),m=Math.ceil((u-c)*Pi.RAD2DEG*.25),g=Math.max(15,p),f=Math.max(30,m),y=new _i(1,1,f,g),[b,x,_,T]=a.getTileBounds(n,l,s,!0,!0),v=a.getTileContentUVBounds(n,l,s),{position:w,normal:P,uv:M}=y.attributes,C=w.count;e.cached.boundingVolume.getSphere(En);for(let e=0;e<C;e++){Cn.fromBufferAttribute(w,e),An.fromBufferAttribute(M,e);const s=r.convertProjectionToLongitude(Pi.mapLinear(An.x,0,1,b,_));let i=r.convertProjectionToLatitude(Pi.mapLinear(An.y,0,1,x,T));if(r.isMercator&&this.endCaps&&(1===T&&1===An.y&&(i=Math.PI/2),0===x&&0===An.y&&(i=-Math.PI/2)),r.isMercator&&0!==An.y&&1!==An.y){const t=r.convertProjectionToLatitude(1),e=1/g,s=Pi.mapLinear(An.y-e,0,1,h,d),n=Pi.mapLinear(An.y+e,0,1,h,d);i>t&&s<t&&(i=t),i<-t&&n>-t&&(i=-t)}t.getCartographicToPosition(i,s,0,Cn).sub(En.center),t.getCartographicToNormal(i,s,Sn);const n=Pi.mapLinear(r.convertLongitudeToProjection(s),b,_,v[0],v[2]),o=Pi.mapLinear(r.convertLatitudeToProjection(i),x,T,v[1],v[3]);M.setXY(e,n,o),w.setXYZ(e,...Cn),P.setXYZ(e,...Sn)}i.geometry=y,i.position.copy(En.center)}return i}createBoundingVolume(t,e,s){if("ellipsoid"===this.shape){const{tiling:i,endCaps:n}=this,r=-1===s,o=r?i.getContentBounds(!0):i.getTileBounds(t,e,s,!0,!0),a=r?i.getContentBounds():i.getTileBounds(t,e,s,!1,!0);return n&&(1===o[3]&&(a[3]=Math.PI/2),0===o[1]&&(a[1]=-Math.PI/2)),{region:[...a,-1,1]}}return super.createBoundingVolume(t,e,s)}createChild(...t){const e=super.createChild(...t),{shape:s,projection:i,tiling:n}=this;if(e&&"ellipsoid"===s){const t=e[vn],s=e[_n],r=e[Tn];if(-1===t)return e.geometricError=1e50,parent;const[o,a,l,c]=n.getTileBounds(s,r,t,!0),{tilePixelWidth:h,tilePixelHeight:u}=n.getLevel(t),d=(l-o)/h,p=(c-a)/u,[,m,g,f]=n.getTileBounds(s,r,t),y=m>0!=f>0?0:Math.min(Math.abs(m),Math.abs(f)),b=i.convertLatitudeToProjection(y),x=i.getLongitudeDerivativeAtProjection(o),_=i.getLatitudeDerivativeAtProjection(b),[T,v]=function(t,e,s){const i=s+1e-5;let n=e+1e-5;Math.abs(n)>Math.PI/2&&(n-=1e-5),t.getCartographicToPosition(e,s,0,Pn),t.getCartographicToPosition(n,s,0,Mn);const r=Pn.distanceTo(Mn)/1e-5;return t.getCartographicToPosition(e,i,0,Mn),[Pn.distanceTo(Mn)/1e-5,r]}(this.tiles.ellipsoid,y,g),w=Math.max(d*x*T,p*_*v);e.geometricError=w}return e}}class Un{get isMercator(){return"EPSG:3857"===this.scheme}constructor(t="EPSG:4326"){this.scheme=t,this.tileCountX=1,this.tileCountY=1,this.setScheme(t)}setScheme(t){switch(this.scheme=t,t){case"EPSG:4326":this.tileCountX=2,this.tileCountY=1;break;case"EPSG:3857":this.tileCountX=1,this.tileCountY=1;break;default:throw new Error}}convertProjectionToLatitude(t){if(this.isMercator){const e=Pi.mapLinear(t,0,1,-1,1);return 2*Math.atan(Math.exp(e*Math.PI))-Math.PI/2}return Pi.mapLinear(t,0,1,-Math.PI/2,Math.PI/2)}convertProjectionToLongitude(t){return Pi.mapLinear(t,0,1,-Math.PI,Math.PI)}convertLatitudeToProjection(t){if(this.isMercator){return.5+1*Math.log(Math.tan(Math.PI/4+t/2))/(2*Math.PI)}return Pi.mapLinear(t,-Math.PI/2,Math.PI/2,0,1)}convertLongitudeToProjection(t){return(t+Math.PI)/(2*Math.PI)}getLongitudeDerivativeAtProjection(t){return 2*Math.PI}getLatitudeDerivativeAtProjection(t){let e=t-1e-5;return e<0&&(e=t+1e-5),this.isMercator?Math.abs(this.convertProjectionToLatitude(t)-this.convertProjectionToLatitude(e))/1e-5:Math.PI}getBounds(){return[this.convertProjectionToLongitude(0),this.convertProjectionToLatitude(0),this.convertProjectionToLongitude(1),this.convertProjectionToLatitude(1)]}}function Rn(...t){return t.join("_")}class Dn{constructor(){this.cache={},this.count=0,this.cachedBytes=0,this.active=0}fetchItem(){}disposeItem(){}getMemoryUsage(t){return 0}setData(...t){const{cache:e}=this,s=t.pop(),i=Rn(...t);if(i in e)throw new Error(`DataCache: "${i}" is already present.`);return this.cache[i]={abortController:new AbortController,result:s,count:1,bytes:this.getMemoryUsage(s)},this.count++,this.cachedBytes+=this.cache[i].bytes,s}lock(...t){const{cache:e}=this,s=Rn(...t);if(s in e)e[s].count++;else{const e=new AbortController,i={abortController:e,result:null,count:1,bytes:0};this.active++,i.result=this.fetchItem(t,e.signal),i.result instanceof Promise?i.result.then(t=>(i.result=t,i.bytes=this.getMemoryUsage(t),this.cachedBytes+=i.bytes,t)).finally(()=>{this.active--}).catch(t=>{}):(this.active--,i.bytes=this.getMemoryUsage(i.result),this.cachedBytes+=i.bytes),this.cache[s]=i,this.count++}return e[s].result}release(...t){const e=Rn(...t);this.releaseViaFullKey(e)}get(...t){const{cache:e}=this,s=Rn(...t);return s in e&&e[s].count>0?e[s].result:null}has(...t){const{cache:e}=this;return Rn(...t)in e}dispose(){const{cache:t}=this;for(const e in t){const{abortController:s}=t[e];s.abort(),this.releaseViaFullKey(e,!0)}this.cache={}}releaseViaFullKey(t,e=!1){const{cache:s}=this;if(t in s&&s[t].count>0){const i=s[t];if(i.count--,0===i.count||e){const n=()=>{if(s[t]!==i)return;const{result:e,abortController:n}=i;n.abort(),e instanceof Promise?e.then(t=>{this.disposeItem(t),this.count--,this.cachedBytes-=i.bytes}).catch(()=>{}):(this.disposeItem(e),this.count--,this.cachedBytes-=i.bytes),delete s[t]};e?n():queueMicrotask(()=>{0===i.count&&n()})}return!0}throw new Error("DataCache: Attempting to release key that does not exist")}}class Fn{get levelCount(){return this._levels.length}get maxLevel(){return this.levelCount-1}get minLevel(){const t=this._levels;for(let e=0;e<t.length;e++)if(null!==t[e])return e;return-1}get contentBounds(){var t;return this._contentBounds??(null==(t=this.projection)?void 0:t.getBounds())??[0,0,1,1]}get aspectRatio(){const{pixelWidth:t,pixelHeight:e}=this.getLevel(this.maxLevel);return t/e}constructor(){this.flipY=!1,this.pixelOverlap=0,this._contentBounds=null,this.projection=null,this._levels=[]}setLevel(t,e={}){const s=this._levels;for(;s.length<t;)s.push(null);const{tilePixelWidth:i=256,tilePixelHeight:n=256,tileCountX:r=2**t,tileCountY:o=2**t,tileBounds:a=null}=e,{pixelWidth:l=i*r,pixelHeight:c=n*o}=e;s[t]={tilePixelWidth:i,tilePixelHeight:n,pixelWidth:l,pixelHeight:c,tileCountX:r,tileCountY:o,tileBounds:a}}generateLevels(t,e,s,i={}){const{minLevel:n=0,tilePixelWidth:r=256,tilePixelHeight:o=256}=i,a=t-1,{pixelWidth:l=r*e*2**a,pixelHeight:c=o*s*2**a}=i;for(let h=n;h<t;h++){const e=t-h-1,s=Math.ceil(l*2**-e),i=Math.ceil(c*2**-e),n=Math.ceil(s/r),a=Math.ceil(i/o);this.setLevel(h,{tilePixelWidth:r,tilePixelHeight:o,pixelWidth:s,pixelHeight:i,tileCountX:n,tileCountY:a})}}getLevel(t){return this._levels[t]}setContentBounds(t,e,s,i){this._contentBounds=[t,e,s,i]}setProjection(t){this.projection=t}getTileAtPoint(t,e,s,i=!1){const{flipY:n}=this,{tileCountX:r,tileCountY:o,tileBounds:a}=this.getLevel(s),l=1/r,c=1/o;if(i||([t,e]=this.toNormalizedPoint(t,e)),a){const s=this.toNormalizedRange(a);t=Pi.mapLinear(t,s[0],s[2],0,1),e=Pi.mapLinear(e,s[1],s[3],0,1)}const h=Math.floor(t/l);let u=Math.floor(e/c);return n&&(u=o-1-u),[h,u]}getTilesInRange(t,e,s,i,n,r=!1){[t,e,s,i]=this.clampToContentBounds([t,e,s,i],r);const o=this.getTileAtPoint(t,e,n,r),a=this.getTileAtPoint(s,i,n,r);this.flipY&&([o[1],a[1]]=[a[1],o[1]]);const{tileCountX:l,tileCountY:c}=this.getLevel(n),[h,u]=o,[d,p]=a;return d<0||p<0||h>=l||u>=c?[0,0,-1,-1]:[Pi.clamp(h,0,l-1),Pi.clamp(u,0,c-1),Pi.clamp(d,0,l-1),Pi.clamp(p,0,c-1)]}getTileExists(t,e,s){const[i,n,r,o]=this.contentBounds,[a,l,c,h]=this.getTileBounds(t,e,s);return!(a>=c||l>=h)&&a<=r&&l<=o&&c>=i&&h>=n}getContentBounds(t=!1){const{projection:e}=this,s=[...this.contentBounds];return e&&t&&(s[0]=e.convertLongitudeToProjection(s[0]),s[1]=e.convertLatitudeToProjection(s[1]),s[2]=e.convertLongitudeToProjection(s[2]),s[3]=e.convertLatitudeToProjection(s[3])),s}getTileContentUVBounds(t,e,s){const[i,n,r,o]=this.getTileBounds(t,e,s,!0,!0),[a,l,c,h]=this.getTileBounds(t,e,s,!0,!1);return[Pi.mapLinear(i,a,c,0,1),Pi.mapLinear(n,l,h,0,1),Pi.mapLinear(r,a,c,0,1),Pi.mapLinear(o,l,h,0,1)]}getTileBounds(t,e,s,i=!1,n=!0){const{flipY:r,pixelOverlap:o,projection:a}=this,{tilePixelWidth:l,tilePixelHeight:c,pixelWidth:h,pixelHeight:u,tileBounds:d}=this.getLevel(s);let p=l*t-o,m=c*e-o,g=p+l+2*o,f=m+c+2*o;if(p=Math.max(p,0),m=Math.max(m,0),g=Math.min(g,h),f=Math.min(f,u),p/=h,g/=h,m/=u,f/=u,r){const t=(f-m)/2,e=1-(m+f)/2;m=e-t,f=e+t}let y=[p,m,g,f];if(d){const t=this.toNormalizedRange(d);y[0]=Pi.mapLinear(y[0],0,1,t[0],t[2]),y[2]=Pi.mapLinear(y[2],0,1,t[0],t[2]),y[1]=Pi.mapLinear(y[1],0,1,t[1],t[3]),y[3]=Pi.mapLinear(y[3],0,1,t[1],t[3])}return n&&(y=this.clampToProjectionBounds(y,!0)),a&&!i&&(y[0]=a.convertProjectionToLongitude(y[0]),y[1]=a.convertProjectionToLatitude(y[1]),y[2]=a.convertProjectionToLongitude(y[2]),y[3]=a.convertProjectionToLatitude(y[3])),y}toNormalizedPoint(t,e){const{projection:s}=this,i=[t,e];return this.projection&&(i[0]=s.convertLongitudeToProjection(i[0]),i[1]=s.convertLatitudeToProjection(i[1])),i}toNormalizedRange(t){return[...this.toNormalizedPoint(t[0],t[1]),...this.toNormalizedPoint(t[2],t[3])]}toCartographicPoint(t,e){const{projection:s}=this,i=[t,e];if(!this.projection)throw new Error("TilingScheme: Projection not available.");return i[0]=s.convertProjectionToLongitude(i[0]),i[1]=s.convertProjectionToLatitude(i[1]),i}toCartographicRange(t){return[...this.toCartographicPoint(t[0],t[1]),...this.toCartographicPoint(t[2],t[3])]}clampToContentBounds(t,e=!1){const s=[...t],[i,n,r,o]=this.getContentBounds(e);return s[0]=Pi.clamp(s[0],i,r),s[1]=Pi.clamp(s[1],n,o),s[2]=Pi.clamp(s[2],i,r),s[3]=Pi.clamp(s[3],n,o),s}clampToProjectionBounds(t,e=!1){const s=[...t],{projection:i}=this;let n;n=e||!i?[0,0,1,1]:i.getBounds();const[r,o,a,l]=n;return s[0]=Pi.clamp(s[0],r,a),s[1]=Pi.clamp(s[1],o,l),s[2]=Pi.clamp(s[2],r,a),s[3]=Pi.clamp(s[3],o,l),s}}class In extends Dn{constructor(){super(),this.tiling=new Fn,this.fetchOptions={},this.fetchData=(...t)=>fetch(...t)}init(){}async processBufferToTexture(t){const e=new Blob([t]),s=await createImageBitmap(e,{premultiplyAlpha:"none",colorSpaceConversion:"none",imageOrientation:"flipY"}),i=new Si(s);return i.generateMipmaps=!1,i.colorSpace=Ai,i.needsUpdate=!0,i}getMemoryUsage(t){const{TextureUtils:e}=xi;if(!e)return 0;const{format:s,type:i,image:n,generateMipmaps:r}=t,{width:o,height:a}=n,l=e.getByteLength(o,a,s,i);return r?4*l/3:l}fetchItem(t,e){const s={...this.fetchOptions,signal:e},i=this.getUrl(...t);return this.fetchData(i,s).then(t=>t.arrayBuffer()).then(t=>this.processBufferToTexture(t))}disposeItem(t){t.dispose(),t.image instanceof ImageBitmap&&t.image.close()}getUrl(...t){}}class kn extends In{constructor(t={}){const{url:e=null}=t;super(),this.tileSets=null,this.extension=null,this.url=e}getUrl(t,e,s){const{url:i,extension:n,tileSets:r,tiling:o}=this;return new URL(`${parseInt(r[s-o.minLevel].href)}/${t}/${e}.${n}`,i).toString()}init(){const{url:t}=this;return this.fetchData(new URL("tilemapresource.xml",t),this.fetchOptions).then(t=>t.text()).then(e=>{const{tiling:s}=this,i=(new DOMParser).parseFromString(e,"text/xml"),n=i.querySelector("BoundingBox"),r=i.querySelector("TileFormat"),o=[...i.querySelector("TileSets").querySelectorAll("TileSet")].map(t=>({href:parseInt(t.getAttribute("href")),unitsPerPixel:parseFloat(t.getAttribute("units-per-pixel")),order:parseInt(t.getAttribute("order"))})).sort((t,e)=>t.order-e.order),a=parseFloat(n.getAttribute("minx"))*Pi.DEG2RAD,l=parseFloat(n.getAttribute("maxx"))*Pi.DEG2RAD,c=parseFloat(n.getAttribute("miny"))*Pi.DEG2RAD,h=parseFloat(n.getAttribute("maxy"))*Pi.DEG2RAD,u=parseInt(r.getAttribute("width")),d=parseInt(r.getAttribute("height")),p=r.getAttribute("extension"),m=i.querySelector("SRS").textContent;this.extension=p,this.url=t,this.tileSets=o,s.setProjection(new Un(m)),s.setContentBounds(a,c,l,h),o.forEach(({order:t})=>{s.setLevel(t,{tileCountX:s.projection.tileCountX*2**t,tilePixelWidth:u,tilePixelHeight:d})})})}}class On extends Ln{constructor(t={}){const{url:e,...s}=t;super(s),this.name="TMS_TILES_PLUGIN",this.imageSource=new kn({url:e})}}const Vn=new Mi,zn=new Vi,Bn=new Mi,Nn=new Mi;class jn extends yi{constructor(t=Ei){super(),this.manager=t,this.ellipsoid=new gt,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI}parse(t){const{ellipsoid:e,solid:s,skirtLength:i,smoothSkirtNormals:n,minLat:r,maxLat:o,minLon:a,maxLon:l}=this,{header:c,indices:h,vertexData:u,edgeIndices:d,extensions:p}=super.parse(t),m=new Li,g=new Ui,f=new Ti(m,g);f.position.set(...c.center);const y="octvertexnormals"in p,b=u.u.length,x=[],_=[],T=[],v=[];let w=0,P=0;for(let E=0;E<b;E++)C(E,Bn),S(Bn.x,Bn.y,Bn.z,Nn),_.push(Bn.x,Bn.y),x.push(...Nn);for(let E=0,L=h.length;E<L;E++)T.push(h[E]);if(y){const t=p.octvertexnormals.normals;for(let e=0,s=t.length;e<s;e++)v.push(t[e])}if(m.addGroup(w,h.length,P),w+=h.length,P++,s){const t=x.length/3;for(let e=0;e<b;e++)C(e,Bn),S(Bn.x,Bn.y,Bn.z,Nn,-i),_.push(Bn.x,Bn.y),x.push(...Nn);for(let e=h.length-1;e>=0;e--)T.push(h[e]+t);if(y){const t=p.octvertexnormals.normals;for(let e=0,s=t.length;e<s;e++)v.push(-t[e])}m.addGroup(w,h.length,P),w+=h.length,P++}if(i>0){const{westIndices:t,eastIndices:e,southIndices:s,northIndices:i}=d;let n;const r=A(t);n=x.length/3,_.push(...r.uv),x.push(...r.positions);for(let c=0,h=r.indices.length;c<h;c++)T.push(r.indices[c]+n);const o=A(e);n=x.length/3,_.push(...o.uv),x.push(...o.positions);for(let c=0,h=o.indices.length;c<h;c++)T.push(o.indices[c]+n);const a=A(s);n=x.length/3,_.push(...a.uv),x.push(...a.positions);for(let c=0,h=a.indices.length;c<h;c++)T.push(a.indices[c]+n);const l=A(i);n=x.length/3,_.push(...l.uv),x.push(...l.positions);for(let c=0,h=l.indices.length;c<h;c++)T.push(l.indices[c]+n);y&&(v.push(...r.normals),v.push(...o.normals),v.push(...a.normals),v.push(...l.normals)),m.addGroup(w,h.length,P),w+=h.length,P++}for(let E=0,L=x.length;E<L;E+=3)x[E+0]-=c.center[0],x[E+1]-=c.center[1],x[E+2]-=c.center[2];const M=x.length/3>65535?new Uint32Array(T):new Uint16Array(T);if(m.setIndex(new Ri(M,1,!1)),m.setAttribute("position",new Ri(new Float32Array(x),3,!1)),m.setAttribute("uv",new Ri(new Float32Array(_),2,!1)),y&&m.setAttribute("normal",new Ri(new Float32Array(v),3,!1)),"watermask"in p){const{mask:t,size:e}=p.watermask,s=new Uint8Array(2*e*e);for(let n=0,r=t.length;n<r;n++){const e=255===t[n]?0:255;s[2*n+0]=e,s[2*n+1]=e}const i=new Di(s,e,e,Fi,Ii);i.flipY=!0,i.minFilter=ki,i.magFilter=Oi,i.needsUpdate=!0,g.roughnessMap=i}return f.userData.minHeight=c.minHeight,f.userData.maxHeight=c.maxHeight,"metadata"in p&&(f.userData.metadata=p.metadata.json),f;function C(t,e){return e.x=u.u[t],e.y=u.v[t],e.z=u.height[t],e}function S(t,s,i,n,h=0){const u=Pi.lerp(c.minHeight,c.maxHeight,i),d=Pi.lerp(a,l,t),p=Pi.lerp(r,o,s);return e.getCartographicToPosition(p,d,u+h,n),n}function A(t){const e=[],s=[],r=[],o=[],a=[];for(let n=0,h=t.length;n<h;n++)C(t[n],Bn),e.push(Bn.x,Bn.y),r.push(Bn.x,Bn.y),S(Bn.x,Bn.y,Bn.z,Nn),s.push(...Nn),S(Bn.x,Bn.y,Bn.z,Nn,-i),o.push(...Nn);const l=t.length-1;for(let i=0;i<l;i++){const e=i,s=i+1,n=i+t.length,r=i+t.length+1;a.push(e,n,s),a.push(s,n,r)}let c=null;if(y){const e=(s.length+o.length)/3;if(n){c=new Array(3*e);const s=p.octvertexnormals.normals,i=c.length/2;for(let n=0,r=e/2;n<r;n++){const e=t[n],r=3*n,o=s[3*e+0],a=s[3*e+1],l=s[3*e+2];c[r+0]=o,c[r+1]=a,c[r+2]=l,c[i+r+0]=o,c[i+r+1]=a,c[i+r+2]=l}}else{c=[],zn.a.fromArray(s,0),zn.b.fromArray(o,0),zn.c.fromArray(s,3),zn.getNormal(Vn);for(let t=0;t<e;t++)c.push(...Vn)}}return{uv:[...e,...r],positions:[...s,...o],indices:a,normals:c}}}}const Wn=["a","b","c"],Gn=new zi,Hn=new zi,qn=new zi,Zn=new zi;class Yn{constructor(){this.attributeList=null,this.splitOperations=[],this.trianglePool=new $n}forEachSplitPermutation(t){const{splitOperations:e}=this,s=(i=0)=>{i>=e.length?t():(e[i].keepPositive=!0,s(i+1),e[i].keepPositive=!1,s(i+1))};s()}addSplitOperation(t,e=!0){this.splitOperations.push({callback:t,keepPositive:e})}clearSplitOperations(){this.splitOperations.length=0}clipObject(t){const e=t.clone(),s=[];return e.traverse(t=>{t.isMesh&&(t.geometry=this.clip(t).geometry,0==(t.geometry.index?t.geometry.index.count/3:t.attributes.position.count/3)&&s.push(t))}),s.forEach(t=>{t.removeFromParent()}),e}clip(t,e=null){const s=this.getClippedData(t,e);return this.constructMesh(s.attributes,s.index,t)}getClippedData(t,e=null,s={}){const{trianglePool:i,splitOperations:n,attributeList:r}=this,o=t.geometry,a=o.attributes.position,l=o.index;let c=0;const h={};s.index=s.index||[],s.vertexIsClipped=s.vertexIsClipped||[],s.attributes=s.attributes||{};for(const m in o.attributes){if(null!==r){if(r instanceof Function&&!r(m))continue;if(Array.isArray(r)&&!r.includes(m))continue}s.attributes[m]=[]}let u=0,d=l?l.count:a.count;null!==e&&(u=e.start,d=e.count);for(let m=u,g=u+d;m<g;m+=3){let e=m+0,s=m+1,r=m+2;l&&(e=l.getX(e),s=l.getX(s),r=l.getX(r));const a=i.get();a.initFromIndices(e,s,r);let c=[a];for(let i=0;i<n.length;i++){const{keepPositive:e,callback:s}=n[i],r=[];for(let i=0;i<c.length;i++){const n=c[i],{indices:a,barycoord:l}=n;n.clipValues.a=s(o,a.a,a.b,a.c,l.a,t.matrixWorld),n.clipValues.b=s(o,a.a,a.b,a.c,l.b,t.matrixWorld),n.clipValues.c=s(o,a.a,a.b,a.c,l.c,t.matrixWorld),this.splitTriangle(n,!e,r)}c=r}for(let t=0,i=c.length;t<i;t++){p(c[t],o)}i.reset()}return s;function p(t,e){for(let i=0;i<3;i++){const n=t.getVertexHash(i,e);n in h||(h[n]=c,c++,t.getVertexData(i,e,s.attributes),s.vertexIsClipped.push(0===t.clipValues[Wn[i]]));const r=h[n];s.index.push(r)}}}constructMesh(t,e,s){const i=s.geometry,n=new Li,r=t.position.length/3>65535?new Uint32Array(e):new Uint16Array(e);n.setIndex(new Ri(r,1,!1));for(const a in t){const e=i.getAttribute(a),s=new e.array.constructor(t[a]),r=new Ri(s,e.itemSize,e.normalized);r.gpuType=e.gpuType,n.setAttribute(a,r)}const o=new Ti(n,s.material.clone());return o.position.copy(s.position),o.quaternion.copy(s.quaternion),o.scale.copy(s.scale),o}splitTriangle(t,e,s){const{trianglePool:i}=this,n=[],r=[],o=[];for(let a=0;a<3;a++){const e=Wn[a],s=Wn[(a+1)%3],i=t.clipValues[e],l=t.clipValues[s];(i<0!=l<0||0===i)&&(n.push(a),r.push([e,s]),i===l?o.push(0):o.push(Pi.mapLinear(0,i,l,0,1)))}if(2!==n.length)Math.min(t.clipValues.a,t.clipValues.b,t.clipValues.c)<0===e&&s.push(t);else if(2===n.length){const a=i.get().initFromTriangle(t),l=i.get().initFromTriangle(t),c=i.get().initFromTriangle(t);let h,u;(n[0]+1)%3===n[1]?(a.lerpVertexFromEdge(t,r[0][0],r[0][1],o[0],"a"),a.copyVertex(t,r[0][1],"b"),a.lerpVertexFromEdge(t,r[1][0],r[1][1],o[1],"c"),a.clipValues.a=0,a.clipValues.c=0,l.lerpVertexFromEdge(t,r[0][0],r[0][1],o[0],"a"),l.copyVertex(t,r[1][1],"b"),l.copyVertex(t,r[0][0],"c"),l.clipValues.a=0,c.lerpVertexFromEdge(t,r[0][0],r[0][1],o[0],"a"),c.lerpVertexFromEdge(t,r[1][0],r[1][1],o[1],"b"),c.copyVertex(t,r[1][1],"c"),c.clipValues.a=0,c.clipValues.b=0):(a.lerpVertexFromEdge(t,r[0][0],r[0][1],o[0],"a"),a.lerpVertexFromEdge(t,r[1][0],r[1][1],o[1],"b"),a.copyVertex(t,r[0][0],"c"),a.clipValues.a=0,a.clipValues.b=0,l.lerpVertexFromEdge(t,r[0][0],r[0][1],o[0],"a"),l.copyVertex(t,r[0][1],"b"),l.lerpVertexFromEdge(t,r[1][0],r[1][1],o[1],"c"),l.clipValues.a=0,l.clipValues.c=0,c.copyVertex(t,r[0][1],"a"),c.copyVertex(t,r[1][0],"b"),c.lerpVertexFromEdge(t,r[1][0],r[1][1],o[1],"c"),c.clipValues.c=0),h=Math.min(a.clipValues.a,a.clipValues.b,a.clipValues.c),u=h<0,u===e&&s.push(a),h=Math.min(l.clipValues.a,l.clipValues.b,l.clipValues.c),u=h<0,u===e&&s.push(l),h=Math.min(c.clipValues.a,c.clipValues.b,c.clipValues.c),u=h<0,u===e&&s.push(c)}}}class $n{constructor(){this.pool=[],this.index=0}get(){if(this.index>=this.pool.length){const t=new Xn;this.pool.push(t)}const t=this.pool[this.index];return this.index++,t}reset(){this.index=0}}class Xn{constructor(){this.indices={a:-1,b:-1,c:-1},this.clipValues={a:-1,b:-1,c:-1},this.barycoord=new Vi}getVertexHash(t,e){const{barycoord:s,indices:i}=this,n=s[Wn[t]];if(1===n.x)return i[Wn[0]];if(1===n.y)return i[Wn[1]];if(1===n.z)return i[Wn[2]];{const{attributes:t}=e;let s="";for(const e in t){const r=t[e];switch(Qn(r,i.a,i.b,i.c,n,Gn),("normal"===e||"tangent"===e||"bitangent"===e)&&Gn.normalize(),r.itemSize){case 4:s+=Jn(Gn.x,Gn.y,Gn.z,Gn.w);break;case 3:s+=Jn(Gn.x,Gn.y,Gn.z);break;case 2:s+=Jn(Gn.x,Gn.y);break;case 1:s+=Jn(Gn.x)}s+="|"}return s}}getVertexData(t,e,s){const{barycoord:i,indices:n}=this,r=i[Wn[t]],{attributes:o}=e;for(const a in o){if(!s[a])continue;const t=o[a],e=s[a];switch(Qn(t,n.a,n.b,n.c,r,Gn),("normal"===a||"tangent"===a||"bitangent"===a)&&Gn.normalize(),t.itemSize){case 4:e.push(Gn.x,Gn.y,Gn.z,Gn.w);break;case 3:e.push(Gn.x,Gn.y,Gn.z);break;case 2:e.push(Gn.x,Gn.y);break;case 1:e.push(Gn.x)}}}initFromTriangle(t){return this.initFromIndices(t.indices.a,t.indices.b,t.indices.c)}initFromIndices(t,e,s){return this.indices.a=t,this.indices.b=e,this.indices.c=s,this.clipValues.a=-1,this.clipValues.b=-1,this.clipValues.c=-1,this.barycoord.a.set(1,0,0),this.barycoord.b.set(0,1,0),this.barycoord.c.set(0,0,1),this}lerpVertexFromEdge(t,e,s,i,n){this.clipValues[n]=Pi.lerp(t.clipValues[e],t.clipValues[s],i),this.barycoord[n].lerpVectors(t.barycoord[e],t.barycoord[s],i)}copyVertex(t,e,s){this.clipValues[s]=t.clipValues[e],this.barycoord[s].copy(t.barycoord[e])}}function Qn(t,e,s,i,n,r){switch(Hn.fromBufferAttribute(t,e),qn.fromBufferAttribute(t,s),Zn.fromBufferAttribute(t,i),r.set(0,0,0,0).addScaledVector(Hn,n.x).addScaledVector(qn,n.y).addScaledVector(Zn,n.z),t.itemSize){case 3:Gn.w=0;break;case 2:Gn.w=0,Gn.z=0;break;case 1:Gn.w=0,Gn.z=0,Gn.y=0}return r}function Jn(...t){let e="";for(let s=0,i=t.length;s<i;s++)e+=~~(1e5*t[s]+.5),s!==i-1&&(e+="_");return e}const Kn={},tr=new Mi,er=new Mi,sr=new Mi,ir=new Mi,nr=new Mi,rr=new Mi,or=new Mi,ar=new wi,lr=new wi,cr=new wi;class hr extends Yn{constructor(){super(),this.ellipsoid=new gt,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI,this.attributeList=["position","normal","uv"]}clipToQuadrant(t,e,s){const{solid:i,skirtLength:n,ellipsoid:r,smoothSkirtNormals:o}=this;let a,l;this.clearSplitOperations(),this.addSplitOperation(ur("x"),!e),this.addSplitOperation(ur("y"),!s);const c=t.geometry.groups[0],h=this.getClippedData(t,c);if(this.adjustVertices(h,t.position,0),i){a={index:h.index.slice().reverse(),attributes:{}};for(const t in h.attributes)a.attributes[t]=h.attributes[t].slice();const e=a.attributes.normal;if(e)for(let t=0;t<e.length;t+=3)e[t+0]*=-1,e[t+1]*=-1,e[t+2]*=-1;this.adjustVertices(a,t.position,-n)}if(n>0){l={index:[],attributes:{position:[],normal:[],uv:[]}};let e=0;const s={},i=(t,i,n)=>{const r=Jn(...t,...n,...i);r in s||(s[r]=e,e++,l.attributes.position.push(...t),l.attributes.normal.push(...n),l.attributes.uv.push(...i)),l.index.push(s[r])},a=h.index,c=h.attributes.uv,u=h.attributes.position,d=h.attributes.normal,p=h.index.length/3;for(let l=0;l<p;l++){const e=3*l;for(let s=0;s<3;s++){const l=(s+1)%3,h=a[e+s],p=a[e+l];if(ar.fromArray(c,2*h),lr.fromArray(c,2*p),ar.x===lr.x&&(0===ar.x||.5===ar.x||1===ar.x)||ar.y===lr.y&&(0===ar.y||.5===ar.y||1===ar.y)){er.fromArray(u,3*h),sr.fromArray(u,3*p);const e=er,s=sr,a=ir.copy(er),l=nr.copy(sr);rr.copy(a).add(t.position),r.getPositionToNormal(rr,rr),a.addScaledVector(rr,-n),rr.copy(l).add(t.position),r.getPositionToNormal(rr,rr),l.addScaledVector(rr,-n),o&&d?(rr.fromArray(d,3*h),or.fromArray(d,3*p)):(rr.subVectors(e,s),or.subVectors(e,a).cross(rr).normalize(),rr.copy(or)),i(s,lr,or),i(e,ar,rr),i(a,ar,rr),i(s,lr,or),i(a,ar,rr),i(l,lr,or)}}}}const u=h.index.length,d=h;if(a){const{index:t,attributes:e}=a,s=d.attributes.position.length/3;for(let i=0,n=t.length;i<n;i++)d.index.push(t[i]+s);for(const i in h.attributes)d.attributes[i].push(...e[i])}if(l){const{index:t,attributes:e}=l,s=d.attributes.position.length/3;for(let i=0,n=t.length;i<n;i++)d.index.push(t[i]+s);for(const i in h.attributes)d.attributes[i].push(...e[i])}const p=e?0:-.5,m=s?0:-.5,g=d.attributes.uv;for(let x=0,_=g.length;x<_;x+=2)g[x]=2*(g[x]+p),g[x+1]=2*(g[x+1]+m);const f=this.constructMesh(d.attributes,d.index,t);f.userData.minHeight=t.userData.minHeight,f.userData.maxHeight=t.userData.maxHeight;let y=0,b=0;return f.geometry.addGroup(b,u,y),b+=u,y++,a&&(f.geometry.addGroup(b,a.index.length,y),b+=a.index.length,y++),l&&(f.geometry.addGroup(b,l.index.length,y),b+=l.index.length,y++),f}adjustVertices(t,e,s){const{ellipsoid:i,minLat:n,maxLat:r,minLon:o,maxLon:a}=this,{attributes:l,vertexIsClipped:c}=t,h=l.position,u=l.uv,d=h.length/3;for(let p=0;p<d;p++){const t=ar.fromArray(u,2*p);c&&c[p]&&(Math.abs(t.x-.5)<1e-10&&(t.x=.5),Math.abs(t.y-.5)<1e-10&&(t.y=.5),ar.toArray(u,2*p));const l=Pi.lerp(n,r,t.y),d=Pi.lerp(o,a,t.x),m=tr.fromArray(h,3*p).add(e);i.getPositionToCartographic(m,Kn),i.getCartographicToPosition(l,d,Kn.height+s,m),m.sub(e),m.toArray(h,3*p)}}}function ur(t){return(e,s,i,n,r)=>{const o=e.attributes.uv;return ar.fromBufferAttribute(o,s),lr.fromBufferAttribute(o,i),cr.fromBufferAttribute(o,n),ar[t]*r.x+lr[t]*r.y+cr[t]*r.z-.5}}const dr=Symbol("TILE_X"),pr=Symbol("TILE_Y"),mr=Symbol("TILE_LEVEL"),gr=Symbol("TILE_AVAILABLE"),fr=1e4,yr=new Mi;function br(t){const{available:e=null,maxzoom:s=null}=t;return null===s?e.length-1:s}function xr(t,e){const s=t[mr],i=function(t){const{metadataAvailability:e=-1}=t;return e}(e);return s<br(e)&&-1!==i&&s%i===0}class _r{constructor(t={}){const{useRecommendedSettings:e=!0,skirtLength:s=null,smoothSkirtNormals:i=!0,solid:n=!1}=t;this.name="QUANTIZED_MESH_PLUGIN",this.priority=-1e3,this.tiles=null,this.layer=null,this.useRecommendedSettings=e,this.skirtLength=s,this.smoothSkirtNormals=i,this.solid=n,this.attribution=null,this.tiling=new Fn,this.projection=new Un}init(t){t.fetchOptions.headers=t.fetchOptions.headers||{},t.fetchOptions.headers.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",this.useRecommendedSettings&&(t.errorTarget=2),this.tiles=t}loadRootTileSet(){const{tiles:t}=this;let e=new URL("layer.json",new URL(t.rootURL,location.href));return t.invokeAllPlugins(t=>e=t.preprocessURL?t.preprocessURL(e,null):e),t.invokeOnePlugin(t=>t.fetchData&&t.fetchData(e,this.tiles.fetchOptions)).then(t=>t.json()).then(t=>{this.layer=t;const{projection:e="EPSG:4326",extensions:s=[],attribution:i="",available:n=null}=t,{tiling:r,tiles:o,projection:a}=this;i&&(this.attribution={value:i,type:"string",collapsible:!0}),s.length>0&&(o.fetchOptions.headers.Accept+=`;extensions=${s.join("-")}`),a.setScheme(e);const{tileCountX:l,tileCountY:c}=a;r.setProjection(a),r.generateLevels(br(t)+1,l,c);const h=[];for(let p=0;p<l;p++){const t=this.createChild(0,p,0,n);t&&h.push(t)}const u={asset:{version:"1.1"},geometricError:1/0,root:{refine:"REPLACE",geometricError:1/0,boundingVolume:{region:[...this.tiling.getContentBounds(),-fr,fr]},children:h,[gr]:n,[mr]:-1}};let d=o.rootURL;return o.invokeAllPlugins(t=>d=t.preprocessURL?t.preprocessURL(d,null):d),o.preprocessTileSet(u,d),u})}parseToMesh(t,e,s,i){const{skirtLength:n,solid:r,smoothSkirtNormals:o,tiles:a}=this,l=a.ellipsoid;let c;if("quantized_tile_split"===s){const t=new URL(i).searchParams,s="true"===t.get("left"),a="true"===t.get("bottom"),h=new hr;h.ellipsoid.copy(l),h.solid=r,h.smoothSkirtNormals=o,h.skirtLength=null===n?e.geometricError:n;const[u,d,p,m]=e.parent.boundingVolume.region;h.minLat=d,h.maxLat=m,h.minLon=u,h.maxLon=p,c=h.clipToQuadrant(e.parent.cached.scene,s,a)}else{if("terrain"!==s)return;{const s=new jn(a.manager);s.ellipsoid.copy(l),s.solid=r,s.smoothSkirtNormals=o,s.skirtLength=null===n?e.geometricError:n;const[i,h,u,d]=e.boundingVolume.region;s.minLat=h,s.maxLat=d,s.minLon=i,s.maxLon=u,c=s.parse(t)}}const{minHeight:h,maxHeight:u,metadata:d}=c.userData;return e.boundingVolume.region[4]=h,e.boundingVolume.region[5]=u,e.cached.boundingVolume.setRegionData(l,...e.boundingVolume.region),d&&("geometricerror"in d&&(e.geometricError=d.geometricerror),xr(e,this.layer)&&"available"in d&&0===e.children.length&&(e[gr]=[...new Array(e[mr]+1).fill(null),...d.available])),this.expandChildren(e),c}getAttributions(t){this.attribution&&t.push(this.attribution)}createChild(t,e,s,i){const{tiles:n,layer:r,tiling:o,projection:a}=this,l=n.ellipsoid,c=null===i&&0===t||function(t,e,s,i){if(t&&e<t.length){const n=t[e];for(let t=0,e=n.length;t<e;t++){const{startX:e,startY:r,endX:o,endY:a}=n[t];if(s>=e&&s<=o&&i>=r&&i<=a)return!0}}return!1}(i,t,e,s),h=function(t,e,s,i,n){return n.tiles[0].replace(/{\s*z\s*}/g,s).replace(/{\s*x\s*}/g,t).replace(/{\s*y\s*}/g,e).replace(/{\s*version\s*}/g,i)}(e,s,t,1,r),u=[...o.getTileBounds(e,s,t),-fr,fr],[,d,,p,,m]=u,g=d>0!=p>0?0:Math.min(Math.abs(d),Math.abs(p));l.getCartographicToPosition(g,0,m,yr),yr.z=0;const f=a.tileCountX,y=2*Math.max(...l.radius)*Math.PI*.25/(65*f)/2**t,b={[gr]:null,[mr]:t,[dr]:e,[pr]:s,refine:"REPLACE",geometricError:y,boundingVolume:{region:u},content:c?{uri:h}:null,children:[]};return xr(b,r)||(b[gr]=i),b}expandChildren(t){const e=t[mr],s=t[dr],i=t[pr],n=t[gr];if(e>=this.tiling.maxLevel)return;let r=!1;for(let o=0;o<2;o++)for(let a=0;a<2;a++){const l=this.createChild(e+1,2*s+o,2*i+a,n);null!==l.content?(t.children.push(l),r=!0):(t.children.push(l),l.content={uri:`tile.quantized_tile_split?bottom=${0===a}&left=${0===o}`})}r||(t.children.length=0)}fetchData(t,e){if(/quantized_tile_split/.test(t))return new ArrayBuffer}disposeTile(t){xr(t,this.layer)&&(t[gr]=null),gr in t&&(t.children.forEach(t=>{this.tiles.processNodeQueue.remove(t)}),t.children.length=0,t.__childrenProcessed=0)}}class Tr{get apiToken(){return this.auth.apiToken}set apiToken(t){this.auth.apiToken=t}get autoRefreshToken(){return this.auth.autoRefreshToken}set autoRefreshToken(t){this.auth.autoRefreshToken=t}constructor({apiToken:t,assetId:e=null,autoRefreshToken:s=!1,useRecommendedSettings:i=!0}){this.name="CESIUM_ION_AUTH_PLUGIN",this.auth=new gi({apiToken:t,autoRefreshToken:s}),this.assetId=e,this.autoRefreshToken=s,this.useRecommendedSettings=i,this.tiles=null,this._tileSetVersion=-1,this._attributions=[]}init(t){null!==this.assetId&&(t.rootURL=`https://api.cesium.com/v1/assets/${this.assetId}/endpoint`),this.tiles=t,this.auth.authURL=t.rootURL,t.resetFailedTiles()}loadRootTileSet(){return this.auth.refreshToken().then(t=>(this._initializeFromAsset(t),this.tiles.invokeOnePlugin(t=>t!==this&&t.loadRootTileSet&&t.loadRootTileSet()))).catch(t=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:t,url:this.auth.authURL})})}preprocessURL(t){return t=new URL(t),/^http/.test(t.protocol)&&-1!=this._tileSetVersion&&t.searchParams.set("v",this._tileSetVersion),t.toString()}fetchData(t,e){return null!==this.tiles.getPluginByName("GOOGLE_CLOUD_AUTH_PLUGIN")?null:this.auth.fetch(t,e)}getAttributions(t){this.tiles.visibleTiles.size>0&&t.push(...this._attributions)}_initializeFromAsset(t){const e=this.tiles;if("externalType"in t){const s=new URL(t.options.url);e.rootURL=t.options.url,e.registerPlugin(new bn({apiToken:s.searchParams.get("key"),autoRefreshToken:this.autoRefreshToken,useRecommendedSettings:this.useRecommendedSettings}))}else{"TERRAIN"===t.type&&null===e.getPluginByName("QUANTIZED_MESH_PLUGIN")?e.registerPlugin(new _r({useRecommendedSettings:this.useRecommendedSettings})):"IMAGERY"===t.type&&null===e.getPluginByName("TMS_TILES_PLUGIN")&&e.registerPlugin(new On({useRecommendedSettings:this.useRecommendedSettings,shape:"ellipsoid"})),e.rootURL=t.url;const s=new URL(t.url);s.searchParams.has("v")&&-1===this._tileSetVersion&&(this._tileSetVersion=s.searchParams.get("v")),t.attributions&&(this._attributions=t.attributions.map(t=>({value:t.html,type:"html",collapsible:t.collapsible})))}}}const vr=new Bi;class wr{constructor(){this.name="UPDATE_ON_CHANGE_PLUGIN",this.tiles=null,this.needsUpdate=!1,this.cameraMatrices=new Map}init(t){this.tiles=t,this._needsUpdateCallback=()=>{this.needsUpdate=!0},this._onCameraAdd=({camera:t})=>{this.needsUpdate=!0,this.cameraMatrices.set(t,new Bi)},this._onCameraDelete=({camera:t})=>{this.needsUpdate=!0,this.cameraMatrices.delete(t)},t.addEventListener("needs-update",this._needsUpdateCallback),t.addEventListener("add-camera",this._onCameraAdd),t.addEventListener("delete-camera",this._onCameraDelete),t.addEventListener("camera-resolution-change",this._needsUpdateCallback),t.cameras.forEach(t=>{this._onCameraAdd({camera:t})})}doTilesNeedUpdate(){const t=this.tiles;let e=!1;this.cameraMatrices.forEach((s,i)=>{vr.copy(t.group.matrixWorld).premultiply(i.matrixWorldInverse).premultiply(i.projectionMatrixInverse),e=e||!vr.equals(s),s.copy(vr)});const s=this.needsUpdate;return this.needsUpdate=!1,s||e}preprocessNode(){this.needsUpdate=!0}dispose(){const t=this.tiles;t.removeEventListener("camera-resolution-change",this._needsUpdateCallback),t.removeEventListener("needs-update",this._needsUpdateCallback),t.removeEventListener("add-camera",this._onCameraAdd),t.removeEventListener("delete-camera",this._onCameraDelete)}}const Pr=new Mi;function Mr(t,e){if(t.isInterleavedBufferAttribute||t.array instanceof e)return t;const s=e===Int8Array||e===Int16Array||e===Int32Array?-1:0,i=new e(t.count*t.itemSize),n=new Ri(i,t.itemSize,!0),r=t.itemSize,o=t.count;for(let a=0;a<o;a++)for(let e=0;e<r;e++){const i=Pi.clamp(t.getComponent(a,e),s,1);n.setComponent(a,e,i)}return n}class Cr{constructor(t){this._options={generateNormals:!1,disableMipmaps:!0,compressIndex:!0,compressNormals:!1,compressUvs:!1,compressPosition:!1,uvType:Int8Array,normalType:Int8Array,positionType:Int16Array,...t},this.name="TILES_COMPRESSION_PLUGIN",this.priority=-100}processTileModel(t,e){const{generateNormals:s,disableMipmaps:i,compressIndex:n,compressUvs:r,compressNormals:o,compressPosition:a,uvType:l,normalType:c,positionType:h}=this._options;t.traverse(t=>{if(t.material&&i){const e=t.material;for(const t in e){const s=e[t];s&&s.isTexture&&s.generateMipmaps&&(s.generateMipmaps=!1,s.minFilter=Oi)}}if(t.geometry){const e=t.geometry,i=e.attributes;if(r){const{uv:t,uv1:e,uv2:s,uv3:n}=i;t&&(i.uv=Mr(t,l)),e&&(i.uv1=Mr(e,l)),s&&(i.uv2=Mr(s,l)),n&&(i.uv3=Mr(n,l))}if(s&&!i.normals&&e.computeVertexNormals(),o&&i.normals&&(i.normals=Mr(i.normals,c)),a&&function(t,e=Int16Array){const s=t.geometry,i=s.attributes,n=i.position;if(n.isInterleavedBufferAttribute||n.array instanceof e)return n;const r=new e(n.count*n.itemSize),o=new Ri(r,n.itemSize,!1),a=n.itemSize,l=n.count;s.computeBoundingBox();const c=s.boundingBox,{min:h,max:u}=c,d=2**(8*e.BYTES_PER_ELEMENT-1)-1,p=-d;for(let m=0;m<l;m++)for(let t=0;t<a;t++){const e=0===t?"x":1===t?"y":"z",s=h[e],i=u[e],r=Pi.mapLinear(n.getComponent(m,t),s,i,p,d);o.setComponent(m,t,r)}c.getCenter(Pr).multiply(t.scale).applyQuaternion(t.quaternion),t.position.add(Pr),t.scale.x*=.5*(u.x-h.x)/d,t.scale.y*=.5*(u.y-h.y)/d,t.scale.z*=.5*(u.z-h.z)/d,i.position=o,t.geometry.boundingBox=null,t.geometry.boundingSphere=null,t.updateMatrixWorld()}(t,h),n&&e.index){const t=i.position.count,s=e.index,n=t>65535?Uint32Array:t>255?Uint16Array:Uint8Array;if(!(s.array instanceof n)){const t=new n(e.index.count);t.set(s.array);const i=new Ri(t,1);e.setIndex(i)}}}})}}function Sr(t,e,s){return t&&e in t?t[e]:s}function Ar(t){return"BOOLEAN"!==t&&"STRING"!==t&&"ENUM"!==t}function Er(t){return/^VEC/.test(t)}function Lr(t){return/^MAT/.test(t)}function Ur(t,e,s,i=null){return Lr(s)||Er(s)?i.fromArray(t,e):t[e]}function Rr(t){const{type:e,componentType:s}=t;switch(e){case"SCALAR":return"INT64"===s?0n:0;case"VEC2":return new wi;case"VEC3":return new Mi;case"VEC4":return new zi;case"MAT2":return new ji;case"MAT3":return new Ni;case"MAT4":return new Bi;case"BOOLEAN":return!1;case"STRING":return"";case"ENUM":return 0}}function Dr(t,e){if(null==e)return!1;switch(t){case"SCALAR":case"ENUM":return"number"==typeof e||"bigint"==typeof e;case"VEC2":return e.isVector2;case"VEC3":return e.isVector3;case"VEC4":return e.isVector4;case"MAT2":return e.isMatrix2;case"MAT3":return e.isMatrix3;case"MAT4":return e.isMatrix4;case"BOOLEAN":return"boolean"==typeof e;case"STRING":return"string"==typeof e}throw new Error("ClassProperty: invalid type.")}function Fr(t,e=null){switch(t){case"INT8":return Int8Array;case"INT16":return Int16Array;case"INT32":return Int32Array;case"INT64":return BigInt64Array;case"UINT8":return Uint8Array;case"UINT16":return Uint16Array;case"UINT32":return Uint32Array;case"UINT64":return BigUint64Array;case"FLOAT32":return Float32Array;case"FLOAT64":return Float64Array}switch(e){case"BOOLEAN":case"STRING":return Uint8Array}throw new Error("ClassProperty: invalid type.")}function Ir(t,e=null){const s=t.default,i=t.type;if(e=e||Rr(t),null===s){switch(i){case"SCALAR":return 0;case"VEC2":return e.set(0,0);case"VEC3":return e.set(0,0,0);case"VEC4":return e.set(0,0,0,0);case"MAT2":case"MAT3":case"MAT4":return e.identity();case"BOOLEAN":return!1;case"STRING":case"ENUM":return""}throw new Error("ClassProperty: invalid type.")}if(Lr(i))e.fromArray(s);else{if(!Er(i))return s;e.fromArray(s)}}function kr(t,e){if(null===t.noData)return e;const s=t.noData,i=t.type;if(Array.isArray(e))for(let r=0,o=e.length;r<o;r++)e[r]=n(e[r]);else e=n(e);return e;function n(e){return function(t){if(Lr(i)){const e=t.elements;for(let t=0,i=s.length;t<i;t++)if(s[t]!==e[t])return!1;return!0}if(Er(i)){for(let e=0,i=s.length;e<i;e++)if(s[e]!==t.getComponent(e))return!1;return!0}return s===t}(e)&&(e=Ir(t,e)),e}}function Or(t,e){const{type:s,componentType:i,scale:n,offset:r,normalized:o}=t;if(Array.isArray(e))for(let c=0,h=e.length;c<h;c++)e[c]=a(e[c]);else e=a(e);return e;function a(t){return t=Lr(s)?function(t){const e=t.elements;for(let s=0,i=e.length;s<i;s++)e[s]=l(e[s]);return t}(t):Er(s)?function(t){return t.x=l(t.x),t.y=l(t.y),"z"in t&&(t.z=l(t.z)),"w"in t&&(t.w=l(t.w)),t}(t):l(t),t}function l(t){return o&&(t=function(t,e){switch(t){case"INT8":return Math.max(e/127,-1);case"INT16":return Math.max(e,32767,-1);case"INT32":return Math.max(e/2147483647,-1);case"INT64":return Math.max(Number(e)/0x8000000000000000,-1);case"UINT8":return e/255;case"UINT16":return e/65535;case"UINT32":return e/4294967295;case"UINT64":return Number(e)/0x10000000000000000}}(i,t)),(o||function(t){return/^FLOAT/.test(t)}(i))&&(t=t*n+r),t}}function Vr(t,e,s=null){if(t.array){Array.isArray(e)||(e=new Array(t.count||0)),e.length=null!==s?s:t.count;for(let s=0,i=e.length;s<i;s++)Dr(t.type,e[s])||(e[s]=Rr(t))}else Dr(t.type,e)||(e=Rr(t));return e}function zr(t,e){for(const s in e)s in t||delete e[s];for(const s in t){const i=t[s];e[s]=Vr(i,e[s])}}class Br{constructor(t,e,s=null){this.name=e.name||null,this.description=e.description||null,this.type=e.type,this.componentType=e.componentType||null,this.enumType=e.enumType||null,this.array=e.array||!1,this.count=e.count||0,this.normalized=e.normalized||!1,this.offset=e.offset||0,this.scale=Sr(e,"scale",1),this.max=Sr(e,"max",1/0),this.min=Sr(e,"min",-1/0),this.required=e.required||!1,this.noData=Sr(e,"noData",null),this.default=Sr(e,"default",null),this.semantic=Sr(e,"semantic",null),this.enumSet=null,this.accessorProperty=s,s&&(this.offset=Sr(s,"offset",this.offset),this.scale=Sr(s,"scale",this.scale),this.max=Sr(s,"max",this.max),this.min=Sr(s,"min",this.min)),"ENUM"===e.type&&(this.enumSet=t[this.enumType],null===this.componentType&&(this.componentType=Sr(this.enumSet,"valueType","UINT16")))}shapeToProperty(t,e=null){return Vr(this,t,e)}resolveDefaultElement(t){return Ir(this,t)}resolveDefault(t){return function(t,e=null){if(t.array){(e=e&&Array.isArray(e)?e:[]).length=t.count;for(let s=0,i=e.length;s<i;s++)e[s]=Ir(t,e[s])}else e=Ir(t,e);return e}(this,t)}resolveNoData(t){return kr(this,t)}resolveEnumsToStrings(t){const e=this.enumSet;if("ENUM"===this.type)if(Array.isArray(t))for(let i=0,n=t.length;i<n;i++)t[i]=s(t[i]);else t=s(t);return t;function s(t){const s=e.values.find(e=>e.value===t);return null===s?"":s.name}}adjustValueScaleOffset(t){return Ar(this.type)?Or(this,t):t}}class Nr{constructor(t,e={},s={},i=null){this.definition=t,this.class=e[t.class],this.className=t.class,this.enums=s,this.data=i,this.name="name"in t?t.name:null,this.properties=null}getPropertyNames(){return Object.keys(this.class.properties)}includesData(t){return!!this.definition.properties[t]}dispose(){}_initProperties(t=Br){const e={};for(const s in this.class.properties)e[s]=new t(this.enums,this.class.properties[s],this.definition.properties[s]);this.properties=e}}class jr extends Br{constructor(t,e,s=null){super(t,e,s),this.attribute=(null==s?void 0:s.attribute)??null}}class Wr extends Nr{constructor(...t){super(...t),this.isPropertyAttributeAccessor=!0,this._initProperties(jr)}getData(t,e,s={}){const i=this.properties;zr(i,s);for(const n in i)s[n]=this.getPropertyValue(n,t,e,s[n]);return s}getPropertyValue(t,e,s,i=null){if(e>=this.count)throw new Error("PropertyAttributeAccessor: Requested index is outside the range of the buffer.");const n=this.properties[t],r=n.type;if(!n)throw new Error("PropertyAttributeAccessor: Requested class property does not exist.");if(!this.definition.properties[t])return n.resolveDefault(i);i=n.shapeToProperty(i);const o=s.getAttribute(n.attribute.toLowerCase());if(Lr(r)){const t=i.elements;for(let s=0,i=t.length;s<i;s<i)t[s]=o.getComponent(e,s)}else if(Er(r))i.fromBufferAttribute(o,e);else{if("SCALAR"!==r&&"ENUM"!==r)throw new Error("StructuredMetadata.PropertyAttributeAccessor: BOOLEAN and STRING types are not supported by property attributes.");i=o.getX(e)}return i=n.adjustValueScaleOffset(i),i=n.resolveEnumsToStrings(i),i=n.resolveNoData(i)}}class Gr extends Br{constructor(t,e,s=null){super(t,e,s),this.values=(null==s?void 0:s.values)??null,this.valueLength=function(t){switch(t){case"ENUM":case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;default:return-1}}(this.type),this.arrayOffsets=Sr(s,"arrayOffsets",null),this.stringOffsets=Sr(s,"stringOffsets",null),this.arrayOffsetType=Sr(s,"arrayOffsetType","UINT32"),this.stringOffsetType=Sr(s,"stringOffsetType","UINT32")}getArrayLengthFromId(t,e){let s=this.count;if(null!==this.arrayOffsets){const{arrayOffsets:i,arrayOffsetType:n}=this,r=new(Fr(n))(t[i]);s=r[e+1]-r[e]}return s}getIndexOffsetFromId(t,e){let s=e;if(this.arrayOffsets){const{arrayOffsets:e,arrayOffsetType:i}=this;s=new(Fr(i))(t[e])[s]}else this.array&&(s*=this.count);return s}}class Hr extends Nr{constructor(...t){super(...t),this.isPropertyTableAccessor=!0,this.count=this.definition.count,this._initProperties(Gr)}getData(t,e={}){const s=this.properties;zr(s,e);for(const i in s)e[i]=this.getPropertyValue(i,t,e[i]);return e}_readValueAtIndex(t,e,s,i=null){const n=this.properties[t],{componentType:r,type:o}=n,a=this.data,l=a[n.values],c=new(Fr(r,o))(l),h=n.getIndexOffsetFromId(a,e);if(Ar(o)||"ENUM"===o)return Ur(c,(h+s)*n.valueLength,o,i);if("STRING"===o){let t=h+s,e=0;if(null!==n.stringOffsets){const{stringOffsets:s,stringOffsetType:i}=n,r=new(Fr(i))(a[s]);e=r[t+1]-r[t],t=r[t]}const r=new Uint8Array(c.buffer,t,e);i=(new TextDecoder).decode(r)}else if("BOOLEAN"===o){const t=h+s,e=t%8;i=1==(c[Math.floor(t/8)]>>e&1)}return i}getPropertyValue(t,e,s=null){if(e>=this.count)throw new Error("PropertyTableAccessor: Requested index is outside the range of the table.");const i=this.properties[t];if(!i)throw new Error("PropertyTableAccessor: Requested property does not exist.");if(!this.definition.properties[t])return i.resolveDefault(s);const n=i.array,r=this.data,o=i.getArrayLengthFromId(r,e);if(s=i.shapeToProperty(s,o),n)for(let a=0,l=s.length;a<l;a++)s[a]=this._readValueAtIndex(t,e,a,s[a]);else s=this._readValueAtIndex(t,e,0,s);return s=i.adjustValueScaleOffset(s),s=i.resolveEnumsToStrings(s),s=i.resolveNoData(s)}}const qr=new $i;class Zr{constructor(){this._renderer=new Wi,this._target=new Gi(1,1),this._texTarget=new Gi,this._quad=new s(new Hi({blending:Yi,blendDst:Zi,blendSrc:qi,uniforms:{map:{value:null},pixel:{value:new wi}},vertexShader:"\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform ivec2 pixel;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texelFetch( map, pixel, 0 );\n\n\t\t\t\t}\n\t\t\t"}))}increaseSizeTo(t){this._target.setSize(Math.max(this._target.width,t),1)}readDataAsync(t){const{_renderer:e,_target:s}=this;return e.readRenderTargetPixelsAsync(s,0,0,t.length/4,1,t)}readData(t){const{_renderer:e,_target:s}=this;e.readRenderTargetPixels(s,0,0,t.length/4,1,t)}renderPixelToTarget(t,e,s){const{_renderer:i,_target:n}=this;qr.min.copy(e),qr.max.copy(e),qr.max.x+=1,qr.max.y+=1,i.initRenderTarget(n),i.copyTextureToTexture(t,n.texture,qr,s,0)}}const Yr=new class{constructor(){let t=null;Object.getOwnPropertyNames(Zr.prototype).forEach(e=>{"constructor"!==e&&(this[e]=(...s)=>(t=t||new Zr,t[e](...s)))})}},$r=new wi,Xr=new wi,Qr=new wi;function Jr(t,e,s=new Array(3)){let i=3*e,n=3*e+1,r=3*e+2;return t.index&&(i=t.index.getX(i),n=t.index.getX(n),r=t.index.getX(r)),s[0]=i,s[1]=n,s[2]=r,s}function Kr(t,e,s,i,n){const[r,o,a]=i,l=function(t,e){return 0===e?t.getAttribute("uv"):t.getAttribute(`uv${e}`)}(t,e);$r.fromBufferAttribute(l,r),Xr.fromBufferAttribute(l,o),Qr.fromBufferAttribute(l,a),n.set(0,0,0).addScaledVector($r,s.x).addScaledVector(Xr,s.y).addScaledVector(Qr,s.z)}function to(t,e,s,i){const n=t.x-Math.floor(t.x),r=t.y-Math.floor(t.y),o=Math.floor(n*e%e),a=Math.floor(r*s%s);return i.set(o,a),i}const eo=new wi,so=new wi,io=new wi;class no extends Br{constructor(t,e,s=null){super(t,e,s),this.channels=Sr(s,"channels",[0]),this.index=Sr(s,"index",null),this.texCoord=Sr(s,"texCoord",null),this.valueLength=parseInt(this.type.replace(/[^0-9]/g,""))||1}readDataFromBuffer(t,e,s=null){const i=this.type;if("BOOLEAN"===i||"STRING"===i)throw new Error("PropertyTextureAccessor: BOOLEAN and STRING types not supported.");return Ur(t,e*this.valueLength,i,s)}}class ro extends Nr{constructor(...t){super(...t),this.isPropertyTextureAccessor=!0,this._asyncRead=!1,this._initProperties(no)}getData(t,e,s,i={}){const n=this.properties;zr(n,i);const r=Object.keys(n),o=r.map(t=>i[t]);return this.getPropertyValuesAtTexel(r,t,e,s,o),r.forEach((t,e)=>i[t]=o[e]),i}async getDataAsync(t,e,s,i={}){const n=this.properties;zr(n,i);const r=Object.keys(n),o=r.map(t=>i[t]);return await this.getPropertyValuesAtTexelAsync(r,t,e,s,o),r.forEach((t,e)=>i[t]=o[e]),i}getPropertyValuesAtTexelAsync(...t){this._asyncRead=!0;const e=this.getPropertyValuesAtTexel(...t);return this._asyncRead=!1,e}getPropertyValuesAtTexel(t,e,s,i,n=[]){for(;n.length<t.length;)n.push(null);n.length=t.length,Yr.increaseSizeTo(n.length);const r=this.data,o=this.definition.properties,a=this.properties,l=Jr(i,e);for(let u=0,d=t.length;u<d;u++){const e=t[u];if(!o[e])continue;const n=a[e],c=r[n.index];Kr(i,n.texCoord,s,l,eo),to(eo,c.image.width,c.image.height,so),io.set(u,0),Yr.renderPixelToTarget(c,so,io)}const c=new Uint8Array(4*t.length);return this._asyncRead?Yr.readDataAsync(c).then(()=>(h.call(this),n)):(Yr.readData(c),h.call(this),n);function h(){for(let e=0,s=t.length;e<s;e++){const s=t[e],i=a[s],r=i.type;if(n[e]=Vr(i,n[e]),!i)throw new Error("PropertyTextureAccessor: Requested property does not exist.");if(!o[s]){n[e]=i.resolveDefault(n);continue}const l=i.valueLength*(i.count||1),h=i.channels.map(t=>c[4*e+t]),u=new(Fr(i.componentType,r))(l);if(new Uint8Array(u.buffer).set(h),i.array){const t=n[e];for(let e=0,s=t.length;e<s;e++)t[e]=i.readDataFromBuffer(u,e,t[e])}else n[e]=i.readDataFromBuffer(u,0,n[e]);n[e]=i.adjustValueScaleOffset(n[e]),n[e]=i.resolveEnumsToStrings(n[e]),n[e]=i.resolveNoData(n[e])}}}dispose(){this.data.forEach(t=>{t&&(t.dispose(),t.image instanceof ImageBitmap&&t.image.close())})}}class oo{constructor(t,e,s,i=null,n=null){const{schema:r,propertyTables:o=[],propertyTextures:a=[],propertyAttributes:l=[]}=t,{enums:c,classes:h}=r,u=o.map(t=>new Hr(t,h,c,s));let d=[],p=[];i&&(i.propertyTextures&&(d=i.propertyTextures.map(t=>new ro(a[t],h,c,e))),i.propertyAttributes&&(p=i.propertyAttributes.map(t=>new Wr(l[t],h,c)))),this.schema=r,this.tableAccessors=u,this.textureAccessors=d,this.attributeAccessors=p,this.object=n,this.textures=e,this.nodeMetadata=i}getPropertyTableData(t,e,s=null){if(Array.isArray(t)&&Array.isArray(e)){s=s||[];const i=Math.min(t.length,e.length);s.length=i;for(let n=0;n<i;n++){const i=this.tableAccessors[t[n]];s[n]=i.getData(e[n],s[n])}}else s=s||{},s=this.tableAccessors[t].getData(e,s);return s}getPropertyTableInfo(t=null){if(null===t&&(t=this.tableAccessors.map((t,e)=>e)),Array.isArray(t))return t.map(t=>{const e=this.tableAccessors[t];return{name:e.name,className:e.definition.class}});{const e=this.tableAccessors[t];return{name:e.name,className:e.definition.class}}}getPropertyTextureData(t,e,s=[]){const i=this.textureAccessors;s.length=i.length;for(let n=0;n<i.length;n++){const r=i[n];s[n]=r.getData(t,e,this.object.geometry,s[n])}return s}async getPropertyTextureDataAsync(t,e,s=[]){const i=this.textureAccessors;s.length=i.length;const n=[];for(let r=0;r<i.length;r++){const o=i[r].getDataAsync(t,e,this.object.geometry,s[r]).then(t=>{s[r]=t});n.push(o)}return await Promise.all(n),s}getPropertyTextureInfo(){return this.textureAccessors}getPropertyAttributeData(t,e=[]){const s=this.attributeAccessors;e.length=s.length;for(let i=0;i<s.length;i++){const n=s[i];e[i]=n.getData(t,this.object.geometry,e[i])}return e}getPropertyAttributeInfo(){return this.attributeAccessors.map(t=>({name:t.name,className:t.definition.class}))}dispose(){this.textureAccessors.forEach(t=>t.dispose()),this.tableAccessors.forEach(t=>t.dispose()),this.attributeAccessors.forEach(t=>t.dispose())}}const ao="EXT_structural_metadata";function lo(t,e=[]){var s;const i=(null==(s=t.json.textures)?void 0:s.length)||0,n=new Array(i).fill(null);return e.forEach(({properties:e})=>{for(const s in e){const{index:i}=e[s];null===n[i]&&(n[i]=t.loadTexture(i))}}),Promise.all(n)}function co(t,e=[]){var s;const i=(null==(s=t.json.bufferViews)?void 0:s.length)||0,n=new Array(i).fill(null);return e.forEach(({properties:e})=>{for(const s in e){const{values:i,arrayOffsets:r,stringOffsets:o}=e[s];null===n[i]&&(n[i]=t.loadBufferView(i)),null===n[r]&&(n[r]=t.loadBufferView(r)),null===n[o]&&(n[o]=t.loadBufferView(o))}}),Promise.all(n)}class ho{constructor(t){this.parser=t,this.name=ao}async afterRoot({scene:t,parser:e}){const s=e.json.extensionsUsed;if(!s||!s.includes(ao))return;let i=null,n=e.json.extensions[ao];if(n.schemaUri){const{manager:t,path:s,requestHeader:r,crossOrigin:o}=e.options,a=new URL(n.schemaUri,s).toString(),l=new Xi(t);l.setCrossOrigin(o),l.setResponseType("json"),l.setRequestHeader(r),i=l.loadAsync(a).then(t=>{n={...n,schema:t}})}const[r,o]=await Promise.all([lo(e,n.propertyTextures),co(e,n.propertyTables),i]),a=new oo(n,r,o);t.userData.structuralMetadata=a,t.traverse(t=>{var s;if(e.associations.has(t)){const{meshes:i,primitives:l}=e.associations.get(t),c=null==(s=e.json.meshes[i])?void 0:s.primitives[l];if(c&&c.extensions&&c.extensions[ao]){const e=c.extensions[ao];t.userData.structuralMetadata=new oo(n,r,o,e,t)}else t.userData.structuralMetadata=a}})}}const uo=new wi,po=new wi,mo=new wi;class go{constructor(t,e,s){this.geometry=t,this.textures=e,this.data=s,this._asyncRead=!1,this.featureIds=s.featureIds.map(t=>{const{texture:e,...s}=t,i={label:null,propertyTable:null,nullFeatureId:null,...s};return e&&(i.texture={texCoord:0,channels:[0],...e}),i})}getTextures(){return this.textures}getFeatureInfo(){return this.featureIds}getFeaturesAsync(...t){this._asyncRead=!0;const e=this.getFeatures(...t);return this._asyncRead=!1,e}getFeatures(t,e){const{geometry:s,textures:i,featureIds:n}=this,r=new Array(n.length).fill(null),o=n.length;Yr.increaseSizeTo(o);const a=Jr(s,t),l=a[(c=e,c.x>c.y&&c.x>c.z?0:c.y>c.z?1:2)];var c;for(let d=0,p=n.length;d<p;d++){const t=n[d],o="nullFeatureId"in t?t.nullFeatureId:null;if("texture"in t){const n=i[t.texture.index];Kr(s,t.texture.texCoord,e,a,uo),to(uo,n.image.width,n.image.height,po),mo.set(d,0),Yr.renderPixelToTarget(i[t.texture.index],po,mo)}else if("attribute"in t){const e=s.getAttribute(`_feature_id_${t.attribute}`).getX(l);e!==o&&(r[d]=e)}else{const t=l;t!==o&&(r[d]=t)}}const h=new Uint8Array(4*o);return this._asyncRead?Yr.readDataAsync(h).then(()=>(u(),r)):(Yr.readData(h),u(),r);function u(){const t=new Uint32Array(1);for(let e=0,s=n.length;e<s;e++){const s=n[e],i="nullFeatureId"in s?s.nullFeatureId:null;if("texture"in s){const{channels:n}=s.texture,o=n.map(t=>h[4*e+t]);new Uint8Array(t.buffer).set(o);const a=t[0];a!==i&&(r[e]=a)}}}}dispose(){this.textures.forEach(t=>{t&&(t.dispose(),t.image instanceof ImageBitmap&&t.image.close())})}}const fo="EXT_mesh_features";function yo(t,e,s){t.traverse(t=>{var i;if(e.associations.has(t)){const{meshes:n,primitives:r}=e.associations.get(t),o=null==(i=e.json.meshes[n])?void 0:i.primitives[r];o&&o.extensions&&o.extensions[fo]&&s(t,o.extensions[fo])}})}class bo{constructor(t){this.parser=t,this.name=fo}async afterRoot({scene:t,parser:e}){var s;const i=e.json.extensionsUsed;if(!i||!i.includes(fo))return;const n=(null==(s=e.json.textures)?void 0:s.length)||0,r=new Array(n).fill(null);yo(t,e,(t,{featureIds:s})=>{s.forEach(t=>{if(t.texture&&null===r[t.texture.index]){const s=t.texture.index;r[s]=e.loadTexture(s)}})});const o=await Promise.all(r);yo(t,e,(t,e)=>{t.userData.meshFeatures=new go(t.geometry,o,e)})}}class xo{constructor(){this.name="CESIUM_RTC"}afterRoot(t){if(t.parser.json.extensions&&t.parser.json.extensions.CESIUM_RTC){const{center:e}=t.parser.json.extensions.CESIUM_RTC;e&&(t.scene.position.x+=e[0],t.scene.position.y+=e[1],t.scene.position.z+=e[2])}}}class _o{constructor(t){t={metadata:!0,rtc:!0,plugins:[],dracoLoader:null,ktxLoader:null,meshoptDecoder:null,autoDispose:!0,...t},this.tiles=null,this.metadata=t.metadata,this.rtc=t.rtc,this.plugins=t.plugins,this.dracoLoader=t.dracoLoader,this.ktxLoader=t.ktxLoader,this.meshoptDecoder=t.meshoptDecoder,this._gltfRegex=/\.(gltf|glb)$/g,this._dracoRegex=/\.drc$/g,this._loader=null}init(t){const s=new e(t.manager);this.dracoLoader&&(s.setDRACOLoader(this.dracoLoader),t.manager.addHandler(this._dracoRegex,this.dracoLoader)),this.ktxLoader&&s.setKTX2Loader(this.ktxLoader),this.meshoptDecoder&&s.setMeshoptDecoder(this.meshoptDecoder),this.rtc&&s.register(()=>new xo),this.metadata&&(s.register(()=>new ho),s.register(()=>new bo)),this.plugins.forEach(t=>s.register(t)),t.manager.addHandler(this._gltfRegex,s),this.tiles=t,this._loader=s}dispose(){this.tiles.manager.removeHandler(this._gltfRegex),this.tiles.manager.removeHandler(this._dracoRegex),this.autoDispose&&(this.ktxLoader.dispose(),this.dracoLoader.dispose())}}class To{set delay(t){this.deferCallbacks.delay=t}get delay(){return this.deferCallbacks.delay}set bytesTarget(t){this.lruCache.minBytesSize=t}get bytesTarget(){return this.lruCache.minBytesSize}get estimatedGpuBytes(){return this.lruCache.cachedBytes}constructor(t={}){const{delay:e=0,bytesTarget:s=0}=t;this.name="UNLOAD_TILES_PLUGIN",this.tiles=null,this.lruCache=new h,this.deferCallbacks=new vo,this.delay=e,this.bytesTarget=s}init(t){this.tiles=t;const{lruCache:e,deferCallbacks:s}=this;s.callback=t=>{e.markUnused(t),e.scheduleUnload(!1)};const i=e=>{const s=e.cached.scene;t.visibleTiles.has(e)||t.invokeOnePlugin(t=>t.unloadTileFromGPU&&t.unloadTileFromGPU(s,e))};this._onUpdateBefore=()=>{e.unloadPriorityCallback=t.lruCache.unloadPriorityCallback,e.computeMemoryUsageCallback=t.lruCache.computeMemoryUsageCallback,e.minSize=1/0,e.maxSize=1/0,e.maxBytesSize=1/0,e.unloadPercent=1,e.autoMarkUnused=!1},this._onVisibilityChangeCallback=({tile:n,visible:r})=>{r?(e.add(n,i),t.markTileUsed(n),s.cancel(n)):s.run(n)},t.forEachLoadedModel((e,s)=>{const i=t.visibleTiles.has(s);this._onVisibilityChangeCallback({scene:e,visible:i})}),t.addEventListener("tile-visibility-change",this._onVisibilityChangeCallback),t.addEventListener("update-before",this._onUpdateBefore)}unloadTileFromGPU(t,e){t&&t.traverse(t=>{if(t.material){const e=t.material;e.dispose();for(const t in e){const s=e[t];s&&s.isTexture&&s.dispose()}}t.geometry&&t.geometry.dispose()})}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._onVisibilityChangeCallback),this.tiles.removeEventListener("update-before",this._onUpdateBefore),this.deferCallbacks.cancelAll()}}class vo{constructor(t=()=>{}){this.map=new Map,this.callback=t,this.delay=0}run(t){const{map:e,delay:s}=this;if(e.has(t))throw new Error("DeferCallbackManager: Callback already initialized.");0===s?this.callback(t):e.set(t,setTimeout(()=>this.callback(t),s))}cancel(t){const{map:e}=this;e.has(t)&&(clearTimeout(e.get(t)),e.delete(t))}cancelAll(){this.map.forEach((t,e)=>{this.cancel(e)})}}const{clamp:wo}=Pi;class Po{constructor(){this.duration=250,this.fadeCount=0,this._lastTick=-1,this._fadeState=new Map,this.onFadeComplete=null,this.onFadeStart=null,this.onFadeSetComplete=null,this.onFadeSetStart=null}deleteObject(t){t&&this.completeFade(t)}guaranteeState(t){const e=this._fadeState;if(e.has(t))return!1;return e.set(t,{fadeInTarget:0,fadeOutTarget:0,fadeIn:0,fadeOut:0}),!0}completeFade(t){const e=this._fadeState;if(!e.has(t))return;const s=0===e.get(t).fadeOutTarget;e.delete(t),this.fadeCount--,this.onFadeComplete&&this.onFadeComplete(t,s),0===this.fadeCount&&this.onFadeSetComplete&&this.onFadeSetComplete()}completeAllFades(){this._fadeState.forEach((t,e)=>{this.completeFade(e)})}forEachObject(t){this._fadeState.forEach((e,s)=>{t(s,e)})}fadeIn(t){const e=this.guaranteeState(t),s=this._fadeState.get(t);s.fadeInTarget=1,s.fadeOutTarget=0,s.fadeOut=0,e&&(this.fadeCount++,1===this.fadeCount&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(t))}fadeOut(t){const e=this.guaranteeState(t),s=this._fadeState.get(t);s.fadeOutTarget=1,e&&(s.fadeInTarget=1,s.fadeIn=1,this.fadeCount++,1===this.fadeCount&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(t))}isFading(t){return this._fadeState.has(t)}isFadingOut(t){const e=this._fadeState.get(t);return e&&1===e.fadeOutTarget}update(){const t=window.performance.now();-1===this._lastTick&&(this._lastTick=t);const e=wo((t-this._lastTick)/this.duration,0,1);this._lastTick=t,this._fadeState.forEach((t,s)=>{const{fadeOutTarget:i,fadeInTarget:n}=t;let{fadeOut:r,fadeIn:o}=t;const a=Math.sign(n-o);o=wo(o+a*e,0,1);const l=Math.sign(i-r);r=wo(r+l*e,0,1),t.fadeIn=o,t.fadeOut=r,((1===r||0===r)&&(1===o||0===o)||r>=o)&&this.completeFade(s)})}}const Mo=Symbol("FADE_PARAMS");function Co(t,e){if(t[Mo])return t[Mo];const s={fadeIn:{value:0},fadeOut:{value:0},fadeTexture:{value:null}};return t[Mo]=s,t.defines={...t.defines||{},FEATURE_FADE:0},t.onBeforeCompile=t=>{e&&e(t),t.uniforms={...t.uniforms,...s},t.vertexShader=t.vertexShader.replace(/void\s+main\(\)\s+{/,t=>`\n\t\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t\tvarying float vBatchId;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t${t}\n\n\t\t\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t\t\t// add 0.5 to the value to avoid floating error that may cause flickering\n\t\t\t\t\t\tvBatchId = getIndirectIndex( gl_DrawID ) + 0.5;\n\n\t\t\t\t\t\t#endif\n\t\t\t\t`),t.fragmentShader=t.fragmentShader.replace(/void main\(/,t=>`\n\t\t\t\t#if FEATURE_FADE\n\n\t\t\t\t// adapted from https://www.shadertoy.com/view/Mlt3z8\n\t\t\t\tfloat bayerDither2x2( vec2 v ) {\n\n\t\t\t\t\treturn mod( 3.0 * v.y + 2.0 * v.x, 4.0 );\n\n\t\t\t\t}\n\n\t\t\t\tfloat bayerDither4x4( vec2 v ) {\n\n\t\t\t\t\tvec2 P1 = mod( v, 2.0 );\n\t\t\t\t\tvec2 P2 = floor( 0.5 * mod( v, 4.0 ) );\n\t\t\t\t\treturn 4.0 * bayerDither2x2( P1 ) + bayerDither2x2( P2 );\n\n\t\t\t\t}\n\n\t\t\t\t// the USE_BATCHING define is not available in fragment shaders\n\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t// functions for reading the fade state of a given batch id\n\t\t\t\tuniform sampler2D fadeTexture;\n\t\t\t\tvarying float vBatchId;\n\t\t\t\tvec2 getFadeValues( const in float i ) {\n\n\t\t\t\t\tint size = textureSize( fadeTexture, 0 ).x;\n\t\t\t\t\tint j = int( i );\n\t\t\t\t\tint x = j % size;\n\t\t\t\t\tint y = j / size;\n\t\t\t\t\treturn texelFetch( fadeTexture, ivec2( x, y ), 0 ).rg;\n\n\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\tuniform float fadeIn;\n\t\t\t\tuniform float fadeOut;\n\n\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t${t}\n\t\t\t`).replace(/#include <dithering_fragment>/,t=>`\n\n\t\t\t\t${t}\n\n\t\t\t\t#if FEATURE_FADE\n\n\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\tvec2 fadeValues = getFadeValues( vBatchId );\n\t\t\t\tfloat fadeIn = fadeValues.r;\n\t\t\t\tfloat fadeOut = fadeValues.g;\n\n\t\t\t\t#endif\n\n\t\t\t\tfloat bayerValue = bayerDither4x4( floor( mod( gl_FragCoord.xy, 4.0 ) ) );\n\t\t\t\tfloat bayerBins = 16.0;\n\t\t\t\tfloat dither = ( 0.5 + bayerValue ) / bayerBins;\n\t\t\t\tif ( dither >= fadeIn ) {\n\n\t\t\t\t\tdiscard;\n\n\t\t\t\t}\n\n\t\t\t\tif ( dither < fadeOut ) {\n\n\t\t\t\t\tdiscard;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t`)},s}class So{constructor(){this._fadeParams=new WeakMap,this.fading=0}setFade(t,e,s){if(!t)return;const i=this._fadeParams;t.traverse(t=>{const n=t.material;if(n&&i.has(n)){const t=i.get(n);t.fadeIn.value=e,t.fadeOut.value=s;const r=+(!(0===e||1===e)||!(0===s||1===s));n.defines.FEATURE_FADE!==r&&(this.fading+=1===r?1:-1,n.defines.FEATURE_FADE=r,n.needsUpdate=!0)}})}prepareScene(t){t.traverse(t=>{t.material&&this.prepareMaterial(t.material)})}deleteScene(t){if(!t)return;this.setFade(t,1,0);const e=this._fadeParams;t.traverse(t=>{const s=t.material;s&&e.delete(s)})}prepareMaterial(t){const e=this._fadeParams;e.has(t)||e.set(t,Co(t,t.onBeforeCompile))}}class Ao{constructor(t,e=new vi){this.other=t,this.material=e,this.visible=!0,this.parent=null,this._instanceInfo=[],this._visibilityChanged=!0;const s=new Proxy(this,{get(e,i){if(i in e)return e[i];{const n=t[i];return n instanceof Function?(...t)=>(e.syncInstances(),n.call(s,...t)):t[i]}},set:(e,s,i)=>(s in e?e[s]=i:t[s]=i,!0),deleteProperty:(e,s)=>s in e?delete e[s]:delete t[s]});return s}syncInstances(){const t=this._instanceInfo,e=this.other._instanceInfo;for(;e.length>t.length;){const s=t.length;t.push(new Proxy({visible:!1},{get:(t,i)=>i in t?t[i]:e[s][i],set:(t,i,n)=>(i in t?t[i]=n:e[s][i]=n,!0)}))}}}class Eo extends Ao{constructor(...t){super(...t);const e=this.material,s=Co(e,e.onBeforeCompile);e.defines.FEATURE_FADE=1,e.defines.USE_BATCHING_FRAG=1,e.needsUpdate=!0,this.fadeTexture=null,this._fadeParams=s}setFadeAt(t,e,s){this._initFadeTexture(),this.fadeTexture.setValueAt(t,255*e,255*s)}_initFadeTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=t*t*2,s=this.fadeTexture;if(!s||s.image.data.length!==e){const i=new Uint8Array(e),n=new Lo(i,t,t,Fi,Ii);if(s){s.dispose();const t=s.image.data,e=this.fadeTexture.image.data,i=Math.min(t.length,e.length);e.set(new t.constructor(t.buffer,0,i))}this.fadeTexture=n,this._fadeParams.fadeTexture.value=n,n.needsUpdate=!0}}dispose(){this.fadeTexture&&this.fadeTexture.dispose()}}class Lo extends Di{setValueAt(t,...e){const{data:s,width:i,height:n}=this.image,r=Math.floor(s.length/(i*n));let o=!1;for(let a=0;a<r;a++){const i=t*r+a,n=s[i],l=e[a]||0;n!==l&&(s[i]=l,o=!0)}o&&(this.needsUpdate=!0)}}const Uo=Symbol("HAS_POPPED_IN"),Ro=new Mi,Do=new Mi,Fo=new Qi,Io=new Qi,ko=new Mi;function Oo(){const t=this._fadeManager,e=this.tiles;this._fadingBefore=t.fadeCount,this._displayActiveTiles=e.displayActiveTiles,e.displayActiveTiles=!0}function Vo(){const t=this._fadeManager,e=this._fadeMaterialManager,s=this._displayActiveTiles,i=this._fadingBefore,n=this._prevCameraTransforms,{tiles:r,maximumFadeOutTiles:o,batchedMesh:a}=this,{cameras:l}=r;r.displayActiveTiles=s,t.update();const c=t.fadeCount;if(0!==i&&0!==c&&(r.dispatchEvent({type:"fade-change"}),r.dispatchEvent({type:"needs-render"})),s||r.visibleTiles.forEach(t=>{const e=t.cached.scene;e&&(e.visible=t.__inFrustum),this.forEachBatchIds(t,(e,s,i)=>{s.setVisibleAt(e,t.__inFrustum),i.batchedMesh.setVisibleAt(e,t.__inFrustum)})}),o<this._fadingOutCount){let e=!0;l.forEach(t=>{if(!n.has(t))return;const s=t.matrixWorld,i=n.get(t);s.decompose(Do,Io,ko),i.decompose(Ro,Fo,ko);const r=Io.angleTo(Fo),o=Do.distanceTo(Ro);e=e&&(r>.25||o>.1)}),e&&t.completeAllFades()}if(l.forEach(t=>{n.get(t).copy(t.matrixWorld)}),t.forEachObject((s,{fadeIn:i,fadeOut:n})=>{const o=s.cached.scene,a=t.isFadingOut(s);r.markTileUsed(s),o&&(e.setFade(o,i,n),a&&(o.visible=!0)),this.forEachBatchIds(s,(t,e,s)=>{e.setFadeAt(t,i,n),e.setVisibleAt(t,!0),s.batchedMesh.setVisibleAt(t,!1)})}),a){const t=r.getPluginByName("BATCHED_TILES_PLUGIN").batchedMesh.material;a.material.map=t.map}}class zo{get fadeDuration(){return this._fadeManager.duration}set fadeDuration(t){this._fadeManager.duration=Number(t)}get fadingTiles(){return this._fadeManager.fadeCount}constructor(t){t={maximumFadeOutTiles:50,fadeRootTiles:!1,fadeDuration:250,...t},this.name="FADE_TILES_PLUGIN",this.priority=-2,this.tiles=null,this.batchedMesh=null,this._quickFadeTiles=new Set,this._fadeManager=new Po,this._fadeMaterialManager=new So,this._prevCameraTransforms=null,this._fadingOutCount=0,this.maximumFadeOutTiles=t.maximumFadeOutTiles,this.fadeRootTiles=t.fadeRootTiles,this.fadeDuration=t.fadeDuration}init(t){this._onLoadModel=({scene:t})=>{this._fadeMaterialManager.prepareScene(t)},this._onDisposeModel=({tile:t,scene:e})=>{this.tiles.visibleTiles.has(t)&&this._quickFadeTiles.add(t.parent),this._fadeManager.deleteObject(t),this._fadeMaterialManager.deleteScene(e)},this._onAddCamera=({camera:t})=>{this._prevCameraTransforms.set(t,new Bi)},this._onDeleteCamera=({camera:t})=>{this._prevCameraTransforms.delete(t)},this._onTileVisibilityChange=({tile:t,visible:e})=>{const s=t.cached.scene;s&&(s.visible=!0),this.forEachBatchIds(t,(t,e,s)=>{e.setFadeAt(t,0,0),e.setVisibleAt(t,!1),s.batchedMesh.setVisibleAt(t,!1)})},this._onUpdateBefore=()=>{Oo.call(this)},this._onUpdateAfter=()=>{Vo.call(this)},t.addEventListener("load-model",this._onLoadModel),t.addEventListener("dispose-model",this._onDisposeModel),t.addEventListener("add-camera",this._onAddCamera),t.addEventListener("delete-camera",this._onDeleteCamera),t.addEventListener("update-before",this._onUpdateBefore),t.addEventListener("update-after",this._onUpdateAfter),t.addEventListener("tile-visibility-change",this._onTileVisibilityChange);const e=this._fadeManager;e.onFadeSetStart=()=>{t.dispatchEvent({type:"fade-start"}),t.dispatchEvent({type:"needs-render"})},e.onFadeSetComplete=()=>{t.dispatchEvent({type:"fade-end"}),t.dispatchEvent({type:"needs-render"})},e.onFadeComplete=(e,s)=>{this._fadeMaterialManager.setFade(e.cached.scene,0,0),this.forEachBatchIds(e,(t,e,i)=>{e.setFadeAt(t,0,0),e.setVisibleAt(t,!1),i.batchedMesh.setVisibleAt(t,s)}),s||(t.invokeOnePlugin(t=>t!==this&&t.setTileVisible&&t.setTileVisible(e,!1)),this._fadingOutCount--)};const s=new Map;t.cameras.forEach(t=>{s.set(t,new Bi)}),t.forEachLoadedModel((t,e)=>{this._onLoadModel({scene:t})}),this.tiles=t,this._fadeManager=e,this._prevCameraTransforms=s}initBatchedMesh(){var t;const e=null==(t=this.tiles.getPluginByName("BATCHED_TILES_PLUGIN"))?void 0:t.batchedMesh;if(e){if(null===this.batchedMesh){this._onBatchedMeshDispose=()=>{this.batchedMesh.dispose(),this.batchedMesh.removeFromParent(),this.batchedMesh=null,e.removeEventListener("dispose",this._onBatchedMeshDispose)};const t=e.material.clone();t.onBeforeCompile=e.material.onBeforeCompile,this.batchedMesh=new Eo(e,t),this.tiles.group.add(this.batchedMesh)}}else null!==this.batchedMesh&&(this._onBatchedMeshDispose(),this._onBatchedMeshDispose=null)}setTileVisible(t,e){const s=this._fadeManager,i=s.isFading(t);if(s.isFadingOut(t)&&this._fadingOutCount--,e?1===t.__depthFromRenderedParent?((t[Uo]||this.fadeRootTiles)&&this._fadeManager.fadeIn(t),t[Uo]=!0):this._fadeManager.fadeIn(t):(this._fadingOutCount++,s.fadeOut(t)),this._quickFadeTiles.has(t)&&(this._fadeManager.completeFade(t),this._quickFadeTiles.delete(t)),i)return!0;const n=this._fadeManager.isFading(t);return!(e||!n)}dispose(){const t=this.tiles;this._fadeManager.completeAllFades(),null!==this.batchedMesh&&this._onBatchedMeshDispose(),t.removeEventListener("load-model",this._onLoadModel),t.removeEventListener("dispose-model",this._onDisposeModel),t.removeEventListener("add-camera",this._onAddCamera),t.removeEventListener("delete-camera",this._onDeleteCamera),t.removeEventListener("update-before",this._onUpdateBefore),t.removeEventListener("update-after",this._onUpdateAfter),t.removeEventListener("tile-visibility-change",this._onTileVisibilityChange),t.forEachLoadedModel((t,e)=>{this._fadeManager.deleteObject(e),t&&(t.visible=!0)})}forEachBatchIds(t,e){if(this.initBatchedMesh(),this.batchedMesh){const s=this.tiles.getPluginByName("BATCHED_TILES_PLUGIN"),i=s.getTileBatchIds(t);i&&i.forEach(t=>{e(t,this.batchedMesh,s)})}}}new Bi,new Mi,new Mi,new Ti,new s(new vi);new Di(new Uint8Array([255,255,255,255]),1,1).needsUpdate=!0,new Mi;export{ss as A,Tr as B,Cr as D,si as F,zo as N,_o as O,wr as U,ui as W,To as a,a as i};
