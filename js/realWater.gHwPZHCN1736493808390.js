import{m as n,e,b as t,U as r,c as o}from"./@tresjs.g7tJPOCI1736493808390.js";import{P as i}from"./tweakpane.yHWGBmom1736493808390.js";import{_ as c,s as a,ay as l,t as s,W as u,m as f,k as p}from"./three.lAfZYOpc1736493808390.js";import{d as v,a4 as g,b as d,o as x,f as h,u as m,g as y,j as w,al as b,r as C,J as R,aj as I,ak as _}from"./@vue.-Mz_IXfk1736493808390.js";import"./@vueuse.kU-N6GoC1736493808390.js";var M="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const z=A;!function(n,e){const t=A,r=L();for(;;)try{if(671564===parseInt(t(241))/1+-parseInt(t(283))/2*(parseInt(t(261))/3)+parseInt(t(270))/4+-parseInt(t(280))/5*(parseInt(t(281))/6)+-parseInt(t(240))/7*(-parseInt(t(239))/8)+parseInt(t(257))/9+parseInt(t(242))/10*(-parseInt(t(263))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const D=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[A(244)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){D(this,(function(){const n=A,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(271),"i"),r=E("init");e[n(253)](r+n(250))&&t[n(253)](r+n(269))?E():r("0")}))()}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[A(244)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function A(n,e){const t=L();return(A=function(n,e){return t[n-=239]})(n,e)}function L(){const n=["__proto__","input","4128832YdWiYB","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","uniforms","water","action","causticTex","stateObject","length","tiles","value","1685rieUsA","19452efsQoQ","causticsTexture","132hQVxYl","prototype","exception","174920bEVNTy","7uZPnRE","497521NdOHtF","730pReXtA","toString","apply","error","setIndex","debu","RawShaderMaterial","constructor","chain","console","gger","test","info",'{}.constructor("return this")( )',"FrontSide","8885403YZhtBc","string","counter","BufferAttribute","25563poJKjg","pool","31999XoqqKQ","table","setAttribute","bind","BufferGeometry"];return(L=function(){return n})()}T(void 0,(function(){const n=A;let e;try{e=Function("return (function() "+n(255)+");")()}catch(o){e=window}const t=e[n(251)]=e.console||{},r=["log","warn",n(254),n(245),n(285),n(264),"trace"];for(let i=0;i<r[n(277)];i++){const e=T.constructor[n(284)][n(266)](T),o=r[i],c=t[o]||e;e[n(268)]=T[n(266)](T),e[n(243)]=c[n(243)][n(266)](c),t[o]=e}}))();const O=v({__name:z(262),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=z,o=t,i=new(c[r(267)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(265)]("position",new(c[r(260)])(l,3)),i[r(246)](new(c[r(260)])(s,1));const u=new(c[r(248)])({uniforms:{light:{value:o.light},tiles:{value:o[r(278)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(256)]}),f=new a(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{const n=r;((n,e)=>{const t=r;u[t(272)][t(273)].value=n,u[t(272)][t(275)][t(279)]=e,p[t(279)].render(f,v[t(279)])})(o.waterTexture,o[n(282)])})),(n,e)=>null}});function E(n){function e(n){const t=A;if(typeof n===t(258))return function(n){}[t(249)]("while (true) {}")[t(244)](t(259));1!==(""+n/n)[t(277)]||n%20==0?function(){return!0}[t(249)]("debu"+t(252)).call(t(274)):function(){return!1}.constructor(t(247)+"gger").apply(t(276)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const F=j;function j(n,e){const t=P();return(j=function(n,e){return t[n-=342]})(n,e)}!function(n,e){const t=j,r=P();for(;;)try{if(456872===-parseInt(t(398))/1+-parseInt(t(372))/2+parseInt(t(350))/3+parseInt(t(390))/4+parseInt(t(395))/5*(parseInt(t(376))/6)+-parseInt(t(389))/7*(-parseInt(t(345))/8)+-parseInt(t(351))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[j(369)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){S(this,(function(){const n=j,e=new RegExp(n(396)),t=new RegExp(n(360),"i"),r=V(n(348));e[n(370)](r+n(364))&&t.test(r+n(346))?V():r("0")}))()}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[j(369)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function P(){const n=["gger","call","debu","while (true) {}","length","geometry","string","waterTexture","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","table",'{}.constructor("return this")( )',"value","chain","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","render","causticTex","counter","apply","test","constructor","356362Obmdvv","setPath","tiles","clear","309360ZyXWzP","underwater","FrontSide","bind","light","warn","white","CubeTextureLoader","neg-y.jpg","load","pos-x.jpg","causticsTexture","prototype","7SEBSDk","295612jEuDxs","BackSide","water","neg-z.jpg","console","15mErLIc","function *\\( *\\)","Color","183763cHfOMI","setClearColor","setRenderTarget","info","uniforms","toString","pooRef","Mesh","2649928RHeLhz","input","pos-z.jpg","init","exception","925668uxbgiN","446076tkNfFk"];return(P=function(){return n})()}W(void 0,(function(){const n=j;let e;try{e=Function("return (function() "+n(362)+");")()}catch(o){e=window}const t=e[n(394)]=e[n(394)]||{},r=["log",n(381),n(401),"error",n(349),n(361),"trace"];for(let i=0;i<r[n(356)];i++){const e=W[n(371)][n(388)][n(379)](W),o=r[i],c=t[o]||e;e.__proto__=W[n(379)](W),e[n(342)]=c[n(342)][n(379)](c),t[o]=e}}))();const k=v({__name:F(392),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=F;let i,a;const s=r,u=s[o(357)],f=(new(c[o(383)]))[o(373)](o(365))[o(385)]([o(386),"neg-x.jpg","pos-y.jpg",o(384),o(347),o(393)]),p=([i,a]=g((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),v=new l({uniforms:{light:{value:s[o(380)]},tiles:{value:p},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new(c[o(344)])(u,v),w=d(null),b=new(c[o(397)])(o(382)),{renderer:C,camera:R}=n(),{onLoop:I}=e();return I((()=>{const n=o;C[n(363)][n(400)](null),C.value[n(399)](b,1),C[n(363)][n(375)](),v[n(402)].water[n(363)]=s[n(359)],v[n(402)][n(367)][n(363)]=s[n(387)],v.side=c[n(378)],v[n(402)][n(377)][n(363)]=!0,C[n(363)][n(366)](y,R[n(363)]),v.side=c[n(391)],v.uniforms[n(377)][n(363)]=!1,C[n(363)].render(y,R[n(363)])})),(n,e)=>{const t=o;return x(),h(O,{tiles:m(p),light:n[t(380)],waterTexture:n[t(359)],causticsTexture:n[t(387)],ref_key:t(343),ref:w},null,8,[t(374),"light",t(359),"causticsTexture"])}}});function V(n){function e(n){const t=j;if(typeof n===t(358))return function(n){}.constructor(t(355)).apply(t(368));1!==(""+n/n)[t(356)]||n%20==0?function(){return!0}.constructor(t(354)+"gger")[t(353)]("action"):function(){return!1}[t(371)](t(354)+t(352))[t(369)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const N=G;function Z(){const n=["18XEreeV","length","log","counter","OrthographicCamera","table","733166gwCjmq","error","console","clear","test","chain","init","trace","__proto__","11mqnKCs","prototype","input","debu","while (true) {}","setRenderTarget","geometry","8620524SIAJFi","causticsTexture","black","8fJKkzO","caustics",'{}.constructor("return this")( )',"texture","11548284pwKVWw","water","uniforms","waterTexture","16JwFnXU","Color","return (function() ","299865MWOhqr","144930nikbMg","apply","render","function *\\( *\\)","light","5609270ktZpNl","stateObject","733443pOmXFT","toString","gger","constructor","3JmWjeE","value"];return(Z=function(){return n})()}!function(n,e){const t=G,r=Z();for(;;)try{if(905541===parseInt(t(506))/1*(parseInt(t(495))/2)+-parseInt(t(502))/3+-parseInt(t(541))/4*(parseInt(t(494))/5)+parseInt(t(530))/6+-parseInt(t(514))/7*(parseInt(t(533))/8)+parseInt(t(508))/9*(-parseInt(t(500))/10)+parseInt(t(523))/11*(parseInt(t(537))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const H=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[G(496)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){H(this,(function(){const n=G,e=new RegExp(n(498)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=J(n(520));e[n(518)](r+n(519))&&t.test(r+n(525))?J():r("0")}))()}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[G(496)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function G(n,e){const t=Z();return(G=function(n,e){return t[n-=493]})(n,e)}B(void 0,(function(){const n=G;let e;try{e=Function(n(493)+n(535)+");")()}catch(o){e=window}const t=e[n(516)]=e[n(516)]||{},r=[n(510),"warn","info",n(515),"exception",n(513),n(521)];for(let i=0;i<r[n(509)];i++){const e=B[n(505)][n(524)].bind(B),o=r[i],c=t[o]||e;e[n(522)]=B.bind(B),e[n(503)]=c[n(503)].bind(c),t[o]=e}}))();const q=v({__name:N(534),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=N,o=t,i=new(c[r(512)])(0,1,1,0,0,2e3),l=new s(2,2,200,200),p=new u(1024,1024),v=new f({uniforms:{light:{value:o[r(499)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),g=new a(l,v),d=new(c[r(542)])(r(532)),{renderer:C}=n(),{onBeforeLoop:R}=e();return R((()=>{const n=r;g.material[n(539)][n(538)][n(507)]=o[n(540)],C.value[n(528)](p),C[n(507)].setClearColor(d,0),C[n(507)][n(517)](),C[n(507)][n(497)](g,i)})),(n,e)=>{const t=r;return x(),h(b,null,{default:y((()=>[w(k,{waterTexture:n[t(540)],causticsTexture:m(p)[t(536)],light:n[t(499)],geometry:m(l)},null,8,[t(540),t(531),t(499),t(529)])])),_:1})}}});function J(n){function e(n){const t=G;if("string"==typeof n)return function(n){}[t(505)](t(527))[t(496)](t(511));1!==(""+n/n)[t(509)]||n%20==0?function(){return!0}.constructor("debugger").call("action"):function(){return!1}[t(505)](t(526)+t(504))[t(496)](t(501)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const $=U;!function(n,e){const t=U,r=X();for(;;)try{if(427512===parseInt(t(341))/1+-parseInt(t(306))/2+parseInt(t(326))/3+parseInt(t(320))/4*(parseInt(t(313))/5)+parseInt(t(362))/6+-parseInt(t(308))/7*(-parseInt(t(330))/8)+-parseInt(t(361))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Y=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[U(329)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function U(n,e){const t=X();return(U=function(n,e){return t[n-=301]})(n,e)}!function(){Y(this,(function(){const n=U,e=new RegExp(n(364)),t=new RegExp(n(371),"i"),r=nn(n(363));e[n(367)](r+n(336))&&t[n(367)](r+n(350))?nn():r("0")}))()}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function X(){const n=["393909kGDNJR","table","prototype","PlaneGeometry","RawShaderMaterial","center","removeEventListener","intersectObject","WebGLRenderTarget","input","console","info","debu","string","uniforms","call","clientY","getY","light","addEventListener","8078382erCVYA","133998GDPSge","init","function *\\( *\\)","counter","waterTexture","test","position","render",'{}.constructor("return this")( )',"\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","FloatType","value","material","while (true) {}","OrthographicCamera","mousemove","1644488hEbqkW","getBoundingClientRect","203FihlKG","attributes","point","setY","length","5OoDrwW","autoClear","toString","clientX","Mesh","radius","setFromCamera","2884636OqxiKu","width","needsUpdate","return (function() ","exception","trace","723663UAbDoD","stateObject","warn","apply","212064mERhmL","texture","waterSimulation","gger","height","bind","chain","action","constructor","domElement","count"];return(X=function(){return n})()}K(void 0,(function(){const n=U,e=function(){const n=U;let e;try{e=Function(n(323)+n(370)+");")()}catch(t){e=window}return e}(),t=e[n(351)]=e[n(351)]||{},r=["log",n(328),n(352),"error",n(324),n(342),n(325)];for(let o=0;o<r[n(312)];o++){const e=K[n(338)][n(343)][n(335)](K),i=r[o],c=t[i]||e;e.__proto__=K.bind(K),e.toString=c[n(315)][n(335)](c),t[i]=e}}))();const Q=v({__name:$(332),props:{light:{}},setup(t,{expose:r}){const o=$,i=new(c[o(304)])(0,1,1,0,0,2e3),u=new s(2,2),f=new(c[o(349)])(256,256,{type:c[o(372)]}),v=new(c[o(349)])(256,256,{type:c[o(372)]}),g=new(c[o(345)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),d=new l({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),y=new l({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),w=new a(u,g),b=new(c[o(317)])(u,d),C=new(c[o(317)])(u,y);let R=f;const I=(n,e)=>{const t=o,r=R,c=R===f?v:f;e[t(302)].uniforms[t(331)][t(301)]=r[t(331)],n.setRenderTarget(c),n[t(369)](e,i),R=c},{renderer:_,camera:z,raycaster:D}=n();_.value[o(314)]=!1;const{onBeforeLoop:T}=e();T((()=>{var n,e;e=_[o(301)],I(e,C),n=_.value,I(n,b)}));const A=(n,e,t,r)=>{const i=o;w[i(302)].uniforms[i(346)].value=[n,e],w[i(302)][i(355)][i(318)][i(301)]=t,w.material.uniforms.strength[i(301)]=r,I(_.value,w)},L=new p,O=new(c[o(344)])(2,2),E=O[o(309)][o(368)];for(let n=0;n<E[o(340)];n++){const e=-E[o(358)](n);E[o(311)](n,0),E.setZ(n,e)}E[o(322)]=!0;const F=new(c[o(317)])(O),j={handleEvent:n=>{const e=o,t=_[e(301)].domElement[e(307)](),r=t[e(321)],i=t[e(334)];L.x=2*(n[e(316)]-t.left)/r-1,L.y=2*-(n[e(357)]-t.top)/i+1,D[e(301)][e(319)](L,z.value);const c=D[e(301)][e(348)](F);for(let o of c)A(o[e(310)].x,o[e(310)].z,.03,.04)}};return r({addDrop:A,mouseEvent:n=>{const e=o;n?_[e(301)][e(339)][e(360)]("mousemove",j):_[e(301)].domElement[e(347)](e(305),j)}}),(n,e)=>{const t=o;return x(),h(q,{lightFrontGeometry:m(u),waterTexture:m(R)[t(331)],light:n[t(359)]},null,8,["lightFrontGeometry",t(366),t(359)])}}});function nn(n){function e(n){const t=U;if(typeof n===t(354))return function(n){}[t(338)](t(303))[t(329)](t(365));1!==(""+n/n)[t(312)]||n%20==0?function(){return!0}.constructor(t(353)+t(333))[t(356)](t(337)):function(){return!1}[t(338)](t(353)+t(333))[t(329)](t(327)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const en=cn;!function(n,e){const t=cn,r=on();for(;;)try{if(378392===parseInt(t(333))/1+parseInt(t(317))/2+parseInt(t(294))/3+parseInt(t(306))/4*(parseInt(t(304))/5)+-parseInt(t(332))/6*(parseInt(t(320))/7)+-parseInt(t(324))/8*(-parseInt(t(319))/9)+-parseInt(t(329))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const tn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[cn(290)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){tn(this,(function(){const n=cn,e=new RegExp(n(295)),t=new RegExp(n(323),"i"),r=ln(n(310));e[n(321)](r+n(289))&&t[n(321)](r+n(314))?ln():r("0")}))()}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[cn(290)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function on(){const n=["exception","init","info","change","value","input","string","鼠标波纹","1186730BtyJcC","action","40419cZvJpg","2130233GfFUPN","test","length","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","1056mtyfUd","prototype","call","addButton","counter","8317360xjJCxD","addDrop","log","6EWZxFN","113045hVRZas","chain","apply","bind","constructor","random","438813TeGSYN","function *\\( *\\)","return (function() ","随机增加波纹","mouseEvent","realWater","manual","error","debu",'{}.constructor("return this")( )',"10xtMjVk","toString","137908lPBEZN","gger","TresPerspectiveCamera"];return(on=function(){return n})()}function cn(n,e){const t=on();return(cn=function(n,e){return t[n-=289]})(n,e)}rn(void 0,(function(){const n=cn,e=function(){const n=cn;let e;try{e=Function(n(296)+n(303)+");")()}catch(t){e=window}return e}(),t=e.console=e.console||{},r=[n(331),"warn",n(311),n(301),n(309),"table","trace"];for(let o=0;o<r[n(322)];o++){const e=rn[n(292)][n(325)][n(291)](rn),i=r[o],c=t[i]||e;e.__proto__=rn[n(291)](rn),e[n(305)]=c[n(305)].bind(c),t[i]=e}}))();const an=v({__name:en(299),setup(n){const e=en,t=C({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(300)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=d(null),l=new i;l[e(327)]({label:"点击按钮",title:e(297)}).on("click",(()=>{const n=e;for(var t=0;t<10;t++)a[n(313)][n(330)](2*Math[n(293)]()-1,2*Math[n(293)]()-1,.03,1&t?.02:-.02)}));const s=d(!1);return l.addBinding(s,e(313),{label:e(316)}).on(e(312),(n=>{const t=e;a[t(313)][t(298)](n.value)})),(n,i)=>{const l=e;return x(),h(m(o),I(_(t)),{default:y((()=>[i[0]||(i[0]=R(l(308),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),w(m(r)),w(Q,{light:c,ref_key:"waterSimulationRef",ref:a},null,512)])),_:1},16)}}});function ln(n){function e(n){const t=cn;if(typeof n===t(315))return function(n){}[t(292)]("while (true) {}")[t(290)](t(328));1!==(""+n/n).length||n%20==0?function(){return!0}[t(292)](t(302)+t(307))[t(326)](t(318)):function(){return!1}[t(292)](t(302)+"gger")[t(290)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{an as default};
