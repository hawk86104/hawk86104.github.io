import{importShared as e}from"./3d-tiles-renderer.de6b_qgz1767149344623.js";import{rz as t,_l as r,Fs as o,no as a,sz as n}from"./index.Btae5S5d1767149344623.js";import{useFBO as i,useTexture as l}from"./customShaderMaterial.vue_vue_type_script_setup_true_lang.C_pYeFAB1767149344623.js";import"./index.vue_vue_type_script_setup_true_lang.C9DbtXj-1767149344623.js";import{getcenterPoint as s,loadGeojson as u}from"./utils.CDk3Ydqj1767149344623.js";import{lonLatToUtm as d}from"./TerrainMeshProvider.CLjD1uZ_1767149344623.js";import{useGLTF as f}from"./index.zGefaP3R1767149344623.js";const{defineComponent:p}=await e("vue"),{createElementVNode:c,unref:v,openBlock:h,createElementBlock:m}=await e("vue"),g=["scale"],y={renderOrder:2200},w=["args"],C=["side","map","color","opacity"],T=["position"],x=["args"],b=["side","map","color","opacity"],_=await e("three"),{ref:M,watch:N}=await e("vue"),S=p({__name:"diffuseCircle",props:{radius:{default:100},ballColor:{default:"#ffff00"},wallColor:{default:"#ffffff"},speed:{default:1}},setup(e){const o=e,{textures:a,isLoading:n}=t(["./plugins/digitalCity/image/diffuseCircle1.png","./plugins/digitalCity/image/diffuseCircle2.png"]);N([a,n],([e,t])=>{e&&!t&&e[1].offset.set(.5,.5)});const i=M(0),l=M(1),{onBeforeRender:s}=r();return s(({delta:e})=>{i.value>1&&(i.value=0),i.value+=e*o.speed,l.value=1.4-i.value}),(e,t)=>(h(),m("TresGroup",{scale:i.value},[c("TresMesh",y,[c("TresSphereGeometry",{args:[o.radius,64,64,0,2*Math.PI,0,Math.PI/2]},null,8,w),c("TresMeshBasicMaterial",{side:_.DoubleSide,transparent:"",map:v(a)[0],color:e.ballColor,opacity:l.value},null,8,C)]),c("TresMesh",{renderOrder:2201,position:[0,.3*o.radius,0]},[c("TresCylinderGeometry",{args:[1.02*o.radius,1.02*o.radius,.6*o.radius,32,1,!0],openEnded:!0},null,8,x),c("TresMeshBasicMaterial",{side:_.DoubleSide,transparent:"",map:v(a)[1],color:e.wallColor,opacity:l.value},null,8,b)],8,T)],8,g))}}),{defineComponent:B}=await e("vue"),{createElementVNode:P,normalizeProps:W,guardReactiveProps:D,openBlock:k,createElementBlock:z}=await e("vue"),R={renderOrder:2200},E=["args"],{toRaw:U,watch:G}=await e("vue"),F=await e("three"),V=B({__name:"depthBufferDiffuse",props:{radius:{default:100},shieldColor:{default:"#ffff00"},rimColor:{default:"#ffffff"},threshold:{default:.005}},setup(e){const t=e,{sizes:a,camera:n}=o(),l=a.aspectRatio.value,s=a.width.value,u=a.height.value,d=i({height:s*l,width:u*l,depth:!0,isLoop:!0}),f={blending:F.NormalBlending,transparent:!0,depthWrite:!1,depthTest:!0,side:F.DoubleSide,vertexShader:"\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n        void main() {\n            vUv = uv;\n            vec4 worldPos = modelMatrix * vec4(position, 1.0);\n            vec4 modelNormal = modelMatrix * vec4(normal, 0.0);\n            vec4 mvPosition = viewMatrix * worldPos;\n            gl_Position = projectionMatrix * mvPosition;\n            vNormal = modelNormal.xyz;\n            vPosition = worldPos.xyz;\n        }\n    ",fragmentShader:"\n        uniform sampler2D uDepthTexture; \n        uniform vec2 uResolution;\n        uniform float uNear;\n        uniform float uFar;\n        uniform float uThreshold;\n        uniform vec3 uShieldColor;\n        uniform vec3 uRimColor;\n\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n\n        #include <packing>\n\n        float LinearizeDepth(float depth) {\n            float zNdc = 2.0 * depth - 1.0;\n            float zEye = (2.0 * uFar * uNear) / ((uFar + uNear) - zNdc * (uFar - uNear));\n            float linearDepth = (zEye - uNear) / (uFar - uNear);\n            return linearDepth;\n        }\n\n        void main() {\n            vec3 normal = normalize(vNormal);\n            if(gl_FrontFacing) {\n                normal *= -1.0;\n            }\n\n            vec3 viewDirection = normalize(cameraPosition - vPosition);\n            float fresnel = 1. + dot(normal, viewDirection);\n            fresnel = pow(fresnel, 4.0);\n\n            vec2 worldCoords = gl_FragCoord.xy/uResolution;\n\n            float sceneDepth = LinearizeDepth(texture2D(uDepthTexture, worldCoords).r);\n            float bubbleDepth = LinearizeDepth(gl_FragCoord.z);\n\n            float difference = abs(sceneDepth - bubbleDepth);\n            float normalizedDistance = clamp(difference / uThreshold, 0.0, 1.0);\n            vec4 intersection = mix(vec4(1.0), vec4(0.0), normalizedDistance);\n            intersection.rgb *= uRimColor;\n\n            vec4 color = vec4(uShieldColor, 0.3);\n            gl_FragColor = color + intersection + vec4(uRimColor, 1.0) * fresnel;\n        }\n    ",uniforms:{uDepthTexture:{value:U(d?.value?.depthTexture)},uResolution:{value:new F.Vector2(s,u)},uNear:{value:n.value?.near??1},uFar:{value:n.value?.far??1e4},uThreshold:{value:t.threshold},uShieldColor:{value:new F.Color(t.shieldColor)},uRimColor:{value:new F.Color(t.rimColor)}}},{onRender:p}=r();return p(()=>{}),G(()=>[t.rimColor,t.shieldColor,t.threshold],([e,t,r])=>{f.uniforms.uRimColor.value.setStyle(e),f.uniforms.uShieldColor.value.setStyle(t),f.uniforms.uThreshold.value=r}),(e,r)=>(k(),z("TresMesh",R,[P("TresSphereGeometry",{args:[t.radius,64,64]},null,8,E),P("TresShaderMaterial",W(D(f)),null,16)]))}}),{withAsyncContext:j,defineComponent:X}=await e("vue"),{unref:q,openBlock:L,createBlock:A}=await e("vue"),{watch:I}=await e("vue");await e("three");const{defineComponent:O}=await e("vue"),{openBlock:$,createElementBlock:Y,createCommentVNode:J}=await e("vue"),{watch:Z,watchEffect:H,toRaw:K,ref:Q}=await e("vue");await e("three");const{defineComponent:ee}=await e("vue"),{createElementVNode:te,normalizeProps:re,guardReactiveProps:oe,openBlock:ae,createElementBlock:ne}=await e("vue"),ie={renderOrder:9999},le=["rotation"],se=["args"],ue=["rotation"],de=["args"],fe=await e("three"),{watchEffect:pe}=await e("vue"),ce=ee({__name:"rectangleGlow",props:{w:{default:100},h:{default:100},pColor:{default:"#ffff00"},gradientWidth:{default:.99},glowWidth:{default:.99},nNumber:{default:8},lineWidth:{default:2},lColor:{default:"#ffff00"}},setup(e){const t=e,r={vertexShader:"\n \t\tvarying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    varying vec2 vUv;\n\t\tuniform vec3 color;\n\t\tuniform float gradientWidth;\n\t\tuniform float glowWidth;\n\t\tuniform float nNumber;\n\n    void main() {\n \t\t\tfloat distX = abs(vUv.x - 0.5) / 0.5;\n      float distY = abs(vUv.y - 0.5) / 0.5;\n\n      // 使用 Minkowski 距离，平滑矩形感 + 中心无交叉线 + 对角线也平滑\n      float dist = pow(pow(distX, nNumber) + pow(distY, nNumber), 1.0 / nNumber);\n\n      float cutoff = 1.0 - gradientWidth;\n  \t\tfloat alpha = smoothstep(cutoff, cutoff + glowWidth, dist);\n\n      gl_FragColor = vec4(color, alpha);\n    }\n  ",transparent:!0,side:fe.DoubleSide,depthWrite:!1,depthTest:!0,uniforms:{color:{type:"uvs",value:new fe.Color(t.pColor)},gradientWidth:{type:"f",value:t.gradientWidth},glowWidth:{type:"f",value:t.glowWidth},nNumber:{type:"f",value:t.nNumber}}},o={transparent:!0,side:fe.DoubleSide,depthWrite:!1,depthTest:!0,uniforms:{borderWidth:{value:t.lineWidth},borderColor:{value:new fe.Color(t.lColor)},size:{value:new fe.Vector2(t.w,t.h)}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    uniform float borderWidth;\n    uniform vec3 borderColor;\n    varying vec2 vUv;\n\t\tuniform vec2 size;\n\n    void main() {\n\t\t \tfloat borderX = borderWidth / size.x;\n  \t\tfloat borderY = borderWidth / size.y;\n\n      float left   = step(vUv.x, borderX);\n      float right  = step(1.0 - borderX, vUv.x);\n      float bottom = step(vUv.y, borderY);\n      float top    = step(1.0 - borderY, vUv.y);\n\n      float edge = max(max(left, right), max(bottom, top)); // 只保留边缘线\n      float alpha = edge;\n\n      gl_FragColor = vec4(borderColor, alpha);\n    }\n  "};return pe(()=>{r.uniforms.color.value=new fe.Color(t.pColor),r.uniforms.gradientWidth.value=t.gradientWidth,r.uniforms.glowWidth.value=t.glowWidth,r.uniforms.nNumber.value=t.nNumber,o.uniforms.borderColor.value=new fe.Color(t.lColor),o.uniforms.borderWidth.value=t.lineWidth,o.uniforms.size.value.set(t.w,t.h)}),(e,t)=>(ae(),ne("TresGroup",ie,[te("TresMesh",{rotation:[Math.PI/2,0,0]},[te("TresPlaneGeometry",{args:[e.w,e.h]},null,8,se),te("TresShaderMaterial",re(oe(r)),null,16)],8,le),te("TresMesh",{rotation:[Math.PI/2,0,0]},[te("TresPlaneGeometry",{args:[e.w+e.lineWidth,e.h+e.lineWidth]},null,8,de),te("TresShaderMaterial",re(oe(o)),null,16)],8,ue)]))}}),{defineComponent:ve}=await e("vue"),{unref:he,createElementVNode:me,normalizeProps:ge,guardReactiveProps:ye,openBlock:we,createElementBlock:Ce}=await e("vue"),Te=["position","uv"],xe=await e("three"),{watchEffect:be,ref:_e,watch:Me}=await e("vue"),Ne=ve({__name:"wave",props:{positionSrc:{default:[{x:0,y:0},{x:10,y:10}]},color:{default:"#ffff00"},opacity:{default:.8},height:{default:100},frequencyNum:{default:8},speed:{default:1}},setup(e){const t=e,o=_e(),a={side:xe.DoubleSide,transparent:!0,depthWrite:!1,depthTest:!0,vertexShader:"\nvarying vec2 vUv; \nvoid main(){\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n}\n",fragmentShader:"\n\tuniform float uTime;\n\tvarying vec2 vUv;\n\t#define PI 3.14159265\n  uniform float speed;\n  uniform vec3 color;\n  uniform float opacity;\n  uniform float frequencyNum;\n\tvoid main(){\n\t\t\t\n\tfloat amplitude = 1.;\n\n\tfloat x = vUv.x;\n\tfloat y = sin(x * frequencyNum) ;\n\tfloat t = 0.01*(-uTime*130.0*speed);\n\ty += sin(x*frequencyNum*2.1 + t)*4.5;\n\ty += sin(x*frequencyNum*1.72 + t*1.121)*4.0;\n\ty += sin(x*frequencyNum*2.221 + t*0.437)*5.0;\n\ty += sin(x*frequencyNum*3.1122+ t*4.269)*2.5;\n\ty *= amplitude*0.06;\n\ty /= 3.;\n\ty += 0.55;\n\n\tfloat ap = step(vUv.y,y) * (y-vUv.y)/y;\n\n\tgl_FragColor = vec4(color,ap*opacity);\n}\n\t",uniforms:{uTime:{type:"pv2",value:0},color:{type:"uvs",value:new xe.Color(t.color)},opacity:{type:"pv2",value:t.opacity},frequencyNum:{type:"pv2",value:t.frequencyNum},speed:{type:"pv2",value:t.speed}}};let n=null,i=null;function l(e=[],t){const r=[],o=[];for(let a=0,n=r.length,i=o.length;a<e.length-1;a++){let l=1,s=e[a],u=e[a+1];r[n++]=s.x,r[n++]=0,r[n++]=s.y,o[i++]=0,o[i++]=0,r[n++]=u.x,r[n++]=0,r[n++]=u.y,o[i++]=1,o[i++]=0,r[n++]=s.x,r[n++]=t,r[n++]=s.y,o[i++]=0,o[i++]=l,r[n++]=s.x,r[n++]=t,r[n++]=s.y,o[i++]=0,o[i++]=l,r[n++]=u.x,r[n++]=0,r[n++]=u.y,o[i++]=1,o[i++]=0,r[n++]=u.x,r[n++]=t,r[n++]=u.y,o[i++]=1,o[i++]=l}n=new Float32Array(r),i=new Float32Array(o)}const{centerPoint:u,points:d}=s(t.positionSrc);l(d,t.height);const{onBeforeRender:f}=r();return f(({delta:e})=>{a.uniforms.uTime.value+=e}),be(()=>{t.color&&(a.uniforms.color.value=new xe.Color(t.color)),t.opacity&&(a.uniforms.opacity.value=t.opacity),t.frequencyNum&&(a.uniforms.frequencyNum.value=t.frequencyNum),t.speed&&(a.uniforms.speed.value=t.speed),o.value&&o.value.position.set(u.x,o.value.position.y,u.y)}),Me(()=>t.height,e=>{l(d,t.height),o.value&&o.value.position.set(u.x,o.value.position.y,u.y)}),(e,t)=>(we(),Ce("TresMesh",{renderOrder:2200,ref_key:"tresMeshRef",ref:o},[me("TresBufferGeometry",{position:[he(n),3],uv:[he(i),2]},null,8,Te),me("TresShaderMaterial",ge(ye(a)),null,16)],512))}}),{withAsyncContext:Se,defineComponent:Be}=await e("vue"),{unref:Pe,renderList:We,Fragment:De,openBlock:ke,createElementBlock:ze,createElementVNode:Re}=await e("vue"),Ee=["args"],Ue=["map","side","color"],{watch:Ge}=await e("vue"),{CatmullRomCurve3:Fe,Vector3:Ve,RepeatWrapping:je,DoubleSide:Xe}=await e("three"),qe=Be({__name:"roadLightByLonLat",props:{geoJson:{},color:{default:"#ffff00"},radius:{default:2},speed:{default:1}},async setup(e){let t,o;const n=e,{state:i}=a("./plugins/digitalCity/image/line.png");Ge(i,e=>{e&&(e.needsUpdate=!0,e.wrapS=e.wrapT=je,e.repeat.set(1,1))});const l=([t,o]=Se(()=>u(n.geoJson)),t=await t,o(),t);let s=[];for(let r=0;r<l.length;r++){const e=l[r],t=[];e.geometry.coordinates.forEach(e=>{const r=d(e[0],e[1],50);t.push(new Ve(r[0],0,-r[1]))});let o=n.color;o="primary"===e.properties.highway?"#7eff10":"tertiary"===e.properties.highway?"#0eeeee":"secondary"===e.properties.highway?"#ffffff":"#ff0ffe",s.push({cr3:new Fe(t),color:o})}const{onBeforeRender:f}=r();return f(()=>{i.value&&(i.value.offset.x-=Math.random()/20*n.speed)}),(e,t)=>(ke(),ze("TresGroup",null,[(ke(!0),ze(De,null,We(Pe(s),(e,t)=>(ke(),ze("TresMesh",{key:t,renderOrder:3e3},[Re("TresTubeGeometry",{args:[e.cr3,64,n.radius,20,!1]},null,8,Ee),Re("TresMeshBasicMaterial",{map:Pe(i),side:Pe(Xe),transparent:!0,color:e.color},null,8,Ue)]))),128))]))}}),{defineComponent:Le}=await e("vue"),{createElementVNode:Ae,unref:Ie,withCtx:Oe,createVNode:$e,openBlock:Ye,createElementBlock:Je}=await e("vue"),Ze=["rotateX"],He=["rotateX","position"],Ke=["args"],Qe=["map","depthTest","side","color"],et=["rotateX","position"],tt=["args"],rt=["map","depthTest","side","color"],{ref:ot}=await e("vue"),at=await e("three"),nt=Le({__name:"coneAnchorMeshA",props:{height:{default:40},color:{default:"#b0ffff"},occlusion:{type:Boolean,default:!0},speed:{default:.05}},setup(e){const t=e,o=ot(),{onBeforeRender:a}=r();return a(()=>{o.value?.rotateZ(t.speed)}),(e,t)=>(Ye(),Je("TresGroup",{rotateX:-Math.PI/2,ref_key:"coneGroup",ref:o,renderOrder:1e4},[$e(Ie(n),{path:"./plugins/digitalCity/image/midGradient.png"},{default:Oe(({state:t})=>[Ae("TresMesh",{rotateX:Math.PI/2,position:[0,0,1.25*e.height],"scale-y":.5},[Ae("TresConeGeometry",{args:[15,e.height,4,1,!0]},null,8,Ke),Ae("TresMeshLambertMaterial",{map:t,transparent:!0,depthTest:e.occlusion,side:at.DoubleSide,color:e.color,depthWrite:!0},null,8,Qe)],8,He),Ae("TresMesh",{rotateX:-Math.PI/2,position:[0,0,e.height/2]},[Ae("TresConeGeometry",{args:[15,e.height,4,1,!0]},null,8,tt),Ae("TresMeshLambertMaterial",{map:t,transparent:!0,depthTest:e.occlusion,side:at.DoubleSide,color:e.color,depthWrite:!0},null,8,rt)],8,et)]),_:1})],8,Ze))}}),{withAsyncContext:it,defineComponent:lt}=await e("vue"),{unref:st,createElementVNode:ut,openBlock:dt,createElementBlock:ft}=await e("vue"),pt=["rotateX"],ct=["object"],vt=["args"],ht=["color","depthTest","map"],{ref:mt,watch:gt}=await e("vue"),yt=await e("three"),wt=lt({__name:"coneAnchorMeshB",props:{anchorColor:{default:"#b0ffff"},rotateSpeed:{default:.05},depthTest:{type:Boolean,default:!0},floorSize:{default:12},floorColor:{default:"#b0ffff"},floorSpeed:{default:.6}},async setup(e){let t,o;const a=e,{scene:n}=([t,o]=it(()=>f("./plugins/digitalCity/model/coneAnchorB.glb")),t=await t,o(),t),i=n?.clone(),s=i.children[0].material.clone();s.color.set(a.anchorColor),s.metalness=0,s.roughness=.5,s.transparent=!0,s.opacity=1,s.depthTest=a.depthTest,i.children[0].renderOrder=0,i.children[0].material=s;const u=([t,o]=it(()=>l("./plugins/digitalCity/image/waveCircle.png")),t=await t,o(),t),{width:d,height:p}=u.image;u.wrapS=u.wrapT=yt.RepeatWrapping,u.repeat.set(1/(d/p),1),gt(()=>[a.anchorColor,a.depthTest],([e,t])=>{s.color.set(e),s.depthTest=t});const c=mt(null),{onRender:v}=r();let h=0;return v(()=>{c.value?.children[0].rotateZ(a.rotateSpeed),u&&(h+=a.floorSpeed,u.offset.x=Math.floor(h)/(u.image.width/u.image.height))}),(e,t)=>(dt(),ft("TresGroup",null,[ut("TresGroup",{rotateX:-Math.PI/2,ref_key:"coneGroup",ref:c},[ut("primitive",{object:st(i)},null,8,ct),ut("TresMesh",null,[ut("TresCircleGeometry",{args:[e.floorSize,32]},null,8,vt),ut("TresMeshStandardMaterial",{color:e.floorColor,metalness:0,roughness:.6,transparent:"",opacity:.8,depthTest:a.depthTest,depthWrite:!1,map:st(u)},null,8,ht)])],8,pt)]))}});export{nt as _sfc_main,wt as _sfc_main$1,V as _sfc_main$2,S as _sfc_main$3,Ne as _sfc_main$4,ce as _sfc_main$5,qe as _sfc_main$6};
