import{a0 as n,_ as t,bO as e}from"./three.FyUEtfsR1741658416045.js";import{e as o}from"./@tresjs.W3PFJhMo1741658416045.js";import{g as r}from"./utils.2o1PLPEO1741658416045.js";import{d as i,b as s,a2 as a,w as c,o as u,H as l,N as f,u as p,aj as v,ak as m}from"./@vue.NRI7TcgI1741658416045.js";const d=w;!function(n,t){const e=w,o=h();for(;;)try{if(693548===parseInt(e(418))/1+parseInt(e(437))/2*(-parseInt(e(419))/3)+-parseInt(e(411))/4+parseInt(e(404))/5*(parseInt(e(455))/6)+parseInt(e(429))/7+-parseInt(e(406))/8*(parseInt(e(436))/9)+parseInt(e(446))/10*(parseInt(e(403))/11))break;o.push(o.shift())}catch(r){o.push(o.shift())}}();const y=function(){let n=!0;return function(t,e){const o=n?function(){if(e){const n=e.apply(t,arguments);return e=null,n}}:function(){};return n=!1,o}}();function h(){const n=["uniforms","ShaderChunk","\n}\n","color","\nprecision lowp float;\nprecision lowp int;\nuniform float time;\nuniform float opacity;\nuniform vec3 color;\nuniform float num;\nuniform float speed;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 fragColor = vec4(0.);\n\tfloat sin = sin((vUv.y - time * speed) * 10. * num);\n\tfloat high = 0.92;\n\tfloat medium = 0.4;\n\tif (sin > high) {\n\t\tfragColor = vec4(mix(vec3(.8, 1., 1.), color, (1. - sin) / (1. - high)), 1.);\n\t} else if(sin > medium) {\n\t\tfragColor = vec4(color, mix(1., 0., 1.-(sin - medium) / (high - medium)));\n\t} else {\n\t\tfragColor = vec4(color, 0.);\n\t}\n\tvec3 fade = mix(color, vec3(0., 0., 0.), vUv.y);\n\tfragColor = mix(fragColor, vec4(fade, 1.), 0.85);\n\tgl_FragColor = vec4(fragColor.rgb, fragColor.a * opacity * (1. - vUv.y));\n}\n","string","4240985UiYFbO","chain","counter","debu","value","prototype","log","243549HpujdV","38858bYiaOb","positionSrc","apply","__proto__","gger","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","#ffff00","speed","return (function() ","8008070LEZsFS","TresShaderMaterial","trace","stateObject","uvs","while (true) {}","test","length","warn","6skbiCU","num","set","call","exception","time","pv2","opacity","tresMeshRef","height","22DZYAiV","3777335DXyVRj","toString","408MREjgr","rippleMesh","constructor","\nvarying vec2 vUv;\nvoid main() {\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t","error","3158472Smbake","input","bind","init","action","console","Color","522069UIUJHd","96dJrxEU",'{}.constructor("return this")( )',"info","position"];return(h=function(){return n})()}!function(){y(this,(function(){const n=w,t=new RegExp("function *\\( *\\)"),e=new RegExp(n(442),"i"),o=b(n(414));t[n(452)](o+n(430))&&e[n(452)](o+n(412))?b():o("0")}))()}();const g=function(){let n=!0;return function(t,e){const o=n?function(){if(e){const n=e[w(439)](t,arguments);return e=null,n}}:function(){};return n=!1,o}}();g(void 0,(function(){const n=w;let t;try{t=Function(n(445)+n(420)+");")()}catch(r){t=window}const e=t[n(416)]=t[n(416)]||{},o=[n(435),n(454),n(421),n(410),n(397),"table",n(448)];for(let i=0;i<o[n(453)];i++){const t=g[n(408)][n(434)].bind(g),r=o[i],s=e[r]||t;t[n(440)]=g[n(413)](g),t[n(405)]=s[n(405)][n(413)](s),e[r]=t}}))();const x=["position","uv"];function w(n,t){const e=h();return(w=function(n,t){return e[n-=395]})(n,t)}const _=i({__name:d(407),props:{positionSrc:{default:[{x:0,y:0},{x:10,y:10}]},color:{default:d(443)},opacity:{default:.8},height:{default:100},num:{default:8},speed:{default:.15}},setup(i){const y=d,h=i,g=s(),w={side:n,transparent:!0,depthWrite:!1,depthTest:!0,vertexShader:"\nprecision lowp float;\nprecision lowp int;\n"+t[y(424)].fog_pars_vertex+y(409)+e.fog_vertex+y(425),fragmentShader:y(427),uniforms:{time:{type:y(399),value:0},color:{type:y(450),value:new(t[y(417)])(h[y(426)])},opacity:{type:y(399),value:h[y(400)]},num:{type:"pv2",value:h[y(456)]},speed:{type:y(399),value:h[y(444)]}}};let _=null,b=null;function C(n=[],t){const e=y,o=[],r=[];for(let i=0,s=o[e(453)],a=r[e(453)];i<n[e(453)]-1;i++){let e=1,c=n[i],u=n[i+1];o[s++]=c.x,o[s++]=0,o[s++]=c.y,r[a++]=0,r[a++]=0,o[s++]=u.x,o[s++]=0,o[s++]=u.y,r[a++]=1,r[a++]=0,o[s++]=c.x,o[s++]=t,o[s++]=c.y,r[a++]=0,r[a++]=e,o[s++]=c.x,o[s++]=t,o[s++]=c.y,r[a++]=0,r[a++]=e,o[s++]=u.x,o[s++]=0,o[s++]=u.y,r[a++]=1,r[a++]=0,o[s++]=u.x,o[s++]=t,o[s++]=u.y,r[a++]=1,r[a++]=e}_=new Float32Array(o),b=new Float32Array(r)}let{centerPoint:I,points:j}=r(h[y(438)]);C(j,h.height);const{onLoop:U}=o();return U((({delta:n})=>{const t=y;w[t(423)][t(398)][t(433)]+=n})),a((()=>{const n=y;h[n(426)]&&(w.uniforms[n(426)].value=new(t[n(417)])(h.color)),h[n(400)]&&(w[n(423)][n(400)][n(433)]=h[n(400)]),h[n(456)]&&(w[n(423)][n(456)].value=h[n(456)]),h[n(444)]&&(w.uniforms.speed.value=h[n(444)]),g.value&&g.value[n(422)][n(395)](I.x,g[n(433)][n(422)].y,I.y)})),c((()=>h[y(438)]),(n=>{const t=y,{centerPoint:e,points:o}=r(n);I=e,j=o,C(j,h[t(402)]),g[t(433)]&&g[t(433)][t(422)][t(395)](I.x,g[t(433)][t(422)].y,I.y)})),(n,t)=>{const e=y;return u(),l("TresMesh",{renderOrder:2200,ref_key:e(401),ref:g},[f("TresBufferGeometry",{position:[p(_),3],uv:[p(b),2]},null,8,x),f(e(447),v(m(w)),null,16)],512)}}});function b(n){function t(n){const e=w;if(typeof n===e(428))return function(n){}[e(408)](e(451))[e(439)](e(431));1!==(""+n/n)[e(453)]||n%20==0?function(){return!0}[e(408)](e(432)+e(441))[e(396)](e(415)):function(){return!1}[e(408)](e(432)+e(441)).apply(e(449)),t(++n)}try{if(n)return t;t(0)}catch(e){}}export{_};
