import{F as e,_ as t,K as a}from"./@tresjs.CC-VM6g11766394917683.js";import"./lamina.1nhejLAH1766394917683.js";import"./three-custom-shader-material.-uIL0IHF1766394917683.js";import"./shapeConfigurator.vue_vue_type_style_index_1_scoped_abbf0cc1_lang.CXJ66YiI1766394917683.js";import"./Resource.CDqX8L841766394917683.js";import{_ as o}from"./skyBoxDmesh.vue_vue_type_script_setup_true_lang.DiBrWkex1766394917683.js";import{P as r}from"./tweakpane.CqZAnw7f1766394917683.js";import{s as n,_ as s}from"./material.vue_vue_type_script_setup_true_lang.Bjy7iE5b1766394917683.js";import{u as i}from"./utils.C2DuXFZ81766394917683.js";import{d as l,ac as u,w as p,G as d,o as c,u as m,I as g,b as v,h as f,m as w,ah as A,e as y,a3 as P,r as x,g as b,a9 as h,aa as _}from"./@vue.BxPWGdWw1766394917683.js";import{i as j,k as D,bK as F,j as C,V as M,dw as z,cV as S,cW as B,d as E,cX as k,a0 as T}from"./three.F31Lz30M1766394917683.js";import"./postprocessing.DnKKyAPS1766394917683.js";import"./@vueuse.PX2Ih8Bm1766394917683.js";import"./glsl-tokenizer.CLaVfVUj1766394917683.js";import"./@amap.fjyZdsU91766394917683.js";import"./glsl-token-descope.DJrZcb6s1766394917683.js";import"./glsl-token-depth.Duvdnvlt1766394917683.js";import"./glsl-token-scope.BdCfdvWe1766394917683.js";import"./glsl-token-properties.DKXemF9b1766394917683.js";import"./glsl-token-assignments.Ctx_yUgS1766394917683.js";import"./glsl-token-string._BF2vlIp1766394917683.js";import"./glsl-token-functions.D-i-0Sqz1766394917683.js";import"./object-hash.BlsCJiuO1766394917683.js";import"./jszip.CCQtYoU41766394917683.js";const q=["geometry"],K=["blending"],N=l({__name:"particlesPoints",props:{geo:{default:new j},uEdge:{default:6},uFreq:{default:.41},uAmp:{default:20},uProgress:{default:-2},uColor:{default:"#4d9bff"},uPointSize:{default:200},particleData:{default:{particleSpeedFactor:.02,velocityFactor:{x:2.5,y:2},waveAmplitude:0}}},async setup(a){let o,r;const s=a,l=s.geo.clone(),v=([o,r]=u(()=>i("./plugins/industry4/image/particle.png")),o=await o,r(),o);let f,w,A,y,P,x,b=l.attributes.position.count;!function(e){b=e.attributes.position.count,f=new Float32Array(b),w=new Float32Array(e.getAttribute("position").array),A=new Float32Array(e.getAttribute("position").array),y=new Float32Array(3*b),P=new Float32Array(b),x=new Float32Array(b);for(let t=0;t<b;t++){let e=3*t+0,a=3*t+1,o=3*t+2;f[t]=5.5*Math.random()+1.5,y[e]=.5*Math.random()+.5,y[a]=.5*Math.random()+.5,y[o]=.1*Math.random(),P[t]=.001,x[t]=Math.random()*Math.PI*2}e.setAttribute("aOffset",new C(f,1)),e.setAttribute("aCurrentPos",new C(A,3)),e.setAttribute("aVelocity",new C(y,3)),e.setAttribute("aDist",new C(P,1)),e.setAttribute("aAngle",new C(x,1))}(l);const{renderer:h}=e(),_={uTexture:{value:v},uPixelDensity:{value:h.getPixelRatio()},uProgress:{value:s.uProgress},uEdge:{value:s.uEdge},uAmp:{value:s.uAmp},uFreq:{value:s.uFreq},uBaseSize:{value:s.uPointSize},uColor:{value:new D(s.uColor)}},j=`\n    ${n}\n    uniform float uPixelDensity;\n    uniform float uBaseSize;\n    uniform float uFreq;\n    uniform float uAmp;\n    uniform float uEdge;\n    uniform float uProgress;\n\n    varying float vNoise;\n    varying float vAngle;\n\n    attribute vec3 aCurrentPos;\n    attribute float aDist;\n    attribute float aAngle;\n\n    void main() {\n        vec3 pos = position;\n\n        float noise = snoise(pos * uFreq) * uAmp;\n        vNoise =noise;\n\n        vAngle = aAngle;\n\n        if( vNoise > uProgress-2.0 && vNoise < uProgress + uEdge+2.0){\n            pos = aCurrentPos;\n        }\n\n        vec4 modelPosition = modelMatrix * vec4(pos, 1.0);\n        vec4 viewPosition = viewMatrix * modelPosition;\n        vec4 projectedPosition = projectionMatrix * viewPosition;\n        gl_Position = projectedPosition;\n\n        float size = uBaseSize * uPixelDensity;\n        size = size  / (aDist + 1.0);\n        gl_PointSize = size / -viewPosition.z;\n}\n`;function z(e){let t=y[3*e+0],a=y[3*e+1],o=y[3*e+2];t*=s.particleData.velocityFactor.x,a*=s.particleData.velocityFactor.y;let{xwave:r,ywave:n}=function(e){const t=A[3*e+0],a=A[3*e+1];let o=Math.sin(2*a)*(.8+s.particleData.waveAmplitude),r=Math.sin(2*t)*(.6+s.particleData.waveAmplitude),n=Math.sin(5*a)*(.2+s.particleData.waveAmplitude),i=Math.sin(1*t)*(.9+s.particleData.waveAmplitude),l=Math.sin(8*a)*(.8+s.particleData.waveAmplitude),u=Math.sin(5*t)*(.6+s.particleData.waveAmplitude);return{xwave:o+n+l+Math.sin(3*a)*(.8+s.particleData.waveAmplitude),ywave:r+i+u+Math.sin(7*t)*(.6+s.particleData.waveAmplitude)}}(e);return t+=r,a+=n,t*=Math.abs(s.particleData.particleSpeedFactor),a*=Math.abs(s.particleData.particleSpeedFactor),o*=Math.abs(s.particleData.particleSpeedFactor),{vx:t,vy:a,vz:o}}const{onBeforeRender:S}=t();return S(()=>{!function(){for(let e=0;e<b;e++){let t=3*e+0,a=3*e+1,o=3*e+2,{vx:r,vy:n,vz:s}=z(e);A[t]+=r,A[a]+=n,A[o]+=s;const i=new M(w[t],w[a],w[o]),l=new M(A[t],A[a],A[o]),u=i.distanceTo(l);P[e]=u,x[e]+=.01,u>f[e]&&(A[t]=w[t],A[a]=w[a],A[o]=w[o])}l.setAttribute("aOffset",new C(f,1)),l.setAttribute("aCurrentPos",new C(A,3)),l.setAttribute("aVelocity",new C(y,3)),l.setAttribute("aDist",new C(P,1)),l.setAttribute("aAngle",new C(x,1))}()}),p(()=>[s.uColor,s.uEdge,s.uFreq,s.uAmp,s.uProgress,s.uPointSize],([e,t,a,o,r,n])=>{_.uColor.value.setStyle(e),_.uEdge.value=t,_.uFreq.value=a,_.uAmp.value=o,_.uProgress.value=r,_.uBaseSize.value=n}),(e,t)=>(c(),d("TresPoints",{geometry:m(l)},[g("TresShaderMaterial",{transparent:"",blending:F,uniforms:_,vertexShader:j,fragmentShader:"\n    uniform vec3 uColor;\n    uniform float uEdge;\n    uniform float uProgress;\n    uniform sampler2D uTexture;\n\n    varying float vNoise;\n    varying float vAngle;\n\n    void main(){\n        if( vNoise < uProgress ) discard;\n        if( vNoise > uProgress + uEdge) discard;\n\n        vec2 coord = gl_PointCoord;\n        coord = coord - 0.5; // get the coordinate from 0-1 ot -0.5 to 0.5\n        coord = coord * mat2(cos(vAngle),sin(vAngle) , -sin(vAngle), cos(vAngle)); // apply the rotation transformaion\n        coord = coord +  0.5; // reset the coordinate to 0-1  \n\n        vec4 texture = texture2D(uTexture,coord);\n\n        gl_FragColor = vec4(vec3(uColor.xyz * texture.xyz),1.0);\n    }\n"},null,8,K)],8,q))}}),R=["geometry"],$=l({__name:"torusKnot",setup(e){const t=new z(3,1,64,8,2,3);return(e,a)=>(c(),d("TresGroup",null,[g("TresMesh",{geometry:m(t)},[f(s,w({color:"#636363",metalness:2,roughness:0},e.$attrs),null,16)],8,R),(c(),v(A,null,{default:y(()=>[f(N,w({geo:m(t)},e.$attrs,{uColor:e.$attrs.uEdgeColor}),null,16,["geo","uColor"])]),_:1}))]))}}),V=l({__name:"bloomPass",setup(a){const{camera:o,renderer:r,scene:n,sizes:s}=e(),i=0,l=.216,u=.2;let p=null;P(()=>{s.width.value&&((e,t,a,o,r)=>{const n=new S(e,t),s=new B(new E(o,r),l,u,i);p=new k(a),p.addPass(n),p.addPass(s)})(n.value,o.value,r,s.width.value,s.height.value)});const{onBeforeRender:d}=t();return d(()=>{p&&p.render()}),(e,t)=>null}}),G=l({__name:"dissolveEffectPlus",setup(e){const t={clearColor:"#201919",windowSize:!0,toneMapping:T,toneMappingExposure:.8,renderMode:"manual"},n=x({uEdgeColor:"#ff784d",uEdge:6,uFreq:.41,uAmp:20,uProgress:-4.9,uPointSize:576,particleData:{particleSpeedFactor:.02,velocityFactor:{x:2.5,y:2},waveAmplitude:0}}),s=x({torusKnotColor:"#7a8c87"}),i=new r({title:"参数",expanded:!0});return i.addBinding(s,"torusKnotColor",{label:"torusKnotColor"}),i.addBinding(n,"uEdgeColor",{label:"边缘颜色"}),i.addBinding(n,"uEdge",{label:"边缘宽度",min:0,max:9,step:.01}),i.addBinding(n,"uFreq",{label:"密度",min:.002,max:2,step:.002}),i.addBinding(n,"uAmp",{label:"幅度",min:3,max:22,step:.01}),i.addBinding(n,"uProgress",{label:"进度",min:-25,max:20,step:.1}),i.addBinding(n,"uPointSize",{label:"粒子大小",min:10,max:800,step:5}),i.addBinding(n.particleData,"particleSpeedFactor",{label:"粒子速度",min:1e-4,max:.1,step:1e-4}),i.addBinding(n.particleData,"velocityFactor",{picker:"inline",label:"粒子飘逸方向",expanded:!0,x:{min:-10,max:10,step:.01},y:{min:-10,max:10,step:.01}}),i.addBinding(n.particleData,"waveAmplitude",{label:"粒子扰动幅度",min:0,max:5,step:.01}),(e,r)=>{const i=b("TresCanvas");return c(),v(i,h(_(t)),{default:y(()=>[r[0]||(r[0]=g("TresPerspectiveCamera",{position:[15,15,15],fov:45,near:.1,far:1e4,"look-at":[0,0,0]},null,-1)),f(m(a),{enableDamping:""}),f($,w(n,{color:s.torusKnotColor}),null,16,["color"]),(c(),v(A,null,{default:y(()=>[f(m(o),{texture:"https://opensource.cdn.icegl.cn/images/skyBox/workshop_blur.jpg"},null,8,["texture"])]),_:1})),f(V)]),_:1},16)}}});export{G as default};
