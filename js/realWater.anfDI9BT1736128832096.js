import{m as n,e,b as t,U as r,c as o}from"./@tresjs.pA0fT6uQ1736128832096.js";import{P as i}from"./tweakpane.yHWGBmom1736128832096.js";import{_ as c,a,aR as l,s,C as u,O as f,t as p,ay as v}from"./three.8H01GNxA1736128832096.js";import{d as g,a4 as d,b as x,o as h,f as m,u as y,g as w,j as b,al as I,r as R,J as C,aj as _,ak as M}from"./@vue.yG49nQHr1736128832096.js";import"./@vueuse.iB8cUOAP1736128832096.js";var z="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";!function(n,e){const t=L,r=A();for(;;)try{if(556757===-parseInt(t(391))/1+parseInt(t(353))/2*(parseInt(t(384))/3)+parseInt(t(383))/4*(-parseInt(t(368))/5)+-parseInt(t(346))/6*(-parseInt(t(397))/7)+parseInt(t(364))/8*(-parseInt(t(370))/9)+parseInt(t(381))/10*(parseInt(t(351))/11)+parseInt(t(357))/12)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const D=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[L(362)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){D(this,(function(){const n=L,e=new RegExp(n(393)),t=new RegExp(n(377),"i"),r=F("init");e[n(375)](r+n(387))&&t.test(r+n(385))?F():r("0")}))()}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function L(n,e){const t=A();return(L=function(n,e){return t[n-=346]})(n,e)}function A(){const n=["setIndex","chain","counter","bind","call","1008960DTxMsB","BufferGeometry","function *\\( *\\)","warn","water","Mesh","7TRVyZF","1469226AEtBAO","causticTex","exception","stateObject","render","19151qXJXcc","return (function() ","22bTbOrr","debu","info","toString","26828376TTjsfM","BufferAttribute","RawShaderMaterial","console","prototype","apply","error","16oCZSwZ","trace","table","position","72815vxRyPs","setAttribute","4762134nbPVBq","light","uniforms","string","length","test","value","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","constructor","waterTexture",'{}.constructor("return this")( )',"3070FFfVRE","FrontSide","116rCbKDB","8520sisUDK","input"];return(A=function(){return n})()}T(void 0,(function(){const n=L;let e;try{e=Function(n(352)+n(380)+");")()}catch(o){e=window}const t=e.console=e[n(360)]||{},r=["log",n(394),n(355),n(363),n(348),n(366),n(365)];for(let i=0;i<r[n(374)];i++){const e=T[n(378)][n(361)].bind(T),o=r[i],c=t[o]||e;e.__proto__=T[n(389)](T),e.toString=c[n(356)][n(389)](c),t[o]=e}}))();const O=g({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=L,o=t,i=new(c[r(392)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(369)](r(367),new a(l,3)),i[r(386)](new(c[r(358)])(s,1));const u=new(c[r(359)])({uniforms:{light:{value:o[r(371)]},tiles:{value:o.tiles},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(382)]}),f=new(c[r(396)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{((n,e)=>{const t=r;u[t(372)][t(395)][t(376)]=n,u[t(372)][t(347)][t(376)]=e,p[t(376)][t(350)](f,v[t(376)])})(o[r(379)],o.causticsTexture)})),(n,e)=>null}});function F(n){function e(n){const t=L;if(typeof n===t(373))return function(n){}.constructor("while (true) {}")[t(362)](t(388));1!==(""+n/n)[t(374)]||n%20==0?function(){return!0}[t(378)](t(354)+"gger")[t(390)]("action"):function(){return!1}.constructor(t(354)+"gger")[t(362)](t(349)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const S=E;!function(n,e){const t=E,r=W();for(;;)try{if(827193===-parseInt(t(367))/1*(-parseInt(t(343))/2)+parseInt(t(327))/3*(-parseInt(t(340))/4)+parseInt(t(353))/5+parseInt(t(322))/6*(parseInt(t(350))/7)+-parseInt(t(357))/8+parseInt(t(361))/9*(parseInt(t(320))/10)+-parseInt(t(344))/11*(parseInt(t(363))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[E(317)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function E(n,e){const t=W();return(E=function(n,e){return t[n-=311]})(n,e)}!function(){j(this,(function(){const n=E,e=new RegExp(n(315)),t=new RegExp(n(342),"i"),r=V("init");e[n(349)](r+"chain")&&t[n(349)](r+n(313))?V():r("0")}))()}();const P=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function W(){const n=["7474245kILAtb","error","causticsTexture","underwater","3535360ADozYe","info","constructor","table","1801593cDCQKw","while (true) {}","705576EOkhwE","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","value","prototype","5GkXjur","setPath","action","RawShaderMaterial","debu","toString","input","string","function *\\( *\\)","bind","apply","pos-y.jpg","side","20IdjQtt","setRenderTarget","1078374TRBmOG","waterTexture","load","FrontSide","exception","372891IqLesE","water",'{}.constructor("return this")( )',"BackSide","tiles","Color","render","pos-z.jpg","setClearColor","warn","console","white","clear","8KJooXp","Mesh","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","5632UYFDGV","275ZDfLmk","log","light","neg-z.jpg","uniforms","test","42ZRebZs","return (function() ","length"];return(W=function(){return n})()}P(void 0,(function(){const n=E;let e;try{e=Function(n(351)+n(329)+");")()}catch(o){e=window}const t=e[n(337)]=e[n(337)]||{},r=[n(345),n(336),n(358),n(354),n(326),n(360),"trace"];for(let i=0;i<r.length;i++){const e=P.constructor[n(366)].bind(P),o=r[i],c=t[o]||e;e.__proto__=P[n(316)](P),e[n(312)]=c[n(312)][n(316)](c),t[o]=e}}))();const k=g({__name:S(328),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=S;let i,a;const s=r,u=s.geometry,f=(new l)[o(368)](o(364))[o(324)](["pos-x.jpg","neg-x.jpg",o(318),"neg-y.jpg",o(334),o(347)]),p=([i,a]=d((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),v=new(c[o(370)])({uniforms:{light:{value:s[o(346)]},tiles:{value:p},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),g=new(c[o(341)])(u,v),w=x(null),b=new(c[o(332)])(o(338)),{renderer:I,camera:R}=n(),{onLoop:C}=e();return C((()=>{const n=o;I[n(365)][n(321)](null),I[n(365)][n(335)](b,1),I.value[n(339)](),v[n(348)].water[n(365)]=s[n(323)],v[n(348)].causticTex[n(365)]=s[n(355)],v[n(319)]=c[n(325)],v[n(348)][n(356)].value=!0,I.value[n(333)](g,R[n(365)]),v[n(319)]=c[n(330)],v[n(348)][n(356)][n(365)]=!1,I[n(365)][n(333)](g,R[n(365)])})),(n,e)=>{const t=o;return h(),m(O,{tiles:y(p),light:n[t(346)],waterTexture:n[t(323)],causticsTexture:n.causticsTexture,ref_key:"pooRef",ref:w},null,8,[t(331),"light",t(323),t(355)])}}});function V(n){function e(n){const t=E;if(typeof n===t(314))return function(n){}[t(359)](t(362))[t(317)]("counter");1!==(""+n/n)[t(352)]||n%20==0?function(){return!0}.constructor(t(311)+"gger").call(t(369)):function(){return!1}[t(359)](t(311)+"gger")[t(317)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}function H(n,e){const t=Q();return(H=function(n,e){return t[n-=230]})(n,e)}const Z=H;!function(n,e){const t=H,r=Q();for(;;)try{if(981291===parseInt(t(238))/1*(-parseInt(t(281))/2)+-parseInt(t(243))/3+-parseInt(t(277))/4*(-parseInt(t(230))/5)+parseInt(t(236))/6+parseInt(t(272))/7*(parseInt(t(275))/8)+-parseInt(t(264))/9+parseInt(t(235))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){B(this,(function(){const n=H,e=new RegExp(n(270)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=N(n(246));e.test(r+n(255))&&t[n(244)](r+n(232))?N():r("0")}))()}();const q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[H(276)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();q(void 0,(function(){const n=H,e=function(){const n=H;let e;try{e=Function(n(252)+n(240)+");")()}catch(t){e=window}return e}(),t=e[n(273)]=e[n(273)]||{},r=[n(253),n(268),n(259),n(247),n(245),n(267),n(263)];for(let o=0;o<r[n(233)];o++){const e=q.constructor.prototype.bind(q),i=r[o],c=t[i]||e;e.__proto__=q[n(265)](q),e.toString=c[n(258)][n(265)](c),t[i]=e}}))();const G=g({__name:Z(278),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=Z,o=t,i=new(c[r(266)])(0,1,1,0,0,2e3),a=new(c[r(271)])(2,2,200,200),l=new(c[r(262)])(1024,1024),f=new(c[r(250)])({uniforms:{light:{value:o[r(251)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new s(a,f),v=new u(r(257)),{renderer:g}=n(),{onBeforeLoop:d}=e();return d((()=>{const n=r;p[n(242)][n(269)][n(231)][n(234)]=o[n(260)],g[n(234)].setRenderTarget(l),g.value[n(261)](v,0),g[n(234)][n(239)](),g.value.render(p,i)})),(n,e)=>{const t=r;return h(),m(I,null,{default:w((()=>[b(k,{waterTexture:n[t(260)],causticsTexture:y(l)[t(280)],light:n[t(251)],geometry:y(a)},null,8,[t(260),t(249),t(251),"geometry"])])),_:1})}}});function N(n){function e(n){const t=H;if("string"==typeof n)return function(n){}[t(256)](t(274)).apply(t(237));1!==(""+n/n)[t(233)]||n%20==0?function(){return!0}[t(256)]("debu"+t(279))[t(241)](t(248)):function(){return!1}.constructor(t(254)+t(279)).apply("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}function Q(){const n=["exception","init","error","action","causticsTexture","ShaderMaterial","light","return (function() ","log","debu","chain","constructor","black","toString","info","waterTexture","setClearColor","WebGLRenderTarget","trace","8193240LfSlPV","bind","OrthographicCamera","table","warn","uniforms","function *\\( *\\)","PlaneGeometry","7Danldc","console","while (true) {}","562064xxCdaF","apply","94508NeQqsh","caustics","gger","texture","604yQrnUS","335qaKLtZ","water","input","length","value","3959180gcKxNL","9696492qxoJjb","counter","1403QdylJg","clear",'{}.constructor("return this")( )',"call","material","4049730JmRFTR","test"];return(Q=function(){return n})()}const $=J;!function(n,e){const t=J,r=X();for(;;)try{if(523967===-parseInt(t(385))/1+parseInt(t(375))/2*(-parseInt(t(365))/3)+parseInt(t(357))/4*(parseInt(t(398))/5)+parseInt(t(381))/6*(-parseInt(t(355))/7)+parseInt(t(348))/8*(-parseInt(t(353))/9)+parseInt(t(338))/10*(-parseInt(t(333))/11)+parseInt(t(386))/12*(parseInt(t(369))/13))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[J(367)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){K(this,(function(){const n=J,e=new RegExp(n(334)),t=new RegExp(n(342),"i"),r=nn(n(359));e[n(343)](r+"chain")&&t[n(343)](r+n(374))?nn():r("0")}))()}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function J(n,e){const t=X();return(J=function(n,e){return t[n-=330]})(n,e)}function X(){const n=["light","top","3310749HKbIom","intersectObject","1015QTXBIG","info","2028336yPIVSA","setFromCamera","init","clientX","while (true) {}","value","PlaneGeometry",'{}.constructor("return this")( )',"135jktxPp","waterTexture","apply","FloatType","104JgKQma","setY","exception","center","console","input","35850SPJvGE","uniforms","counter","trace","error","constructor","30318rWhygv","Vector2","getY","WebGLRenderTarget","1002120qnlCML","6339696VkvQQO","width","setRenderTarget","RawShaderMaterial","material","radius","table","domElement","warn","setZ","clientY","addEventListener","5nDeTHr","action","Mesh","count","waterSimulation","11rYqcPz","function *\\( *\\)","length","point","toString","9324290zKqzHB","stateObject","texture","debu","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","test","left","gger","getBoundingClientRect","prototype","16FUSPEi","needsUpdate","mousemove"];return(X=function(){return n})()}U(void 0,(function(){const n=J;let e;try{e=Function("return (function() "+n(364)+");")()}catch(o){e=window}const t=e.console=e[n(373)]||{},r=["log",n(394),n(356),n(379),n(371),n(392),n(378)];for(let i=0;i<r[n(335)];i++){const e=U[n(380)][n(347)].bind(U),o=r[i],c=t[o]||e;e.__proto__=U.bind(U),e[n(337)]=c[n(337)].bind(c),t[o]=e}}))();const Y=g({__name:$(332),props:{light:{}},setup(t,{expose:r}){const o=$,i=new f(0,1,1,0,0,2e3),a=new p(2,2),l=new(c[o(384)])(256,256,{type:c[o(368)]}),u=new(c[o(384)])(256,256,{type:c[o(368)]}),g=new(c[o(389)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),d=new v({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),x=new(c[o(389)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:z,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),w=new s(a,g),b=new(c[o(330)])(a,d),I=new s(a,x);let R=l;const C=(n,e)=>{const t=o,r=R,c=R===l?u:l;e[t(390)][t(376)][t(340)][t(362)]=r[t(340)],n[t(388)](c),n.render(e,i),R=c},{renderer:_,camera:M,raycaster:D}=n();_[o(362)].autoClear=!1;const{onBeforeLoop:T}=e();T((()=>{const n=o;var e,t;t=_[n(362)],C(t,I),e=_[n(362)],C(e,b)}));const L=(n,e,t,r)=>{const i=o;w[i(390)][i(376)][i(372)].value=[n,e],w[i(390)][i(376)][i(391)][i(362)]=t,w[i(390)][i(376)].strength[i(362)]=r,C(_[i(362)],w)},A=new(c[o(382)]),O=new(c[o(363)])(2,2),F=O.attributes.position;for(let n=0;n<F[o(331)];n++){const e=-F[o(383)](n);F[o(370)](n,0),F[o(395)](n,e)}F[o(349)]=!0;const S=new(c[o(330)])(O),j={handleEvent:n=>{const e=o,t=_[e(362)][e(393)][e(346)](),r=t[e(387)],i=t.height;A.x=2*(n[e(360)]-t[e(344)])/r-1,A.y=2*-(n[e(396)]-t[e(352)])/i+1,D[e(362)][e(358)](A,M[e(362)]);const c=D[e(362)][e(354)](S);for(let o of c)L(o.point.x,o[e(336)].z,.03,.04)}};return r({addDrop:L,mouseEvent:n=>{const e=o;n?_[e(362)][e(393)][e(397)](e(350),j):_[e(362)].domElement.removeEventListener(e(350),j)}}),(n,e)=>{const t=o;return h(),m(G,{lightFrontGeometry:y(a),waterTexture:y(R)[t(340)],light:n.light},null,8,["lightFrontGeometry",t(366),t(351)])}}});function nn(n){function e(n){const t=J;if("string"==typeof n)return function(n){}[t(380)](t(361)).apply(t(377));1!==(""+n/n)[t(335)]||n%20==0?function(){return!0}[t(380)](t(341)+"gger").call(t(399)):function(){return!1}[t(380)](t(341)+t(345))[t(367)](t(339)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function en(n,e){const t=an();return(en=function(n,e){return t[n-=157]})(n,e)}const tn=en;!function(n,e){const t=en,r=an();for(;;)try{if(682695===-parseInt(t(170))/1*(parseInt(t(173))/2)+parseInt(t(189))/3*(-parseInt(t(183))/4)+parseInt(t(178))/5*(parseInt(t(187))/6)+parseInt(t(165))/7*(-parseInt(t(180))/8)+parseInt(t(194))/9+-parseInt(t(176))/10*(parseInt(t(175))/11)+-parseInt(t(171))/12*(-parseInt(t(202))/13))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const rn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[en(169)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){rn(this,(function(){const n=en,e=new RegExp(n(205)),t=new RegExp(n(179),"i"),r=ln("init");e[n(204)](r+n(192))&&t[n(204)](r+n(163))?ln():r("0")}))()}();const on=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[en(169)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();on(void 0,(function(){const n=en;let e;try{e=Function("return (function() "+n(195)+");")()}catch(o){e=window}const t=e[n(193)]=e[n(193)]||{},r=["log",n(196),"info",n(166),"exception",n(159),n(160)];for(let i=0;i<r[n(191)];i++){const e=on[n(201)][n(182)].bind(on),o=r[i],c=t[o]||e;e[n(168)]=on[n(174)](on),e[n(185)]=c[n(185)][n(174)](c),t[o]=e}}))();const cn=g({__name:tn(181),setup(n){const e=tn,t=R({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(200)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=x(null),l=new i;l[e(197)]({label:e(162),title:e(158)}).on("click",(()=>{const n=e;for(var t=0;t<10;t++)a[n(184)].addDrop(2*Math[n(188)]()-1,2*Math[n(188)]()-1,.03,1&t?.02:-.02)}));const s=x(!1);return l[e(198)](s,e(184),{label:"鼠标波纹"}).on(e(157),(n=>{const t=e;a[t(184)][t(172)](n[t(184)])})),(n,i)=>{const l=e;return h(),m(y(o),_(M(t)),{default:w((()=>[i[0]||(i[0]=C(l(164),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),b(y(r)),b(Y,{light:c,ref_key:l(186),ref:a},null,512)])),_:1},16)}}});function an(){const n=["toString","waterSimulationRef","1842HktlVr","random","3614196phOlks","debu","length","chain","console","1393578gwDbTq",'{}.constructor("return this")( )',"warn","addButton","addBinding","gger","manual","constructor","212706PrZUHf","action","test","function *\\( *\\)","change","随机增加波纹","table","trace","counter","点击按钮","input","TresPerspectiveCamera","21TNMfkx","error","stateObject","__proto__","apply","16511iOviPl","1680LRHhvO","mouseEvent","42tHnqsy","bind","179135qbQDuX","820DaRAdh","string","21985WAttcB","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","602328jFSBOT","realWater","prototype","4kjVUdY","value"];return(an=function(){return n})()}function ln(n){function e(n){const t=en;if(typeof n===t(177))return function(n){}.constructor("while (true) {}")[t(169)](t(161));1!==(""+n/n).length||n%20==0?function(){return!0}[t(201)]("debu"+t(199)).call(t(203)):function(){return!1}[t(201)](t(190)+t(199))[t(169)](t(167)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{cn as default};
