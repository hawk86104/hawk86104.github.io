import{m as n,e,b as t,U as r,c as o}from"./@tresjs.vA_UT8oy1734746792122.js";import{P as i}from"./tweakpane.yHWGBmom1734746792122.js";import{_ as c,a,aA as l,s,aR as u,C as f,K as p,O as v,W as g,k as d}from"./three.1FILWcBb1734746792122.js";import{d as x,a6 as h,b as m,o as y,f as w,u as b,g as I,j as R,al as C,r as _,J as z,aj as M,ak as D}from"./@vue.-THQH3GC1734746792122.js";import"./@vueuse.lqJslAkC1734746792122.js";var T="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const A=F;!function(n,e){const t=F,r=S();for(;;)try{if(749409===parseInt(t(339))/1+-parseInt(t(362))/2+parseInt(t(364))/3*(parseInt(t(353))/4)+parseInt(t(359))/5*(parseInt(t(381))/6)+parseInt(t(360))/7*(parseInt(t(372))/8)+parseInt(t(366))/9*(-parseInt(t(369))/10)+parseInt(t(354))/11*(parseInt(t(384))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){L(this,(function(){const n=F,e=new RegExp(n(382)),t=new RegExp(n(365),"i"),r=j(n(380));e[n(342)](r+"chain")&&t.test(r+n(348))?j():r("0")}))()}();const O=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function F(n,e){const t=S();return(F=function(n,e){return t[n-=338]})(n,e)}O(void 0,(function(){const n=F;let e;try{e=Function(n(370)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(352)]=e[n(352)]||{},r=[n(378),"warn",n(338),n(385),n(356),n(374),n(344)];for(let i=0;i<r.length;i++){const e=O[n(343)].prototype[n(358)](O),o=r[i],c=t[o]||e;e.__proto__=O[n(358)](O),e[n(350)]=c[n(350)].bind(c),t[o]=e}}))();const E=x({__name:A(340),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=A,o=t,i=new(c[r(347)]),u=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),f=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(357)](r(351),new(c[r(341)])(u,3)),i.setIndex(new a(f,1));const p=new l({uniforms:{light:{value:o[r(373)]},tiles:{value:o.tiles},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(371)]}),v=new s(i,p),{renderer:g,camera:d}=n(),{onAfterLoop:x}=e();return x((()=>{const n=r;((n,e)=>{const t=r;p[t(346)][t(368)][t(383)]=n,p.uniforms[t(379)][t(383)]=e,g[t(383)][t(367)](v,d[t(383)])})(o[n(376)],o[n(361)])})),(n,e)=>null}});function j(n){function e(n){const t=F;if(typeof n===t(377))return function(n){}[t(343)](t(355))[t(363)](t(345));1!==(""+n/n)[t(349)]||n%20==0?function(){return!0}[t(343)]("debugger").call(t(375)):function(){return!1}.constructor("debugger")[t(363)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}function S(){const n=["159vtrFXb","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","9fkQAaw","render","water","1817810lNNAmu","return (function() ","FrontSide","784856mJQrBY","light","table","action","waterTexture","string","log","causticTex","init","1290DwYvzw","function *\\( *\\)","value","3156ANqQlY","error","info","789438uJRbcf","pool","BufferAttribute","test","constructor","trace","counter","uniforms","BufferGeometry","input","length","toString","position","console","52828zutojx","737UcDSYD","while (true) {}","exception","setAttribute","bind","3210ioljoS","14UKaNvZ","causticsTexture","1820168QyOCBL","apply"];return(S=function(){return n})()}const W=H;function P(){const n=["721976hCopEL","render","5901HAaBXI","14UiEYuh","test","exception","call","neg-z.jpg","debu","setPath","pooRef","constructor","3699EEcSXw","uniforms","console","clear","info","RawShaderMaterial","causticTex","bind","underwater","table","return (function() ","while (true) {}","causticsTexture","FrontSide","43992oJvrml","white","stateObject","615560qhLOpF","setClearColor","gger","water","side","374172vMQRiw","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","4350ttdbpJ","pos-y.jpg","init","627JjaCAC","4IMxFTQ","string","chain","error","prototype","33231TzUUvt","light","waterTexture","apply","toString","trace","length","value","neg-x.jpg","15sOIztS"];return(P=function(){return n})()}!function(n,e){const t=H,r=P();for(;;)try{if(100868===parseInt(t(384))/1+-parseInt(t(367))/2*(parseInt(t(372))/3)+parseInt(t(356))/4+-parseInt(t(381))/5*(parseInt(t(361))/6)+parseInt(t(385))/7*(parseInt(t(382))/8)+parseInt(t(394))/9*(parseInt(t(363))/10)+-parseInt(t(366))/11*(parseInt(t(408))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const k=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){k(this,(function(){const n=H,e=new RegExp("function *\\( *\\)"),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=Z(n(365));e[n(386)](r+n(369))&&t[n(386)](r+"input")?Z():r("0")}))()}();const V=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[H(375)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function H(n,e){const t=P();return(H=function(n,e){return t[n-=354]})(n,e)}V(void 0,(function(){const n=H;let e;try{e=Function(n(404)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e.console=e[n(396)]||{},r=["log","warn",n(398),n(370),n(387),n(403),n(377)];for(let i=0;i<r[n(378)];i++){const e=V.constructor[n(371)][n(401)](V),o=r[i],c=t[o]||e;e.__proto__=V[n(401)](V),e[n(376)]=c[n(376)][n(401)](c),t[o]=e}}))();const N=x({__name:W(359),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=W;let i,a;const l=r,v=l.geometry,g=(new u)[o(391)](o(362)).load(["pos-x.jpg",o(380),o(364),"neg-y.jpg","pos-z.jpg",o(389)]),d=([i,a]=h((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),x=new(c[o(399)])({uniforms:{light:{value:l.light},tiles:{value:d},sky:{value:g},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),I=new s(v,x),R=m(null),C=new f(o(354)),{renderer:_,camera:z}=n(),{onLoop:M}=e();return M((()=>{const n=o;_[n(379)].setRenderTarget(null),_.value[n(357)](C,1),_[n(379)][n(397)](),x[n(395)][n(359)][n(379)]=l.waterTexture,x[n(395)][n(400)].value=l.causticsTexture,x[n(360)]=c[n(407)],x[n(395)][n(402)][n(379)]=!0,_[n(379)][n(383)](I,z[n(379)]),x.side=p,x.uniforms[n(402)].value=!1,_.value[n(383)](I,z[n(379)])})),(n,e)=>{const t=o;return y(),w(E,{tiles:b(d),light:n[t(373)],waterTexture:n[t(374)],causticsTexture:n.causticsTexture,ref_key:t(392),ref:R},null,8,["tiles",t(373),"waterTexture",t(406)])}}});function Z(n){function e(n){const t=H;if(typeof n===t(368))return function(n){}[t(393)](t(405))[t(375)]("counter");1!==(""+n/n).length||n%20==0?function(){return!0}[t(393)](t(390)+t(358))[t(388)]("action"):function(){return!1}[t(393)](t(390)+"gger")[t(375)](t(355)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const G=Y;!function(n,e){const t=Y,r=B();for(;;)try{if(261290===-parseInt(t(501))/1*(-parseInt(t(500))/2)+-parseInt(t(484))/3*(-parseInt(t(468))/4)+-parseInt(t(496))/5*(-parseInt(t(479))/6)+parseInt(t(502))/7*(parseInt(t(488))/8)+-parseInt(t(492))/9+-parseInt(t(463))/10*(parseInt(t(465))/11)+parseInt(t(483))/12)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Y(476)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function B(){const n=["6651GbPoob","light","value","material","11152lGlchO","WebGLRenderTarget","table","counter","2961315tnnNrF","setClearColor","black","Mesh","111205kaEUyu","string","chain","debu","660342vUhbhL","1zoleRp","896jPSrOO","texture","constructor","call","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","prototype","__proto__","setRenderTarget","info","causticsTexture","caustics","clear","Color","length","water","OrthographicCamera","return (function() ","bind","geometry","38750foWCfG","uniforms","572toztYh","waterTexture","input","188lJNEiL","init","log","PlaneGeometry","warn","action","ShaderMaterial","toString","apply","gger","test","6twxJpp","trace","exception",'{}.constructor("return this")( )',"1881384dvZzrt"];return(B=function(){return n})()}!function(){U(this,(function(){const n=Y,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(448),"i"),r=X(n(469));e[n(478)](r+n(498))&&t[n(478)](r+n(467))?X():r("0")}))()}();const J=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Y(476)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Y(n,e){const t=B();return(Y=function(n,e){return t[n-=448]})(n,e)}J(void 0,(function(){const n=Y;let e;try{e=Function(n(460)+n(482)+");")()}catch(o){e=window}const t=e.console=e.console||{},r=[n(470),n(472),n(452),"error",n(481),n(490),n(480)];for(let i=0;i<r[n(457)];i++){const e=J[n(504)][n(449)].bind(J),o=r[i],c=t[o]||e;e[n(450)]=J[n(461)](J),e[n(475)]=c[n(475)].bind(c),t[o]=e}}))();const $=x({__name:G(454),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=G,o=t,i=new(c[r(459)])(0,1,1,0,0,2e3),a=new(c[r(471)])(2,2,200,200),l=new(c[r(489)])(1024,1024),s=new(c[r(474)])({uniforms:{light:{value:o[r(485)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),u=new(c[r(495)])(a,s),f=new(c[r(456)])(r(494)),{renderer:p}=n(),{onBeforeLoop:v}=e();return v((()=>{const n=r;u[n(487)][n(464)][n(458)][n(486)]=o[n(466)],p[n(486)][n(451)](l),p.value[n(493)](f,0),p[n(486)][n(455)](),p[n(486)].render(u,i)})),(n,e)=>{const t=r;return y(),w(C,null,{default:I((()=>[R(N,{waterTexture:n[t(466)],causticsTexture:b(l)[t(503)],light:n[t(485)],geometry:b(a)},null,8,[t(466),t(453),t(485),t(462)])])),_:1})}}});function X(n){function e(n){const t=Y;if(typeof n===t(497))return function(n){}[t(504)]("while (true) {}")[t(476)](t(491));1!==(""+n/n)[t(457)]||n%20==0?function(){return!0}[t(504)]("debugger")[t(505)](t(473)):function(){return!1}[t(504)](t(499)+t(477))[t(476)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const q=Q;function Q(n,e){const t=en();return(Q=function(n,e){return t[n-=410]})(n,e)}!function(n,e){const t=Q,r=en();for(;;)try{if(169844===-parseInt(t(439))/1*(parseInt(t(417))/2)+parseInt(t(457))/3+-parseInt(t(470))/4*(-parseInt(t(456))/5)+-parseInt(t(413))/6+-parseInt(t(428))/7*(-parseInt(t(459))/8)+parseInt(t(480))/9*(-parseInt(t(449))/10)+parseInt(t(414))/11*(parseInt(t(471))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[Q(424)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){K(this,(function(){const n=Q,e=new RegExp(n(446)),t=new RegExp(n(474),"i"),r=rn("init");e[n(468)](r+"chain")&&t[n(468)](r+n(452))?rn():r("0")}))()}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function en(){const n=["waterTexture","console","needsUpdate","RawShaderMaterial","texture","Mesh",'{}.constructor("return this")( )',"FloatType","center","width","284885GhWZgp","removeEventListener","lightFrontGeometry","toString","waterSimulation","strength","top","function *\\( *\\)","prototype","WebGLRenderTarget","268970xLPhXb","length","autoClear","input","PlaneGeometry","setY","mousemove","30mgqkrl","190935gfaJzh","bind","1653064wbJmoX","value","position","constructor","clientY","setRenderTarget","trace","domElement","clientX","test","light","35988syOVGc","2093892UniKTJ","attributes","radius","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","material","error","debu","string","stateObject","9kCRRXb","log","setFromCamera","addEventListener","table","action","102750wOpzwg","11lzuWVz","uniforms","point","2zUXDre","gger","intersectObject","height","count","info","left","apply","return (function() ","render","getBoundingClientRect","7XdYBkj"];return(en=function(){return n})()}nn(void 0,(function(){const n=Q;let e;try{e=Function(n(425)+n(435)+");")()}catch(o){e=window}const t=e[n(430)]=e[n(430)]||{},r=[n(481),"warn",n(422),n(476),"exception",n(411),n(465)];for(let i=0;i<r[n(450)];i++){const e=nn[n(462)][n(447)][n(458)](nn),o=r[i],c=t[o]||e;e.__proto__=nn.bind(nn),e[n(442)]=c[n(442)][n(458)](c),t[o]=e}}))();const tn=x({__name:q(443),props:{light:{}},setup(t,{expose:r}){const o=q,i=new v(0,1,1,0,0,2e3),a=new(c[o(453)])(2,2),l=new(c[o(448)])(256,256,{type:c[o(436)]}),u=new g(256,256,{type:c[o(436)]}),f=new(c[o(432)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:T,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),p=new(c[o(432)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:T,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),x=new(c[o(432)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:T,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),h=new(c[o(434)])(a,f),m=new(c[o(434)])(a,p),I=new s(a,x);let R=l;const C=(n,e)=>{const t=o,r=R,c=R===l?u:l;e[t(475)][t(415)].texture[t(460)]=r[t(433)],n[t(464)](c),n[t(426)](e,i),R=c},{renderer:_,camera:z,raycaster:M}=n();_.value[o(451)]=!1;const{onBeforeLoop:D}=e();D((()=>{const n=o;var e,t;t=_[n(460)],C(t,I),e=_[n(460)],C(e,m)}));const A=(n,e,t,r)=>{const i=o;h[i(475)][i(415)][i(437)][i(460)]=[n,e],h[i(475)][i(415)][i(473)][i(460)]=t,h[i(475)][i(415)][i(444)][i(460)]=r,C(_.value,h)},L=new d,O=new(c[o(453)])(2,2),F=O[o(472)][o(461)];for(let n=0;n<F[o(421)];n++){const e=-F.getY(n);F[o(454)](n,0),F.setZ(n,e)}F[o(431)]=!0;const E=new(c[o(434)])(O),j={handleEvent:n=>{const e=o,t=_[e(460)].domElement[e(427)](),r=t[e(438)],i=t[e(420)];L.x=2*(n[e(467)]-t[e(423)])/r-1,L.y=2*-(n[e(463)]-t[e(445)])/i+1,M[e(460)][e(482)](L,z[e(460)]);const c=M.value[e(419)](E);for(let o of c)A(o[e(416)].x,o[e(416)].z,.03,.04)}};return r({addDrop:A,mouseEvent:n=>{const e=o;n?_[e(460)].domElement[e(410)](e(455),j):_.value[e(466)][e(440)](e(455),j)}}),(n,e)=>{const t=o;return y(),w($,{lightFrontGeometry:b(a),waterTexture:b(R)[t(433)],light:n.light},null,8,[t(441),t(429),t(469)])}}});function rn(n){function e(n){const t=Q;if(typeof n===t(478))return function(n){}.constructor("while (true) {}")[t(424)]("counter");1!==(""+n/n)[t(450)]||n%20==0?function(){return!0}[t(462)]("debu"+t(418)).call(t(412)):function(){return!1}[t(462)](t(477)+t(418)).apply(t(479)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function on(){const n=["console","trace","mouseEvent","random","236328jMciJO","apply","bind","__proto__","function *\\( *\\)","log","realWater","点击按钮","length","info","toString","49065vdduFO","22FpnvGa","call","test","4865004uswsSs","80xVFeuw","addDrop","change","2133000yZzhmK","exception","init","108568uRxKNa",'{}.constructor("return this")( )',"counter","随机增加波纹","constructor","action","error","stateObject","string","833136uetUFP","鼠标波纹","499967UnCRHI","gger","debu","return (function() ","value","98BYVmaw","waterSimulationRef"];return(on=function(){return n})()}const cn=ln;!function(n,e){const t=ln,r=on();for(;;)try{if(364928===parseInt(t(384))/1+parseInt(t(407))/2*(-parseInt(t(406))/3)+-parseInt(t(373))/4*(parseInt(t(367))/5)+parseInt(t(382))/6+-parseInt(t(389))/7*(parseInt(t(395))/8)+parseInt(t(366))/9+parseInt(t(370))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const an=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[ln(396)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function ln(n,e){const t=on();return(ln=function(n,e){return t[n-=364]})(n,e)}!function(){an(this,(function(){const n=ln,e=new RegExp(n(399)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=fn(n(372));e[n(365)](r+"chain")&&t.test(r+"input")?fn():r("0")}))()}();const sn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[ln(396)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();sn(void 0,(function(){const n=ln,e=function(){const n=ln;let e;try{e=Function(n(387)+n(374)+");")()}catch(t){e=window}return e}(),t=e[n(391)]=e[n(391)]||{},r=[n(400),"warn",n(404),n(379),n(371),"table",n(392)];for(let o=0;o<r[n(403)];o++){const e=sn[n(377)].prototype[n(397)](sn),i=r[o],c=t[i]||e;e[n(398)]=sn[n(397)](sn),e[n(405)]=c.toString.bind(c),t[i]=e}}))();const un=x({__name:cn(401),setup(n){const e=cn,t=_({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:"manual"}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=m(null),l=new i;l.addButton({label:e(402),title:e(376)}).on("click",(()=>{const n=e;for(var t=0;t<10;t++)a[n(388)][n(368)](2*Math[n(394)]()-1,2*Math.random()-1,.03,1&t?.02:-.02)}));const s=m(!1);return l.addBinding(s,e(388),{label:e(383)}).on(e(369),(n=>{const t=e;a.value[t(393)](n[t(388)])})),(n,i)=>{const l=e;return y(),w(b(o),M(D(t)),{default:I((()=>[i[0]||(i[0]=z("TresPerspectiveCamera",{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),R(b(r)),R(tn,{light:c,ref_key:l(390),ref:a},null,512)])),_:1},16)}}});function fn(n){function e(n){const t=ln;if(typeof n===t(381))return function(n){}[t(377)]("while (true) {}")[t(396)](t(375));1!==(""+n/n)[t(403)]||n%20==0?function(){return!0}[t(377)](t(386)+"gger")[t(364)](t(378)):function(){return!1}[t(377)]("debu"+t(385))[t(396)](t(380)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{un as default};
