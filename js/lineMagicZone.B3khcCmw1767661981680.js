import{importShared as e}from"./3d-tiles-renderer.COLnOnaF1767661981680.js";import{Pane as t}from"./tweakpane.BbuIEN141767661981680.js";import{useLoop as n,customShaderMaterial_default as o,OrbitControls_default as a}from"./index.DJAV0vsW1767661981680.js";import{_sfc_main as i}from"./reflectorDUDV.vue_vue_type_script_setup_true_lang.Dp5x0OLV1767661981680.js";import{useTexture$1 as r}from"./customShaderMaterial.vue_vue_type_script_setup_true_lang.DgUcrDxr1767661981680.js";import"./index.vue_vue_type_script_setup_true_lang.BX1FIS001767661981680.js";const{withAsyncContext:l,defineComponent:s}=await e("vue"),{unref:m,createElementVNode:d,createVNode:u,openBlock:f,createElementBlock:p}=await e("vue"),v=["rotateX"],h=["position","aIndex","aNormal"],g=await e("three"),{useAttrs:c,watch:x}=await e("vue"),w=s({__name:"lineMagicZone",props:{height:{default:1.6},speed:{default:1},color:{default:"#90ee90"}},async setup(e){let t,a;const i=c(),s=e,w=([t,a]=l(()=>r(["./plugins/basic/shine/image/round.png","./plugins/digitalCity/image/noise/noisePerlin.png"])),t=await t,a(),t),I=new g.EllipseCurve(0,0,8,8,0,2*Math.PI,!1,0),S=[];for(let n=0;n<5;n++)S.push(...I.getPoints(719)),I.xRadius+=.2,I.yRadius+=.2;const _=new Float32Array(S.map((e,t)=>t)),T=(new g.BufferGeometry).setFromPoints(S).getAttribute("position").array,N=new Float32Array(T.length);for(let n=0;n<T.length/3;n++){const e=3*n;T[e+1]+=.15*Math.floor(n/720);const t=n%720*3,o=3*(n%720+2880);N[e]=T[o]-T[t],N[e+1]=T[o+1]-T[t+1],N[e+2]=T[o+2]-T[t+2]}const U={uTime:{value:0},uScale:{value:i.scale?i.scale:1},uHeight:{value:s.height},uPerlinTexture:{value:w[1]},baseColor:{value:new g.Color(s.color)}},{onRender:y}=n();return y(()=>{U.uTime.value+=.01*s.speed}),x(()=>[s.color,i.scale,s.height],([e,t,n])=>{U.baseColor.value.set(e),U.uScale.value=t,U.uHeight.value=n}),(e,t)=>(f(),p("TresGroup",null,[d("TresPoints",{rotateX:-Math.PI/2,scale:.1},[d("TresBufferGeometry",{position:[m(T),3],aIndex:[m(_),1],aNormal:[m(N),3]},null,8,h),u(m(o),{baseMaterial:g.PointsMaterial,vertexShader:"\nvarying vec2 vMapUv;\nattribute float aIndex;\nattribute vec3 aNormal;\nuniform float uTime;\nuniform float uScale;\nuniform float uHeight;\nuniform sampler2D uPerlinTexture;\nvarying float vIndex;\nvarying float vSelfIndex;\nvarying float vCircleNum;\nfloat getStrength(float aIndex, float uTime, vec3 aNormal) {\n    float selfIndex = mod(aIndex, 720.0);\n    float circleNum = (aIndex - selfIndex) / 720.0;\n    vec3 pDir = normalize(aNormal);\n    float waveWidth = 90.0;\n    float totalLength = 720.0;\n    float modUtime = mod(uTime * 50.0, 720.0);\n    float dw = waveWidth * 0.5;\n    float smoothStart = smoothstep(modUtime, modUtime + dw, selfIndex);\n    float smoothEnd = 1.0 - smoothstep(modUtime + waveWidth - dw, modUtime + waveWidth, selfIndex);\n    float strength = min(smoothStart, smoothEnd);\n    float isOver = step(720.0, modUtime + waveWidth);\n    float over = (modUtime + waveWidth - 720.0);\n    float isOverStep1 = (1.0 - step(dw, over)) * isOver;\n    float isOverStep2 = step(dw, over);\n    float overStep1Left = min(smoothstep(modUtime, modUtime + dw, selfIndex), (1.0 - smoothstep(modUtime + waveWidth - dw, modUtime + waveWidth, selfIndex)));\n    float overStep1Right = 1.0 - smoothstep(modUtime + waveWidth - dw, modUtime + waveWidth, selfIndex + 720.0);\n    float overStep1 = max(overStep1Left, overStep1Right);\n    float overStep2Left = smoothstep(modUtime, modUtime + dw, selfIndex);\n    float overStep2Right = min(smoothstep(modUtime, modUtime + dw, selfIndex + 720.0), (1.0 - smoothstep(modUtime + waveWidth - dw, modUtime + waveWidth, selfIndex + 720.0)));\n    float overStep2 = max(overStep2Left, overStep2Right);\n    float os = isOverStep1 * overStep1 + overStep2 * isOverStep2;\n    strength = (1.0 - isOver) * strength + isOver * os;\n    return strength;\n}\nvoid main() {\n\tvMapUv = uv;\n\tfloat selfIndex = mod(aIndex, 720.0);\n\tfloat circleNum = (aIndex - selfIndex) / 720.0;\n\tvec3 pDir = normalize(aNormal);\n\tfloat noise = texture(uPerlinTexture, vec2((selfIndex / 720.0), mod(uTime * 0.1, 1.0))).r;\n\tfloat strength = getStrength(aIndex, uTime, aNormal);\n\tstrength += getStrength(aIndex, uTime + 10.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 20.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 30.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 40.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 50.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 60.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 70.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 80.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 90.0 + noise, aNormal);\n\tcsm_Position.x += pDir.x * strength * 0.5;\n\tcsm_Position.z += strength * circleNum * noise * uHeight;\n\tcsm_Position.y += pDir.z * strength * 0.5;\n\tvIndex = aIndex;\n\tcsm_PointSize = 0.01*uScale;\n}\n",fragmentShader:"\nvarying vec2 vMapUv;\nvarying float vIndex;\nuniform float uTime;\nuniform vec3 baseColor;\nuniform sampler2D uPerlinTexture;\nvoid main() {\n\tvec3 whiteColor = vec3( 1.0,1.0,1.0);\n\tfloat selfIndex=mod(vIndex,720.0);\n\tfloat circleNum=(vIndex - selfIndex)/720.0;\n\tvec3 finalColor=mix(baseColor,diffuse,circleNum/5.0);\n\tfinalColor*=1.0;\n\tcsm_DiffuseColor = vec4( finalColor, opacity );\n}\n",uniforms:U,map:m(w)[0],alphaMap:m(w)[0],transparent:"",depthWrite:!1,blending:g.AdditiveBlending,color:"#409eff",size:.1},null,8,["baseMaterial","map","alphaMap","blending"])],8,v)]))}}),{defineComponent:I}=await e("vue"),{createElementVNode:S,unref:_,createVNode:T,mergeProps:N,Suspense:U,withCtx:y,openBlock:C,createBlock:b,resolveComponent:P}=await e("vue"),{reactive:M}=await e("vue"),W=I({__name:"lineMagicZone",setup(e){const n=M({reflectivity:.1,showGridHelper:!0,scale:1}),o=M({color:"#ff0000",scale:1.8,height:2.4,speed:1}),r=new t;return r.addBinding(o,"color",{label:"颜色"}),r.addBinding(o,"scale",{label:"大小",min:.1,max:3,step:.1}),r.addBinding(o,"height",{label:"高度",min:.1,max:3,step:.1}),r.addBinding(o,"speed",{label:"速度",min:-5,max:5,step:.1}),(e,t)=>{const r=P("TresCanvas");return C(),b(r,{clearColor:"#201919","window-size":"",antialias:"",alpha:"",logarithmicDepthBuffer:""},{default:y(()=>[t[0]||(t[0]=S("TresPerspectiveCamera",{position:[5,5,5],fov:45,near:.1,far:1e4},null,-1)),T(_(a),{enableDamping:""}),t[1]||(t[1]=S("TresAmbientLight",{intensity:2},null,-1)),(C(),b(U,null,{default:y(()=>[T(w,N({position:[3,0,0]},o),null,16)]),_:1})),(C(),b(U,null,{default:y(()=>[T(w,{position:[-3,0,0],scale:1.6,height:3})]),_:1})),T(i,N({position:[0,-.5,0]},n),null,16)]),_:1})}}});export{W as default};
