import{m as n,e,a as t,o as r,f as o}from"./@tresjs.GCV-1VTd1743149128717.js";import{P as i}from"./tweakpane.ivGeiIdz1743149128717.js";import{_ as c,c as a,a_ as l,m as s}from"./three.hBhj0ayh1743149128717.js";import{d as u,a3 as f,b as p,o as v,f as g,u as d,g as x,j as h,al as m,r as y,N as w,aj as b,ak as C}from"./@vue.L-brCdZe1743149128717.js";import"./postprocessing.JYKQQ2FM1743149128717.js";import"./@vueuse.K3OHOx4F1743149128717.js";var R="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const I=D;!function(n,e){const t=D,r=z();for(;;)try{if(433317===-parseInt(t(260))/1+-parseInt(t(236))/2+parseInt(t(255))/3*(parseInt(t(248))/4)+parseInt(t(259))/5*(-parseInt(t(235))/6)+parseInt(t(225))/7*(-parseInt(t(217))/8)+-parseInt(t(245))/9+parseInt(t(226))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const _=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[D(249)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){_(this,(function(){const n=D,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(242),"i"),r=A(n(220));e[n(234)](r+"chain")&&t[n(234)](r+n(222))?A():r("0")}))()}();const M=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[D(249)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function z(){const n=["bind","6101505SRSBnS","BufferGeometry","trace","496772FCuykR","apply","action","console","RawShaderMaterial","light","table","6pnKyPn","prototype","render","waterTexture","2930YzqGiH","509108YFRlpV","warn",'{}.constructor("return this")( )',"length","__proto__","setAttribute","17624ezcviA","log","tiles","init","constructor","input","counter","FrontSide","1134CDutlc","22344340MdokSc","BufferAttribute","string","Mesh","pool","stateObject","uniforms","exception","test","816mrePSF","851736xkjJuC","toString","debu","causticsTexture","gger","value","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","causticTex"];return(z=function(){return n})()}function D(n,e){const t=z();return D=function(n,e){return t[n-=214]},D(n,e)}M(void 0,(function(){const n=D;let e;try{e=Function("return (function() "+n(262)+");")()}catch(o){e=window}const t=e.console=e[n(251)]||{},r=[n(218),n(261),"info","error",n(233),n(254),n(247)];for(let i=0;i<r.length;i++){const e=M[n(221)][n(256)][n(244)](M),o=r[i],c=t[o]||e;e[n(215)]=M[n(244)](M),e[n(237)]=c[n(237)].bind(c),t[o]=e}}))();const T=u({__name:I(230),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=I,o=t,i=new(c[r(246)]),l=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),s=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(216)]("position",new a(l,3)),i.setIndex(new(c[r(227)])(s,1));const u=new(c[r(252)])({uniforms:{light:{value:o[r(253)]},tiles:{value:o[r(219)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(224)]}),f=new(c[r(229)])(i,u),{renderer:p,camera:v}=n(),{onAfterLoop:g}=e();return g((()=>{const n=r;((n,e)=>{const t=r;u[t(232)].water[t(241)]=n,u.uniforms[t(243)][t(241)]=e,p[t(241)][t(257)](f,v[t(241)])})(o[n(258)],o[n(239)])})),(n,e)=>null}});function A(n){function e(n){const t=D;if(typeof n===t(228))return function(n){}.constructor("while (true) {}")[t(249)](t(223));1!==(""+n/n)[t(214)]||n%20==0?function(){return!0}[t(221)](t(238)+"gger").call(t(250)):function(){return!1}[t(221)](t(238)+t(240))[t(249)](t(231)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const L=S;!function(n,e){const t=S,r=j();for(;;)try{if(814919===parseInt(t(233))/1+-parseInt(t(279))/2+-parseInt(t(244))/3*(-parseInt(t(240))/4)+parseInt(t(253))/5+parseInt(t(264))/6+parseInt(t(287))/7+parseInt(t(270))/8*(-parseInt(t(274))/9))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const O=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[S(245)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){O(this,(function(){const n=S,e=new RegExp(n(254)),t=new RegExp(n(234),"i"),r=W(n(232));e[n(257)](r+"chain")&&t.test(r+n(249))?W():r("0")}))()}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function S(n,e){const t=j();return S=function(n,e){return t[n-=223]},S(n,e)}function j(){const n=["causticsTexture","bind","length","input","BackSide",'{}.constructor("return this")( )',"__proto__","6637330eWZLuY","function *\\( *\\)","toString","gger","test","log","render","clear","exception","FrontSide","Color","1879038Jpcnmf","action","CubeTextureLoader","uniforms","side","Mesh","215328TspsEN","setPath","error","table","684YrFhWm","stateObject","light","water","pos-x.jpg","1317674tlMqED","constructor","pooRef","call","/images/skyBox/6jpg/","neg-y.jpg","pos-z.jpg","geometry","4251219pThnZk","return (function() ","causticTex","neg-x.jpg","while (true) {}","pos-y.jpg","https://opensource.cdn.icegl.cn","load","resource.cos","debu","init","442870iYrPtJ","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","value","waterTexture","white","warn","string","8ukYQfO","underwater","console","tiles","1242819YSXsvN","apply"];return(j=function(){return n})()}F(void 0,(function(){const n=S;let e;try{e=Function(n(223)+n(251)+");")()}catch(o){e=window}const t=e.console=e[n(242)]||{},r=[n(258),n(238),"info",n(272),n(261),n(273),"trace"];for(let i=0;i<r[n(248)];i++){const e=F.constructor.prototype[n(247)](F),o=r[i],c=t[o]||e;e[n(252)]=F[n(247)](F),e[n(255)]=c[n(255)][n(247)](c),t[o]=e}}))();const E=u({__name:L(277),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=L;let i,a;const s=r,u=s[o(286)],x=(new(c[o(266)]))[o(271)](o(228)+o(283))[o(229)]([o(278),o(225),o(227),o(284),o(285),"neg-z.jpg"]),h=([i,a]=f((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),m=new l({uniforms:{light:{value:s[o(276)]},tiles:{value:h},sky:{value:x},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new(c[o(269)])(u,m),w=p(null),b=new(c[o(263)])(o(237)),{renderer:C,camera:R}=n(),{onLoop:I}=e();return I((()=>{const n=o;C.value.setRenderTarget(null),C[n(235)].setClearColor(b,1),C.value[n(260)](),m[n(267)][n(277)][n(235)]=s.waterTexture,m[n(267)][n(224)][n(235)]=s[n(246)],m[n(268)]=c[n(262)],m[n(267)][n(241)][n(235)]=!0,C.value[n(259)](y,R[n(235)]),m.side=c[n(250)],m.uniforms[n(241)][n(235)]=!1,C.value.render(y,R[n(235)])})),(n,e)=>{const t=o;return v(),g(T,{tiles:d(h),light:n[t(276)],waterTexture:n[t(236)],causticsTexture:n.causticsTexture,ref_key:t(281),ref:w},null,8,[t(243),t(276),t(236),t(246)])}}});function W(n){function e(n){const t=S;if(typeof n===t(239))return function(n){}[t(280)](t(226)).apply("counter");1!==(""+n/n)[t(248)]||n%20==0?function(){return!0}[t(280)](t(231)+t(256))[t(282)](t(265)):function(){return!1}.constructor(t(231)+"gger")[t(245)](t(275)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const P=V;!function(n,e){const t=V,r=N();for(;;)try{if(480740===-parseInt(t(432))/1+parseInt(t(434))/2+-parseInt(t(442))/3*(parseInt(t(427))/4)+-parseInt(t(458))/5*(-parseInt(t(479))/6)+parseInt(t(478))/7*(parseInt(t(459))/8)+-parseInt(t(433))/9+parseInt(t(425))/10*(parseInt(t(461))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const k=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[V(437)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){k(this,(function(){const n=V,e=new RegExp(n(454)),t=new RegExp(n(430),"i"),r=q(n(466));e[n(464)](r+n(457))&&t[n(464)](r+n(465))?q():r("0")}))()}();const H=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[V(437)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function V(n,e){const t=N();return V=function(n,e){return t[n-=423]},V(n,e)}function N(){const n=["test","input","init","caustics","trace","causticsTexture","while (true) {}","waterTexture","Mesh","string","__proto__","Color","material","black","1193402nXbLPb","3834yNuOAu",'{}.constructor("return this")( )',"setRenderTarget","5080gssadC","toString","64uEDJPb","value","setClearColor","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","bind","428404pdrwqD","6481242MTYygM","920530FQAcGd","OrthographicCamera","texture","apply","info","uniforms","length","gger","127509JpiZAz","constructor","render","return (function() ","geometry","log","WebGLRenderTarget","table","light","debu","stateObject","action","function *\\( *\\)","ShaderMaterial","clear","chain","595QVhhMr","16Lxztig","prototype","31009dlLcUC","call","console"];return(N=function(){return n})()}H(void 0,(function(){const n=V,e=function(){const n=V;let e;try{e=Function(n(445)+n(423)+");")()}catch(t){e=window}return e}(),t=e[n(463)]=e[n(463)]||{},r=[n(447),"warn",n(438),"error","exception",n(449),n(468)];for(let o=0;o<r[n(440)];o++){const e=H.constructor[n(460)][n(431)](H),i=r[o],c=t[i]||e;e[n(474)]=H[n(431)](H),e[n(426)]=c[n(426)][n(431)](c),t[i]=e}}))();const Z=u({__name:P(467),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=P,o=t,i=new(c[r(435)])(0,1,1,0,0,2e3),a=new s(2,2,200,200),l=new(c[r(448)])(1024,1024),u=new(c[r(455)])({uniforms:{light:{value:o[r(450)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),f=new(c[r(472)])(a,u),p=new(c[r(475)])(r(477)),{renderer:y}=n(),{onBeforeLoop:w}=e();return w((()=>{const n=r;f[n(476)][n(439)].water.value=o[n(471)],y[n(428)][n(424)](l),y[n(428)][n(429)](p,0),y.value[n(456)](),y[n(428)][n(444)](f,i)})),(n,e)=>{const t=r;return v(),g(m,null,{default:x((()=>[h(E,{waterTexture:n.waterTexture,causticsTexture:d(l)[t(436)],light:n.light,geometry:d(a)},null,8,[t(471),t(469),"light",t(446)])])),_:1})}}});function q(n){function e(n){const t=V;if(typeof n===t(473))return function(n){}[t(443)](t(470))[t(437)]("counter");1!==(""+n/n)[t(440)]||n%20==0?function(){return!0}[t(443)](t(451)+t(441))[t(462)](t(453)):function(){return!1}[t(443)](t(451)+t(441))[t(437)](t(452)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const Y=B;!function(n,e){const t=B,r=$();for(;;)try{if(544287===parseInt(t(179))/1+parseInt(t(165))/2+parseInt(t(153))/3*(-parseInt(t(186))/4)+-parseInt(t(157))/5*(parseInt(t(145))/6)+parseInt(t(129))/7+-parseInt(t(152))/8+parseInt(t(170))/9*(parseInt(t(140))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const G=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[B(155)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function B(n,e){const t=$();return B=function(n,e){return t[n-=116]},B(n,e)}function $(){const n=["bind","toString","287520mTpWki","waterSimulation","call","input","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","width","light","constructor","mousemove","info","FloatType","console","position","OrthographicCamera","render","4127193wfyYoh","height","return (function() ","debu","addEventListener","WebGLRenderTarget","counter","exception",'{}.constructor("return this")( )',"value","radius","140pWThAz","point","chain","top","warn","1014MNervK","setZ","texture","strength","material","length","gger","5340728sHcmSm","18OolzeK","while (true) {}","apply","Mesh","30230AWwvGq","action","PlaneGeometry","setRenderTarget","trace","Vector2","intersectObject","function *\\( *\\)","1355606WIGhQi","stateObject","test","prototype","log","251577HMUwKd","domElement","__proto__","clientY","left","string","RawShaderMaterial","autoClear","getY","1006188upfJqb","uniforms","init","clientX","setY"];return($=function(){return n})()}!function(){G(this,(function(){const n=B,e=new RegExp(n(164)),t=new RegExp(n(118),"i"),r=Q(n(181));e[n(167)](r+n(142))&&t.test(r+n(117))?Q():r("0")}))()}();const K=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();K(void 0,(function(){const n=B;let e;try{e=Function(n(131)+n(137)+");")()}catch(o){e=window}const t=e[n(125)]=e[n(125)]||{},r=[n(169),n(144),n(123),"error",n(136),"table",n(161)];for(let i=0;i<r[n(150)];i++){const e=K.constructor[n(168)][n(184)](K),o=r[i],c=t[o]||e;e[n(172)]=K[n(184)](K),e.toString=c[n(185)][n(184)](c),t[o]=e}}))();const J=u({__name:Y(187),props:{light:{}},setup(t,{expose:r}){const o=Y,i=new(c[o(127)])(0,1,1,0,0,2e3),a=new(c[o(159)])(2,2),l=new(c[o(134)])(256,256,{type:c[o(124)]}),s=new(c[o(134)])(256,256,{type:c[o(124)]}),u=new(c[o(176)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:R,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),f=new(c[o(176)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:R,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),p=new(c[o(176)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:R,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),x=new(c[o(156)])(a,u),h=new(c[o(156)])(a,f),m=new(c[o(156)])(a,p);let y=l;const w=(n,e)=>{const t=o,r=y,c=y===l?s:l;e.material[t(180)][t(147)][t(138)]=r[t(147)],n[t(160)](c),n[t(128)](e,i),y=c},{renderer:b,camera:C,raycaster:I}=n();b[o(138)][o(177)]=!1;const{onBeforeLoop:_}=e();_((()=>{const n=o;var e,t;t=b[n(138)],w(t,m),e=b[n(138)],w(e,h)}));const M=(n,e,t,r)=>{const i=o;x[i(149)][i(180)].center.value=[n,e],x.material.uniforms[i(139)][i(138)]=t,x[i(149)].uniforms[i(148)][i(138)]=r,w(b[i(138)],x)},z=new(c[o(162)]),D=new(c[o(159)])(2,2),T=D.attributes[o(126)];for(let n=0;n<T.count;n++){const e=-T[o(178)](n);T[o(183)](n,0),T[o(146)](n,e)}T.needsUpdate=!0;const A=new(c[o(156)])(D),L={handleEvent:n=>{const e=o,t=b[e(138)][e(171)].getBoundingClientRect(),r=t[e(119)],i=t[e(130)];z.x=2*(n[e(182)]-t[e(174)])/r-1,z.y=2*-(n[e(173)]-t[e(143)])/i+1,I.value.setFromCamera(z,C.value);const c=I[e(138)][e(163)](A);for(let o of c)M(o[e(141)].x,o[e(141)].z,.03,.04)}};return r({addDrop:M,mouseEvent:n=>{const e=o;n?b.value[e(171)][e(133)](e(122),L):b[e(138)][e(171)].removeEventListener(e(122),L)}}),(n,e)=>{const t=o;return v(),g(Z,{lightFrontGeometry:d(a),waterTexture:d(y)[t(147)],light:n[t(120)]},null,8,["lightFrontGeometry","waterTexture",t(120)])}}});function Q(n){function e(n){const t=B;if(typeof n===t(175))return function(n){}[t(121)](t(154))[t(155)](t(135));1!==(""+n/n)[t(150)]||n%20==0?function(){return!0}[t(121)](t(132)+t(151))[t(116)](t(158)):function(){return!1}[t(121)](t(132)+t(151))[t(155)](t(166)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const U=en;!function(n,e){const t=en,r=tn();for(;;)try{if(428675===-parseInt(t(493))/1+-parseInt(t(483))/2+parseInt(t(489))/3+parseInt(t(484))/4+parseInt(t(511))/5+parseInt(t(496))/6+-parseInt(t(474))/7*(-parseInt(t(504))/8))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const X=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[en(499)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){X(this,(function(){const n=en,e=new RegExp(n(506)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=on(n(487));e[n(507)](r+"chain")&&t[n(507)](r+"input")?on():r("0")}))()}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function en(n,e){const t=tn();return en=function(n,e){return t[n-=474]},en(n,e)}function tn(){const n=["function *\\( *\\)","test","debu","mouseEvent","warn","701800DTqDWH","__proto__","prototype","console","return (function() ","2737511nzzMRo","gger","随机增加波纹","counter","toString","鼠标波纹",'{}.constructor("return this")( )',"waterSimulationRef","constructor","1698884aimvIK","2950660qgOxyI","value","log","init","manual","280923izqKts","while (true) {}","addDrop","realWater","660525ZJcwwX","length","addButton","1108980qxlKQb","change","call","apply","trace","bind","table","点击按钮","16tUKyxq","stateObject"];return(tn=function(){return n})()}nn(void 0,(function(){const n=en,e=function(){const n=en;let e;try{e=Function(n(515)+n(480)+");")()}catch(t){e=window}return e}(),t=e[n(514)]=e[n(514)]||{},r=[n(486),n(510),"info","error","exception",n(502),n(500)];for(let o=0;o<r[n(494)];o++){const e=nn[n(482)][n(513)][n(501)](nn),i=r[o],c=t[i]||e;e[n(512)]=nn.bind(nn),e[n(478)]=c.toString.bind(c),t[i]=e}}))();const rn=u({__name:U(492),setup(n){const e=U,t=y({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(488)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=p(null),l=new i;l[e(495)]({label:e(503),title:e(476)}).on("click",(()=>{const n=e;for(var t=0;t<10;t++)a.value[n(491)](2*Math.random()-1,2*Math.random()-1,.03,1&t?.02:-.02)}));const s=p(!1);return l.addBinding(s,"value",{label:e(479)}).on(e(497),(n=>{const t=e;a[t(485)][t(509)](n[t(485)])})),(n,i)=>{const l=e;return v(),g(d(o),b(C(t)),{default:x((()=>[i[0]||(i[0]=w("TresPerspectiveCamera",{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),h(d(r)),h(J,{light:c,ref_key:l(481),ref:a},null,512)])),_:1},16)}}});function on(n){function e(n){const t=en;if("string"==typeof n)return function(n){}[t(482)](t(490)).apply(t(477));1!==(""+n/n)[t(494)]||n%20==0?function(){return!0}[t(482)](t(508)+t(475))[t(498)]("action"):function(){return!1}[t(482)](t(508)+t(475))[t(499)](t(505)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{rn as default};
