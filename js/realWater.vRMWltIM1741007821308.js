import{m as n,e,a as t,o as r,f as o}from"./@tresjs.u6hJLBm41741007821308.js";import{P as i}from"./tweakpane.yDiyAAkA1741007821308.js";import{B as c,_ as a,c as l,O as s,o as u,aW as f,V as p}from"./three.sBrYSCgq1741007821308.js";import{d as v,a3 as g,b as d,o as x,f as h,u as m,g as y,j as w,al as b,r as R,N as C,aj as I,ak as _}from"./@vue.NRI7TcgI1741007821308.js";import"./postprocessing.rsQjznIU1741007821308.js";import"./@vueuse.jd1Cg91M1741007821308.js";var M="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";!function(n,e){const t=T,r=D();for(;;)try{if(985525===-parseInt(t(235))/1*(parseInt(t(237))/2)+-parseInt(t(253))/3*(-parseInt(t(242))/4)+parseInt(t(234))/5+parseInt(t(228))/6+-parseInt(t(245))/7+parseInt(t(244))/8+-parseInt(t(260))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[T(261)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function D(){const n=["waterTexture","33143103PlNzha","apply","RawShaderMaterial","table","setIndex","init","BufferAttribute","return (function() ","call","causticsTexture","debu","action","__proto__","Mesh","bind","7205526RXslfk","tiles","chain",'{}.constructor("return this")( )',"FrontSide","setAttribute","9030475eqwkZO","4yybKed","causticTex","355458Saennq","render","string","position","error","16cmOsHq","value","14402856UxUepu","490427kwbTiL","toString","console","warn","prototype","test","input","length","481272frFUQA","stateObject","constructor","gger","log","info"];return(D=function(){return n})()}!function(){z(this,(function(){const n=T,e=new RegExp("function *\\( *\\)"),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=O(n(218));e[n(250)](r+n(230))&&t[n(250)](r+n(251))?O():r("0")}))()}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function T(n,e){const t=D();return(T=function(n,e){return t[n-=217]})(n,e)}L(void 0,(function(){const n=T,e=function(){const n=T;let e;try{e=Function(n(220)+n(231)+");")()}catch(t){e=window}return e}(),t=e[n(247)]=e[n(247)]||{},r=[n(257),n(248),n(258),n(241),"exception",n(263),"trace"];for(let o=0;o<r[n(252)];o++){const e=L[n(255)][n(249)][n(227)](L),i=r[o],c=t[i]||e;e[n(225)]=L[n(227)](L),e[n(246)]=c[n(246)][n(227)](c),t[i]=e}}))();const A=v({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=T,o=t,i=new c,s=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),u=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(233)](r(240),new(a[r(219)])(s,3)),i[r(217)](new l(u,1));const f=new(a[r(262)])({uniforms:{light:{value:o.light},tiles:{value:o[r(229)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:a[r(232)]}),p=new(a[r(226)])(i,f),{renderer:v,camera:g}=n(),{onAfterLoop:d}=e();return d((()=>{const n=r;((n,e)=>{const t=r;f.uniforms.water[t(243)]=n,f.uniforms[t(236)][t(243)]=e,v[t(243)][t(238)](p,g[t(243)])})(o[n(259)],o[n(222)])})),(n,e)=>null}});function O(n){function e(n){const t=T;if(typeof n===t(239))return function(n){}[t(255)]("while (true) {}")[t(261)]("counter");1!==(""+n/n)[t(252)]||n%20==0?function(){return!0}[t(255)](t(223)+t(256))[t(221)](t(224)):function(){return!1}.constructor(t(223)+t(256))[t(261)](t(254)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=E,r=S();for(;;)try{if(871837===-parseInt(t(311))/1+parseInt(t(302))/2+-parseInt(t(348))/3+-parseInt(t(343))/4*(parseInt(t(305))/5)+-parseInt(t(326))/6+-parseInt(t(350))/7+parseInt(t(358))/8)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[E(310)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){j(this,(function(){const n=E,e=new RegExp(n(331)),t=new RegExp(n(303),"i"),r=W(n(355));e[n(328)](r+n(347))&&t[n(328)](r+n(333))?W():r("0")}))()}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function S(){const n=["RawShaderMaterial","value","3284542LAAONF","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","stateObject","15gMcDOT","counter","info","underwater","BackSide","apply","1593300YeBmlY","debu","table","Color",'{}.constructor("return this")( )',"exception","setRenderTarget","clear","console","log","render","setPath","__proto__","load","CubeTextureLoader","7633734PGichp","pooRef","test","causticTex","return (function() ","function *\\( *\\)","length","input","geometry","FrontSide","neg-y.jpg","prototype","toString","pos-z.jpg","pos-x.jpg","constructor","causticsTexture","1692776inPkQA","waterTexture","bind","light","chain","3881712TmmYUa","uniforms","2273670SXQkvM","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","string","tiles","white","init","Mesh","gger","39867608Yvimio","side","error"];return(S=function(){return n})()}function E(n,e){const t=S();return(E=function(n,e){return t[n-=299]})(n,e)}F(void 0,(function(){const n=E;let e;try{e=Function(n(330)+n(315)+");")()}catch(o){e=window}const t=e[n(319)]=e[n(319)]||{},r=[n(320),"warn",n(307),n(299),n(316),n(313),"trace"];for(let i=0;i<r[n(332)];i++){const e=F[n(341)][n(337)][n(345)](F),o=r[i],c=t[o]||e;e[n(323)]=F[n(345)](F),e[n(338)]=c[n(338)][n(345)](c),t[o]=e}}))();const P=v({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=E;let i,c;const l=r,s=l[o(334)],u=(new(a[o(325)]))[o(322)](o(351))[o(324)]([o(340),"neg-x.jpg","pos-y.jpg",o(336),o(339),"neg-z.jpg"]),f=([i,c]=g((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,c(),i),p=new(a[o(300)])({uniforms:{light:{value:l[o(346)]},tiles:{value:f},sky:{value:u},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),v=new(a[o(356)])(s,p),y=d(null),w=new(a[o(314)])(o(354)),{renderer:b,camera:R}=n(),{onLoop:C}=e();return C((()=>{const n=o;b[n(301)][n(317)](null),b.value.setClearColor(w,1),b[n(301)][n(318)](),p[n(349)].water[n(301)]=l[n(344)],p.uniforms[n(329)][n(301)]=l[n(342)],p[n(359)]=a[n(335)],p.uniforms.underwater.value=!0,b[n(301)][n(321)](v,R[n(301)]),p.side=a[n(309)],p[n(349)][n(308)][n(301)]=!1,b[n(301)].render(v,R[n(301)])})),(n,e)=>{const t=o;return x(),h(A,{tiles:m(f),light:n.light,waterTexture:n[t(344)],causticsTexture:n.causticsTexture,ref_key:t(327),ref:y},null,8,[t(353),t(346),t(344),t(342)])}}});function W(n){function e(n){const t=E;if(typeof n===t(352))return function(n){}[t(341)]("while (true) {}")[t(310)](t(306));1!==(""+n/n)[t(332)]||n%20==0?function(){return!0}[t(341)](t(312)+t(357)).call("action"):function(){return!1}[t(341)](t(312)+t(357))[t(310)](t(304)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const k=N;!function(n,e){const t=N,r=Z();for(;;)try{if(269002===parseInt(t(461))/1*(-parseInt(t(441))/2)+parseInt(t(472))/3*(parseInt(t(443))/4)+-parseInt(t(468))/5+-parseInt(t(451))/6*(-parseInt(t(459))/7)+parseInt(t(439))/8+parseInt(t(490))/9*(-parseInt(t(449))/10)+parseInt(t(444))/11*(parseInt(t(431))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const V=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){V(this,(function(){const n=N,e=new RegExp(n(448)),t=new RegExp(n(479),"i"),r=G(n(458));e[n(473)](r+n(471))&&t[n(473)](r+n(484))?G():r("0")}))()}();const H=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[N(480)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function Z(){const n=["caustics","info","setRenderTarget","__proto__","1289600Rjkjbx","gger","2704UiuUpU","Mesh","138588XyQNDN","8503glOuCQ","geometry","debu","error","function *\\( *\\)","60LkqLFk","counter","972EmlcMF","clear","length","Color","constructor","material","PlaneGeometry","init","11928CXZGkS","value","201jvjaVl","stateObject","call","black","causticsTexture","action","log","1714190cLrnhW","console","table","chain","27yPVPzp","test","prototype","toString","warn","return (function() ","string","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","apply","bind","render","WebGLRenderTarget","input","water","texture",'{}.constructor("return this")( )',"ShaderMaterial","trace","89253stpleC","3012ReuPZs","light","waterTexture","setClearColor"];return(Z=function(){return n})()}function N(n,e){const t=Z();return(N=function(n,e){return t[n-=431]})(n,e)}H(void 0,(function(){const n=N,e=function(){const n=N;let e;try{e=Function(n(477)+n(487)+");")()}catch(t){e=window}return e}(),t=e[n(469)]=e.console||{},r=[n(467),n(476),n(436),n(447),"exception",n(470),n(489)];for(let o=0;o<r[n(453)];o++){const e=H[n(455)][n(474)][n(481)](H),i=r[o],c=t[i]||e;e[n(438)]=H[n(481)](H),e[n(475)]=c.toString[n(481)](c),t[i]=e}}))();const B=v({__name:k(435),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=k,o=t,i=new s(0,1,1,0,0,2e3),c=new(a[r(457)])(2,2,200,200),l=new(a[r(483)])(1024,1024),u=new(a[r(488)])({uniforms:{light:{value:o[r(432)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),f=new(a[r(442)])(c,u),p=new(a[r(454)])(r(464)),{renderer:v}=n(),{onBeforeLoop:g}=e();return g((()=>{const n=r;f[n(456)].uniforms[n(485)][n(460)]=o[n(433)],v[n(460)][n(437)](l),v[n(460)][n(434)](p,0),v.value[n(452)](),v[n(460)][n(482)](f,i)})),(n,e)=>{const t=r;return x(),h(b,null,{default:y((()=>[w(P,{waterTexture:n[t(433)],causticsTexture:m(l)[t(486)],light:n[t(432)],geometry:m(c)},null,8,["waterTexture",t(465),"light",t(445)])])),_:1})}}});function G(n){function e(n){const t=N;if(typeof n===t(478))return function(n){}[t(455)]("while (true) {}")[t(480)](t(450));1!==(""+n/n)[t(453)]||n%20==0?function(){return!0}[t(455)](t(446)+"gger")[t(463)](t(466)):function(){return!1}[t(455)](t(446)+t(440))[t(480)](t(462)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const U=q;!function(n,e){const t=q,r=Q();for(;;)try{if(612475===-parseInt(t(144))/1+parseInt(t(151))/2+-parseInt(t(193))/3+-parseInt(t(149))/4+-parseInt(t(156))/5*(parseInt(t(166))/6)+parseInt(t(204))/7*(parseInt(t(158))/8)+parseInt(t(202))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Y=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(171)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Y(this,(function(){const n=q,e=new RegExp(n(174)),t=new RegExp(n(178),"i"),r=J(n(177));e[n(191)](r+n(147))&&t[n(191)](r+n(180))?J():r("0")}))()}();const $=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(171)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function q(n,e){const t=Q();return(q=function(n,e){return t[n-=138]})(n,e)}function Q(){const n=["material","apply","OrthographicCamera","Mesh","function *\\( *\\)","setRenderTarget","waterSimulation","init","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","position","input","radius","console","constructor","light","width","getBoundingClientRect","uniforms","strength","toString","call","test","exception","1320549nNkgSi","point","waterTexture",'{}.constructor("return this")( )',"needsUpdate","while (true) {}","setZ","left","debu","30528459GbbCnW","center","362201jcBvIY","intersectObject","height","lightFrontGeometry","__proto__","log","warn","PlaneGeometry","819989tabEkR","action","stateObject","chain","removeEventListener","4622228hLWhPk","domElement","64858suIogs","WebGLRenderTarget","top","clientX","mousemove","9295LEYdyA","addEventListener","8bUwguQ","value","bind","table","texture","count","prototype","info","1446JDfGXM","setFromCamera","length","RawShaderMaterial"];return(Q=function(){return n})()}$(void 0,(function(){const n=q;let e;try{e=Function("return (function() "+n(196)+");")()}catch(o){e=window}const t=e[n(182)]=e[n(182)]||{},r=[n(141),n(142),n(165),"error",n(192),n(161),"trace"];for(let i=0;i<r[n(168)];i++){const e=$[n(183)][n(164)][n(160)]($),o=r[i],c=t[o]||e;e[n(140)]=$[n(160)]($),e[n(189)]=c[n(189)][n(160)](c),t[o]=e}}))();const X=v({__name:U(176),props:{light:{}},setup(t,{expose:r}){const o=U,i=new(a[o(172)])(0,1,1,0,0,2e3),c=new(a[o(143)])(2,2),l=new(a[o(152)])(256,256,{type:u}),s=new(a[o(152)])(256,256,{type:u}),v=new f({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),g=new(a[o(169)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),d=new(a[o(169)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),y=new(a[o(173)])(c,v),w=new(a[o(173)])(c,g),b=new(a[o(173)])(c,d);let R=l;const C=(n,e)=>{const t=o,r=R,c=R===l?s:l;e[t(170)].uniforms[t(162)][t(159)]=r[t(162)],n[t(175)](c),n.render(e,i),R=c},{renderer:I,camera:_,raycaster:z}=n();I.value.autoClear=!1;const{onBeforeLoop:D}=e();D((()=>{var n,e;e=I[o(159)],C(e,b),n=I.value,C(n,w)}));const L=(n,e,t,r)=>{const i=o;y.material[i(187)][i(203)][i(159)]=[n,e],y.material.uniforms[i(181)][i(159)]=t,y[i(170)][i(187)][i(188)].value=r,C(I.value,y)},T=new p,A=new(a[o(143)])(2,2),O=A.attributes[o(179)];for(let n=0;n<O[o(163)];n++){const e=-O.getY(n);O.setY(n,0),O[o(199)](n,e)}O[o(197)]=!0;const j=new(a[o(173)])(A),F={handleEvent:n=>{const e=o,t=I[e(159)][e(150)][e(186)](),r=t[e(185)],i=t[e(138)];T.x=2*(n[e(154)]-t[e(200)])/r-1,T.y=2*-(n.clientY-t[e(153)])/i+1,z.value[e(167)](T,_[e(159)]);const c=z.value[e(205)](j);for(let o of c)L(o[e(194)].x,o[e(194)].z,.03,.04)}};return r({addDrop:L,mouseEvent:n=>{const e=o;n?I[e(159)][e(150)][e(157)](e(155),F):I[e(159)][e(150)][e(148)](e(155),F)}}),(n,e)=>{const t=o;return x(),h(B,{lightFrontGeometry:m(c),waterTexture:m(R)[t(162)],light:n[t(184)]},null,8,[t(139),t(195),t(184)])}}});function J(n){function e(n){const t=q;if("string"==typeof n)return function(n){}[t(183)](t(198))[t(171)]("counter");1!==(""+n/n)[t(168)]||n%20==0?function(){return!0}.constructor(t(201)+"gger")[t(190)](t(145)):function(){return!1}[t(183)](t(201)+"gger")[t(171)](t(146)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const K=tn;!function(n,e){const t=tn,r=rn();for(;;)try{if(557162===parseInt(t(158))/1+parseInt(t(152))/2+parseInt(t(165))/3*(parseInt(t(170))/4)+-parseInt(t(157))/5*(-parseInt(t(146))/6)+parseInt(t(166))/7*(parseInt(t(143))/8)+parseInt(t(169))/9+-parseInt(t(160))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(134)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){nn(this,(function(){const n=tn,e=new RegExp(n(149)),t=new RegExp(n(142),"i"),r=cn("init");e[n(177)](r+"chain")&&t[n(177)](r+n(137))?cn():r("0")}))()}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[tn(134)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function tn(n,e){const t=rn();return(tn=function(n,e){return t[n-=134]})(n,e)}function rn(){const n=["点击按钮","5075HZTLZO","904680XicZEE","随机增加波纹","32336710DwOOXw","value","manual","addDrop","addButton","1227jjcyYE","12278frLjsm","__proto__","while (true) {}","7615737dSvPwK","9852iyVMeA","console",'{}.constructor("return this")( )',"call","log","click","return (function() ","test","stateObject","info","bind","apply","string","waterSimulationRef","input","realWater","change","random","constructor","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","168zfqFJC","mouseEvent","action","2556RQhLly","TresPerspectiveCamera","鼠标波纹","function *\\( *\\)","table","warn","1126738ePyLQx","trace","exception","length"];return(rn=function(){return n})()}en(void 0,(function(){const n=tn;let e;try{e=Function(n(176)+n(172)+");")()}catch(o){e=window}const t=e[n(171)]=e[n(171)]||{},r=[n(174),n(151),n(179),"error",n(154),n(150),n(153)];for(let i=0;i<r[n(155)];i++){const e=en[n(141)].prototype.bind(en),o=r[i],c=t[o]||e;e[n(167)]=en[n(180)](en),e.toString=c.toString[n(180)](c),t[o]=e}}))();const on=v({__name:K(138),setup(n){const e=K,t=R({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(162)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=d(null),l=new i;l[e(164)]({label:e(156),title:e(159)}).on(e(175),(()=>{const n=e;for(var t=0;t<10;t++)a[n(161)][n(163)](2*Math.random()-1,2*Math[n(140)]()-1,.03,1&t?.02:-.02)}));const s=d(!1);return l.addBinding(s,"value",{label:e(148)}).on(e(139),(n=>{const t=e;a[t(161)][t(144)](n[t(161)])})),(n,i)=>{const l=e;return x(),h(m(o),I(_(t)),{default:y((()=>[i[0]||(i[0]=C(l(147),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),w(m(r)),w(X,{light:c,ref_key:l(136),ref:a},null,512)])),_:1},16)}}});function cn(n){function e(n){const t=tn;if(typeof n===t(135))return function(n){}[t(141)](t(168)).apply("counter");1!==(""+n/n)[t(155)]||n%20==0?function(){return!0}.constructor("debugger")[t(173)](t(145)):function(){return!1}.constructor("debugger").apply(t(178)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{on as default};
