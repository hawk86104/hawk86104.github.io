import{m as e,Q as t,Z as a,e as r,J as n,a as i,H as l}from"./@tresjs.CnmCKMfV1751615890160.js";import"./index.PTppoOOJ1751615890160.js";import{n as o,a as s,aQ as u,aR as p,a5 as h,u as d,N as v,r as c,_ as m,aA as f,B as g,c as x,l as M,aO as _,E as S,aG as w,C as y,M as D,q as b,t as U,V as T,h as B,X as E,aE as P,aF as R,ay as F,A as z,aU as C}from"./three.-xXgCQua1751615890160.js";import{d as A,a as j,v as k,w as W,A as L,G as I,o as O,m as G,u as N,b as $,I as q,L as H,a3 as V,j as J,f as Q,F as X,a2 as Z,a4 as K,r as Y,t as ee,e as te,H as ae,ak as re,al as ne,am as ie}from"./@vue.Mugdq9o81751615890160.js";import{E as le,R as oe,B as se,G as ue,a as pe}from"./postprocessing.CkX0KHoZ1751615890160.js";import"./@vueuse.DfywP5Cl1751615890160.js";import"./object-hash.Buz3XByS1751615890160.js";import"./@amap.CGUF9xH41751615890160.js";import"./jszip.BAodBTnl1751615890160.js";const he=(()=>Number.parseInt(h.replace(/\D+/g,"")))();class de extends o{constructor(e=new s){super({uniforms:{inputBuffer:new p(null),depthBuffer:new p(null),resolution:new p(new s),texelSize:new p(new s),halfTexelSize:new p(new s),kernel:new p(0),scale:new p(1),cameraNear:new p(0),cameraFar:new p(1),depthEdge0:new p(0),depthEdge1:new p(1),depthScale:new p(0),depthBias:new p(.25)},fragmentShader:`#include <common>\n        #include <dithering_pars_fragment>      \n        uniform sampler2D inputBuffer;\n        uniform sampler2D depthBuffer;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float depthEdge0;\n        uniform float depthEdge1;\n        uniform float depthScale;\n        uniform float depthBias;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          float depthFactor = 0.0;\n          \n          #ifdef USE_DEPTH\n            vec4 depth = texture2D(depthBuffer, vUv);\n            depthFactor = smoothstep(\n              1.0 - depthEdge1, 1.0 - depthEdge0,\n              1.0 - (depth.r * depth.a) + depthBias\n            );\n            depthFactor = clamp(depthScale * depthFactor + 0.25, 0.0, 1.0);\n          #endif\n\n          gl_FragColor = 0.25 * (\n            texture2D(inputBuffer, mix(vUv0, vUv, depthFactor))\n            + texture2D(inputBuffer, mix(vUv1, vUv, depthFactor))\n            + texture2D(inputBuffer, mix(vUv2, vUv, depthFactor))\n            + texture2D(inputBuffer, mix(vUv3, vUv, depthFactor))\n          );\n          \n          #include <dithering_fragment>\n          #include <tonemapping_fragment>\n          #include <${he>=154?"colorspace_fragment":"encodings_fragment"}>\n        }`,vertexShader:"uniform vec2 texelSize;\n        uniform vec2 halfTexelSize;\n        uniform float kernel;\n        uniform float scale;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          vec2 uv = position.xy * 0.5 + 0.5;\n          vUv = uv;\n\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0);\n        }",blending:u,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}class ve{constructor({resolution:e,width:t=500,height:a=500,depthEdge0:r=0,depthEdge1:n=1,depthScale:i=0,depthBias:l=.25}){this.renderToScreen=!1,this.renderTargetA=new d(e,e,{minFilter:c,magFilter:c,stencilBuffer:!1,depthBuffer:!1,type:v}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new de,this.convolutionMaterial.setTexelSize(1/t,1/a),this.convolutionMaterial.setResolution(new s(t,a)),this.scene=new m,this.camera=new f,this.convolutionMaterial.uniforms.depthEdge0.value=r,this.convolutionMaterial.uniforms.depthEdge1.value=n,this.convolutionMaterial.uniforms.depthScale.value=i,this.convolutionMaterial.uniforms.depthBias.value=l,this.convolutionMaterial.defines.USE_DEPTH=i>0;const o=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),u=new Float32Array([0,0,2,0,0,2]),p=new g;p.setAttribute("position",new x(o,3)),p.setAttribute("uv",new x(u,2)),this.screen=new M(p,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,a){const r=this.scene,n=this.camera,i=this.renderTargetA,l=this.renderTargetB,o=this.convolutionMaterial,s=o.uniforms;s.depthBuffer.value=t.depthTexture;const u=o.kernel;let p,h,d,v=t;for(h=0,d=u.length-1;h<d;++h)p=1&h?l:i,s.kernel.value=u[h],s.inputBuffer.value=v.texture,e.setRenderTarget(p),e.render(r,n),v=p;s.kernel.value=u[h],s.inputBuffer.value=v.texture,e.setRenderTarget(this.renderToScreen?null:a),e.render(r,n)}dispose(){this.screen.material.dispose(),this.screen.geometry.dispose(),this.renderTargetA.dispose(),this.renderTargetB.dispose(),this.convolutionMaterial.dispose()}}class ce extends _{constructor(e={}){super(e),this._tDepth={value:null},this._distortionMap={value:null},this._tSharp={value:null},this._tBlur={value:null},this._textureMatrix={value:null},this._mix={value:.5},this._sharpMix={value:0},this._blurMixSmooth={value:0},this._blurMixRough={value:0},this._sharpDepthEdgeMin={value:.9},this._sharpDepthEdgeMax={value:1},this._sharpDepthScale={value:0},this._sharpDepthBias={value:0},this._distortion={value:1},this.setValues(e)}onBeforeCompile(e){e.defines?.USE_UV||(e.defines.USE_UV="");for(const t of Object.keys(e.defines))e.defines[t.toUpperCase()]=e.defines[t];e.uniforms.tSharp=this._tSharp,e.uniforms.tDepth=this._tDepth,e.uniforms.tBlur=this._tBlur,e.uniforms.distortionMap=this._distortionMap,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mixMain=this._mix,e.uniforms.sharpMix=this._sharpMix,e.uniforms.sharpDepthScale=this._sharpDepthScale,e.uniforms.sharpDepthEdgeMin=this._sharpDepthEdgeMin,e.uniforms.sharpDepthEdgeMax=this._sharpDepthEdgeMax,e.uniforms.sharpDepthBias=this._sharpDepthBias,e.uniforms.blurMixSmooth=this._blurMixSmooth,e.uniforms.blurMixRough=this._blurMixRough,e.uniforms.distortion=this._distortion,e.vertexShader=`\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;\n      ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace("#include <project_vertex>","#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );"),e.fragmentShader=`\n        uniform sampler2D tSharp;\n        uniform sampler2D tBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float mixMain;\n        uniform float sharpMix;\n        uniform float blurMixSmooth;\n        uniform float blurMixRough;\n        uniform float sharpDepthScale;\n        uniform float sharpDepthBias;\n        uniform float sharpDepthEdgeMin;\n        uniform float sharpDepthEdgeMax;\n        varying vec4 my_vUv;\n        ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>","#include <emissivemap_fragment>\n\n      vec4 new_vUv = my_vUv;\n\n      #ifdef USE_DISTORTION\n        float distortionFactor = (texture(distortionMap, vUv).r - 0.5) * distortion;\n        new_vUv.x += distortionFactor;\n        new_vUv.y += distortionFactor;\n      #endif\n\n      #ifdef USE_NORMALMAP\n\n        vec4 normalColor = texture(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        vec2 normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n\n        vec4 sharp = texture(tSharp, normal_uv);\n\n        #ifdef USE_BLUR\n          vec4 blur = texture(tBlur, normal_uv);\n        #endif\n\n        #ifdef USE_DEPTH\n          vec4 depth = texture(tDepth, normal_uv);\n        #endif\n\n      #else\n\n        vec4 sharp = textureProj(tSharp, new_vUv);\n\n        #ifdef USE_BLUR\n          vec4 blur = textureProj(tBlur, new_vUv);\n        #endif\n\n        #ifdef USE_DEPTH\n          vec4 depth = textureProj(tDepth, new_vUv);\n        #endif\n\n      #endif\n\n      #ifdef USE_DEPTH\n        float depthFactor = smoothstep(\n          1.0 - sharpDepthEdgeMax, 1.0 - sharpDepthEdgeMin,\n          1.0 - (depth.r * depth.a) + sharpDepthBias\n        );\n        depthFactor = clamp(sharpDepthScale * depthFactor, 0.0, 1.0);\n\n        sharp *= depthFactor;\n      #endif\n\n      sharp *= (1.0 - roughnessFactor);\n      "),e.fragmentShader=e.fragmentShader.replace("#include <opaque_fragment>","\n\n      #ifdef USE_BLUR\n        outgoingLight += mixMain * (\n          vec3(sharp) * sharpMix\n          + vec3(blur) * (blurMixSmooth * (1.0 - roughnessFactor) + blurMixRough * roughnessFactor)\n        );\n      #else\n        outgoingLight += mixMain * vec3(sharp) * sharpMix;\n      #endif\n\n      #include <opaque_fragment>\n      ")}get tSharp(){return this._tSharp.value}set tSharp(e){this._tSharp.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tBlur(){return this._tBlur.value}set tBlur(e){this._tBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get sharpMix(){return this._sharpMix.value}set sharpMix(e){this._sharpMix.value=e}get blurMixSmooth(){return this._blurMixSmooth.value}set blurMixSmooth(e){this._blurMixSmooth.value=e}get blurMixRough(){return this._blurMixRough.value}set blurMixRough(e){this._blurMixRough.value=e}get mix(){return this._mix.value}set mix(e){this._mix.value=e}get sharpDepthScale(){return this._sharpDepthScale.value}set sharpDepthScale(e){this._sharpDepthScale.value=e}get sharpDepthBias(){return this._sharpDepthBias.value}set sharpDepthBias(e){this._sharpDepthBias.value=e}get sharpDepthEdgeMin(){return this._sharpDepthEdgeMin.value}set sharpDepthEdgeMin(e){this._sharpDepthEdgeMin.value=e}get sharpDepthEdgeMax(){return this._sharpDepthEdgeMax.value}set sharpDepthEdgeMax(e){this._sharpDepthEdgeMax.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}}const me=["texture-matrix","t-sharp","t-depth","t-blur","defines-USE_BLUR","defines-USE_DEPTH","defines-USE_DISTORTION"],fe=A({__name:"index",props:{resolution:{default:256},mix:{default:1},sharpMix:{default:1},sharpDepthScale:{default:1},sharpDepthBias:{default:0},sharpDepthEdgeMin:{default:0},sharpDepthEdgeMax:{default:.2},blurMixSmooth:{default:1},blurMixRough:{default:1},blurDepthScale:{default:1},blurDepthBias:{default:0},blurDepthEdgeMin:{default:0},blurDepthEdgeMax:{default:.2},blurSize:{default:()=>[0,0]},distortionMap:{},distortion:{default:0},reflectorOffset:{default:0},color:{default:()=>new y(3355443)},roughness:{default:1},metalness:{default:0},map:{},lightMap:{},lightMapIntensity:{default:1},aoMap:{},aoMapIntensity:{default:1},emissive:{default:()=>new y(0)},emissiveIntensity:{default:1},emissiveMap:{},bumpMap:{},bumpScale:{default:1},normalMap:{},normalMapType:{default:w},normalScale:{default:()=>new s(1,1)},displacementMap:{},displacementScale:{default:1},displacementBias:{default:0},roughnessMap:{default:null},metalnessMap:{},alphaMap:{},envMap:{},envMapRotation:{default:()=>new S},envMapIntensity:{default:1},wireframe:{type:Boolean,default:!1},wireframeLinewidth:{default:1},wireframeLinecap:{default:"round"},wireframeLinejoin:{default:"round"},flatShading:{type:Boolean,default:!1},fog:{type:Boolean,default:!0}},setup(r,{expose:n}){const i=r,{extend:l,invalidate:o}=e();l({MeshReflectionMaterial:ce});const s=j((()=>500-(Array.isArray(i.blurSize)?i.blurSize[0]:i.blurSize))),u=j((()=>500-(Array.isArray(i.blurSize)?i.blurSize[1]:i.blurSize))),p=j((()=>s.value>0||u.value>0)),h=j((()=>i.sharpDepthScale>0||i.blurDepthScale>0)),m=j((()=>!!i.distortionMap)),f=j((()=>!!i.roughnessMap)),g=k();let x;const M={reflectorPlane:new B,normal:new T,reflectorWorldPosition:new T,cameraWorldPosition:new T,rotationMatrix:new D,lookAtPosition:new T(0,0,-1),clipPlane:new U,view:new T,target:new T,q:new U,virtualCamera:new b,textureMatrix:new D},_=new d(i.resolution,i.resolution,{minFilter:c,magFilter:c,type:v,depthBuffer:!0,depthTexture:new E(i.resolution,i.resolution)}),S=new d(i.resolution,i.resolution,{minFilter:c,magFilter:c,type:v});return W((()=>[i.resolution]),(()=>{_.setSize(i.resolution,i.resolution),S.setSize(i.resolution,i.resolution)})),W((()=>[i.resolution,s.value,u.value,i.blurDepthEdgeMin,i.blurDepthEdgeMax,i.blurDepthScale,i.blurDepthBias]),(()=>{x?.dispose(),x=new ve({resolution:i.resolution,width:s.value,height:u.value,depthEdge0:i.blurDepthEdgeMin,depthEdge1:i.blurDepthEdgeMax,depthScale:i.blurDepthScale,depthBias:i.blurDepthBias})}),{immediate:!0}),W((()=>[p.value]),(()=>{t().logWarning("MeshReflectionMaterial: Setting blurMixRough or blurMixSmooth to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials.")})),W(h,(()=>{t().logWarning("MeshReflectionMaterial: Setting depthScale to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials.")})),W(m,(()=>{t().logWarning("MeshReflectionMaterial: Toggling distortionMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.")})),W(f,(()=>{t().logWarning("MeshReflectionMaterial: Toggling roughnessMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.")})),W((()=>[i.normalMap]),(()=>{t().logWarning("MeshReflectionMaterial: Toggling normalMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.")})),L((()=>{_.dispose(),S.dispose(),x.dispose()})),a().onBeforeRender((({renderer:e,scene:t,camera:a,invalidate:r})=>{const n=g.value?.__tres?.parent;n&&(!function(e,t,a,r){o();const n=e.xr.enabled,l=e.shadowMap.autoUpdate;if(M.reflectorWorldPosition.setFromMatrixPosition(r.matrixWorld),M.cameraWorldPosition.setFromMatrixPosition(a.matrixWorld),M.rotationMatrix.extractRotation(r.matrixWorld),M.normal.set(0,0,1),M.normal.applyMatrix4(M.rotationMatrix),M.reflectorWorldPosition.addScaledVector(M.normal,i.reflectorOffset),M.view.subVectors(M.reflectorWorldPosition,M.cameraWorldPosition),M.view.dot(M.normal)>0)return;r.visible=!1,M.view.reflect(M.normal).negate(),M.view.add(M.reflectorWorldPosition),M.rotationMatrix.extractRotation(a.matrixWorld),M.lookAtPosition.set(0,0,-1),M.lookAtPosition.applyMatrix4(M.rotationMatrix),M.lookAtPosition.add(M.cameraWorldPosition),M.target.subVectors(M.reflectorWorldPosition,M.lookAtPosition),M.target.reflect(M.normal).negate(),M.target.add(M.reflectorWorldPosition),M.virtualCamera.position.copy(M.view),M.virtualCamera.up.set(0,1,0),M.virtualCamera.up.applyMatrix4(M.rotationMatrix),M.virtualCamera.up.reflect(M.normal),M.virtualCamera.lookAt(M.target),M.virtualCamera.far=a.far,M.virtualCamera.updateMatrixWorld(),M.virtualCamera.projectionMatrix.copy(a.projectionMatrix),M.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),M.textureMatrix.multiply(M.virtualCamera.projectionMatrix),M.textureMatrix.multiply(M.virtualCamera.matrixWorldInverse),M.textureMatrix.multiply(r.matrixWorld),M.reflectorPlane.setFromNormalAndCoplanarPoint(M.normal,M.reflectorWorldPosition),M.reflectorPlane.applyMatrix4(M.virtualCamera.matrixWorldInverse),M.clipPlane.set(M.reflectorPlane.normal.x,M.reflectorPlane.normal.y,M.reflectorPlane.normal.z,M.reflectorPlane.constant);const s=M.virtualCamera.projectionMatrix;M.q.x=(Math.sign(M.clipPlane.x)+s.elements[8])/s.elements[0],M.q.y=(Math.sign(M.clipPlane.y)+s.elements[9])/s.elements[5],M.q.z=-1,M.q.w=(1+s.elements[10])/s.elements[14],M.clipPlane.multiplyScalar(2/M.clipPlane.dot(M.q)),s.elements[2]=M.clipPlane.x,s.elements[6]=M.clipPlane.y,s.elements[10]=M.clipPlane.z+1,s.elements[14]=M.clipPlane.w,e.shadowMap.autoUpdate=!1,e.setRenderTarget(_),e.autoClear||e.clear(),e.render(t,M.virtualCamera),x.render(e,_,S),e.xr.enabled=n,e.shadowMap.autoUpdate=l,r.visible=!0,e.setRenderTarget(null)}(e,t,a,n),r())})),n({instance:g}),(e,t)=>(O(),I("TresMeshReflectionMaterial",G({key:`key${p.value?"0":"1"}${h.value?"0":"1"}${m.value?"0":"1"}${f.value?"0":"1"}`,ref_key:"materialRef",ref:g},i,{"texture-matrix":M.textureMatrix,"t-sharp":N(_)?.texture,"t-depth":N(_)?.depthTexture,"t-blur":N(S)?.texture,"defines-USE_BLUR":p.value?"":void 0,"defines-USE_DEPTH":h.value?"":void 0,"defines-USE_DISTORTION":m.value?"":void 0}),null,16,me))}});const ge=["object"],xe=A({__name:"index",props:{resolution:{default:256},near:{default:.1},far:{default:1e3},envMap:{default:null},fog:{default:null},frames:{default:1/0}},setup(t,{expose:a}){const n=t,{fbo:i,camera:l,update:o}=function({resolution:t=256,near:a=.1,far:r=1e3,envMap:n,fog:i}={}){const{renderer:l,scene:o}=e(),s=$(null),u=$(t),p=$(a),h=$(r),d=$(null);let c,m;return W((()=>u),(e=>{s.value?.dispose(),s.value=new P(e.value),s.value.texture.type=v}),{immediate:!0}),W([p,h,s],(([e,t,a])=>{a&&(d.value=new R(e,t,a))}),{immediate:!0}),L((()=>{s.value?.dispose()})),{fbo:s,camera:d,update:()=>{c=o.value.fog,m=o.value.background,o.value.background=n||m,o.value.fog=i||c,d.value?.update(l.value,o.value),o.value.fog=c,o.value.background=m}}}({resolution:n.resolution,near:n.near,far:n.far,envMap:n.envMap,fog:n.fog}),{onBeforeLoop:s}=r();let u=0;const p=$(null);return s((()=>{p.value&&(n.frames===1/0||u<n.frames)&&(p.value.visible=!1,o(),p.value.visible=!0,u++)})),a({texture:i.value?.texture}),(e,t)=>(O(),I("TresGroup",null,[q("primitive",{object:N(l)},null,8,ge),q("TresGroup",{ref_key:"rgRef",ref:p},[H(e.$slots,"default")],512)]))}}),Me=["map"],_e=["envMap"],Se=A({__name:"screen",async setup(e){let t,a;const r=$();r.value=([t,a]=V((()=>n("./plugins/visualArts/video/vlg.mp4",{loop:!0}))),t=await t,a(),t),r.value.colorSpace=F;const i=$(),l=$();W(i,(e=>{l.value=e.texture}));const o=$();return(e,t)=>(O(),I(X,null,[q("TresMesh",{ref_key:"tmSceen",ref:o,position:[0,0,-16]},[t[0]||(t[0]=q("TresPlaneGeometry",{args:[16,10]},null,-1)),q("TresMeshBasicMaterial",{map:r.value},null,8,Me),t[1]||(t[1]=q("TresMesh",{scale:[16.05,10.05,1],position:[0,0,-.01]},[q("TresPlaneGeometry"),q("TresMeshBasicMaterial",{color:"black"})],-1))],512),J(N(xe),{ref_key:"cubeCameraRef",ref:i,position:[-3,-1,-5],resolution:256},{default:Q((()=>[q("TresMesh",null,[t[2]||(t[2]=q("TresSphereGeometry",{args:[2,32,32]},null,-1)),q("TresMeshStandardMaterial",{metalness:1,roughness:.1,envMap:l.value},null,8,_e)])])),_:1},512)],64))}}),we=A({__name:"effectComposer",props:{screen:{}},setup(t){const a=t,{camera:n,renderer:i,scene:l,sizes:o}=e();let s=null,u=null;const p=[];Z((()=>{if(o.width.value){const e=n.value;((e,t,a)=>{s=new le(a,{frameBufferType:v,multisampling:8});const r=new oe(e,t);s.addPass(r)})(l.value,e,i.value,o.width.value,o.height.value),(e=>{const t=new z({color:16768426,transparent:!0,fog:!1}),r=new C(.75,32,32),n=new M(r,t);n.frustumCulled=!1,n.matrixAutoUpdate=!1;const i=new ue(e,K(a.screen),{blur:!0,decay:.8,exposure:.34});p.push(i)})(e),p.push(new se({luminanceThreshold:0,mipmapBlur:!0,luminanceSmoothing:0,intensity:1})),u=new pe(e,...p),s.addPass(u)}}));const{onAfterLoop:h}=r();return h((()=>{s&&s.render()})),(e,t)=>null}}),ye=["rotation"],De=A({__name:"volumetricLightGodray",setup(e){const t=Y({clearColor:"#050505",antialias:!1,renderMode:"manual"}),a=Y({enableDamping:!0}),r=$(null),n=$(null);return W((()=>r),(e=>{ee((()=>{e&&void 0!==e.value.$refs.tmSceen&&(n.value=e.value.$refs.tmSceen)}))}),{deep:!0}),(e,o)=>(O(),te(N(l),G(t,{"window-size":""}),{default:Q((()=>[o[1]||(o[1]=q("TresPerspectiveCamera",{position:[0,0,30],fov:45,near:.1,far:1e3},null,-1)),J(N(i),re(ne(a)),null,16),o[2]||(o[2]=q("TresAmbientLight",{intensity:.5},null,-1)),(O(),te(ie,null,{default:Q((()=>[J(Se,{ref_key:"screenRef",ref:r},null,512)])),_:1})),q("TresMesh",{position:[0,-5.02,0],receiveShadow:"",rotation:[-Math.PI/2,0,0]},[o[0]||(o[0]=q("TresPlaneGeometry",{args:[50,50]},null,-1)),J(N(fe),{blur:[300,50],resolution:1024,mixBlur:1,mixStrength:100,roughness:1,depthScale:1.2,minDepthThreshold:.4,maxDepthThreshold:1.4,color:"#202020",metalness:.8})],8,ye),n.value?(O(),te(we,{key:0,screen:n.value},null,8,["screen"])):ae("",!0)])),_:1},16))}});export{De as default};
