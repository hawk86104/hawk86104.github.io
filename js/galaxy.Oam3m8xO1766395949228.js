import{k as e,bK as n,ad as o,A as a,dc as t,j as s}from"./three.F31Lz30M1766395949228.js";import{$ as r,a0 as i,K as l}from"./@tresjs.DsQAOGDv1766395949228.js";import{d as u,a as m,w as d,g as c,G as v,o as h,h as p,u as f,e as w,I as g,a9 as P,aa as M,m as C,F as b}from"./@vue.BxPWGdWw1766395949228.js";import"./postprocessing.Rj820gp21766395949228.js";import"./@vueuse.D_OASVSl1766395949228.js";const y=["position","a-scale","color","a-randomness"],x=u({__name:"galaxy",setup(u){const x={clearColor:"black",shadows:!0,alpha:!1,shadowMapType:t,outputColorSpace:a,toneMapping:o,windowSize:!0},z={count:3e4,size:20,radius:5,branches:5,spin:4,randomness:.13,randomnessPower:7.5,insideColor:"#b5f28d",outsideColor:"#1b3984"},T=new e(z.insideColor),A=new e(z.outsideColor),S=new Float32Array(3*z.count),j=new Float32Array(3*z.count),F=new Float32Array(z.count),_=new Float32Array(3*z.count);for(let e=0;e<z.count;e++){const n=3*e,o=Math.random()*z.radius,a=e%z.branches*Math.PI*2/z.branches;S[n]=Math.cos(a)*o,S[n+1]=0,S[n+2]=Math.sin(a)*o;const t=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),s=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),r=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1);_[n]=t,_[n+1]=s,_[n+2]=r;const i=T.clone();i.lerp(A,o/z.radius),j[n+0]=i.r,j[n+1]=i.g,j[n+2]=i.b,F[e]=Math.random()}const k={transparent:!0,depthWrite:!1,blending:n,vertexColors:!0,vertexShader:"uniform float uSize;\nuniform float uTime;\n\nattribute float aScale;\nattribute vec3 aRandomness;\n\nvarying vec3 vColor;\n\nvoid main() {\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n\n    \n    float angle = atan(modelPosition.x, modelPosition.z);\n    float distanceToCenter = length(modelPosition.xz);\n    float angleOffset = (1.0 / distanceToCenter) * uTime * 0.2;\n    angle += angleOffset;\n\n    modelPosition.x = distanceToCenter * cos(angle);\n    modelPosition.z = distanceToCenter * sin(angle);\n\n    \n    modelPosition.xyz += aRandomness;\n\n    vec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectedPosition = projectionMatrix * viewPosition;\n    gl_Position = projectedPosition;\n\n    gl_PointSize = uSize * aScale;\n\n    \n    gl_PointSize *= ( 1.0 / - viewPosition.z);\n\n    \n    vColor = color;\n\n}",fragmentShader:"varying vec3 vColor;\n\nvoid main()\n{\n    \n    float strength = distance(gl_PointCoord, vec2(0.5));\n    strength = 1.0 - strength;\n    strength = pow(strength, 5.0);\n\n    \n    vec3 color = mix(vec3(0.0), vColor, strength);\n    gl_FragColor = vec4(color, 1.0);\n}",uniforms:{uTime:{value:0},uSize:{value:z.size}}};const R=m(null),I=({elapsed:e})=>{R.value&&(R.value.material.uniforms.uTime.value=e)},{count:O,size:G,radius:K,branches:B,spin:E,randomness:L,randomnessPower:W,insideColor:$,outsideColor:q}=r({count:{value:3e4,min:0,max:1e5,step:1},size:{value:20,min:.01,max:40,step:1},radius:{value:5,min:.1,max:20,step:.01},branches:{value:5,min:2,max:10,step:1},spin:{value:4,min:-5,max:5,step:.01},randomness:{value:.13,min:.1,max:.2,step:.01},randomnessPower:{value:7.5,min:1,max:10,step:.001},insideColor:"#b5f28d",outsideColor:"#1b3984"});return d([O.value,G.value,K.value,B.value,E.value,L.value,W.value,$.value,q.value],n=>{n.forEach((e,n)=>{z[Object.keys(z)[n]]=e.value}),function(){if(R.value){const n=new e(z.insideColor),o=new e(z.outsideColor),a=new Float32Array(3*z.count),t=new Float32Array(3*z.count),r=new Float32Array(z.count),i=new Float32Array(3*z.count);for(let e=0;e<z.count;e++){const s=3*e,l=Math.random()*z.radius,u=e%z.branches*Math.PI*2/z.branches;a[s]=Math.cos(u)*l,a[s+1]=0,a[s+2]=Math.sin(u)*l;const m=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),d=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),c=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1);i[s]=m,i[s+1]=d,i[s+2]=c;const v=n.clone();v.lerp(o,l/z.radius),t[s+0]=v.r,t[s+1]=v.g,t[s+2]=v.b,r[e]=Math.random()}R.value.geometry.setAttribute("position",new s(a,3)),R.value.geometry.setAttribute("aRandomness",new s(i,3)),R.value.geometry.setAttribute("color",new s(t,3)),R.value.geometry.setAttribute("aScale",new s(r,1))}}()}),(e,n)=>{const o=c("TresCanvas");return h(),v(b,null,[p(f(i)),p(o,C(x,{onLoop:I}),{default:w(()=>[n[0]||(n[0]=g("TresPerspectiveCamera",{position:[3,3,3]},null,-1)),g("TresPoints",{ref_key:"bufferRef",ref:R},[g("TresBufferGeometry",{position:[f(S),3],"a-scale":[f(F),1],color:[f(j),3],"a-randomness":[f(_),3]},null,8,y),g("TresShaderMaterial",P(M(k)),null,16)],512),p(f(l))]),_:1},16)],64)}}});export{x as default};
