import{_ as o}from"./@tresjs.BCHtwiaC1763540743861.js";import{d as e,a6 as i,H as r,o as t}from"./@vue.Co_gxueH1763540743861.js";import{ae as a,l as n}from"./three.rXKzP9fQ1763540743861.js";import"./postprocessing.51l5tmA-1763540743861.js";import"./@vueuse.CfFJ-iFV1763540743861.js";const l=["object"],u=e({__name:"buildingsModelIncompatible",props:{model:{},bulidingsColor:{default:"#EC5BFF"},landColor:{default:"#112233"},opacity:{default:.9}},setup(e){const u=e,m={value:0},d=u.model.city,s=u.model.land,f=(o,e)=>{let i;"cu"===o?(i=Array.isArray(d.material)?d.material:[d.material],i.forEach(o=>{"color"===e?o[e].setStyle(u.bulidingsColor):"opacity"===e&&(o.opacity=u.opacity,o.transparent=!0),o.side=a})):"land"===o&&(i=Array.isArray(s.material)?s.material:[s.material],i.forEach(o=>{o[e].setStyle(u.landColor),o.side=a}))};(()=>{const{geometry:o}=d;o.computeBoundingBox(),o.computeBoundingSphere();const{max:e,min:i}=o.boundingBox;(Array.isArray(d.material)?d.material:[d.material]).forEach(o=>{o.onBeforeCompile=o=>{o.uniforms.uMax={value:e},o.uniforms.uMin={value:i},o.uniforms.uLightColor={value:new n("#ffffff")},o.uniforms.uBorderWidth={value:5},o.uniforms.uCircleTime={value:5},o.uniforms.uTime=m;o.vertexShader=o.vertexShader.replace("void main() {","\n\tvarying vec4 vPosition;\n\tvoid main() {\n\t\t vPosition = modelMatrix * vec4(position,1.0);\n");o.fragmentShader=o.fragmentShader.replace("void main() {","\n\tuniform mat4 modelMatrix;\n  varying vec4 vPosition;\n\tuniform vec3 uMax; \n\tuniform vec3 uMin; \n\tuniform float uBorderWidth; \n\tuniform vec3 uLightColor;\n\tuniform float uCircleTime; \n\tuniform float uTime; \n\tvec4 uMax_world;\n\tvec4 uMin_world;\n\n\tvoid main() {\n\t\t// 转世界坐标\n\t\tuMax_world =  modelMatrix * vec4(uMax,1.0);\n\t\tuMin_world =  modelMatrix * vec4(uMin,1.0);\n"),o.fragmentShader=o.fragmentShader.replace("#include <tonemapping_fragment>","\n#include <dithering_fragment>\n\tvec3 distColor = outgoingLight;\n\tfloat residue = uTime - floor(uTime / uCircleTime) * uCircleTime;\n\tfloat rate = residue / uCircleTime;\n\tfloat lightOffset = rate * (uMax_world.y - uMin_world.y);\n\n\tif (uMin_world.y + lightOffset < vPosition.y && uMin_world.y + lightOffset + uBorderWidth > vPosition.y) {\n\t\tgl_FragColor = vec4(uLightColor, diffuseColor.a);\n\t} else {\n\t\tgl_FragColor = vec4(distColor, diffuseColor.a);\n\t}\n")}})})();const{onBeforeRender:c}=o();return c(({delta:o})=>{m.value+=o}),i(()=>{u.bulidingsColor&&f("cu","color"),u.landColor&&f("land","color"),u.opacity&&f("cu","opacity")}),(o,e)=>(t(),r("primitive",{object:u.model.model.clone()},null,8,l))}});export{u as default};
