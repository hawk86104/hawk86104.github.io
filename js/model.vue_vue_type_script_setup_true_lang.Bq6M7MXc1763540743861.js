import{u as e}from"./index.Crdf3MNx1763540743861.js";import{n as o,c as a}from"./colors.D1dba6jQ1763540743861.js";import{g as r}from"./gsap.CY1N3EIL1763540743861.js";import{_ as n}from"./@tresjs.BCHtwiaC1763540743861.js";import{d as t,a as l,q as u,H as s,I as m,o as i,u as c,J as _}from"./@vue.Co_gxueH1763540743861.js";import{f as d,l as v}from"./three.rXKzP9fQ1763540743861.js";const f=["rotation","position"],p=["rotation"],g=["geometry","material"],h=["geometry","material"],x=t({__name:"model",setup(t,{expose:x}){let y,w;const S=l(!1);u(async()=>{const{nodes:a,materials:r}=await e("https://opensource.cdn.icegl.cn/model/eCommerce/energy-can.glb");y=a,w=r,w.Body.metalness=0,w.Body.roughness=1,w.Body.onBeforeCompile=e=>{e.uniforms=Object.assign(e.uniforms,k),e.vertexShader=e.vertexShader.replace("#include <common>","\n          #include <common>\n          varying vec2 vUv;\n        "),e.vertexShader=e.vertexShader.replace("#include <begin_vertex>","\n          #include <begin_vertex>\n          vUv = uv;\n        "),e.fragmentShader=e.fragmentShader.replace("#include <common>",`\n          #include <common>\n          uniform float u_time;\n          uniform vec3 u_color1;\n          uniform vec3 u_color2;\n          uniform float u_progress;\n          uniform float u_width;\n          uniform float u_scaleX;\n          uniform float u_scaleY;\n          uniform vec2 u_textureSize;\n          varying vec2 vUv;\n          ${o}\n          float parabola( float x, float k ) {\n            return pow( 4. * x * ( 1. - x ), k );\n          }\n      `),e.fragmentShader=e.fragmentShader.replace("#include <color_fragment>","\n          #include <color_fragment>\n            float aspect = u_textureSize.x/u_textureSize.y;\n            float dt = parabola(u_progress,1.);\n            float border = 1.;\n            float noise = 0.5*(cnoise(vec4(vUv.x*u_scaleX  + 0.5*u_time/3., vUv.y*u_scaleY,0.5*u_time/3.,0.)) + 1.);\n            float w = u_width*dt;\n            float maskValue = smoothstep(1. - w,1.,vUv.y + mix(-w/2., 1. - w/2., u_progress));\n            maskValue += maskValue * noise;\n            float mask = smoothstep(border,border+0.01,maskValue);\n            diffuseColor.rgb += mix(u_color1,u_color2,mask);\n        ")},k.u_textureSize.value=new d(w.Body.map.source.data.width,w.Body.map.source.data.height),S.value=!0});const k={u_time:{value:0},u_color1:{value:new v(a[0])},u_color2:{value:new v(a[1])},u_progress:{value:.5},u_width:{value:.8},u_scaleX:{value:50},u_scaleY:{value:50},u_textureSize:{value:new d(0,0)}};let b=0;let B=l(0);const{onBeforeRender:j}=n();return j(({elapsed:e})=>{B.value=.12*Math.sin(e),k.u_time.value=e}),x({onClick:function(){++b>=a.length&&(b=0),console.log("model colorIndex",b);let e=new v(a[b]);k.u_color2.value=e;const o=k.u_progress;r.killTweensOf(o),o.value=.5,r.to(o,{duration:1.5,ease:"power1.out",value:1,onComplete:()=>{k.u_color1.value=e}})}}),(e,o)=>S.value?(i(),s("TresGroup",{key:0,rotation:[-Math.PI/2,1.7,Math.PI/2],position:[0,c(B),5]},[_("TresGroup",{rotation:[-Math.PI/2,0,0]},[_("TresMesh",{geometry:c(y).LowRes_Can_Alluminium_0.geometry,material:c(w).Alluminium},null,8,g),_("TresMesh",{geometry:c(y).LowRes_Can_Body_0.geometry,material:c(w).Body},null,8,h)],8,p)],8,f)):m("",!0)}});export{x as _};
