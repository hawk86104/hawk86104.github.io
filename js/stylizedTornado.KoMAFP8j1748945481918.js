import{P as e}from"./tweakpane.C0HtAJSg1748945481918.js";import{i as o}from"./index.BtHogETy1748945481918.js";import{b as n}from"./pagesShow.vue_vue_type_script_setup_true_lang.C59LJHCL1748945481918.js";import{e as l}from"./@tresjs.Fe0mFN5V1748945481918.js";import{d as a,w as r,G as t,o as i,ak as s,al as f,b as u,I as c,j as d,u as p,r as m,f as v,e as h,H as g,m as w,F as C}from"./@vue.C_fjx3FT1748945481918.js";import{C as y,ab as O,a as T}from"./three.Bg9S6UMF1748945481918.js";import{l as b}from"./yangyangLoading.BHzQTI_h1748945481918.js";import"./utils.CgbmMZAd1748945481918.js";import"./@fesjs.C-LkgHF-1748945481918.js";import"./vue-router.w-0wu-F31748945481918.js";import"./lodash-es.C7pWAXPe1748945481918.js";import"./@qlin.q6OWdsQV1748945481918.js";import"./pinia.BlZ7d4KF1748945481918.js";import"./@babel.BPq7uOAK1748945481918.js";import"./@floating-ui.BFjFSAYt1748945481918.js";import"./@juggle.CcBCnTIR1748945481918.js";import"./three-mesh-ui.module.CqXY-Phf1748945481918.js";import"./three-custom-shader-material.Dfz3g2j31748945481918.js";import"./buildingsCustomShaderMaterial.DyBo--wu1748945481918.js";import"./postprocessing.meaIGyM81748945481918.js";import"./@vueuse.C8008KiJ1748945481918.js";const S=a({__name:"meshSpiralMaterial",props:{frontColor:{default:"#320564"},backColor:{default:"#ec22ff"},intensity:{default:1.5},powerOffset:{default:4},noiseCutOff:{default:.32},colorBoth:{type:Boolean,default:!1}},setup(e){const n=e,a=o.getItem("noiseVoronoi.png"),u={uniforms:{uTime:{value:0},uFrontColor:{value:new y(n.frontColor)},uBackColor:{value:new y(n.backColor).multiplyScalar(n.intensity)},uNoise:{value:a},uPowerOffset:{value:n.powerOffset},uNoiseCutOff:{value:n.noiseCutOff},uColorBoth:{value:n.colorBoth}},vertexShader:"out vec2 vUv;\n\nvoid main()\n{\n    \n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    vUv = uv;\n    \n}",fragmentShader:"uniform float uTime;\nuniform vec3 uFrontColor;\nuniform vec3 uBackColor;\nuniform sampler2D uNoise;\nuniform float uPowerOffset;\nuniform float uNoiseCutOff;\nuniform bool uColorBoth;\n\nin vec2 vUv;\n\nvoid clip( float clipValue, float alphaThreshold, int type )\n{\n    \n    switch( type )\n    {\n        case 0: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n\n        case 1: \n            if( clipValue > alphaThreshold ) discard;\n        break;\n\n        case 2: \n            if( clipValue <= alphaThreshold ) discard;\n        break;\n\n        case 3: \n            if( clipValue >= alphaThreshold ) discard;\n        break;\n\n        case 4: \n            if( clipValue == alphaThreshold ) discard;\n        break;\n\n        default: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n    }\n}\nvec2 tileOffset( vec2 uv , vec2 tiling, vec2 offset )\n{\n    return  uv * tiling + offset;\n}\n\nvoid main()\n{\n    vec2 uv = vUv;\n\n    vec2 timeOffset = vec2( uTime * 0.6, 0.0 );\n\n    \n\n    \n    vec3 noiseVoronoi = texture( uNoise, uv ).rgb;\n\n    float uvCutOff = uv.y;\n\n    uvCutOff = smoothstep( 0.02, 1.0, uvCutOff + 0.2  );\n\n    \n    float noiseCutOff = pow( noiseVoronoi.r, uPowerOffset );\n\n    \n\n    \n    vec3 colorFront = uFrontColor;\n    colorFront *= noiseCutOff;\n\n    vec3 colorBack = uBackColor;\n    colorBack *= noiseCutOff;\n\n    \n    vec3 colorFinal = colorFront;\n\n    if( uColorBoth )\n    {\n        colorFinal = ( ( gl_FrontFacing ) ? colorFront : colorBack );\n    }\n\n    \n    clip( noiseCutOff, uNoiseCutOff, 0 );\n\n    gl_FragColor = vec4( colorFinal, noiseCutOff * uvCutOff );\n    \n\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n\n}",transparent:!0,side:O,depthWrite:!0,depthTest:!0},{onLoop:c}=l();return c((({delta:e})=>{u.uniforms.uTime.value+=e})),r((()=>[n.frontColor,n.backColor]),(([e,o])=>{u.uniforms.uFrontColor.value.setStyle(e),u.uniforms.uBackColor.value.setStyle(o).multiplyScalar(n.intensity)})),(e,o)=>(i(),t("TresShaderMaterial",s(f(u)),null,16))}}),x=["geometry"],k=a({__name:"highlightMiddle",props:{frontColor:{default:"#111111"},backColor:{default:"#ff810c"}},setup(e){const n=u(null),{nodes:a}=o.getItem("spiral-middle.glb"),{onLoop:r}=l();return r((({delta:e,elapsed:o})=>{if(n.value){const l=3.4*o,a=.2*Math.sin(l)+.8;n.value.rotation.y+=6*e,n.value.scale.set(a,a,a)}})),(e,o)=>(i(),t("TresGroup",null,[c("TresMesh",{ref_key:"meshRef",ref:n,geometry:p(a).Cylinder.geometry,renderOrder:999991},[d(S,{frontColor:e.frontColor,backColor:e.backColor,intensity:2.7,powerOffset:12,colorBoth:""},null,8,["frontColor","backColor"])],8,x)]))}});const _=a({__name:"meshTornadoMaterial",props:{colorBase:{default:"#ff821c"},colorIntensity:{default:12},twirlAmount:{default:8},radialShearAmount:{default:new T(5,5)},twirlOffset:{default:new T(0,.5)},radialOffset:{default:new T(0,.5)},twirlCenter:{default:new T(.5,-.5)},radialCenter:{default:new T(.5,.5)},noisePower:{default:1},alphaThreshold:{default:.17},showEdge:{type:Boolean,default:!1}},setup(e){const o=e,n={uniforms:{uTime:{value:0},uColor:{value:new y(o.colorBase).multiplyScalar(o.colorIntensity)},uTwirl:{value:o.twirlAmount},uRadialShear:{value:o.radialShearAmount},uTwirlOffset:{value:o.twirlOffset},uRadialOffset:{value:o.radialOffset},uTwirlCenter:{value:o.twirlCenter},uRadialCenter:{value:o.radialCenter},uNoisePower:{value:o.noisePower},uAlphaThreshold:{value:o.alphaThreshold},uEdge:{value:o.showEdge}},vertexShader:"out vec2 vUv;\n\nvoid main()\n{\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    vUv = uv;\n}",fragmentShader:"uniform float uTime;\nuniform vec3 uColor;\nuniform float uTwirl;\nuniform vec2 uRadialShear;\nuniform vec2 uTwirlOffset;\nuniform vec2 uRadialOffset;\nuniform vec2 uTwirlCenter;\nuniform vec2 uRadialCenter;\nuniform float uNoisePower;\nuniform float uAlphaThreshold;\nuniform bool uEdge;\n\nin vec2 vUv;\n\nvoid clip( float clipValue, float alphaThreshold, int type )\n{\n    \n    switch( type )\n    {\n        case 0: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n\n        case 1: \n            if( clipValue > alphaThreshold ) discard;\n        break;\n\n        case 2: \n            if( clipValue <= alphaThreshold ) discard;\n        break;\n\n        case 3: \n            if( clipValue >= alphaThreshold ) discard;\n        break;\n\n        case 4: \n            if( clipValue == alphaThreshold ) discard;\n        break;\n\n        default: \n            if( clipValue < alphaThreshold ) discard;\n        break;\n    }\n}\nvec2 twirl(vec2 uv, vec2 center, float strength, vec2 offset)\n{\n    vec2 delta = uv - center;\n    float angle = strength * length(delta);\n    float x = cos(angle) * delta.x - sin(angle) * delta.y;\n    float y = sin(angle) * delta.x + cos(angle) * delta.y;\n    return vec2(x + center.x + offset.x, y + center.y + offset.y);\n}\nvec2 radialShear( vec2 uv, vec2 center, float strength, vec2 offset )\n{\n    vec2 delta = uv - center;\n    float delta2 = dot( delta.xy, delta.xy );\n\n    float deltaOffset = delta2 * strength;\n\n    return uv + vec2( delta.y, -delta.x) * deltaOffset + offset;\n}\n\nvec2 radialShear( vec2 uv, vec2 center, vec2 strength, vec2 offset )\n{\n    vec2 delta = uv - center;\n    vec2 delta2 =  vec2( dot( delta.xy, delta.xy ) );\n\n    vec2 deltaOffset = delta2 * strength;\n\n    return uv + vec2( delta.y, -delta.x) * deltaOffset + offset;\n}\nfloat randomSimple(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat interpolate( float a, float b, float t )\n{\n    return ( 1.0 - t ) * a + ( t * b );\n}\n\nfloat valueNoise( vec2 uv )\n{\n    vec2 i = floor( uv );\n    vec2 f = fract( uv );\n    f = f * f * ( 3.0 - 2.0 * f );\n\n    uv = abs( fract( uv ) - 0.5 );\n    vec2 c0 = i + vec2(0.0, 0.0);\n    vec2 c1 = i + vec2(1.0, 0.0);\n    vec2 c2 = i + vec2(0.0, 1.0);\n    vec2 c3 = i + vec2(1.0, 1.0);\n    float r0 = randomSimple(c0);\n    float r1 = randomSimple(c1);\n    float r2 = randomSimple(c2);\n    float r3 = randomSimple(c3);\n\n    float bottomOfGrid = interpolate(r0, r1, f.x);\n    float topOfGrid = interpolate(r2, r3, f.x);\n    float t = interpolate(bottomOfGrid, topOfGrid, f.y);\n    return t;\n}\n\nfloat noiseSimple( vec2 UV, float Scale )\n{\n    float t = 0.0;\n\n    float freq = pow(2.0, float(0));\n    float amp = pow(0.5, float(3-0));\n    t += valueNoise(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    freq = pow(2.0, float(1));\n    amp = pow(0.5, float(3-1));\n    t += valueNoise(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    freq = pow(2.0, float(2));\n    amp = pow(0.5, float(3-2));\n    t += valueNoise(vec2(UV.x * Scale / freq, UV.y * Scale / freq ) ) * amp;\n\n    return t;\n}\nfloat remap( float value, float min1, float max1, float min2, float max2 ) \n{\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main()\n{\n\n    vec2 uv = vUv;\n    float time = uTime;\n\n    vec2 twirlOffset = vec2( time * uTwirlOffset.x, time * uTwirlOffset.y );\n    vec2 radialOffset = vec2( time * uRadialOffset.x, time * uRadialOffset.y );\n\n    float uvCutOff = uv.y;\n    uvCutOff = smoothstep( 0.2, 1.0, uvCutOff + 0.2 );\n\n    vec2 uvRadial = radialShear( uv, uRadialCenter, uRadialShear, radialOffset );\n    vec2 uvTwirl = twirl( uv, uTwirlCenter, uTwirl, twirlOffset );\n\n    float noiseRadial = noiseSimple( uvRadial, 20.0 );\n    float noiseTwirl = noiseSimple( uvTwirl, 20.0 );\n\n    float noise = noiseRadial * noiseTwirl;\n\n    noise = pow( noise, uNoisePower );\n\n    float dissolve = remap( noise, 0.0, 1.0, 1.0, 0.0 );\n\n    vec3 colorFinal = uColor;\n    colorFinal *= noise;\n\n    clip( noise, uAlphaThreshold, 0 );\n\n    vec4 color = vec4( colorFinal, dissolve );\n\n    if( uEdge )\n    {\n        color.a *= uvCutOff;\n    }\n\n    gl_FragColor = color;\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n\n}",transparent:!0,side:O,depthWrite:!0,depthTest:!0},{onLoop:a}=l();return a((({delta:e})=>{n.uniforms.uTime.value+=e})),r((()=>o.colorBase),(e=>{n.uniforms.uColor.value.setStyle(e).multiplyScalar(o.colorIntensity)})),(e,o)=>(i(),t("TresShaderMaterial",s(f(n)),null,16))}}),B=["geometry"],j=a({__name:"tornadoOutter",props:{color:{default:"#ff5400"}},setup(e){const{nodes:n}=o.getItem("tornado.glb");return(e,o)=>(i(),t("TresMesh",{geometry:p(n).tornado.geometry},[d(_,{colorBase:e.color,colorIntensity:2,twirlAmount:6,radialShearAmount:new T(.9,.9),twirlCenter:new T(.5,-.52),twirlOffset:new T(-.5,-.25),radialOffset:new T(-.5,.5),alphaThreshold:.18,showEdge:!1},null,8,["colorBase","radialShearAmount","twirlCenter","twirlOffset","radialOffset"])],8,B))}}),V=["geometry"],F=a({__name:"tornado",props:{color:{default:"#ff5400"}},setup(e){const{nodes:n}=o.getItem("tornado.glb");return(e,o)=>(i(),t("TresMesh",{geometry:p(n).tornado.geometry},[d(_,{colorBase:e.color,colorIntensity:13,twirlAmount:8,radialShearAmount:new T(.7,.7),twirlCenter:new T(.5,-.52),twirlOffset:new T(-1,-.5),radialOffset:new T(-1,.5),alphaThreshold:.23,showEdge:!1},null,8,["colorBase","radialShearAmount","twirlCenter","twirlOffset","radialOffset"])],8,V))}}),R=["geometry"],A=a({__name:"tornadoInner",props:{color:{default:"#ff5400"}},setup(e){const{nodes:n}=o.getItem("tornado.glb");return(e,o)=>(i(),t("TresMesh",{geometry:p(n).tornado.geometry},[d(_,{colorBase:e.color,colorIntensity:8,radialShearAmount:new T(.7,.7),alphaThreshold:.17,showEdge:!0},null,8,["colorBase","radialShearAmount"])],8,R))}}),M=a({__name:"experience",props:{color0:{default:"#111111"},color1:{default:"#ff810c"},color2:{default:"#3a3a3a"},color3:{default:"#ff821c"},color4:{default:"#ff5400"}},setup:e=>(e,o)=>(i(),t("TresGroup",null,[d(k,{scale:[1.1,4.6,1.1],position:[0,-2,0],frontColor:e.color0,backColor:e.color1},null,8,["frontColor","backColor"]),d(j,{scale:[.6,.4,.6],position:[0,-2.5,0],renderOrder:999992,color:e.color2},null,8,["color"]),d(F,{scale:[.44,.4,.44],position:[0,-2.5,0],renderOrder:999993,color:e.color3},null,8,["color"]),d(A,{scale:.4,position:[0,-2.5,0],renderOrder:999994,color:e.color4},null,8,["color"])]))}),N=a({__name:"stylizedTornado",setup(l){o.loadResources([{functionName:"GLTFLoader",url:"./plugins/digitalCity/model/spiral-middle.glb"},{functionName:"GLTFLoader",url:"./plugins/digitalCity/model/tornado.glb"},{functionName:"TextureLoader",url:"./plugins/digitalCity/image/noise/noiseVoronoi.png"}]);const a=new e({title:"龙卷风参数",expanded:!0}),r=m({color0:"#111111",color1:"#ff810c",color2:"#3a3a3a",color3:"#ff821c",color4:"#ff1800"});return a.addBinding(r,"color0",{label:"颜色0"}),a.addBinding(r,"color1",{label:"颜色1"}),a.addBinding(r,"color2",{label:"颜色2"}),a.addBinding(r,"color3",{label:"颜色3"}),a.addBinding(r,"color4",{label:"颜色4"}),(e,l)=>(i(),t(C,null,[d(p(b),{useResourceManager:""}),d(n,{showAxesHelper:!1},{ability:v((()=>[p(o).hasAllFinished.value?(i(),h(M,w({key:0,position:[10,280,0],scale:100},r),null,16)):g("",!0)])),_:1})],64))}});export{N as default};
