import{T as o,E as t}from"./@tweenjs.Dhzs71lh1756372194067.js";import{l as e}from"./utils.HXWwD6ZG1756372194067.js";import{m as n}from"./d3-geo.DJvUpGvj1756372194067.js";import{g as s,S as r,V as a,M as l}from"./three.QlBabAUP1756372194067.js";const i=(e,n,s,r=1e3)=>{const a=e.value.position.clone(),l=s.value.target.clone(),i=n.clone(),c=n.clone();c.y=0;const p=new o({x:a.x,y:a.y,z:a.z,lookAtX:l.x,lookAtY:l.y,lookAtZ:l.z}).to({x:i.x,y:i.y,z:i.z,lookAtX:c.x,lookAtY:c.y,lookAtZ:c.z},r).easing(t.Quadratic.InOut).onUpdate((o=>{e.value.position.set(o.x,o.y,o.z),s.value.target.set(o.lookAtX,o.lookAtY,o.lookAtZ)})).start().onComplete((()=>{p.stop()}));return p},c=(e,n,s,r=[-2e3,-2e3],a=1e3)=>{const l=e.position.clone(),i=s.target.clone(),c=n.clone(),p=n.clone();p.y=0,p.x=p.x+r[0],p.z=p.z+r[1];const u=new o({x:l.x,y:l.y,z:l.z,lookAtX:i.x,lookAtY:i.y,lookAtZ:i.z}).to({x:c.x,y:c.y,z:c.z,lookAtX:p.x,lookAtY:p.y,lookAtZ:p.z},a).easing(t.Quadratic.InOut).onUpdate((o=>{e.position.set(o.x,o.y,o.z),s.target.set(o.lookAtX,o.lookAtY,o.lookAtZ)})).start().onComplete((()=>{u.stop()}));return u},p=async o=>{const t=await e(o),s=n().center(t[0].properties.center).translate([0,0]).scale(1e3),r=[];return t[0].geometry.coordinates[0].forEach((o=>{o.forEach((o=>{const[t,e]=s(o);r.push([t,0,e])}))})),r},u=o=>{const t=new s,e=new r,n=new a;if(o.getBoundingBox(t))t.getCenter(n);else{if(!o.getBoundingSphere(e))return void console.warn("tiles 没有 bounding 信息");n.copy(e.center)}console.log("tiles center (ECEF?)",n,"len=",n.length());const{east:i,north:c,up:p}=(o=>{const t=o.x,e=o.y;o.z;const n=Math.atan2(e,t),s=o.clone().normalize(),r=new a(-Math.sin(n),Math.cos(n),0),l=s.clone().multiplyScalar(r.dot(s));return r.sub(l).normalize(),{east:r,north:(new a).crossVectors(s,r).normalize(),up:s}})(n),u=(new l).makeBasis(i,c,p).clone().transpose(),y=(new l).makeTranslation(-n.x,-n.y,-n.z),x=(new l).multiplyMatrices(u,y);o.group.matrixAutoUpdate=!1,o.group.matrix.identity(),o.group.applyMatrix4(x),o.group.updateMatrixWorld(!0)},y=async o=>{if(!o.toLowerCase().endsWith(".json"))return!1;try{const t=await fetch(o);if(!t.ok)return!1;const e=await t.json(),n="object"==typeof e.asset&&void 0!==e.geometricError&&"object"==typeof e.root,s="1.0"===e.asset?.version||"1.1"===e.asset?.version;return n&&s}catch(t){return console.error("❌ 验证失败:",t),!1}};export{u as a,c as b,i as f,p as g,y as i};
