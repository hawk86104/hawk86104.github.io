import{h as e,y as t,importShared as s,E as n,GLTFLoader as i,zt as r}from"./3d-tiles-renderer.qyEDeaaW1769484739493.js";import{FullScreenQuad as o}from"./Pass.B0L5cC9t1769484739493.js";const a="https://tile.googleapis.com/v1/createSession";let l=class{get isMapTilesSession(){return this.authURL===a}constructor(e={}){const{apiToken:t,sessionOptions:s=null,autoRefreshToken:n=!1}=e;this.apiToken=t,this.autoRefreshToken=n,this.authURL=a,this.sessionToken=null,this.sessionOptions=s,this._tokenRefreshPromise=null}async fetch(e,t){null===this.sessionToken&&this.isMapTilesSession&&this.refreshToken(t),await this._tokenRefreshPromise;const s=new URL(e);s.searchParams.set("key",this.apiToken),this.sessionToken&&s.searchParams.set("session",this.sessionToken);let n=await fetch(s,t);return n.status>=400&&n.status<=499&&this.autoRefreshToken&&(await this.refreshToken(t),this.sessionToken&&s.searchParams.set("session",this.sessionToken),n=await fetch(s,t)),null!==this.sessionToken||this.isMapTilesSession?n:n.json().then(e=>(this.sessionToken=c(e),e))}refreshToken(e){if(null===this._tokenRefreshPromise){const t=new URL(this.authURL);t.searchParams.set("key",this.apiToken);const s={...e};this.isMapTilesSession&&(s.method="POST",s.body=JSON.stringify(this.sessionOptions),s.headers=s.headers||{},s.headers={...s.headers,"Content-Type":"application/json"}),this._tokenRefreshPromise=fetch(t,s).then(e=>{if(!e.ok)throw new Error(`GoogleCloudAuth: Failed to load data with error code ${e.status}`);return e.json()}).then(e=>(this.sessionToken=c(e),this._tokenRefreshPromise=null,e))}return this._tokenRefreshPromise}};function c(t){if("session"in t)return t.session;{let s=null;const n=t.root;return e(n,e=>{if(e.content&&e.content.uri){const[,t]=e.content.uri.split("?");return s=new URLSearchParams(t).get("session"),!0}return!1}),s}}let h=class{constructor(e={}){const{apiToken:t,autoRefreshToken:s=!1}=e;this.apiToken=t,this.autoRefreshToken=s,this.authURL=null,this._tokenRefreshPromise=null,this._bearerToken=null}async fetch(e,t){await this._tokenRefreshPromise;const s={...t};s.headers=s.headers||{},s.headers={...s.headers,Authorization:this._bearerToken};const n=await fetch(e,s);return n.status>=400&&n.status<=499&&this.autoRefreshToken?(await this.refreshToken(t),s.headers.Authorization=this._bearerToken,fetch(e,s)):n}refreshToken(e){if(null===this._tokenRefreshPromise){const t=new URL(this.authURL);t.searchParams.set("access_token",this.apiToken),this._tokenRefreshPromise=fetch(t,e).then(e=>{if(!e.ok)throw new Error(`CesiumIonAuthPlugin: Failed to load data with error code ${e.status}`);return e.json()}).then(e=>(this._bearerToken=`Bearer ${e.accessToken}`,this._tokenRefreshPromise=null,e))}return this._tokenRefreshPromise}};function u(e){return e>>1^-(1&e)}let d=class extends t{constructor(...e){super(...e),this.fetchOptions.header={Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9"}}loadAsync(...e){const{fetchOptions:t}=this;return t.header=t.header||{},t.header.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",t.header.Accept+=";extensions=octvertexnormals-watermask-metadata",super.loadAsync(...e)}parse(e){let t=0;const s=new DataView(e),n=()=>{const e=s.getFloat64(t,!0);return t+=8,e},i=()=>{const e=s.getFloat32(t,!0);return t+=4,e},r=()=>{const e=s.getUint32(t,!0);return t+=4,e},o=()=>{const e=s.getUint8(t);return t+=1,e},a=(s,n)=>{const i=new n(e,t,s);return t+=s*n.BYTES_PER_ELEMENT,i},l={center:[n(),n(),n()],minHeight:i(),maxHeight:i(),sphereCenter:[n(),n(),n()],sphereRadius:n(),horizonOcclusionPoint:[n(),n(),n()]},c=r(),h=a(c,Uint16Array),d=a(c,Uint16Array),f=a(c,Uint16Array),m=new Float32Array(c),g=new Float32Array(c),y=new Float32Array(c);let x=0,T=0,b=0;const v=32767;for(let p=0;p<c;++p)x+=u(h[p]),T+=u(d[p]),b+=u(f[p]),m[p]=x/v,g[p]=T/v,y[p]=b/v;const A=c>65536,_=A?Uint32Array:Uint16Array;t=A?4*Math.ceil(t/4):2*Math.ceil(t/2);const w=a(3*r(),_);let L=0;for(var M=0;M<w.length;++M){const e=w[M];w[M]=L-e,0===e&&++L}const P=(e,t)=>g[t]-g[e],E=(e,t)=>m[e]-m[t],C=a(r(),_);C.sort(P);const S=a(r(),_);S.sort(E);const I=a(r(),_);I.sort((e,t)=>-P(e,t));const U=a(r(),_);U.sort((e,t)=>-E(e,t));const R={westIndices:C,southIndices:S,eastIndices:I,northIndices:U},V={};for(;t<s.byteLength;){const e=o(),t=r();if(1===e){const t=a(2*c,Uint8Array),s=new Float32Array(3*c);for(let e=0;e<c;e++){let n=t[2*e+0]/255*2-1,i=t[2*e+1]/255*2-1;const r=1-(Math.abs(n)+Math.abs(i));if(r<0){const e=n;n=(1-Math.abs(i))*p(e),i=(1-Math.abs(e))*p(i)}const o=Math.sqrt(n*n+i*i+r*r);s[3*e+0]=n/o,s[3*e+1]=i/o,s[3*e+2]=r/o}V.octvertexnormals={extensionId:e,normals:s}}else if(2===e){const s=1===t?1:256,n=a(s*s,Uint8Array);V.watermask={extensionId:e,mask:n,size:s}}else if(4===e){const t=a(r(),Uint8Array),s=(new TextDecoder).decode(t);V.metadata={extensionId:e,json:JSON.parse(s)}}}return{header:l,indices:w,vertexData:{u:m,v:g,height:y},edgeIndices:R,extensions:V}}};function p(e){return e<0?-1:1}const f=await s("three"),{PlaneGeometry:m,Mesh:g,MeshBasicMaterial:y,Vector2:x,MathUtils:T,Vector3:b,Sphere:v,Texture:A,SRGBColorSpace:_,DefaultLoadingManager:w,BufferGeometry:L,MeshStandardMaterial:M,BufferAttribute:P,DataTexture:E,RGFormat:C,UnsignedByteType:S,LinearMipMapLinearFilter:I,LinearFilter:U,Triangle:R,Vector4:V,Matrix4:k,Matrix3:B,Matrix2:F,WebGLRenderer:D,WebGLRenderTarget:O,ShaderMaterial:N,OneFactor:j,ZeroFactor:z,CustomBlending:G,Box2:H,FileLoader:q,Quaternion:X,BatchedMesh:W,Source:Y,Box3:$,REVISION:Q,WebGLArrayRenderTarget:Z,Raycaster:K,DoubleSide:J,OrthographicCamera:ee,Color:te,CanvasTexture:se,Ray:ne,LineSegments:ie,LineBasicMaterial:re,EdgesGeometry:oe,BoxGeometry:ae,Group:le,Box3Helper:ce,PointsMaterial:he}=await s("three");class ue{constructor(){this.creditsCount={}}_adjustAttributions(e,t){const s=this.creditsCount,n=e.split(/;/g);for(let i=0,r=n.length;i<r;i++){const e=n[i];e in s||(s[e]=0),s[e]+=t?1:-1,s[e]<=0&&delete s[e]}}addAttributions(e){this._adjustAttributions(e,!0)}removeAttributions(e){this._adjustAttributions(e,!1)}toString(){return Object.entries(this.creditsCount).sort((e,t)=>{const s=e[1];return t[1]-s}).map(e=>e[0]).join("; ")}}class de{constructor({apiToken:e,sessionOptions:t=null,autoRefreshToken:s=!1,logoUrl:n=null,useRecommendedSettings:i=!0}){this.name="GOOGLE_CLOUD_AUTH_PLUGIN",this.apiToken=e,this.useRecommendedSettings=i,this.logoUrl=n,this.auth=new l({apiToken:e,autoRefreshToken:s,sessionOptions:t}),this.tiles=null,this._visibilityChangeCallback=null,this._attributionsManager=new ue,this._logoAttribution={value:"",type:"image",collapsible:!1},this._attribution={value:"",type:"string",collapsible:!0}}init(e){const{useRecommendedSettings:t,auth:s}=this;e.resetFailedTiles(),null==e.rootURL&&(e.rootURL="https://tile.googleapis.com/v1/3dtiles/root.json"),s.sessionOptions||(s.authURL=e.rootURL),t&&!s.isMapTilesSession&&(e.errorTarget=20),this.tiles=e,this._visibilityChangeCallback=({tile:e,visible:t})=>{var s,n;const i=(null==(n=null==(s=e.cached.metadata)?void 0:s.asset)?void 0:n.copyright)||"";t?this._attributionsManager.addAttributions(i):this._attributionsManager.removeAttributions(i)},e.addEventListener("tile-visibility-change",this._visibilityChangeCallback)}getAttributions(e){this.tiles.visibleTiles.size>0&&(this.logoUrl&&(this._logoAttribution.value=this.logoUrl,e.push(this._logoAttribution)),this._attribution.value=this._attributionsManager.toString(),e.push(this._attribution))}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._visibilityChangeCallback)}async fetchData(e,t){return this.auth.fetch(e,t)}}const pe=new x,fe=Symbol("TILE_X"),me=Symbol("TILE_Y"),ge=Symbol("TILE_LEVEL");class ye{get tiling(){return this.imageSource.tiling}constructor(e={}){const{pixelSize:t=null,center:s=!1,useRecommendedSettings:n=!0,imageSource:i=null}=e;this.priority=-10,this.tiles=null,this.imageSource=i,this.pixelSize=t,this.center=s,this.useRecommendedSettings=n,null!==t&&console.warn('ImageFormatPlugin: "pixelSize" has been deprecated in favor of scaling the tiles root.')}init(e){this.useRecommendedSettings&&(e.errorTarget=1),this.tiles=e,this.imageSource.fetchOptions=e.fetchOptions,this.imageSource.fetchData=(t,s)=>(e.invokeAllPlugins(e=>t=e.preprocessURL?e.preprocessURL(t,null):t),e.invokeOnePlugin(e=>e!==this&&e.fetchData&&e.fetchData(t,s)))}async loadRootTileSet(){const{tiles:e,imageSource:t}=this;return t.url=t.url||e.rootURL,e.invokeAllPlugins(e=>t.url=e.preprocessURL?e.preprocessURL(t.url,null):t.url),await t.init(),e.rootURL=t.url,this.getTileset(t.url)}async parseToMesh(e,t,s,n,i){if(i.aborted)return null;const{imageSource:r}=this,o=t[fe],a=t[me],l=t[ge],c=await r.processBufferToTexture(e);if(i.aborted)return c.dispose(),c.image.close(),null;r.setData(o,a,l,c);let h=1,u=1,d=0,p=0,f=0;const x=t.boundingVolume.box;x&&([d,p,f]=x,h=x[3],u=x[7]);const b=new m(2*h,2*u),v=new g(b,new y({map:c,transparent:!0}));v.position.set(d,p,f);const A=r.tiling.getTileContentUVBounds(o,a,l),{uv:_}=b.attributes;for(let m=0;m<_.count;m++)pe.fromBufferAttribute(_,m),pe.x=T.mapLinear(pe.x,0,1,A[0],A[2]),pe.y=T.mapLinear(pe.y,0,1,A[1],A[3]),_.setXY(m,pe.x,pe.y);return v}preprocessNode(e){const{tiling:t}=this,s=t.maxLevel;e[ge]<s&&null!==e.parent&&this.expandChildren(e)}disposeTile(e){const t=e[fe],s=e[me],n=e[ge],{imageSource:i}=this;i.has(t,s,n)&&i.release(t,s,n)}getTileset(e){const{tiling:t,tiles:s}=this,n=t.minLevel,{tileCountX:i,tileCountY:r}=t.getLevel(n),o=[];for(let l=0;l<i;l++)for(let e=0;e<r;e++){const t=this.createChild(l,e,n);null!==t&&o.push(t)}const a={asset:{version:"1.1"},geometricError:1e5,root:{refine:"REPLACE",geometricError:1e5,boundingVolume:this.createBoundingVolume(0,0,-1),children:o,[ge]:-1,[fe]:0,[me]:0}};return s.preprocessTileSet(a,e),a}getUrl(e,t,s){return this.imageSource.getUrl(e,t,s)}createBoundingVolume(e,t,s){const{center:n,pixelSize:i,tiling:r}=this,{pixelWidth:o,pixelHeight:a}=r.getLevel(r.maxLevel),[l,c,h,u]=-1===s?r.getContentBounds(!0):r.getTileBounds(e,t,s,!0);let d=(h-l)/2,p=(u-c)/2,f=l+d,m=c+p;return n&&(f-=.5,m-=.5),i?(f*=o*i,d*=o*i,m*=a*i,p*=a*i):(f*=r.aspectRatio,d*=r.aspectRatio),{box:[f,m,0,d,0,0,0,p,0,0,0,0]}}createChild(e,t,s){const{pixelSize:n,tiling:i}=this;if(!i.getTileExists(e,t,s))return null;const{pixelWidth:r,pixelHeight:o}=i.getLevel(i.maxLevel),{pixelWidth:a,pixelHeight:l}=i.getLevel(s);let c=Math.max(1/a,1/l);return n&&(c*=n*Math.max(r,o)),{refine:"REPLACE",geometricError:c,boundingVolume:this.createBoundingVolume(e,t,s),content:{uri:this.getUrl(e,t,s)},children:[],[fe]:e,[me]:t,[ge]:s}}expandChildren(e){const t=e[ge],s=e[fe],n=e[me];for(let i=0;i<2;i++)for(let r=0;r<2;r++){const o=this.createChild(2*s+i,2*n+r,t+1);o&&e.children.push(o)}}}const xe=new b,Te=new b;const be=new b,ve=new b,Ae=new x,_e=new v;class we extends ye{get projection(){return this.tiling.projection}constructor(e={}){const{shape:t="planar",endCaps:s=!0,...n}=e;super(n),this.shape=t,this.endCaps=s}async parseToMesh(e,t,...s){const n=await super.parseToMesh(e,t,...s),{shape:i,projection:r,tiles:o,tiling:a}=this;if("ellipsoid"===i){const e=o.ellipsoid,s=t[ge],i=t[fe],l=t[me],[c,h,u,d]=t.boundingVolume.region,p=Math.ceil((d-h)*T.RAD2DEG*.25),f=Math.ceil((u-c)*T.RAD2DEG*.25),g=Math.max(15,p),y=Math.max(30,f),x=new m(1,1,y,g),[b,v,A,_]=a.getTileBounds(i,l,s,!0,!0),w=a.getTileContentUVBounds(i,l,s),{position:L,normal:M,uv:P}=x.attributes,E=L.count;t.cached.boundingVolume.getSphere(_e);for(let t=0;t<E;t++){be.fromBufferAttribute(L,t),Ae.fromBufferAttribute(P,t);const s=r.convertProjectionToLongitude(T.mapLinear(Ae.x,0,1,b,A));let n=r.convertProjectionToLatitude(T.mapLinear(Ae.y,0,1,v,_));if(r.isMercator&&this.endCaps&&(1===_&&1===Ae.y&&(n=Math.PI/2),0===v&&0===Ae.y&&(n=-Math.PI/2)),r.isMercator&&0!==Ae.y&&1!==Ae.y){const e=r.convertProjectionToLatitude(1),t=1/g,s=T.mapLinear(Ae.y-t,0,1,h,d),i=T.mapLinear(Ae.y+t,0,1,h,d);n>e&&s<e&&(n=e),n<-e&&i>-e&&(n=-e)}e.getCartographicToPosition(n,s,0,be).sub(_e.center),e.getCartographicToNormal(n,s,ve);const i=T.mapLinear(r.convertLongitudeToProjection(s),b,A,w[0],w[2]),o=T.mapLinear(r.convertLatitudeToProjection(n),v,_,w[1],w[3]);P.setXY(t,i,o),L.setXYZ(t,...be),M.setXYZ(t,...ve)}n.geometry=x,n.position.copy(_e.center)}return n}createBoundingVolume(e,t,s){if("ellipsoid"===this.shape){const{tiling:n,endCaps:i}=this,r=-1===s,o=r?n.getContentBounds(!0):n.getTileBounds(e,t,s,!0,!0),a=r?n.getContentBounds():n.getTileBounds(e,t,s,!1,!0);return i&&(1===o[3]&&(a[3]=Math.PI/2),0===o[1]&&(a[1]=-Math.PI/2)),{region:[...a,-1,1]}}return super.createBoundingVolume(e,t,s)}createChild(...e){const t=super.createChild(...e),{shape:s,projection:n,tiling:i}=this;if(t&&"ellipsoid"===s){const e=t[ge],s=t[fe],r=t[me];if(-1===e)return t.geometricError=1e50,parent;const[o,a,l,c]=i.getTileBounds(s,r,e,!0),{tilePixelWidth:h,tilePixelHeight:u}=i.getLevel(e),d=(l-o)/h,p=(c-a)/u,[,f,m,g]=i.getTileBounds(s,r,e),y=f>0!=g>0?0:Math.min(Math.abs(f),Math.abs(g)),x=n.convertLatitudeToProjection(y),T=n.getLongitudeDerivativeAtProjection(o),b=n.getLatitudeDerivativeAtProjection(x),[v,A]=function(e,t,s){const n=s+1e-5;let i=t+1e-5;Math.abs(i)>Math.PI/2&&(i-=1e-5),e.getCartographicToPosition(t,s,0,xe),e.getCartographicToPosition(i,s,0,Te);const r=xe.distanceTo(Te)/1e-5;return e.getCartographicToPosition(t,n,0,Te),[xe.distanceTo(Te)/1e-5,r]}(this.tiles.ellipsoid,y,m),_=Math.max(d*T*v,p*b*A);t.geometricError=_}return t}}class Le{get isMercator(){return"EPSG:3857"===this.scheme}constructor(e="EPSG:4326"){this.scheme=e,this.tileCountX=1,this.tileCountY=1,this.setScheme(e)}setScheme(e){switch(this.scheme=e,e){case"EPSG:4326":this.tileCountX=2,this.tileCountY=1;break;case"EPSG:3857":this.tileCountX=1,this.tileCountY=1;break;default:throw new Error}}convertProjectionToLatitude(e){if(this.isMercator){const t=T.mapLinear(e,0,1,-1,1);return 2*Math.atan(Math.exp(t*Math.PI))-Math.PI/2}return T.mapLinear(e,0,1,-Math.PI/2,Math.PI/2)}convertProjectionToLongitude(e){return T.mapLinear(e,0,1,-Math.PI,Math.PI)}convertLatitudeToProjection(e){if(this.isMercator){return.5+1*Math.log(Math.tan(Math.PI/4+e/2))/(2*Math.PI)}return T.mapLinear(e,-Math.PI/2,Math.PI/2,0,1)}convertLongitudeToProjection(e){return(e+Math.PI)/(2*Math.PI)}getLongitudeDerivativeAtProjection(e){return 2*Math.PI}getLatitudeDerivativeAtProjection(e){let t=e-1e-5;return t<0&&(t=e+1e-5),this.isMercator?Math.abs(this.convertProjectionToLatitude(e)-this.convertProjectionToLatitude(t))/1e-5:Math.PI}getBounds(){return[this.convertProjectionToLongitude(0),this.convertProjectionToLatitude(0),this.convertProjectionToLongitude(1),this.convertProjectionToLatitude(1)]}}function Me(...e){return e.join("_")}class Pe{constructor(){this.cache={},this.count=0,this.cachedBytes=0,this.active=0}fetchItem(){}disposeItem(){}getMemoryUsage(e){return 0}setData(...e){const{cache:t}=this,s=e.pop(),n=Me(...e);if(n in t)throw new Error(`DataCache: "${n}" is already present.`);return this.cache[n]={abortController:new AbortController,result:s,count:1,bytes:this.getMemoryUsage(s)},this.count++,this.cachedBytes+=this.cache[n].bytes,s}lock(...e){const{cache:t}=this,s=Me(...e);if(s in t)t[s].count++;else{const t=new AbortController,n={abortController:t,result:null,count:1,bytes:0};this.active++,n.result=this.fetchItem(e,t.signal),n.result instanceof Promise?n.result.then(e=>(n.result=e,n.bytes=this.getMemoryUsage(e),this.cachedBytes+=n.bytes,e)).finally(()=>{this.active--}).catch(e=>{}):(this.active--,n.bytes=this.getMemoryUsage(n.result),this.cachedBytes+=n.bytes),this.cache[s]=n,this.count++}return t[s].result}release(...e){const t=Me(...e);this.releaseViaFullKey(t)}get(...e){const{cache:t}=this,s=Me(...e);return s in t&&t[s].count>0?t[s].result:null}has(...e){const{cache:t}=this;return Me(...e)in t}dispose(){const{cache:e}=this;for(const t in e){const{abortController:s}=e[t];s.abort(),this.releaseViaFullKey(t,!0)}this.cache={}}releaseViaFullKey(e,t=!1){const{cache:s}=this;if(e in s&&s[e].count>0){const n=s[e];if(n.count--,0===n.count||t){const i=()=>{if(s[e]!==n)return;const{result:t,abortController:i}=n;i.abort(),t instanceof Promise?t.then(e=>{this.disposeItem(e),this.count--,this.cachedBytes-=n.bytes}).catch(()=>{}):(this.disposeItem(t),this.count--,this.cachedBytes-=n.bytes),delete s[e]};t?i():queueMicrotask(()=>{0===n.count&&i()})}return!0}throw new Error("DataCache: Attempting to release key that does not exist")}}class Ee{get levelCount(){return this._levels.length}get maxLevel(){return this.levelCount-1}get minLevel(){const e=this._levels;for(let t=0;t<e.length;t++)if(null!==e[t])return t;return-1}get contentBounds(){var e;return this._contentBounds??(null==(e=this.projection)?void 0:e.getBounds())??[0,0,1,1]}get aspectRatio(){const{pixelWidth:e,pixelHeight:t}=this.getLevel(this.maxLevel);return e/t}constructor(){this.flipY=!1,this.pixelOverlap=0,this._contentBounds=null,this.projection=null,this._levels=[]}setLevel(e,t={}){const s=this._levels;for(;s.length<e;)s.push(null);const{tilePixelWidth:n=256,tilePixelHeight:i=256,tileCountX:r=2**e,tileCountY:o=2**e,tileBounds:a=null}=t,{pixelWidth:l=n*r,pixelHeight:c=i*o}=t;s[e]={tilePixelWidth:n,tilePixelHeight:i,pixelWidth:l,pixelHeight:c,tileCountX:r,tileCountY:o,tileBounds:a}}generateLevels(e,t,s,n={}){const{minLevel:i=0,tilePixelWidth:r=256,tilePixelHeight:o=256}=n,a=e-1,{pixelWidth:l=r*t*2**a,pixelHeight:c=o*s*2**a}=n;for(let h=i;h<e;h++){const t=e-h-1,s=Math.ceil(l*2**-t),n=Math.ceil(c*2**-t),i=Math.ceil(s/r),a=Math.ceil(n/o);this.setLevel(h,{tilePixelWidth:r,tilePixelHeight:o,pixelWidth:s,pixelHeight:n,tileCountX:i,tileCountY:a})}}getLevel(e){return this._levels[e]}setContentBounds(e,t,s,n){this._contentBounds=[e,t,s,n]}setProjection(e){this.projection=e}getTileAtPoint(e,t,s,n=!1){const{flipY:i}=this,{tileCountX:r,tileCountY:o,tileBounds:a}=this.getLevel(s),l=1/r,c=1/o;if(n||([e,t]=this.toNormalizedPoint(e,t)),a){const s=this.toNormalizedRange(a);e=T.mapLinear(e,s[0],s[2],0,1),t=T.mapLinear(t,s[1],s[3],0,1)}const h=Math.floor(e/l);let u=Math.floor(t/c);return i&&(u=o-1-u),[h,u]}getTilesInRange(e,t,s,n,i,r=!1){[e,t,s,n]=this.clampToContentBounds([e,t,s,n],r);const o=this.getTileAtPoint(e,t,i,r),a=this.getTileAtPoint(s,n,i,r);this.flipY&&([o[1],a[1]]=[a[1],o[1]]);const{tileCountX:l,tileCountY:c}=this.getLevel(i),[h,u]=o,[d,p]=a;return d<0||p<0||h>=l||u>=c?[0,0,-1,-1]:[T.clamp(h,0,l-1),T.clamp(u,0,c-1),T.clamp(d,0,l-1),T.clamp(p,0,c-1)]}getTileExists(e,t,s){const[n,i,r,o]=this.contentBounds,[a,l,c,h]=this.getTileBounds(e,t,s);return!(a>=c||l>=h)&&a<=r&&l<=o&&c>=n&&h>=i}getContentBounds(e=!1){const{projection:t}=this,s=[...this.contentBounds];return t&&e&&(s[0]=t.convertLongitudeToProjection(s[0]),s[1]=t.convertLatitudeToProjection(s[1]),s[2]=t.convertLongitudeToProjection(s[2]),s[3]=t.convertLatitudeToProjection(s[3])),s}getTileContentUVBounds(e,t,s){const[n,i,r,o]=this.getTileBounds(e,t,s,!0,!0),[a,l,c,h]=this.getTileBounds(e,t,s,!0,!1);return[T.mapLinear(n,a,c,0,1),T.mapLinear(i,l,h,0,1),T.mapLinear(r,a,c,0,1),T.mapLinear(o,l,h,0,1)]}getTileBounds(e,t,s,n=!1,i=!0){const{flipY:r,pixelOverlap:o,projection:a}=this,{tilePixelWidth:l,tilePixelHeight:c,pixelWidth:h,pixelHeight:u,tileBounds:d}=this.getLevel(s);let p=l*e-o,f=c*t-o,m=p+l+2*o,g=f+c+2*o;if(p=Math.max(p,0),f=Math.max(f,0),m=Math.min(m,h),g=Math.min(g,u),p/=h,m/=h,f/=u,g/=u,r){const e=(g-f)/2,t=1-(f+g)/2;f=t-e,g=t+e}let y=[p,f,m,g];if(d){const e=this.toNormalizedRange(d);y[0]=T.mapLinear(y[0],0,1,e[0],e[2]),y[2]=T.mapLinear(y[2],0,1,e[0],e[2]),y[1]=T.mapLinear(y[1],0,1,e[1],e[3]),y[3]=T.mapLinear(y[3],0,1,e[1],e[3])}return i&&(y=this.clampToProjectionBounds(y,!0)),a&&!n&&(y[0]=a.convertProjectionToLongitude(y[0]),y[1]=a.convertProjectionToLatitude(y[1]),y[2]=a.convertProjectionToLongitude(y[2]),y[3]=a.convertProjectionToLatitude(y[3])),y}toNormalizedPoint(e,t){const{projection:s}=this,n=[e,t];return this.projection&&(n[0]=s.convertLongitudeToProjection(n[0]),n[1]=s.convertLatitudeToProjection(n[1])),n}toNormalizedRange(e){return[...this.toNormalizedPoint(e[0],e[1]),...this.toNormalizedPoint(e[2],e[3])]}toCartographicPoint(e,t){const{projection:s}=this,n=[e,t];if(!this.projection)throw new Error("TilingScheme: Projection not available.");return n[0]=s.convertProjectionToLongitude(n[0]),n[1]=s.convertProjectionToLatitude(n[1]),n}toCartographicRange(e){return[...this.toCartographicPoint(e[0],e[1]),...this.toCartographicPoint(e[2],e[3])]}clampToContentBounds(e,t=!1){const s=[...e],[n,i,r,o]=this.getContentBounds(t);return s[0]=T.clamp(s[0],n,r),s[1]=T.clamp(s[1],i,o),s[2]=T.clamp(s[2],n,r),s[3]=T.clamp(s[3],i,o),s}clampToProjectionBounds(e,t=!1){const s=[...e],{projection:n}=this;let i;i=t||!n?[0,0,1,1]:n.getBounds();const[r,o,a,l]=i;return s[0]=T.clamp(s[0],r,a),s[1]=T.clamp(s[1],o,l),s[2]=T.clamp(s[2],r,a),s[3]=T.clamp(s[3],o,l),s}}class Ce extends Pe{constructor(){super(),this.tiling=new Ee,this.fetchOptions={},this.fetchData=(...e)=>fetch(...e)}init(){}async processBufferToTexture(e){const t=new Blob([e]),s=await createImageBitmap(t,{premultiplyAlpha:"none",colorSpaceConversion:"none",imageOrientation:"flipY"}),n=new A(s);return n.generateMipmaps=!1,n.colorSpace=_,n.needsUpdate=!0,n}getMemoryUsage(e){const{TextureUtils:t}=f;if(!t)return 0;const{format:s,type:n,image:i,generateMipmaps:r}=e,{width:o,height:a}=i,l=t.getByteLength(o,a,s,n);return r?4*l/3:l}fetchItem(e,t){const s={...this.fetchOptions,signal:t},n=this.getUrl(...e);return this.fetchData(n,s).then(e=>e.arrayBuffer()).then(e=>this.processBufferToTexture(e))}disposeItem(e){e.dispose(),e.image instanceof ImageBitmap&&e.image.close()}getUrl(...e){}}class Se extends Ce{constructor(e={}){const{url:t=null}=e;super(),this.tileSets=null,this.extension=null,this.url=t}getUrl(e,t,s){const{url:n,extension:i,tileSets:r,tiling:o}=this;return new URL(`${parseInt(r[s-o.minLevel].href)}/${e}/${t}.${i}`,n).toString()}init(){const{url:e}=this;return this.fetchData(new URL("tilemapresource.xml",e),this.fetchOptions).then(e=>e.text()).then(t=>{const{tiling:s}=this,n=(new DOMParser).parseFromString(t,"text/xml"),i=n.querySelector("BoundingBox"),r=n.querySelector("TileFormat"),o=[...n.querySelector("TileSets").querySelectorAll("TileSet")].map(e=>({href:parseInt(e.getAttribute("href")),unitsPerPixel:parseFloat(e.getAttribute("units-per-pixel")),order:parseInt(e.getAttribute("order"))})).sort((e,t)=>e.order-t.order),a=parseFloat(i.getAttribute("minx"))*T.DEG2RAD,l=parseFloat(i.getAttribute("maxx"))*T.DEG2RAD,c=parseFloat(i.getAttribute("miny"))*T.DEG2RAD,h=parseFloat(i.getAttribute("maxy"))*T.DEG2RAD,u=parseInt(r.getAttribute("width")),d=parseInt(r.getAttribute("height")),p=r.getAttribute("extension"),f=n.querySelector("SRS").textContent;this.extension=p,this.url=e,this.tileSets=o,s.setProjection(new Le(f)),s.setContentBounds(a,c,l,h),o.forEach(({order:e})=>{s.setLevel(e,{tileCountX:s.projection.tileCountX*2**e,tilePixelWidth:u,tilePixelHeight:d})})})}}class Ie extends we{constructor(e={}){const{url:t,...s}=e;super(s),this.name="TMS_TILES_PLUGIN",this.imageSource=new Se({url:t})}}const Ue=new b,Re=new R,Ve=new b,ke=new b;class Be extends d{constructor(e=w){super(),this.manager=e,this.ellipsoid=new r,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI}parse(e){const{ellipsoid:t,solid:s,skirtLength:n,smoothSkirtNormals:i,minLat:r,maxLat:o,minLon:a,maxLon:l}=this,{header:c,indices:h,vertexData:u,edgeIndices:d,extensions:p}=super.parse(e),f=new L,m=new M,y=new g(f,m);y.position.set(...c.center);const x="octvertexnormals"in p,b=u.u.length,v=[],A=[],_=[],w=[];let R=0,V=0;for(let g=0;g<b;g++)B(g,Ve),F(Ve.x,Ve.y,Ve.z,ke),A.push(Ve.x,Ve.y),v.push(...ke);for(let g=0,T=h.length;g<T;g++)_.push(h[g]);if(x){const e=p.octvertexnormals.normals;for(let t=0,s=e.length;t<s;t++)w.push(e[t])}if(f.addGroup(R,h.length,V),R+=h.length,V++,s){const e=v.length/3;for(let t=0;t<b;t++)B(t,Ve),F(Ve.x,Ve.y,Ve.z,ke,-n),A.push(Ve.x,Ve.y),v.push(...ke);for(let t=h.length-1;t>=0;t--)_.push(h[t]+e);if(x){const e=p.octvertexnormals.normals;for(let t=0,s=e.length;t<s;t++)w.push(-e[t])}f.addGroup(R,h.length,V),R+=h.length,V++}if(n>0){const{westIndices:e,eastIndices:t,southIndices:s,northIndices:n}=d;let i;const r=D(e);i=v.length/3,A.push(...r.uv),v.push(...r.positions);for(let c=0,h=r.indices.length;c<h;c++)_.push(r.indices[c]+i);const o=D(t);i=v.length/3,A.push(...o.uv),v.push(...o.positions);for(let c=0,h=o.indices.length;c<h;c++)_.push(o.indices[c]+i);const a=D(s);i=v.length/3,A.push(...a.uv),v.push(...a.positions);for(let c=0,h=a.indices.length;c<h;c++)_.push(a.indices[c]+i);const l=D(n);i=v.length/3,A.push(...l.uv),v.push(...l.positions);for(let c=0,h=l.indices.length;c<h;c++)_.push(l.indices[c]+i);x&&(w.push(...r.normals),w.push(...o.normals),w.push(...a.normals),w.push(...l.normals)),f.addGroup(R,h.length,V),R+=h.length,V++}for(let g=0,T=v.length;g<T;g+=3)v[g+0]-=c.center[0],v[g+1]-=c.center[1],v[g+2]-=c.center[2];const k=v.length/3>65535?new Uint32Array(_):new Uint16Array(_);if(f.setIndex(new P(k,1,!1)),f.setAttribute("position",new P(new Float32Array(v),3,!1)),f.setAttribute("uv",new P(new Float32Array(A),2,!1)),x&&f.setAttribute("normal",new P(new Float32Array(w),3,!1)),"watermask"in p){const{mask:e,size:t}=p.watermask,s=new Uint8Array(2*t*t);for(let i=0,r=e.length;i<r;i++){const t=255===e[i]?0:255;s[2*i+0]=t,s[2*i+1]=t}const n=new E(s,t,t,C,S);n.flipY=!0,n.minFilter=I,n.magFilter=U,n.needsUpdate=!0,m.roughnessMap=n}return y.userData.minHeight=c.minHeight,y.userData.maxHeight=c.maxHeight,"metadata"in p&&(y.userData.metadata=p.metadata.json),y;function B(e,t){return t.x=u.u[e],t.y=u.v[e],t.z=u.height[e],t}function F(e,s,n,i,h=0){const u=T.lerp(c.minHeight,c.maxHeight,n),d=T.lerp(a,l,e),p=T.lerp(r,o,s);return t.getCartographicToPosition(p,d,u+h,i),i}function D(e){const t=[],s=[],r=[],o=[],a=[];for(let i=0,h=e.length;i<h;i++)B(e[i],Ve),t.push(Ve.x,Ve.y),r.push(Ve.x,Ve.y),F(Ve.x,Ve.y,Ve.z,ke),s.push(...ke),F(Ve.x,Ve.y,Ve.z,ke,-n),o.push(...ke);const l=e.length-1;for(let n=0;n<l;n++){const t=n,s=n+1,i=n+e.length,r=n+e.length+1;a.push(t,i,s),a.push(s,i,r)}let c=null;if(x){const t=(s.length+o.length)/3;if(i){c=new Array(3*t);const s=p.octvertexnormals.normals,n=c.length/2;for(let i=0,r=t/2;i<r;i++){const t=e[i],r=3*i,o=s[3*t+0],a=s[3*t+1],l=s[3*t+2];c[r+0]=o,c[r+1]=a,c[r+2]=l,c[n+r+0]=o,c[n+r+1]=a,c[n+r+2]=l}}else{c=[],Re.a.fromArray(s,0),Re.b.fromArray(o,0),Re.c.fromArray(s,3),Re.getNormal(Ue);for(let e=0;e<t;e++)c.push(...Ue)}}return{uv:[...t,...r],positions:[...s,...o],indices:a,normals:c}}}}const Fe=["a","b","c"],De=new V,Oe=new V,Ne=new V,je=new V;class ze{constructor(){this.attributeList=null,this.splitOperations=[],this.trianglePool=new Ge}forEachSplitPermutation(e){const{splitOperations:t}=this,s=(n=0)=>{n>=t.length?e():(t[n].keepPositive=!0,s(n+1),t[n].keepPositive=!1,s(n+1))};s()}addSplitOperation(e,t=!0){this.splitOperations.push({callback:e,keepPositive:t})}clearSplitOperations(){this.splitOperations.length=0}clipObject(e){const t=e.clone(),s=[];return t.traverse(e=>{e.isMesh&&(e.geometry=this.clip(e).geometry,0==(e.geometry.index?e.geometry.index.count/3:e.attributes.position.count/3)&&s.push(e))}),s.forEach(e=>{e.removeFromParent()}),t}clip(e,t=null){const s=this.getClippedData(e,t);return this.constructMesh(s.attributes,s.index,e)}getClippedData(e,t=null,s={}){const{trianglePool:n,splitOperations:i,attributeList:r}=this,o=e.geometry,a=o.attributes.position,l=o.index;let c=0;const h={};s.index=s.index||[],s.vertexIsClipped=s.vertexIsClipped||[],s.attributes=s.attributes||{};for(const f in o.attributes){if(null!==r){if(r instanceof Function&&!r(f))continue;if(Array.isArray(r)&&!r.includes(f))continue}s.attributes[f]=[]}let u=0,d=l?l.count:a.count;null!==t&&(u=t.start,d=t.count);for(let f=u,m=u+d;f<m;f+=3){let t=f+0,s=f+1,r=f+2;l&&(t=l.getX(t),s=l.getX(s),r=l.getX(r));const a=n.get();a.initFromIndices(t,s,r);let c=[a];for(let n=0;n<i.length;n++){const{keepPositive:t,callback:s}=i[n],r=[];for(let n=0;n<c.length;n++){const i=c[n],{indices:a,barycoord:l}=i;i.clipValues.a=s(o,a.a,a.b,a.c,l.a,e.matrixWorld),i.clipValues.b=s(o,a.a,a.b,a.c,l.b,e.matrixWorld),i.clipValues.c=s(o,a.a,a.b,a.c,l.c,e.matrixWorld),this.splitTriangle(i,!t,r)}c=r}for(let e=0,n=c.length;e<n;e++){p(c[e],o)}n.reset()}return s;function p(e,t){for(let n=0;n<3;n++){const i=e.getVertexHash(n,t);i in h||(h[i]=c,c++,e.getVertexData(n,t,s.attributes),s.vertexIsClipped.push(0===e.clipValues[Fe[n]]));const r=h[i];s.index.push(r)}}}constructMesh(e,t,s){const n=s.geometry,i=new L,r=e.position.length/3>65535?new Uint32Array(t):new Uint16Array(t);i.setIndex(new P(r,1,!1));for(const a in e){const t=n.getAttribute(a),s=new t.array.constructor(e[a]),r=new P(s,t.itemSize,t.normalized);r.gpuType=t.gpuType,i.setAttribute(a,r)}const o=new g(i,s.material.clone());return o.position.copy(s.position),o.quaternion.copy(s.quaternion),o.scale.copy(s.scale),o}splitTriangle(e,t,s){const{trianglePool:n}=this,i=[],r=[],o=[];for(let a=0;a<3;a++){const t=Fe[a],s=Fe[(a+1)%3],n=e.clipValues[t],l=e.clipValues[s];(n<0!=l<0||0===n)&&(i.push(a),r.push([t,s]),n===l?o.push(0):o.push(T.mapLinear(0,n,l,0,1)))}if(2!==i.length)Math.min(e.clipValues.a,e.clipValues.b,e.clipValues.c)<0===t&&s.push(e);else if(2===i.length){const a=n.get().initFromTriangle(e),l=n.get().initFromTriangle(e),c=n.get().initFromTriangle(e);let h,u;(i[0]+1)%3===i[1]?(a.lerpVertexFromEdge(e,r[0][0],r[0][1],o[0],"a"),a.copyVertex(e,r[0][1],"b"),a.lerpVertexFromEdge(e,r[1][0],r[1][1],o[1],"c"),a.clipValues.a=0,a.clipValues.c=0,l.lerpVertexFromEdge(e,r[0][0],r[0][1],o[0],"a"),l.copyVertex(e,r[1][1],"b"),l.copyVertex(e,r[0][0],"c"),l.clipValues.a=0,c.lerpVertexFromEdge(e,r[0][0],r[0][1],o[0],"a"),c.lerpVertexFromEdge(e,r[1][0],r[1][1],o[1],"b"),c.copyVertex(e,r[1][1],"c"),c.clipValues.a=0,c.clipValues.b=0):(a.lerpVertexFromEdge(e,r[0][0],r[0][1],o[0],"a"),a.lerpVertexFromEdge(e,r[1][0],r[1][1],o[1],"b"),a.copyVertex(e,r[0][0],"c"),a.clipValues.a=0,a.clipValues.b=0,l.lerpVertexFromEdge(e,r[0][0],r[0][1],o[0],"a"),l.copyVertex(e,r[0][1],"b"),l.lerpVertexFromEdge(e,r[1][0],r[1][1],o[1],"c"),l.clipValues.a=0,l.clipValues.c=0,c.copyVertex(e,r[0][1],"a"),c.copyVertex(e,r[1][0],"b"),c.lerpVertexFromEdge(e,r[1][0],r[1][1],o[1],"c"),c.clipValues.c=0),h=Math.min(a.clipValues.a,a.clipValues.b,a.clipValues.c),u=h<0,u===t&&s.push(a),h=Math.min(l.clipValues.a,l.clipValues.b,l.clipValues.c),u=h<0,u===t&&s.push(l),h=Math.min(c.clipValues.a,c.clipValues.b,c.clipValues.c),u=h<0,u===t&&s.push(c)}}}class Ge{constructor(){this.pool=[],this.index=0}get(){if(this.index>=this.pool.length){const e=new He;this.pool.push(e)}const e=this.pool[this.index];return this.index++,e}reset(){this.index=0}}class He{constructor(){this.indices={a:-1,b:-1,c:-1},this.clipValues={a:-1,b:-1,c:-1},this.barycoord=new R}getVertexHash(e,t){const{barycoord:s,indices:n}=this,i=s[Fe[e]];if(1===i.x)return n[Fe[0]];if(1===i.y)return n[Fe[1]];if(1===i.z)return n[Fe[2]];{const{attributes:e}=t;let s="";for(const t in e){const r=e[t];switch(qe(r,n.a,n.b,n.c,i,De),("normal"===t||"tangent"===t||"bitangent"===t)&&De.normalize(),r.itemSize){case 4:s+=Xe(De.x,De.y,De.z,De.w);break;case 3:s+=Xe(De.x,De.y,De.z);break;case 2:s+=Xe(De.x,De.y);break;case 1:s+=Xe(De.x)}s+="|"}return s}}getVertexData(e,t,s){const{barycoord:n,indices:i}=this,r=n[Fe[e]],{attributes:o}=t;for(const a in o){if(!s[a])continue;const e=o[a],t=s[a];switch(qe(e,i.a,i.b,i.c,r,De),("normal"===a||"tangent"===a||"bitangent"===a)&&De.normalize(),e.itemSize){case 4:t.push(De.x,De.y,De.z,De.w);break;case 3:t.push(De.x,De.y,De.z);break;case 2:t.push(De.x,De.y);break;case 1:t.push(De.x)}}}initFromTriangle(e){return this.initFromIndices(e.indices.a,e.indices.b,e.indices.c)}initFromIndices(e,t,s){return this.indices.a=e,this.indices.b=t,this.indices.c=s,this.clipValues.a=-1,this.clipValues.b=-1,this.clipValues.c=-1,this.barycoord.a.set(1,0,0),this.barycoord.b.set(0,1,0),this.barycoord.c.set(0,0,1),this}lerpVertexFromEdge(e,t,s,n,i){this.clipValues[i]=T.lerp(e.clipValues[t],e.clipValues[s],n),this.barycoord[i].lerpVectors(e.barycoord[t],e.barycoord[s],n)}copyVertex(e,t,s){this.clipValues[s]=e.clipValues[t],this.barycoord[s].copy(e.barycoord[t])}}function qe(e,t,s,n,i,r){switch(Oe.fromBufferAttribute(e,t),Ne.fromBufferAttribute(e,s),je.fromBufferAttribute(e,n),r.set(0,0,0,0).addScaledVector(Oe,i.x).addScaledVector(Ne,i.y).addScaledVector(je,i.z),e.itemSize){case 3:De.w=0;break;case 2:De.w=0,De.z=0;break;case 1:De.w=0,De.z=0,De.y=0}return r}function Xe(...e){let t="";for(let s=0,n=e.length;s<n;s++)t+=~~(1e5*e[s]+.5),s!==n-1&&(t+="_");return t}const We={},Ye=new b,$e=new b,Qe=new b,Ze=new b,Ke=new b,Je=new b,et=new b,tt=new x,st=new x,nt=new x;class it extends ze{constructor(){super(),this.ellipsoid=new r,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI,this.attributeList=["position","normal","uv"]}clipToQuadrant(e,t,s){const{solid:n,skirtLength:i,ellipsoid:r,smoothSkirtNormals:o}=this;let a,l;this.clearSplitOperations(),this.addSplitOperation(rt("x"),!t),this.addSplitOperation(rt("y"),!s);const c=e.geometry.groups[0],h=this.getClippedData(e,c);if(this.adjustVertices(h,e.position,0),n){a={index:h.index.slice().reverse(),attributes:{}};for(const e in h.attributes)a.attributes[e]=h.attributes[e].slice();const t=a.attributes.normal;if(t)for(let e=0;e<t.length;e+=3)t[e+0]*=-1,t[e+1]*=-1,t[e+2]*=-1;this.adjustVertices(a,e.position,-i)}if(i>0){l={index:[],attributes:{position:[],normal:[],uv:[]}};let t=0;const s={},n=(e,n,i)=>{const r=Xe(...e,...i,...n);r in s||(s[r]=t,t++,l.attributes.position.push(...e),l.attributes.normal.push(...i),l.attributes.uv.push(...n)),l.index.push(s[r])},a=h.index,c=h.attributes.uv,u=h.attributes.position,d=h.attributes.normal,p=h.index.length/3;for(let l=0;l<p;l++){const t=3*l;for(let s=0;s<3;s++){const l=(s+1)%3,h=a[t+s],p=a[t+l];if(tt.fromArray(c,2*h),st.fromArray(c,2*p),tt.x===st.x&&(0===tt.x||.5===tt.x||1===tt.x)||tt.y===st.y&&(0===tt.y||.5===tt.y||1===tt.y)){$e.fromArray(u,3*h),Qe.fromArray(u,3*p);const t=$e,s=Qe,a=Ze.copy($e),l=Ke.copy(Qe);Je.copy(a).add(e.position),r.getPositionToNormal(Je,Je),a.addScaledVector(Je,-i),Je.copy(l).add(e.position),r.getPositionToNormal(Je,Je),l.addScaledVector(Je,-i),o&&d?(Je.fromArray(d,3*h),et.fromArray(d,3*p)):(Je.subVectors(t,s),et.subVectors(t,a).cross(Je).normalize(),Je.copy(et)),n(s,st,et),n(t,tt,Je),n(a,tt,Je),n(s,st,et),n(a,tt,Je),n(l,st,et)}}}}const u=h.index.length,d=h;if(a){const{index:e,attributes:t}=a,s=d.attributes.position.length/3;for(let n=0,i=e.length;n<i;n++)d.index.push(e[n]+s);for(const n in h.attributes)d.attributes[n].push(...t[n])}if(l){const{index:e,attributes:t}=l,s=d.attributes.position.length/3;for(let n=0,i=e.length;n<i;n++)d.index.push(e[n]+s);for(const n in h.attributes)d.attributes[n].push(...t[n])}const p=t?0:-.5,f=s?0:-.5,m=d.attributes.uv;for(let T=0,b=m.length;T<b;T+=2)m[T]=2*(m[T]+p),m[T+1]=2*(m[T+1]+f);const g=this.constructMesh(d.attributes,d.index,e);g.userData.minHeight=e.userData.minHeight,g.userData.maxHeight=e.userData.maxHeight;let y=0,x=0;return g.geometry.addGroup(x,u,y),x+=u,y++,a&&(g.geometry.addGroup(x,a.index.length,y),x+=a.index.length,y++),l&&(g.geometry.addGroup(x,l.index.length,y),x+=l.index.length,y++),g}adjustVertices(e,t,s){const{ellipsoid:n,minLat:i,maxLat:r,minLon:o,maxLon:a}=this,{attributes:l,vertexIsClipped:c}=e,h=l.position,u=l.uv,d=h.length/3;for(let p=0;p<d;p++){const e=tt.fromArray(u,2*p);c&&c[p]&&(Math.abs(e.x-.5)<1e-10&&(e.x=.5),Math.abs(e.y-.5)<1e-10&&(e.y=.5),tt.toArray(u,2*p));const l=T.lerp(i,r,e.y),d=T.lerp(o,a,e.x),f=Ye.fromArray(h,3*p).add(t);n.getPositionToCartographic(f,We),n.getCartographicToPosition(l,d,We.height+s,f),f.sub(t),f.toArray(h,3*p)}}}function rt(e){return(t,s,n,i,r)=>{const o=t.attributes.uv;return tt.fromBufferAttribute(o,s),st.fromBufferAttribute(o,n),nt.fromBufferAttribute(o,i),tt[e]*r.x+st[e]*r.y+nt[e]*r.z-.5}}const ot=Symbol("TILE_X"),at=Symbol("TILE_Y"),lt=Symbol("TILE_LEVEL"),ct=Symbol("TILE_AVAILABLE"),ht=1e4,ut=new b;function dt(e){const{available:t=null,maxzoom:s=null}=e;return null===s?t.length-1:s}function pt(e,t){const s=e[lt],n=function(e){const{metadataAvailability:t=-1}=e;return t}(t);return s<dt(t)&&-1!==n&&s%n===0}class ft{constructor(e={}){const{useRecommendedSettings:t=!0,skirtLength:s=null,smoothSkirtNormals:n=!0,solid:i=!1}=e;this.name="QUANTIZED_MESH_PLUGIN",this.priority=-1e3,this.tiles=null,this.layer=null,this.useRecommendedSettings=t,this.skirtLength=s,this.smoothSkirtNormals=n,this.solid=i,this.attribution=null,this.tiling=new Ee,this.projection=new Le}init(e){e.fetchOptions.headers=e.fetchOptions.headers||{},e.fetchOptions.headers.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",this.useRecommendedSettings&&(e.errorTarget=2),this.tiles=e}loadRootTileSet(){const{tiles:e}=this;let t=new URL("layer.json",new URL(e.rootURL,location.href));return e.invokeAllPlugins(e=>t=e.preprocessURL?e.preprocessURL(t,null):t),e.invokeOnePlugin(e=>e.fetchData&&e.fetchData(t,this.tiles.fetchOptions)).then(e=>e.json()).then(e=>{this.layer=e;const{projection:t="EPSG:4326",extensions:s=[],attribution:n="",available:i=null}=e,{tiling:r,tiles:o,projection:a}=this;n&&(this.attribution={value:n,type:"string",collapsible:!0}),s.length>0&&(o.fetchOptions.headers.Accept+=`;extensions=${s.join("-")}`),a.setScheme(t);const{tileCountX:l,tileCountY:c}=a;r.setProjection(a),r.generateLevels(dt(e)+1,l,c);const h=[];for(let p=0;p<l;p++){const e=this.createChild(0,p,0,i);e&&h.push(e)}const u={asset:{version:"1.1"},geometricError:1/0,root:{refine:"REPLACE",geometricError:1/0,boundingVolume:{region:[...this.tiling.getContentBounds(),-ht,ht]},children:h,[ct]:i,[lt]:-1}};let d=o.rootURL;return o.invokeAllPlugins(e=>d=e.preprocessURL?e.preprocessURL(d,null):d),o.preprocessTileSet(u,d),u})}parseToMesh(e,t,s,n){const{skirtLength:i,solid:r,smoothSkirtNormals:o,tiles:a}=this,l=a.ellipsoid;let c;if("quantized_tile_split"===s){const e=new URL(n).searchParams,s="true"===e.get("left"),a="true"===e.get("bottom"),h=new it;h.ellipsoid.copy(l),h.solid=r,h.smoothSkirtNormals=o,h.skirtLength=null===i?t.geometricError:i;const[u,d,p,f]=t.parent.boundingVolume.region;h.minLat=d,h.maxLat=f,h.minLon=u,h.maxLon=p,c=h.clipToQuadrant(t.parent.cached.scene,s,a)}else{if("terrain"!==s)return;{const s=new Be(a.manager);s.ellipsoid.copy(l),s.solid=r,s.smoothSkirtNormals=o,s.skirtLength=null===i?t.geometricError:i;const[n,h,u,d]=t.boundingVolume.region;s.minLat=h,s.maxLat=d,s.minLon=n,s.maxLon=u,c=s.parse(e)}}const{minHeight:h,maxHeight:u,metadata:d}=c.userData;return t.boundingVolume.region[4]=h,t.boundingVolume.region[5]=u,t.cached.boundingVolume.setRegionData(l,...t.boundingVolume.region),d&&("geometricerror"in d&&(t.geometricError=d.geometricerror),pt(t,this.layer)&&"available"in d&&0===t.children.length&&(t[ct]=[...new Array(t[lt]+1).fill(null),...d.available])),this.expandChildren(t),c}getAttributions(e){this.attribution&&e.push(this.attribution)}createChild(e,t,s,n){const{tiles:i,layer:r,tiling:o,projection:a}=this,l=i.ellipsoid,c=null===n&&0===e||function(e,t,s,n){if(e&&t<e.length){const i=e[t];for(let e=0,t=i.length;e<t;e++){const{startX:t,startY:r,endX:o,endY:a}=i[e];if(s>=t&&s<=o&&n>=r&&n<=a)return!0}}return!1}(n,e,t,s),h=function(e,t,s,n,i){return i.tiles[0].replace(/{\s*z\s*}/g,s).replace(/{\s*x\s*}/g,e).replace(/{\s*y\s*}/g,t).replace(/{\s*version\s*}/g,n)}(t,s,e,1,r),u=[...o.getTileBounds(t,s,e),-ht,ht],[,d,,p,,f]=u,m=d>0!=p>0?0:Math.min(Math.abs(d),Math.abs(p));l.getCartographicToPosition(m,0,f,ut),ut.z=0;const g=a.tileCountX,y=2*Math.max(...l.radius)*Math.PI*.25/(65*g)/2**e,x={[ct]:null,[lt]:e,[ot]:t,[at]:s,refine:"REPLACE",geometricError:y,boundingVolume:{region:u},content:c?{uri:h}:null,children:[]};return pt(x,r)||(x[ct]=n),x}expandChildren(e){const t=e[lt],s=e[ot],n=e[at],i=e[ct];if(t>=this.tiling.maxLevel)return;let r=!1;for(let o=0;o<2;o++)for(let a=0;a<2;a++){const l=this.createChild(t+1,2*s+o,2*n+a,i);null!==l.content?(e.children.push(l),r=!0):(e.children.push(l),l.content={uri:`tile.quantized_tile_split?bottom=${0===a}&left=${0===o}`})}r||(e.children.length=0)}fetchData(e,t){if(/quantized_tile_split/.test(e))return new ArrayBuffer}disposeTile(e){pt(e,this.layer)&&(e[ct]=null),ct in e&&(e.children.forEach(e=>{this.tiles.processNodeQueue.remove(e)}),e.children.length=0,e.__childrenProcessed=0)}}class mt{get apiToken(){return this.auth.apiToken}set apiToken(e){this.auth.apiToken=e}get autoRefreshToken(){return this.auth.autoRefreshToken}set autoRefreshToken(e){this.auth.autoRefreshToken=e}constructor({apiToken:e,assetId:t=null,autoRefreshToken:s=!1,useRecommendedSettings:n=!0}){this.name="CESIUM_ION_AUTH_PLUGIN",this.auth=new h({apiToken:e,autoRefreshToken:s}),this.assetId=t,this.autoRefreshToken=s,this.useRecommendedSettings=n,this.tiles=null,this._tileSetVersion=-1,this._attributions=[]}init(e){null!==this.assetId&&(e.rootURL=`https://api.cesium.com/v1/assets/${this.assetId}/endpoint`),this.tiles=e,this.auth.authURL=e.rootURL,e.resetFailedTiles()}loadRootTileSet(){return this.auth.refreshToken().then(e=>(this._initializeFromAsset(e),this.tiles.invokeOnePlugin(e=>e!==this&&e.loadRootTileSet&&e.loadRootTileSet()))).catch(e=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:e,url:this.auth.authURL})})}preprocessURL(e){return e=new URL(e),/^http/.test(e.protocol)&&-1!=this._tileSetVersion&&e.searchParams.set("v",this._tileSetVersion),e.toString()}fetchData(e,t){return null!==this.tiles.getPluginByName("GOOGLE_CLOUD_AUTH_PLUGIN")?null:this.auth.fetch(e,t)}getAttributions(e){this.tiles.visibleTiles.size>0&&e.push(...this._attributions)}_initializeFromAsset(e){const t=this.tiles;if("externalType"in e){const s=new URL(e.options.url);t.rootURL=e.options.url,t.registerPlugin(new de({apiToken:s.searchParams.get("key"),autoRefreshToken:this.autoRefreshToken,useRecommendedSettings:this.useRecommendedSettings}))}else{"TERRAIN"===e.type&&null===t.getPluginByName("QUANTIZED_MESH_PLUGIN")?t.registerPlugin(new ft({useRecommendedSettings:this.useRecommendedSettings})):"IMAGERY"===e.type&&null===t.getPluginByName("TMS_TILES_PLUGIN")&&t.registerPlugin(new Ie({useRecommendedSettings:this.useRecommendedSettings,shape:"ellipsoid"})),t.rootURL=e.url;const s=new URL(e.url);s.searchParams.has("v")&&-1===this._tileSetVersion&&(this._tileSetVersion=s.searchParams.get("v")),e.attributions&&(this._attributions=e.attributions.map(e=>({value:e.html,type:"html",collapsible:e.collapsible})))}}}const gt=new k;class yt{constructor(){this.name="UPDATE_ON_CHANGE_PLUGIN",this.tiles=null,this.needsUpdate=!1,this.cameraMatrices=new Map}init(e){this.tiles=e,this._needsUpdateCallback=()=>{this.needsUpdate=!0},this._onCameraAdd=({camera:e})=>{this.needsUpdate=!0,this.cameraMatrices.set(e,new k)},this._onCameraDelete=({camera:e})=>{this.needsUpdate=!0,this.cameraMatrices.delete(e)},e.addEventListener("needs-update",this._needsUpdateCallback),e.addEventListener("add-camera",this._onCameraAdd),e.addEventListener("delete-camera",this._onCameraDelete),e.addEventListener("camera-resolution-change",this._needsUpdateCallback),e.cameras.forEach(e=>{this._onCameraAdd({camera:e})})}doTilesNeedUpdate(){const e=this.tiles;let t=!1;this.cameraMatrices.forEach((s,n)=>{gt.copy(e.group.matrixWorld).premultiply(n.matrixWorldInverse).premultiply(n.projectionMatrixInverse),t=t||!gt.equals(s),s.copy(gt)});const s=this.needsUpdate;return this.needsUpdate=!1,s||t}preprocessNode(){this.needsUpdate=!0}dispose(){const e=this.tiles;e.removeEventListener("camera-resolution-change",this._needsUpdateCallback),e.removeEventListener("needs-update",this._needsUpdateCallback),e.removeEventListener("add-camera",this._onCameraAdd),e.removeEventListener("delete-camera",this._onCameraDelete)}}const xt=new b;function Tt(e,t){if(e.isInterleavedBufferAttribute||e.array instanceof t)return e;const s=t===Int8Array||t===Int16Array||t===Int32Array?-1:0,n=new t(e.count*e.itemSize),i=new P(n,e.itemSize,!0),r=e.itemSize,o=e.count;for(let a=0;a<o;a++)for(let t=0;t<r;t++){const n=T.clamp(e.getComponent(a,t),s,1);i.setComponent(a,t,n)}return i}class bt{constructor(e){this._options={generateNormals:!1,disableMipmaps:!0,compressIndex:!0,compressNormals:!1,compressUvs:!1,compressPosition:!1,uvType:Int8Array,normalType:Int8Array,positionType:Int16Array,...e},this.name="TILES_COMPRESSION_PLUGIN",this.priority=-100}processTileModel(e,t){const{generateNormals:s,disableMipmaps:n,compressIndex:i,compressUvs:r,compressNormals:o,compressPosition:a,uvType:l,normalType:c,positionType:h}=this._options;e.traverse(e=>{if(e.material&&n){const t=e.material;for(const e in t){const s=t[e];s&&s.isTexture&&s.generateMipmaps&&(s.generateMipmaps=!1,s.minFilter=U)}}if(e.geometry){const t=e.geometry,n=t.attributes;if(r){const{uv:e,uv1:t,uv2:s,uv3:i}=n;e&&(n.uv=Tt(e,l)),t&&(n.uv1=Tt(t,l)),s&&(n.uv2=Tt(s,l)),i&&(n.uv3=Tt(i,l))}if(s&&!n.normals&&t.computeVertexNormals(),o&&n.normals&&(n.normals=Tt(n.normals,c)),a&&function(e,t=Int16Array){const s=e.geometry,n=s.attributes,i=n.position;if(i.isInterleavedBufferAttribute||i.array instanceof t)return i;const r=new t(i.count*i.itemSize),o=new P(r,i.itemSize,!1),a=i.itemSize,l=i.count;s.computeBoundingBox();const c=s.boundingBox,{min:h,max:u}=c,d=2**(8*t.BYTES_PER_ELEMENT-1)-1,p=-d;for(let f=0;f<l;f++)for(let e=0;e<a;e++){const t=0===e?"x":1===e?"y":"z",s=h[t],n=u[t],r=T.mapLinear(i.getComponent(f,e),s,n,p,d);o.setComponent(f,e,r)}c.getCenter(xt).multiply(e.scale).applyQuaternion(e.quaternion),e.position.add(xt),e.scale.x*=.5*(u.x-h.x)/d,e.scale.y*=.5*(u.y-h.y)/d,e.scale.z*=.5*(u.z-h.z)/d,n.position=o,e.geometry.boundingBox=null,e.geometry.boundingSphere=null,e.updateMatrixWorld()}(e,h),i&&t.index){const e=n.position.count,s=t.index,i=e>65535?Uint32Array:e>255?Uint16Array:Uint8Array;if(!(s.array instanceof i)){const e=new i(t.index.count);e.set(s.array);const n=new P(e,1);t.setIndex(n)}}}})}}function vt(e,t,s){return e&&t in e?e[t]:s}function At(e){return"BOOLEAN"!==e&&"STRING"!==e&&"ENUM"!==e}function _t(e){return/^VEC/.test(e)}function wt(e){return/^MAT/.test(e)}function Lt(e,t,s,n=null){return wt(s)||_t(s)?n.fromArray(e,t):e[t]}function Mt(e){const{type:t,componentType:s}=e;switch(t){case"SCALAR":return"INT64"===s?0n:0;case"VEC2":return new x;case"VEC3":return new b;case"VEC4":return new V;case"MAT2":return new F;case"MAT3":return new B;case"MAT4":return new k;case"BOOLEAN":return!1;case"STRING":return"";case"ENUM":return 0}}function Pt(e,t){if(null==t)return!1;switch(e){case"SCALAR":case"ENUM":return"number"==typeof t||"bigint"==typeof t;case"VEC2":return t.isVector2;case"VEC3":return t.isVector3;case"VEC4":return t.isVector4;case"MAT2":return t.isMatrix2;case"MAT3":return t.isMatrix3;case"MAT4":return t.isMatrix4;case"BOOLEAN":return"boolean"==typeof t;case"STRING":return"string"==typeof t}throw new Error("ClassProperty: invalid type.")}function Et(e,t=null){switch(e){case"INT8":return Int8Array;case"INT16":return Int16Array;case"INT32":return Int32Array;case"INT64":return BigInt64Array;case"UINT8":return Uint8Array;case"UINT16":return Uint16Array;case"UINT32":return Uint32Array;case"UINT64":return BigUint64Array;case"FLOAT32":return Float32Array;case"FLOAT64":return Float64Array}switch(t){case"BOOLEAN":case"STRING":return Uint8Array}throw new Error("ClassProperty: invalid type.")}function Ct(e,t=null){const s=e.default,n=e.type;if(t=t||Mt(e),null===s){switch(n){case"SCALAR":return 0;case"VEC2":return t.set(0,0);case"VEC3":return t.set(0,0,0);case"VEC4":return t.set(0,0,0,0);case"MAT2":case"MAT3":case"MAT4":return t.identity();case"BOOLEAN":return!1;case"STRING":case"ENUM":return""}throw new Error("ClassProperty: invalid type.")}if(wt(n))t.fromArray(s);else{if(!_t(n))return s;t.fromArray(s)}}function St(e,t){if(null===e.noData)return t;const s=e.noData,n=e.type;if(Array.isArray(t))for(let r=0,o=t.length;r<o;r++)t[r]=i(t[r]);else t=i(t);return t;function i(t){return function(e){if(wt(n)){const t=e.elements;for(let e=0,n=s.length;e<n;e++)if(s[e]!==t[e])return!1;return!0}if(_t(n)){for(let t=0,n=s.length;t<n;t++)if(s[t]!==e.getComponent(t))return!1;return!0}return s===e}(t)&&(t=Ct(e,t)),t}}function It(e,t){const{type:s,componentType:n,scale:i,offset:r,normalized:o}=e;if(Array.isArray(t))for(let c=0,h=t.length;c<h;c++)t[c]=a(t[c]);else t=a(t);return t;function a(e){return e=wt(s)?function(e){const t=e.elements;for(let s=0,n=t.length;s<n;s++)t[s]=l(t[s]);return e}(e):_t(s)?function(e){return e.x=l(e.x),e.y=l(e.y),"z"in e&&(e.z=l(e.z)),"w"in e&&(e.w=l(e.w)),e}(e):l(e)}function l(e){return o&&(e=function(e,t){switch(e){case"INT8":return Math.max(t/127,-1);case"INT16":return Math.max(t,32767,-1);case"INT32":return Math.max(t/2147483647,-1);case"INT64":return Math.max(Number(t)/0x8000000000000000,-1);case"UINT8":return t/255;case"UINT16":return t/65535;case"UINT32":return t/4294967295;case"UINT64":return Number(t)/0x10000000000000000}}(n,e)),(o||function(e){return/^FLOAT/.test(e)}(n))&&(e=e*i+r),e}}function Ut(e,t,s=null){if(e.array){Array.isArray(t)||(t=new Array(e.count||0)),t.length=null!==s?s:e.count;for(let s=0,n=t.length;s<n;s++)Pt(e.type,t[s])||(t[s]=Mt(e))}else Pt(e.type,t)||(t=Mt(e));return t}function Rt(e,t){for(const s in t)s in e||delete t[s];for(const s in e){const n=e[s];t[s]=Ut(n,t[s])}}class Vt{constructor(e,t,s=null){this.name=t.name||null,this.description=t.description||null,this.type=t.type,this.componentType=t.componentType||null,this.enumType=t.enumType||null,this.array=t.array||!1,this.count=t.count||0,this.normalized=t.normalized||!1,this.offset=t.offset||0,this.scale=vt(t,"scale",1),this.max=vt(t,"max",1/0),this.min=vt(t,"min",-1/0),this.required=t.required||!1,this.noData=vt(t,"noData",null),this.default=vt(t,"default",null),this.semantic=vt(t,"semantic",null),this.enumSet=null,this.accessorProperty=s,s&&(this.offset=vt(s,"offset",this.offset),this.scale=vt(s,"scale",this.scale),this.max=vt(s,"max",this.max),this.min=vt(s,"min",this.min)),"ENUM"===t.type&&(this.enumSet=e[this.enumType],null===this.componentType&&(this.componentType=vt(this.enumSet,"valueType","UINT16")))}shapeToProperty(e,t=null){return Ut(this,e,t)}resolveDefaultElement(e){return Ct(this,e)}resolveDefault(e){return function(e,t=null){if(e.array){(t=t&&Array.isArray(t)?t:[]).length=e.count;for(let s=0,n=t.length;s<n;s++)t[s]=Ct(e,t[s])}else t=Ct(e,t);return t}(this,e)}resolveNoData(e){return St(this,e)}resolveEnumsToStrings(e){const t=this.enumSet;if("ENUM"===this.type)if(Array.isArray(e))for(let n=0,i=e.length;n<i;n++)e[n]=s(e[n]);else e=s(e);return e;function s(e){const s=t.values.find(t=>t.value===e);return null===s?"":s.name}}adjustValueScaleOffset(e){return At(this.type)?It(this,e):e}}class kt{constructor(e,t={},s={},n=null){this.definition=e,this.class=t[e.class],this.className=e.class,this.enums=s,this.data=n,this.name="name"in e?e.name:null,this.properties=null}getPropertyNames(){return Object.keys(this.class.properties)}includesData(e){return!!this.definition.properties[e]}dispose(){}_initProperties(e=Vt){const t={};for(const s in this.class.properties)t[s]=new e(this.enums,this.class.properties[s],this.definition.properties[s]);this.properties=t}}class Bt extends Vt{constructor(e,t,s=null){super(e,t,s),this.attribute=(null==s?void 0:s.attribute)??null}}class Ft extends kt{constructor(...e){super(...e),this.isPropertyAttributeAccessor=!0,this._initProperties(Bt)}getData(e,t,s={}){const n=this.properties;Rt(n,s);for(const i in n)s[i]=this.getPropertyValue(i,e,t,s[i]);return s}getPropertyValue(e,t,s,n=null){if(t>=this.count)throw new Error("PropertyAttributeAccessor: Requested index is outside the range of the buffer.");const i=this.properties[e],r=i.type;if(!i)throw new Error("PropertyAttributeAccessor: Requested class property does not exist.");if(!this.definition.properties[e])return i.resolveDefault(n);n=i.shapeToProperty(n);const o=s.getAttribute(i.attribute.toLowerCase());if(wt(r)){const e=n.elements;for(let s=0,n=e.length;s<n;s<n)e[s]=o.getComponent(t,s)}else if(_t(r))n.fromBufferAttribute(o,t);else{if("SCALAR"!==r&&"ENUM"!==r)throw new Error("StructuredMetadata.PropertyAttributeAccessor: BOOLEAN and STRING types are not supported by property attributes.");n=o.getX(t)}return n=i.adjustValueScaleOffset(n),n=i.resolveEnumsToStrings(n),n=i.resolveNoData(n)}}class Dt extends Vt{constructor(e,t,s=null){super(e,t,s),this.values=(null==s?void 0:s.values)??null,this.valueLength=function(e){switch(e){case"ENUM":case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;default:return-1}}(this.type),this.arrayOffsets=vt(s,"arrayOffsets",null),this.stringOffsets=vt(s,"stringOffsets",null),this.arrayOffsetType=vt(s,"arrayOffsetType","UINT32"),this.stringOffsetType=vt(s,"stringOffsetType","UINT32")}getArrayLengthFromId(e,t){let s=this.count;if(null!==this.arrayOffsets){const{arrayOffsets:n,arrayOffsetType:i}=this,r=new(Et(i))(e[n]);s=r[t+1]-r[t]}return s}getIndexOffsetFromId(e,t){let s=t;if(this.arrayOffsets){const{arrayOffsets:t,arrayOffsetType:n}=this;s=new(Et(n))(e[t])[s]}else this.array&&(s*=this.count);return s}}class Ot extends kt{constructor(...e){super(...e),this.isPropertyTableAccessor=!0,this.count=this.definition.count,this._initProperties(Dt)}getData(e,t={}){const s=this.properties;Rt(s,t);for(const n in s)t[n]=this.getPropertyValue(n,e,t[n]);return t}_readValueAtIndex(e,t,s,n=null){const i=this.properties[e],{componentType:r,type:o}=i,a=this.data,l=a[i.values],c=new(Et(r,o))(l),h=i.getIndexOffsetFromId(a,t);if(At(o)||"ENUM"===o)return Lt(c,(h+s)*i.valueLength,o,n);if("STRING"===o){let e=h+s,t=0;if(null!==i.stringOffsets){const{stringOffsets:s,stringOffsetType:n}=i,r=new(Et(n))(a[s]);t=r[e+1]-r[e],e=r[e]}const r=new Uint8Array(c.buffer,e,t);n=(new TextDecoder).decode(r)}else if("BOOLEAN"===o){const e=h+s,t=e%8;n=1==(c[Math.floor(e/8)]>>t&1)}return n}getPropertyValue(e,t,s=null){if(t>=this.count)throw new Error("PropertyTableAccessor: Requested index is outside the range of the table.");const n=this.properties[e];if(!n)throw new Error("PropertyTableAccessor: Requested property does not exist.");if(!this.definition.properties[e])return n.resolveDefault(s);const i=n.array,r=this.data,o=n.getArrayLengthFromId(r,t);if(s=n.shapeToProperty(s,o),i)for(let a=0,l=s.length;a<l;a++)s[a]=this._readValueAtIndex(e,t,a,s[a]);else s=this._readValueAtIndex(e,t,0,s);return s=n.adjustValueScaleOffset(s),s=n.resolveEnumsToStrings(s),s=n.resolveNoData(s)}}const Nt=new H;class jt{constructor(){this._renderer=new D,this._target=new O(1,1),this._texTarget=new O,this._quad=new o(new N({blending:G,blendDst:z,blendSrc:j,uniforms:{map:{value:null},pixel:{value:new x}},vertexShader:"\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform ivec2 pixel;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texelFetch( map, pixel, 0 );\n\n\t\t\t\t}\n\t\t\t"}))}increaseSizeTo(e){this._target.setSize(Math.max(this._target.width,e),1)}readDataAsync(e){const{_renderer:t,_target:s}=this;return t.readRenderTargetPixelsAsync(s,0,0,e.length/4,1,e)}readData(e){const{_renderer:t,_target:s}=this;t.readRenderTargetPixels(s,0,0,e.length/4,1,e)}renderPixelToTarget(e,t,s){const{_renderer:n,_target:i}=this;Nt.min.copy(t),Nt.max.copy(t),Nt.max.x+=1,Nt.max.y+=1,n.initRenderTarget(i),n.copyTextureToTexture(e,i.texture,Nt,s,0)}}const zt=new class{constructor(){let e=null;Object.getOwnPropertyNames(jt.prototype).forEach(t=>{"constructor"!==t&&(this[t]=(...s)=>(e=e||new jt,e[t](...s)))})}},Gt=new x,Ht=new x,qt=new x;function Xt(e,t,s=new Array(3)){let n=3*t,i=3*t+1,r=3*t+2;return e.index&&(n=e.index.getX(n),i=e.index.getX(i),r=e.index.getX(r)),s[0]=n,s[1]=i,s[2]=r,s}function Wt(e,t,s,n,i){const[r,o,a]=n,l=function(e,t){return 0===t?e.getAttribute("uv"):e.getAttribute(`uv${t}`)}(e,t);Gt.fromBufferAttribute(l,r),Ht.fromBufferAttribute(l,o),qt.fromBufferAttribute(l,a),i.set(0,0,0).addScaledVector(Gt,s.x).addScaledVector(Ht,s.y).addScaledVector(qt,s.z)}function Yt(e,t,s,n){const i=e.x-Math.floor(e.x),r=e.y-Math.floor(e.y),o=Math.floor(i*t%t),a=Math.floor(r*s%s);return n.set(o,a),n}const $t=new x,Qt=new x,Zt=new x;class Kt extends Vt{constructor(e,t,s=null){super(e,t,s),this.channels=vt(s,"channels",[0]),this.index=vt(s,"index",null),this.texCoord=vt(s,"texCoord",null),this.valueLength=parseInt(this.type.replace(/[^0-9]/g,""))||1}readDataFromBuffer(e,t,s=null){const n=this.type;if("BOOLEAN"===n||"STRING"===n)throw new Error("PropertyTextureAccessor: BOOLEAN and STRING types not supported.");return Lt(e,t*this.valueLength,n,s)}}class Jt extends kt{constructor(...e){super(...e),this.isPropertyTextureAccessor=!0,this._asyncRead=!1,this._initProperties(Kt)}getData(e,t,s,n={}){const i=this.properties;Rt(i,n);const r=Object.keys(i),o=r.map(e=>n[e]);return this.getPropertyValuesAtTexel(r,e,t,s,o),r.forEach((e,t)=>n[e]=o[t]),n}async getDataAsync(e,t,s,n={}){const i=this.properties;Rt(i,n);const r=Object.keys(i),o=r.map(e=>n[e]);return await this.getPropertyValuesAtTexelAsync(r,e,t,s,o),r.forEach((e,t)=>n[e]=o[t]),n}getPropertyValuesAtTexelAsync(...e){this._asyncRead=!0;const t=this.getPropertyValuesAtTexel(...e);return this._asyncRead=!1,t}getPropertyValuesAtTexel(e,t,s,n,i=[]){for(;i.length<e.length;)i.push(null);i.length=e.length,zt.increaseSizeTo(i.length);const r=this.data,o=this.definition.properties,a=this.properties,l=Xt(n,t);for(let u=0,d=e.length;u<d;u++){const t=e[u];if(!o[t])continue;const i=a[t],c=r[i.index];Wt(n,i.texCoord,s,l,$t),Yt($t,c.image.width,c.image.height,Qt),Zt.set(u,0),zt.renderPixelToTarget(c,Qt,Zt)}const c=new Uint8Array(4*e.length);return this._asyncRead?zt.readDataAsync(c).then(()=>(h.call(this),i)):(zt.readData(c),h.call(this),i);function h(){for(let t=0,s=e.length;t<s;t++){const s=e[t],n=a[s],r=n.type;if(i[t]=Ut(n,i[t]),!n)throw new Error("PropertyTextureAccessor: Requested property does not exist.");if(!o[s]){i[t]=n.resolveDefault(i);continue}const l=n.valueLength*(n.count||1),h=n.channels.map(e=>c[4*t+e]),u=new(Et(n.componentType,r))(l);if(new Uint8Array(u.buffer).set(h),n.array){const e=i[t];for(let t=0,s=e.length;t<s;t++)e[t]=n.readDataFromBuffer(u,t,e[t])}else i[t]=n.readDataFromBuffer(u,0,i[t]);i[t]=n.adjustValueScaleOffset(i[t]),i[t]=n.resolveEnumsToStrings(i[t]),i[t]=n.resolveNoData(i[t])}}}dispose(){this.data.forEach(e=>{e&&(e.dispose(),e.image instanceof ImageBitmap&&e.image.close())})}}class es{constructor(e,t,s,n=null,i=null){const{schema:r,propertyTables:o=[],propertyTextures:a=[],propertyAttributes:l=[]}=e,{enums:c,classes:h}=r,u=o.map(e=>new Ot(e,h,c,s));let d=[],p=[];n&&(n.propertyTextures&&(d=n.propertyTextures.map(e=>new Jt(a[e],h,c,t))),n.propertyAttributes&&(p=n.propertyAttributes.map(e=>new Ft(l[e],h,c)))),this.schema=r,this.tableAccessors=u,this.textureAccessors=d,this.attributeAccessors=p,this.object=i,this.textures=t,this.nodeMetadata=n}getPropertyTableData(e,t,s=null){if(Array.isArray(e)&&Array.isArray(t)){s=s||[];const n=Math.min(e.length,t.length);s.length=n;for(let i=0;i<n;i++){const n=this.tableAccessors[e[i]];s[i]=n.getData(t[i],s[i])}}else s=s||{},s=this.tableAccessors[e].getData(t,s);return s}getPropertyTableInfo(e=null){if(null===e&&(e=this.tableAccessors.map((e,t)=>t)),Array.isArray(e))return e.map(e=>{const t=this.tableAccessors[e];return{name:t.name,className:t.definition.class}});{const t=this.tableAccessors[e];return{name:t.name,className:t.definition.class}}}getPropertyTextureData(e,t,s=[]){const n=this.textureAccessors;s.length=n.length;for(let i=0;i<n.length;i++){const r=n[i];s[i]=r.getData(e,t,this.object.geometry,s[i])}return s}async getPropertyTextureDataAsync(e,t,s=[]){const n=this.textureAccessors;s.length=n.length;const i=[];for(let r=0;r<n.length;r++){const o=n[r].getDataAsync(e,t,this.object.geometry,s[r]).then(e=>{s[r]=e});i.push(o)}return await Promise.all(i),s}getPropertyTextureInfo(){return this.textureAccessors}getPropertyAttributeData(e,t=[]){const s=this.attributeAccessors;t.length=s.length;for(let n=0;n<s.length;n++){const i=s[n];t[n]=i.getData(e,this.object.geometry,t[n])}return t}getPropertyAttributeInfo(){return this.attributeAccessors.map(e=>({name:e.name,className:e.definition.class}))}dispose(){this.textureAccessors.forEach(e=>e.dispose()),this.tableAccessors.forEach(e=>e.dispose()),this.attributeAccessors.forEach(e=>e.dispose())}}const ts="EXT_structural_metadata";function ss(e,t=[]){var s;const n=(null==(s=e.json.textures)?void 0:s.length)||0,i=new Array(n).fill(null);return t.forEach(({properties:t})=>{for(const s in t){const{index:n}=t[s];null===i[n]&&(i[n]=e.loadTexture(n))}}),Promise.all(i)}function ns(e,t=[]){var s;const n=(null==(s=e.json.bufferViews)?void 0:s.length)||0,i=new Array(n).fill(null);return t.forEach(({properties:t})=>{for(const s in t){const{values:n,arrayOffsets:r,stringOffsets:o}=t[s];null===i[n]&&(i[n]=e.loadBufferView(n)),null===i[r]&&(i[r]=e.loadBufferView(r)),null===i[o]&&(i[o]=e.loadBufferView(o))}}),Promise.all(i)}class is{constructor(e){this.parser=e,this.name=ts}async afterRoot({scene:e,parser:t}){const s=t.json.extensionsUsed;if(!s||!s.includes(ts))return;let n=null,i=t.json.extensions[ts];if(i.schemaUri){const{manager:e,path:s,requestHeader:r,crossOrigin:o}=t.options,a=new URL(i.schemaUri,s).toString(),l=new q(e);l.setCrossOrigin(o),l.setResponseType("json"),l.setRequestHeader(r),n=l.loadAsync(a).then(e=>{i={...i,schema:e}})}const[r,o]=await Promise.all([ss(t,i.propertyTextures),ns(t,i.propertyTables),n]),a=new es(i,r,o);e.userData.structuralMetadata=a,e.traverse(e=>{var s;if(t.associations.has(e)){const{meshes:n,primitives:l}=t.associations.get(e),c=null==(s=t.json.meshes[n])?void 0:s.primitives[l];if(c&&c.extensions&&c.extensions[ts]){const t=c.extensions[ts];e.userData.structuralMetadata=new es(i,r,o,t,e)}else e.userData.structuralMetadata=a}})}}const rs=new x,os=new x,as=new x;class ls{constructor(e,t,s){this.geometry=e,this.textures=t,this.data=s,this._asyncRead=!1,this.featureIds=s.featureIds.map(e=>{const{texture:t,...s}=e,n={label:null,propertyTable:null,nullFeatureId:null,...s};return t&&(n.texture={texCoord:0,channels:[0],...t}),n})}getTextures(){return this.textures}getFeatureInfo(){return this.featureIds}getFeaturesAsync(...e){this._asyncRead=!0;const t=this.getFeatures(...e);return this._asyncRead=!1,t}getFeatures(e,t){const{geometry:s,textures:n,featureIds:i}=this,r=new Array(i.length).fill(null),o=i.length;zt.increaseSizeTo(o);const a=Xt(s,e),l=a[(c=t,c.x>c.y&&c.x>c.z?0:c.y>c.z?1:2)];var c;for(let d=0,p=i.length;d<p;d++){const e=i[d],o="nullFeatureId"in e?e.nullFeatureId:null;if("texture"in e){const i=n[e.texture.index];Wt(s,e.texture.texCoord,t,a,rs),Yt(rs,i.image.width,i.image.height,os),as.set(d,0),zt.renderPixelToTarget(n[e.texture.index],os,as)}else if("attribute"in e){const t=s.getAttribute(`_feature_id_${e.attribute}`).getX(l);t!==o&&(r[d]=t)}else{const e=l;e!==o&&(r[d]=e)}}const h=new Uint8Array(4*o);return this._asyncRead?zt.readDataAsync(h).then(()=>(u(),r)):(zt.readData(h),u(),r);function u(){const e=new Uint32Array(1);for(let t=0,s=i.length;t<s;t++){const s=i[t],n="nullFeatureId"in s?s.nullFeatureId:null;if("texture"in s){const{channels:i}=s.texture,o=i.map(e=>h[4*t+e]);new Uint8Array(e.buffer).set(o);const a=e[0];a!==n&&(r[t]=a)}}}}dispose(){this.textures.forEach(e=>{e&&(e.dispose(),e.image instanceof ImageBitmap&&e.image.close())})}}const cs="EXT_mesh_features";function hs(e,t,s){e.traverse(e=>{var n;if(t.associations.has(e)){const{meshes:i,primitives:r}=t.associations.get(e),o=null==(n=t.json.meshes[i])?void 0:n.primitives[r];o&&o.extensions&&o.extensions[cs]&&s(e,o.extensions[cs])}})}class us{constructor(e){this.parser=e,this.name=cs}async afterRoot({scene:e,parser:t}){var s;const n=t.json.extensionsUsed;if(!n||!n.includes(cs))return;const i=(null==(s=t.json.textures)?void 0:s.length)||0,r=new Array(i).fill(null);hs(e,t,(e,{featureIds:s})=>{s.forEach(e=>{if(e.texture&&null===r[e.texture.index]){const s=e.texture.index;r[s]=t.loadTexture(s)}})});const o=await Promise.all(r);hs(e,t,(e,t)=>{e.userData.meshFeatures=new ls(e.geometry,o,t)})}}class ds{constructor(){this.name="CESIUM_RTC"}afterRoot(e){if(e.parser.json.extensions&&e.parser.json.extensions.CESIUM_RTC){const{center:t}=e.parser.json.extensions.CESIUM_RTC;t&&(e.scene.position.x+=t[0],e.scene.position.y+=t[1],e.scene.position.z+=t[2])}}}class ps{constructor(e){e={metadata:!0,rtc:!0,plugins:[],dracoLoader:null,ktxLoader:null,meshoptDecoder:null,autoDispose:!0,...e},this.tiles=null,this.metadata=e.metadata,this.rtc=e.rtc,this.plugins=e.plugins,this.dracoLoader=e.dracoLoader,this.ktxLoader=e.ktxLoader,this.meshoptDecoder=e.meshoptDecoder,this._gltfRegex=/\.(gltf|glb)$/g,this._dracoRegex=/\.drc$/g,this._loader=null}init(e){const t=new i(e.manager);this.dracoLoader&&(t.setDRACOLoader(this.dracoLoader),e.manager.addHandler(this._dracoRegex,this.dracoLoader)),this.ktxLoader&&t.setKTX2Loader(this.ktxLoader),this.meshoptDecoder&&t.setMeshoptDecoder(this.meshoptDecoder),this.rtc&&t.register(()=>new ds),this.metadata&&(t.register(()=>new is),t.register(()=>new us)),this.plugins.forEach(e=>t.register(e)),e.manager.addHandler(this._gltfRegex,t),this.tiles=e,this._loader=t}dispose(){this.tiles.manager.removeHandler(this._gltfRegex),this.tiles.manager.removeHandler(this._dracoRegex),this.autoDispose&&(this.ktxLoader.dispose(),this.dracoLoader.dispose())}}class fs{set delay(e){this.deferCallbacks.delay=e}get delay(){return this.deferCallbacks.delay}set bytesTarget(e){this.lruCache.minBytesSize=e}get bytesTarget(){return this.lruCache.minBytesSize}get estimatedGpuBytes(){return this.lruCache.cachedBytes}constructor(e={}){const{delay:t=0,bytesTarget:s=0}=e;this.name="UNLOAD_TILES_PLUGIN",this.tiles=null,this.lruCache=new n,this.deferCallbacks=new ms,this.delay=t,this.bytesTarget=s}init(e){this.tiles=e;const{lruCache:t,deferCallbacks:s}=this;s.callback=e=>{t.markUnused(e),t.scheduleUnload(!1)};const n=t=>{const s=t.cached.scene;e.visibleTiles.has(t)||e.invokeOnePlugin(e=>e.unloadTileFromGPU&&e.unloadTileFromGPU(s,t))};this._onUpdateBefore=()=>{t.unloadPriorityCallback=e.lruCache.unloadPriorityCallback,t.computeMemoryUsageCallback=e.lruCache.computeMemoryUsageCallback,t.minSize=1/0,t.maxSize=1/0,t.maxBytesSize=1/0,t.unloadPercent=1,t.autoMarkUnused=!1},this._onVisibilityChangeCallback=({tile:i,visible:r})=>{r?(t.add(i,n),e.markTileUsed(i),s.cancel(i)):s.run(i)},e.forEachLoadedModel((t,s)=>{const n=e.visibleTiles.has(s);this._onVisibilityChangeCallback({scene:t,visible:n})}),e.addEventListener("tile-visibility-change",this._onVisibilityChangeCallback),e.addEventListener("update-before",this._onUpdateBefore)}unloadTileFromGPU(e,t){e&&e.traverse(e=>{if(e.material){const t=e.material;t.dispose();for(const e in t){const s=t[e];s&&s.isTexture&&s.dispose()}}e.geometry&&e.geometry.dispose()})}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._onVisibilityChangeCallback),this.tiles.removeEventListener("update-before",this._onUpdateBefore),this.deferCallbacks.cancelAll()}}class ms{constructor(e=()=>{}){this.map=new Map,this.callback=e,this.delay=0}run(e){const{map:t,delay:s}=this;if(t.has(e))throw new Error("DeferCallbackManager: Callback already initialized.");0===s?this.callback(e):t.set(e,setTimeout(()=>this.callback(e),s))}cancel(e){const{map:t}=this;t.has(e)&&(clearTimeout(t.get(e)),t.delete(e))}cancelAll(){this.map.forEach((e,t)=>{this.cancel(t)})}}const{clamp:gs}=T;class ys{constructor(){this.duration=250,this.fadeCount=0,this._lastTick=-1,this._fadeState=new Map,this.onFadeComplete=null,this.onFadeStart=null,this.onFadeSetComplete=null,this.onFadeSetStart=null}deleteObject(e){e&&this.completeFade(e)}guaranteeState(e){const t=this._fadeState;if(t.has(e))return!1;return t.set(e,{fadeInTarget:0,fadeOutTarget:0,fadeIn:0,fadeOut:0}),!0}completeFade(e){const t=this._fadeState;if(!t.has(e))return;const s=0===t.get(e).fadeOutTarget;t.delete(e),this.fadeCount--,this.onFadeComplete&&this.onFadeComplete(e,s),0===this.fadeCount&&this.onFadeSetComplete&&this.onFadeSetComplete()}completeAllFades(){this._fadeState.forEach((e,t)=>{this.completeFade(t)})}forEachObject(e){this._fadeState.forEach((t,s)=>{e(s,t)})}fadeIn(e){const t=this.guaranteeState(e),s=this._fadeState.get(e);s.fadeInTarget=1,s.fadeOutTarget=0,s.fadeOut=0,t&&(this.fadeCount++,1===this.fadeCount&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(e))}fadeOut(e){const t=this.guaranteeState(e),s=this._fadeState.get(e);s.fadeOutTarget=1,t&&(s.fadeInTarget=1,s.fadeIn=1,this.fadeCount++,1===this.fadeCount&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(e))}isFading(e){return this._fadeState.has(e)}isFadingOut(e){const t=this._fadeState.get(e);return t&&1===t.fadeOutTarget}update(){const e=window.performance.now();-1===this._lastTick&&(this._lastTick=e);const t=gs((e-this._lastTick)/this.duration,0,1);this._lastTick=e,this._fadeState.forEach((e,s)=>{const{fadeOutTarget:n,fadeInTarget:i}=e;let{fadeOut:r,fadeIn:o}=e;const a=Math.sign(i-o);o=gs(o+a*t,0,1);const l=Math.sign(n-r);r=gs(r+l*t,0,1),e.fadeIn=o,e.fadeOut=r,((1===r||0===r)&&(1===o||0===o)||r>=o)&&this.completeFade(s)})}}const xs=Symbol("FADE_PARAMS");function Ts(e,t){if(e[xs])return e[xs];const s={fadeIn:{value:0},fadeOut:{value:0},fadeTexture:{value:null}};return e[xs]=s,e.defines={...e.defines||{},FEATURE_FADE:0},e.onBeforeCompile=e=>{t&&t(e),e.uniforms={...e.uniforms,...s},e.vertexShader=e.vertexShader.replace(/void\s+main\(\)\s+{/,e=>`\n\t\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t\tvarying float vBatchId;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t${e}\n\n\t\t\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t\t\t// add 0.5 to the value to avoid floating error that may cause flickering\n\t\t\t\t\t\tvBatchId = getIndirectIndex( gl_DrawID ) + 0.5;\n\n\t\t\t\t\t\t#endif\n\t\t\t\t`),e.fragmentShader=e.fragmentShader.replace(/void main\(/,e=>`\n\t\t\t\t#if FEATURE_FADE\n\n\t\t\t\t// adapted from https://www.shadertoy.com/view/Mlt3z8\n\t\t\t\tfloat bayerDither2x2( vec2 v ) {\n\n\t\t\t\t\treturn mod( 3.0 * v.y + 2.0 * v.x, 4.0 );\n\n\t\t\t\t}\n\n\t\t\t\tfloat bayerDither4x4( vec2 v ) {\n\n\t\t\t\t\tvec2 P1 = mod( v, 2.0 );\n\t\t\t\t\tvec2 P2 = floor( 0.5 * mod( v, 4.0 ) );\n\t\t\t\t\treturn 4.0 * bayerDither2x2( P1 ) + bayerDither2x2( P2 );\n\n\t\t\t\t}\n\n\t\t\t\t// the USE_BATCHING define is not available in fragment shaders\n\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t// functions for reading the fade state of a given batch id\n\t\t\t\tuniform sampler2D fadeTexture;\n\t\t\t\tvarying float vBatchId;\n\t\t\t\tvec2 getFadeValues( const in float i ) {\n\n\t\t\t\t\tint size = textureSize( fadeTexture, 0 ).x;\n\t\t\t\t\tint j = int( i );\n\t\t\t\t\tint x = j % size;\n\t\t\t\t\tint y = j / size;\n\t\t\t\t\treturn texelFetch( fadeTexture, ivec2( x, y ), 0 ).rg;\n\n\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\tuniform float fadeIn;\n\t\t\t\tuniform float fadeOut;\n\n\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t${e}\n\t\t\t`).replace(/#include <dithering_fragment>/,e=>`\n\n\t\t\t\t${e}\n\n\t\t\t\t#if FEATURE_FADE\n\n\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\tvec2 fadeValues = getFadeValues( vBatchId );\n\t\t\t\tfloat fadeIn = fadeValues.r;\n\t\t\t\tfloat fadeOut = fadeValues.g;\n\n\t\t\t\t#endif\n\n\t\t\t\tfloat bayerValue = bayerDither4x4( floor( mod( gl_FragCoord.xy, 4.0 ) ) );\n\t\t\t\tfloat bayerBins = 16.0;\n\t\t\t\tfloat dither = ( 0.5 + bayerValue ) / bayerBins;\n\t\t\t\tif ( dither >= fadeIn ) {\n\n\t\t\t\t\tdiscard;\n\n\t\t\t\t}\n\n\t\t\t\tif ( dither < fadeOut ) {\n\n\t\t\t\t\tdiscard;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t`)},s}class bs{constructor(){this._fadeParams=new WeakMap,this.fading=0}setFade(e,t,s){if(!e)return;const n=this._fadeParams;e.traverse(e=>{const i=e.material;if(i&&n.has(i)){const e=n.get(i);e.fadeIn.value=t,e.fadeOut.value=s;const r=+(!(0===t||1===t)||!(0===s||1===s));i.defines.FEATURE_FADE!==r&&(this.fading+=1===r?1:-1,i.defines.FEATURE_FADE=r,i.needsUpdate=!0)}})}prepareScene(e){e.traverse(e=>{e.material&&this.prepareMaterial(e.material)})}deleteScene(e){if(!e)return;this.setFade(e,1,0);const t=this._fadeParams;e.traverse(e=>{const s=e.material;s&&t.delete(s)})}prepareMaterial(e){const t=this._fadeParams;t.has(e)||t.set(e,Ts(e,e.onBeforeCompile))}}class vs{constructor(e,t=new y){this.other=e,this.material=t,this.visible=!0,this.parent=null,this._instanceInfo=[],this._visibilityChanged=!0;const s=new Proxy(this,{get(t,n){if(n in t)return t[n];{const i=e[n];return i instanceof Function?(...e)=>(t.syncInstances(),i.call(s,...e)):e[n]}},set:(t,s,n)=>(s in t?t[s]=n:e[s]=n,!0),deleteProperty:(t,s)=>s in t?delete t[s]:delete e[s]});return s}syncInstances(){const e=this._instanceInfo,t=this.other._instanceInfo;for(;t.length>e.length;){const s=e.length;e.push(new Proxy({visible:!1},{get:(e,n)=>n in e?e[n]:t[s][n],set:(e,n,i)=>(n in e?e[n]=i:t[s][n]=i,!0)}))}}}class As extends vs{constructor(...e){super(...e);const t=this.material,s=Ts(t,t.onBeforeCompile);t.defines.FEATURE_FADE=1,t.defines.USE_BATCHING_FRAG=1,t.needsUpdate=!0,this.fadeTexture=null,this._fadeParams=s}setFadeAt(e,t,s){this._initFadeTexture(),this.fadeTexture.setValueAt(e,255*t,255*s)}_initFadeTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const t=e*e*2,s=this.fadeTexture;if(!s||s.image.data.length!==t){const n=new Uint8Array(t),i=new _s(n,e,e,C,S);if(s){s.dispose();const e=s.image.data,t=this.fadeTexture.image.data,n=Math.min(e.length,t.length);t.set(new e.constructor(e.buffer,0,n))}this.fadeTexture=i,this._fadeParams.fadeTexture.value=i,i.needsUpdate=!0}}dispose(){this.fadeTexture&&this.fadeTexture.dispose()}}class _s extends E{setValueAt(e,...t){const{data:s,width:n,height:i}=this.image,r=Math.floor(s.length/(n*i));let o=!1;for(let a=0;a<r;a++){const n=e*r+a,i=s[n],l=t[a]||0;i!==l&&(s[n]=l,o=!0)}o&&(this.needsUpdate=!0)}}const ws=Symbol("HAS_POPPED_IN"),Ls=new b,Ms=new b,Ps=new X,Es=new X,Cs=new b;function Ss(){const e=this._fadeManager,t=this.tiles;this._fadingBefore=e.fadeCount,this._displayActiveTiles=t.displayActiveTiles,t.displayActiveTiles=!0}function Is(){const e=this._fadeManager,t=this._fadeMaterialManager,s=this._displayActiveTiles,n=this._fadingBefore,i=this._prevCameraTransforms,{tiles:r,maximumFadeOutTiles:o,batchedMesh:a}=this,{cameras:l}=r;r.displayActiveTiles=s,e.update();const c=e.fadeCount;if(0!==n&&0!==c&&(r.dispatchEvent({type:"fade-change"}),r.dispatchEvent({type:"needs-render"})),s||r.visibleTiles.forEach(e=>{const t=e.cached.scene;t&&(t.visible=e.__inFrustum),this.forEachBatchIds(e,(t,s,n)=>{s.setVisibleAt(t,e.__inFrustum),n.batchedMesh.setVisibleAt(t,e.__inFrustum)})}),o<this._fadingOutCount){let t=!0;l.forEach(e=>{if(!i.has(e))return;const s=e.matrixWorld,n=i.get(e);s.decompose(Ms,Es,Cs),n.decompose(Ls,Ps,Cs);const r=Es.angleTo(Ps),o=Ms.distanceTo(Ls);t=t&&(r>.25||o>.1)}),t&&e.completeAllFades()}if(l.forEach(e=>{i.get(e).copy(e.matrixWorld)}),e.forEachObject((s,{fadeIn:n,fadeOut:i})=>{const o=s.cached.scene,a=e.isFadingOut(s);r.markTileUsed(s),o&&(t.setFade(o,n,i),a&&(o.visible=!0)),this.forEachBatchIds(s,(e,t,s)=>{t.setFadeAt(e,n,i),t.setVisibleAt(e,!0),s.batchedMesh.setVisibleAt(e,!1)})}),a){const e=r.getPluginByName("BATCHED_TILES_PLUGIN").batchedMesh.material;a.material.map=e.map}}class Us{get fadeDuration(){return this._fadeManager.duration}set fadeDuration(e){this._fadeManager.duration=Number(e)}get fadingTiles(){return this._fadeManager.fadeCount}constructor(e){e={maximumFadeOutTiles:50,fadeRootTiles:!1,fadeDuration:250,...e},this.name="FADE_TILES_PLUGIN",this.priority=-2,this.tiles=null,this.batchedMesh=null,this._quickFadeTiles=new Set,this._fadeManager=new ys,this._fadeMaterialManager=new bs,this._prevCameraTransforms=null,this._fadingOutCount=0,this.maximumFadeOutTiles=e.maximumFadeOutTiles,this.fadeRootTiles=e.fadeRootTiles,this.fadeDuration=e.fadeDuration}init(e){this._onLoadModel=({scene:e})=>{this._fadeMaterialManager.prepareScene(e)},this._onDisposeModel=({tile:e,scene:t})=>{this.tiles.visibleTiles.has(e)&&this._quickFadeTiles.add(e.parent),this._fadeManager.deleteObject(e),this._fadeMaterialManager.deleteScene(t)},this._onAddCamera=({camera:e})=>{this._prevCameraTransforms.set(e,new k)},this._onDeleteCamera=({camera:e})=>{this._prevCameraTransforms.delete(e)},this._onTileVisibilityChange=({tile:e,visible:t})=>{const s=e.cached.scene;s&&(s.visible=!0),this.forEachBatchIds(e,(e,t,s)=>{t.setFadeAt(e,0,0),t.setVisibleAt(e,!1),s.batchedMesh.setVisibleAt(e,!1)})},this._onUpdateBefore=()=>{Ss.call(this)},this._onUpdateAfter=()=>{Is.call(this)},e.addEventListener("load-model",this._onLoadModel),e.addEventListener("dispose-model",this._onDisposeModel),e.addEventListener("add-camera",this._onAddCamera),e.addEventListener("delete-camera",this._onDeleteCamera),e.addEventListener("update-before",this._onUpdateBefore),e.addEventListener("update-after",this._onUpdateAfter),e.addEventListener("tile-visibility-change",this._onTileVisibilityChange);const t=this._fadeManager;t.onFadeSetStart=()=>{e.dispatchEvent({type:"fade-start"}),e.dispatchEvent({type:"needs-render"})},t.onFadeSetComplete=()=>{e.dispatchEvent({type:"fade-end"}),e.dispatchEvent({type:"needs-render"})},t.onFadeComplete=(t,s)=>{this._fadeMaterialManager.setFade(t.cached.scene,0,0),this.forEachBatchIds(t,(e,t,n)=>{t.setFadeAt(e,0,0),t.setVisibleAt(e,!1),n.batchedMesh.setVisibleAt(e,s)}),s||(e.invokeOnePlugin(e=>e!==this&&e.setTileVisible&&e.setTileVisible(t,!1)),this._fadingOutCount--)};const s=new Map;e.cameras.forEach(e=>{s.set(e,new k)}),e.forEachLoadedModel((e,t)=>{this._onLoadModel({scene:e})}),this.tiles=e,this._fadeManager=t,this._prevCameraTransforms=s}initBatchedMesh(){var e;const t=null==(e=this.tiles.getPluginByName("BATCHED_TILES_PLUGIN"))?void 0:e.batchedMesh;if(t){if(null===this.batchedMesh){this._onBatchedMeshDispose=()=>{this.batchedMesh.dispose(),this.batchedMesh.removeFromParent(),this.batchedMesh=null,t.removeEventListener("dispose",this._onBatchedMeshDispose)};const e=t.material.clone();e.onBeforeCompile=t.material.onBeforeCompile,this.batchedMesh=new As(t,e),this.tiles.group.add(this.batchedMesh)}}else null!==this.batchedMesh&&(this._onBatchedMeshDispose(),this._onBatchedMeshDispose=null)}setTileVisible(e,t){const s=this._fadeManager,n=s.isFading(e);if(s.isFadingOut(e)&&this._fadingOutCount--,t?1===e.__depthFromRenderedParent?((e[ws]||this.fadeRootTiles)&&this._fadeManager.fadeIn(e),e[ws]=!0):this._fadeManager.fadeIn(e):(this._fadingOutCount++,s.fadeOut(e)),this._quickFadeTiles.has(e)&&(this._fadeManager.completeFade(e),this._quickFadeTiles.delete(e)),n)return!0;const i=this._fadeManager.isFading(e);return!(t||!i)}dispose(){const e=this.tiles;this._fadeManager.completeAllFades(),null!==this.batchedMesh&&this._onBatchedMeshDispose(),e.removeEventListener("load-model",this._onLoadModel),e.removeEventListener("dispose-model",this._onDisposeModel),e.removeEventListener("add-camera",this._onAddCamera),e.removeEventListener("delete-camera",this._onDeleteCamera),e.removeEventListener("update-before",this._onUpdateBefore),e.removeEventListener("update-after",this._onUpdateAfter),e.removeEventListener("tile-visibility-change",this._onTileVisibilityChange),e.forEachLoadedModel((e,t)=>{this._fadeManager.deleteObject(t),e&&(e.visible=!0)})}forEachBatchIds(e,t){if(this.initBatchedMesh(),this.batchedMesh){const s=this.tiles.getPluginByName("BATCHED_TILES_PLUGIN"),n=s.getTileBatchIds(e);n&&n.forEach(e=>{t(e,this.batchedMesh,s)})}}}new k,new b,new b,new g,new o(new y);new E(new Uint8Array([255,255,255,255]),1,1).needsUpdate=!0,new b;export{mt as Br,bt as Dr,fs as Fr,Us as Nr,ps as Or,yt as Ur};
