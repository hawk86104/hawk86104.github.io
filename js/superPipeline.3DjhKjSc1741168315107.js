import{e as n}from"./@tresjs.Ea5Oq_-I1741168315107.js";import{a0 as t,aX as e}from"./three.FxqAALWt1741168315107.js";import{_ as r}from"./argestCircle.iQbYZf4A1741168315107.js";import{d as o,e as a,o as c,f as i,g as s,N as f,aj as l,ak as p,m as d}from"./@vue.NRI7TcgI1741168315107.js";import"./postprocessing.hfy6Kqg11741168315107.js";import"./@vueuse.Z8xAfE_A1741168315107.js";const v=m;function m(n,t){const e=b();return(m=function(n,t){return e[n-=232]})(n,t)}!function(n,t){const e=m,r=b();for(;;)try{if(266095===-parseInt(e(256))/1*(-parseInt(e(267))/2)+parseInt(e(272))/3*(parseInt(e(275))/4)+parseInt(e(258))/5*(-parseInt(e(234))/6)+parseInt(e(274))/7+parseInt(e(255))/8*(parseInt(e(242))/9)+-parseInt(e(268))/10*(parseInt(e(232))/11)+-parseInt(e(277))/12*(parseInt(e(278))/13))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const u=function(){let n=!0;return function(t,e){const r=n?function(){if(e){const n=e[m(280)](t,arguments);return e=null,n}}:function(){};return n=!1,r}}();!function(){u(this,(function(){const n=m,t=new RegExp(n(244)),e=new RegExp(n(241),"i"),r=j(n(276));t[n(271)](r+n(237))&&e.test(r+n(260))?j():r("0")}))()}();const x=function(){let n=!0;return function(t,e){const r=n?function(){if(e){const n=e[m(280)](t,arguments);return e=null,n}}:function(){};return n=!1,r}}();x(void 0,(function(){const n=m,t=function(){const n=m;let t;try{t=Function(n(264)+'{}.constructor("return this")( ));')()}catch(e){t=window}return t}(),e=t[n(259)]=t[n(259)]||{},r=[n(257),n(273),n(239),"error",n(236),n(250),n(248)];for(let o=0;o<r.length;o++){const t=x[n(251)][n(235)].bind(x),a=r[o],c=e[a]||t;t.__proto__=x[n(262)](x),t[n(245)]=c[n(245)][n(262)](c),e[a]=t}}))();const h={ref:v(266),position:[0,0,1800],fov:45,near:1,far:1e4},y=[v(240)];function b(){const n=["input","call","bind","TresAmbientLight","return (function() ","stateObject","perspectiveCameraRef","58116VNxckU","50XPQIjX","gger","superPipeline","test","3rZmgLn","warn","40712dUhCNe","1854808VUOURq","init","228uxVUUm","207259YmhKXF","uTime","apply","action","466675pnkDrA","debu","2004TwUqbS","prototype","exception","chain","TresDirectionalLight","info","rotation-x","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","117rhyvJc","TresShaderMaterial","function *\\( *\\)","toString","#ffffff","while (true) {}","trace","uniforms","table","constructor","string","counter","quanMeshRef","116744eJCimx","7VtUwHm","log","1220cGjPWp","console"];return(b=function(){return n})()}const g=o({__name:v(270),setup(o){const v={clearColor:"#000000",shadows:!0,alpha:!1,useLegacyLights:!0},u={uniforms:{uTime:{type:"f",value:0}},vertexShader:r,fragmentShader:"// 光线追踪实例，想学习每行代码的逻辑，请联系ICE社区-Jsonco\nvarying vec2 vUv;\nuniform float uTime;\n#define FAR 50.\nfloat svObjID,svObjID2;\nvec3 vObjID;\n#define TUN 0.\n#define ROD 1.\n#define BLT 2.\nmat2 rot(float th){vec2 a=sin(vec2(1.5707963,0)+th);return mat2(a,-a.y,a.x);}\nvec3 camPath(float t){\n  float a=sin(t*3.14159265/16.+1.5707963);\n  float b=cos(t*3.14159265/16.);\n  return vec3(a,b*a*.5,t);\n}\n\nvec3 camPathPL(float t){\n  float it=floor(t+1.);\n  float ft=t-it;\n  float a=sin(it*3.14159265/16.+1.5707963);\n  float b=cos(it*3.14159265/16.);\n  vec2 p0=vec2(a,b*a*.5);\n  a=sin((it+1.)*3.14159265/16.+1.5707963);\n  b=cos((it+1.)*3.14159265/16.);\n  vec2 p1=vec2(a,b*a*.5);\n  vec2 p=mix(p0,p1,ft);\n  return vec3(p,t);\n}\nvec2 objMin(vec2 a,vec2 b){\n  return a.x<b.x?a:b;\n}\n\nfloat map(vec3 p){\n  const float depth=.25;\n  p.xy-=camPath(p.z).xy;\n  float tun=(1.+depth)-length(p.xy);\n  vec3 q=p;\n  vec3 q2=p;\n  float a=atan(q.y,q.x)/6.2831853;\n  float ia=(floor(a*5.)+.5)/5.*6.2831853;\n  float ia2=(floor(a*15.)+.5)/15.*6.2831853;\n  q.xy*=rot(ia+sign(mod(q.z+1.,4.)-2.)*3.14159/15.);//\n  q2.xy*=rot(ia2);\n  q.x=mod(q.x,2.)-1.;\n  q.z=mod(q.z,2.)-1.;\n  q2.x=mod(q2.x,(2.+.25))-(2.+.25)/2.;\n  q=abs(q);\n  q2=abs(q2);\n  float tunDetail=max(min(q.y,q.z)-.07,-(min(q.y,q.z)-.007));\n  tun=min(tun,max(tunDetail,tun-depth));\n  float blt=max(max(q2.x*.866025+q2.y*.5,q2.y)-.055,q.z-.16);\n  float thread=max(sin(q.z*6.283*64.)*2.,0.)*.002;\n  float rod=max(length(q2.xy)-.025+thread,q.z-.19);\n  rod=min(rod,max(length(q2.xy)-.075,q.z-.09));\n  vObjID=vec3(tun,blt,rod);\n  return min(min(tun,blt),rod);\n}\nfloat refTrace(vec3 ro,vec3 rd){\n  float t=0.;\n  for(int i=0;i<12;i++){\n    float d=map(ro+rd*t);\n    if(abs(d)<.005*(t*.25+1.)||t>FAR)break;\n    t+=d;\n  }\n  return t;\n}\n\nfloat trace(vec3 ro,vec3 rd){\n  float t=0.,d;\n  for(int i=0;i<96;i++){\n    d=map(ro+rd*t);\n    if(abs(d)<.001*(t*.125+1.)||t>FAR)break;\n    t+=d;\n  }\n  return min(t,FAR);\n}\nvec3 nrHyb(vec3 p,inout float crv,float ef){\n  vec2 e=vec2(-1.,1.)*.66*ef/450.;\n  float d1=map(p+e.yxx),d2=map(p+e.xxy);\n  float d3=map(p+e.xyx),d4=map(p+e.yyy);\n  float d=map(p);\n  float d5,d6;\n  crv=clamp((d1+d2+d3+d4-d*4.)*24.+.5,0.,1.);\n  e=vec2(.005,0);\n  d1=map(p+e.xyy),d2=map(p-e.xyy);\n  d3=map(p+e.yxy),d4=map(p-e.yxy);\n  d5=map(p+e.yyx),d6=map(p-e.yyx);\n  return normalize(vec3(d1-d2,d3-d4,d5-d6));\n}\nvec3 nrRef(in vec3 p,inout float crv,in float ef){\n  vec2 e=vec2(-1.,1.)*.66*ef/450.;\n  float d1=map(p+e.yxx),d2=map(p+e.xxy);\n  float d3=map(p+e.xyx),d4=map(p+e.yyy);\n  float d=map(p);\n  crv=clamp((d1+d2+d3+d4-d*4.)*24.+.5,0.,1.);\n  e=vec2(-1.,1.)*.002;\n  d1=map(p+e.yxx),d2=map(p+e.xxy);\n  d3=map(p+e.xyx),d4=map(p+e.yyy);\n  return normalize(e.yxx*d1+e.xxy*d2+e.xyx*d3+e.yyy*d4);\n}\nfloat cao(in vec3 p,in vec3 n){\n  float sca=1.,occ=0.;\n  for(float i=0.;i<5.;i++){\n    float hr=.01+i*.5/4.;\n    float dd=map(n*hr+p);\n    occ+=(hr-dd)*sca;\n    sca*=.7;\n  }\n  return clamp(1.-occ,0.,1.);\n}\nfloat softShadow(vec3 ro,vec3 lp,float k){\n  const int maxIterationsShad=20;\n  vec3 rd=(lp-ro);\n  float shade=1.;\n  float dist=.05;\n  float end=max(length(rd),.001);\n  rd/=end;\n  for(int i=0;i<maxIterationsShad;i++){\n    float h=map(ro+rd*dist);\n    shade=min(shade,k*h/dist);\n    dist+=clamp(h,.01,.25);\n    if(h<.001||dist>end)break;\n  }\n  return min(max(shade,0.)+.2,1.);\n}\nvec3 palette(float t){\n  vec3 a=vec3(.5,.5,.5);\n  vec3 b=vec3(.5,.5,.5);\n  vec3 c=vec3(1.,1.,1.);\n  vec3 d=vec3(sin(uTime*.2)*.5+.5,cos(uTime*.25)*.5+.5,sin(uTime*.3+1.)*.5+.5);\n  return a+b*cos(6.28318*(c*t+d));\n}\nvoid main(){\n  vec2 u=(vUv-vec2(.5))*2.;\n  #ifdef THREE_D\n  float sg=sign(fragCoord.x-.5*iResolution.x);\n  u.x-=sg*.25*iResolution.x/iResolution.y;\n  #endif\n  float speed=2.;\n  vec3 ro=camPath(uTime*speed+.0);\n  vec3 lk=camPath(uTime*speed+.5);\n  vec3 lp=camPath(uTime*speed+2.);\n  lp.y+=.5;\n  #ifdef THREE_D\n  ro.x-=sg*.15;lk.x-=sg*.15;lp.x-=sg*.15;\n  #endif\n  float FOV=.75;\n  vec3 fwd=normalize(lk-ro);\n  vec3 rgt=normalize(vec3(fwd.z,0.,-fwd.x));\n  vec3 up=cross(fwd,rgt);\n  vec3 rd=fwd+FOV*(u.x*rgt+u.y*up);\n  rd=normalize(vec3(rd.xy,(rd.z-length(rd.xy)*.25)*.75));\n  float swivel=camPath(lk.z).x;\n  rd.xy=rot(swivel/48.)*rd.xy;\n  rd.xz=rot(swivel/32.)*rd.xz;\n  float t=trace(ro,rd);\n  vec2 vObj=objMin(vec2(vObjID.x,TUN),vec2(vObjID.y,BLT));\n  vObj=objMin(vObj,vec2(vObjID.z,ROD));\n  svObjID=vObj.y;\n  vec3 sp=ro+rd*t;\n  float crv=1.,ef=8.;\n  vec3 sn=nrHyb(sp,crv,ef);\n  float sh=softShadow(sp,lp,16.);\n  float ao=cao(sp,sn);\n  vec3 ld=lp-sp;\n  float lDist=max(length(ld),.0001);\n  ld/=lDist;\n  float atten=1./(1.+lDist*.25+lDist*lDist*.025);\n  const float tSize0=1./1.;\n  vec3 tx=palette(rd.z+uTime*.4);\n  tx=tx*.5+smoothstep(.02,.8,tx)*1.;\n  float gr=dot(tx,vec3(.299,.587,.114));\n  if(svObjID==TUN)tx*=vec3(1);\n  else if(svObjID==ROD)tx=(gr*.5+.5)*vec3(1);\n  else if(svObjID==BLT)tx=(tx*.5+.5)*vec3(1.4,.7,.05);\n  float dif=max(dot(ld,sn),0.);\n  float spe=pow(max(dot(reflect(rd,sn),ld),0.),64.);\n  float Schlick=pow(1.-max(dot(rd,normalize(rd+ld)),0.),5.);\n  Schlick=mix(.5,1.,Schlick);\n  if(svObjID!=TUN)\n  dif=(pow(dif,4.)*.5+pow(dif,8.)*.5)*3.;\n  vec3 ref=reflect(rd,sn);\n  float rt=refTrace(sp+ref*.1,ref);\n  vObj=objMin(vec2(vObjID.x,TUN),vec2(vObjID.y,BLT));\n  vObj=objMin(vObj,vec2(vObjID.z,ROD));\n  svObjID2=vObj.y;\n  float crv2=1.;\n  vec3 rsp=sp+ref*rt;\n  vec3 rsn=nrRef(rsp,crv2,ef);\n  vec3 rCol=palette(u.x+uTime*.4);\n  rCol=smoothstep(.02,.8,rCol)*2.;\n  gr=dot(rCol,vec3(.299,.587,.114));\n  if(svObjID2==TUN)rCol*=vec3(1);\n  else if(svObjID2==ROD)rCol=(gr*.5+.5)*vec3(1);\n  else if(svObjID2==BLT)rCol=(rCol*.5+.5)*vec3(1.4,.7,.05);\n  float rDiff=max(dot(rsn,normalize(lp-rsp)),0.);\n  float rSpec=pow(max(dot(reflect(ref,rsn),normalize(lp-rsp)),0.),8.);\n  float rlDist=length(lp-rsp);\n  if(svObjID2!=TUN)rDiff=(pow(rDiff,4.)*.5+pow(rDiff,8.)*.5)*3.;\n  rCol=rCol*(rDiff+.25)+vec3(1.,.6,.2)*rSpec*2.;\n  rCol*=1./(1.+rlDist*.25+rlDist*rlDist*.025);\n  rCol*=min(crv2*1.5,1.);\n  vec3 fc=tx*(dif+ao*.3)+vec3(1,.6,.2)*spe*Schlick*2.;\n  if(svObjID!=TUN)fc+=rCol*.5;\n  else fc+=rCol*.25;\n  fc*=atten*sh*ao;\n  fc*=clamp(crv*1.5,0.,1.);\n  vec3 bg=vec3(1,.7,.4);\n  fc=mix(fc,bg*2.,smoothstep(0.,.95,t/FAR));\n  gl_FragColor=vec4(pow(clamp(fc,0.,1.),vec3(1./2.)),1.);// 1./2.2, etc.\n}\n",side:t,blending:e,depthWrite:!1,transparent:!0},{onLoop:x}=n();return x((({delta:n})=>{const t=m;u[t(249)][t(279)].value+=n})),(n,t)=>{const e=m,r=a("TresCanvas");return c(),i(r,d(v,{"window-size":""}),{default:s((()=>[f("TresPerspectiveCamera",h,null,512),t[1]||(t[1]=f(e(263),{color:e(246)},null,-1)),t[2]||(t[2]=f(e(238),{position:[100,100,0],intensity:.5,color:e(246)},null,-1)),f("TresMesh",{ref:e(254),"rotation-x":Math.PI},[t[0]||(t[0]=f("TresPlaneGeometry",{args:[4e3,4e3]},null,-1)),f(e(243),l(p(u)),null,16)],8,y)])),_:1},16)}}});function j(n){function t(n){const e=m;if(typeof n===e(252))return function(n){}[e(251)](e(247))[e(280)](e(253));1!==(""+n/n).length||n%20==0?function(){return!0}[e(251)](e(233)+e(269))[e(261)](e(281)):function(){return!1}[e(251)](e(233)+e(269))[e(280)](e(265)),t(++n)}try{if(n)return t;t(0)}catch(e){}}export{g as default};
