import{F as e,V as t,_ as r}from"./@tresjs.DeDzA3xI1764662849723.js";import{f as a}from"./utils.CNife3_q1764662849723.js";import{q as n,d as i,c0 as o,bL as l,a_ as s,J as u,b3 as h,r as p,a1 as d,bU as v,i as c,j as f,o as m,u as x,E as g,bI as M,k as _,M as S,g as D,V as w,P as U,b6 as y,dl as b,W as E,H as B}from"./three.F31Lz30M1764662849723.js";import{d as P,c as T,t as R,w as F,A as z,a1 as C,G as A,o as W,m as j,u as k}from"./@vue.D9fSGD371764662849723.js";const I=(()=>Number.parseInt(s.replace(/\D+/g,"")))();class L extends n{constructor(e=new i){super({uniforms:{inputBuffer:new l(null),depthBuffer:new l(null),resolution:new l(new i),texelSize:new l(new i),halfTexelSize:new l(new i),kernel:new l(0),scale:new l(1),cameraNear:new l(0),cameraFar:new l(1),depthEdge0:new l(0),depthEdge1:new l(1),depthScale:new l(0),depthBias:new l(.25)},fragmentShader:`#include <common>\n        #include <dithering_pars_fragment>      \n        uniform sampler2D inputBuffer;\n        uniform sampler2D depthBuffer;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float depthEdge0;\n        uniform float depthEdge1;\n        uniform float depthScale;\n        uniform float depthBias;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          float depthFactor = 0.0;\n          \n          #ifdef USE_DEPTH\n            vec4 depth = texture2D(depthBuffer, vUv);\n            depthFactor = smoothstep(\n              1.0 - depthEdge1, 1.0 - depthEdge0,\n              1.0 - (depth.r * depth.a) + depthBias\n            );\n            depthFactor = clamp(depthScale * depthFactor + 0.25, 0.0, 1.0);\n          #endif\n\n          gl_FragColor = 0.25 * (\n            texture2D(inputBuffer, mix(vUv0, vUv, depthFactor))\n            + texture2D(inputBuffer, mix(vUv1, vUv, depthFactor))\n            + texture2D(inputBuffer, mix(vUv2, vUv, depthFactor))\n            + texture2D(inputBuffer, mix(vUv3, vUv, depthFactor))\n          );\n          \n          #include <dithering_fragment>\n          #include <tonemapping_fragment>\n          #include <${I>=154?"colorspace_fragment":"encodings_fragment"}>\n        }`,vertexShader:"uniform vec2 texelSize;\n        uniform vec2 halfTexelSize;\n        uniform float kernel;\n        uniform float scale;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          vec2 uv = position.xy * 0.5 + 0.5;\n          vUv = uv;\n\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0);\n        }",blending:o,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}class O{constructor({resolution:e,width:t=500,height:r=500,depthEdge0:a=0,depthEdge1:n=1,depthScale:o=0,depthBias:l=.25}){this.renderToScreen=!1,this.renderTargetA=new u(e,e,{minFilter:p,magFilter:p,stencilBuffer:!1,depthBuffer:!1,type:h}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new L,this.convolutionMaterial.setTexelSize(1/t,1/r),this.convolutionMaterial.setResolution(new i(t,r)),this.scene=new d,this.camera=new v,this.convolutionMaterial.uniforms.depthEdge0.value=a,this.convolutionMaterial.uniforms.depthEdge1.value=n,this.convolutionMaterial.uniforms.depthScale.value=o,this.convolutionMaterial.uniforms.depthBias.value=l,this.convolutionMaterial.defines.USE_DEPTH=o>0;const s=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),x=new Float32Array([0,0,2,0,0,2]),g=new c;g.setAttribute("position",new f(s,3)),g.setAttribute("uv",new f(x,2)),this.screen=new m(g,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,r){const a=this.scene,n=this.camera,i=this.renderTargetA,o=this.renderTargetB,l=this.convolutionMaterial,s=l.uniforms;s.depthBuffer.value=t.depthTexture;const u=l.kernel;let h,p,d,v=t;for(p=0,d=u.length-1;p<d;++p)h=1&p?o:i,s.kernel.value=u[p],s.inputBuffer.value=v.texture,e.setRenderTarget(h),e.render(a,n),v=h;s.kernel.value=u[p],s.inputBuffer.value=v.texture,e.setRenderTarget(this.renderToScreen?null:r),e.render(a,n)}dispose(){this.screen.material.dispose(),this.screen.geometry.dispose(),this.renderTargetA.dispose(),this.renderTargetB.dispose(),this.convolutionMaterial.dispose()}}class q extends x{constructor(e={}){super(e),this._tDepth={value:null},this._distortionMap={value:null},this._tSharp={value:null},this._tBlur={value:null},this._textureMatrix={value:null},this._mix={value:.5},this._sharpMix={value:0},this._blurMixSmooth={value:0},this._blurMixRough={value:0},this._sharpDepthEdgeMin={value:.9},this._sharpDepthEdgeMax={value:1},this._sharpDepthScale={value:0},this._sharpDepthBias={value:0},this._distortion={value:1},this.setValues(e)}onBeforeCompile(e){e.defines?.USE_UV||(e.defines.USE_UV="");for(const t of Object.keys(e.defines))e.defines[t.toUpperCase()]=e.defines[t];e.uniforms.tSharp=this._tSharp,e.uniforms.tDepth=this._tDepth,e.uniforms.tBlur=this._tBlur,e.uniforms.distortionMap=this._distortionMap,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mixMain=this._mix,e.uniforms.sharpMix=this._sharpMix,e.uniforms.sharpDepthScale=this._sharpDepthScale,e.uniforms.sharpDepthEdgeMin=this._sharpDepthEdgeMin,e.uniforms.sharpDepthEdgeMax=this._sharpDepthEdgeMax,e.uniforms.sharpDepthBias=this._sharpDepthBias,e.uniforms.blurMixSmooth=this._blurMixSmooth,e.uniforms.blurMixRough=this._blurMixRough,e.uniforms.distortion=this._distortion,e.vertexShader=`\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;\n      ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace("#include <project_vertex>","#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );"),e.fragmentShader=`\n        uniform sampler2D tSharp;\n        uniform sampler2D tBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float mixMain;\n        uniform float sharpMix;\n        uniform float blurMixSmooth;\n        uniform float blurMixRough;\n        uniform float sharpDepthScale;\n        uniform float sharpDepthBias;\n        uniform float sharpDepthEdgeMin;\n        uniform float sharpDepthEdgeMax;\n        varying vec4 my_vUv;\n        ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>","#include <emissivemap_fragment>\n\n      vec4 new_vUv = my_vUv;\n\n      #ifdef USE_DISTORTION\n        float distortionFactor = (texture(distortionMap, vUv).r - 0.5) * distortion;\n        new_vUv.x += distortionFactor;\n        new_vUv.y += distortionFactor;\n      #endif\n\n      #ifdef USE_NORMALMAP\n\n        vec4 normalColor = texture(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        vec2 normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n\n        vec4 sharp = texture(tSharp, normal_uv);\n\n        #ifdef USE_BLUR\n          vec4 blur = texture(tBlur, normal_uv);\n        #endif\n\n        #ifdef USE_DEPTH\n          vec4 depth = texture(tDepth, normal_uv);\n        #endif\n\n      #else\n\n        vec4 sharp = textureProj(tSharp, new_vUv);\n\n        #ifdef USE_BLUR\n          vec4 blur = textureProj(tBlur, new_vUv);\n        #endif\n\n        #ifdef USE_DEPTH\n          vec4 depth = textureProj(tDepth, new_vUv);\n        #endif\n\n      #endif\n\n      #ifdef USE_DEPTH\n        float depthFactor = smoothstep(\n          1.0 - sharpDepthEdgeMax, 1.0 - sharpDepthEdgeMin,\n          1.0 - (depth.r * depth.a) + sharpDepthBias\n        );\n        depthFactor = clamp(sharpDepthScale * depthFactor, 0.0, 1.0);\n\n        sharp *= depthFactor;\n      #endif\n\n      sharp *= (1.0 - roughnessFactor);\n      "),e.fragmentShader=e.fragmentShader.replace("#include <opaque_fragment>","\n\n      #ifdef USE_BLUR\n        outgoingLight += mixMain * (\n          vec3(sharp) * sharpMix\n          + vec3(blur) * (blurMixSmooth * (1.0 - roughnessFactor) + blurMixRough * roughnessFactor)\n        );\n      #else\n        outgoingLight += mixMain * vec3(sharp) * sharpMix;\n      #endif\n\n      #include <opaque_fragment>\n      ")}get tSharp(){return this._tSharp.value}set tSharp(e){this._tSharp.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tBlur(){return this._tBlur.value}set tBlur(e){this._tBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get sharpMix(){return this._sharpMix.value}set sharpMix(e){this._sharpMix.value=e}get blurMixSmooth(){return this._blurMixSmooth.value}set blurMixSmooth(e){this._blurMixSmooth.value=e}get blurMixRough(){return this._blurMixRough.value}set blurMixRough(e){this._blurMixRough.value=e}get mix(){return this._mix.value}set mix(e){this._mix.value=e}get sharpDepthScale(){return this._sharpDepthScale.value}set sharpDepthScale(e){this._sharpDepthScale.value=e}get sharpDepthBias(){return this._sharpDepthBias.value}set sharpDepthBias(e){this._sharpDepthBias.value=e}get sharpDepthEdgeMin(){return this._sharpDepthEdgeMin.value}set sharpDepthEdgeMin(e){this._sharpDepthEdgeMin.value=e}get sharpDepthEdgeMax(){return this._sharpDepthEdgeMax.value}set sharpDepthEdgeMax(e){this._sharpDepthEdgeMax.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}}const N=["texture-matrix","t-sharp","t-depth","t-blur","defines-USE_BLUR","defines-USE_DEPTH","defines-USE_DISTORTION"],V=P({__name:"index",props:{resolution:{default:256},mix:{default:1},sharpMix:{default:1},sharpDepthScale:{default:1},sharpDepthBias:{default:0},sharpDepthEdgeMin:{default:0},sharpDepthEdgeMax:{default:.2},blurMixSmooth:{default:1},blurMixRough:{default:1},blurDepthScale:{default:1},blurDepthBias:{default:0},blurDepthEdgeMin:{default:0},blurDepthEdgeMax:{default:.2},blurSize:{default:()=>[0,0]},distortionMap:{},distortion:{default:0},reflectorOffset:{default:0},color:{default:()=>new _(3355443)},roughness:{default:1},metalness:{default:0},map:{},lightMap:{},lightMapIntensity:{default:1},aoMap:{},aoMapIntensity:{default:1},emissive:{default:()=>new _(0)},emissiveIntensity:{default:1},emissiveMap:{},bumpMap:{},bumpScale:{default:1},normalMap:{},normalMapType:{default:M},normalScale:{default:()=>new i(1,1)},displacementMap:{},displacementScale:{default:1},displacementBias:{default:0},roughnessMap:{default:null},metalnessMap:{},alphaMap:{},envMap:{},envMapRotation:{default:()=>new g},envMapIntensity:{default:1},wireframe:{type:Boolean,default:!1},wireframeLinewidth:{default:1},wireframeLinecap:{default:"round"},wireframeLinejoin:{default:"round"},flatShading:{type:Boolean,default:!1},fog:{type:Boolean,default:!0}},setup(n,{expose:i}){const o=n,{extend:l,invalidate:s}=e();l({MeshReflectionMaterial:q});const d=T(()=>500-(Array.isArray(o.blurSize)?o.blurSize[0]:o.blurSize)),v=T(()=>500-(Array.isArray(o.blurSize)?o.blurSize[1]:o.blurSize)),c=T(()=>d.value>0||v.value>0),f=T(()=>o.sharpDepthScale>0||o.blurDepthScale>0),m=T(()=>!!o.distortionMap),x=T(()=>!!o.roughnessMap),g=R();let M;const _={reflectorPlane:new U,normal:new w,reflectorWorldPosition:new w,cameraWorldPosition:new w,rotationMatrix:new S,lookAtPosition:new w(0,0,-1),clipPlane:new B,view:new w,target:new w,q:new B,virtualCamera:new D,textureMatrix:new S},P=new u(o.resolution,o.resolution,{minFilter:p,magFilter:p,type:h,depthBuffer:!0,depthTexture:new y(o.resolution,o.resolution)}),I=new u(o.resolution,o.resolution,{minFilter:p,magFilter:p,type:h});F(()=>[o.resolution],()=>{P.setSize(o.resolution,o.resolution),I.setSize(o.resolution,o.resolution)}),F(()=>[o.resolution,d.value,v.value,o.blurDepthEdgeMin,o.blurDepthEdgeMax,o.blurDepthScale,o.blurDepthBias],()=>{M?.dispose(),M=new O({resolution:o.resolution,width:d.value,height:v.value,depthEdge0:o.blurDepthEdgeMin,depthEdge1:o.blurDepthEdgeMax,depthScale:o.blurDepthScale,depthBias:o.blurDepthBias})},{immediate:!0}),F(()=>[c.value],()=>{t("MeshReflectionMaterial: Setting blurMixRough or blurMixSmooth to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),F(f,()=>{t("MeshReflectionMaterial: Setting depthScale to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),F(m,()=>{t("MeshReflectionMaterial: Toggling distortionMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),F(x,()=>{t("MeshReflectionMaterial: Toggling roughnessMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),F(()=>[o.normalMap],()=>{t("MeshReflectionMaterial: Toggling normalMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),z(()=>{P.dispose(),I.dispose(),M.dispose()});const{onBeforeRender:L}=r();return L(({renderer:e,scene:t,camera:r})=>{const n=g.value?.__tres?.parent;if(n)if(e instanceof b)console.warn("MeshReflectionMaterial: WebGPURenderer is not supported yet");else if(e instanceof E){s();const i=e.xr.enabled,l=e.shadowMap.autoUpdate;if(_.reflectorWorldPosition.setFromMatrixPosition(n.matrixWorld),_.cameraWorldPosition.setFromMatrixPosition(r.value?.matrixWorld),_.rotationMatrix.extractRotation(n.matrixWorld),_.normal.set(0,0,1),_.normal.applyMatrix4(_.rotationMatrix),_.reflectorWorldPosition.addScaledVector(_.normal,o.reflectorOffset),_.view.subVectors(_.reflectorWorldPosition,_.cameraWorldPosition),_.view.dot(_.normal)>0)return;n.visible=!1,_.view.reflect(_.normal).negate(),_.view.add(_.reflectorWorldPosition),_.rotationMatrix.extractRotation(r.value?.matrixWorld),_.lookAtPosition.set(0,0,-1),_.lookAtPosition.applyMatrix4(_.rotationMatrix),_.lookAtPosition.add(_.cameraWorldPosition),_.target.subVectors(_.reflectorWorldPosition,_.lookAtPosition),_.target.reflect(_.normal).negate(),_.target.add(_.reflectorWorldPosition),_.virtualCamera.position.copy(_.view),_.virtualCamera.up.set(0,1,0),_.virtualCamera.up.applyMatrix4(_.rotationMatrix),_.virtualCamera.up.reflect(_.normal),_.virtualCamera.lookAt(_.target),_.virtualCamera.far=r.value.far,_.virtualCamera.updateMatrixWorld(),_.virtualCamera.far=r.value.far,_.virtualCamera.projectionMatrix.copy(r.value.projectionMatrix),_.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),_.textureMatrix.multiply(_.virtualCamera.projectionMatrix),_.textureMatrix.multiply(_.virtualCamera.matrixWorldInverse),_.textureMatrix.multiply(n.matrixWorld),_.reflectorPlane.setFromNormalAndCoplanarPoint(_.normal,_.reflectorWorldPosition),_.reflectorPlane.applyMatrix4(_.virtualCamera.matrixWorldInverse),_.clipPlane.set(_.reflectorPlane.normal.x,_.reflectorPlane.normal.y,_.reflectorPlane.normal.z,_.reflectorPlane.constant);const u=_.virtualCamera.projectionMatrix;_.q.x=(Math.sign(_.clipPlane.x)+u.elements[8])/u.elements[0],_.q.y=(Math.sign(_.clipPlane.y)+u.elements[9])/u.elements[5],_.q.z=-1,_.q.w=(1+u.elements[10])/u.elements[14],_.clipPlane.multiplyScalar(2/_.clipPlane.dot(_.q)),u.elements[2]=_.clipPlane.x,u.elements[6]=_.clipPlane.y,u.elements[10]=_.clipPlane.z+1,u.elements[14]=_.clipPlane.w,e.shadowMap.autoUpdate=!1,e.setRenderTarget(P),e.autoClear||e.clear(),a(C(t)),e.render(C(t),_.virtualCamera),e instanceof E&&M.render(e,P,I),a(C(t),!1),e.xr.enabled=i,e.shadowMap.autoUpdate=l,n.visible=!0,e.setRenderTarget(null),s()}}),i({instance:g}),(e,t)=>(W(),A("TresMeshReflectionMaterial",j({key:`key${c.value?"0":"1"}${f.value?"0":"1"}${m.value?"0":"1"}${x.value?"0":"1"}`,ref_key:"materialRef",ref:g},o,{"texture-matrix":_.textureMatrix,"t-sharp":k(P)?.texture,"t-depth":k(P)?.depthTexture,"t-blur":k(I)?.texture,"defines-USE_BLUR":c.value?"":void 0,"defines-USE_DEPTH":f.value?"":void 0,"defines-USE_DISTORTION":m.value?"":void 0}),null,16,N))}});export{V as _};
