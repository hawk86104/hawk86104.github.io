import{az as b,aB as w,aM as C,bm as P,at as T,b9 as L,a1 as _,l as z,ak as D,b3 as A,b5 as W,bg as U,w as g,a6 as k,o as F,c as R,Y as y,aa as E,ab as I,aT as f}from"./vendor.5cVREgKq1715677997908.js";import{s as B}from"./shaderMaterial.E5wLlhv_1715677997908.js";import{M as j}from"./MeshDiscardMaterial.gAk3Okd81715677997908.js";function G(l){return l.isLight}function O(l){return!!l.geometry}const V=B({color:new b(0),blend:2,alphaTest:.75,opacity:0,map:null},"varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vUv = uv;\n   }","varying vec2 vUv;\n   uniform sampler2D map;\n   uniform vec3 color;\n   uniform float opacity;\n   uniform float alphaTest;\n   uniform float blend;\n   void main() {\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\n     #include <tonemapping_fragment>\n     #include <".concat(parseInt(L.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment",">\n   }"));class N{constructor(e,s,h=1024){this.renderer=e,this.res=h,this.scene=s,this.buffer1Active=!1,this.lights=[],this.meshes=[],this.object=null,this.clearColor=new b,this.clearAlpha=0;const o=/(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent)?P:T;this.progressiveLightMap1=new w(this.res,this.res,{type:o}),this.progressiveLightMap2=new w(this.res,this.res,{type:o}),this.discardMat=new j,this.targetMat=new C({fog:!1}),this.previousShadowMap={value:this.progressiveLightMap1.texture},this.averagingWindow={value:100},this.targetMat.onBeforeCompile=r=>{r.vertexShader="varying vec2 vUv;\n"+r.vertexShader.slice(0,-1)+"vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";const c=r.fragmentShader.indexOf("void main() {");r.fragmentShader="varying vec2 vUv;\n"+r.fragmentShader.slice(0,c)+"uniform sampler2D previousShadowMap;\n	uniform float averagingWindow;\n"+r.fragmentShader.slice(c-1,-1)+"\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\n      }",r.uniforms.previousShadowMap=this.previousShadowMap,r.uniforms.averagingWindow=this.averagingWindow}}clear(){this.renderer.getClearColor(this.clearColor),this.clearAlpha=this.renderer.getClearAlpha(),this.renderer.setClearColor("black",1),this.renderer.setRenderTarget(this.progressiveLightMap1),this.renderer.clear(),this.renderer.setRenderTarget(this.progressiveLightMap2),this.renderer.clear(),this.renderer.setRenderTarget(null),this.renderer.setClearColor(this.clearColor,this.clearAlpha),this.lights=[],this.meshes=[],this.scene.traverse(e=>{O(e)?this.meshes.push({object:e,material:e.material}):G(e)&&this.lights.push({object:e,intensity:e.intensity})})}prepare(){this.lights.forEach(e=>e.object.intensity=0),this.meshes.forEach(e=>e.object.material=this.discardMat)}finish(){this.lights.forEach(e=>e.object.intensity=e.intensity),this.meshes.forEach(e=>e.object.material=e.material)}configure(e){this.object=e}update(e,s=100){if(!this.object)return;this.averagingWindow.value=s,this.object.material=this.targetMat;const h=this.buffer1Active?this.progressiveLightMap1:this.progressiveLightMap2,o=this.buffer1Active?this.progressiveLightMap2:this.progressiveLightMap1,r=this.scene.background;this.scene.background=null,this.renderer.setRenderTarget(h),this.previousShadowMap.value=o.texture,this.buffer1Active=!this.buffer1Active,this.renderer.render(this.scene,e),this.renderer.setRenderTarget(null),this.scene.background=r}}const H=["rotate-x"],Y=y("TresPlaneGeometry",{args:[1,1]},null,-1),K=_({__name:"accumulativeShadowsCom",props:{opacity:{default:.8},alphaTest:{default:.9},color:{default:"#000000"},blend:{default:2},lightPosition:{default:{x:3,y:5,z:3}},frames:{default:60},blendWindow:{default:100},ambient:{default:.5}},setup(l){const e=l;let s=z();const{extend:h,scene:o,renderer:r,camera:c}=D();h({SoftShadowMaterial:V});const a={position:new A().set(e.lightPosition.x,e.lightPosition.y,e.lightPosition.z),radius:1,amount:8,intensity:Math.PI,bias:.001,mapSize:1024,size:8,near:.5,far:200},n=new N(r.value,o.value,a.mapSize),S={map:n.progressiveLightMap2.texture,transparent:!0,depthWrite:!1,toneMapped:!0,blend:e.blend,alphaTest:e.alphaTest,opacity:e.opacity,color:e.color},d=new W;for(let i=0;i<a.amount;i++){const t=new U(16777215,a.intensity/a.amount);t.castShadow=!0,t.shadow.bias=a.bias,t.shadow.camera.near=a.near,t.shadow.camera.far=a.far,t.shadow.camera.right=a.size/2,t.shadow.camera.left=-a.size/2,t.shadow.camera.top=a.size/2,t.shadow.camera.bottom=-a.size/2,t.shadow.mapSize.width=a.mapSize,t.shadow.mapSize.height=a.mapSize,d.add(t)}const x=()=>{const i=a.position.length();for(let t=0;t<d.children.length;t++){const v=d.children[t];if(Math.random()>e.ambient)v.position.set(a.position.x+f.randFloatSpread(a.radius),a.position.y+f.randFloatSpread(a.radius),a.position.z+f.randFloatSpread(a.radius));else{let p=Math.acos(2*Math.random()-1)-Math.PI/2,M=2*Math.PI*Math.random();v.position.set(Math.cos(p)*Math.cos(M)*i,Math.abs(Math.cos(p)*Math.sin(M)*i),Math.sin(p)*i)}}},m=(i=1)=>{o.value.add(d),n.prepare();for(let t=0;t<i;t++)x(),n.update(c.value,e.blendWindow),console.log("shadows plm update",t);o.value.remove(d),n.finish()};g(()=>s.value,i=>{i&&(n.configure(i),n.clear(),console.log("shadows render start"),m(e.frames),console.log("shadows render end"))});const u=()=>{n.clear(),m(e.frames)};return k(()=>{s.value&&(e.opacity&&(s.value.material.opacity=e.opacity),e.alphaTest&&(s.value.material.alphaTest=e.alphaTest),e.color&&s.value.material.color.set(e.color),e.blend&&(s.value.material.blend=e.blend))}),g(()=>e.lightPosition,i=>{i&&(console.log(e.lightPosition),a.position.set(i.x,i.y,i.z),u())},{deep:!0}),g(()=>[e.frames,e.blendWindow,e.ambient],()=>{u()}),(i,t)=>(F(),R("TresMesh",{"receive-shadow":"",ref_key:"gPlane",ref:s,scale:10,"rotate-x":-Math.PI/2},[Y,y("TresSoftShadowMaterial",E(I(S)),null,16)],8,H))}});export{K as _};
