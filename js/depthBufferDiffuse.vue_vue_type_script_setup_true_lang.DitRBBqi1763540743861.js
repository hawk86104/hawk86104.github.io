import{F as e,_ as r}from"./@tresjs.BCHtwiaC1763540743861.js";import{p as o}from"./index.Crdf3MNx1763540743861.js";import{d as n,a9 as a,w as l,H as i,o as t,J as s,ac as u,ao as v}from"./@vue.Co_gxueH1763540743861.js";import{l as d,f,ae as m,am as h}from"./three.rXKzP9fQ1763540743861.js";const c={renderOrder:2200},p=["args"],g=n({__name:"depthBufferDiffuse",props:{radius:{default:100},shieldColor:{default:"#ffff00"},rimColor:{default:"#ffffff"},threshold:{default:.005}},setup(n){const g=n,{sizes:C,camera:D}=e(),x=C.aspectRatio.value,w=C.width.value,y=C.height.value,z=o({height:w*x,width:y*x,depth:!0,isLoop:!0}),N={blending:h,transparent:!0,depthWrite:!1,depthTest:!0,side:m,vertexShader:"\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n        void main() {\n            vUv = uv;\n            vec4 worldPos = modelMatrix * vec4(position, 1.0);\n            vec4 modelNormal = modelMatrix * vec4(normal, 0.0);\n            vec4 mvPosition = viewMatrix * worldPos;\n            gl_Position = projectionMatrix * mvPosition;\n            vNormal = modelNormal.xyz;\n            vPosition = worldPos.xyz;\n        }\n    ",fragmentShader:"\n        uniform sampler2D uDepthTexture; \n        uniform vec2 uResolution;\n        uniform float uNear;\n        uniform float uFar;\n        uniform float uThreshold;\n        uniform vec3 uShieldColor;\n        uniform vec3 uRimColor;\n\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n\n        #include <packing>\n\n        float LinearizeDepth(float depth) {\n            float zNdc = 2.0 * depth - 1.0;\n            float zEye = (2.0 * uFar * uNear) / ((uFar + uNear) - zNdc * (uFar - uNear));\n            float linearDepth = (zEye - uNear) / (uFar - uNear);\n            return linearDepth;\n        }\n\n        void main() {\n            vec3 normal = normalize(vNormal);\n            if(gl_FrontFacing) {\n                normal *= -1.0;\n            }\n\n            vec3 viewDirection = normalize(cameraPosition - vPosition);\n            float fresnel = 1. + dot(normal, viewDirection);\n            fresnel = pow(fresnel, 4.0);\n\n            vec2 worldCoords = gl_FragCoord.xy/uResolution;\n\n            float sceneDepth = LinearizeDepth(texture2D(uDepthTexture, worldCoords).r);\n            float bubbleDepth = LinearizeDepth(gl_FragCoord.z);\n\n            float difference = abs(sceneDepth - bubbleDepth);\n            float normalizedDistance = clamp(difference / uThreshold, 0.0, 1.0);\n            vec4 intersection = mix(vec4(1.0), vec4(0.0), normalizedDistance);\n            intersection.rgb *= uRimColor;\n\n            vec4 color = vec4(uShieldColor, 0.3);\n            gl_FragColor = color + intersection + vec4(uRimColor, 1.0) * fresnel;\n        }\n    ",uniforms:{uDepthTexture:{value:a(z?.value?.depthTexture)},uResolution:{value:new f(w,y)},uNear:{value:D.value?.near??1},uFar:{value:D.value?.far??1e4},uThreshold:{value:g.threshold},uShieldColor:{value:new d(g.shieldColor)},uRimColor:{value:new d(g.rimColor)}}},{onRender:F}=r();return F(()=>{}),l(()=>[g.rimColor,g.shieldColor,g.threshold],([e,r,o])=>{N.uniforms.uRimColor.value.setStyle(e),N.uniforms.uShieldColor.value.setStyle(r),N.uniforms.uThreshold.value=o}),(e,r)=>(t(),i("TresMesh",c,[s("TresSphereGeometry",{args:[g.radius,64,64]},null,8,p),s("TresShaderMaterial",u(v(N)),null,16)]))}});export{g as _};
