import{m as n,e,b as t,U as r,c as o}from"./@tresjs.fCqPNEAw1735275234726.js";import{P as i}from"./tweakpane.yHWGBmom1735275234726.js";import{B as c,_ as a,a as l,aR as s,z as u,W as f,ay as p,s as v,k as g}from"./three.jpi2UCEx1735275234726.js";import{d,a6 as x,b as h,o as m,f as y,u as w,g as b,j as R,al as C,r as I,J as _,aj as M,ak as z}from"./@vue.u2cBPEWn1735275234726.js";import"./@vueuse.8jEBPPFT1735275234726.js";var D="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const T=E;!function(n,e){const t=E,r=F();for(;;)try{if(655526===parseInt(t(404))/1+-parseInt(t(426))/2*(-parseInt(t(434))/3)+-parseInt(t(414))/4*(-parseInt(t(418))/5)+-parseInt(t(423))/6+parseInt(t(391))/7*(parseInt(t(405))/8)+-parseInt(t(435))/9*(-parseInt(t(411))/10)+parseInt(t(408))/11*(-parseInt(t(412))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){A(this,(function(){const n=E,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(403),"i"),r=S(n(425));e[n(415)](r+n(413))&&t[n(415)](r+n(432))?S():r("0")}))()}();const L=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[E(402)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function F(){const n=["3303uyqfEZ","info","FrontSide","while (true) {}","Mesh","console","string","21eRJNnm","prototype","exception","trace","render","setIndex","return (function() ","uniforms","setAttribute","position","log","apply","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","1096471VgDouw","1375824EnEKwj","causticTex","tiles","869UATUSa","gger","error","22460DELUwT","523944qGjboh","chain","5228dTuRyT","test","toString","value","4405lqVqJx","warn","constructor",'{}.constructor("return this")( )',"pool","415176uhpbBE","causticsTexture","init","2tiBqAH","action","BufferAttribute","RawShaderMaterial","stateObject","bind","input","debu","1757598Zbdltz"];return(F=function(){return n})()}L(void 0,(function(){const n=E;let e;try{e=Function(n(397)+n(421)+");")()}catch(o){e=window}const t=e[n(389)]=e[n(389)]||{},r=[n(401),n(419),n(436),n(410),n(393),"table",n(394)];for(let i=0;i<r.length;i++){const e=L[n(420)][n(392)][n(431)](L),o=r[i],c=t[o]||e;e.__proto__=L[n(431)](L),e[n(416)]=c[n(416)][n(431)](c),t[o]=e}}))();const O=d({__name:T(422),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=T,o=t,i=new c,s=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),u=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(399)](r(400),new(a[r(428)])(s,3)),i[r(396)](new l(u,1));const f=new(a[r(429)])({uniforms:{light:{value:o.light},tiles:{value:o[r(407)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:a[r(437)]}),p=new(a[r(439)])(i,f),{renderer:v,camera:g}=n(),{onAfterLoop:d}=e();return d((()=>{const n=r;((n,e)=>{const t=r;f[t(398)].water[t(417)]=n,f[t(398)][t(406)][t(417)]=e,v[t(417)][t(395)](p,g[t(417)])})(o.waterTexture,o[n(424)])})),(n,e)=>null}});function E(n,e){const t=F();return(E=function(n,e){return t[n-=389]})(n,e)}function S(n){function e(n){const t=E;if(typeof n===t(390))return function(n){}.constructor(t(438))[t(402)]("counter");1!==(""+n/n).length||n%20==0?function(){return!0}[t(420)](t(433)+"gger").call(t(427)):function(){return!1}[t(420)](t(433)+t(409)).apply(t(430)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const j=V;!function(n,e){const t=V,r=k();for(;;)try{if(555212===-parseInt(t(510))/1*(parseInt(t(487))/2)+parseInt(t(480))/3+parseInt(t(465))/4+parseInt(t(481))/5+-parseInt(t(514))/6+parseInt(t(507))/7*(-parseInt(t(464))/8)+-parseInt(t(463))/9*(-parseInt(t(475))/10))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[V(460)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){W(this,(function(){const n=V,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(497),"i"),r=Z("init");e.test(r+n(476))&&t.test(r+n(500))?Z():r("0")}))()}();const P=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[V(460)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function V(n,e){const t=k();return(V=function(n,e){return t[n-=460]})(n,e)}function k(){const n=["clear","apply","underwater","RawShaderMaterial","14780250cgczCA","4042224BTlzty","309456AAfiiL","constructor","exception","causticTex","warn","water","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","pos-y.jpg","load","call","10dEJLdF","chain","waterTexture","neg-x.jpg","BackSide","3277581inHNfS","1461870ffArnR","gger","__proto__","uniforms","debu","light","271372bcXQmT","Mesh","neg-z.jpg","Color","console",'{}.constructor("return this")( )',"length","error","pos-x.jpg","setPath","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","prototype","setRenderTarget","input","action","side","toString","setClearColor","causticsTexture","pooRef","14rgfYJC","value","return (function() ","8TyKeAh","log","info","counter","2719554HArFhE","render","bind"];return(k=function(){return n})()}P(void 0,(function(){const n=V,e=function(){const n=V;let e;try{e=Function(n(509)+n(492)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(491)]||{},r=[n(511),n(469),n(512),n(494),n(467),"table","trace"];for(let o=0;o<r[n(493)];o++){const e=P.constructor[n(498)][n(516)](P),i=r[o],c=t[i]||e;e[n(483)]=P[n(516)](P),e[n(503)]=c[n(503)][n(516)](c),t[i]=e}}))();const H=d({__name:j(470),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=j;let i,c;const l=r,f=l.geometry,p=(new s)[o(496)](o(471))[o(473)]([o(495),o(478),o(472),"neg-y.jpg","pos-z.jpg",o(489)]),v=([i,c]=x((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,c(),i),g=new(a[o(462)])({uniforms:{light:{value:l[o(486)]},tiles:{value:v},sky:{value:p},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),d=new(a[o(488)])(f,g),b=h(null),R=new(a[o(490)])("white"),{renderer:C,camera:I}=n(),{onLoop:_}=e();return _((()=>{const n=o;C[n(508)][n(499)](null),C[n(508)][n(504)](R,1),C[n(508)][n(517)](),g[n(484)][n(470)][n(508)]=l.waterTexture,g[n(484)][n(468)][n(508)]=l[n(505)],g[n(502)]=u,g[n(484)].underwater[n(508)]=!0,C[n(508)][n(515)](d,I.value),g.side=a[n(479)],g[n(484)][n(461)][n(508)]=!1,C[n(508)].render(d,I.value)})),(n,e)=>{const t=o;return m(),y(O,{tiles:w(v),light:n[t(486)],waterTexture:n[t(477)],causticsTexture:n[t(505)],ref_key:t(506),ref:b},null,8,["tiles",t(486),"waterTexture",t(505)])}}});function Z(n){function e(n){const t=V;if("string"==typeof n)return function(n){}[t(466)]("while (true) {}")[t(460)](t(513));1!==(""+n/n)[t(493)]||n%20==0?function(){return!0}.constructor(t(485)+t(482))[t(474)](t(501)):function(){return!1}[t(466)](t(485)+t(482))[t(460)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}function N(n,e){const t=J();return(N=function(n,e){return t[n-=439]})(n,e)}const B=N;!function(n,e){const t=N,r=J();for(;;)try{if(352681===parseInt(t(480))/1*(parseInt(t(476))/2)+-parseInt(t(439))/3+parseInt(t(470))/4*(-parseInt(t(466))/5)+-parseInt(t(444))/6*(parseInt(t(479))/7)+parseInt(t(491))/8*(-parseInt(t(496))/9)+-parseInt(t(472))/10*(-parseInt(t(445))/11)+parseInt(t(468))/12)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const G=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[N(477)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){G(this,(function(){const n=N,e=new RegExp(n(449)),t=new RegExp(n(465),"i"),r=$(n(442));e[n(494)](r+n(460))&&t[n(494)](r+n(492))?$():r("0")}))()}();const q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function J(){const n=["light","material","value","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","1015185ptZzWd","setRenderTarget","19340112KpLZWb","water","12dLqFTc","render","40JoZkXG","caustics","log","ShaderMaterial","45886wkPDUV","apply","while (true) {}","7nMJeiT","1MJgVuY","info","clear","black","error","length","gger","call","setClearColor","debu","console","2501288qHSnQO","input","OrthographicCamera","test","trace","18AcBWex","1647102QHDxUt","waterTexture","counter","init","Mesh","433218pcQcNV","1577763FsFlns","constructor","stateObject","Color","function *\\( *\\)","texture","warn","prototype","bind","table",'{}.constructor("return this")( )',"string","toString","uniforms","PlaneGeometry","chain","return (function() "];return(J=function(){return n})()}q(void 0,(function(){const n=N,e=function(){const n=N;let e;try{e=Function(n(461)+n(455)+");")()}catch(t){e=window}return e}(),t=e[n(490)]=e[n(490)]||{},r=[n(474),n(451),n(481),n(484),"exception",n(454),n(495)];for(let o=0;o<r[n(485)];o++){const e=q[n(446)][n(452)][n(453)](q),i=r[o],c=t[i]||e;e.__proto__=q[n(453)](q),e[n(457)]=c[n(457)][n(453)](c),t[i]=e}}))();const U=d({__name:B(473),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=B,o=t,i=new(a[r(493)])(0,1,1,0,0,2e3),c=new(a[r(459)])(2,2,200,200),l=new f(1024,1024),s=new(a[r(475)])({uniforms:{light:{value:o[r(462)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),u=new(a[r(443)])(c,s),p=new(a[r(448)])(r(483)),{renderer:v}=n(),{onBeforeLoop:g}=e();return g((()=>{const n=r;u[n(463)][n(458)][n(469)][n(464)]=o[n(440)],v[n(464)][n(467)](l),v[n(464)][n(488)](p,0),v.value[n(482)](),v.value[n(471)](u,i)})),(n,e)=>{const t=r;return m(),y(C,null,{default:b((()=>[R(H,{waterTexture:n[t(440)],causticsTexture:w(l)[t(450)],light:n[t(462)],geometry:w(c)},null,8,[t(440),"causticsTexture","light","geometry"])])),_:1})}}});function $(n){function e(n){const t=N;if(typeof n===t(456))return function(n){}.constructor(t(478))[t(477)](t(441));1!==(""+n/n)[t(485)]||n%20==0?function(){return!0}[t(446)](t(489)+t(486))[t(487)]("action"):function(){return!1}[t(446)](t(489)+"gger")[t(477)](t(447)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const Y=nn;!function(n,e){const t=nn,r=K();for(;;)try{if(731439===-parseInt(t(314))/1+parseInt(t(355))/2+-parseInt(t(349))/3+-parseInt(t(354))/4*(-parseInt(t(357))/5)+parseInt(t(328))/6+-parseInt(t(321))/7*(-parseInt(t(370))/8)+-parseInt(t(317))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[nn(356)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Q(this,(function(){const n=nn,e=new RegExp(n(330)),t=new RegExp(n(312),"i"),r=tn("init");e[n(323)](r+"chain")&&t[n(323)](r+"input")?tn():r("0")}))()}();const X=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[nn(356)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function K(){const n=["while (true) {}","test","action","counter","WebGLRenderTarget","center","7736874YbGQiN","constructor","function *\\( *\\)","gger","debu","stateObject","removeEventListener","RawShaderMaterial","domElement","Mesh","string","length","info","bind","needsUpdate","prototype","clientY","warn","mousemove","setY","strength","2774133bpGALr","setZ","height","setFromCamera","value","193540mRXRki","2458008UJsSwx","apply","60hvAiOl","waterTexture",'{}.constructor("return this")( )',"FloatType","table","addEventListener","autoClear","point","exception","PlaneGeometry","getBoundingClientRect","waterSimulation","width","8OwvjGm","uniforms","OrthographicCamera","__proto__","setRenderTarget","radius","texture","render","toString","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","error","1330664TJxVMY","material","attributes","1479222UcpXTb","intersectObject","clientX","top","364483JFbZzk"];return(K=function(){return n})()}function nn(n,e){const t=K();return(nn=function(n,e){return t[n-=308]})(n,e)}X(void 0,(function(){const n=nn;let e;try{e=Function("return (function() "+n(359)+");")()}catch(o){e=window}const t=e.console=e.console||{},r=["log",n(345),n(340),n(313),n(365),n(361),"trace"];for(let i=0;i<r[n(339)];i++){const e=X[n(329)][n(343)][n(341)](X),o=r[i],c=t[o]||e;e[n(373)]=X[n(341)](X),e[n(311)]=c.toString[n(341)](c),t[o]=e}}))();const en=d({__name:Y(368),props:{light:{}},setup(t,{expose:r}){const o=Y,i=new(a[o(372)])(0,1,1,0,0,2e3),c=new(a[o(366)])(2,2),l=new f(256,256,{type:a[o(360)]}),s=new(a[o(326)])(256,256,{type:a[o(360)]}),u=new(a[o(335)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),d=new p({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),x=new p({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:D,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),h=new v(c,u),b=new(a[o(337)])(c,d),R=new(a[o(337)])(c,x);let C=l;const I=(n,e)=>{const t=o,r=C,c=C===l?s:l;e[t(315)][t(371)][t(309)][t(353)]=r[t(309)],n[t(374)](c),n[t(310)](e,i),C=c},{renderer:_,camera:M,raycaster:z}=n();_[o(353)][o(363)]=!1;const{onBeforeLoop:T}=e();T((()=>{var n,e;e=_[o(353)],I(e,R),n=_.value,I(n,b)}));const A=(n,e,t,r)=>{const i=o;h[i(315)].uniforms[i(327)][i(353)]=[n,e],h[i(315)][i(371)][i(308)][i(353)]=t,h[i(315)][i(371)][i(348)][i(353)]=r,I(_.value,h)},L=new g,F=new(a[o(366)])(2,2),O=F[o(316)].position;for(let n=0;n<O.count;n++){const e=-O.getY(n);O[o(347)](n,0),O[o(350)](n,e)}O[o(342)]=!0;const E=new(a[o(337)])(F),S={handleEvent:n=>{const e=o,t=_[e(353)][e(336)][e(367)](),r=t[e(369)],i=t[e(351)];L.x=2*(n[e(319)]-t.left)/r-1,L.y=2*-(n[e(344)]-t[e(320)])/i+1,z[e(353)][e(352)](L,M[e(353)]);const c=z[e(353)][e(318)](E);for(let o of c)A(o[e(364)].x,o.point.z,.03,.04)}};return r({addDrop:A,mouseEvent:n=>{const e=o;n?_[e(353)][e(336)][e(362)](e(346),S):_.value[e(336)][e(334)](e(346),S)}}),(n,e)=>{const t=o;return m(),y(U,{lightFrontGeometry:w(c),waterTexture:w(C)[t(309)],light:n.light},null,8,["lightFrontGeometry",t(358),"light"])}}});function tn(n){function e(n){const t=nn;if(typeof n===t(338))return function(n){}[t(329)](t(322))[t(356)](t(325));1!==(""+n/n)[t(339)]||n%20==0?function(){return!0}[t(329)](t(332)+"gger").call(t(324)):function(){return!1}[t(329)](t(332)+t(331))[t(356)](t(333)),e(++n)}try{if(n)return e;e(0)}catch(t){}}function rn(n,e){const t=ln();return(rn=function(n,e){return t[n-=253]})(n,e)}const on=rn;!function(n,e){const t=rn,r=ln();for(;;)try{if(198488===-parseInt(t(254))/1*(parseInt(t(300))/2)+parseInt(t(255))/3+-parseInt(t(262))/4+parseInt(t(270))/5+parseInt(t(292))/6+-parseInt(t(267))/7+parseInt(t(284))/8)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const cn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[rn(259)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){cn(this,(function(){const n=rn,e=new RegExp(n(291)),t=new RegExp(n(266),"i"),r=un(n(271));e[n(297)](r+n(253))&&t.test(r+"input")?un():r("0")}))()}();const an=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[rn(259)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function ln(){const n=["2321400FgEhdN","__proto__","error","random","exception","test","toString","addButton","2QxLnMm","TresPerspectiveCamera","chain","391978dWxqoT","61788DDBmTc","warn","counter","随机增加波纹","apply","return (function() ","change","1532340StSlDp","prototype","log","length","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","2576371tVEGZY","bind","string","1433730GUFogO","init","info","trace","while (true) {}","mouseEvent","manual","stateObject","value","action","debu","addDrop","table","gger","5178896RbNsxP","constructor","realWater","鼠标波纹","waterSimulationRef","call","addBinding","function *\\( *\\)"];return(ln=function(){return n})()}an(void 0,(function(){const n=rn;let e;try{e=Function(n(260)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e.console=e.console||{},r=[n(264),n(256),n(272),n(294),n(296),n(282),n(273)];for(let i=0;i<r[n(265)];i++){const e=an.constructor[n(263)].bind(an),o=r[i],c=t[o]||e;e[n(293)]=an[n(268)](an),e.toString=c[n(298)][n(268)](c),t[o]=e}}))();const sn=d({__name:on(286),setup(n){const e=on,t=I({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(276)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=h(null),l=new i;l[e(299)]({label:"点击按钮",title:e(258)}).on("click",(()=>{const n=e;for(var t=0;t<10;t++)a.value[n(281)](2*Math[n(295)]()-1,2*Math.random()-1,.03,1&t?.02:-.02)}));const s=h(!1);return l[e(290)](s,e(278),{label:e(287)}).on(e(261),(n=>{const t=e;a[t(278)][t(275)](n[t(278)])})),(n,i)=>{const l=e;return m(),y(w(o),M(z(t)),{default:b((()=>[i[0]||(i[0]=_(l(301),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),R(w(r)),R(en,{light:c,ref_key:l(288),ref:a},null,512)])),_:1},16)}}});function un(n){function e(n){const t=rn;if(typeof n===t(269))return function(n){}[t(285)](t(274))[t(259)](t(257));1!==(""+n/n).length||n%20==0?function(){return!0}.constructor(t(280)+"gger")[t(289)](t(279)):function(){return!1}[t(285)](t(280)+t(283))[t(259)](t(277)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{sn as default};
