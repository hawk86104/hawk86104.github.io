const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./index.B2-FHinZ1769412424343.js","./3d-tiles-renderer.DFcJBJdg1769412424343.js","./runtime-core.esm-bundler.D5Ci-qZd1769412424343.js","../css/index.BPhjZGul1769412424343.css","./index.BM1quI7G1769412424343.js","./index.vue_vue_type_script_setup_true_lang.DH77e3Tw1769412424343.js","./utils.BJ1fGVNw1769412424343.js","./three.webgpu.3jxo6HDu1769412424343.js","./three.DM5Jrh-_1769412424343.js","./index.BDOS1X5j1769412424343.js","./useSeek.BeqkRePD1769412424343.js","./shapeConfigurator.Bi8mAc3U1769412424343.js","./index.vWHhfcZY1769412424343.js","./flexiblePipe.vue_vue_type_script_setup_true_lang.CfAMQXkg1769412424343.js","./Resource._LsWhyZZ1769412424343.js","./DRACOLoader.BUWLMpr31769412424343.js","./HDRLoader.CTHHWwB91769412424343.js","./buildFlexiblePipe.BcC53sUF1769412424343.js","./flexiblePipe2.vue_vue_type_script_setup_true_lang.2LHp48yd1769412424343.js","./material.vue_vue_type_script_setup_true_lang.BUucjTR-1769412424343.js"])))=>i.map(i=>d[i]);
import{importShared as e}from"./3d-tiles-renderer.DFcJBJdg1769412424343.js";import{useTres as t,RGBELoader as n,useLoop as a,objectHash as r,__vitePreload as o,TorusKnot_default as i,Torus_default as l,Tetrahedron_default as s,Sphere_default as c,RoundedBox_default as u,Ring_default as m,Plane_default as d,Octahedron_default as f,Icosahedron_default as p,Dodecahedron_default as v,Cylinder_default as h,Cone_default as g,Circle_default as y,Box_default as _}from"./index.B2-FHinZ1769412424343.js";import{shaderMaterial as x}from"./shaderMaterial.CJONWwcM1769412424343.js";import{FullScreenQuad as b}from"./Pass.pIqL6Azh1769412424343.js";import"./index.vue_vue_type_script_setup_true_lang.DH77e3Tw1769412424343.js";import{instance as S}from"./Resource._LsWhyZZ1769412424343.js";import{NCard as M}from"./Card.M8AczkLc1769412424343.js";import{NSpace as w}from"./Space.B1HK3hVx1769412424343.js";import{NSelect as P,NSlider as k,NSwitch as T}from"./Switch.DEm_cb7c1769412424343.js";import{NForm as C,NFormItem as R}from"./FormItem.rXyOI1If1769412424343.js";import{B as I}from"./three-custom-shader-material.es.DUHaOnDf1769412424343.js";const{Scene:E,Object3D:D,Mesh:A}=await e("three");class z extends D{constructor(){super(),this.virtualScene=null,this.virtualScene=new E}add(...e){return this.virtualScene.add(...e),this}destructor(){this.virtualScene.traverse(e=>{e instanceof A&&(e.geometry.dispose(),e.material.dispose(),e.material.map&&e.material.map.dispose(),this.virtualScene.remove(e))}),this.virtualScene=null}}const O={sunset:"venice/venice_sunset_1k.hdr",studio:"studio/poly_haven_studio_1k.hdr",city:"city/canary_wharf_1k.hdr",umbrellas:"outdoor/outdoor_umbrellas_1k.hdr",night:"outdoor/satara_night_1k.hdr",forest:"outood/mossy_forest_1k.hdr",snow:"outdoor/snowy_forest_path_01_1k.hdr",dawn:"kiara/kiara_1_dawn_1k.hdr",hangar:"indoor/small_hangar_01_1k.hdr",urban:"indoor/abandoned_games_room_02_1k.hdr",modern:"city/modern_buildings_2_1k.hdr",shangai:"city/shanghai_bund_1k.hdr"},{CubeReflectionMapping:B,CubeTextureLoader:F,EquirectangularReflectionMapping:j}=await e("three"),{computed:N,ref:L,toRefs:U,unref:V,watch:H}=await e("vue");const{withAsyncContext:G,defineComponent:W}=await e("vue"),{unref:$,renderSlot:K,openBlock:Y,createElementBlock:q,createCommentVNode:Z}=await e("vue"),{ref:X,useSlots:J,onUnmounted:Q,watch:ee,toRaw:te}=await e("vue"),{WebGLCubeRenderTarget:ne,CubeCamera:ae,HalfFloatType:re,UnsignedByteType:oe,NearestFilter:ie}=await e("three"),le=W({__name:"component",props:{background:{type:[Boolean,String],default:!1},blur:{default:0},files:{default:[]},path:{default:""},preset:{default:void 0},resolution:{default:256},near:{default:1},far:{default:1e3},frames:{default:1/0},useDefaultScene:{type:Boolean,default:!1}},async setup(e,{expose:r}){let o,i;const l=e,s=X(null);r({texture:s});const{extend:c,renderer:u,scene:m}=t();let d=null,f=X(null),p=null;const v=X(null);Q(()=>{v.value?.destructor(),f.value?.dispose()});const{onBeforeRender:h}=a();let g=1;h(()=>{p&&v.value&&f.value&&(l.frames===1/0||g<l.frames)&&(l.useDefaultScene?p.update(u,m.value):p.update(u,te(v.value.virtualScene)),g++)});const y=([o,i]=G(()=>async function(e,a){const{scene:r,invalidate:o}=t();H(e,()=>{o()});const{preset:i,blur:l,files:s=L([]),path:c=L(""),background:u}=U(e),m=L(null),d=N(()=>Array.isArray(s.value)),f=N(()=>d.value?F:n);return H([s,c],async([e,t])=>{if(e&&e.length>0&&!i?.value){try{m.value=await ta(f.value,d.value?[...V(e)]:V(e),e=>{t&&e.setPath(V(t))})}catch(n){throw new Error(`Failed to load environment map: ${n}`)}m.value&&(m.value.mapping=d.value?B:j),o()}},{immediate:!0}),H(m,e=>{r.value&&e&&(r.value.environment=e)},{immediate:!0}),H([u,m],([e,t])=>{if(r.value){let n=a?.value?a.value.texture:t,o=r.value.background;o?.isColor||(o=void 0),r.value.background=e?n:o}},{immediate:!0}),H(()=>l?.value,e=>{r.value&&e&&(r.value.backgroundBlurriness=e)},{immediate:!0}),H(()=>i?.value,async e=>{if(e&&e in O){const a="https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/",r=O[e];try{m.value=await ta(n,r,e=>{a&&e.setPath(a)})}catch(t){throw new Error(`Failed to load environment map: ${t}`)}m.value&&m.value&&(m.value.mapping=j),o()}else if(e&&!(e in O))throw new Error(`Preset must be one of: ${Object.keys(O).join(", ")}`)},{immediate:!0}),m}(l,f)),o=await o,i(),o),_=e=>{e?(m.value.environment=e.texture,l.background&&(m.value.background=e.texture)):(m.value.environment=y.value,l.background&&(m.value.background=y.value))};ee(y,e=>{f.value&&_(f.value)},{immediate:!0,deep:!0}),c({EnvSence:z});const x=()=>{f.value?.dispose(),f.value=new ne(l.resolution),p=new ae(l.near,l.far,f.value),l.useDefaultScene?(f.value.texture.type=oe,f.value.texture.generateMipmaps=!1,f.value.texture.minFilter=ie,f.value.texture.magFilter=ie):f.value.texture.type=re,_(f.value)};return ee(()=>J().default,e=>{e&&(!f.value||f.value.texture.type!==re)&&(d=e(),Array.isArray(d)&&d.length>0&&"symbol"!=typeof d[0]?.type)?x():(f.value?.dispose(),f.value=null,_(null))},{immediate:!0,deep:!0}),s.value=y,ee(()=>l.useDefaultScene,e=>{f.value&&x()}),(e,t)=>$(f)?(Y(),q("TresEnvSence",{key:0,ref_key:"envSence",ref:v},[K(e.$slots,"default")],512)):Z("",!0)}}),{defineComponent:se}=await e("vue"),{openBlock:ce,createElementBlock:ue,createBlock:me,unref:de,createElementVNode:fe}=await e("vue"),pe={key:0,args:[0,1,64]},ve={key:1,args:[.5,1,64]},he={key:2},ge=["toneMapped","map","side","color"],{ref:ye,watchEffect:_e,onMounted:xe,watch:be}=await e("vue"),{Color:Se,DoubleSide:Me}=await e("three"),we=se({__name:"index",props:{args:{default:null},from:{default:"rect"},toneMapped:{type:Boolean,default:!1},map:{default:null},intensity:{default:1},color:{default:new Se(16777215)}},setup(e){const t=e,n=ye();return _e(()=>{n.value&&(n.value.color.multiplyScalar(t.intensity),n.value.needsUpdate=!0)}),be(()=>t.color,e=>{n.value&&(n.value.color.set(e),n.value.color.multiplyScalar(t.intensity),n.value.needsUpdate=!0)}),xe(()=>{}),(e,a)=>(ce(),ue("TresMesh",null,["circle"===t.from?(ce(),ue("TresRingGeometry",pe)):"ring"===t.from?(ce(),ue("TresRingGeometry",ve)):"rect"===t.from?(ce(),ue("TresPlaneGeometry",he)):(ce(),me(t.from,{key:3,args:t})),fe("TresMeshBasicMaterial",{ref_key:"material",ref:n,toneMapped:e.toneMapped,map:e.map,side:de(Me),color:e.color},null,8,ge)]))}}),{DepthTexture:Pe,DepthFormat:ke,UnsignedShortType:Te,HalfFloatType:Ce,LinearFilter:Re,WebGLRenderTarget:Ie}=await e("three"),{isReactive:Ee,onBeforeUnmount:De,reactive:Ae,ref:ze,toRefs:Oe,watchEffect:Be,toRaw:Fe}=await e("vue");function je(e){const n=ze(null),{height:r,width:o,settings:i,depth:l,isLoop:s}=Ee(e)?Oe(e):Oe(Ae(e)),{onRender:c}=a(),{camera:u,renderer:m,scene:d,sizes:f}=t();return Be(()=>{n.value?.dispose(),n.value=new Ie(o?.value||f.width.value,r?.value||f.height.value,{minFilter:Re,magFilter:Re,type:Ce,...i?.value}),l?.value&&(n.value.depthTexture=new Pe(o?.value||f.width.value,r?.value||f.height.value),n.value.depthTexture.format=ke,n.value.depthTexture.type=Te)}),c(()=>{s?.value&&(m.setRenderTarget(Fe(n.value)),m.clear(),m.render(Fe(d.value),Fe(u.value)),m.setRenderTarget(null))}),De(()=>{n.value?.dispose()}),n}const Ne=await e("three");function Le(e=1024,t=1024,n){var a=e,r=t,o=n||{};const{samples:i=0,depth:l,...s}=o,c=null!=l?l:o.depthBuffer;var u=new Ne.WebGLRenderTarget(a,r,{minFilter:Ne.LinearFilter,magFilter:Ne.LinearFilter,type:Ne.HalfFloatType,...s});return c&&(u.depthTexture=new Ne.DepthTexture(a,r,Ne.FloatType)),u.samples=i,u}const Ue=await e("three");function Ve(e=Ue.FrontSide){const t={value:new Ue.Matrix4};return Object.assign(new Ue.MeshNormalMaterial({side:e}),{viewMatrix:t,onBeforeCompile:e=>{e.uniforms.viewMatrix=t,e.fragmentShader="vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n         }\n"+e.fragmentShader.replace("#include <normal_fragment_maps>","#include <normal_fragment_maps>\n           normal = inverseTransformDirection( normal, viewMatrix );\n")}})}const He=x({causticsTexture:null,causticsTextureB:null,color:new Ue.Color,lightProjMatrix:new Ue.Matrix4,lightViewMatrix:new Ue.Matrix4},"varying vec3 vWorldPosition;   \n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\n     vWorldPosition = worldPosition.xyz;\n   }",`varying vec3 vWorldPosition;\n  uniform vec3 color;\n  uniform sampler2D causticsTexture; \n  uniform sampler2D causticsTextureB; \n  uniform mat4 lightProjMatrix;\n  uniform mat4 lightViewMatrix;\n   void main() {\n    // Apply caustics  \n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\n    lightSpacePos.xyz /= lightSpacePos.w;\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\n    gl_FragColor = vec4((front + back) * color, 1.0);\n    #include <tonemapping_fragment>\n    #include <${parseInt(Ue.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n   }`),Ge=x({cameraMatrixWorld:new Ue.Matrix4,cameraProjectionMatrixInv:new Ue.Matrix4,normalTexture:null,depthTexture:null,lightDir:new Ue.Vector3(0,1,0),lightPlaneNormal:new Ue.Vector3(0,1,0),lightPlaneConstant:0,near:.1,far:100,modelMatrix:new Ue.Matrix4,worldRadius:1/40,ior:1.1,bounces:0,resolution:1024,size:10,intensity:.5},"\n  varying vec2 vUv;\n  void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }","  \n  uniform mat4 cameraMatrixWorld;\n  uniform mat4 cameraProjectionMatrixInv;\n  uniform vec3 lightDir;\n  uniform vec3 lightPlaneNormal;\n  uniform float lightPlaneConstant;\n  uniform float near;\n  uniform float far;\n  uniform float time;\n  uniform float worldRadius;\n  uniform float resolution;\n  uniform float size;\n  uniform float intensity;\n  uniform float ior;\n  precision highp isampler2D;\n  precision highp usampler2D;\n  uniform sampler2D normalTexture;\n  uniform sampler2D depthTexture;\n  uniform float bounces;\n  varying vec2 vUv;\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\n    // Perspective division\n    viewSpacePosition /= viewSpacePosition.w;\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\n    return worldSpacePosition.xyz;\n  }                  \n  float sdPlane( vec3 p, vec3 n, float h ) {\n    // n must be normalized\n    return dot(p,n) + h;\n  }\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n  }\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\n    rayOrigin = ro;\n    rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = pos + rayDirection * 0.1;\n    return rayDirection;\n  }\n  void main() {\n    // Each sample consists of random offset in the x and y direction\n    float caustic = 0.0;\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\n    float texelsNeeded = worldRadius / causticTexelSize;\n    float sampleRadius = texelsNeeded / resolution;\n    float sum = 0.0;\n    if (texture2D(depthTexture, vUv).x == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 uv1 = vUv + offset1 * sampleRadius;\n    vec2 uv2 = vUv + offset2 * sampleRadius;\n    vec2 uv3 = vUv + offset3 * sampleRadius;\n    vec2 uv4 = vUv + offset4 * sampleRadius;\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\n    // Sanity check the depths\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\n    vec3 endPos1, endPos2, endPos3, endPos4;\n    vec3 endDir1, endDir2, endDir3, endDir4;\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\n    caustic += intensity * (lightPosArea / finalArea);\n    // Calculate the area of the triangle in light spaces\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\n  }"),We={depthBuffer:!0,minFilter:Ue.LinearFilter,magFilter:Ue.LinearFilter,type:Ue.UnsignedByteType},$e={minFilter:Ue.LinearMipmapLinearFilter,magFilter:Ue.LinearFilter,type:Ue.FloatType,generateMipmaps:!0};const Ke=(e,{frames:t=1,causticsOnly:n=!1,ior:a=1.1,backside:r=!1,backsideIOR:o=1.1,worldRadius:i=.3125,color:l=new Ue.Color("white"),intensity:s=.05,resolution:c=2024,lightSource:u=new Ue.Vector3(1,1,1),near:m=.1,far:d=0}={})=>{const f={frames:t,ior:a,color:l,causticsOnly:n,backside:r,backsideIOR:o,worldRadius:i,intensity:s,resolution:c,lightSource:u,near:m,far:d},p=new Ue.Group;p.name="caustics_group";const v=new Ue.OrthographicCamera,h=new Ue.Scene;h.name="caustics_scene";const g=e,y=new Ue.CameraHelper(v);y.name="caustics_helper";const _=f.resolution,x=Le(_,_,We),S=Le(_,_,We);e.extensions.get("OES_texture_float_linear")||(console.warn("Caustics: OES_texture_float_linear extension is not supported, using HalfFloatType instead."),$e.type=Ue.HalfFloatType);const M=Le(_,_,$e),w=Le(_,_,$e),P=new Ue.Mesh(new Ue.PlaneGeometry(1,1),new He({transparent:!0,color:f.color,causticsTexture:M.texture,causticsTextureB:w.texture,blending:Ue.CustomBlending,blendSrc:Ue.OneFactor,blendDst:Ue.SrcAlphaFactor,depthWrite:!1}));P.name="caustics_plane",P.rotation.x=-Math.PI/2,P.renderOrder=2,p.add(h,P),p.updateWorldMatrix(!1,!0);const k=function(e){const t=Ve(),n=Ve(Ue.BackSide),a=new Ge,r=new b(a);let o=0;const i=new Ue.Vector3,l=new Ue.Frustum,s=new Ue.Matrix4,c=new Ue.Plane,u=new Ue.Vector3,m=new Ue.Vector3,d=new Ue.Box3,f=new Ue.Vector3,p=[],v=[],h=[],g=[],y=new Ue.Vector3;for(let _=0;_<8;_++)p.push(new Ue.Vector3),v.push(new Ue.Vector3),h.push(new Ue.Vector3),g.push(new Ue.Vector3);return function(_){const{params:x,helper:b,camera:S,plane:M,normalTarget:w,normalTargetB:P,causticsTarget:k,causticsTargetB:T,scene:C,group:R}=e();if(x.frames===1/0||x.frames&&o++<x.frames){var I;(null==(E=x.lightSource)?void 0:E.isVector3)?u.copy(x.lightSource).normalize():x.lightSource&&u.copy(R.worldToLocal(x.lightSource.getWorldPosition(i)).normalize()),m.copy(u).multiplyScalar(-1),null==(I=C.parent)||I.matrixWorld.identity(),d.setFromObject(C,!0),p[0].set(d.min.x,d.min.y,d.min.z),p[1].set(d.min.x,d.min.y,d.max.z),p[2].set(d.min.x,d.max.y,d.min.z),p[3].set(d.min.x,d.max.y,d.max.z),p[4].set(d.max.x,d.min.y,d.min.z),p[5].set(d.max.x,d.min.y,d.max.z),p[6].set(d.max.x,d.max.y,d.min.z),p[7].set(d.max.x,d.max.y,d.max.z);for(let t=0;t<8;t++)v[t].copy(p[t]);d.getCenter(f),p.map(e=>e.sub(f));const e=c.set(m,0);p.map((t,n)=>e.projectPoint(t,h[n]));const o=h.reduce((e,t)=>e.add(t),i.set(0,0,0)).divideScalar(h.length),D=h.map(e=>e.distanceTo(o)).reduce((e,t)=>Math.max(e,t)),A=p.map(e=>e.dot(u)).reduce((e,t)=>Math.max(e,t));S.position.copy(y.copy(u).multiplyScalar(A).add(f)),S.lookAt(C.localToWorld(f));const z=s.lookAt(S.position,f,i.set(0,1,0));if(S.left=-D,S.right=D,S.top=D,S.bottom=-D,x.near&&(S.near=x.near),x.far)S.far=x.far;else{const e=i.set(0,D,0).applyMatrix4(z),t=(S.position.y+e.y)/u.y;S.far=t}S.updateProjectionMatrix(),S.updateMatrixWorld();const O=v.map((e,t)=>e.add(g[t].copy(u).multiplyScalar(-e.y/u.y))),B=O.reduce((e,t)=>e.add(t),i.set(0,0,0)).divideScalar(O.length),F=2*O.map(e=>Math.hypot(e.x-B.x,e.z-B.z)).reduce((e,t)=>Math.max(e,t));M.scale.setScalar(F),M.position.copy(B),null!=b&&b.parent&&b.update(),n.viewMatrix.value=t.viewMatrix.value=S.matrixWorldInverse;const j=l.setFromProjectionMatrix(s.multiplyMatrices(S.projectionMatrix,S.matrixWorldInverse)).planes[4];a.cameraMatrixWorld=S.matrixWorld,a.cameraProjectionMatrixInv=S.projectionMatrixInverse,a.lightDir=m,a.lightPlaneNormal=j.normal,a.lightPlaneConstant=j.constant,a.near=S.near,a.far=S.far,x.resolution&&(a.resolution=x.resolution),a.size=D,x.intensity&&(a.intensity=x.intensity),x.worldRadius&&(a.worldRadius=x.worldRadius),C.visible=!0,_.setRenderTarget(w),_.clear(),C.overrideMaterial=t,_.render(C,S),_.setRenderTarget(P),_.clear(),x.backside&&(C.overrideMaterial=n,_.render(C,S)),C.overrideMaterial=null,x.ior&&(a.ior=x.ior),M.material.lightProjMatrix=S.projectionMatrix,M.material.lightViewMatrix=S.matrixWorldInverse,a.normalTexture=w.texture,a.depthTexture=w.depthTexture,_.setRenderTarget(k),_.clear(),r.render(_),x.backsideIOR&&(a.ior=x.backsideIOR),a.normalTexture=P.texture,a.depthTexture=P.depthTexture,_.setRenderTarget(T),_.clear(),x.backside&&r.render(_),_.setRenderTarget(null),x.causticsOnly&&(C.visible=!1)}var E}}(()=>({params:f,scene:h,group:p,camera:v,plane:P,normalTarget:x,normalTargetB:S,causticsTarget:M,causticsTargetB:w,helper:y}));return{scene:h,group:p,helper:y,params:f,update:k.bind({},g),normalTarget:x,normalTargetB:S,causticsTarget:M,causticsTargetB:w}},Ye=x({},"void main() { }","void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }"),qe=await e("three");class Ze extends qe.MeshPhysicalMaterial{constructor({samples:e=6,transmissionSampler:t=!1,chromaticAberration:n=.05,transmission:a=0,_transmission:r=1,transmissionMap:o=null,roughness:i=0,thickness:l=0,thicknessMap:s=null,attenuationDistance:c=1/0,attenuationColor:u=new qe.Color("white"),anisotropicBlur:m=.1,time:d=0,distortion:f=0,distortionScale:p=.5,temporalDistortion:v=0,buffer:h=null}={}){super(),this.uniforms={chromaticAberration:{value:n},transmission:{value:a},_transmission:{value:r},transmissionMap:{value:o},roughness:{value:i},thickness:{value:l},thicknessMap:{value:s},attenuationDistance:{value:c},attenuationColor:{value:u},anisotropicBlur:{value:m},time:{value:d},distortion:{value:f},distortionScale:{value:p},temporalDistortion:{value:v},buffer:{value:h}},this.onBeforeCompile=n=>{n.uniforms={...n.uniforms,...this.uniforms},t?n.defines.USE_SAMPLER="":n.defines.USE_TRANSMISSION="",n.fragmentShader="\n      uniform float chromaticAberration;         \n      uniform float anisotropicBlur;      \n      uniform float time;\n      uniform float distortion;\n      uniform float distortionScale;\n      uniform float temporalDistortion;\n      uniform sampler2D buffer;\n\n      vec3 random3(vec3 c) {\n        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n        vec3 r;\n        r.z = fract(512.0*j);\n        j *= .125;\n        r.x = fract(512.0*j);\n        j *= .125;\n        r.y = fract(512.0*j);\n        return r-0.5;\n      }\n\n      uint hash( uint x ) {\n        x += ( x << 10u );\n        x ^= ( x >>  6u );\n        x += ( x <<  3u );\n        x ^= ( x >> 11u );\n        x += ( x << 15u );\n        return x;\n      }\n\n      // Compound versions of the hashing algorithm I whipped together.\n      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\n      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\n      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n      // Construct a float with half-open range [0:1] using low 23 bits.\n      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\n      float floatConstruct( uint m ) {\n        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n        m |= ieeeOne;                          // Add fractional part to 1.0\n        float  f = uintBitsToFloat( m );       // Range [1:2]\n        return f - 1.0;                        // Range [0:1]\n      }\n\n      // Pseudo-random value in half-open range [0:1].\n      float randomBase( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\n      float randomBase( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float randomBase( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float randomBase( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float rand(float seed) {\n        float result = randomBase(vec3(gl_FragCoord.xy, seed));\n        return result;\n      }\n\n      const float F3 =  0.3333333;\n      const float G3 =  0.1666667;\n\n      float snoise(vec3 p) {\n        vec3 s = floor(p + dot(p, vec3(F3)));\n        vec3 x = p - s + dot(s, vec3(G3));\n        vec3 e = step(vec3(0.0), x - x.yzx);\n        vec3 i1 = e*(1.0 - e.zxy);\n        vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n        vec3 x1 = x - i1 + G3;\n        vec3 x2 = x - i2 + 2.0*G3;\n        vec3 x3 = x - 1.0 + 3.0*G3;\n        vec4 w, d;\n        w.x = dot(x, x);\n        w.y = dot(x1, x1);\n        w.z = dot(x2, x2);\n        w.w = dot(x3, x3);\n        w = max(0.6 - w, 0.0);\n        d.x = dot(random3(s), x);\n        d.y = dot(random3(s + i1), x1);\n        d.z = dot(random3(s + i2), x2);\n        d.w = dot(random3(s + 1.0), x3);\n        w *= w;\n        w *= w;\n        d *= w;\n        return dot(d, vec4(52.0));\n      }\n\n      float snoiseFractal(vec3 m) {\n        return 0.5333333* snoise(m)\n              +0.2666667* snoise(2.0*m)\n              +0.1333333* snoise(4.0*m)\n              +0.0666667* snoise(8.0*m);\n      }\n"+n.fragmentShader,n.fragmentShader=n.fragmentShader.replace("#include <transmission_pars_fragment>","\n        #ifdef USE_TRANSMISSION\n          // Transmission code is based on glTF-Sampler-Viewer\n          // https://github.com/KhronosGroup/glTF-Sample-Viewer\n          uniform float _transmission;\n          uniform float thickness;\n          uniform float attenuationDistance;\n          uniform vec3 attenuationColor;\n          #ifdef USE_TRANSMISSIONMAP\n            uniform sampler2D transmissionMap;\n          #endif\n          #ifdef USE_THICKNESSMAP\n            uniform sampler2D thicknessMap;\n          #endif\n          uniform vec2 transmissionSamplerSize;\n          uniform sampler2D transmissionSamplerMap;\n          uniform mat4 modelMatrix;\n          uniform mat4 projectionMatrix;\n          varying vec3 vWorldPosition;\n          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n            // Direction of refracted light.\n            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n            // Compute rotation-independant scaling of the model matrix.\n            vec3 modelScale;\n            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n            // The thickness is specified in local space.\n            return normalize( refractionVector ) * thickness * modelScale;\n          }\n          float applyIorToRoughness( const in float roughness, const in float ior ) {\n            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n            // an IOR of 1.5 results in the default amount of microfacet refraction.\n            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n          }\n          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );            \n            #ifdef USE_SAMPLER\n              #ifdef texture2DLodEXT\n                return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #else\n                return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #endif\n            #else\n              return texture2D(buffer, fragCoord.xy);\n            #endif\n          }\n          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n            if ( isinf( attenuationDistance ) ) {\n              // Attenuation distance is +âˆž, i.e. the transmitted color is not attenuated at all.\n              return radiance;\n            } else {\n              // Compute light attenuation using Beer's law.\n              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n              return transmittance * radiance;\n            }\n          }\n          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n            const in vec3 attenuationColor, const in float attenuationDistance ) {\n            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n            vec3 refractedRayExit = position + transmissionRay;\n            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n            vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n            refractionCoords += 1.0;\n            refractionCoords /= 2.0;\n            // Sample framebuffer to get pixel the refracted ray hits.\n            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n            // Get the specular component.\n            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n          }\n        #endif\n"),n.fragmentShader=n.fragmentShader.replace("#include <transmission_fragment>",`  \n        // Improve the refraction to use the world pos\n        material.transmission = _transmission;\n        material.transmissionAlpha = 1.0;\n        material.thickness = thickness;\n        material.attenuationDistance = attenuationDistance;\n        material.attenuationColor = attenuationColor;\n        #ifdef USE_TRANSMISSIONMAP\n          material.transmission *= texture2D( transmissionMap, vUv ).r;\n        #endif\n        #ifdef USE_THICKNESSMAP\n          material.thickness *= texture2D( thicknessMap, vUv ).g;\n        #endif\n        \n        vec3 pos = vWorldPosition;\n        float runningSeed = 0.0;\n        vec3 v = normalize( cameraPosition - pos );\n        vec3 n = inverseTransformDirection( normal, viewMatrix );\n        vec3 transmission = vec3(0.0);\n        float transmissionR, transmissionB, transmissionG;\n        float randomCoords = rand(runningSeed++);\n        float thickness_smear = thickness * max(pow(roughnessFactor, 0.33), anisotropicBlur);\n        vec3 distortionNormal = vec3(0.0);\n        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;\n        if (distortion > 0.0) {\n          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));\n        }\n        for (float i = 0.0; i < ${e}.0; i ++) {\n          vec3 sampleNorm = normalize(n + roughnessFactor * roughnessFactor * 2.0 * normalize(vec3(rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5)) * pow(rand(runningSeed++), 0.33) + distortionNormal);\n          transmissionR = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(${e}),\n            material.attenuationColor, material.attenuationDistance\n          ).r;\n          transmissionG = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(${e})) , material.thickness + thickness_smear * (i + randomCoords) / float(${e}),\n            material.attenuationColor, material.attenuationDistance\n          ).g;\n          transmissionB = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(${e})), material.thickness + thickness_smear * (i + randomCoords) / float(${e}),\n            material.attenuationColor, material.attenuationDistance\n          ).b;\n          transmission.r += transmissionR;\n          transmission.g += transmissionG;\n          transmission.b += transmissionB;\n        }\n        transmission /= ${e}.0;\n        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n`)},Object.keys(this.uniforms).forEach(e=>Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:t=>this.uniforms[e].value=t}))}}const{defineComponent:Xe}=await e("vue"),{unref:Je,openBlock:Qe,createElementBlock:et}=await e("vue"),tt=["buffer","side"],{shallowRef:nt,nextTick:at,onMounted:rt}=await e("vue"),{BackSide:ot,DoubleSide:it}=await e("three"),lt=Xe({__name:"index",props:{backside:{type:Boolean,default:!0},thickness:{default:1},backsideThickness:{default:.5},fboResolution:{default:256}},setup(e,{expose:n}){const r=nt(),{extend:o,scene:i,renderer:l,camera:s}=t(),c=nt(),u=e;o({MeshTransmissionMaterial:Ze});const m=new Ye,{onBeforeRender:d}=a(),f=je({width:u.fboResolution,height:u.fboResolution,isLoop:!1}),p=je({width:u.fboResolution,height:u.fboResolution,isLoop:!1});let v,h,g,y;return rt(async()=>{await at(),c.value=function(e,t){let n;return e.traverse(e=>{e.isMesh&&e.material&&e.material.uuid===t&&(n=e)}),n}(i.value,r.value.uuid)}),d(({elapsed:e})=>{r.value&&(r.value.time=e,r.value.buffer===p.value.texture&&c.value&&(g=l.toneMapping,v=i.value.background,h=r.value.envMapIntensity,y=c.value.material.side,c.value.material=m,u.backside&&(l.setRenderTarget(f.value),l.render(i.value,s.value),c.value.material=r.value,c.value.material.thickness=u.backsideThickness,c.value.material.buffer=f.value.texture,c.value.material.side=ot,c.value.material.envMapIntensity=0),l.setRenderTarget(p.value),l.render(i.value,s.value),c.value.material.buffer=p.value.texture,c.value.material=r.value,c.value.material.thickness=u.thickness,c.value.material.side=y,c.value.material.envMapIntensity=h,i.value.background=v,l.setRenderTarget(null),l.toneMapping=g))}),n({root:r,constructor:Ze}),(e,t)=>(Qe(),et("TresMeshTransmissionMaterial",{ref_key:"MeshTransmissionMaterialClass",ref:r,buffer:Je(p).texture,side:Je(it)},null,8,tt))}}),{defineComponent:st}=await e("vue"),{renderSlot:ct,createElementVNode:ut,openBlock:mt,createElementBlock:dt}=await e("vue"),{ref:ft,onMounted:pt}=await e("vue"),{Box3:vt,Vector3:ht,Sphere:gt}=await e("three"),yt=st({__name:"index",props:{precise:{type:Boolean,default:!0},top:{type:Boolean,default:!1},right:{type:Boolean,default:!1},bottom:{type:Boolean,default:!1},left:{type:Boolean,default:!1},front:{type:Boolean,default:!1},back:{type:Boolean,default:!1},disable:{type:Boolean,default:!1},disableX:{type:Boolean,default:!1},disableY:{type:Boolean,default:!1},disableZ:{type:Boolean,default:!1}},setup(e){const t=e,n=ft(null),a=ft(null),r=ft(null);return pt(()=>{if(!a.value)return;if(!r.value)return;a.value.matrixWorld.identity();const e=(new vt).setFromObject(r.value,t.precise),n=new ht,o=new gt,i=e.max.x-e.min.x,l=e.max.y-e.min.y,s=e.max.z-e.min.z;e.getCenter(n),e.getBoundingSphere(o);const c=t.top?l/2:t.bottom?-l/2:0,u=t.left?-i/2:t.right?i/2:0,m=t.front?s/2:t.back?-s/2:0;a.value.position.set(t.disable||t.disableX?0:-n.x+u,t.disable||t.disableY?0:-n.y+c,t.disable||t.disableZ?0:-n.z+m)}),(e,t)=>(mt(),dt("TresGroup",{ref_key:"gref",ref:n},[ut("TresGroup",{ref_key:"outer",ref:a},[ut("TresGroup",{ref_key:"inner",ref:r},[ct(e.$slots,"default")],512)],512)],512))}}),{defineComponent:_t}=await e("vue"),{renderSlot:xt,createElementVNode:bt,unref:St,Fragment:Mt,openBlock:wt,createElementBlock:Pt}=await e("vue"),kt=["object"],Tt=["object"],{shallowRef:Ct,watch:Rt,watchEffect:It}=await e("vue"),Et=await e("three"),Dt=_t({__name:"index",props:{color:{default:"#ffffff"},ior:{default:1.1},backsideIOR:{default:1.1},far:{default:15},worldRadius:{default:.3},intensity:{default:.05},causticsOnly:{type:Boolean,default:!1},lightSource:{default:{x:1,y:1,z:1}},resolution:{default:1024}},setup(e){const n=e,{renderer:r}=t(),o=Ke(r,{frames:1/0,resolution:n.resolution,worldRadius:n.worldRadius});o.params.backside=!0;const i=Ct(null);Rt(i,e=>{e&&o.scene.add(e)});const{onBeforeRender:l}=a();return l(({elapsed:e})=>{o.update()}),It(()=>{n.color&&o.params.color.set(n.color),n.ior&&(o.params.ior=n.ior),n.backsideIOR&&(o.params.backsideIOR=n.backsideIOR),n.far&&(o.params.far=n.far),n.worldRadius&&(o.params.worldRadius=n.worldRadius),n.intensity&&(o.params.intensity=n.intensity)}),Rt(()=>n.causticsOnly,e=>{o.params.causticsOnly=e}),Rt(()=>n.lightSource,e=>{e&&o.params.lightSource instanceof Et.Vector3&&o.params.lightSource.set(e.x,e.y,e.z)},{deep:!0}),(e,t)=>(wt(),Pt(Mt,null,[bt("TresGroup",{ref_key:"group",ref:i},[xt(e.$slots,"default")],512),bt("primitive",{object:St(o).group,position:[0,.003,0]},null,8,kt),bt("primitive",{object:St(o).helper,visible:!1},null,8,Tt)],64))}}),At=await e("three");const zt=({focus:e=0,size:t=25,samples:n=10}={})=>{const a=At.ShaderChunk.shadowmap_pars_fragment;return At.ShaderChunk.shadowmap_pars_fragment=At.ShaderChunk.shadowmap_pars_fragment.replace("#ifdef USE_SHADOWMAP",`#ifdef USE_SHADOWMAP\n\n    #define PENUMBRA_FILTER_SIZE float(${t})\n    #define RGB_NOISE_FUNCTION(uv) (randRGB(uv))\n    vec3 randRGB(vec2 uv) {\n      return vec3(\n        fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),\n        fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),\n        fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)\n      );\n    }\n    \n    vec3 lowPassRandRGB(vec2 uv) {\n      // 3x3 convolution (average)\n      // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9\n      vec3 result = vec3(0);\n      result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));\n      result *= 0.111111111; // 1.0 / 9.0\n      return result;\n    }\n    vec3 highPassRandRGB(vec2 uv) {\n      // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal\n      // hp(x) = x - lp(x)\n      return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;\n    }\n    \n    \n    vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n      const float goldenAngle = 2.399963f; // radians\n      float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n      float theta = float(sampleIndex) * goldenAngle + angle;\n      float sine = sin(theta);\n      float cosine = cos(theta);\n      return vec2(cosine, sine) * r;\n    }\n    float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n      return (zReceiver - zBlocker) / zBlocker;\n    }\n    float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {\n      float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\n      float blockerDepthSum = float(${e});\n      float blockers = 0.0;\n    \n      int j = 0;\n      vec2 offset = vec2(0.);\n      float depth = 0.;\n    \n      #pragma unroll_loop_start\n      for(int i = 0; i < ${n}; i ++) {\n        offset = (vogelDiskSample(j, ${n}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;\n        depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));\n        if (depth < compare) {\n          blockerDepthSum += depth;\n          blockers++;\n        }\n        j++;\n      }\n      #pragma unroll_loop_end\n    \n      if (blockers > 0.0) {\n        return blockerDepthSum / blockers;\n      }\n      return -1.0;\n    }\n            \n    float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {\n      float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\n      float shadow = 0.0f;\n      int j = 0;\n      vec2 vogelSample = vec2(0.0);\n      vec2 offset = vec2(0.0);\n      #pragma unroll_loop_start\n      for (int i = 0; i < ${n}; i++) {\n        vogelSample = vogelDiskSample(j, ${n}, angle) * texelSize;\n        offset = vogelSample * (1.0 + filterRadius * float(${t}));\n        shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n        j++;\n      }\n      #pragma unroll_loop_end\n      return shadow * 1.0 / ${n}.0;\n    }\n    \n    float PCSS (sampler2D shadowMap, vec4 coords) {\n      vec2 uv = coords.xy;\n      float zReceiver = coords.z; // Assumed to be eye-space z in this code\n      float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;\n      float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);\n      if (avgBlockerDepth == -1.0) {\n        return 1.0;\n      }\n      float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n      return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);\n    }`).replace("#if defined( SHADOWMAP_TYPE_PCF )","\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )"),(e,t,n)=>{At.ShaderChunk.shadowmap_pars_fragment=a,function(e,t,n){t.traverse(t=>{t.material&&(Array.isArray(t.material)?t.material.forEach(t=>{e.properties.remove(t),t.dispose()}):(e.properties.remove(t.material),t.material.dispose()))}),e.info.programs.length=0,e.compile(t,n)}(e,t,n)}},{defineComponent:Ot}=await e("vue"),{watch:Bt}=await e("vue"),{Mesh:Ft}=await e("three"),jt=Ot({__name:"index",props:{enabled:{type:Boolean,default:!0},size:{default:25},focus:{default:0},samples:{default:10}},setup(e){const n=e,{camera:a,renderer:r,scene:o}=t();let i=null;const l=e=>{const{enabled:t,size:n,focus:l,samples:s}=e;i&&(i(r,o.value,a.value),i=null),t&&(i=zt({focus:l,size:n,samples:s}),o.value.traverse(e=>{e instanceof Ft&&e.material.dispose()}))};return l(n),Bt(n,()=>{l(n)}),(e,t)=>null}}),Nt=await e("three"),{HalfFloatType:Lt,WebGLCubeRenderTarget:Ut}=await e("three"),{onBeforeUnmount:Vt,ref:Ht,watch:Gt}=await e("vue");const{defineComponent:Wt}=await e("vue"),{unref:$t,createElementVNode:Kt,renderSlot:Yt,openBlock:qt,createElementBlock:Zt}=await e("vue"),Xt=["object"],{ref:Jt}=await e("vue"),Qt=Wt({__name:"index",props:{resolution:{default:256},near:{default:.1},far:{default:1e3},envMap:{default:null},fog:{default:null},frames:{default:1/0}},setup(e,{expose:n}){const r=e,{fbo:o,camera:i,update:l}=function({resolution:e=256,near:n=.1,far:a=1e3,envMap:r,fog:o}={}){const{renderer:i,scene:l}=t(),s=Ht(null),c=Ht(e),u=Ht(n),m=Ht(a),d=Ht(null);let f,p;return Gt(()=>c,e=>{s.value?.dispose(),s.value=new Ut(e.value),s.value.texture.type=Lt},{immediate:!0}),Gt([u,m,s],([e,t,n])=>{n&&(d.value=new Nt.CubeCamera(e,t,n))},{immediate:!0}),Vt(()=>{s.value?.dispose()}),{fbo:s,camera:d,update:()=>{f=l.value.fog,p=l.value.background,l.value.background=r||p,l.value.fog=o||f,d.value?.update(i,l.value),l.value.fog=f,l.value.background=p}}}({resolution:r.resolution,near:r.near,far:r.far,envMap:r.envMap,fog:r.fog}),{onBeforeRender:s}=a();let c=0;const u=Jt(null);return s(()=>{u.value&&(r.frames===1/0||c<r.frames)&&(u.value.visible=!1,l(),u.value.visible=!0,c++)}),n({texture:o.value?.texture}),(e,t)=>(qt(),Zt("TresGroup",null,[Kt("primitive",{object:$t(i)},null,8,Xt),Kt("TresGroup",{ref_key:"rgRef",ref:u},[Yt(e.$slots,"default")],512)]))}}),en=await e("three");function tn(e,t,n,a){const r=class extends en.ShaderMaterial{constructor(r={}){const o=Object.entries(e);super({uniforms:o.reduce((e,[t,n])=>({...e,...en.UniformsUtils.clone({[t]:{value:n}})}),{}),vertexShader:t,fragmentShader:n}),this.key="",o.forEach(([e])=>Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:t=>this.uniforms[e].value=t})),Object.assign(this,r),a&&a(this)}};return r.key=en.MathUtils.generateUUID(),r}const nn=await e("three");function an(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var a=n.call(e,t);if("object"!=typeof a)return a;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e,"string");return"symbol"==typeof t?t:String(t)}function rn(e,t,n){return(t=an(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function on(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,a)}return n}function ln(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?on(Object(n),!0).forEach(function(t){rn(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):on(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function sn(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}function cn(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,a=new Array(t);n<t;n++)a[n]=e[n];return a}function un(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=n){var a,r,o,i,l=[],s=!0,c=!1;try{if(o=(n=n.call(e)).next,0===t);else for(;!(s=(a=o.call(n)).done)&&(l.push(a.value),l.length!==t);s=!0);}catch(u){c=!0,r=u}finally{try{if(!s&&null!=n.return&&(i=n.return(),Object(i)!==i))return}finally{if(c)throw r}}return l}}(e,t)||function(e,t){if(e){if("string"==typeof e)return cn(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?cn(e,t):void 0}}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function mn(e,t,n){return t&&function(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,an(a.key),a)}}(e.prototype,t),Object.defineProperty(e,"prototype",{writable:!1}),e}function dn(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function fn(e,t){return fn=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},fn(e,t)}function pn(e){return pn=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},pn(e)}function vn(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(e){return!1}}();return function(){var n,a=pn(e);if(t){var r=pn(this).constructor;n=Reflect.construct(a,arguments,r)}else n=a.apply(this,arguments);return function(e,t){if(t&&("object"==typeof t||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return dn(e)}(this,n)}}var hn,gn,yn,_n="csm_DiffuseColor",xn="csm_Normal",bn="csm_Roughness",Sn="csm_Metalness",Mn="csm_Emissive",wn="csm_AO",Pn="csm_Bump",kn="csm_Clearcoat",Tn="csm_ClearcoatRoughness",Cn="csm_ClearcoatNormal",Rn="csm_PointSize",In="csm_FragColor",En="csm_DepthAlpha",Dn="csm_Position",An="csm_PositionRaw",zn=(rn(hn={},"".concat(Dn),"*"),rn(hn,"".concat(An),"*"),rn(hn,"".concat(xn),"*"),rn(hn,"".concat(Rn),["PointsMaterial"]),rn(hn,"".concat(_n),"*"),rn(hn,"".concat(In),"*"),rn(hn,"".concat(Mn),["MeshStandardMaterial","MeshPhysicalMaterial"]),rn(hn,"".concat(bn),["MeshStandardMaterial","MeshPhysicalMaterial"]),rn(hn,"".concat(Sn),["MeshStandardMaterial","MeshPhysicalMaterial"]),rn(hn,"".concat(wn),["MeshStandardMaterial","MeshPhysicalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial"]),rn(hn,"".concat(Pn),["MeshLambertMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MeshToonMaterial","ShadowMaterial"]),rn(hn,"".concat(En),["MeshDepthMaterial"]),rn(hn,"".concat(kn),["MeshPhysicalMaterial"]),rn(hn,"".concat(Tn),["MeshPhysicalMaterial"]),rn(hn,"".concat(Cn),["MeshPhysicalMaterial"]),hn),On={"#include <lights_physical_fragment>":nn.ShaderChunk.lights_physical_fragment},Bn=(rn(gn={},"".concat(xn),{"#include <beginnormal_vertex>":"\n    vec3 objectNormal = ".concat(xn,";\n    #ifdef USE_TANGENT\n\t    vec3 objectTangent = vec3( tangent.xyz );\n    #endif\n    ")}),rn(gn,"".concat(Dn),{"#include <begin_vertex>":"\n    vec3 transformed = ".concat(Dn,";\n  ")}),rn(gn,"".concat(An),{"#include <begin_vertex>":"\n    vec4 csm_internal_positionUnprojected = ".concat(An,";\n    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;\n    #ifdef USE_INSTANCING\n      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;\n    #endif\n    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;\n    vec3 transformed = csm_internal_positionUnprojected.xyz;\n  ")}),rn(gn,"".concat(Rn),{"gl_PointSize = size;":"\n    gl_PointSize = ".concat(Rn,";\n    ")}),rn(gn,"".concat(_n),{"#include <color_fragment>":"\n    #include <color_fragment>\n    diffuseColor = ".concat(_n,";\n  ")}),rn(gn,"".concat(In),{"#include <dithering_fragment>":"\n    #include <dithering_fragment>\n    gl_FragColor  = ".concat(In,";\n  ")}),rn(gn,"".concat(Mn),{"vec3 totalEmissiveRadiance = emissive;":"\n    vec3 totalEmissiveRadiance = ".concat(Mn,";\n    ")}),rn(gn,"".concat(bn),{"#include <roughnessmap_fragment>":"\n    #include <roughnessmap_fragment>\n    roughnessFactor = ".concat(bn,";\n    ")}),rn(gn,"".concat(Sn),{"#include <metalnessmap_fragment>":"\n    #include <metalnessmap_fragment>\n    metalnessFactor = ".concat(Sn,";\n    ")}),rn(gn,"".concat(wn),{"#include <aomap_fragment>":"\n    #include <aomap_fragment>\n    reflectedLight.indirectDiffuse *= 1. - ".concat(wn,";\n    ")}),rn(gn,"".concat(Pn),{"#include <normal_fragment_maps>":"\n    #include <normal_fragment_maps>\n\n    vec3 csm_internal_orthogonal = ".concat(Pn," - (dot(").concat(Pn,", normal) * normal);\n    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;\n    normal = normalize(normal - csm_internal_projectedbump);\n    ")}),rn(gn,"".concat(En),{"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );":"\n      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * ".concat(En," );\n    "),"gl_FragColor = packDepthToRGBA( fragCoordZ );":"\n      gl_FragColor = packDepthToRGBA( fragCoordZ );\n      gl_FragColor.a *= ".concat(En,";\n    ")}),rn(gn,"".concat(kn),{"material.clearcoat = clearcoat;":"material.clearcoat = ".concat(kn,";")}),rn(gn,"".concat(Tn),{"material.clearcoatRoughness = clearcoatRoughness;":"material.clearcoatRoughness = ".concat(Tn,";")}),rn(gn,"".concat(Cn),{"#include <clearcoat_normal_fragment_begin>":"\n      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);\n      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;\n      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);\n    "}),gn),Fn=(rn(yn={},"".concat(Dn),{"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );":"\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( ".concat(Dn,", 1.0 );\n  ")}),rn(yn,"".concat(An),{"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );":"\n    gl_Position = ".concat(Dn,";\n  ")}),rn(yn,"".concat(_n),{"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );":"\n    gl_FragColor = ".concat(_n,";\n  ")}),rn(yn,"".concat(In),{"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );":"\n    gl_FragColor = ".concat(In,";\n  ")}),yn),jn={clearcoat:[kn,Cn,Tn]},Nn=["baseMaterial","fragmentShader","vertexShader","uniforms","patchMap","cacheKey","silent"],Ln=function(e,t,n){return e.split(t).join(n)},Un=function(e,t){return new RegExp("\\b".concat((n=t,n.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")),"\\b")).test(e);var n};function Vn(e){return e?e.replace(/\s/g,""):void 0}function Hn(e){return e.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm,"")}var Gn=function(){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&fn(e,t)}(t,nn.Material);var e=vn(t);function t(n){var a,r,o,i,l=n.baseMaterial,s=n.fragmentShader,c=n.vertexShader,u=n.uniforms,m=n.patchMap,d=n.cacheKey,f=n.silent,p=sn(n,Nn);if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),!function(e){try{new e}catch(t){if(t.message.indexOf("is not a constructor")>=0)return!1}return!0}(l)?(r=l,Object.assign(r,p)):r=new l(p),"RawShaderMaterial"===r.type)throw new Error("CustomShaderMaterial does not support RawShaderMaterial");(function(e,t){Object.assign(e,t);var n=Object.getPrototypeOf(t);Object.entries(Object.getOwnPropertyDescriptors(n)).filter(function(e){var t="function"==typeof e[1].get,n="function"==typeof e[1].set,a="function"==typeof e[1].value,r="constructor"===e[0];return(t||n||a)&&!r}).forEach(function(t){"function"!=typeof e[t[0]]&&Object.defineProperty(e,t[0],t[1])})})(dn(a=e.call(this)),r),a.__csm={patchMap:m||{},fragmentShader:s||"",vertexShader:c||"",cacheKey:d,baseMaterial:l,instanceID:nn.MathUtils.generateUUID(),type:r.type,isAlreadyExtended:(o=r.onBeforeCompile,i=o.toString().trim(),!(0===i.substring(i.indexOf("{")+1,i.lastIndexOf("}")).trim().length)),cacheHash:"",silent:f},a.uniforms=ln(ln({},a.uniforms||{}),u||{});var v=a.__csm,h=v.fragmentShader,g=v.vertexShader,y=a.uniforms;return a.__csm.cacheHash=a._getCacheHash(),a._generateMaterial(h,g,y),a}return mn(t,[{key:"update",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.uniforms=e.uniforms||this.uniforms,Object.assign(this.__csm,e);var t=this.__csm,n=t.fragmentShader,a=t.vertexShader,r=this.uniforms,o=this._getCacheHash();this.__csm.cacheHash=o,this._generateMaterial(n,a,r)}},{key:"clone",value:function(){var e={baseMaterial:this.__csm.baseMaterial,fragmentShader:this.__csm.fragmentShader,vertexShader:this.__csm.vertexShader,uniforms:this.uniforms,silent:this.__csm.silent,patchMap:this.__csm.patchMap,cacheKey:this.__csm.cacheKey},t=new this.constructor(e);return Object.assign(this,t),t}},{key:"_getCacheHash",value:function(){var e=this.__csm,t=e.fragmentShader,n=e.vertexShader,a=this.uniforms,o=[Vn(t),Vn(n),a].filter(function(e){return void 0!==e});return o.length>0?r(o,{excludeValues:!0}):this.customProgramCacheKey()}},{key:"_generateMaterial",value:function(e,t,n){var a=this;this.uniforms=n||{},this.customProgramCacheKey=function(){return a.__csm.cacheHash};var r=function(n){try{var r=a._getMaterialDefine();if(e){var o=a._patchShader(Hn(e),n.fragmentShader,!0);n.fragmentShader=r+o}if(t){var i=a._patchShader(Hn(t),n.vertexShader);n.vertexShader="#define IS_VERTEX;\n"+i,n.vertexShader=r+n.vertexShader}n.uniforms=ln(ln({},n.uniforms),a.uniforms),a.uniforms=n.uniforms}catch(l){console.error(l)}};if(this.__csm.isAlreadyExtended){var o=this.onBeforeCompile;this.onBeforeCompile=function(e,t){o(e,t),r(e)}}else this.onBeforeCompile=r;this.needsUpdate=!0}},{key:"_patchShader",value:function(e,t,n){var a=this,r=t,o=ln(ln({},this._getPatchMapForMaterial()),this.__csm.patchMap);Object.entries(jn).forEach(function(t){var n=un(t,2),r=n[0],o=n[1].find(function(t){return Un(e,t)});if(o&&!a[r])throw new Error('CSM: Property "'.concat(r,'" is required to use output "').concat(o,'". Shader cannot compile.'))}),Object.entries(On).forEach(function(e){var t=un(e,2),n=t[0],a=t[1];r=Ln(r,n,a)}),Object.keys(o).forEach(function(t){Object.keys(o[t]).forEach(function(n){var i=zn[t],l=a.__csm.type;if("*"===t||Un(e,t)){if(!(!i||Array.isArray(i)&&i.includes(l)||"*"===i))throw new Error("CSM: ".concat(t," is not available in ").concat(l,". Shader cannot compile."));r=Ln(r,n,o[t][n])}})});var i,l,s,c,u="csm_main_"+this.__csm.instanceID.replace(/-/g,"_"),m=e.replace(/void\s+main\s*\(\s*\)/g,"void ".concat(u,"()")),d=e.includes("void main()"),f=r.includes("// #_CSM_#");return d&&(f&&this.__csm.isAlreadyExtended?(r=r.replace("void main() {","\n            ".concat(m,"\n            \n            void main() {\n          ")),i=r,l="// #_CSM_#",s="\n            ".concat(u,"();\n            // #_CSM_#\n          "),c=i.lastIndexOf(l),r=-1===c?i:i.substring(0,c)+s+i.substring(c+l.length)):r=r.replace("void main() {","\n            #ifndef CSM_IS_HEAD_DEFAULTS_DEFINED\n              ".concat("\n    varying mat4 csm_internal_vModelViewMatrix;\n","\n              #define CSM_IS_HEAD_DEFAULTS_DEFINED 1\n            #endif\n    \n            ").concat("\n    \n#ifdef IS_VERTEX\n    vec3 csm_Position;\n    vec4 csm_PositionRaw;\n    vec3 csm_Normal;\n\n    // csm_PointSize\n    #ifdef IS_POINTSMATERIAL\n        float csm_PointSize;\n    #endif\n#else\n    vec4 csm_DiffuseColor;\n    vec4 csm_FragColor;\n\n    // csm_Emissive, csm_Roughness, csm_Metalness\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\n        vec3 csm_Emissive;\n        float csm_Roughness;\n        float csm_Metalness;\n        \n        #if defined IS_MESHPHYSICALMATERIAL\n            float csm_Clearcoat;\n            float csm_ClearcoatRoughness;\n            vec3 csm_ClearcoatNormal;\n        #endif\n    #endif\n\n    // csm_AO\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\n        float csm_AO;\n    #endif\n\n    // csm_Bump\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \n        vec3 csm_Bump;\n    #endif\n\n    float csm_DepthAlpha;\n#endif\n","\n    \n            ").concat(m,"\n            \n            void main() {\n              #ifndef CSM_IS_DEFAULTS_DEFINED\n                ").concat("\n\n#ifdef IS_VERTEX\n    // csm_Position & csm_PositionRaw\n    #ifdef IS_UNKNOWN\n        csm_Position = vec3(0.0);\n        csm_PositionRaw = vec4(0.0);\n        csm_Normal = vec3(0.0);\n    #else\n        csm_Position = position;\n        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n        csm_Normal = normal;\n    #endif\n\n    // csm_PointSize\n    #ifdef IS_POINTSMATERIAL\n        csm_PointSize = size;\n    #endif\n#else\n    // csm_DiffuseColor & csm_FragColor\n    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL\n        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\n        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n    #else\n        #ifdef USE_MAP\n            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);\n\n            #ifdef DECODE_VIDEO_TEXTURE\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\n            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);\n            #endif\n\n            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\n            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\n        #else\n            csm_DiffuseColor = vec4(diffuse, opacity);\n            csm_FragColor = vec4(diffuse, opacity);\n        #endif\n    #endif\n\n    // csm_Emissive, csm_Roughness, csm_Metalness\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\n        csm_Emissive = emissive;\n        csm_Roughness = roughness;\n        csm_Metalness = metalness;\n\n        #if defined IS_MESHPHYSICALMATERIAL\n            #ifdef USE_CLEARCOAT\n                csm_Clearcoat = clearcoat;\n                csm_ClearcoatRoughness = clearcoatRoughness;\n            #else\n                csm_Clearcoat = 0.0;\n                csm_ClearcoatRoughness = 0.0;\n            #endif\n        #endif\n    #endif\n\n    // csm_AO\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\n        csm_AO = 0.0;\n    #endif\n\n    // csm_Bump\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \n        csm_Bump = vec3(0.0);\n    #endif\n\n    csm_DepthAlpha = 1.0;\n#endif\n","\n                #define CSM_IS_DEFAULTS_DEFINED 1\n              #endif\n              \n              #ifndef CSM_IS_MAIN_DEFAULTS_DEFINED\n                ").concat(n?"\n    \n":"\n    csm_internal_vModelViewMatrix = modelViewMatrix;\n","\n                #define CSM_IS_MAIN_DEFAULTS_DEFINED 1\n              #endif\n  \n              ").concat(u,"();\n              // #_CSM_#\n          "))),r}},{key:"_getMaterialDefine",value:function(){var e=this.__csm.type;return e?"#define IS_".concat(e.toUpperCase(),";\n"):"#define IS_UNKNOWN;\n"}},{key:"_getPatchMapForMaterial",value:function(){return"ShaderMaterial"===this.__csm.type?Fn:Bn}}]),t}();const{defineComponent:Wn}=await e("vue"),{unref:$n,openBlock:Kn,createElementBlock:Yn}=await e("vue"),qn=["object"],Zn=await e("three"),{watchEffect:Xn}=await e("vue"),Jn=Wn({__name:"index",props:{color:{default:"#ff00fc"},metalness:{default:1},roughness:{default:1},clearcoat:{default:1},clearcoatRoughness:{default:0}},setup(e){const t=e,n={baseMaterial:Zn.MeshPhysicalMaterial,metalness:t.metalness,roughness:t.roughness,clearcoat:t.clearcoat,clearcoatRoughness:t.clearcoatRoughness,color:t.color,vertexShader:"\n\t\t\tvarying vec3 csm_vPosition;\n\t\t\tvarying vec3 csm_vWorldNormal;\n\t\t\tvarying vec3 csm_vWorldViewDirection;\n\t\t\tvarying vec4 csm_vGlPosition;\n\n\t\t\tvoid main() {\n\t\t\t\t\tcsm_vWorldNormal = normalize((modelMatrix * vec4(normal.xyz, 0.0)).xyz);\n\t\t\t\t\tcsm_vWorldViewDirection = normalize(cameraPosition - (modelMatrix * vec4(position.xyz, 0.0)).xyz) ;\n\n\t\t\t\t\tcsm_vGlPosition = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t\t\t\t\tcsm_vPosition = position;\n\t\t\t}",fragmentShader:"\n\t\t\tconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv) {\n  uv *= myt;\n  uv *= mys;\n  return fract(fract(uv / mys) * uv);\n}\n\nvec3 hash(vec3 p) {\n  return fract(\n      sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),\n               dot(p, vec3(113.0, 1.0, 57.0)))) *\n      43758.5453);\n}\n\nfloat mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 perm(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\nfloat floatHash(vec3 p) {\n  vec3 a = floor(p);\n  vec3 d = p - a;\n  d = d * d * (3.0 - 2.0 * d);\n\n  vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n  vec4 k1 = perm(b.xyxy);\n  vec4 k2 = perm(k1.xyxy + b.zzww);\n\n  vec4 c = k2 + a.zzzz;\n  vec4 k3 = perm(c);\n  vec4 k4 = perm(c + 1.0);\n\n  vec4 o1 = fract(k3 * (1.0 / 41.0));\n  vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n  vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n  vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n  return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvec2 voronoi3d(vec3 pos) {\n  vec3 baseCell = floor(pos);\n\n  float minDistToCell = 10.0;\n  vec3 closestCell;\n  for (int x = -1; x <= 1; x++) {\n    for (int y = -1; y <= 1; y++) {\n      for (int z = -1; z <= 1; z++) {\n        vec3 cell = baseCell + vec3(float(x), float(y), float(z));\n        vec3 cellPosition = cell + hash(cell);\n        vec3 toCell = cellPosition - pos;\n        float distToCell = length(toCell);\n        if (distToCell < minDistToCell) {\n          minDistToCell = distToCell;\n          closestCell = cell;\n        }\n      }\n    }\n  }\n\n  float random = floatHash(closestCell);\n  return vec2(minDistToCell, random);\n}\n      vec4 permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n\nfloat pnoise(vec3 P) {\n  vec3 Pi0 = floor(P);        \n  vec3 Pi1 = Pi0 + vec3(1.0); \n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P);        \n  vec3 Pf1 = Pf0 - vec3(1.0); \n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(\n      vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(\n      vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111),\n                 fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\t\t\tvarying vec3 csm_vPosition;\n\t\t\tvarying vec3 csm_vWorldNormal;\n\t\t\tvarying vec3 csm_vWorldViewDirection;\n\t\t\tvarying vec4 csm_vGlPosition;\n\n      uniform vec3 uFleckColor;\n\n      const float fresnel_Power = 1.0;\n\n      float fresnel() {\n          return pow(1.0 - dot(csm_vWorldNormal, csm_vWorldViewDirection), fresnel_Power);\n      }\n\n      float mapLinear(float x, float a1, float a2, float b1, float b2) {\n          return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n      }\n\n      void main() {\n      // Fresnel\n      float fresnelFactor = fresnel();\n\n      // Fleck\n      float fleckFactor = voronoi3d(csm_vPosition * 2000.0).y;\n      float fleckFactorY = voronoi3d(csm_vPosition * 2000.0 + 100.0).y;\n      float fleckFactorZ = voronoi3d(csm_vPosition * 2000.0 + 200.0).y;\n\n      // Distance from camera\n      float normalizedDist = csm_vGlPosition.z / csm_vGlPosition.w;\n      normalizedDist = smoothstep(0.6, 1.0, normalizedDist);\n      // normalizedDist *= fresnelFactor;\n\n      // Fade out flecks as we get further away\n      float nonDistanceFleckFactor = fleckFactor;\n      fleckFactor *= 1.0 - normalizedDist;\n\n      // Diffuse\n      float diffuseFactor = csm_DiffuseColor.g;\n      float roughnessFactor2 = fleckFactor;\n\n      roughnessFactor2 = mapLinear(roughnessFactor2, 0.0, 1.0, 0.4, 0.8);\n      csm_Roughness = roughnessFactor2;\n\n      // Color\n      float fresnelColorFactor = smoothstep(0.0, 1.0, clamp(fresnelFactor, 0.0, 0.4));\n      vec3 fresnelColor = mix(csm_DiffuseColor.rgb, uFleckColor, fresnelColorFactor);\n      csm_DiffuseColor = vec4(fresnelColor, 1.0);\n\n      float fleckColorFactor = smoothstep(0.99, 0.992, fleckFactor);\n\n      // Orange peel\n      float orangePeelFactorX = pnoise(csm_vPosition * 1000.0);\n      float orangePeelFactorY = pnoise(csm_vPosition * 1000.0 + 100.0);\n      float orangePeelFactorZ = pnoise(csm_vPosition * 1000.0 + 200.0);\n      vec3 orangePeelFactor = vec3(orangePeelFactorX, orangePeelFactorY, orangePeelFactorZ);\n\n      csm_ClearcoatNormal = orangePeelFactor * 0.01 * (1.0 - normalizedDist);\n      // csm_Clearcoat = 10.0;\n      // csm_ClearcoatRoughness = 0.0;\n\n      csm_Bump = vec3(fleckFactor, fleckFactorY, fleckFactorZ) * 1.0 * (1.0 - normalizedDist);\n      }\n\t\t"},a=new Gn(n);return Xn(()=>{a.color.setStyle(t.color),a.metalness=t.metalness,a.roughness=t.roughness,a.clearcoat=t.clearcoat,a.clearcoatRoughness=t.clearcoatRoughness}),(e,t)=>(Kn(),Yn("primitive",{object:$n(a)},null,8,qn))}}),{watch:Qn}=await e("vue");async function ea(e){const t=e.split("/").pop();S.getResource("TextureLoader",e,t);const n=S.getReactiveItem(t);return new Promise((e,t)=>{const a=n();if(a)return void e(a);const r=Qn(()=>n(),n=>{n?(r(),e(n)):t(new Error("useTexture åŠ è½½å¤±è´¥ï¼Œæœªå¾—åˆ°æ¨¡åž‹"))})})}async function ta(e,t,n,a,r){const o=new e;return r&&r(o),n&&n(o),await new Promise((e,n)=>{o.load(t,t=>{const n=t;n.scene&&Object.assign(n,function(e){const t={nodes:{},materials:{}};return e&&e.traverse(e=>{e.name&&(t.nodes[e.name]=e),e.material&&!t.materials[e.material.name]&&(t.materials[e.material.name]=e.material)}),t}(n.scene)),e(n)},a,e=>{n(e)})})}const{TextureLoader:na}=await e("three"),aa=Array.isArray;async function ra(e,t){const n=new na(t),a=e=>new Promise((t,a)=>{n.load(e,e=>t(e),()=>null,()=>{a(new Error("[useTextures] - Failed to load texture"))})});if(aa(e)){const t=await Promise.all(e.map(e=>a(e)));return e.length>1?t:t[0]}{const{map:t,displacementMap:n,normalMap:r,roughnessMap:o,metalnessMap:i,aoMap:l,alphaMap:s,matcap:c}=e;return{map:t?await a(t):null,displacementMap:n?await a(n):null,normalMap:r?await a(r):null,roughnessMap:o?await a(o):null,metalnessMap:i?await a(i):null,aoMap:l?await a(l):null,alphaMap:s?await a(s):null,matcap:c?await a(c):null}}}const{FrontSide:oa,BackSide:ia,DoubleSide:la,NormalBlending:sa,AdditiveBlending:ca,SubtractiveBlending:ua,MultiplyBlending:ma,NoBlending:da}=await e("three"),fa=[{label:"FrontSide",value:oa},{label:"BackSide",value:ia},{label:"DoubleSide",value:la}],pa=[{label:"NoBlending",value:da},{label:"NormalBlending",value:sa},{label:"AdditiveBlending",value:ca},{label:"SubtractiveBlending",value:ua},{label:"MultiplyBlending",value:ma}],va={color:"#ffffff",map:null,wireframe:!1,opacity:1,transparent:!1,side:oa,alphaTest:0,blending:sa,depthTest:!0,depthWrite:!0},ha={emissive:"#000000",emissiveIntensity:1,metalness:.5,roughness:.5,metalnessMap:null,roughnessMap:null,normalMap:null,normalScale:{x:1,y:1},bumpMap:null,bumpScale:1,displacementMap:null,displacementScale:1,displacementBias:0,aoMap:null,aoMapIntensity:1,envMap:null,envMapIntensity:1},ga={...ha,clearcoat:.2,clearcoatRoughness:.1,reflectivity:.5,transmission:0,ior:1.5,thickness:.01,attenuationColor:"#ffffff",attenuationDistance:0,specularIntensity:1,specularColor:"#ffffff",sheen:0,sheenColor:"#ffffff",clearcoatNormalMap:null,clearcoatNormalScale:{x:1,y:1}},ya={MeshBasicMaterial:{component:"TresMeshBasicMaterial",props:{...va}},MeshLambertMaterial:{component:"TresMeshLambertMaterial",props:{...va,emissive:"#000000",emissiveIntensity:1,emissiveMap:null,reflectivity:1,refractionRatio:.98}},MeshPhongMaterial:{component:"TresMeshPhongMaterial",props:{...va,emissive:"#000000",emissiveIntensity:1,specular:"#111111",shininess:30,specularMap:null,emissiveMap:null,bumpMap:null,bumpScale:1,normalMap:null,normalScale:{x:1,y:1},displacementMap:null,displacementScale:1,displacementBias:0}},MeshStandardMaterial:{component:"TresMeshStandardMaterial",props:{...va,...ha}},MeshPhysicalMaterial:{component:"TresMeshPhysicalMaterial",props:{...va,...ga}},MeshToonMaterial:{component:"TresMeshToonMaterial",props:{...va,gradientMap:null,bumpMap:null,bumpScale:1,normalMap:null,normalScale:{x:1,y:1}}},MeshGlassMaterial:{component:async()=>(await o(()=>import("./index.B2-FHinZ1769412424343.js").then(e=>e.trescientos),__vite__mapDeps([0,1,2,3]),import.meta.url)).MeshGlassMaterial,props:{...va,metalness:.5,roughness:0}},TransmissionMaterial:{component:async()=>(await o(()=>import("./index.BM1quI7G1769412424343.js"),__vite__mapDeps([4,5,1,0,2,3,6,7,8,9,10,11]),import.meta.url)).TransmissionMaterial,props:{color:"#ffffff",roughness:0,reflectivity:.5,attenuationColor:"#ffffff",attenuationDistance:2,chromaticAberration:.05,anisotropicBlur:.1,distortion:0,temporalDistortion:0,backside:!0,thickness:1,backsideThickness:.5}},ClearcoatMaterial:{component:async()=>(await o(()=>import("./index.BM1quI7G1769412424343.js"),__vite__mapDeps([4,5,1,0,2,3,6,7,8,9,10,11]),import.meta.url)).ClearcoatMaterial,props:{color:"#ff00fc",metalness:1,roughness:1,clearcoat:1,clearcoatRoughness:0}},dissolveEffectMaterial:{component:async()=>(await o(()=>import("./index.vWHhfcZY1769412424343.js"),__vite__mapDeps([12,13,1,0,2,3,14,15,16,17,18,19]),import.meta.url)).dissolveEffectMaterial,props:{color:"#B520A9",uEdgeColor:"#4d9bff",uEdge:6,uFreq:.41,uAmp:20,uProgress:-1,metalness:1,roughness:1}}},{markRaw:_a}=await e("vue");const{defineComponent:xa}=await e("vue"),{resolveDynamicComponent:ba,mergeProps:Sa,openBlock:Ma,createBlock:wa}=await e("vue"),{ref:Pa,watch:ka}=await e("vue"),Ta=xa({__name:"index",props:{type:{},materialProps:{}},setup(e){const t=e,n=Pa(null),a=Pa({}),r=Pa(null);let o=!1;return ka(()=>t.type,async e=>{if(r.value)try{r.value.dispose?.(),console.log("å·²é‡Šæ”¾æ—§æè´¨ç»„ä»¶")}catch(l){console.warn("é‡Šæ”¾æè´¨ç»„ä»¶å¤±è´¥:",l)}var i;o=!1,n.value=await async function(e){let t=ya[e].component;return"function"==typeof t&&(t=_a(await t())),t}(e),o=!0,a.value={...(i=e,ya[i].props),...t.materialProps}},{immediate:!0}),ka(()=>[t.type,t.materialProps],([e,t],[n])=>{e===n&&o&&(a.value=t)},{deep:!0}),(e,t)=>(Ma(),wa(ba(n.value),Sa(a.value,{ref_key:"materialRef",ref:r}),null,16))}}),Ca={Box:{params:[{key:"width",label:"width",type:"number",default:1},{key:"height",label:"height",type:"number",default:1},{key:"depth",label:"depth",type:"number",default:1},{key:"widthSegments",label:"widthSegments",type:"number",default:1,min:1,max:6,step:1},{key:"heightSegments",label:"heightSegments",type:"number",default:1,min:1,max:6,step:1},{key:"depthSegments",label:"depthSegments",type:"number",default:1,min:1,max:6,step:1}]},Circle:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"segments",label:"segments",type:"number",default:32,min:3,max:64,step:1},{key:"thetaStart",label:"thetaStart",type:"number",default:0,min:0,max:2*Math.PI,step:.01},{key:"thetaLength",label:"thetaLength",type:"number",default:2*Math.PI,min:.1,max:2*Math.PI,step:.01}]},Cone:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"height",label:"height",type:"number",default:2,min:0},{key:"radialSegments",label:"radialSegments",type:"number",default:8,min:3,max:64,step:1},{key:"heightSegments",label:"heightSegments",type:"number",default:1,min:1,max:32,step:1},{key:"openEnded",label:"openEnded",type:"boolean",default:!1},{key:"thetaStart",label:"thetaStart",type:"number",default:0,min:0,max:2*Math.PI,step:.01},{key:"thetaLength",label:"thetaLength",type:"number",default:2*Math.PI,min:.1,max:2*Math.PI,step:.01}]},Cylinder:{params:[{key:"radiusTop",label:"radiusTop",type:"number",default:1,min:0},{key:"radiusBottom",label:"radiusBottom",type:"number",default:1,min:0},{key:"height",label:"height",type:"number",default:2,min:0},{key:"radialSegments",label:"radialSegments",type:"number",default:8,min:3,max:64,step:1},{key:"heightSegments",label:"heightSegments",type:"number",default:1,min:1,max:32,step:1},{key:"openEnded",label:"openEnded",type:"boolean",default:!1},{key:"thetaStart",label:"thetaStart",type:"number",default:0,min:0,max:2*Math.PI,step:.01},{key:"thetaLength",label:"thetaLength",type:"number",default:2*Math.PI,min:.1,max:2*Math.PI,step:.01}]},Dodecahedron:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"detail",label:"detail",type:"number",default:0,min:0,max:5,step:1}]},Icosahedron:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"detail",label:"detail",type:"number",default:0,min:0,max:5,step:1}]},Octahedron:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"detail",label:"detail",type:"number",default:0,min:0,max:5,step:1}]},Plane:{params:[{key:"width",label:"width",type:"number",default:1,min:0},{key:"height",label:"height",type:"number",default:1,min:0},{key:"widthSegments",label:"widthSegments",type:"number",default:1,min:1,max:64,step:1},{key:"heightSegments",label:"heightSegments",type:"number",default:1,min:1,max:64,step:1}]},Ring:{params:[{key:"innerRadius",label:"innerRadius",type:"number",default:.5,min:0},{key:"outerRadius",label:"outerRadius",type:"number",default:1,min:0},{key:"thetaSegments",label:"thetaSegments",type:"number",default:8,min:3,max:64,step:1},{key:"phiSegments",label:"phiSegments",type:"number",default:1,min:1,max:16,step:1},{key:"thetaStart",label:"thetaStart",type:"number",default:0,min:0,max:2*Math.PI,step:.01},{key:"thetaLength",label:"thetaLength",type:"number",default:2*Math.PI,min:.1,max:2*Math.PI,step:.01}]},RoundedBox:{params:[{key:"width",label:"width",type:"number",default:1,min:0},{key:"height",label:"height",type:"number",default:1,min:0},{key:"depth",label:"depth",type:"number",default:1,min:0},{key:"segments",label:"segments",type:"number",default:2,min:0,max:8,step:.1},{key:"radius",label:"radius",type:"number",default:.1,min:0,max:1,step:.01}]},Sphere:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"widthSegments",label:"widthSegments",type:"number",default:32,min:3,max:128,step:1},{key:"heightSegments",label:"heightSegments",type:"number",default:16,min:2,max:128,step:1},{key:"phiStart",label:"phiStart",type:"number",default:0,min:0,max:2*Math.PI,step:.01},{key:"phiLength",label:"phiLength",type:"number",default:2*Math.PI,min:.1,max:2*Math.PI,step:.01},{key:"thetaStart",label:"thetaStart",type:"number",default:0,min:0,max:Math.PI,step:.01},{key:"thetaLength",label:"thetaLength",type:"number",default:Math.PI,min:.1,max:Math.PI,step:.01}]},Tetrahedron:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"detail",label:"detail",type:"number",default:0,min:0,max:5,step:1}]},Torus:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"tube",label:"tube",type:"number",default:.4,min:0},{key:"radialSegments",label:"radialSegments",type:"number",default:8,min:3,max:64,step:1},{key:"tubularSegments",label:"tubularSegments",type:"number",default:64,min:3,max:256,step:1},{key:"arc",label:"arc",type:"number",default:2*Math.PI,min:.1,max:2*Math.PI,step:.01}]},TorusKnot:{params:[{key:"radius",label:"radius",type:"number",default:1,min:0},{key:"tube",label:"tube",type:"number",default:.4,min:0},{key:"tubularSegments",label:"tubularSegments",type:"number",default:64,min:3,max:256,step:1},{key:"radialSegments",label:"radialSegments",type:"number",default:8,min:3,max:128,step:1},{key:"p",label:"p",type:"number",default:2,min:1,max:10,step:.1},{key:"q",label:"q",type:"number",default:3,min:1,max:10,step:.1}]}},{defineComponent:Ra}=await e("vue"),{unref:Ia,createVNode:Ea,renderList:Da,Fragment:Aa,openBlock:za,createElementBlock:Oa,mergeProps:Ba,createBlock:Fa,createCommentVNode:ja,withCtx:Na}=await e("vue"),La={class:"shape-configurator"},{ref:Ua,reactive:Va,computed:Ha,watch:Ga}=await e("vue"),Wa=Ra({__name:"shapeConfigurator",props:{modelValue:{}},emits:["update:modelValue"],setup(e,{emit:t}){const n=e,a=t,r=Object.keys(Ca).map(e=>({label:e,value:e})),o=Ua(n.modelValue?.type??"Box"),i=Ha(()=>Ca[o.value]),l=Va({});function s(e=!0){const t=i.value;if(t)for(const a of t.params)if(l[a.key]=a.default,e&&n.modelValue&&n.modelValue.args){const e=t.params.findIndex(e=>e.key===a.key);-1!==e&&void 0!==n.modelValue.args[e]&&(l[a.key]=n.modelValue.args[e])}}const c=Ha(()=>{const e=i.value;return e?e.params.map(e=>l[e.key]):[]});function u(e){return"number"!==e.type?{}:{min:e.min??.1,max:e.max??5,step:e.step??.1}}return Ga(()=>({type:o.value,args:c.value}),e=>a("update:modelValue",e),{deep:!0,immediate:!0}),s(),(e,t)=>(za(),Oa("div",La,[Ea(Ia(M),null,{default:Na(()=>[Ea(Ia(w),{vertical:"",size:"small"},{default:Na(()=>[Ea(Ia(P),{value:o.value,"onUpdate:value":[t[0]||(t[0]=e=>o.value=e),t[1]||(t[1]=e=>s(!1))],options:Ia(r),placeholder:"é€‰æ‹©å›¾å½¢ç±»åž‹"},null,8,["value","options"]),i.value?(za(),Fa(Ia(C),{key:0,size:"small","label-placement":"left","label-width":100},{default:Na(()=>[(za(!0),Oa(Aa,null,Da(i.value.params,e=>(za(),Oa("div",{key:e.key,style:{"margin-bottom":"12px"}},[Ea(Ia(R),{label:e.label},{default:Na(()=>["number"===e.type?(za(),Fa(Ia(k),Ba({key:0,size:"tiny",value:l[e.key],"onUpdate:value":t=>l[e.key]=t},{ref_for:!0},u(e),{style:{width:"100%"}}),null,16,["value","onUpdate:value"])):"boolean"===e.type?(za(),Fa(Ia(T),{key:1,size:"small",value:l[e.key],"onUpdate:value":t=>l[e.key]=t},null,8,["value","onUpdate:value"])):ja("",!0)]),_:2},1032,["label"])]))),128))]),_:1})):ja("",!0)]),_:1})]),_:1})]))}}),{defineComponent:$a}=await e("vue"),{renderSlot:Ka,resolveDynamicComponent:Ya,withCtx:qa,openBlock:Za,createBlock:Xa,createCommentVNode:Ja}=await e("vue"),{computed:Qa}=await e("vue"),er=$a({__name:"shapeRenderer",props:{modelValue:{}},setup(e){const t={Box:_,Circle:y,Cone:g,Cylinder:h,Dodecahedron:v,Icosahedron:p,Octahedron:f,Plane:d,Ring:m,RoundedBox:u,Sphere:c,Tetrahedron:s,Torus:l,TorusKnot:i},n=e,a=Qa(()=>t[n.modelValue?.type]??null);return(e,t)=>a.value?(Za(),Xa(Ya(a.value),{key:0,args:e.modelValue.args},{default:qa(()=>[Ka(e.$slots,"default")]),_:3},8,["args"])):Ja("",!0)}}),{defineComponent:tr}=await e("vue"),{unref:nr,createVNode:ar,withCtx:rr,openBlock:or,createBlock:ir}=await e("vue"),lr=tr({__name:"forEditor",props:{shape:{default:{type:"Box",args:[2,1,1]}},materialType:{type:String,default:"MeshStandardMaterial"},materialProps:{type:Object,required:!0}},setup:e=>(t,n)=>(or(),ir(nr(er),{position:[0,.5,0],modelValue:e.shape},{default:rr(()=>[ar(nr(Ta),{type:e.materialType,"material-props":e.materialProps},null,8,["type","material-props"])]),_:1},8,["modelValue"]))}),{defineComponent:sr}=await e("vue"),{openBlock:cr,createElementBlock:ur}=await e("vue"),mr=["object"],{shallowRef:dr,watch:fr,useAttrs:pr}=await e("vue"),vr=await e("three"),hr=sr({__name:"customShaderMaterial",props:{baseMaterial:{},vertexShader:{},fragmentShader:{},uniforms:{}},setup(e){const t=pr(),n=e,a=dr(null);return fr(()=>n.baseMaterial,e=>{a.value&&a.value.dispose(),a.value=new I({baseMaterial:vr[e],vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,uniforms:n.uniforms})},{immediate:!0}),fr(()=>({...t}),e=>{const t=a.value;t&&Object.keys(e).forEach(n=>{if(!(n in t))return;const a=e[n];!0===a&&"boolean"!=typeof t[n]||t[n]!==a&&(t[n]=a,t.needsUpdate=!0)})},{immediate:!0,deep:!1}),(e,t)=>(cr(),ur("primitive",{object:a.value},null,8,mr))}});export{tn as CientosShaderMaterial,Ye as MeshDiscardMaterial,Ze as MeshTransmissionMaterial,le as _sfc_main,we as _sfc_main$1,lr as _sfc_main$10,hr as _sfc_main$11,Wa as _sfc_main$12,lt as _sfc_main$2,yt as _sfc_main$3,Dt as _sfc_main$4,jt as _sfc_main$5,Qt as _sfc_main$6,Jn as _sfc_main$7,Ta as _sfc_main$8,er as _sfc_main$9,pa as blendingOptions,ya as materialPresets,fa as sideOptions,je as useFBO,ta as useLoader,ea as useTexture,ra as useTexture$1};
