import{_ as n}from"./@tresjs.BCHtwiaC1763540743861.js";import{A as a,f as e,b8 as o,ae as s}from"./three.rXKzP9fQ1763540743861.js";import{a as t}from"./argestCircle.EZRfPXY41763540743861.js";import{d as r,H as l,o as f,J as m,ac as i,ao as c}from"./@vue.Co_gxueH1763540743861.js";const g=["rotation-y"],u=r({__name:"background2",setup(r){const u={uniforms:{uTime:{type:"f",value:0},R:{type:e,value:new e(800,350)},iMouse:{value:new a(0,0,0,0)}},vertexShader:t,fragmentShader:"#define SCALE 8.0\n\n#define PI radians(180.0)\n#define TAU (PI*2.0)\n#define CS(a) vec2(cos(a), sin(a))\n#define PT(u,r) smoothstep(0.0, r, r-length(u))\n\n#define FAR 60.\nvarying vec2 vUv;\nuniform float uTime;\nuniform vec2 R;\nuniform vec4 iMouse;\n\nvec3 gm(vec3 c, float n, float t, float w, float d, bool i)\n{\n    float g = min(abs(n), 1.0/abs(n));\n    float s = abs(sin(n*PI-t));\n    if (i) s = min(s, abs(sin(PI/n+t)));\n    return (1.0-pow(abs(s), w))*c*pow(g, d)*6.0;\n}\n\nfloat ds(vec2 u, float e, float n, float w, float h, float ro)\n{\n    float ur = length(u); \n    float sr = pow(ur, e); \n    float a = round(sr)*n*TAU; \n    vec2 xy = CS(a+ro)*ur; \n    float l = PT(u-xy, w); \n    float s = mod(sr+0.5, 1.0); \n    s = min(s, 1.0-s); \n    return l*s*h;\n}\n\nvoid main(){\n\n    float t = uTime/PI*2.0;\n   vec4 m = iMouse; m.xy = m.xy*2.0/R-1.0; \n    if (m.z > 0.0) t += m.y*SCALE; \n    float z = (m.z > 0.0) ? pow(1.0-abs(m.y), sign(m.y)): 1.0; \n    float e = (m.z > 0.0) ? pow(1.0-abs(m.x), -sign(m.x)): 1.0; \n    float se = (m.z > 0.0) ? e*-sign(m.y): 1.0; \n    vec3 bg = vec3(0); \n  \n    \n    float aa = 3.0; \n    for (float j = 0.0; j < aa; j++)\n    for (float k = 0.0; k < aa; k++)\n    {\n        vec3 c = vec3(0);\n        vec2 o = vec2(j, k)/aa;\n        vec2 uv = ((vUv-0.5)*R+o)/R.y*SCALE*z; \n        if (m.z > 0.0) uv = exp(log(abs(uv))*e)*sign(uv); \n\n        float px = length(fwidth(uv)); \n        float x = uv.x; \n        float y = uv.y; \n        float l = length(uv); \n\n        float mc = (x*x+y*y-1.0)/y; \n        float g = min(abs(mc), 1.0/abs(mc)); \n        vec3 gold = vec3(1.0, 0.6, 0.0)*g*l;\n        vec3 blue = vec3(0.3, 0.5, 0.9)*(1.0-g);\n        vec3 rgb = max(gold, blue);\n\n        float w = 0.1; \n        float d = 0.4; \n        c = max(c, gm(rgb, mc, -t, w, d, false)); \n        c = max(c, gm(rgb, abs(y/x)*sign(y), -t, w, d, false)); \n        c = max(c, gm(rgb, (x*x)/(y*y)*sign(y), -t, w, d, false)); \n        c = max(c, gm(rgb, (x*x)+(y*y), t, w, d, true)); \n\n        c += rgb*ds(uv, se, t/TAU, px*2.0, 2.0, 0.0); \n        c += rgb*ds(uv, se, t/TAU, px*2.0, 2.0, PI); \n        c += rgb*ds(uv, -se, t/TAU, px*2.0, 2.0, 0.0); \n        c += rgb*ds(uv, -se, t/TAU, px*2.0, 2.0, PI); \n        c = max(c, 0.0); \n\n        c += pow(max(1.0-l, 0.0), 3.0/z); \n\n        if (m.z > 0.0) \n        {\n            vec2 xyg = abs(fract(uv+0.5)-0.5)/px; \n            c.gb += 0.2*(1.0-min(min(xyg.x, xyg.y), 1.0));\n        }\n        bg += c;\n    }\n    bg /= aa*aa;\n    bg *= sqrt(bg)*1.5;\n    \n    gl_FragColor = vec4(bg, 1.0);\n}",side:s,blending:o,depthWrite:!1},{onBeforeRender:v}=n();return v(({delta:n})=>{u.uniforms.uTime.value+=10*n}),(n,a)=>(f(),l("TresMesh",{ref:"quanMeshRef","rotation-y":Math.PI,position:[0,180,410]},[a[0]||(a[0]=m("TresPlaneGeometry",{args:[820,220]},null,-1)),m("TresShaderMaterial",i(c(u)),null,16)],8,g))}});export{u as _};
