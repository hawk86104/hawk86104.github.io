import{h as Jt,y as es,importShared as kt,E as ts,GLTFLoader as ss,zt as Vt}from"./3d-tiles-renderer.DZNovkLO1767148983502.js";import{FullScreenQuad as Bt}from"./Pass.CNeFv-CX1767148983502.js";const Ke="https://tile.googleapis.com/v1/createSession";let is=class{get isMapTilesSession(){return this.authURL===Ke}constructor(e={}){const{apiToken:t,sessionOptions:s=null,autoRefreshToken:i=!1}=e;this.apiToken=t,this.autoRefreshToken=i,this.authURL=Ke,this.sessionToken=null,this.sessionOptions=s,this._tokenRefreshPromise=null}async fetch(e,t){this.sessionToken===null&&this.isMapTilesSession&&this.refreshToken(t),await this._tokenRefreshPromise;const s=new URL(e);s.searchParams.set("key",this.apiToken),this.sessionToken&&s.searchParams.set("session",this.sessionToken);let i=await fetch(s,t);return i.status>=400&&i.status<=499&&this.autoRefreshToken&&(await this.refreshToken(t),this.sessionToken&&s.searchParams.set("session",this.sessionToken),i=await fetch(s,t)),this.sessionToken===null&&!this.isMapTilesSession?i.json().then(r=>(this.sessionToken=Je(r),r)):i}refreshToken(e){if(this._tokenRefreshPromise===null){const t=new URL(this.authURL);t.searchParams.set("key",this.apiToken);const s={...e};this.isMapTilesSession&&(s.method="POST",s.body=JSON.stringify(this.sessionOptions),s.headers=s.headers||{},s.headers={...s.headers,"Content-Type":"application/json"}),this._tokenRefreshPromise=fetch(t,s).then(i=>{if(!i.ok)throw new Error(`GoogleCloudAuth: Failed to load data with error code ${i.status}`);return i.json()}).then(i=>(this.sessionToken=Je(i),this._tokenRefreshPromise=null,i))}return this._tokenRefreshPromise}};function Je(l){if("session"in l)return l.session;{let e=null;const t=l.root;return Jt(t,s=>{if(s.content&&s.content.uri){const[,i]=s.content.uri.split("?");return e=new URLSearchParams(i).get("session"),!0}return!1}),e}}let rs=class{constructor(e={}){const{apiToken:t,autoRefreshToken:s=!1}=e;this.apiToken=t,this.autoRefreshToken=s,this.authURL=null,this._tokenRefreshPromise=null,this._bearerToken=null}async fetch(e,t){await this._tokenRefreshPromise;const s={...t};s.headers=s.headers||{},s.headers={...s.headers,Authorization:this._bearerToken};const i=await fetch(e,s);return i.status>=400&&i.status<=499&&this.autoRefreshToken?(await this.refreshToken(t),s.headers.Authorization=this._bearerToken,fetch(e,s)):i}refreshToken(e){if(this._tokenRefreshPromise===null){const t=new URL(this.authURL);t.searchParams.set("access_token",this.apiToken),this._tokenRefreshPromise=fetch(t,e).then(s=>{if(!s.ok)throw new Error(`CesiumIonAuthPlugin: Failed to load data with error code ${s.status}`);return s.json()}).then(s=>(this._bearerToken=`Bearer ${s.accessToken}`,this._tokenRefreshPromise=null,s))}return this._tokenRefreshPromise}};function Be(l){return l>>1^-(l&1)}let ns=class extends es{constructor(...e){super(...e),this.fetchOptions.header={Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9"}}loadAsync(...e){const{fetchOptions:t}=this;return t.header=t.header||{},t.header.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",t.header.Accept+=";extensions=octvertexnormals-watermask-metadata",super.loadAsync(...e)}parse(e){let t=0;const s=new DataView(e),i=()=>{const w=s.getFloat64(t,!0);return t+=8,w},r=()=>{const w=s.getFloat32(t,!0);return t+=4,w},n=()=>{const w=s.getUint32(t,!0);return t+=4,w},a=()=>{const w=s.getUint8(t);return t+=1,w},o=(w,W)=>{const J=new W(e,t,w);return t+=w*W.BYTES_PER_ELEMENT,J},c={center:[i(),i(),i()],minHeight:r(),maxHeight:r(),sphereCenter:[i(),i(),i()],sphereRadius:i(),horizonOcclusionPoint:[i(),i(),i()]},u=n(),h=o(u,Uint16Array),f=o(u,Uint16Array),m=o(u,Uint16Array),p=new Float32Array(u),d=new Float32Array(u),g=new Float32Array(u);let y=0,x=0,T=0;const b=32767;for(let w=0;w<u;++w)y+=Be(h[w]),x+=Be(f[w]),T+=Be(m[w]),p[w]=y/b,d[w]=x/b,g[w]=T/b;const v=u>65536,M=v?Uint32Array:Uint16Array;v?t=Math.ceil(t/4)*4:t=Math.ceil(t/2)*2;const P=n(),S=o(P*3,M);let N=0;for(var j=0;j<S.length;++j){const w=S[j];S[j]=N-w,w===0&&++N}const X=(w,W)=>d[W]-d[w],B=(w,W)=>-X(w,W),G=(w,W)=>p[w]-p[W],L=(w,W)=>-G(w,W),A=n(),E=o(A,M);E.sort(X);const C=n(),I=o(C,M);I.sort(G);const z=n(),k=o(z,M);k.sort(B);const V=n(),F=o(V,M);F.sort(L);const U={westIndices:E,southIndices:I,eastIndices:k,northIndices:F},H={};for(;t<s.byteLength;){const w=a(),W=n();if(w===1){const J=o(u*2,Uint8Array),Z=new Float32Array(u*3);for(let ee=0;ee<u;ee++){let se=J[2*ee+0]/255*2-1,te=J[2*ee+1]/255*2-1;const Me=1-(Math.abs(se)+Math.abs(te));if(Me<0){const Ze=se;se=(1-Math.abs(te))*et(Ze),te=(1-Math.abs(Ze))*et(te)}const Ve=Math.sqrt(se*se+te*te+Me*Me);Z[3*ee+0]=se/Ve,Z[3*ee+1]=te/Ve,Z[3*ee+2]=Me/Ve}H.octvertexnormals={extensionId:w,normals:Z}}else if(w===2){const J=W===1?1:256,Z=o(J*J,Uint8Array);H.watermask={extensionId:w,mask:Z,size:J}}else if(w===4){const J=n(),Z=o(J,Uint8Array),ee=new TextDecoder().decode(Z);H.metadata={extensionId:w,json:JSON.parse(ee)}}}return{header:c,indices:S,vertexData:{u:p,v:d,height:g},edgeIndices:U,extensions:H}}};function et(l){return l<0?-1:1}const as=await kt("three"),{PlaneGeometry:Ft,Mesh:Re,MeshBasicMaterial:$e,Vector2:Q,MathUtils:_,Vector3:O,Sphere:os,Texture:ls,SRGBColorSpace:cs,DefaultLoadingManager:us,BufferGeometry:Dt,MeshStandardMaterial:hs,BufferAttribute:re,DataTexture:We,RGFormat:Ot,UnsignedByteType:Nt,LinearMipMapLinearFilter:ds,LinearFilter:jt,Triangle:zt,Vector4:_e,Matrix4:me,Matrix3:ps,Matrix2:fs,WebGLRenderer:ms,WebGLRenderTarget:tt,ShaderMaterial:gs,OneFactor:ys,ZeroFactor:xs,CustomBlending:bs,Box2:Ts,FileLoader:vs,Quaternion:Gt,BatchedMesh:Pi,Source:Si,Box3:Ci,REVISION:Ei,WebGLArrayRenderTarget:Ii,Raycaster:Ui,DoubleSide:Ri,OrthographicCamera:ki,Color:Vi,CanvasTexture:Bi,Ray:Fi,LineSegments:Di,LineBasicMaterial:Oi,EdgesGeometry:Ni,BoxGeometry:ji,Group:zi,Box3Helper:Gi,PointsMaterial:Hi}=await kt("three");class As{constructor(){this.creditsCount={}}_adjustAttributions(e,t){const s=this.creditsCount,i=e.split(/;/g);for(let r=0,n=i.length;r<n;r++){const a=i[r];a in s||(s[a]=0),s[a]+=t?1:-1,s[a]<=0&&delete s[a]}}addAttributions(e){this._adjustAttributions(e,!0)}removeAttributions(e){this._adjustAttributions(e,!1)}toString(){return Object.entries(this.creditsCount).sort((e,t)=>{const s=e[1];return t[1]-s}).map(e=>e[0]).join("; ")}}const _s="https://tile.googleapis.com/v1/3dtiles/root.json";class Ls{constructor({apiToken:e,sessionOptions:t=null,autoRefreshToken:s=!1,logoUrl:i=null,useRecommendedSettings:r=!0}){this.name="GOOGLE_CLOUD_AUTH_PLUGIN",this.apiToken=e,this.useRecommendedSettings=r,this.logoUrl=i,this.auth=new is({apiToken:e,autoRefreshToken:s,sessionOptions:t}),this.tiles=null,this._visibilityChangeCallback=null,this._attributionsManager=new As,this._logoAttribution={value:"",type:"image",collapsible:!1},this._attribution={value:"",type:"string",collapsible:!0}}init(e){const{useRecommendedSettings:t,auth:s}=this;e.resetFailedTiles(),e.rootURL==null&&(e.rootURL=_s),s.sessionOptions||(s.authURL=e.rootURL),t&&!s.isMapTilesSession&&(e.errorTarget=20),this.tiles=e,this._visibilityChangeCallback=({tile:i,visible:r})=>{var n,a;const o=((a=(n=i.cached.metadata)==null?void 0:n.asset)==null?void 0:a.copyright)||"";r?this._attributionsManager.addAttributions(o):this._attributionsManager.removeAttributions(o)},e.addEventListener("tile-visibility-change",this._visibilityChangeCallback)}getAttributions(e){this.tiles.visibleTiles.size>0&&(this.logoUrl&&(this._logoAttribution.value=this.logoUrl,e.push(this._logoAttribution)),this._attribution.value=this._attributionsManager.toString(),e.push(this._attribution))}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._visibilityChangeCallback)}async fetchData(e,t){return this.auth.fetch(e,t)}}const ue=new Q,de=Symbol("TILE_X"),pe=Symbol("TILE_Y"),ae=Symbol("TILE_LEVEL");class ws{get tiling(){return this.imageSource.tiling}constructor(e={}){const{pixelSize:t=null,center:s=!1,useRecommendedSettings:i=!0,imageSource:r=null}=e;this.priority=-10,this.tiles=null,this.imageSource=r,this.pixelSize=t,this.center=s,this.useRecommendedSettings=i,t!==null&&console.warn('ImageFormatPlugin: "pixelSize" has been deprecated in favor of scaling the tiles root.')}init(e){this.useRecommendedSettings&&(e.errorTarget=1),this.tiles=e,this.imageSource.fetchOptions=e.fetchOptions,this.imageSource.fetchData=(t,s)=>(e.invokeAllPlugins(i=>t=i.preprocessURL?i.preprocessURL(t,null):t),e.invokeOnePlugin(i=>i!==this&&i.fetchData&&i.fetchData(t,s)))}async loadRootTileSet(){const{tiles:e,imageSource:t}=this;return t.url=t.url||e.rootURL,e.invokeAllPlugins(s=>t.url=s.preprocessURL?s.preprocessURL(t.url,null):t.url),await t.init(),e.rootURL=t.url,this.getTileset(t.url)}async parseToMesh(e,t,s,i,r){if(r.aborted)return null;const{imageSource:n}=this,a=t[de],o=t[pe],c=t[ae],u=await n.processBufferToTexture(e);if(r.aborted)return u.dispose(),u.image.close(),null;n.setData(a,o,c,u);let h=1,f=1,m=0,p=0,d=0;const g=t.boundingVolume.box;g&&([m,p,d]=g,h=g[3],f=g[7]);const y=new Ft(2*h,2*f),x=new Re(y,new $e({map:u,transparent:!0}));x.position.set(m,p,d);const T=n.tiling.getTileContentUVBounds(a,o,c),{uv:b}=y.attributes;for(let v=0;v<b.count;v++)ue.fromBufferAttribute(b,v),ue.x=_.mapLinear(ue.x,0,1,T[0],T[2]),ue.y=_.mapLinear(ue.y,0,1,T[1],T[3]),b.setXY(v,ue.x,ue.y);return x}preprocessNode(e){const{tiling:t}=this,s=t.maxLevel;e[ae]<s&&e.parent!==null&&this.expandChildren(e)}disposeTile(e){const t=e[de],s=e[pe],i=e[ae],{imageSource:r}=this;r.has(t,s,i)&&r.release(t,s,i)}getTileset(e){const{tiling:t,tiles:s}=this,i=t.minLevel,{tileCountX:r,tileCountY:n}=t.getLevel(i),a=[];for(let c=0;c<r;c++)for(let u=0;u<n;u++){const h=this.createChild(c,u,i);h!==null&&a.push(h)}const o={asset:{version:"1.1"},geometricError:1e5,root:{refine:"REPLACE",geometricError:1e5,boundingVolume:this.createBoundingVolume(0,0,-1),children:a,[ae]:-1,[de]:0,[pe]:0}};return s.preprocessTileSet(o,e),o}getUrl(e,t,s){return this.imageSource.getUrl(e,t,s)}createBoundingVolume(e,t,s){const{center:i,pixelSize:r,tiling:n}=this,{pixelWidth:a,pixelHeight:o}=n.getLevel(n.maxLevel),[c,u,h,f]=s===-1?n.getContentBounds(!0):n.getTileBounds(e,t,s,!0);let m=(h-c)/2,p=(f-u)/2,d=c+m,g=u+p;return i&&(d-=.5,g-=.5),r?(d*=a*r,m*=a*r,g*=o*r,p*=o*r):(d*=n.aspectRatio,m*=n.aspectRatio),{box:[d,g,0,m,0,0,0,p,0,0,0,0]}}createChild(e,t,s){const{pixelSize:i,tiling:r}=this;if(!r.getTileExists(e,t,s))return null;const{pixelWidth:n,pixelHeight:a}=r.getLevel(r.maxLevel),{pixelWidth:o,pixelHeight:c}=r.getLevel(s);let u=Math.max(1/o,1/c);return i&&(u*=i*Math.max(n,a)),{refine:"REPLACE",geometricError:u,boundingVolume:this.createBoundingVolume(e,t,s),content:{uri:this.getUrl(e,t,s)},children:[],[de]:e,[pe]:t,[ae]:s}}expandChildren(e){const t=e[ae],s=e[de],i=e[pe];for(let r=0;r<2;r++)for(let n=0;n<2;n++){const a=this.createChild(2*s+r,2*i+n,t+1);a&&e.children.push(a)}}}const Fe=new O,Pe=new O;function Ms(l,e,t){const s=t+1e-5;let i=e+1e-5;Math.abs(i)>Math.PI/2&&(i=i-1e-5),l.getCartographicToPosition(e,t,0,Fe),l.getCartographicToPosition(i,t,0,Pe);const r=Fe.distanceTo(Pe)/1e-5;return l.getCartographicToPosition(e,s,0,Pe),[Fe.distanceTo(Pe)/1e-5,r]}const Ps=30,Ss=15,De=new O,st=new O,ie=new Q,Oe=new os;class Cs extends ws{get projection(){return this.tiling.projection}constructor(e={}){const{shape:t="planar",endCaps:s=!0,...i}=e;super(i),this.shape=t,this.endCaps=s}async parseToMesh(e,t,...s){const i=await super.parseToMesh(e,t,...s),{shape:r,projection:n,tiles:a,tiling:o}=this;if(r==="ellipsoid"){const c=a.ellipsoid,u=t[ae],h=t[de],f=t[pe],[m,p,d,g]=t.boundingVolume.region,y=Math.ceil((g-p)*_.RAD2DEG*.25),x=Math.ceil((d-m)*_.RAD2DEG*.25),T=Math.max(Ss,y),b=Math.max(Ps,x),v=new Ft(1,1,b,T),[M,P,S,N]=o.getTileBounds(h,f,u,!0,!0),j=o.getTileContentUVBounds(h,f,u),{position:X,normal:B,uv:G}=v.attributes,L=X.count;t.cached.boundingVolume.getSphere(Oe);for(let A=0;A<L;A++){De.fromBufferAttribute(X,A),ie.fromBufferAttribute(G,A);const E=n.convertProjectionToLongitude(_.mapLinear(ie.x,0,1,M,S));let C=n.convertProjectionToLatitude(_.mapLinear(ie.y,0,1,P,N));if(n.isMercator&&this.endCaps&&(N===1&&ie.y===1&&(C=Math.PI/2),P===0&&ie.y===0&&(C=-Math.PI/2)),n.isMercator&&ie.y!==0&&ie.y!==1){const k=n.convertProjectionToLatitude(1),V=1/T,F=_.mapLinear(ie.y-V,0,1,p,g),U=_.mapLinear(ie.y+V,0,1,p,g);C>k&&F<k&&(C=k),C<-k&&U>-k&&(C=-k)}c.getCartographicToPosition(C,E,0,De).sub(Oe.center),c.getCartographicToNormal(C,E,st);const I=_.mapLinear(n.convertLongitudeToProjection(E),M,S,j[0],j[2]),z=_.mapLinear(n.convertLatitudeToProjection(C),P,N,j[1],j[3]);G.setXY(A,I,z),X.setXYZ(A,...De),B.setXYZ(A,...st)}i.geometry=v,i.position.copy(Oe.center)}return i}createBoundingVolume(e,t,s){if(this.shape==="ellipsoid"){const{tiling:i,endCaps:r}=this,n=s===-1,a=n?i.getContentBounds(!0):i.getTileBounds(e,t,s,!0,!0),o=n?i.getContentBounds():i.getTileBounds(e,t,s,!1,!0);return r&&(a[3]===1&&(o[3]=Math.PI/2),a[1]===0&&(o[1]=-Math.PI/2)),{region:[...o,-1,1]}}else return super.createBoundingVolume(e,t,s)}createChild(...e){const t=super.createChild(...e),{shape:s,projection:i,tiling:r}=this;if(t&&s==="ellipsoid"){const n=t[ae],a=t[de],o=t[pe];if(n===-1)return t.geometricError=1e50,parent;const[c,u,h,f]=r.getTileBounds(a,o,n,!0),{tilePixelWidth:m,tilePixelHeight:p}=r.getLevel(n),d=(h-c)/m,g=(f-u)/p,[,y,x,T]=r.getTileBounds(a,o,n),b=y>0!=T>0?0:Math.min(Math.abs(y),Math.abs(T)),v=i.convertLatitudeToProjection(b),M=i.getLongitudeDerivativeAtProjection(c),P=i.getLatitudeDerivativeAtProjection(v),[S,N]=Ms(this.tiles.ellipsoid,b,x),j=Math.max(d*M*S,g*P*N);t.geometricError=j}return t}}class Ht{get isMercator(){return this.scheme==="EPSG:3857"}constructor(e="EPSG:4326"){this.scheme=e,this.tileCountX=1,this.tileCountY=1,this.setScheme(e)}setScheme(e){switch(this.scheme=e,e){case"EPSG:4326":this.tileCountX=2,this.tileCountY=1;break;case"EPSG:3857":this.tileCountX=1,this.tileCountY=1;break;default:throw new Error}}convertProjectionToLatitude(e){if(this.isMercator){const t=_.mapLinear(e,0,1,-1,1);return 2*Math.atan(Math.exp(t*Math.PI))-Math.PI/2}else return _.mapLinear(e,0,1,-Math.PI/2,Math.PI/2)}convertProjectionToLongitude(e){return _.mapLinear(e,0,1,-Math.PI,Math.PI)}convertLatitudeToProjection(e){if(this.isMercator){const t=Math.log(Math.tan(Math.PI/4+e/2));return 1/2+1*t/(2*Math.PI)}else return _.mapLinear(e,-Math.PI/2,Math.PI/2,0,1)}convertLongitudeToProjection(e){return(e+Math.PI)/(2*Math.PI)}getLongitudeDerivativeAtProjection(e){return 2*Math.PI}getLatitudeDerivativeAtProjection(e){let t=e-1e-5;return t<0&&(t=e+1e-5),this.isMercator?Math.abs(this.convertProjectionToLatitude(e)-this.convertProjectionToLatitude(t))/1e-5:Math.PI}getBounds(){return[this.convertProjectionToLongitude(0),this.convertProjectionToLatitude(0),this.convertProjectionToLongitude(1),this.convertProjectionToLatitude(1)]}}function ge(...l){return l.join("_")}class Es{constructor(){this.cache={},this.count=0,this.cachedBytes=0,this.active=0}fetchItem(){}disposeItem(){}getMemoryUsage(e){return 0}setData(...e){const{cache:t}=this,s=e.pop(),i=ge(...e);if(i in t)throw new Error(`DataCache: "${i}" is already present.`);return this.cache[i]={abortController:new AbortController,result:s,count:1,bytes:this.getMemoryUsage(s)},this.count++,this.cachedBytes+=this.cache[i].bytes,s}lock(...e){const{cache:t}=this,s=ge(...e);if(s in t)t[s].count++;else{const i=new AbortController,r={abortController:i,result:null,count:1,bytes:0};this.active++,r.result=this.fetchItem(e,i.signal),r.result instanceof Promise?r.result.then(n=>(r.result=n,r.bytes=this.getMemoryUsage(n),this.cachedBytes+=r.bytes,n)).finally(()=>{this.active--}).catch(n=>{}):(this.active--,r.bytes=this.getMemoryUsage(r.result),this.cachedBytes+=r.bytes),this.cache[s]=r,this.count++}return t[s].result}release(...e){const t=ge(...e);this.releaseViaFullKey(t)}get(...e){const{cache:t}=this,s=ge(...e);return s in t&&t[s].count>0?t[s].result:null}has(...e){const{cache:t}=this;return ge(...e)in t}dispose(){const{cache:e}=this;for(const t in e){const{abortController:s}=e[t];s.abort(),this.releaseViaFullKey(t,!0)}this.cache={}}releaseViaFullKey(e,t=!1){const{cache:s}=this;if(e in s&&s[e].count>0){const i=s[e];if(i.count--,i.count===0||t){const r=()=>{if(s[e]!==i)return;const{result:n,abortController:a}=i;a.abort(),n instanceof Promise?n.then(o=>{this.disposeItem(o),this.count--,this.cachedBytes-=i.bytes}).catch(()=>{}):(this.disposeItem(n),this.count--,this.cachedBytes-=i.bytes),delete s[e]};t?r():queueMicrotask(()=>{i.count===0&&r()})}return!0}throw new Error("DataCache: Attempting to release key that does not exist")}}class qt{get levelCount(){return this._levels.length}get maxLevel(){return this.levelCount-1}get minLevel(){const e=this._levels;for(let t=0;t<e.length;t++)if(e[t]!==null)return t;return-1}get contentBounds(){var e;return this._contentBounds??((e=this.projection)==null?void 0:e.getBounds())??[0,0,1,1]}get aspectRatio(){const{pixelWidth:e,pixelHeight:t}=this.getLevel(this.maxLevel);return e/t}constructor(){this.flipY=!1,this.pixelOverlap=0,this._contentBounds=null,this.projection=null,this._levels=[]}setLevel(e,t={}){const s=this._levels;for(;s.length<e;)s.push(null);const{tilePixelWidth:i=256,tilePixelHeight:r=256,tileCountX:n=2**e,tileCountY:a=2**e,tileBounds:o=null}=t,{pixelWidth:c=i*n,pixelHeight:u=r*a}=t;s[e]={tilePixelWidth:i,tilePixelHeight:r,pixelWidth:c,pixelHeight:u,tileCountX:n,tileCountY:a,tileBounds:o}}generateLevels(e,t,s,i={}){const{minLevel:r=0,tilePixelWidth:n=256,tilePixelHeight:a=256}=i,o=e-1,{pixelWidth:c=n*t*2**o,pixelHeight:u=a*s*2**o}=i;for(let h=r;h<e;h++){const f=e-h-1,m=Math.ceil(c*2**-f),p=Math.ceil(u*2**-f),d=Math.ceil(m/n),g=Math.ceil(p/a);this.setLevel(h,{tilePixelWidth:n,tilePixelHeight:a,pixelWidth:m,pixelHeight:p,tileCountX:d,tileCountY:g})}}getLevel(e){return this._levels[e]}setContentBounds(e,t,s,i){this._contentBounds=[e,t,s,i]}setProjection(e){this.projection=e}getTileAtPoint(e,t,s,i=!1){const{flipY:r}=this,{tileCountX:n,tileCountY:a,tileBounds:o}=this.getLevel(s),c=1/n,u=1/a;if(i||([e,t]=this.toNormalizedPoint(e,t)),o){const m=this.toNormalizedRange(o);e=_.mapLinear(e,m[0],m[2],0,1),t=_.mapLinear(t,m[1],m[3],0,1)}const h=Math.floor(e/c);let f=Math.floor(t/u);return r&&(f=a-1-f),[h,f]}getTilesInRange(e,t,s,i,r,n=!1){[e,t,s,i]=this.clampToContentBounds([e,t,s,i],n);const a=this.getTileAtPoint(e,t,r,n),o=this.getTileAtPoint(s,i,r,n);this.flipY&&([a[1],o[1]]=[o[1],a[1]]);const{tileCountX:c,tileCountY:u}=this.getLevel(r),[h,f]=a,[m,p]=o;return m<0||p<0||h>=c||f>=u?[0,0,-1,-1]:[_.clamp(h,0,c-1),_.clamp(f,0,u-1),_.clamp(m,0,c-1),_.clamp(p,0,u-1)]}getTileExists(e,t,s){const[i,r,n,a]=this.contentBounds,[o,c,u,h]=this.getTileBounds(e,t,s);return!(o>=u||c>=h)&&o<=n&&c<=a&&u>=i&&h>=r}getContentBounds(e=!1){const{projection:t}=this,s=[...this.contentBounds];return t&&e&&(s[0]=t.convertLongitudeToProjection(s[0]),s[1]=t.convertLatitudeToProjection(s[1]),s[2]=t.convertLongitudeToProjection(s[2]),s[3]=t.convertLatitudeToProjection(s[3])),s}getTileContentUVBounds(e,t,s){const[i,r,n,a]=this.getTileBounds(e,t,s,!0,!0),[o,c,u,h]=this.getTileBounds(e,t,s,!0,!1);return[_.mapLinear(i,o,u,0,1),_.mapLinear(r,c,h,0,1),_.mapLinear(n,o,u,0,1),_.mapLinear(a,c,h,0,1)]}getTileBounds(e,t,s,i=!1,r=!0){const{flipY:n,pixelOverlap:a,projection:o}=this,{tilePixelWidth:c,tilePixelHeight:u,pixelWidth:h,pixelHeight:f,tileBounds:m}=this.getLevel(s);let p=c*e-a,d=u*t-a,g=p+c+a*2,y=d+u+a*2;if(p=Math.max(p,0),d=Math.max(d,0),g=Math.min(g,h),y=Math.min(y,f),p=p/h,g=g/h,d=d/f,y=y/f,n){const T=(y-d)/2,b=1-(d+y)/2;d=b-T,y=b+T}let x=[p,d,g,y];if(m){const T=this.toNormalizedRange(m);x[0]=_.mapLinear(x[0],0,1,T[0],T[2]),x[2]=_.mapLinear(x[2],0,1,T[0],T[2]),x[1]=_.mapLinear(x[1],0,1,T[1],T[3]),x[3]=_.mapLinear(x[3],0,1,T[1],T[3])}return r&&(x=this.clampToProjectionBounds(x,!0)),o&&!i&&(x[0]=o.convertProjectionToLongitude(x[0]),x[1]=o.convertProjectionToLatitude(x[1]),x[2]=o.convertProjectionToLongitude(x[2]),x[3]=o.convertProjectionToLatitude(x[3])),x}toNormalizedPoint(e,t){const{projection:s}=this,i=[e,t];return this.projection&&(i[0]=s.convertLongitudeToProjection(i[0]),i[1]=s.convertLatitudeToProjection(i[1])),i}toNormalizedRange(e){return[...this.toNormalizedPoint(e[0],e[1]),...this.toNormalizedPoint(e[2],e[3])]}toCartographicPoint(e,t){const{projection:s}=this,i=[e,t];if(this.projection)i[0]=s.convertProjectionToLongitude(i[0]),i[1]=s.convertProjectionToLatitude(i[1]);else throw new Error("TilingScheme: Projection not available.");return i}toCartographicRange(e){return[...this.toCartographicPoint(e[0],e[1]),...this.toCartographicPoint(e[2],e[3])]}clampToContentBounds(e,t=!1){const s=[...e],[i,r,n,a]=this.getContentBounds(t);return s[0]=_.clamp(s[0],i,n),s[1]=_.clamp(s[1],r,a),s[2]=_.clamp(s[2],i,n),s[3]=_.clamp(s[3],r,a),s}clampToProjectionBounds(e,t=!1){const s=[...e],{projection:i}=this;let r;t||!i?r=[0,0,1,1]:r=i.getBounds();const[n,a,o,c]=r;return s[0]=_.clamp(s[0],n,o),s[1]=_.clamp(s[1],a,c),s[2]=_.clamp(s[2],n,o),s[3]=_.clamp(s[3],a,c),s}}class Is extends Es{constructor(){super(),this.tiling=new qt,this.fetchOptions={},this.fetchData=(...e)=>fetch(...e)}init(){}async processBufferToTexture(e){const t=new Blob([e]),s=await createImageBitmap(t,{premultiplyAlpha:"none",colorSpaceConversion:"none",imageOrientation:"flipY"}),i=new ls(s);return i.generateMipmaps=!1,i.colorSpace=cs,i.needsUpdate=!0,i}getMemoryUsage(e){const{TextureUtils:t}=as;if(!t)return 0;const{format:s,type:i,image:r,generateMipmaps:n}=e,{width:a,height:o}=r,c=t.getByteLength(a,o,s,i);return n?c*4/3:c}fetchItem(e,t){const s={...this.fetchOptions,signal:t},i=this.getUrl(...e);return this.fetchData(i,s).then(r=>r.arrayBuffer()).then(r=>this.processBufferToTexture(r))}disposeItem(e){e.dispose(),e.image instanceof ImageBitmap&&e.image.close()}getUrl(...e){}}class Us extends Is{constructor(e={}){const{url:t=null}=e;super(),this.tileSets=null,this.extension=null,this.url=t}getUrl(e,t,s){const{url:i,extension:r,tileSets:n,tiling:a}=this;return new URL(`${parseInt(n[s-a.minLevel].href)}/${e}/${t}.${r}`,i).toString()}init(){const{url:e}=this;return this.fetchData(new URL("tilemapresource.xml",e),this.fetchOptions).then(t=>t.text()).then(t=>{const{tiling:s}=this,i=new DOMParser().parseFromString(t,"text/xml"),r=i.querySelector("BoundingBox"),n=i.querySelector("TileFormat"),a=[...i.querySelector("TileSets").querySelectorAll("TileSet")].map(g=>({href:parseInt(g.getAttribute("href")),unitsPerPixel:parseFloat(g.getAttribute("units-per-pixel")),order:parseInt(g.getAttribute("order"))})).sort((g,y)=>g.order-y.order),o=parseFloat(r.getAttribute("minx"))*_.DEG2RAD,c=parseFloat(r.getAttribute("maxx"))*_.DEG2RAD,u=parseFloat(r.getAttribute("miny"))*_.DEG2RAD,h=parseFloat(r.getAttribute("maxy"))*_.DEG2RAD,f=parseInt(n.getAttribute("width")),m=parseInt(n.getAttribute("height")),p=n.getAttribute("extension"),d=i.querySelector("SRS").textContent;this.extension=p,this.url=e,this.tileSets=a,s.setProjection(new Ht(d)),s.setContentBounds(o,u,c,h),a.forEach(({order:g})=>{s.setLevel(g,{tileCountX:s.projection.tileCountX*2**g,tilePixelWidth:f,tilePixelHeight:m})})})}}class Rs extends Cs{constructor(e={}){const{url:t,...s}=e;super(s),this.name="TMS_TILES_PLUGIN",this.imageSource=new Us({url:t})}}const it=new O,Se=new zt,D=new O,ne=new O;class ks extends ns{constructor(e=us){super(),this.manager=e,this.ellipsoid=new Vt,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI}parse(e){const{ellipsoid:t,solid:s,skirtLength:i,smoothSkirtNormals:r,minLat:n,maxLat:a,minLon:o,maxLon:c}=this,{header:u,indices:h,vertexData:f,edgeIndices:m,extensions:p}=super.parse(e),d=new Dt,g=new hs,y=new Re(d,g);y.position.set(...u.center);const x="octvertexnormals"in p,T=f.u.length,b=[],v=[],M=[],P=[];let S=0,N=0;for(let L=0;L<T;L++)X(L,D),B(D.x,D.y,D.z,ne),v.push(D.x,D.y),b.push(...ne);for(let L=0,A=h.length;L<A;L++)M.push(h[L]);if(x){const L=p.octvertexnormals.normals;for(let A=0,E=L.length;A<E;A++)P.push(L[A])}if(d.addGroup(S,h.length,N),S+=h.length,N++,s){const L=b.length/3;for(let A=0;A<T;A++)X(A,D),B(D.x,D.y,D.z,ne,-i),v.push(D.x,D.y),b.push(...ne);for(let A=h.length-1;A>=0;A--)M.push(h[A]+L);if(x){const A=p.octvertexnormals.normals;for(let E=0,C=A.length;E<C;E++)P.push(-A[E])}d.addGroup(S,h.length,N),S+=h.length,N++}if(i>0){const{westIndices:L,eastIndices:A,southIndices:E,northIndices:C}=m;let I;const z=G(L);I=b.length/3,v.push(...z.uv),b.push(...z.positions);for(let U=0,H=z.indices.length;U<H;U++)M.push(z.indices[U]+I);const k=G(A);I=b.length/3,v.push(...k.uv),b.push(...k.positions);for(let U=0,H=k.indices.length;U<H;U++)M.push(k.indices[U]+I);const V=G(E);I=b.length/3,v.push(...V.uv),b.push(...V.positions);for(let U=0,H=V.indices.length;U<H;U++)M.push(V.indices[U]+I);const F=G(C);I=b.length/3,v.push(...F.uv),b.push(...F.positions);for(let U=0,H=F.indices.length;U<H;U++)M.push(F.indices[U]+I);x&&(P.push(...z.normals),P.push(...k.normals),P.push(...V.normals),P.push(...F.normals)),d.addGroup(S,h.length,N),S+=h.length,N++}for(let L=0,A=b.length;L<A;L+=3)b[L+0]-=u.center[0],b[L+1]-=u.center[1],b[L+2]-=u.center[2];const j=b.length/3>65535?new Uint32Array(M):new Uint16Array(M);if(d.setIndex(new re(j,1,!1)),d.setAttribute("position",new re(new Float32Array(b),3,!1)),d.setAttribute("uv",new re(new Float32Array(v),2,!1)),x&&d.setAttribute("normal",new re(new Float32Array(P),3,!1)),"watermask"in p){const{mask:L,size:A}=p.watermask,E=new Uint8Array(2*A*A);for(let I=0,z=L.length;I<z;I++){const k=L[I]===255?0:255;E[2*I+0]=k,E[2*I+1]=k}const C=new We(E,A,A,Ot,Nt);C.flipY=!0,C.minFilter=ds,C.magFilter=jt,C.needsUpdate=!0,g.roughnessMap=C}return y.userData.minHeight=u.minHeight,y.userData.maxHeight=u.maxHeight,"metadata"in p&&(y.userData.metadata=p.metadata.json),y;function X(L,A){return A.x=f.u[L],A.y=f.v[L],A.z=f.height[L],A}function B(L,A,E,C,I=0){const z=_.lerp(u.minHeight,u.maxHeight,E),k=_.lerp(o,c,L),V=_.lerp(n,a,A);return t.getCartographicToPosition(V,k,z+I,C),C}function G(L){const A=[],E=[],C=[],I=[],z=[];for(let F=0,U=L.length;F<U;F++)X(L[F],D),A.push(D.x,D.y),C.push(D.x,D.y),B(D.x,D.y,D.z,ne),E.push(...ne),B(D.x,D.y,D.z,ne,-i),I.push(...ne);const k=L.length-1;for(let F=0;F<k;F++){const U=F,H=F+1,w=F+L.length,W=F+L.length+1;z.push(U,w,H),z.push(H,w,W)}let V=null;if(x){const F=(E.length+I.length)/3;if(r){V=new Array(F*3);const U=p.octvertexnormals.normals,H=V.length/2;for(let w=0,W=F/2;w<W;w++){const J=L[w],Z=3*w,ee=U[3*J+0],se=U[3*J+1],te=U[3*J+2];V[Z+0]=ee,V[Z+1]=se,V[Z+2]=te,V[H+Z+0]=ee,V[H+Z+1]=se,V[H+Z+2]=te}}else{V=[],Se.a.fromArray(E,0),Se.b.fromArray(I,0),Se.c.fromArray(E,3),Se.getNormal(it);for(let U=0;U<F;U++)V.push(...it)}}return{uv:[...A,...C],positions:[...E,...I],indices:z,normals:V}}}}const q=0,le=["a","b","c"],R=new _e,rt=new _e,nt=new _e,at=new _e;class Vs{constructor(){this.attributeList=null,this.splitOperations=[],this.trianglePool=new Bs}forEachSplitPermutation(e){const{splitOperations:t}=this,s=(i=0)=>{if(i>=t.length){e();return}t[i].keepPositive=!0,s(i+1),t[i].keepPositive=!1,s(i+1)};s()}addSplitOperation(e,t=!0){this.splitOperations.push({callback:e,keepPositive:t})}clearSplitOperations(){this.splitOperations.length=0}clipObject(e){const t=e.clone(),s=[];return t.traverse(i=>{i.isMesh&&(i.geometry=this.clip(i).geometry,(i.geometry.index?i.geometry.index.count/3:i.attributes.position.count/3)===0&&s.push(i))}),s.forEach(i=>{i.removeFromParent()}),t}clip(e,t=null){const s=this.getClippedData(e,t);return this.constructMesh(s.attributes,s.index,e)}getClippedData(e,t=null,s={}){const{trianglePool:i,splitOperations:r,attributeList:n}=this,a=e.geometry,o=a.attributes.position,c=a.index;let u=0;const h={};s.index=s.index||[],s.vertexIsClipped=s.vertexIsClipped||[],s.attributes=s.attributes||{};for(const d in a.attributes)n!==null&&(n instanceof Function&&!n(d)||Array.isArray(n)&&!n.includes(d))||(s.attributes[d]=[]);let f=0,m=c?c.count:o.count;t!==null&&(f=t.start,m=t.count);for(let d=f,g=f+m;d<g;d+=3){let y=d+0,x=d+1,T=d+2;c&&(y=c.getX(y),x=c.getX(x),T=c.getX(T));const b=i.get();b.initFromIndices(y,x,T);let v=[b];for(let M=0;M<r.length;M++){const{keepPositive:P,callback:S}=r[M],N=[];for(let j=0;j<v.length;j++){const X=v[j],{indices:B,barycoord:G}=X;X.clipValues.a=S(a,B.a,B.b,B.c,G.a,e.matrixWorld),X.clipValues.b=S(a,B.a,B.b,B.c,G.b,e.matrixWorld),X.clipValues.c=S(a,B.a,B.b,B.c,G.c,e.matrixWorld),this.splitTriangle(X,!P,N)}v=N}for(let M=0,P=v.length;M<P;M++){const S=v[M];p(S,a)}i.reset()}return s;function p(d,g){for(let y=0;y<3;y++){const x=d.getVertexHash(y,g);x in h||(h[x]=u,u++,d.getVertexData(y,g,s.attributes),s.vertexIsClipped.push(d.clipValues[le[y]]===q));const T=h[x];s.index.push(T)}}}constructMesh(e,t,s){const i=s.geometry,r=new Dt,n=e.position.length/3>65535?new Uint32Array(t):new Uint16Array(t);r.setIndex(new re(n,1,!1));for(const o in e){const c=i.getAttribute(o),u=new c.array.constructor(e[o]),h=new re(u,c.itemSize,c.normalized);h.gpuType=c.gpuType,r.setAttribute(o,h)}const a=new Re(r,s.material.clone());return a.position.copy(s.position),a.quaternion.copy(s.quaternion),a.scale.copy(s.scale),a}splitTriangle(e,t,s){const{trianglePool:i}=this,r=[],n=[],a=[];for(let o=0;o<3;o++){const c=le[o],u=le[(o+1)%3],h=e.clipValues[c],f=e.clipValues[u];(h<q!=f<q||h===q)&&(r.push(o),n.push([c,u]),h===f?a.push(0):a.push(_.mapLinear(q,h,f,0,1)))}if(r.length!==2)Math.min(e.clipValues.a,e.clipValues.b,e.clipValues.c)<q===t&&s.push(e);else if(r.length===2){const o=i.get().initFromTriangle(e),c=i.get().initFromTriangle(e),u=i.get().initFromTriangle(e);(r[0]+1)%3===r[1]?(o.lerpVertexFromEdge(e,n[0][0],n[0][1],a[0],"a"),o.copyVertex(e,n[0][1],"b"),o.lerpVertexFromEdge(e,n[1][0],n[1][1],a[1],"c"),o.clipValues.a=q,o.clipValues.c=q,c.lerpVertexFromEdge(e,n[0][0],n[0][1],a[0],"a"),c.copyVertex(e,n[1][1],"b"),c.copyVertex(e,n[0][0],"c"),c.clipValues.a=q,u.lerpVertexFromEdge(e,n[0][0],n[0][1],a[0],"a"),u.lerpVertexFromEdge(e,n[1][0],n[1][1],a[1],"b"),u.copyVertex(e,n[1][1],"c"),u.clipValues.a=q,u.clipValues.b=q):(o.lerpVertexFromEdge(e,n[0][0],n[0][1],a[0],"a"),o.lerpVertexFromEdge(e,n[1][0],n[1][1],a[1],"b"),o.copyVertex(e,n[0][0],"c"),o.clipValues.a=q,o.clipValues.b=q,c.lerpVertexFromEdge(e,n[0][0],n[0][1],a[0],"a"),c.copyVertex(e,n[0][1],"b"),c.lerpVertexFromEdge(e,n[1][0],n[1][1],a[1],"c"),c.clipValues.a=q,c.clipValues.c=q,u.copyVertex(e,n[0][1],"a"),u.copyVertex(e,n[1][0],"b"),u.lerpVertexFromEdge(e,n[1][0],n[1][1],a[1],"c"),u.clipValues.c=q);let h,f;h=Math.min(o.clipValues.a,o.clipValues.b,o.clipValues.c),f=h<q,f===t&&s.push(o),h=Math.min(c.clipValues.a,c.clipValues.b,c.clipValues.c),f=h<q,f===t&&s.push(c),h=Math.min(u.clipValues.a,u.clipValues.b,u.clipValues.c),f=h<q,f===t&&s.push(u)}}}class Bs{constructor(){this.pool=[],this.index=0}get(){if(this.index>=this.pool.length){const t=new Fs;this.pool.push(t)}const e=this.pool[this.index];return this.index++,e}reset(){this.index=0}}class Fs{constructor(){this.indices={a:-1,b:-1,c:-1},this.clipValues={a:-1,b:-1,c:-1},this.barycoord=new zt}getVertexHash(e,t){const{barycoord:s,indices:i}=this,r=le[e],n=s[r];if(n.x===1)return i[le[0]];if(n.y===1)return i[le[1]];if(n.z===1)return i[le[2]];{const{attributes:a}=t;let o="";for(const c in a){const u=a[c];switch(ot(u,i.a,i.b,i.c,n,R),(c==="normal"||c==="tangent"||c==="bitangent")&&R.normalize(),u.itemSize){case 4:o+=Te(R.x,R.y,R.z,R.w);break;case 3:o+=Te(R.x,R.y,R.z);break;case 2:o+=Te(R.x,R.y);break;case 1:o+=Te(R.x);break}o+="|"}return o}}getVertexData(e,t,s){const{barycoord:i,indices:r}=this,n=le[e],a=i[n],{attributes:o}=t;for(const c in o){if(!s[c])continue;const u=o[c],h=s[c];switch(ot(u,r.a,r.b,r.c,a,R),(c==="normal"||c==="tangent"||c==="bitangent")&&R.normalize(),u.itemSize){case 4:h.push(R.x,R.y,R.z,R.w);break;case 3:h.push(R.x,R.y,R.z);break;case 2:h.push(R.x,R.y);break;case 1:h.push(R.x);break}}}initFromTriangle(e){return this.initFromIndices(e.indices.a,e.indices.b,e.indices.c)}initFromIndices(e,t,s){return this.indices.a=e,this.indices.b=t,this.indices.c=s,this.clipValues.a=-1,this.clipValues.b=-1,this.clipValues.c=-1,this.barycoord.a.set(1,0,0),this.barycoord.b.set(0,1,0),this.barycoord.c.set(0,0,1),this}lerpVertexFromEdge(e,t,s,i,r){this.clipValues[r]=_.lerp(e.clipValues[t],e.clipValues[s],i),this.barycoord[r].lerpVectors(e.barycoord[t],e.barycoord[s],i)}copyVertex(e,t,s){this.clipValues[s]=e.clipValues[t],this.barycoord[s].copy(e.barycoord[t])}}function ot(l,e,t,s,i,r){switch(rt.fromBufferAttribute(l,e),nt.fromBufferAttribute(l,t),at.fromBufferAttribute(l,s),r.set(0,0,0,0).addScaledVector(rt,i.x).addScaledVector(nt,i.y).addScaledVector(at,i.z),l.itemSize){case 3:R.w=0;break;case 2:R.w=0,R.z=0;break;case 1:R.w=0,R.z=0,R.y=0;break}return r}function Te(...l){let e="";for(let t=0,s=l.length;t<s;t++)e+=~~(l[t]*1e5+.5),t!==s-1&&(e+="_");return e}const lt={},Ds=new O,Ne=new O,je=new O,Os=new O,Ns=new O,K=new O,fe=new O,Y=new Q,oe=new Q,ct=new Q;class js extends Vs{constructor(){super(),this.ellipsoid=new Vt,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI,this.attributeList=["position","normal","uv"]}clipToQuadrant(e,t,s){const{solid:i,skirtLength:r,ellipsoid:n,smoothSkirtNormals:a}=this;this.clearSplitOperations(),this.addSplitOperation(ut("x"),!t),this.addSplitOperation(ut("y"),!s);let o,c;const u=e.geometry.groups[0],h=this.getClippedData(e,u);if(this.adjustVertices(h,e.position,0),i){o={index:h.index.slice().reverse(),attributes:{}};for(const v in h.attributes)o.attributes[v]=h.attributes[v].slice();const b=o.attributes.normal;if(b)for(let v=0;v<b.length;v+=3)b[v+0]*=-1,b[v+1]*=-1,b[v+2]*=-1;this.adjustVertices(o,e.position,-r)}if(r>0){c={index:[],attributes:{position:[],normal:[],uv:[]}};let b=0;const v={},M=(B,G,L)=>{const A=Te(...B,...L,...G);A in v||(v[A]=b,b++,c.attributes.position.push(...B),c.attributes.normal.push(...L),c.attributes.uv.push(...G)),c.index.push(v[A])},P=h.index,S=h.attributes.uv,N=h.attributes.position,j=h.attributes.normal,X=h.index.length/3;for(let B=0;B<X;B++){const G=3*B;for(let L=0;L<3;L++){const A=(L+1)%3,E=P[G+L],C=P[G+A];if(Y.fromArray(S,E*2),oe.fromArray(S,C*2),Y.x===oe.x&&(Y.x===0||Y.x===.5||Y.x===1)||Y.y===oe.y&&(Y.y===0||Y.y===.5||Y.y===1)){Ne.fromArray(N,E*3),je.fromArray(N,C*3);const I=Ne,z=je,k=Os.copy(Ne),V=Ns.copy(je);K.copy(k).add(e.position),n.getPositionToNormal(K,K),k.addScaledVector(K,-r),K.copy(V).add(e.position),n.getPositionToNormal(K,K),V.addScaledVector(K,-r),a&&j?(K.fromArray(j,E*3),fe.fromArray(j,C*3)):(K.subVectors(I,z),fe.subVectors(I,k).cross(K).normalize(),K.copy(fe)),M(z,oe,fe),M(I,Y,K),M(k,Y,K),M(z,oe,fe),M(k,Y,K),M(V,oe,fe)}}}}const f=h.index.length,m=h;if(o){const{index:b,attributes:v}=o,M=m.attributes.position.length/3;for(let P=0,S=b.length;P<S;P++)m.index.push(b[P]+M);for(const P in h.attributes)m.attributes[P].push(...v[P])}if(c){const{index:b,attributes:v}=c,M=m.attributes.position.length/3;for(let P=0,S=b.length;P<S;P++)m.index.push(b[P]+M);for(const P in h.attributes)m.attributes[P].push(...v[P])}const p=t?0:-.5,d=s?0:-.5,g=m.attributes.uv;for(let b=0,v=g.length;b<v;b+=2)g[b]=(g[b]+p)*2,g[b+1]=(g[b+1]+d)*2;const y=this.constructMesh(m.attributes,m.index,e);y.userData.minHeight=e.userData.minHeight,y.userData.maxHeight=e.userData.maxHeight;let x=0,T=0;return y.geometry.addGroup(T,f,x),T+=f,x++,o&&(y.geometry.addGroup(T,o.index.length,x),T+=o.index.length,x++),c&&(y.geometry.addGroup(T,c.index.length,x),T+=c.index.length,x++),y}adjustVertices(e,t,s){const{ellipsoid:i,minLat:r,maxLat:n,minLon:a,maxLon:o}=this,{attributes:c,vertexIsClipped:u}=e,h=c.position,f=c.uv,m=h.length/3;for(let p=0;p<m;p++){const d=Y.fromArray(f,p*2);u&&u[p]&&(Math.abs(d.x-.5)<1e-10&&(d.x=.5),Math.abs(d.y-.5)<1e-10&&(d.y=.5),Y.toArray(f,p*2));const g=_.lerp(r,n,d.y),y=_.lerp(a,o,d.x),x=Ds.fromArray(h,p*3).add(t);i.getPositionToCartographic(x,lt),i.getCartographicToPosition(g,y,lt.height+s,x),x.sub(t),x.toArray(h,p*3)}}}function ut(l){return(e,t,s,i,r)=>{const n=e.attributes.uv;return Y.fromBufferAttribute(n,t),oe.fromBufferAttribute(n,s),ct.fromBufferAttribute(n,i),Y[l]*r.x+oe[l]*r.y+ct[l]*r.z-.5}}const ht=Symbol("TILE_X"),dt=Symbol("TILE_Y"),ve=Symbol("TILE_LEVEL"),he=Symbol("TILE_AVAILABLE"),Ce=1e4,pt=new O;function zs(l,e,t,s){if(l&&e<l.length){const i=l[e];for(let r=0,n=i.length;r<n;r++){const{startX:a,startY:o,endX:c,endY:u}=i[r];if(t>=a&&t<=c&&s>=o&&s<=u)return!0}}return!1}function Xt(l){const{available:e=null,maxzoom:t=null}=l;return t===null?e.length-1:t}function Gs(l){const{metadataAvailability:e=-1}=l;return e}function ze(l,e){const t=l[ve],s=Gs(e),i=Xt(e);return t<i&&s!==-1&&t%s===0}function Hs(l,e,t,s,i){return i.tiles[0].replace(/{\s*z\s*}/g,t).replace(/{\s*x\s*}/g,l).replace(/{\s*y\s*}/g,e).replace(/{\s*version\s*}/g,s)}class qs{constructor(e={}){const{useRecommendedSettings:t=!0,skirtLength:s=null,smoothSkirtNormals:i=!0,solid:r=!1}=e;this.name="QUANTIZED_MESH_PLUGIN",this.priority=-1e3,this.tiles=null,this.layer=null,this.useRecommendedSettings=t,this.skirtLength=s,this.smoothSkirtNormals=i,this.solid=r,this.attribution=null,this.tiling=new qt,this.projection=new Ht}init(e){e.fetchOptions.headers=e.fetchOptions.headers||{},e.fetchOptions.headers.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",this.useRecommendedSettings&&(e.errorTarget=2),this.tiles=e}loadRootTileSet(){const{tiles:e}=this;let t=new URL("layer.json",new URL(e.rootURL,location.href));return e.invokeAllPlugins(s=>t=s.preprocessURL?s.preprocessURL(t,null):t),e.invokeOnePlugin(s=>s.fetchData&&s.fetchData(t,this.tiles.fetchOptions)).then(s=>s.json()).then(s=>{this.layer=s;const{projection:i="EPSG:4326",extensions:r=[],attribution:n="",available:a=null}=s,{tiling:o,tiles:c,projection:u}=this;n&&(this.attribution={value:n,type:"string",collapsible:!0}),r.length>0&&(c.fetchOptions.headers.Accept+=`;extensions=${r.join("-")}`),u.setScheme(i);const{tileCountX:h,tileCountY:f}=u;o.setProjection(u),o.generateLevels(Xt(s)+1,h,f);const m=[];for(let g=0;g<h;g++){const y=this.createChild(0,g,0,a);y&&m.push(y)}const p={asset:{version:"1.1"},geometricError:1/0,root:{refine:"REPLACE",geometricError:1/0,boundingVolume:{region:[...this.tiling.getContentBounds(),-Ce,Ce]},children:m,[he]:a,[ve]:-1}};let d=c.rootURL;return c.invokeAllPlugins(g=>d=g.preprocessURL?g.preprocessURL(d,null):d),c.preprocessTileSet(p,d),p})}parseToMesh(e,t,s,i){const{skirtLength:r,solid:n,smoothSkirtNormals:a,tiles:o}=this,c=o.ellipsoid;let u;if(s==="quantized_tile_split"){const p=new URL(i).searchParams,d=p.get("left")==="true",g=p.get("bottom")==="true",y=new js;y.ellipsoid.copy(c),y.solid=n,y.smoothSkirtNormals=a,y.skirtLength=r===null?t.geometricError:r;const[x,T,b,v]=t.parent.boundingVolume.region;y.minLat=T,y.maxLat=v,y.minLon=x,y.maxLon=b,u=y.clipToQuadrant(t.parent.cached.scene,d,g)}else if(s==="terrain"){const p=new ks(o.manager);p.ellipsoid.copy(c),p.solid=n,p.smoothSkirtNormals=a,p.skirtLength=r===null?t.geometricError:r;const[d,g,y,x]=t.boundingVolume.region;p.minLat=g,p.maxLat=x,p.minLon=d,p.maxLon=y,u=p.parse(e)}else return;const{minHeight:h,maxHeight:f,metadata:m}=u.userData;return t.boundingVolume.region[4]=h,t.boundingVolume.region[5]=f,t.cached.boundingVolume.setRegionData(c,...t.boundingVolume.region),m&&("geometricerror"in m&&(t.geometricError=m.geometricerror),ze(t,this.layer)&&"available"in m&&t.children.length===0&&(t[he]=[...new Array(t[ve]+1).fill(null),...m.available])),this.expandChildren(t),u}getAttributions(e){this.attribution&&e.push(this.attribution)}createChild(e,t,s,i){const{tiles:r,layer:n,tiling:a,projection:o}=this,c=r.ellipsoid,u=i===null&&e===0||zs(i,e,t,s),h=Hs(t,s,e,1,n),f=[...a.getTileBounds(t,s,e),-Ce,Ce],[,m,,p,,d]=f,g=m>0!=p>0?0:Math.min(Math.abs(m),Math.abs(p));c.getCartographicToPosition(g,0,d,pt),pt.z=0;const y=o.tileCountX,x=Math.max(...c.radius)*2*Math.PI*.25/(65*y)/2**e,T={[he]:null,[ve]:e,[ht]:t,[dt]:s,refine:"REPLACE",geometricError:x,boundingVolume:{region:f},content:u?{uri:h}:null,children:[]};return ze(T,n)||(T[he]=i),T}expandChildren(e){const t=e[ve],s=e[ht],i=e[dt],r=e[he];if(t>=this.tiling.maxLevel)return;let n=!1;for(let a=0;a<2;a++)for(let o=0;o<2;o++){const c=this.createChild(t+1,2*s+a,2*i+o,r);c.content!==null?(e.children.push(c),n=!0):(e.children.push(c),c.content={uri:`tile.quantized_tile_split?bottom=${o===0}&left=${a===0}`})}n||(e.children.length=0)}fetchData(e,t){if(/quantized_tile_split/.test(e))return new ArrayBuffer}disposeTile(e){ze(e,this.layer)&&(e[he]=null),he in e&&(e.children.forEach(t=>{this.tiles.processNodeQueue.remove(t)}),e.children.length=0,e.__childrenProcessed=0)}}class qi{get apiToken(){return this.auth.apiToken}set apiToken(e){this.auth.apiToken=e}get autoRefreshToken(){return this.auth.autoRefreshToken}set autoRefreshToken(e){this.auth.autoRefreshToken=e}constructor({apiToken:e,assetId:t=null,autoRefreshToken:s=!1,useRecommendedSettings:i=!0}){this.name="CESIUM_ION_AUTH_PLUGIN",this.auth=new rs({apiToken:e,autoRefreshToken:s}),this.assetId=t,this.autoRefreshToken=s,this.useRecommendedSettings=i,this.tiles=null,this._tileSetVersion=-1,this._attributions=[]}init(e){this.assetId!==null&&(e.rootURL=`https://api.cesium.com/v1/assets/${this.assetId}/endpoint`),this.tiles=e,this.auth.authURL=e.rootURL,e.resetFailedTiles()}loadRootTileSet(){return this.auth.refreshToken().then(e=>(this._initializeFromAsset(e),this.tiles.invokeOnePlugin(t=>t!==this&&t.loadRootTileSet&&t.loadRootTileSet()))).catch(e=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:e,url:this.auth.authURL})})}preprocessURL(e){return e=new URL(e),/^http/.test(e.protocol)&&this._tileSetVersion!=-1&&e.searchParams.set("v",this._tileSetVersion),e.toString()}fetchData(e,t){return this.tiles.getPluginByName("GOOGLE_CLOUD_AUTH_PLUGIN")!==null?null:this.auth.fetch(e,t)}getAttributions(e){this.tiles.visibleTiles.size>0&&e.push(...this._attributions)}_initializeFromAsset(e){const t=this.tiles;if("externalType"in e){const s=new URL(e.options.url);t.rootURL=e.options.url,t.registerPlugin(new Ls({apiToken:s.searchParams.get("key"),autoRefreshToken:this.autoRefreshToken,useRecommendedSettings:this.useRecommendedSettings}))}else{e.type==="TERRAIN"&&t.getPluginByName("QUANTIZED_MESH_PLUGIN")===null?t.registerPlugin(new qs({useRecommendedSettings:this.useRecommendedSettings})):e.type==="IMAGERY"&&t.getPluginByName("TMS_TILES_PLUGIN")===null&&t.registerPlugin(new Rs({useRecommendedSettings:this.useRecommendedSettings,shape:"ellipsoid"})),t.rootURL=e.url;const s=new URL(e.url);s.searchParams.has("v")&&this._tileSetVersion===-1&&(this._tileSetVersion=s.searchParams.get("v")),e.attributions&&(this._attributions=e.attributions.map(i=>({value:i.html,type:"html",collapsible:i.collapsible})))}}}const Ge=new me;class Xi{constructor(){this.name="UPDATE_ON_CHANGE_PLUGIN",this.tiles=null,this.needsUpdate=!1,this.cameraMatrices=new Map}init(e){this.tiles=e,this._needsUpdateCallback=()=>{this.needsUpdate=!0},this._onCameraAdd=({camera:t})=>{this.needsUpdate=!0,this.cameraMatrices.set(t,new me)},this._onCameraDelete=({camera:t})=>{this.needsUpdate=!0,this.cameraMatrices.delete(t)},e.addEventListener("needs-update",this._needsUpdateCallback),e.addEventListener("add-camera",this._onCameraAdd),e.addEventListener("delete-camera",this._onCameraDelete),e.addEventListener("camera-resolution-change",this._needsUpdateCallback),e.cameras.forEach(t=>{this._onCameraAdd({camera:t})})}doTilesNeedUpdate(){const e=this.tiles;let t=!1;this.cameraMatrices.forEach((i,r)=>{Ge.copy(e.group.matrixWorld).premultiply(r.matrixWorldInverse).premultiply(r.projectionMatrixInverse),t=t||!Ge.equals(i),i.copy(Ge)});const s=this.needsUpdate;return this.needsUpdate=!1,s||t}preprocessNode(){this.needsUpdate=!0}dispose(){const e=this.tiles;e.removeEventListener("camera-resolution-change",this._needsUpdateCallback),e.removeEventListener("needs-update",this._needsUpdateCallback),e.removeEventListener("add-camera",this._onCameraAdd),e.removeEventListener("delete-camera",this._onCameraDelete)}}const ft=new O;function ye(l,e){if(l.isInterleavedBufferAttribute||l.array instanceof e)return l;const t=e===Int8Array||e===Int16Array||e===Int32Array?-1:0,s=new e(l.count*l.itemSize),i=new re(s,l.itemSize,!0),r=l.itemSize,n=l.count;for(let a=0;a<n;a++)for(let o=0;o<r;o++){const c=_.clamp(l.getComponent(a,o),t,1);i.setComponent(a,o,c)}return i}function Xs(l,e=Int16Array){const t=l.geometry,s=t.attributes,i=s.position;if(i.isInterleavedBufferAttribute||i.array instanceof e)return i;const r=new e(i.count*i.itemSize),n=new re(r,i.itemSize,!1),a=i.itemSize,o=i.count;t.computeBoundingBox();const c=t.boundingBox,{min:u,max:h}=c,f=2**(8*e.BYTES_PER_ELEMENT-1)-1,m=-f;for(let p=0;p<o;p++)for(let d=0;d<a;d++){const g=d===0?"x":d===1?"y":"z",y=u[g],x=h[g],T=_.mapLinear(i.getComponent(p,d),y,x,m,f);n.setComponent(p,d,T)}c.getCenter(ft).multiply(l.scale).applyQuaternion(l.quaternion),l.position.add(ft),l.scale.x*=.5*(h.x-u.x)/f,l.scale.y*=.5*(h.y-u.y)/f,l.scale.z*=.5*(h.z-u.z)/f,s.position=n,l.geometry.boundingBox=null,l.geometry.boundingSphere=null,l.updateMatrixWorld()}class $i{constructor(e){this._options={generateNormals:!1,disableMipmaps:!0,compressIndex:!0,compressNormals:!1,compressUvs:!1,compressPosition:!1,uvType:Int8Array,normalType:Int8Array,positionType:Int16Array,...e},this.name="TILES_COMPRESSION_PLUGIN",this.priority=-100}processTileModel(e,t){const{generateNormals:s,disableMipmaps:i,compressIndex:r,compressUvs:n,compressNormals:a,compressPosition:o,uvType:c,normalType:u,positionType:h}=this._options;e.traverse(f=>{if(f.material&&i){const m=f.material;for(const p in m){const d=m[p];d&&d.isTexture&&d.generateMipmaps&&(d.generateMipmaps=!1,d.minFilter=jt)}}if(f.geometry){const m=f.geometry,p=m.attributes;if(n){const{uv:d,uv1:g,uv2:y,uv3:x}=p;d&&(p.uv=ye(d,c)),g&&(p.uv1=ye(g,c)),y&&(p.uv2=ye(y,c)),x&&(p.uv3=ye(x,c))}if(s&&!p.normals&&m.computeVertexNormals(),a&&p.normals&&(p.normals=ye(p.normals,u)),o&&Xs(f,h),r&&m.index){const d=p.position.count,g=m.index,y=d>65535?Uint32Array:d>255?Uint16Array:Uint8Array;if(!(g.array instanceof y)){const x=new y(m.index.count);x.set(g.array);const T=new re(x,1);m.setIndex(T)}}}})}}function $(l,e,t){return l&&e in l?l[e]:t}function $t(l){return l!=="BOOLEAN"&&l!=="STRING"&&l!=="ENUM"}function $s(l){return/^FLOAT/.test(l)}function Le(l){return/^VEC/.test(l)}function we(l){return/^MAT/.test(l)}function Wt(l,e,t,s=null){return we(t)||Le(t)?s.fromArray(l,e):l[e]}function Xe(l){const{type:e,componentType:t}=l;switch(e){case"SCALAR":return t==="INT64"?0n:0;case"VEC2":return new Q;case"VEC3":return new O;case"VEC4":return new _e;case"MAT2":return new fs;case"MAT3":return new ps;case"MAT4":return new me;case"BOOLEAN":return!1;case"STRING":return"";case"ENUM":return 0}}function mt(l,e){if(e==null)return!1;switch(l){case"SCALAR":return typeof e=="number"||typeof e=="bigint";case"VEC2":return e.isVector2;case"VEC3":return e.isVector3;case"VEC4":return e.isVector4;case"MAT2":return e.isMatrix2;case"MAT3":return e.isMatrix3;case"MAT4":return e.isMatrix4;case"BOOLEAN":return typeof e=="boolean";case"STRING":return typeof e=="string";case"ENUM":return typeof e=="number"||typeof e=="bigint"}throw new Error("ClassProperty: invalid type.")}function Ae(l,e=null){switch(l){case"INT8":return Int8Array;case"INT16":return Int16Array;case"INT32":return Int32Array;case"INT64":return BigInt64Array;case"UINT8":return Uint8Array;case"UINT16":return Uint16Array;case"UINT32":return Uint32Array;case"UINT64":return BigUint64Array;case"FLOAT32":return Float32Array;case"FLOAT64":return Float64Array}switch(e){case"BOOLEAN":return Uint8Array;case"STRING":return Uint8Array}throw new Error("ClassProperty: invalid type.")}function Ws(l,e=null){if(l.array){e=e&&Array.isArray(e)?e:[],e.length=l.count;for(let t=0,s=e.length;t<s;t++)e[t]=Ee(l,e[t])}else e=Ee(l,e);return e}function Ee(l,e=null){const t=l.default,s=l.type;if(e=e||Xe(l),t===null){switch(s){case"SCALAR":return 0;case"VEC2":return e.set(0,0);case"VEC3":return e.set(0,0,0);case"VEC4":return e.set(0,0,0,0);case"MAT2":return e.identity();case"MAT3":return e.identity();case"MAT4":return e.identity();case"BOOLEAN":return!1;case"STRING":return"";case"ENUM":return""}throw new Error("ClassProperty: invalid type.")}else if(we(s))e.fromArray(t);else if(Le(s))e.fromArray(t);else return t}function Ys(l,e){if(l.noData===null)return e;const t=l.noData,s=l.type;if(Array.isArray(e))for(let n=0,a=e.length;n<a;n++)e[n]=i(e[n]);else e=i(e);return e;function i(n){return r(n)&&(n=Ee(l,n)),n}function r(n){if(we(s)){const a=n.elements;for(let o=0,c=t.length;o<c;o++)if(t[o]!==a[o])return!1;return!0}else if(Le(s)){for(let a=0,o=t.length;a<o;a++)if(t[a]!==n.getComponent(a))return!1;return!0}else return t===n}}function Qs(l,e){switch(l){case"INT8":return Math.max(e/127,-1);case"INT16":return Math.max(e,32767,-1);case"INT32":return Math.max(e/2147483647,-1);case"INT64":return Math.max(Number(e)/9223372036854776e3,-1);case"UINT8":return e/255;case"UINT16":return e/65535;case"UINT32":return e/4294967295;case"UINT64":return Number(e)/18446744073709552e3}}function Zs(l,e){const{type:t,componentType:s,scale:i,offset:r,normalized:n}=l;if(Array.isArray(e))for(let h=0,f=e.length;h<f;h++)e[h]=a(e[h]);else e=a(e);return e;function a(h){return we(t)?h=c(h):Le(t)?h=o(h):h=u(h),h}function o(h){return h.x=u(h.x),h.y=u(h.y),"z"in h&&(h.z=u(h.z)),"w"in h&&(h.w=u(h.w)),h}function c(h){const f=h.elements;for(let m=0,p=f.length;m<p;m++)f[m]=u(f[m]);return h}function u(h){return n&&(h=Qs(s,h)),(n||$s(s))&&(h=h*i+r),h}}function Ye(l,e,t=null){if(l.array){Array.isArray(e)||(e=new Array(l.count||0)),e.length=t!==null?t:l.count;for(let s=0,i=e.length;s<i;s++)mt(l.type,e[s])||(e[s]=Xe(l))}else mt(l.type,e)||(e=Xe(l));return e}function Ie(l,e){for(const t in e)t in l||delete e[t];for(const t in l){const s=l[t];e[t]=Ye(s,e[t])}}function Ks(l){switch(l){case"ENUM":return 1;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":return 4;case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;case"BOOLEAN":return-1;case"STRING":return-1;default:return-1}}class ke{constructor(e,t,s=null){this.name=t.name||null,this.description=t.description||null,this.type=t.type,this.componentType=t.componentType||null,this.enumType=t.enumType||null,this.array=t.array||!1,this.count=t.count||0,this.normalized=t.normalized||!1,this.offset=t.offset||0,this.scale=$(t,"scale",1),this.max=$(t,"max",1/0),this.min=$(t,"min",-1/0),this.required=t.required||!1,this.noData=$(t,"noData",null),this.default=$(t,"default",null),this.semantic=$(t,"semantic",null),this.enumSet=null,this.accessorProperty=s,s&&(this.offset=$(s,"offset",this.offset),this.scale=$(s,"scale",this.scale),this.max=$(s,"max",this.max),this.min=$(s,"min",this.min)),t.type==="ENUM"&&(this.enumSet=e[this.enumType],this.componentType===null&&(this.componentType=$(this.enumSet,"valueType","UINT16")))}shapeToProperty(e,t=null){return Ye(this,e,t)}resolveDefaultElement(e){return Ee(this,e)}resolveDefault(e){return Ws(this,e)}resolveNoData(e){return Ys(this,e)}resolveEnumsToStrings(e){const t=this.enumSet;if(this.type==="ENUM")if(Array.isArray(e))for(let i=0,r=e.length;i<r;i++)e[i]=s(e[i]);else e=s(e);return e;function s(i){const r=t.values.find(n=>n.value===i);return r===null?"":r.name}}adjustValueScaleOffset(e){return $t(this.type)?Zs(this,e):e}}class Qe{constructor(e,t={},s={},i=null){this.definition=e,this.class=t[e.class],this.className=e.class,this.enums=s,this.data=i,this.name="name"in e?e.name:null,this.properties=null}getPropertyNames(){return Object.keys(this.class.properties)}includesData(e){return!!this.definition.properties[e]}dispose(){}_initProperties(e=ke){const t={};for(const s in this.class.properties)t[s]=new e(this.enums,this.class.properties[s],this.definition.properties[s]);this.properties=t}}class Js extends ke{constructor(e,t,s=null){super(e,t,s),this.attribute=s?.attribute??null}}class ei extends Qe{constructor(...e){super(...e),this.isPropertyAttributeAccessor=!0,this._initProperties(Js)}getData(e,t,s={}){const i=this.properties;Ie(i,s);for(const r in i)s[r]=this.getPropertyValue(r,e,t,s[r]);return s}getPropertyValue(e,t,s,i=null){if(t>=this.count)throw new Error("PropertyAttributeAccessor: Requested index is outside the range of the buffer.");const r=this.properties[e],n=r.type;if(r){if(!this.definition.properties[e])return r.resolveDefault(i)}else throw new Error("PropertyAttributeAccessor: Requested class property does not exist.");i=r.shapeToProperty(i);const a=s.getAttribute(r.attribute.toLowerCase());if(we(n)){const o=i.elements;for(let c=0,u=o.length;c<u;c<u)o[c]=a.getComponent(t,c)}else if(Le(n))i.fromBufferAttribute(a,t);else if(n==="SCALAR"||n==="ENUM")i=a.getX(t);else throw new Error("StructuredMetadata.PropertyAttributeAccessor: BOOLEAN and STRING types are not supported by property attributes.");return i=r.adjustValueScaleOffset(i),i=r.resolveEnumsToStrings(i),i=r.resolveNoData(i),i}}class ti extends ke{constructor(e,t,s=null){super(e,t,s),this.values=s?.values??null,this.valueLength=Ks(this.type),this.arrayOffsets=$(s,"arrayOffsets",null),this.stringOffsets=$(s,"stringOffsets",null),this.arrayOffsetType=$(s,"arrayOffsetType","UINT32"),this.stringOffsetType=$(s,"stringOffsetType","UINT32")}getArrayLengthFromId(e,t){let s=this.count;if(this.arrayOffsets!==null){const{arrayOffsets:i,arrayOffsetType:r}=this,n=Ae(r),a=new n(e[i]);s=a[t+1]-a[t]}return s}getIndexOffsetFromId(e,t){let s=t;if(this.arrayOffsets){const{arrayOffsets:i,arrayOffsetType:r}=this,n=Ae(r);s=new n(e[i])[s]}else this.array&&(s*=this.count);return s}}class si extends Qe{constructor(...e){super(...e),this.isPropertyTableAccessor=!0,this.count=this.definition.count,this._initProperties(ti)}getData(e,t={}){const s=this.properties;Ie(s,t);for(const i in s)t[i]=this.getPropertyValue(i,e,t[i]);return t}_readValueAtIndex(e,t,s,i=null){const r=this.properties[e],{componentType:n,type:a}=r,o=this.data,c=o[r.values],u=Ae(n,a),h=new u(c),f=r.getIndexOffsetFromId(o,t);if($t(a)||a==="ENUM")return Wt(h,(f+s)*r.valueLength,a,i);if(a==="STRING"){let m=f+s,p=0;if(r.stringOffsets!==null){const{stringOffsets:g,stringOffsetType:y}=r,x=Ae(y),T=new x(o[g]);p=T[m+1]-T[m],m=T[m]}const d=new Uint8Array(h.buffer,m,p);i=new TextDecoder().decode(d)}else if(a==="BOOLEAN"){const m=f+s,p=Math.floor(m/8),d=m%8;i=(h[p]>>d&1)===1}return i}getPropertyValue(e,t,s=null){if(t>=this.count)throw new Error("PropertyTableAccessor: Requested index is outside the range of the table.");const i=this.properties[e];if(i){if(!this.definition.properties[e])return i.resolveDefault(s)}else throw new Error("PropertyTableAccessor: Requested property does not exist.");const r=i.array,n=this.data,a=i.getArrayLengthFromId(n,t);if(s=i.shapeToProperty(s,a),r)for(let o=0,c=s.length;o<c;o++)s[o]=this._readValueAtIndex(e,t,o,s[o]);else s=this._readValueAtIndex(e,t,0,s);return s=i.adjustValueScaleOffset(s),s=i.resolveEnumsToStrings(s),s=i.resolveNoData(s),s}}const xe=new Ts;class gt{constructor(){this._renderer=new ms,this._target=new tt(1,1),this._texTarget=new tt,this._quad=new Bt(new gs({blending:bs,blendDst:xs,blendSrc:ys,uniforms:{map:{value:null},pixel:{value:new Q}},vertexShader:`
				void main() {

					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

				}
			`,fragmentShader:`
				uniform sampler2D map;
				uniform ivec2 pixel;

				void main() {

					gl_FragColor = texelFetch( map, pixel, 0 );

				}
			`}))}increaseSizeTo(e){this._target.setSize(Math.max(this._target.width,e),1)}readDataAsync(e){const{_renderer:t,_target:s}=this;return t.readRenderTargetPixelsAsync(s,0,0,e.length/4,1,e)}readData(e){const{_renderer:t,_target:s}=this;t.readRenderTargetPixels(s,0,0,e.length/4,1,e)}renderPixelToTarget(e,t,s){const{_renderer:i,_target:r}=this;xe.min.copy(t),xe.max.copy(t),xe.max.x+=1,xe.max.y+=1,i.initRenderTarget(r),i.copyTextureToTexture(e,r.texture,xe,s,0)}}const ce=new class{constructor(){let l=null;Object.getOwnPropertyNames(gt.prototype).forEach(e=>{e!=="constructor"&&(this[e]=(...t)=>(l=l||new gt,l[e](...t)))})}},yt=new Q,xt=new Q,bt=new Q;function ii(l,e){return e===0?l.getAttribute("uv"):l.getAttribute(`uv${e}`)}function Yt(l,e,t=new Array(3)){let s=3*e,i=3*e+1,r=3*e+2;return l.index&&(s=l.index.getX(s),i=l.index.getX(i),r=l.index.getX(r)),t[0]=s,t[1]=i,t[2]=r,t}function Qt(l,e,t,s,i){const[r,n,a]=s,o=ii(l,e);yt.fromBufferAttribute(o,r),xt.fromBufferAttribute(o,n),bt.fromBufferAttribute(o,a),i.set(0,0,0).addScaledVector(yt,t.x).addScaledVector(xt,t.y).addScaledVector(bt,t.z)}function Zt(l,e,t,s){const i=l.x-Math.floor(l.x),r=l.y-Math.floor(l.y),n=Math.floor(i*e%e),a=Math.floor(r*t%t);return s.set(n,a),s}const Tt=new Q,vt=new Q,At=new Q;class ri extends ke{constructor(e,t,s=null){super(e,t,s),this.channels=$(s,"channels",[0]),this.index=$(s,"index",null),this.texCoord=$(s,"texCoord",null),this.valueLength=parseInt(this.type.replace(/[^0-9]/g,""))||1}readDataFromBuffer(e,t,s=null){const i=this.type;if(i==="BOOLEAN"||i==="STRING")throw new Error("PropertyTextureAccessor: BOOLEAN and STRING types not supported.");return Wt(e,t*this.valueLength,i,s)}}class ni extends Qe{constructor(...e){super(...e),this.isPropertyTextureAccessor=!0,this._asyncRead=!1,this._initProperties(ri)}getData(e,t,s,i={}){const r=this.properties;Ie(r,i);const n=Object.keys(r),a=n.map(o=>i[o]);return this.getPropertyValuesAtTexel(n,e,t,s,a),n.forEach((o,c)=>i[o]=a[c]),i}async getDataAsync(e,t,s,i={}){const r=this.properties;Ie(r,i);const n=Object.keys(r),a=n.map(o=>i[o]);return await this.getPropertyValuesAtTexelAsync(n,e,t,s,a),n.forEach((o,c)=>i[o]=a[c]),i}getPropertyValuesAtTexelAsync(...e){this._asyncRead=!0;const t=this.getPropertyValuesAtTexel(...e);return this._asyncRead=!1,t}getPropertyValuesAtTexel(e,t,s,i,r=[]){for(;r.length<e.length;)r.push(null);r.length=e.length,ce.increaseSizeTo(r.length);const n=this.data,a=this.definition.properties,o=this.properties,c=Yt(i,t);for(let f=0,m=e.length;f<m;f++){const p=e[f];if(!a[p])continue;const d=o[p],g=n[d.index];Qt(i,d.texCoord,s,c,Tt),Zt(Tt,g.image.width,g.image.height,vt),At.set(f,0),ce.renderPixelToTarget(g,vt,At)}const u=new Uint8Array(e.length*4);if(this._asyncRead)return ce.readDataAsync(u).then(()=>(h.call(this),r));return ce.readData(u),h.call(this),r;function h(){for(let f=0,m=e.length;f<m;f++){const p=e[f],d=o[p],g=d.type;if(r[f]=Ye(d,r[f]),d){if(!a[p]){r[f]=d.resolveDefault(r);continue}}else throw new Error("PropertyTextureAccessor: Requested property does not exist.");const y=d.valueLength*(d.count||1),x=d.channels.map(M=>u[4*f+M]),T=d.componentType,b=Ae(T,g),v=new b(y);if(new Uint8Array(v.buffer).set(x),d.array){const M=r[f];for(let P=0,S=M.length;P<S;P++)M[P]=d.readDataFromBuffer(v,P,M[P])}else r[f]=d.readDataFromBuffer(v,0,r[f]);r[f]=d.adjustValueScaleOffset(r[f]),r[f]=d.resolveEnumsToStrings(r[f]),r[f]=d.resolveNoData(r[f])}}}dispose(){this.data.forEach(e=>{e&&(e.dispose(),e.image instanceof ImageBitmap&&e.image.close())})}}class _t{constructor(e,t,s,i=null,r=null){const{schema:n,propertyTables:a=[],propertyTextures:o=[],propertyAttributes:c=[]}=e,{enums:u,classes:h}=n,f=a.map(d=>new si(d,h,u,s));let m=[],p=[];i&&(i.propertyTextures&&(m=i.propertyTextures.map(d=>new ni(o[d],h,u,t))),i.propertyAttributes&&(p=i.propertyAttributes.map(d=>new ei(c[d],h,u)))),this.schema=n,this.tableAccessors=f,this.textureAccessors=m,this.attributeAccessors=p,this.object=r,this.textures=t,this.nodeMetadata=i}getPropertyTableData(e,t,s=null){if(!Array.isArray(e)||!Array.isArray(t))s=s||{},s=this.tableAccessors[e].getData(t,s);else{s=s||[];const i=Math.min(e.length,t.length);s.length=i;for(let r=0;r<i;r++){const n=this.tableAccessors[e[r]];s[r]=n.getData(t[r],s[r])}}return s}getPropertyTableInfo(e=null){if(e===null&&(e=this.tableAccessors.map((t,s)=>s)),Array.isArray(e))return e.map(t=>{const s=this.tableAccessors[t];return{name:s.name,className:s.definition.class}});{const t=this.tableAccessors[e];return{name:t.name,className:t.definition.class}}}getPropertyTextureData(e,t,s=[]){const i=this.textureAccessors;s.length=i.length;for(let r=0;r<i.length;r++){const n=i[r];s[r]=n.getData(e,t,this.object.geometry,s[r])}return s}async getPropertyTextureDataAsync(e,t,s=[]){const i=this.textureAccessors;s.length=i.length;const r=[];for(let n=0;n<i.length;n++){const a=i[n].getDataAsync(e,t,this.object.geometry,s[n]).then(o=>{s[n]=o});r.push(a)}return await Promise.all(r),s}getPropertyTextureInfo(){return this.textureAccessors}getPropertyAttributeData(e,t=[]){const s=this.attributeAccessors;t.length=s.length;for(let i=0;i<s.length;i++){const r=s[i];t[i]=r.getData(e,this.object.geometry,t[i])}return t}getPropertyAttributeInfo(){return this.attributeAccessors.map(e=>({name:e.name,className:e.definition.class}))}dispose(){this.textureAccessors.forEach(e=>e.dispose()),this.tableAccessors.forEach(e=>e.dispose()),this.attributeAccessors.forEach(e=>e.dispose())}}const be="EXT_structural_metadata";function ai(l,e=[]){var t;const s=((t=l.json.textures)==null?void 0:t.length)||0,i=new Array(s).fill(null);return e.forEach(({properties:r})=>{for(const n in r){const{index:a}=r[n];i[a]===null&&(i[a]=l.loadTexture(a))}}),Promise.all(i)}function oi(l,e=[]){var t;const s=((t=l.json.bufferViews)==null?void 0:t.length)||0,i=new Array(s).fill(null);return e.forEach(({properties:r})=>{for(const n in r){const{values:a,arrayOffsets:o,stringOffsets:c}=r[n];i[a]===null&&(i[a]=l.loadBufferView(a)),i[o]===null&&(i[o]=l.loadBufferView(o)),i[c]===null&&(i[c]=l.loadBufferView(c))}}),Promise.all(i)}class li{constructor(e){this.parser=e,this.name=be}async afterRoot({scene:e,parser:t}){const s=t.json.extensionsUsed;if(!s||!s.includes(be))return;let i=null,r=t.json.extensions[be];if(r.schemaUri){const{manager:c,path:u,requestHeader:h,crossOrigin:f}=t.options,m=new URL(r.schemaUri,u).toString(),p=new vs(c);p.setCrossOrigin(f),p.setResponseType("json"),p.setRequestHeader(h),i=p.loadAsync(m).then(d=>{r={...r,schema:d}})}const[n,a]=await Promise.all([ai(t,r.propertyTextures),oi(t,r.propertyTables),i]),o=new _t(r,n,a);e.userData.structuralMetadata=o,e.traverse(c=>{var u;if(t.associations.has(c)){const{meshes:h,primitives:f}=t.associations.get(c),m=(u=t.json.meshes[h])==null?void 0:u.primitives[f];if(m&&m.extensions&&m.extensions[be]){const p=m.extensions[be];c.userData.structuralMetadata=new _t(r,n,a,p,c)}else c.userData.structuralMetadata=o}})}}const Lt=new Q,wt=new Q,Mt=new Q;function ci(l){return l.x>l.y&&l.x>l.z?0:l.y>l.z?1:2}class ui{constructor(e,t,s){this.geometry=e,this.textures=t,this.data=s,this._asyncRead=!1,this.featureIds=s.featureIds.map(i=>{const{texture:r,...n}=i,a={label:null,propertyTable:null,nullFeatureId:null,...n};return r&&(a.texture={texCoord:0,channels:[0],...r}),a})}getTextures(){return this.textures}getFeatureInfo(){return this.featureIds}getFeaturesAsync(...e){this._asyncRead=!0;const t=this.getFeatures(...e);return this._asyncRead=!1,t}getFeatures(e,t){const{geometry:s,textures:i,featureIds:r}=this,n=new Array(r.length).fill(null),a=r.length;ce.increaseSizeTo(a);const o=Yt(s,e),c=o[ci(t)];for(let f=0,m=r.length;f<m;f++){const p=r[f],d="nullFeatureId"in p?p.nullFeatureId:null;if("texture"in p){const g=i[p.texture.index];Qt(s,p.texture.texCoord,t,o,Lt),Zt(Lt,g.image.width,g.image.height,wt),Mt.set(f,0),ce.renderPixelToTarget(i[p.texture.index],wt,Mt)}else if("attribute"in p){const g=s.getAttribute(`_feature_id_${p.attribute}`).getX(c);g!==d&&(n[f]=g)}else{const g=c;g!==d&&(n[f]=g)}}const u=new Uint8Array(a*4);if(this._asyncRead)return ce.readDataAsync(u).then(()=>(h(),n));return ce.readData(u),h(),n;function h(){const f=new Uint32Array(1);for(let m=0,p=r.length;m<p;m++){const d=r[m],g="nullFeatureId"in d?d.nullFeatureId:null;if("texture"in d){const{channels:y}=d.texture,x=y.map(b=>u[4*m+b]);new Uint8Array(f.buffer).set(x);const T=f[0];T!==g&&(n[m]=T)}}}}dispose(){this.textures.forEach(e=>{e&&(e.dispose(),e.image instanceof ImageBitmap&&e.image.close())})}}const Ue="EXT_mesh_features";function Pt(l,e,t){l.traverse(s=>{var i;if(e.associations.has(s)){const{meshes:r,primitives:n}=e.associations.get(s),a=(i=e.json.meshes[r])==null?void 0:i.primitives[n];a&&a.extensions&&a.extensions[Ue]&&t(s,a.extensions[Ue])}})}class hi{constructor(e){this.parser=e,this.name=Ue}async afterRoot({scene:e,parser:t}){var s;const i=t.json.extensionsUsed;if(!i||!i.includes(Ue))return;const r=((s=t.json.textures)==null?void 0:s.length)||0,n=new Array(r).fill(null);Pt(e,t,(o,{featureIds:c})=>{c.forEach(u=>{if(u.texture&&n[u.texture.index]===null){const h=u.texture.index;n[h]=t.loadTexture(h)}})});const a=await Promise.all(n);Pt(e,t,(o,c)=>{o.userData.meshFeatures=new ui(o.geometry,a,c)})}}class di{constructor(){this.name="CESIUM_RTC"}afterRoot(e){if(e.parser.json.extensions&&e.parser.json.extensions.CESIUM_RTC){const{center:t}=e.parser.json.extensions.CESIUM_RTC;t&&(e.scene.position.x+=t[0],e.scene.position.y+=t[1],e.scene.position.z+=t[2])}}}class Wi{constructor(e){e={metadata:!0,rtc:!0,plugins:[],dracoLoader:null,ktxLoader:null,meshoptDecoder:null,autoDispose:!0,...e},this.tiles=null,this.metadata=e.metadata,this.rtc=e.rtc,this.plugins=e.plugins,this.dracoLoader=e.dracoLoader,this.ktxLoader=e.ktxLoader,this.meshoptDecoder=e.meshoptDecoder,this._gltfRegex=/\.(gltf|glb)$/g,this._dracoRegex=/\.drc$/g,this._loader=null}init(e){const t=new ss(e.manager);this.dracoLoader&&(t.setDRACOLoader(this.dracoLoader),e.manager.addHandler(this._dracoRegex,this.dracoLoader)),this.ktxLoader&&t.setKTX2Loader(this.ktxLoader),this.meshoptDecoder&&t.setMeshoptDecoder(this.meshoptDecoder),this.rtc&&t.register(()=>new di),this.metadata&&(t.register(()=>new li),t.register(()=>new hi)),this.plugins.forEach(s=>t.register(s)),e.manager.addHandler(this._gltfRegex,t),this.tiles=e,this._loader=t}dispose(){this.tiles.manager.removeHandler(this._gltfRegex),this.tiles.manager.removeHandler(this._dracoRegex),this.autoDispose&&(this.ktxLoader.dispose(),this.dracoLoader.dispose())}}class Yi{set delay(e){this.deferCallbacks.delay=e}get delay(){return this.deferCallbacks.delay}set bytesTarget(e){this.lruCache.minBytesSize=e}get bytesTarget(){return this.lruCache.minBytesSize}get estimatedGpuBytes(){return this.lruCache.cachedBytes}constructor(e={}){const{delay:t=0,bytesTarget:s=0}=e;this.name="UNLOAD_TILES_PLUGIN",this.tiles=null,this.lruCache=new ts,this.deferCallbacks=new pi,this.delay=t,this.bytesTarget=s}init(e){this.tiles=e;const{lruCache:t,deferCallbacks:s}=this;s.callback=r=>{t.markUnused(r),t.scheduleUnload(!1)};const i=r=>{const n=r.cached.scene;e.visibleTiles.has(r)||e.invokeOnePlugin(a=>a.unloadTileFromGPU&&a.unloadTileFromGPU(n,r))};this._onUpdateBefore=()=>{t.unloadPriorityCallback=e.lruCache.unloadPriorityCallback,t.computeMemoryUsageCallback=e.lruCache.computeMemoryUsageCallback,t.minSize=1/0,t.maxSize=1/0,t.maxBytesSize=1/0,t.unloadPercent=1,t.autoMarkUnused=!1},this._onVisibilityChangeCallback=({tile:r,visible:n})=>{n?(t.add(r,i),e.markTileUsed(r),s.cancel(r)):s.run(r)},e.forEachLoadedModel((r,n)=>{const a=e.visibleTiles.has(n);this._onVisibilityChangeCallback({scene:r,visible:a})}),e.addEventListener("tile-visibility-change",this._onVisibilityChangeCallback),e.addEventListener("update-before",this._onUpdateBefore)}unloadTileFromGPU(e,t){e&&e.traverse(s=>{if(s.material){const i=s.material;i.dispose();for(const r in i){const n=i[r];n&&n.isTexture&&n.dispose()}}s.geometry&&s.geometry.dispose()})}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._onVisibilityChangeCallback),this.tiles.removeEventListener("update-before",this._onUpdateBefore),this.deferCallbacks.cancelAll()}}class pi{constructor(e=()=>{}){this.map=new Map,this.callback=e,this.delay=0}run(e){const{map:t,delay:s}=this;if(t.has(e))throw new Error("DeferCallbackManager: Callback already initialized.");s===0?this.callback(e):t.set(e,setTimeout(()=>this.callback(e),s))}cancel(e){const{map:t}=this;t.has(e)&&(clearTimeout(t.get(e)),t.delete(e))}cancelAll(){this.map.forEach((e,t)=>{this.cancel(t)})}}const{clamp:He}=_;class fi{constructor(){this.duration=250,this.fadeCount=0,this._lastTick=-1,this._fadeState=new Map,this.onFadeComplete=null,this.onFadeStart=null,this.onFadeSetComplete=null,this.onFadeSetStart=null}deleteObject(e){e&&this.completeFade(e)}guaranteeState(e){const t=this._fadeState;if(t.has(e))return!1;const s={fadeInTarget:0,fadeOutTarget:0,fadeIn:0,fadeOut:0};return t.set(e,s),!0}completeFade(e){const t=this._fadeState;if(!t.has(e))return;const s=t.get(e).fadeOutTarget===0;t.delete(e),this.fadeCount--,this.onFadeComplete&&this.onFadeComplete(e,s),this.fadeCount===0&&this.onFadeSetComplete&&this.onFadeSetComplete()}completeAllFades(){this._fadeState.forEach((e,t)=>{this.completeFade(t)})}forEachObject(e){this._fadeState.forEach((t,s)=>{e(s,t)})}fadeIn(e){const t=this.guaranteeState(e),s=this._fadeState.get(e);s.fadeInTarget=1,s.fadeOutTarget=0,s.fadeOut=0,t&&(this.fadeCount++,this.fadeCount===1&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(e))}fadeOut(e){const t=this.guaranteeState(e),s=this._fadeState.get(e);s.fadeOutTarget=1,t&&(s.fadeInTarget=1,s.fadeIn=1,this.fadeCount++,this.fadeCount===1&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(e))}isFading(e){return this._fadeState.has(e)}isFadingOut(e){const t=this._fadeState.get(e);return t&&t.fadeOutTarget===1}update(){const e=window.performance.now();this._lastTick===-1&&(this._lastTick=e);const t=He((e-this._lastTick)/this.duration,0,1);this._lastTick=e,this._fadeState.forEach((s,i)=>{const{fadeOutTarget:r,fadeInTarget:n}=s;let{fadeOut:a,fadeIn:o}=s;const c=Math.sign(n-o);o=He(o+c*t,0,1);const u=Math.sign(r-a);a=He(a+u*t,0,1),s.fadeIn=o,s.fadeOut=a,((a===1||a===0)&&(o===1||o===0)||a>=o)&&this.completeFade(i)})}}const qe=Symbol("FADE_PARAMS");function Kt(l,e){if(l[qe])return l[qe];const t={fadeIn:{value:0},fadeOut:{value:0},fadeTexture:{value:null}};return l[qe]=t,l.defines={...l.defines||{},FEATURE_FADE:0},l.onBeforeCompile=s=>{e&&e(s),s.uniforms={...s.uniforms,...t},s.vertexShader=s.vertexShader.replace(/void\s+main\(\)\s+{/,i=>`
					#ifdef USE_BATCHING_FRAG

					varying float vBatchId;

					#endif

					${i}

						#ifdef USE_BATCHING_FRAG

						// add 0.5 to the value to avoid floating error that may cause flickering
						vBatchId = getIndirectIndex( gl_DrawID ) + 0.5;

						#endif
				`),s.fragmentShader=s.fragmentShader.replace(/void main\(/,i=>`
				#if FEATURE_FADE

				// adapted from https://www.shadertoy.com/view/Mlt3z8
				float bayerDither2x2( vec2 v ) {

					return mod( 3.0 * v.y + 2.0 * v.x, 4.0 );

				}

				float bayerDither4x4( vec2 v ) {

					vec2 P1 = mod( v, 2.0 );
					vec2 P2 = floor( 0.5 * mod( v, 4.0 ) );
					return 4.0 * bayerDither2x2( P1 ) + bayerDither2x2( P2 );

				}

				// the USE_BATCHING define is not available in fragment shaders
				#ifdef USE_BATCHING_FRAG

				// functions for reading the fade state of a given batch id
				uniform sampler2D fadeTexture;
				varying float vBatchId;
				vec2 getFadeValues( const in float i ) {

					int size = textureSize( fadeTexture, 0 ).x;
					int j = int( i );
					int x = j % size;
					int y = j / size;
					return texelFetch( fadeTexture, ivec2( x, y ), 0 ).rg;

				}

				#else

				uniform float fadeIn;
				uniform float fadeOut;

				#endif

				#endif

				${i}
			`).replace(/#include <dithering_fragment>/,i=>`

				${i}

				#if FEATURE_FADE

				#ifdef USE_BATCHING_FRAG

				vec2 fadeValues = getFadeValues( vBatchId );
				float fadeIn = fadeValues.r;
				float fadeOut = fadeValues.g;

				#endif

				float bayerValue = bayerDither4x4( floor( mod( gl_FragCoord.xy, 4.0 ) ) );
				float bayerBins = 16.0;
				float dither = ( 0.5 + bayerValue ) / bayerBins;
				if ( dither >= fadeIn ) {

					discard;

				}

				if ( dither < fadeOut ) {

					discard;

				}

				#endif

			`)},t}class mi{constructor(){this._fadeParams=new WeakMap,this.fading=0}setFade(e,t,s){if(!e)return;const i=this._fadeParams;e.traverse(r=>{const n=r.material;if(n&&i.has(n)){const a=i.get(n);a.fadeIn.value=t,a.fadeOut.value=s;const o=+(!(t===0||t===1)||!(s===0||s===1));n.defines.FEATURE_FADE!==o&&(this.fading+=o===1?1:-1,n.defines.FEATURE_FADE=o,n.needsUpdate=!0)}})}prepareScene(e){e.traverse(t=>{t.material&&this.prepareMaterial(t.material)})}deleteScene(e){if(!e)return;this.setFade(e,1,0);const t=this._fadeParams;e.traverse(s=>{const i=s.material;i&&t.delete(i)})}prepareMaterial(e){const t=this._fadeParams;t.has(e)||t.set(e,Kt(e,e.onBeforeCompile))}}class gi{constructor(e,t=new $e){this.other=e,this.material=t,this.visible=!0,this.parent=null,this._instanceInfo=[],this._visibilityChanged=!0;const s=new Proxy(this,{get(i,r){if(r in i)return i[r];{const n=e[r];return n instanceof Function?(...a)=>(i.syncInstances(),n.call(s,...a)):e[r]}},set(i,r,n){return r in i?i[r]=n:e[r]=n,!0},deleteProperty(i,r){return r in i?delete i[r]:delete e[r]}});return s}syncInstances(){const e=this._instanceInfo,t=this.other._instanceInfo;for(;t.length>e.length;){const s=e.length;e.push(new Proxy({visible:!1},{get(i,r){return r in i?i[r]:t[s][r]},set(i,r,n){return r in i?i[r]=n:t[s][r]=n,!0}}))}}}class yi extends gi{constructor(...e){super(...e);const t=this.material,s=Kt(t,t.onBeforeCompile);t.defines.FEATURE_FADE=1,t.defines.USE_BATCHING_FRAG=1,t.needsUpdate=!0,this.fadeTexture=null,this._fadeParams=s}setFadeAt(e,t,s){this._initFadeTexture(),this.fadeTexture.setValueAt(e,t*255,s*255)}_initFadeTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const t=e*e*2,s=this.fadeTexture;if(!s||s.image.data.length!==t){const i=new Uint8Array(t),r=new xi(i,e,e,Ot,Nt);if(s){s.dispose();const n=s.image.data,a=this.fadeTexture.image.data,o=Math.min(n.length,a.length);a.set(new n.constructor(n.buffer,0,o))}this.fadeTexture=r,this._fadeParams.fadeTexture.value=r,r.needsUpdate=!0}}dispose(){this.fadeTexture&&this.fadeTexture.dispose()}}class xi extends We{setValueAt(e,...t){const{data:s,width:i,height:r}=this.image,n=Math.floor(s.length/(i*r));let a=!1;for(let o=0;o<n;o++){const c=e*n+o,u=s[c],h=t[o]||0;u!==h&&(s[c]=h,a=!0)}a&&(this.needsUpdate=!0)}}const St=Symbol("HAS_POPPED_IN"),Ct=new O,Et=new O,It=new Gt,Ut=new Gt,Rt=new O;function bi(){const l=this._fadeManager,e=this.tiles;this._fadingBefore=l.fadeCount,this._displayActiveTiles=e.displayActiveTiles,e.displayActiveTiles=!0}function Ti(){const l=this._fadeManager,e=this._fadeMaterialManager,t=this._displayActiveTiles,s=this._fadingBefore,i=this._prevCameraTransforms,{tiles:r,maximumFadeOutTiles:n,batchedMesh:a}=this,{cameras:o}=r;r.displayActiveTiles=t,l.update();const c=l.fadeCount;if(s!==0&&c!==0&&(r.dispatchEvent({type:"fade-change"}),r.dispatchEvent({type:"needs-render"})),t||r.visibleTiles.forEach(u=>{const h=u.cached.scene;h&&(h.visible=u.__inFrustum),this.forEachBatchIds(u,(f,m,p)=>{m.setVisibleAt(f,u.__inFrustum),p.batchedMesh.setVisibleAt(f,u.__inFrustum)})}),n<this._fadingOutCount){let u=!0;o.forEach(h=>{if(!i.has(h))return;const f=h.matrixWorld,m=i.get(h);f.decompose(Et,Ut,Rt),m.decompose(Ct,It,Rt);const p=Ut.angleTo(It),d=Et.distanceTo(Ct);u=u&&(p>.25||d>.1)}),u&&l.completeAllFades()}if(o.forEach(u=>{i.get(u).copy(u.matrixWorld)}),l.forEachObject((u,{fadeIn:h,fadeOut:f})=>{const m=u.cached.scene,p=l.isFadingOut(u);r.markTileUsed(u),m&&(e.setFade(m,h,f),p&&(m.visible=!0)),this.forEachBatchIds(u,(d,g,y)=>{g.setFadeAt(d,h,f),g.setVisibleAt(d,!0),y.batchedMesh.setVisibleAt(d,!1)})}),a){const u=r.getPluginByName("BATCHED_TILES_PLUGIN").batchedMesh.material;a.material.map=u.map}}class Qi{get fadeDuration(){return this._fadeManager.duration}set fadeDuration(e){this._fadeManager.duration=Number(e)}get fadingTiles(){return this._fadeManager.fadeCount}constructor(e){e={maximumFadeOutTiles:50,fadeRootTiles:!1,fadeDuration:250,...e},this.name="FADE_TILES_PLUGIN",this.priority=-2,this.tiles=null,this.batchedMesh=null,this._quickFadeTiles=new Set,this._fadeManager=new fi,this._fadeMaterialManager=new mi,this._prevCameraTransforms=null,this._fadingOutCount=0,this.maximumFadeOutTiles=e.maximumFadeOutTiles,this.fadeRootTiles=e.fadeRootTiles,this.fadeDuration=e.fadeDuration}init(e){this._onLoadModel=({scene:i})=>{this._fadeMaterialManager.prepareScene(i)},this._onDisposeModel=({tile:i,scene:r})=>{this.tiles.visibleTiles.has(i)&&this._quickFadeTiles.add(i.parent),this._fadeManager.deleteObject(i),this._fadeMaterialManager.deleteScene(r)},this._onAddCamera=({camera:i})=>{this._prevCameraTransforms.set(i,new me)},this._onDeleteCamera=({camera:i})=>{this._prevCameraTransforms.delete(i)},this._onTileVisibilityChange=({tile:i,visible:r})=>{const n=i.cached.scene;n&&(n.visible=!0),this.forEachBatchIds(i,(a,o,c)=>{o.setFadeAt(a,0,0),o.setVisibleAt(a,!1),c.batchedMesh.setVisibleAt(a,!1)})},this._onUpdateBefore=()=>{bi.call(this)},this._onUpdateAfter=()=>{Ti.call(this)},e.addEventListener("load-model",this._onLoadModel),e.addEventListener("dispose-model",this._onDisposeModel),e.addEventListener("add-camera",this._onAddCamera),e.addEventListener("delete-camera",this._onDeleteCamera),e.addEventListener("update-before",this._onUpdateBefore),e.addEventListener("update-after",this._onUpdateAfter),e.addEventListener("tile-visibility-change",this._onTileVisibilityChange);const t=this._fadeManager;t.onFadeSetStart=()=>{e.dispatchEvent({type:"fade-start"}),e.dispatchEvent({type:"needs-render"})},t.onFadeSetComplete=()=>{e.dispatchEvent({type:"fade-end"}),e.dispatchEvent({type:"needs-render"})},t.onFadeComplete=(i,r)=>{this._fadeMaterialManager.setFade(i.cached.scene,0,0),this.forEachBatchIds(i,(n,a,o)=>{a.setFadeAt(n,0,0),a.setVisibleAt(n,!1),o.batchedMesh.setVisibleAt(n,r)}),r||(e.invokeOnePlugin(n=>n!==this&&n.setTileVisible&&n.setTileVisible(i,!1)),this._fadingOutCount--)};const s=new Map;e.cameras.forEach(i=>{s.set(i,new me)}),e.forEachLoadedModel((i,r)=>{this._onLoadModel({scene:i})}),this.tiles=e,this._fadeManager=t,this._prevCameraTransforms=s}initBatchedMesh(){var e;const t=(e=this.tiles.getPluginByName("BATCHED_TILES_PLUGIN"))==null?void 0:e.batchedMesh;if(t){if(this.batchedMesh===null){this._onBatchedMeshDispose=()=>{this.batchedMesh.dispose(),this.batchedMesh.removeFromParent(),this.batchedMesh=null,t.removeEventListener("dispose",this._onBatchedMeshDispose)};const s=t.material.clone();s.onBeforeCompile=t.material.onBeforeCompile,this.batchedMesh=new yi(t,s),this.tiles.group.add(this.batchedMesh)}}else this.batchedMesh!==null&&(this._onBatchedMeshDispose(),this._onBatchedMeshDispose=null)}setTileVisible(e,t){const s=this._fadeManager,i=s.isFading(e);if(s.isFadingOut(e)&&this._fadingOutCount--,t?e.__depthFromRenderedParent===1?((e[St]||this.fadeRootTiles)&&this._fadeManager.fadeIn(e),e[St]=!0):this._fadeManager.fadeIn(e):(this._fadingOutCount++,s.fadeOut(e)),this._quickFadeTiles.has(e)&&(this._fadeManager.completeFade(e),this._quickFadeTiles.delete(e)),i)return!0;const r=this._fadeManager.isFading(e);return!!(!t&&r)}dispose(){const e=this.tiles;this._fadeManager.completeAllFades(),this.batchedMesh!==null&&this._onBatchedMeshDispose(),e.removeEventListener("load-model",this._onLoadModel),e.removeEventListener("dispose-model",this._onDisposeModel),e.removeEventListener("add-camera",this._onAddCamera),e.removeEventListener("delete-camera",this._onDeleteCamera),e.removeEventListener("update-before",this._onUpdateBefore),e.removeEventListener("update-after",this._onUpdateAfter),e.removeEventListener("tile-visibility-change",this._onTileVisibilityChange),e.forEachLoadedModel((t,s)=>{this._fadeManager.deleteObject(s),t&&(t.visible=!0)})}forEachBatchIds(e,t){if(this.initBatchedMesh(),this.batchedMesh){const s=this.tiles.getPluginByName("BATCHED_TILES_PLUGIN"),i=s.getTileBatchIds(e);i&&i.forEach(r=>{t(r,this.batchedMesh,s)})}}}new me;new O;new O;new Re;new Bt(new $e);const vi=new We(new Uint8Array([255,255,255,255]),1,1);vi.needsUpdate=!0;new O;export{qi as Br,$i as Dr,Yi as Fr,Qi as Nr,Wi as Or,Xi as Ur};
