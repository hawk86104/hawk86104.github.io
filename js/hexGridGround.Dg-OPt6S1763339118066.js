import{n as e,_ as i,o as a,K as n}from"./@tresjs.DhQ48cWv1763339118066.js";import{P as s}from"./tweakpane.CqZAnw7f1763339118066.js";import{_ as o}from"./reflectorDUDV.vue_vue_type_script_setup_true_lang.DNNK2ETe1763339118066.js";import{d as t,w as r,b as d,o as l,u,G as v,I as m,h as c,m as f,r as g,g as p,e as h}from"./@vue.D9fSGD371763339118066.js";import{y as x,a6 as w}from"./three.k2YzZXGk1763339118066.js";import"./postprocessing.DOPl5nnp1763339118066.js";import"./@vueuse.B6dgVg3U1763339118066.js";import"./dither.glsl.tNAdkJUa1763339118066.js";import"./Reflector.D6sZOZyZ1763339118066.js";import"./OimoPhysicsBuffer.BkVte0M41763339118066.js";import"./oimophysics.CfVKSiAm1763339118066.js";import"./vite-plugin-qiankun.B06WoCqG1763339118066.js";import"./utils.CNife3_q1763339118066.js";const b=t({__name:"hexGridMaterial",props:{baseMaterial:{default:x},speed:{default:1},gridWeight:{default:.03},raisedBottom:{default:.05},waveFrequency:{default:.2},wavePow:{default:4},division:{default:32},divisionScaleX:{default:1},direction:{default:4},isReversed:{default:!1},hasMaskTexture:{default:!1},maskTexture:{default:""}},setup(n){const s=n,o={gridWeight:{value:s.gridWeight},raisedBottom:{value:s.raisedBottom},waveFrequency:{value:s.waveFrequency},wavePow:{value:s.wavePow},direction:{value:s.direction},isReversed:{value:s.isReversed},hasMaskTexture:{value:s.hasMaskTexture},maskTexture:{value:null},division:{value:s.division},divisionScaleX:{value:s.divisionScaleX},time:{value:0}};if(s.maskTexture){const{state:i}=e(s.maskTexture);o.maskTexture=i}r(()=>[s.gridWeight,s.raisedBottom,s.waveFrequency,s.wavePow,s.division,s.divisionScaleX,s.direction,s.isReversed,s.hasMaskTexture],([e,i,a,n,s,t,r,d,l])=>{o.gridWeight.value=e,o.raisedBottom.value=i,o.waveFrequency.value=a,o.wavePow.value=n,o.division.value=s,o.divisionScaleX.value=t,o.direction.value=r,o.isReversed.value=d,o.hasMaskTexture.value=l});const{onBeforeRender:t}=i();return t(({delta:e})=>{o.time.value+=e*s.speed}),(e,i)=>(l(),d(u(a),{baseMaterial:n.baseMaterial,vertexShader:"\nvarying vec2 uvPosition;\nvoid main() {\n    uvPosition = uv;\n}\n",side:w,transparent:"",fragmentShader:u("varying vec2 uvPosition;\n\nuniform float time;\n\nuniform float raisedBottom;\nuniform float waveFrequency;\nuniform float wavePow;\nuniform int direction;\n\nuniform float division;\nuniform float divisionScaleX;\n\nuniform bool hasMaskTexture;\nuniform sampler2D maskTexture;\n\nuniform bool isReversed;\n\nuniform float gridWeight;\n\nfloat hexDist(vec2 p) {\n  p = abs(p);\n  float d = dot(p, normalize(vec2(1.0, 1.73)));\n  return max(d, p.x);\n}\nvec4 hexCoords(vec2 uv) {\n  vec2 r = vec2(1.0, 1.73);\n  vec2 h = r * 0.5;\n  vec2 a = mod(uv, r) - h;\n  vec2 b = mod(uv - h, r) - h;\n\n  vec2 gv = length(a) < length(b) ? a : b;\n  vec2 id = uv - gv;\n\n  float x = atan(gv.x, gv.y);\n  float y = 0.5 - hexDist(gv);\n\n  return vec4(x, y, id);\n}\n\nvoid main() {\n  vec2 uv = uvPosition * vec2(division * divisionScaleX, division);\n  vec4 hc = hexCoords(uv);\n  vec2 id = hc.zw;\n  float distance = id.y;\n  if (direction == 3) {\n    distance = id.x;\n  } else if (direction == 5) {\n    distance = length(id.xy);\n  } else if (direction == 6) {\n    vec2 center = vec2(0.5 * division * divisionScaleX, 0.5 * division);\n    distance = length(uv - center);\n  }\n  float wavy =\n      pow(sin((distance * waveFrequency - time)), wavePow) + raisedBottom;\n\n  float diffuseColorA = csm_DiffuseColor.a;\n  diffuseColorA *= wavy;\n\n  float mask = 1.0;\n  if (hasMaskTexture) {\n    vec2 uVm = id / vec2(division * divisionScaleX, division);\n    mask = texture2D(maskTexture, uVm).g;\n  }\n\n  float w = gridWeight + (1.0 - mask);\n  w = clamp(w, 0.0, 1.0);\n\n  float margin = clamp(w * 0.33, 0.00, 0.02);\n  float stepMax = w + margin;\n\n  float gridLine = smoothstep(w, stepMax, hc.y);\n  gridLine = isReversed ? 1.0 - gridLine : gridLine;\n  diffuseColorA *= gridLine;\n\n  \n  \n  csm_DiffuseColor.rgb *= diffuseColorA;\n\nfloat brightness = length(csm_DiffuseColor.rgb);\n\nfloat alphaBlend = smoothstep(0.0, 1.0, brightness);\n\ncsm_DiffuseColor.a *= alphaBlend;\n\ncsm_FragColor = vec4(csm_DiffuseColor.rgb, csm_DiffuseColor.a);\n}"),uniforms:o},null,8,["baseMaterial","side","fragmentShader"]))}}),y=["rotation"],B=t({__name:"hexGridMesh",setup(e){const i=x;return(e,a)=>(l(),v("TresMesh",{rotation:[-Math.PI/2,0,0]},[a[0]||(a[0]=m("TresPlaneGeometry",{args:[1,1]},null,-1)),c(b,f({baseMaterial:u(i)},e.$attrs,{maskTexture:"./plugins/floor/image/logoBlack.png"}),null,16,["baseMaterial"])],8,y))}}),k=t({__name:"hexGridGround",setup(e){const i=g({reflectivity:.8,showGridHelper:!1,scale:1}),a=g({color:"#de62f2",speed:1.9,gridWeight:.223,raisedBottom:.66,waveFrequency:.066,wavePow:19,division:46,divisionScaleX:1,isReversed:!1,direction:4,hasMaskTexture:!0}),t=new s({title:"hexGridGround",expanded:!0});return t.addBinding(a,"hasMaskTexture",{label:"图片纹理"}),t.addBinding(a,"color",{label:"颜色"}),t.addBinding(a,"speed",{label:"速度",min:-5,max:5,step:.1}),t.addBinding(a,"gridWeight",{label:"网格宽度",min:.001,max:.5,step:.001}),t.addBinding(a,"raisedBottom",{label:"渐变宽度",min:.001,max:1,step:.001}),t.addBinding(a,"waveFrequency",{label:"分段",min:.001,max:1,step:.001}),t.addBinding(a,"wavePow",{label:"渐变强度",min:1,max:30,step:.1}),t.addBinding(a,"division",{label:"网格整体缩放",min:.1,max:50,step:.1}),t.addBinding(a,"divisionScaleX",{label:"网格横向缩放",min:.1,max:10,step:.1}),t.addBinding(a,"isReversed",{label:"颜色取反"}),t.addBinding(a,"direction",{label:"方向类别",min:3,max:6,step:1}),(e,s)=>{const t=p("TresCanvas");return l(),d(t,{clearColor:"#666666","window-size":""},{default:h(()=>[s[0]||(s[0]=m("TresPerspectiveCamera",{position:[3,3,0],fov:45,near:.1,far:1e4},null,-1)),c(u(n),{enableDamping:"",autoRotate:""}),c(B,f(a,{scale:9}),null,16),c(o,f({position:[0,-.06,0]},i),null,16)]),_:1})}}});export{k as default};
