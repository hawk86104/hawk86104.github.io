import{e,m as n,o as t}from"./@tresjs.zc7faK4J1743660816268.js";import{aJ as o,bU as a,a as r,t as l,a7 as i,A as s,a6 as c,B as u,ak as v,al as m,u as f,_ as d,aq as g,m as p,l as h,c9 as b,c7 as x,c8 as y,V as T,cn as w,n as U,c2 as _,C as S}from"./three.2wx8FU0g1743660816268.js";import{d as D,o as N,H as B,N as C,u as P,F as j,w as F,j as k,z,e as E,g as A,aj as M,ak as $}from"./@vue.B5PFBfKs1743660816268.js";import{_ as G}from"./@fesjs.9AUNBPBQ1743660816268.js";import"./postprocessing.ApTwx-211743660816268.js";import"./@vueuse.jtbb8I7w1743660816268.js";import"./vue-router.K4ys0Z-O1743660816268.js";import"./lodash-es.IJc9G_SW1743660816268.js";import"./@qlin.o0hjOMCg1743660816268.js";import"./pinia.0dYyFDku1743660816268.js";import"./@floating-ui.HzHndBae1743660816268.js";import"./@juggle.4EyLec-41743660816268.js";var R="float N21(vec2 st){\n\treturn fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat smoothNoise(vec2 ip){\n\tvec2 lv=fract(ip);\n\tvec2 id=floor(ip);\n\t\n\tlv=lv*lv*(3.-2.*lv);\n\t\n\tfloat bl=N21(id);\n\tfloat br=N21(id+vec2(1,0));\n\tfloat b=mix(bl,br,lv.x);\n\t\n\tfloat tl=N21(id+vec2(0,1));\n\tfloat tr=N21(id+vec2(1,1));\n\tfloat t=mix(tl,tr,lv.x);\n\t\n\treturn clamp(mix(b,t,lv.y)*.5+.5,0.,1.);\n}\nfloat smoothNoise2(vec2 p){\n\tp.y+=time;\n\tp/=4.;\n\t\n\tfloat n=smoothNoise(p)*1.5;\n\tn+=smoothNoise(p*2.01)*.25;\n\tn+=smoothNoise(p*4.02)*.125;\n\tn+=smoothNoise(p*8.03)*.0625;\n\tn/=(1.5+.25+.125+.0625);\n\treturn clamp(n,0.,1.);\n}";const H=["geometry","material"],L=["material"],I=["rotateX"],V=100,q=D({__name:"lucesPlane",props:{globalUniforms:{}},setup(n){const t=n,u=[],v=[],m=new o(1,36,18),f=(new a).copy(m);f.instanceCount=V;const d=[];for(let e=0;e<V;e++){let e=r.randFloatSpread(49),n=r.randFloatSpread(49),t=r.randFloat(.0625,.125),o=r.randFloat(1,3);d.push(e,n,t),v.push(new l(e,n,o,r.randFloat(1,2))),u.push(new l(e,n,t,o))}f.setAttribute("instData",new i(new Float32Array(d),3));const g=new s({color:16720418,onBeforeCompile:e=>{e.uniforms.noiseTex=t.globalUniforms.noise,e.vertexShader=`\n      uniform sampler2D noiseTex;\n      attribute vec4 instData;\n      ${e.vertexShader}\n    `.replace("#include <begin_vertex>","#include <begin_vertex>\n      transformed = position * instData.z;\n      \n      transformed.x += instData.x;\n      transformed.z += instData.y;\n      vec2 nUv = (vec2(instData.x, -instData.y) - vec2(-25.)) / 50.;\n      float h = texture2D(noiseTex, nUv).g;\n      h = (h - 0.5) * 4.;\n      transformed.y += h;\n      ")}}),p={luces:{value:u}},h=new c({color:2363940,onBeforeCompile:e=>{e.uniforms.luces=p.luces,e.uniforms.globalBloom=t.globalUniforms.globalBloom,e.uniforms.noiseTex=t.globalUniforms.noise,e.vertexShader=`\n      uniform float time;\n      uniform sampler2D noiseTex;\n      varying vec3 vPos;\n      varying float intensity;\n      \n      //// https://discourse.threejs.org/t/calculating-vertex-normals-after-displacement-in-the-vertex-shader/16989/8 ///\n      \n      // the function which defines the displacement\n      float displace(vec2 vUv) {\n        return (texture2D(noiseTex, vUv).g - 0.5) * 4.;\n      }\n\n      vec3 getNormal(vec2 vUv){\n        vec3 displacedPosition = position + normal * displace(vUv);\n\n        float texelSize = 1.0 / 512.0; // temporarily hardcoding texture resolution\n        float offset = 0.1;\n\n        vec3 neighbour1 = position + vec3(1., 0., 0.) * offset;\n        vec3 neighbour2 = position + vec3(0., 0., 1.) * offset;\n        vec2 neighbour1uv = vUv + vec2(-texelSize, 0);\n        vec2 neighbour2uv = vUv  + vec2(0, -texelSize);\n        vec3 displacedNeighbour1 = neighbour1 + normal * displace(neighbour1uv);\n        vec3 displacedNeighbour2 = neighbour2 + normal * displace(neighbour2uv);\n\n        // https://i.ya-webdesign.com/images/vector-normals-tangent-16.png\n        vec3 displacedTangent = displacedNeighbour1 - displacedPosition;\n        vec3 displacedBitangent = displacedNeighbour2 - displacedPosition;\n\n        // https://upload.wikimedia.org/wikipedia/commons/d/d2/Right_hand_rule_cross_product.svg\n        vec3 displacedNormal = normalize(cross(displacedBitangent, displacedTangent));\n        return displacedNormal;\n      }\n      \n      ${e.vertexShader}\n    `.replace("#include <begin_vertex>","#include <begin_vertex>\n\n        float h = texture2D(noiseTex, uv).g;\n        intensity = h;\n        h = (h - 0.5) * 4.;\n        transformed.y = h;\n        vPos = transformed;\n        transformedNormal = normalMatrix * getNormal(uv);\n      "),e.fragmentShader=`\n      uniform vec4 luces[100];\n      uniform sampler2D noiseTex;\n      uniform float globalBloom;\n      varying vec3 vPos;\n      varying float intensity;\n\n      ${e.fragmentShader}\n    `.replace("#include <fog_fragment>","\n        vec3 col = vec3(1, 0, 0)*0.75;\n        float intensity = 0.;\n        for(int i = 0;i < 100; i++){\n          vec4 lux = luces[i];\n          vec2 luxUv = (vec2(lux.x, -lux.y) - vec2(-25.)) / 50.;\n          float h = texture2D(noiseTex, luxUv).g;\n          h = (h - 0.5) * 4.;\n          vec3 lightPos = vec3(lux.x, h, lux.y);\n          float currIntensity = smoothstep(lux.z + lux.w, lux.z, distance(vPos, lightPos));\n          intensity += pow(currIntensity, 16.);\n        }\n        intensity = clamp(intensity, 0., 1.);\n        col = mix(col * 0.5, col, intensity);\n        col = mix(gl_FragColor.rgb, col, intensity);\n        col += vec3(1) * intensity * 0.01;\n        gl_FragColor = vec4( col, opacity );\n        #include <fog_fragment>\n      ").replace("#include <dithering_fragment>","#include <dithering_fragment>\n        if (globalBloom > 0.5) {\n          gl_FragColor = vec4(0);\n        }\n      ")}}),{onLoop:b}=e();return b((({elapsed:e})=>{for(let n=0;n<V;n++){const t=v[n];let o=(t.y+e+25)%50-25;u[n].y=o,u[n].w=(Math.sin(e*t.w*(n%3+1))*Math.cos(e*t.w*(n%5+1))*.25+.25)*t.z+.75*t.z,f.attributes.instData.setY(n,o)}f.attributes.instData.needsUpdate=!0})),(e,n)=>(N(),B(j,null,[C("TresMesh",{geometry:P(f),material:P(g)},null,8,H),C("TresMesh",{material:P(h)},[C("TresPlaneGeometry",{args:[50,50,500,500],rotateX:.5*-Math.PI},null,8,I)],8,L)],64))}}),W=["material"],X=D({__name:"portal",props:{globalUniforms:{}},setup(e){const n=e,t=new s({color:16737843,transparent:!0,onBeforeCompile:e=>{e.uniforms.time=n.globalUniforms.time,e.uniforms.globalBloom=n.globalUniforms.globalBloom,e.fragmentShader=`\n      #define S(a, b, t) smoothstep(a, b, t)\n      uniform float time;\n      uniform float globalBloom;\n      \n      ${R}\n      \n      float getTri(vec2 uv, float shift){\n        uv = uv * 2.-1.;\n        float a = atan(uv.x + shift,uv.y) + 3.1415926;\n        float r = 3.1415926 * 2./3.;\n        return cos(floor(.5+a/r)*r-a)*length(uv);\n      }\n      \n      float doubleTri(vec2 uv, float still, float width){\n        vec2 baseUv = uv;\n        vec2 e2 = fwidth(baseUv * 20.);\n        float e = min(e2.x, e2.y) * width;\n        float baseTri = getTri(baseUv, cos(baseUv.y * 31. + time) * sin(baseUv.y * 27. + time * 4.) * 0.025 * still);\n        float td = abs(fract(baseTri * 20.) - 0.5);\n        float tri = S(e, 0., td) - S(0., e, td);\n        tri *= step(0.4, baseTri) -  step(0.5, baseTri);\n        return tri;\n      }\n      \n      ${e.fragmentShader}\n    `.replace("vec4 diffuseColor = vec4( diffuse, opacity );","\n        float tri = doubleTri(vUv, 0.0, 16.);\n        float triWave = doubleTri(vUv, 1.0, 8.);\n        float fullTri = max(tri, triWave);\n        \n        if (fullTri < 0.5) discard;\n        \n        vec3 col = mix(diffuse, vec3(0.75), fullTri);\n        \n        float blinking = smoothNoise(vec2(time, time * 5.));\n        blinking = blinking * 0.9 + 0.1;\n        \n        vec4 diffuseColor = vec4(col * blinking, fullTri);\n      ").replace("#include <dithering_fragment>","#include <dithering_fragment>\n        if (globalBloom > 0.5) {\n          gl_FragColor = vec4(gl_FragColor.rgb * 0.375, fullTri);\n        }\n      ")}});return t.defines={USE_UV:""},(e,n)=>(N(),B("TresMesh",{material:P(t),position:[0,3.75,-12]},n[0]||(n[0]=[C("TresPlaneGeometry",{args:[5,5]},null,-1)]),8,W))}}),J=["material","geometry"],Y=D({__name:"drops",props:{globalUniforms:{}},setup(e){const n=e,t=[],o=[];for(let i=0;i<2e4;i++){const e=r.randFloatSpread(35),n=r.randFloat(-5,10),a=r.randFloatSpread(35),l=r.randFloat(.25,.5);t.push(e,n,a,e,n,a),o.push(0,l,1,l)}const a=new u;a.setAttribute("position",new v(t,3)),a.setAttribute("gEnds",new v(o,2));const l=new m({color:8930440,transparent:!0,onBeforeCompile:e=>{e.uniforms.time=n.globalUniforms.time,e.uniforms.noiseTex=n.globalUniforms.noise,e.uniforms.globalBloom=n.globalUniforms.globalBloom,e.vertexShader=`\n      uniform float time;\n      uniform sampler2D noiseTex;\n      attribute vec2 gEnds;\n      varying float vGEnds;\n      varying float vH;\n\n      ${e.vertexShader}\n    `.replace("#include <begin_vertex>","#include <begin_vertex>\n        \n      vec3 pos = position;\n      \n      vec2 nUv = (vec2(pos.x, -pos.z) - vec2(-25.)) / 50.;\n      float h = texture2D(noiseTex, nUv).g;\n      h = (h - 0.5) * 4.;\n      \n      pos.y = -mod(10. - (pos.y - time * 5.), 15.) + 10.;\n      h = pos.y - h;\n      pos.y += gEnds.x * gEnds.y;\n      transformed = pos;\n      vGEnds = gEnds.x;\n      vH = smoothstep(3., 0., h);\n      "),e.fragmentShader=`\n      uniform float time;\n      uniform float globalBloom;\n      varying float vGEnds;\n      varying float vH;\n      ${R}\n      ${e.fragmentShader}\n    `.replace("vec4 diffuseColor = vec4( diffuse, opacity );","\n      float op = 1. - vGEnds;\n      op = pow(op, 3.);\n      float h = (pow(vH, 3.) * 0.5 + 0.5);\n      vec3 col = diffuse * h; // lighter close to the surface\n      col *= 1. + smoothstep(0.99, 1., h); // sparkle at the surface\n      if (globalBloom > 0.5) {\n        //col *= 0.5;\n      }\n      vec4 diffuseColor = vec4( col, op );\n      \n      ")}});return(e,n)=>(N(),B("TresLineSegments",{material:P(l),geometry:P(a)},null,8,J))}}),K=D({__name:"fboRender",setup(t){const o={time:{value:0},globalBloom:{value:0},noise:{value:null}},a=new f(512,512),r=new d,l=new g,i=new p(2,2),c=new s({onBeforeCompile:e=>{e.uniforms.time=o.time,e.fragmentShader=`\n      uniform float time;\n      ${R}\n      ${e.fragmentShader}\n    `.replace("vec4 diffuseColor = vec4( diffuse, opacity );","\n        vec3 col = vec3(0);\n        float h = clamp(smoothNoise2(vUv * 50.), 0., 1.);\n        col = vec3(h);\n        vec4 diffuseColor = vec4( col, opacity );\n      ")}});c.defines={USE_UV:""};const u=new h(i,c);r.add(u),o.noise.value=a.texture;const{camera:v,renderer:m,scene:D,sizes:C,controls:P}=n();F((()=>P.value),(e=>{e?.target.set(0,2,0),D.value.background||(D.value.background=new S(6706534))}));const z=new b(m.value),E=new b(m.value),A=new x(D.value,v.value),M=new y(new T(C.width.value,C.height.value),1.2,.5,0);z.renderToScreen=!1,z.addPass(A),z.addPass(M);const $=new w(new U({uniforms:{baseTexture:{value:null},bloomTexture:{value:z.renderTarget2.texture}},vertexShader:"\n\t\t\t\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t\t\t\tvUv = uv;\n\t\t\t\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\t\t\t\t}",fragmentShader:"\n\t\t\t\t\t\t\t\tuniform sampler2D baseTexture;\n\t\t\t\t\t\t\t\tuniform sampler2D bloomTexture;\n\t\t\t\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t\t\t\tgl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );\n\t\t\t\t\t\t\t\t}",defines:{}}),"baseTexture");$.needsSwap=!0,E.addPass(A),E.addPass($),D.value.fog=new _(6706534,1,25);const{onLoop:G}=e();return G((({elapsed:e})=>{o.time.value=e,m.value&&(m.value.setRenderTarget(a),m.value.render(r,l),m.value.setRenderTarget(null),o.globalBloom.value=1.2,D.value.fog.color.set(0),D.value.fog.near=15,D.value.background?.set(0),z.render(),o.globalBloom.value=0,D.value.fog.color.set(6706534),D.value.fog.near=10,D.value.background?.set(6706534),E.render())})),(e,n)=>(N(),B(j,null,[k(q,{globalUniforms:o}),k(X,{globalUniforms:o}),k(Y,{globalUniforms:o})],64))}}),O={class:"text"};const Q=G({},[["render",function(e,n){return N(),B("div",O,n[0]||(n[0]=[C("span",{class:"retro noselect"},[C("span",{style:{color:"#eae"}},"光"),z("噪声")],-1)]))}],["__scopeId","data-v-3881bd43"]]),Z=D({__name:"lightNoise",setup(e){const n={windowSize:!0,antialias:!0,renderMode:"manual"},o={enableDamping:!0,minDistance:5,maxDistance:10,minPolarAngle:60*r.DEG2RAD,maxPolarAngle:90*r.DEG2RAD,makeDefault:!0};return(e,a)=>{const r=E("TresCanvas");return N(),B(j,null,[k(Q),k(r,M($(n)),{default:A((()=>[a[0]||(a[0]=C("TresPerspectiveCamera",{position:[0,3,5],fov:45,near:.1,far:1e3},null,-1)),k(P(t),M($(o)),null,16),a[1]||(a[1]=C("TresAmbientLight",{intensity:.5},null,-1)),a[2]||(a[2]=C("TresDirectionalLight",{position:[0,3,-12],intensity:1},null,-1)),k(K)])),_:1},16)],64)}}});export{Z as default};
