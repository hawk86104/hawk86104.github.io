import{F as e,_ as t}from"./@tresjs.BCHtwiaC1763540743861.js";import{_ as n}from"./caustics.vue_vue_type_script_setup_true_lang.DZ811zlk1763540743861.js";import{l as r}from"./lodash.CybtBilg1763540743861.js";import{d as o,a,b as i,o as l,u as s}from"./@vue.Co_gxueH1763540743861.js";import{O as u,o as d,H as c,a4 as v,aS as m,n as f,h,f as x}from"./three.rXKzP9fQ1763540743861.js";var g="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const p=o({__name:"waterSimulation",props:{light:{}},setup(o,{expose:p}){const y=new u(0,1,1,0,0,2e3),w=new d(2,2),_=new c(256,256,{type:v}),D=new c(256,256,{type:v}),F=new m({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:g,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),S=new m({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:g,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),j=new m({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:g,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),E=new f(w,F),b=new f(w,S),C=new f(w,j);let z=_;const B=(e,t)=>{const n=z,r=z===_?D:_;t.material.uniforms.texture.value=n.texture,e.setRenderTarget(r),e.render(t,y),z=r},{renderer:P,camera:R}=e(),T=a(new h);P.autoClear=!1;const{onBeforeRender:Y}=t();Y(()=>{B(P,C),(e=>{B(e,b)})(P)});const G=(e,t,n,r)=>{E.material.uniforms.center.value=[e,t],E.material.uniforms.radius.value=n,E.material.uniforms.strength.value=r,B(P,E)},I=new x,L=new d(2,2),O=L.attributes.position;for(let e=0;e<O.count;e++){const t=-O.getY(e);O.setY(e,0),O.setZ(e,t)}O.needsUpdate=!0;const A=new f(L),H=e=>{const t=P.domElement.getBoundingClientRect(),n=t.width,r=t.height;I.x=2*(e.clientX-t.left)/n-1,I.y=2*-(e.clientY-t.top)/r+1,T.value.setFromCamera(I,R.value);const o=T.value.intersectObject(A);for(let a of o)G(a.point.x,a.point.z,.03,.04)},U={handleEvent:H};return p({addDrop:G,mouseEvent:e=>{e?P.domElement.addEventListener("mousemove",r.throttle(H,30)):P.domElement.removeEventListener("mousemove",U)}}),(e,t)=>(l(),i(n,{lightFrontGeometry:s(w),waterTexture:s(z).texture,light:e.light},null,8,["lightFrontGeometry","waterTexture","light"]))}});export{p as _};
