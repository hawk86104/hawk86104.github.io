import{l as e}from"./@tresjs.BCHtwiaC1763540743861.js";import{s}from"./snoise.B6agkY-m1763540743861.js";import{d as o,w as r,b as u,o as a,u as n}from"./@vue.Co_gxueH1763540743861.js";import{aD as t,l,ae as i}from"./three.rXKzP9fQ1763540743861.js";const d=o({__name:"material",props:{baseMaterial:{default:new t},uEdgeColor:{default:"#4d9bff"},uEdge:{default:6},uFreq:{default:.41},uAmp:{default:20},uProgress:{default:-2}},setup(o){const t=o,d={uEdgeColor:{value:new l(t.uEdgeColor)},uFreq:{value:t.uFreq},uAmp:{value:t.uAmp},uProgress:{value:t.uProgress},uEdge:{value:t.uEdge}},f=`\n  varying vec3 vPos;\n\n  uniform float uFreq;\n  uniform float uAmp;\n  uniform float uProgress;\n  uniform float uEdge;\n  uniform vec3 uEdgeColor;\n\n  ${s}\n\n\tvoid main() {\n\t\tfloat noise = snoise(vPos * uFreq) * uAmp; // calculate snoise in fragment shader for smooth dissolve edges\n\n    if(noise < uProgress) discard; // discard any fragment where noise is lower than progress\n\n    float edgeWidth = uProgress + uEdge;\n\n    if(noise > uProgress && noise < edgeWidth){\n        csm_DiffuseColor = vec4(vec3(uEdgeColor),noise); // colors the edge\n    }else{\n\t\t\t\tcsm_DiffuseColor = vec4(csm_DiffuseColor.xyz,1.0);\n\t\t}\n\t}\n`;return r(()=>[t.uEdgeColor,t.uEdge,t.uFreq,t.uAmp,t.uProgress],([e,s,o,r,u])=>{d.uEdgeColor.value.setStyle(e),d.uEdge.value=s,d.uFreq.value=o,d.uAmp.value=r,d.uProgress.value=u}),(s,r)=>(a(),u(n(e),{baseMaterial:o.baseMaterial,vertexShader:"\n\tvarying vec3 vPos;\n\tvoid main() {\n\t\tvPos = position;\n\t}\n",side:i,fragmentShader:f,uniforms:d},null,8,["baseMaterial","side"]))}});export{d as _};
