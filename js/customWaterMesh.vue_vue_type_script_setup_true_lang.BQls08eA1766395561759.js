import{_ as e}from"./@tresjs.BAA1xUmy1766395561759.js";import{p as n}from"./gl-noise.DADvM2fE1766395561759.js";import"./shapeConfigurator.vue_vue_type_style_index_1_scoped_abbf0cc1_lang.BYqEDbJP1766395561759.js";import"./Resource.BvxQFOEE1766395561759.js";import{_ as t}from"./customShaderMaterial.vue_vue_type_script_setup_true_lang.D4TJgL8B1766395561759.js";import{d as a,a3 as r,G as s,o,I as i,h as l,u as g}from"./@vue.BxPWGdWw1766395561759.js";import{k as v,a6 as u}from"./three.F31Lz30M1766395561759.js";const c=["rotation-x"],f=["args"],h=a({__name:"customWaterMesh",props:{height:{default:.2},Flatshading:{type:Boolean,default:!1},waterColor:{default:"#52a7f7"},waterHighlight:{default:"#b3ffff"},brightness:{default:1},baseMaterial:{default:"MeshPhysicalMaterial"},roughness:{default:.2},metalness:{default:.1},speed:{default:1}},setup(a){const h=a,m={vertex:"\nuniform float uTime;\nuniform float uHeight;\nvarying float vHeight;\n\nvec3 displace(vec3 point) {\n  vec3 p = point;\n  p.y += uTime * 2.0;\n  gln_tFBMOpts fbmOpts = gln_tFBMOpts(1.0, 0.4, 2.3, 0.4, 1.0, 5, false, false);\n  gln_tGerstnerWaveOpts A = gln_tGerstnerWaveOpts(vec2(0.0, -1.0), 0.5, 2.0);\n  gln_tGerstnerWaveOpts B = gln_tGerstnerWaveOpts(vec2(0.0, 1.0), 0.25, 4.0);\n  gln_tGerstnerWaveOpts C = gln_tGerstnerWaveOpts(vec2(1.0, 1.0), 0.15, 6.0);\n  gln_tGerstnerWaveOpts D = gln_tGerstnerWaveOpts(vec2(1.0, 1.0), 0.4, 2.0);\n  vec3 n = vec3(0.0);\n  if(p.z >= uHeight / 2.0) {\n      n.z += gln_normalize(gln_pfbm(p.xy + (uTime * 0.5), fbmOpts));\n      n += gln_GerstnerWave(p, A, uTime).xzy;\n      n += gln_GerstnerWave(p, B, uTime).xzy * 0.5;\n      n += gln_GerstnerWave(p, C, uTime).xzy * 0.25;\n      n += gln_GerstnerWave(p, D, uTime).xzy * 0.2;\n  }\n  vHeight = n.z;\n  return point + n;\n}\n\nvec3 orthogonal(vec3 v) {\n  return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n  : vec3(0.0, -v.z, v.y));\n}\n\nvec3 recalcNormals(vec3 newPos) {\n  float offset = 0.001;\n  vec3 tangent = orthogonal(normal);\n  vec3 bitangent = normalize(cross(normal, tangent));\n  vec3 neighbour1 = position + tangent * offset;\n  vec3 neighbour2 = position + bitangent * offset;\n\n  vec3 displacedNeighbour1 = displace(neighbour1);\n  vec3 displacedNeighbour2 = displace(neighbour2);\n\n  vec3 displacedTangent = displacedNeighbour1 - newPos;\n  vec3 displacedBitangent = displacedNeighbour2 - newPos;\n\n  return normalize(cross(displacedTangent, displacedBitangent));\n}\n\nvoid main() {\n  csm_Position = displace(position);\n  csm_Normal = recalcNormals(csm_Position);\n}\n\t",fragment:"\nvarying float vHeight;\nuniform vec3 waterColor;\nuniform vec3 waterHighlight;\nuniform float offset;\nuniform float contrast;\nuniform float brightness;\n\nvec3 calcColor() {\n  float mask = (pow(vHeight, 2.) - offset) * contrast;\n  vec3 diffuseColor = mix(waterColor, waterHighlight, mask);\n  diffuseColor *= brightness;\n  return diffuseColor;\n}\n\nvoid main() {\n  csm_DiffuseColor = vec4(calcColor(), 1.0);\n}\n\t"},p={uTime:{value:0},waterColor:{value:new v(h.waterColor).convertLinearToSRGB()},waterHighlight:{value:new v(h.waterHighlight).convertLinearToSRGB()},offset:{value:.4},contrast:{value:3.1},brightness:{value:h.brightness},uHeight:{value:h.height}},{onBeforeRender:d}=e();return d(()=>{p.uTime.value-=.002*h.speed}),r(()=>{p.uHeight.value=h.height,p.brightness.value=h.brightness,p.waterColor.value.set(h.waterColor).convertLinearToSRGB(),p.waterHighlight.value.set(h.waterHighlight).convertLinearToSRGB()}),(e,a)=>(o(),s("TresMesh",{"rotation-x":-Math.PI/2},[i("TresBoxGeometry",{args:[5,5,e.height,64,64,1]},null,8,f),l(g(t),{baseMaterial:e.baseMaterial,vertexShader:g(n)(m.vertex),fragmentShader:m.fragment,uniforms:p,side:u,roughness:e.roughness,metalness:e.metalness,flatShading:e.Flatshading,silent:""},null,8,["baseMaterial","vertexShader","fragmentShader","side","roughness","metalness","flatShading"])],8,c))}});export{h as _};
