import{_ as t}from"./@tresjs.BCHtwiaC1763540743861.js";import{V as n,f as e,b8 as d,ae as c}from"./three.rXKzP9fQ1763540743861.js";import{a as i}from"./argestCircle.EZRfPXY41763540743861.js";import{d as o,H as v,o as s,J as m,ac as a,ao as p}from"./@vue.Co_gxueH1763540743861.js";const f=["rotation-y"],r=o({__name:"background4",setup(o){const r={uniforms:{uTime:{type:"f",value:0},R:{type:e,value:new e(800,350)},iMouse:{value:new n(0,0,0)}},vertexShader:i,fragmentShader:"#define SCALE 8.0\n\n#define pi  3.14159\n#define tau 6.28318\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a)) \nvarying vec2 vUv;\nuniform float uTime;\nuniform vec2 R;\nuniform vec3 iMouse;\n\n#define ILLUMINATION\n\n#define WARP_SHADER\n\nfloat udBox( vec3 p, vec3 b ) \n{\t\n\treturn length(max(abs(p)-b,0.0)); \n}\n\nfloat sdBox( vec3 p, vec3 b ) \n{\t\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSegment(vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length(pa - ba*h) - r;\n}\n\nfloat time;\n\nvec4 scene(vec3 p, inout float t, inout vec3 tcol)\n{\n\tfloat d, d1, d2, d3, d4, d5, f, v;\n\t\n\t#ifdef ILLUMINATION\n\tvec3 col = vec3(0.06, 0.06, 0.16);\n\t#else\n    vec3 col = vec3(1.0);\n\t#endif\n\t\n\t\n\td1 = sdBox(p, vec3(0.6, 1.2, 0.5));\n\tv = sdBox(p-vec3(0.0, 0.01, 0.0), vec3(0.58, 1.1, 0.48)); \n\td3 = sdBox(p-vec3(0.0, 0.05, 0.0), vec3(0.58, 0.97, 0.7)); \n\td4 = sdBox(p-vec3(0.0, 0.05, 0.0), vec3(0.7, 0.97, 0.48)); \n\td = max(-d4, max(-d3, max(-v, d1)));\n\t\n\t\n\td = min(d, udBox(p-vec3(0.0, -0.45, 0.48), vec3(0.58, 0.01, 0.01)));\n\td = min(d, udBox(p-vec3(0.0, 0.05, 0.48), vec3(0.58, 0.01, 0.01)));\n\td = min(d, udBox(p-vec3(0.0, 0.55, 0.48), vec3(0.58, 0.01, 0.01)));\n\t\n\td = min(d, udBox(p-vec3(0.0, -0.45, -0.48), vec3(0.58, 0.01, 0.01)));\n\td = min(d, udBox(p-vec3(0.0, 0.05, -0.48), vec3(0.58, 0.01, 0.01)));\n\td = min(d, udBox(p-vec3(0.0, 0.55, -0.48), vec3(0.58, 0.01, 0.01)));\n\t\n\td = min(d, udBox(p-vec3(0.58, 0.05, 0.0), vec3(0.01, 0.01, 0.48)));\n\td = min(d, udBox(p-vec3(0.58, 0.02, 0.0), vec3(0.01, 1.0, 0.01)));\n\n\t\n\tif (v < 0.0) \n\t{\n\t\t\n\t\t\n\t\t\n\t\td1 = udRoundBox(p-vec3(-0.493, 0.1, 0.22), vec3(0.05, 0.3, 0.16), 0.02);\n\t\td2 = udRoundBox(p-vec3(-0.475, 0.2, 0.22), vec3(0.07, 0.26, 0.16), 0.02);\n\t\td3 = sdSegment(p, vec3(0.03 , -0.1 , 0.2), vec3(-0.1 , 0.02 , 0.16), 0.03);\n\t\td4 = udRoundBox(p-vec3(0.03 , -0.14 , 0.2), vec3(0.01, 0.01, 0.01), 0.04);\n\t\td5 = udRoundBox(p-vec3(-0.12 , 0.0 , 0.16), vec3(0.01, 0.01, 0.01), 0.04);\n\t\td = min(d, min(min(min(min(d5,d4),d3),d2),d1));\n\t\t\n\t\t\n\t\tif (abs(p.x+0.16) < 0.22) \n\t\t{\n\t\t\td = min(d, sdSegment(p, vec3(p.x     , -0.23 + sin( p.x     *12.0)*0.2, 0.2), \n\t\t\t\t\t\t \t\t    vec3(p.x-0.1 , -0.23 + sin((p.x-0.1)*12.0)*0.2, 0.2), 0.01));\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\td1 = sdSegment(p, vec3(0.11  , 0.42 , 0.12), vec3(0.11  , 0.43 , -0.12), 0.1); \n\t\td2 = sdSegment(p, vec3(0.05  , 0.34 , 0.0), vec3(0.38 , 0.3 ,  0.0), 0.1); \n\t\td3 = sdSegment(p, vec3(0.17 , 0.44 , 0.0),  vec3(0.38 , 0.3 ,  0.0), 0.13); \n\t\td4 = sdSegment(p, vec3(0.35  , 0.31 , 0.0),  vec3(0.38 , -0.2  ,  0.0), 0.06); \n\t\td = min(d, min(min(min(d4,d3),d2),d1));\t\n\t\t\n\t\t\n\t\td1 = sdSegment(p, vec3( 0.2 , -0.18 , -0.18),  vec3(-0.08  , -0.04 , 0.0), 0.05);\n\t\td2 = sdSegment(p, vec3(-0.1 , -0.04  ,  0.0), vec3(-0.13 , 0.29 , 0.11), 0.03);\n\t\td = min(d, min(d2,d1));\n\t\t\n\t\t\n\t\td1 = sdSegment(p, vec3(-0.13 , 0.32 , 0.11), vec3(-0.4  , 0.5+p.x*0.3 , 0.14), 0.012); \n\t\td2 = sdSegment(p, vec3(-0.12 , 0.31 , 0.12), vec3(-0.24 , 0.33  , 0.1), 0.014); \n\t\td3 = sdSegment(p, vec3(-0.25 , 0.33  , 0.1), vec3(-0.26 , 0.28  , 0.1), 0.012);\n\t\td4 = sdSegment(p, vec3(-0.13 , 0.31 , 0.13), vec3(-0.25 , 0.3 , 0.15), 0.014); \n\t\td = min(d, min(min(min(d4,d3),d2),d1));\t\n\t\t\n\t\t\n\t\td1 = sdSegment(p, vec3(0.2, -0.14, 0.18), vec3(0.21, -0.3, 0.2), 0.05);\n\t\td2 = sdSegment(p, vec3(0.21, -0.3, 0.2), vec3(0.03, -0.1, 0.2), 0.04);\n\t\td = min(d, min(d2, d1));\n\t\t\n\t\t\n\t\td1 = sdSegment(p, vec3(0.3, -0.22, 0.0), vec3(0.26, -0.76, 0.1), 0.23);\n\t\td2 = sdSegment(p, vec3(0.3, -0.22, 0.0), vec3(0.26, -0.76, -0.1), 0.23);\n\t\td3 = sdSegment(p, vec3(0.3, -0.22, 0.0), vec3(0.18, -0.72, 0.0), 0.23);\n\t\td4 = sdSegment(p, vec3(0.27, -0.72, 0.16), vec3(0.28, -1.0, 0.14), 0.1);\n\t\td5 = sdSegment(p, vec3(0.28, -0.72, -0.16), vec3(0.28, -1.0, -0.14), 0.1);\n\t\td = min(d, min(min(min(min(d5,d4),d3),d2),d1));\n\t\n\t\t\n\t\tfloat blink = mod(floor(time*10.0), 2.0);\n\t\tf = length(vec3(-0.4, 0.38, 0.14)-p);\n\t\ttcol += blink*0.04*smoothstep(0.2, 0.0, f)*vec3(0.2, 0.08, 0.0);\n\t\ttcol = mix(tcol, vec3(0.9, 0.08, 0.0), blink*smoothstep(0.06, 0.0, f));\n\t\tt += blink*0.1*smoothstep(0.2, 0.0, f);\n\t\t\n\t\t\n\t\tt = max(0.2, t + 0.04 + 0.02*sin(p.y*5.0+time));\n\t\ttcol += smoothstep(0.1, 1.2, p.y*0.3)*(1.0-tcol);\n\t\t\n\t\t\n\t\tf = length(0.3*vec3(sin(time*0.2+66.0), 3.2+sin(time*0.7)*0.5, cos(time*0.6))-p);\n\t\td = min(d, f - 0.01);\n\t\ttcol += step(f, 0.01)*0.01;\n\t\t\n\t\tf = length(0.4*vec3(sin(-time*0.4), 3.3+sin(-t*0.5)*cos(t+100.0), sin(time*0.34+32.0))-p);\n\t\td = min(d, f - 0.006);\n\t\ttcol += step(f, 0.01)*0.01;\n\t\t\n\t\tf = length(0.36*vec3(sin(time*0.6), 3.4+sin(time*0.5)*sin(-time*0.2), sin(-time*0.3))-p);\n\t\td = min(d, f - 0.006);\n\t\ttcol += step(f, 0.01)*0.01;\n\n\t\t\n\t\n\t\td1 = 0.1*sin((p.y+time)*8.0);\n\t\td2 = 0.1*cos((p.y+time)*8.0);\n\t\td3 = sdSegment(p, vec3(d1 , mod(time*6.0, 8.0) - 4.0, d2),  \n\t\t\t\t\t\t  vec3(d1 , mod(time*6.0, 8.0) - 2.0, d2), 0.47);\n\t\t\n\t\ttcol = mix(tcol, vec3(0.0078, 0.9882, 0.0588), 1.0-smoothstep(-0.5,0.0, d3));\n\t\tif (d3 < 0.0) t += 0.1;\n\t\t\n\t}\t\n\t\n\treturn vec4(col, d);\n}\n\nvec3 Dave_Hoskins_Warp_Shader()\n{\n\tfloat s = 0.0, v = 0.0;\n\tvec2 uv = vUv.xy-0.5;\n\tfloat t = time*0.0005;\n\tuv.x = (uv.x * R.x / R.y) + sin(t)*.5;\n\tfloat si = sin(t+2.17); \n\tfloat co = cos(t);\n\tuv *= mat2(co, si, -si, co);\n\tvec3 col = vec3(0.0);\n\tfor (int r = 0; r < 100; r++) \n\t{\n\t\tvec3 p= vec3(0.3, 0.2, floor(time) * 0.0008) + s * vec3(uv, 0.143);\n\t\tp.z = mod(p.z,2.0);\n\t\tfor (int i=0; i < 10; i++) p = abs(p*2.04) / dot(p, p) - 0.75;\n\t\tv += length(p*p)*smoothstep(0.0, 0.5, 0.9 - s) * .002;\n\t\t col +=  vec3(0.0196, 0.5451, 0.9725) * v * 0.013;\n\t\ts += .01;\n\t}\t\n\treturn col;\n}\n\nvoid main(){\n \t#ifdef WARP_SHADER\n\ttime = (uTime+2.4) * 6.0;\n\tvec3 col = Dave_Hoskins_Warp_Shader();\n\t#endif\n\t\n\ttime = uTime + 7.3;\n    vec2 pos =4.*(vUv.xy-0.5) ;\n\t\n    float focus = 3.0;\n    float far = 9.0;\n\t\n\tfloat atime = time*0.4;\n\tvec3 cp = vec3(2.0+sin(atime)*3.0, 0.6+sin(atime)*0.6, 5.0+cos(atime)); \n  \t\n  \t\n\t\n\tif (iMouse.z > 0.0)\n\t{\n\t\tfloat d = (R.y-iMouse.y)*0.01+3.0;\n\t\tcp = vec3(sin(iMouse.x*0.01)*d, .0, cos(iMouse.x*0.01)*d);\n\t}\n\t\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(sin(time), 1.0, cos(time));\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\n\t\n    vec3 ray = cp;\n\tfloat dist = 0.0;\n    vec4 s;\n\t\n\tfloat t = 0.06;\n\tvec3 tcol = vec3(0.0, 0.5, 0.7);\n\t\n    for(int i=0; i < 40; i++) \n\t{\n        s = scene(ray, t, tcol);\n\t\t\n        dist += s.w;\n        ray += dir * s.w;\n\t\t\n        if(s.w < 0.01) break;\n\t\t\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\t\n\t#ifndef ILLUMINATION\n\tt = 0.0;\n\t#endif\n\t\n    float b = 1.0 - dist/far;\n\tvec3 c = mix(vec3(b * s.rgb), tcol, t);\n\t\n\t#ifdef WARP_SHADER\n\tcol = mix(c, col, smoothstep(0.5, 0.99, min(0.7-b, 1.0-t))); \n    gl_FragColor = vec4(col, 1.0);\n\t#else\n\tgl_FragColor = vec4(c, 1.0);\n\t#endif\n   \n}",side:c,blending:d,depthWrite:!1},{onBeforeRender:l}=t();return l(({delta:t})=>{r.uniforms.uTime.value+=10*t}),(t,n)=>(s(),v("TresMesh",{ref:"quanMeshRef","rotation-y":Math.PI,position:[0,180,-410]},[n[0]||(n[0]=m("TresPlaneGeometry",{args:[820,220]},null,-1)),m("TresShaderMaterial",a(p(r)),null,16)],8,f))}});export{r as _};
