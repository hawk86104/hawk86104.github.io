import{importShared as J}from"./3d-tiles-renderer.DZNovkLO1767148983502.js";import{_sfc_main as ce}from"./pagesShow.vue_vue_type_script_setup_true_lang.Crq63Xp41767148983502.js";import{Fs as he,_l as ue}from"./index.DTe2qqjO1767148983502.js";const r=await J("three");class T{static Time=new T("Time");static Sequence=new T("Sequence");constructor(e){this.name=e}}class me{constructor(){this.init()}init(){this.progressType=T.Time,this.lifetime=1,this.age=0,this.sequenceElement=new r.Vector4,this.position=new r.Vector3,this.velocity=new r.Vector3,this.acceleration=new r.Vector3,this.normal=new r.Vector3,this.rotation=0,this.rotationalSpeed=0,this.size=new r.Vector2,this.color=new r.Color,this.alpha=1,this.initialSize=new r.Vector2,this.initialColor=new r.Color,this.initialAlpha=1}setAll(e,t,i,s,o,a,l,h,m,p,u,f,n,w,y,v){this.progressType=e,this.lifetime=t,this.age=i,this.sequenceElement.copy(s),this.position.copy(o),this.velocity.copy(a),this.acceleration.copy(l),this.normal.copy(h),this.rotation=m,this.rotationalSpeed=p,this.size=u,this.color.copy(f),this.alpha=n,this.initialSize.copy(w),this.initialColor.copy(y),this.initialAlpha=v}copyTo(e){e.setAll(this.progressType,this.lifetime,this.age,this.sequenceElement,this.position,this.velocity,this.acceleration,this.normal,this.rotation,this.rotationalSpeed,this.size,this.color,this.alpha,this.initialSize,this.initialColor,this.initialAlpha)}copy(e){this.setAll(e.progressType,e.lifetime,e.age,e.sequenceElement,e.position,e.velocity,e.acceleration,e.normal,e.rotation,e.rotationalSpeed,e.size,e.color,e.alpha,e.initialSize,e.initialColor,e.initialAlpha)}}class ee{constructor(){this.particleCount=0,this.activeParticleCount=0,this.particleStates=[]}init(e){this.setParticleCount(e)}setParticleCount(e){this.particleCount!=e&&(this.dispose(),this.allocate(e)),this.particleCount=e}setActiveParticleCount(e){this.activeParticleCount=e}allocate(e){this.particleStates=[],this.particleCount=e;for(let t=0;t<e;t++)this.particleStates[t]=new me}dispose(){}getParticleCount(){return this.particleCount}flushParticleStateToBuffers(){}copyState(e,t){if(e>=this.particleCount)throw new Error('ParticleStateArray::copyState() -> "srcIndex" is out of range.');if(t>=this.particleCount)throw new Error('ParticleStateArray::copyState() -> "destIndex" is out of range.');const i=this.particleStates[e],s=this.particleStates[t];i.copyTo(s)}setState(e,t){if(e>=this.particleCount)throw new Error('ParticleStateArray::setState() -> "index" is out of range.');return this.particleStates[e].copy(t)}getState(e){if(e>=this.particleCount)throw new Error('ParticleStateArray::getState() -> "index" is out of range.');return this.particleStates[e]}computeBoundingBox=function(){const e=new r.Vector3;return function(t=new r.Box3,i=null){const s=t.min,o=t.max;for(let a=0;a<this.activeParticleCount;a++){const l=this.getState(a);let h=l.position;i&&(e.copy(h),e.applyMatrix4(i),h=e);const m=Math.max(l.size.x,l.size.y),p=h.x-m,u=h.x+m,f=h.y-m,n=h.y+m,w=h.z-m,y=h.z+m;(a==0||h.x<s.x)&&(s.x=p),(a==0||h.x>o.x)&&(o.x=u),(a==0||h.y<s.y)&&(s.y=f),(a==0||h.y>o.y)&&(o.y=n),(a==0||h.z<s.z)&&(s.z=w),(a==0||h.z>o.z)&&(o.z=y)}return t}}();computeBoundingSphere=function(){const e=new r.Vector3,t=new r.Vector3,i=new r.Vector3;return function(s=new r.Sphere,o=null){let a=0;for(let l=0;l<this.activeParticleCount;l++){const h=this.getState(l);let m=h.position;o&&(i.copy(m),i.applyMatrix4(o),m=i);const p=Math.max(h.size.x,h.size.y);if(l==0)e.copy(m),a=p;else{t.copy(m).sub(e);const u=t.length()+p;if(u>a){const n=(u-a)/2;t.normalize().multiplyScalar(n),e.add(t),a+=n}}}return s.center.copy(e),s.radius=a,s}}()}class pe{constructor(e,t,i=0){this.start=e,this.length=t,this.id=i}}class de{constructor(){this.sequences={},this.ids=[]}addSequence(e,t,i){if(this.hasID(i))throw new Error("ParticleSequenceGroup::addParticleSequence -> Tried to add sequence with duplicate ID.");const s=new pe(e,t,i);return this.sequences[i]=s,this.ids.push(i),s}getSequence(e){if(!this.hasID(e))throw new Error("ParticleSequenceGroup::getSequence -> Invalid ID.");return this.sequences[e]}getSequenceIDs(){return this.ids}hasID(e){return!!this.sequences[e]}}class O{constructor(){}initializeState(e){e.initialColor.set(1,1,1),e.initialSize.set(1,1),e.initialAlpha=1,e.progressType=T.Time,e.lifetime=0,e.age=0,e.sequenceElement.set(0,0,0,0),e.position.set(0,0,0),e.velocity.set(0,0,0),e.acceleration.set(0,0,0),e.normal.set(0,0,1),e.rotation=0,e.rotationalSpeed=0,e.size.copy(e.initialSize),e.color.copy(e.initialColor),e.alpha=1}}class K extends O{constructor(){super()}initializeState(e){super.initializeState(e)}}class _{constructor(){}updateState(){}}class Q extends _{constructor(){super(),this.timeScaledVelocity=new r.Vector3,this.timeScaledAcceleration=new r.Vector3,this.stateAcceleration=new r.Vector3,this.stateVelocity=new r.Vector3}updateState(e,t){return super.updateState(e,t),this.stateAcceleration.copy(e.acceleration),this.timeScaledAcceleration.copy(this.stateAcceleration),this.timeScaledAcceleration.multiplyScalar(t),e.velocity.add(this.timeScaledAcceleration),this.stateVelocity.copy(e.velocity),this.timeScaledVelocity.copy(this.stateVelocity),this.timeScaledVelocity.multiplyScalar(t),e.position.add(this.timeScaledVelocity),e.age=e.age+t,e.rotation=e.rotation+t*e.rotationalSpeed,!0}}class z{static clamp(e,t,i){return Math.min(Math.max(e,t),i)}static currentTime(){return performance.now()/1e3}}class se{constructor(){this.components=[]}addComponent(e){this.components.push(e)}update(e,t){for(const i of this.components)i.update(e,t)}getComponent(e){if(e>=this.components.length)throw new Error('ComponentContainer::getComponent() -> "index" is out of range.');return this.components[e]}}class x{static NotStarted=new x("NotStarted");static Running=new x("Running");static Paused=new x("Paused");static Done=new x("Done");constructor(e){this.name=e}}class C{constructor(e,t){this.owner=e,this.owner.visible=!1,this.visible=!0,this.particleSystemRenderer=t,this.initialized=!1,this.maximumActiveParticles=0,this.activeParticleCount=0,this.simulateInWorldSpace=!0,this.emitterInitialized=!1,this.particleEmitter=null,this.componentContainer=new se,this.particleStateInitializers=[],this.particleStateOperators=[],this.particleStates=null,this.systemState=x.NotStarted,this.particleSequences=new de,this.onUpdateCallback=null,this.transformInitialDirectionInWorldSpace=!0,this.boundingBox=new r.Box3,this.boundingSphere=new r.Sphere}init(e){if(!this.initialized)this.maximumActiveParticles=e,this.particleSystemRenderer?(this.particleSystemRenderer.setOwner(this.owner),this.particleSystemRenderer.init(this.maximumActiveParticles,this.simulateInWorldSpace),this.particleSystemRenderer.setSimulateInWorldSpace(this.simulateInWorldSpace),this.particleStates=this.particleSystemRenderer.getParticleStateArray()):(this.particleStates=new ee,this.particleStates.init(this.maximumActiveParticles)),this.addParticleStateInitializer(new K),this.addParticleStateOperator(new Q),this.initialized=!0;else throw new Error("ParticleSystem::init() -> trying to intialize more than once.")}getVisible(){return this.visible}setVisibile(e){return this.visible=e}onUpdate(e){this.onUpdateCallback=e}update(e,t){if(this.systemState==x.Running){if(this.owner.updateWorldMatrix(!0),e=e==null||e==null?z.currentTime():e,t=t==null||t==null?e-this.lastUpdateTime:t,this.emitterInitialized&&this.systemState==x.Running){const i=this.particleEmitter.update(t);i>0&&this.activateParticles(i),this.advanceActiveParticles(t),this.onUpdateCallback&&this.onUpdateCallback(this.activeParticleCount),this.updateBounds()}this.componentContainer.update(e,t),this.lastUpdateTime=e}}render(e,t){if(this.getVisible()&&this.particleSystemRenderer){const i=e.autoClear;e.autoClear=!1,this.owner.visible=!0,this.owner.matrixWorldNeedsUpdate=!0,this.particleSystemRenderer.render(this.owner,e,t),this.owner.visible=!1,e.autoClear=i}}start(){(this.systemState==x.NotStarted||this.systemState==x.Paused)&&(this.systemState=x.Running,this.startTime=z.currentTime(),this.lastUpdateTime=this.startTime)}pause(){this.systemState==x.Running&&(this.systemState=x.Paused)}stop(){}getSystemState(){return this.systemState}setEmitter(e){return this.particleEmitter=e,this.particleEmitter.maximumActiveParticles=this.maximumActiveParticles,this.emitterInitialized=!0,this.particleEmitter}addComponent(e){this.componentContainer.addComponent(e)}getComponent(e){return this.componentContainer.getComponent(e)}addParticleStateInitializer(e){return this.particleStateInitializers.push(e),e}getParticleStateInitializerCount(){return this.particleStateInitializers.length}getParticleStateInitializer(e){if(e>=this.particleStateInitializers.length)throw new Error('ParticleSystem::getParticleStateInitializer() -> "index" is out of range.');return this.particleStateInitializers[e]}addParticleStateOperator(e){return this.particleStateOperators.push(e),e}getParticleStateOperatorCount(){return this.particleStateOperators.length}getParticleStateOperator(e){if(e>=this.particleStateOperators.length)throw new Error('ParticleSystem::getParticleStateOperator() -> "index" is out of range.');return this.particleStateOperators[e]}getMaximumActiveParticles(){return this.maximumActiveParticles}getActiveParticleCount(){return this.activeParticleCount}getParticleState(e){if(e>=this.activeParticleCount)throw new Error('ParticleSystem::getParticleState() -> "index" is out of range.');return this.particleStates.getState(e)}getParticleStates(){return this.particleStates}getParticleSystemRenderer(){return this.particleSystemRenderer}getSimulateInWorldSpace(){return this.simulateInWorldSpace}setSimulateInWorldSpace(e){this.simulateInWorldSpace=e,this.particleSystemRenderer&&this.particleSystemRenderer.setSimulateInWorldSpace(this.simulateInWorldSpace)}setTransformInitialDirectionInWorldSpace(e){this.transformInitialDirectionInWorldSpace=e}addParticleSequence(e,t,i=0){this.particleSequences.addSequence(e,t,i)}getParticleSequences(){return this.particleSequences}getEmitter(){return this.particleEmitter}updateBounds=function(){const e=new r.Matrix4;return function(){let t=null;this.transformInitialDirectionInWorldSpace&&(t=e,t.copy(this.owner.matrixWorld).invert()),this.particleSystemRenderer.calculatingBoundingSphereFromBox()?(this.particleStates.computeBoundingBox(this.boundingBox,t),this.particleSystemRenderer.setBoundingBox(this.boundingBox)):(this.particleStates.computeBoundingSphere(this.boundingSphere,t),this.particleSystemRenderer.setBoundingSphere(this.boundingSphere))}}();activateParticles(e){if(this.systemState==x.Running){const t=z.clamp(this.activeParticleCount+e,0,this.maximumActiveParticles);for(let i=this.activeParticleCount;i<t;i++)this.activateParticle(i);this.activeParticleCount=t,this.particleStates.setActiveParticleCount(this.activeParticleCount)}}activateParticle(e){if(this.systemState==x.Running){const t=this.particleStates.getState(e);t.age=0;for(let i=0;i<this.particleStateInitializers.length;i++)this.particleStateInitializers[i].initializeState(t);if(this.simulateInWorldSpace){t.position.applyMatrix4(this.owner.matrixWorld);const i=t.velocity.length();if(this.transformInitialDirectionInWorldSpace){t.velocity.transformDirection(this.owner.matrixWorld).multiplyScalar(i);const s=t.acceleration.length();t.acceleration.transformDirection(this.owner.matrixWorld).multiplyScalar(s)}}this.particleStates.flushParticleStateToBuffers(e)}}advanceActiveParticles(e){if(this.systemState==x.Running){let t=0;for(;t<this.activeParticleCount;){if(!this.advanceActiveParticle(t,e)){t<this.activeParticleCount-1&&this.copyParticleInArray(this.activeParticleCount-1,t),this.activeParticleCount--;continue}t++}this.particleStates.setActiveParticleCount(this.activeParticleCount)}}advanceActiveParticle(e,t){if(this.systemState==x.Running){const i=this.particleStates.getState(e);for(let s=0;s<this.particleStateOperators.length;s++){const a=this.particleStateOperators[s].updateState(i,t),l=i.lifetime;if(!a||l!=0&&i.age>=l)return!1}return this.particleStates.flushParticleStateToBuffers(e),!0}return!1}copyParticleInArray(e,t){this.particleStates.copyState(e,t),this.particleStates.flushParticleStateToBuffers(t)}static fromJSON(e,t,i){const s=(n,w,y)=>{w(n);for(const v in n)if(n.hasOwnProperty(v)){const b=n[v];typeof b=="object"&&s(b,w)}};s(e,n=>{n.type&&(n.type=t.parseTypeString(n.type))});const o=e.maxParticleCount,a=e.simulateInWorldSpace,l=e.renderer,h=l.type.fromJSON(l.params),m=new r.Object3D,p=new C(m,h,i);p.init(o),p.setSimulateInWorldSpace(a);const u=e.emitter,f=u.type.fromJSON(u.params);if(p.setEmitter(f),e.sequences)for(const n of e.sequences)p.addParticleSequence(n.start,n.length,n.id);if(e.initializers)for(const n of e.initializers)p.addParticleStateInitializer(n.type.fromJSON(p,n.params));if(e.operators)for(const n of e.operators){const w=p.addParticleStateOperator(n.type.fromJSON(p,n.params));n.elements&&w.addElementsFromParameters(n.elements)}return[p,m]}toJSON(e){const t=this.getParticleSystemRenderer(),i=this.getEmitter(),s=this.getParticleSequences(),o=s.getSequenceIDs().map(u=>{const f=s.getSequence(u);return{id:u,start:f.start,length:f.length}}),a=[],l=this.getParticleStateInitializerCount();for(let u=0;u<l;u++){const f=this.getParticleStateInitializer(u);f.constructor!==K&&a.push({type:e.getTypePath(f.constructor),params:f.toJSON(e)})}const h=[],m=this.getParticleStateOperatorCount();for(let u=0;u<m;u++){const f=this.getParticleStateOperator(u);if(f.constructor!==Q){const n=f.toJSON(e),w=n.params||n,y=n.params?n.elements:null,v={type:e.getTypePath(f.constructor),params:w};y&&(v.elements=y),h.push(v)}}return{maxParticleCount:this.getMaximumActiveParticles(),simulateInWorldSpace:this.getSimulateInWorldSpace(),renderer:{type:e.getTypePath(t.constructor),params:t.toJSON()},emitter:{type:e.getTypePath(i.constructor),params:i.toJSON()},sequences:o,initializers:a,operators:h}}}class re{constructor(){this.particleSystems=[],this.startupTime=performance.now()/1e3,this.lastUpdateTime=this.startupTime,this.componentContainer=new se}update(){const e=z.currentTime(),t=e-this.lastUpdateTime;for(const i of this.particleSystems)i.update(e,t);this.componentContainer.update(e,t),this.lastUpdateTime=e}render(e,t){for(const i of this.particleSystems)i.render(e,t)}addParticleSystem(e){this.particleSystems.push(e)}addComponent(e){this.componentContainer.addComponent(e)}getComponent(e){return this.componentContainer.getComponent(e)}}class ne{constructor(){this.initialized=!1,this.particleCount=0,this.owner=null,this.simulateInWorldSpace=!1}setSimulateInWorldSpace(e){this.simulateInWorldSpace=e}getParticleStateArray(){}setOwner(e){this.owner=e}init(e){if(this.particleCount=e,!this.initialized)return this.initialized=!0,!0;throw new Error("Renderer::init() -> trying to intialize more than once.")}render(){}}class fe extends ee{constructor(){super(),this.geometry=null,this.progressTypes=null,this.lifetimes=null,this.ages=null,this.sequenceElements=null,this.positions=null,this.velocities=null,this.accelerations=null,this.normals=null,this.rotations=null,this.rotationalSpeeds=null,this.sizes=null,this.colors=null,this.initialSizes=null,this.initialColors=null,this.instanced=!1,this.verticesPerParticle=6}init(e,t=!1){this.instanced=t,this.instanced?this.verticesPerParticle=1:this.verticesPerParticle=6,super.init(e),this.allocate(e)}setParticleCount(e){super.setParticleCount(e)}setActiveParticleCount(e){super.setActiveParticleCount(e),e>0?this.instanced?this.geometry.instanceCount=e:this.geometry.setDrawRange(0,this.verticesPerParticle*e):this.instanced?this.geometry.instanceCount=0:this.geometry.setDrawRange(0,0)}flushParticleStateToBuffers(e){if(e>=this.particleCount)throw new Error('ParticleStateAttributeArray::flushParticleStateToBuffers() -> "index" is out of range.');const t=this.getState(e),i=e*this.verticesPerParticle;for(let s=0;s<this.verticesPerParticle;s++)this.lifetimes.setX(i+s,t.lifetime),this.lifetimes.needsUpdate=!0,this.ages.setX(i+s,t.age),this.ages.needsUpdate=!0,this.sequenceElements.setXYZW(i+s,t.sequenceElement.x,t.sequenceElement.y,t.sequenceElement.z,t.sequenceElement.w),this.sequenceElements.needsUpdate=!0,this.positions.setXYZ(i+s,t.position.x,t.position.y,t.position.z),this.positions.needsUpdate=!0,this.velocities.setXYZ(i+s,t.velocity.x,t.velocity.y,t.velocity.z),this.velocities.needsUpdate=!0,this.accelerations.setXYZ(i+s,t.acceleration.x,t.acceleration.y,t.acceleration.z),this.accelerations.needsUpdate=!0,this.normals.setXYZ(i+s,t.normal.x,t.normal.y,t.normal.z),this.normals.needsUpdate=!0,this.rotations.setX(i+s,t.rotation),this.rotations.needsUpdate=!0,this.rotationalSpeeds.setX(i+s,t.rotationalSpeed),this.rotationalSpeeds.needsUpdate=!0,this.sizes.setXY(i+s,t.size.x,t.size.y),this.sizes.needsUpdate=!0,this.colors.setXYZ(i+s,t.color.r,t.color.g,t.color.b),this.colors.needsUpdate=!0,this.alphas.setX(i+s,t.alpha),this.alphas.needsUpdate=!0,this.initialSizes.setXY(i+s,t.initialSize.x,t.initialSize.y),this.initialSizes.needsUpdate=!0,this.initialAlphas.setX(i+s,t.initialAlpha),this.initialAlphas.needsUpdate=!0}copyState(e,t){super.copyState(e,t),this.flushParticleStateToBuffers(t)}setState(e,t){if(e>=this.particleCount)throw new Error('ParticleStateAttributeArray::setState() -> "index" is out of range.');super.setState(e,t),this.flushParticleStateToBuffers(e)}getPositions(){return this.positions}getSizes(){return this.sizes}getRotations(){return this.rotations}getSequenceElements(){return this.sequenceElements}getColors(){return this.colors}getGeometry(){return this.geometry}allocate(e){super.allocate(e);const t=(I,c)=>this.instanced?new r.InstancedBufferAttribute(I,c):new r.BufferAttribute(I,c),i=this.verticesPerParticle*this.particleCount;if(this.instanced){const I=new r.BufferGeometry,c=new Float32Array(18);this.basePositions=new r.BufferAttribute(c,3),I.setAttribute("position",this.basePositions),this.basePositions.needsUpdate=!0,this.basePositions.setXYZ(0,-1,1,0),this.basePositions.setXYZ(1,-1,-1,0),this.basePositions.setXYZ(2,1,1,0),this.basePositions.setXYZ(3,-1,-1,0),this.basePositions.setXYZ(4,1,-1,0),this.basePositions.setXYZ(5,1,1,0);const A=new Float32Array(12);this.baseUVs=new r.BufferAttribute(A,2),I.setAttribute("baseUV",this.baseUVs),this.baseUVs.needsUpdate=!0,this.baseUVs.setXY(0,0,1),this.baseUVs.setXY(1,0,0),this.baseUVs.setXY(2,1,1),this.baseUVs.setXY(3,0,0),this.baseUVs.setXY(4,1,0),this.baseUVs.setXY(5,1,1);const G=new Float32Array(6);this.customIndexes=new r.BufferAttribute(G,1),I.setAttribute("customIndex",this.customIndexes),this.customIndexes.needsUpdate=!0,this.customIndexes.setX(0,0),this.customIndexes.setX(1,1),this.customIndexes.setX(2,3),this.customIndexes.setX(3,1),this.customIndexes.setX(4,2),this.customIndexes.setX(5,3),this.geometry=new r.InstancedBufferGeometry().copy(I),this.geometry.instanceCount=0}else{this.geometry=new r.BufferGeometry;const I=new Float32Array(i);this.customIndexes=new r.BufferAttribute(I,1),this.geometry.setAttribute("customIndex",this.customIndexes),this.customIndexes.needsUpdate=!0;for(let c=0;c<this.particleCount;c++){const A=c*this.verticesPerParticle;this.customIndexes.setX(A,0),this.customIndexes.setX(A+1,1),this.customIndexes.setX(A+2,3),this.customIndexes.setX(A+3,1),this.customIndexes.setX(A+4,2),this.customIndexes.setX(A+5,3)}}const s=new Float32Array(i),o=new Float32Array(i),a=new Float32Array(i*4),l=new Float32Array(i*3),h=new Float32Array(i*3),m=new Float32Array(i*3),p=new Float32Array(i*3),u=new Float32Array(i),f=new Float32Array(i),n=new Float32Array(i*2),w=new Float32Array(i*3),y=new Float32Array(i),v=new Float32Array(i*2),b=new Float32Array(i*3),V=new Float32Array(i);this.positions=t(l,3),this.positions.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("particlePosition",this.positions),this.lifetimes=t(s,1),this.lifetimes.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("lifetime",this.lifetimes),this.ages=t(o,1),this.ages.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("age",this.ages),this.sequenceElements=t(a,4),this.sequenceElements.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("sequenceElement",this.sequenceElements),this.velocities=t(h,3),this.velocities.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("velocity",this.velocities),this.accelerations=t(m,3),this.accelerations.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("acceleration",this.accelerations),this.normals=t(p,3),this.normals.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("normal",this.normals),this.rotations=t(u,1),this.rotations.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("rotation",this.rotations),this.rotationalSpeeds=t(f,1),this.rotationalSpeeds.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("rotationalSpeed",this.rotationalSpeeds),this.sizes=t(n,2),this.sizes.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("size",this.sizes),this.colors=t(w,3),this.colors.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("color",this.colors),this.alphas=t(y,1),this.alphas.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("alpha",this.alphas),this.initialSizes=t(v,2),this.initialSizes.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("initialSize",this.initialSizes),this.initialColors=t(b,3),this.initialColors.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("initialColor",this.initialColors),this.initialAlphas=t(V,1),this.initialAlphas.setUsage(r.DynamicDrawUsage),this.geometry.setAttribute("initialAlpha",this.initialAlphas)}dispose(){super.dispose(),this.geometry&&(this.geometry.dispose(),this.geometry=null)}}class Se{constructor(e,t,i,s,o){this.length=e,this.x=t,this.y=i,this.width=s,this.height=o}}class Y{constructor(e,t){this.texture=e,this.texturePath=t,this.frameSets=[]}getTexture(){return this.texture}getTexturePath(){return this.texturePath}getFrameSetCount(){return this.frameSets.length}addFrameSet(e,t,i,s,o){this.frameSets.push(new Se(e,t,i,s,o))}getFrameSet(e){if(e>=this.frameSets.length)throw new Error('Atlas::getFrameSet -> "index" is out of range.');return this.frameSets[e]}}class F extends ne{constructor(e,t,i=!1,s=r.NormalBlending,o=!0,a){super(),this.instanced=e,this.particleStateArray=null,this.material=null,this.mesh=null,this.atlas=t,this.interpolateAtlasFrames=i,this.blending=s,this.boundingBox=new r.Box3,this.boundingSphere=new r.Sphere,this.calculateBoundingSphereFromBox=o,this.renderOrder=a}setOwner(e){super.setOwner(e)}getParticleStateArray(){return this.particleStateArray}setSimulateInWorldSpace(e){super.setSimulateInWorldSpace(e),this.material&&(this.material.uniforms.simulateInWorldSpace.value=e?1:0,this.material.uniformsNeedUpdate=!0)}calculatingBoundingSphereFromBox(){return this.calculateBoundingSphereFromBox}setBoundingBox(e){this.boundingBox.copy(e),this.mesh&&this.updateMeshBounds()}setBoundingSphere(e){this.boundingSphere.copy(e),this.mesh&&this.updateMeshBounds()}render(e,t,i){t.render(e,i)}updateMeshBounds=function(){const e=new r.Vector3;return function(){const t=this.particleStateArray.getGeometry();if(this.calculateBoundingSphereFromBox){t.boundingBox||(t.boundingBox=new r.Box3),t.boundingBox.copy(this.boundingBox),t.boundingSphere||(t.boundingSphere=new r.Sphere),e.x=(this.boundingBox.min.x+this.boundingBox.max.x)/2,e.y=(this.boundingBox.min.y+this.boundingBox.max.y)/2,e.z=(this.boundingBox.min.z+this.boundingBox.max.z)/2;const i=this.boundingBox.max.x-e.x,s=this.boundingBox.max.y-e.y,o=this.boundingBox.max.z-e.z,a=Math.max(Math.max(i,s),o);t.boundingSphere.center.copy(e),t.boundingSphere.radius=Math.sqrt(2*a*a)}else t.boundingSphere||(t.boundingSphere=new r.Sphere),t.boundingSphere.copy(this.boundingSphere)}}();init(e){super.init(e)&&(this.particleStateArray=new fe,this.particleStateArray.init(e,this.instanced),this.material=this.createMaterial(null,null,null,!0,!1),this.material.blending=this.blending,this.mesh=new r.Mesh(this.particleStateArray.getGeometry(),this.material),this.mesh.frustumCulled=!0,this.renderOrder!==void 0&&(this.mesh.renderOrder=this.renderOrder),this.updateMeshBounds(),this.owner.add(this.mesh))}dispose(){this.particleStateArray.dispose()}createMaterial(e,t,i,s,o){const a=[...Array(16).keys()].map(f=>new r.Vector4);if(this.atlas)for(let f=0;f<this.atlas.getFrameSetCount();f++){const n=this.atlas.getFrameSet(f);a[f]=new r.Vector4(n.x,n.y,n.width,n.height)}const l=this.atlas?this.atlas.getTexture():null,h=this.interpolateAtlasFrames,m=this.simulateInWorldSpace,p=this.instanced?1:0,u={atlasFrameSet:{type:"v4v",value:a},atlasTexture:{type:"t",value:l},interpolateAtlasFrames:{value:h},uvOffset:{type:"v2",value:new r.Vector2},simulateInWorldSpace:{value:m},instanced:{value:p}};return i=i||{},Object.assign(i,u),e=e||F.Shader.getVertexShader(o),t=t||F.Shader.getFragmentShader(s,o),new r.ShaderMaterial({uniforms:i,vertexShader:e,fragmentShader:t,transparent:!0,alphaTest:1,blending:r.NormalBlending,blendDstAlpha:r.OneMinusSrcAlphaFactor,blendSrcAlpha:r.SrcAlphaFactor,depthTest:!0,depthWrite:!1})}static Shader={get VertexVars(){return[`const int MAX_ATLAS_FRAME_SETS = 16; 
`,`uniform vec4 atlasFrameSet[MAX_ATLAS_FRAME_SETS]; 
`,`uniform int interpolateAtlasFrames; 
`,`uniform int simulateInWorldSpace; 
`,`uniform int instanced; 
`,`attribute vec2 baseUV;
`,`attribute float customIndex;
`,`attribute vec4 particlePosition;
`,`attribute float rotation;
`,`attribute vec2 size;
`,`attribute vec4 sequenceElement;
`,`attribute vec3 color;
`,`attribute float alpha;
`,`varying vec2 vUV1;
`,`varying vec2 vUV2;
`,`varying vec3 vFragColor;
`,`varying float vFragAlpha;
`,`varying float vSequenceElementT; 
`].join(`
`)},get FragmentVars(){return[`uniform int interpolateAtlasFrames; 
`,`uniform sampler2D atlasTexture;
`,`uniform vec2 uvOffset;
`,`varying vec2 vUV1;
`,`varying vec2 vUV2;
`,`varying vec3 vFragColor;
`,`varying float vFragAlpha;
`,`varying float vSequenceElementT;
`].join(`
`)},getVertexShader(e){let t=["#include <common>",this.VertexVars].join(`
`);return e&&(t+=`  
 #include <logdepthbuf_pars_vertex> 
`),t+=[`void getUV(in int sequenceElement, in int sequenceNumber, in vec4 atlasFrames, out vec2 uv) { 
`,`   float atlasFrameWidth = atlasFrames.z; 
`,`   float atlasFrameHeight = atlasFrames.w; 
`,`   float atlasFrameX = atlasFrames.x; 
`,`   float atlasFrameY = atlasFrames.y; 
`,`   int firstRowSections = int((1.0 - atlasFrameX) / atlasFrameWidth); 
`,`   int maxRowSections = int(1.0 / atlasFrameWidth); 
`,`   float firstRowX = atlasFrameX + atlasFrameWidth * float(sequenceElement); 
`,`   float firstRowY = 1.0 - (atlasFrameY + atlasFrameHeight); 
`,`   int nRowSequenceElement = sequenceElement - firstRowSections; 
`,`   float SNOverHS = float(nRowSequenceElement) / float(maxRowSections);
`,`   int nRowYTile = int(SNOverHS);
`,`   int nRowXTile = int((SNOverHS - float(nRowYTile)) * float(maxRowSections));
`,`   float nRowX = float(nRowXTile) * atlasFrameWidth;
`,`   float nRowY = 1.0 - ((float(nRowYTile) + 1.0) * (atlasFrameHeight) + atlasFrameY + atlasFrameHeight);
`,`   float nRow = step(float(firstRowSections), float(sequenceElement)); 
`,`   uv.x = nRow * nRowX + (1.0 - nRow) * firstRowX; 
`,`   uv.y = nRow * nRowY + (1.0 - nRow) * firstRowY; 
`,`} 
`,`void main()
`,`{
`,`   const vec2 right = vec2(1.0, 0.0);
`,`   const vec2 up = vec2(0.0, 1.0);
`,`   const vec2 left = vec2(-1.0, 0.0);
`,`   const vec2 down = vec2(0.0, -1.0);
`,`   const vec2 uRight = vec2(1.0, 1.0);
`,`   const vec2 uLeft = vec2(-1.0, 1.0);
`,`   const vec2 dLeft = vec2(-1.0, -1.0);
`,`   const vec2 dRight = vec2(1.0, -1.0);
`,`   vec4 viewPosition; 
`,`   if (simulateInWorldSpace == 1) { 
`,`       viewPosition = viewMatrix * particlePosition;
`,`   } else { 
`,`       viewPosition = viewMatrix * modelMatrix * particlePosition;
`,`   } 
`,`   float sequenceElementF = sequenceElement.x;
`,`   int sequenceNumber = int(sequenceElement.y);
`,`   int sequenceStart = int(sequenceElement.z);
`,`   int sequenceLength = int(sequenceElement.w);
`,`   vec4 atlasFrames = atlasFrameSet[sequenceNumber]; 
`,`   vec2 uv1; 
`,`   vec2 uv2; 
`,`   vSequenceElementT = sequenceElementF - float(int(sequenceElementF)); 
`,`   int firstSequenceElement = int(sequenceElementF); 
`,`   int secondSequenceElement = clamp(firstSequenceElement + 1, sequenceStart, sequenceStart + sequenceLength - 1); 
`,`   getUV(firstSequenceElement, sequenceNumber, atlasFrames, uv1); 
`,`   if (interpolateAtlasFrames == 1 && firstSequenceElement != secondSequenceElement) { 
 `,`       getUV(secondSequenceElement, sequenceNumber, atlasFrames, uv2); 
`,`   } 
`,`   float atlasFrameWidth = atlasFrames.z; 
`,`   float atlasFrameHeight = atlasFrames.w; 
`,`   float rotMag = rotation; 
`,`   mat2 rotMat = mat2(cos(rotMag), -sin(rotMag), sin(rotMag), cos(rotMag)) * mat2(size.x, 0.0, 0.0, size.y);
`,`   float rightSide; 
`,`   float upperSide; 
`,`   if (instanced != 1) { 
`,`       rightSide = step(2.0, customIndex); 
`,`       vec2 upperSideStep = step(vec2(customIndex, 3.0), vec2(0.0, customIndex));
`,`       upperSide = upperSideStep.x + upperSideStep.y;
`,`   }  else { 
`,`       rightSide = baseUV.x; 
`,`       upperSide = baseUV.y; 
`,`   } 
`,`   float uvXOffset = atlasFrameWidth * rightSide; 
`,`   float uvYOffset = atlasFrameHeight * upperSide; 
`,`   vec2 rotVec; 
`,`   if (instanced != 1) { 
`,`       vec4 rotVecStep = step(vec4(customIndex, customIndex, 3.0, 2.0), vec4(0.0, 1.0, customIndex, customIndex)); 
`,`       float uLeftV = rotVecStep.x; 
`,`       float dLeftV = rotVecStep.y - rotVecStep.x; 
`,`       float uRightV = rotVecStep.z; 
`,`       float dRightV = rotVecStep.w - rotVecStep.z; 
`,`       rotVec = uLeft * uLeftV + dLeft * dLeftV + dRight * dRightV + uRight * uRightV; 
`,`   }  else { 
`,`       rotVec = position.xy; 
 `,`   } 
`,`   gl_Position = projectionMatrix * (vec4(rotMat * rotVec, 0.0, 0.0) + viewPosition);
`,`   vUV1 = vec2(uv1.x + uvXOffset, uv1.y + uvYOffset);
`,`   vUV2 = vec2(uv2.x + uvXOffset, uv2.y + uvYOffset);
`,`   vFragColor = color; 
`,`   vFragAlpha = alpha; 
`].join(`
`),e&&(t+=`   
  #include <logdepthbuf_vertex> 
`),t+=`} 
`,t},getFragmentShader(e,t){let i=`#include <common> 
${this.FragmentVars}
`;return t&&(i+=`  
 #include <logdepthbuf_pars_fragment> 
`),i+=`void main() { 
`,t&&(i+=`    
  #include <logdepthbuf_fragment> 
`),e?i+=[`   vec4 color1 = texture(atlasTexture, vUV1 + uvOffset) * vec4(vFragColor, 1.0);
`,`   vec4 color2 = color1; 
`,`   if (interpolateAtlasFrames == 1) color2 = texture(atlasTexture, vUV2 + uvOffset) * vec4(vFragColor, 1.0);
`,`   gl_FragColor = mix(color1, color2, vSequenceElementT);
`,`   gl_FragColor.a *= vFragAlpha; 
`].join(`
`):i+=[`   vec4 color1 = texture2D(atlasTexture, vUV1 + uvOffset) * vec4(vFragColor, 1.0);
`,`   vec4 color2 = color1; 
`,`   if (interpolateAtlasFrames == 1) color2 = texture(atlasTexture, vUV2 + uvOffset) * vec4(vFragColor, 1.0);
`,`   gl_FragColor = mix(color1, color2, vSequenceElementT);
`,`   gl_FragColor.a *= vFragAlpha; 
`].join(`
`),i+=`}
`,i}};static fromJSON(e){const t=e.atlas,i=new r.TextureLoader().load(t.texturePath),s=new Y(i,t.texturePath),o=t.framesets;for(const l of o)s.addFrameSet(l.length,l.x,l.y,l.width,l.height);const a=new F(e.instanced,s,t.interpolateFrames);return e.blending=="Additive"?a.blending=r.AdditiveBlending:a.blending=r.NormalBlending,a}toJSON(e){e=e||(a=>{if(a.texturePath)return a.texturePath;const h=a.getTexture().source;if(h){const m=h.data;if(m){const p=m.baseURI,u=m.currentSrc;return u.indexOf(p)>=0?u.substr(p.length,u.length-p.length):u}}});const i=[];for(let a=0;a<this.atlas.getFrameSetCount();a++){const l=this.atlas.getFrameSet(a);i.push(l)}let s="Normal";return this.material.blending===r.AdditiveBlending&&(s="Additive"),{instanced:this.instanced,blending:s,atlas:{interpolateFrames:this.interpolateAtlasFrames,texturePath:e(this.atlas),framesets:i}}}}class ge{constructor(){this.emissionRelativeStartTime=0,this.emissionDuration=0,this.emitCount=0,this.age=0,this.timeActive=0,this.activeCount=0,this.maximumActiveParticles=0}update(e){return this.internalUpdate(e),0}internalUpdate(e){return this.age+=e,this.timeActive=Math.max(this.age-this.emissionRelativeStartTime,0),this.age>=this.emissionRelativeStartTime&&(this.emissionDuration==0||this.timeActive<=emissionDuration)}updateEmitCount(e){this.emitCount+=e}}class ye extends ge{constructor(){super(),this.emissionMinimum=0,this.emissionMaximum=0}}class E extends ye{constructor(e=0){super(),this.emissionRate=e}update(e){if(this.internalUpdate(e)){const t=this.emissionRate*this.timeActive-this.emitCount;if(t>=1){const i=Math.floor(t);return this.updateEmitCount(i),i}}return 0}static fromJSON(e){const t=new E;return t.emissionRate=e.emissionRate||0,t}toJSON(){return{emissionRate:this.emissionRate}}}class g{static Default=new g("Default");static Vector2=new g("Vector2");static Vector3=new g("Vector3");static Vector4=new g("Vector4");static Color=new g("Color");constructor(e){this.name=e}static getTypeID(e){let t=g.Default;return e===r.Vector2?t=g.Vector2:e===r.Vector3?t=g.Vector3:e===r.Vector4?t=g.Vector4:e===r.Color&&(t=g.Color),t}static loadJSONParameter(e,t){switch(t){case r.Vector2:return new r.Vector2().fromArray(e);case r.Vector3:return new r.Vector3().fromArray(e);case r.Vector4:return new r.Vector4().fromArray(e);case r.Color:return new r.Color().fromArray(e)}return e}}class ae{constructor(e){this.outType=e,this.outTypeID=g.getTypeID(e)}}class P extends ae{constructor(e,t,i,s,o,a){super(e),this.range=t,this.offset=i,this.uniformRange=s,this.uniformOffset=o,this.normalize=a}generate(e){const t=Math.random()*this.uniformRange;switch(this.outTypeID){case g.Default:e=Math.random()*this.range+this.offset,this.normalize&&(e=e<0?-1:1);break;case g.Vector2:e.set(this.generateForElement(t,"x"),this.generateForElement(t,"y"));break;case g.Vector3:e.set(this.generateForElement(t,"x"),this.generateForElement(t,"y"),this.generateForElement(t,"z"));break;case g.Vector4:e.set(this.generateForElement(t,"x"),this.generateForElement(t,"y"),this.generateForElement(t,"z"),this.generateForElement(t,"w"));break}return this.normalize&&e.normalize(),e}generateForElement(e,t){return e+Math.random()*this.range[t]+this.offset[t]+this.uniformOffset}clone(){return new P(this.outType,this.range,this.offset,this.uniformRange,this.uniformOffset,this.normalize)}static getParameterJSON(e){return e instanceof r.Vector2||e instanceof r.Vector3||e instanceof r.Vector4||e instanceof r.Color?e.toArray():e}static fromJSON(e){return new P(e.type,g.loadJSONParameter(e.range,e.type),g.loadJSONParameter(e.offset,e.type),e.uniformRange||0,e.uniformOffset||0,e.normalize)}toJSON(e){const t={range:P.getParameterJSON(this.range),offset:P.getParameterJSON(this.offset),uniformRange:this.uniformRange,uniformOffset:this.uniformOffset},i=e.getTypePath(this.range.constructor);return i!=null&&(t.type=i),{type:e.getTypePath(P),params:t}}}class q extends O{constructor(e,t,i,s,o){super(),this.range=e,this.offset=t,this.uniformRange=i,this.uniformOffset=s,this.normalize=o,this.generator=new P(0,this.range,this.offset,this.uniformRange,this.uniformOffset,this.normalize)}initializeState(e){e.lifetime=this.generator.generate()}static fromJSON(e,t){return new q(t.range,t.offset,t.uniformRange,t.uniformOffset,t.normalize)}toJSON(){return{range:this.range,offset:this.offset,uniformRange:this.uniformRange,uniformOffset:this.uniformOffset,normalize:this.normalize}}}class W extends O{constructor(e){super(),this.generator=e.clone()}initializeState(e){e.rotation=this.generator.generate(e.rotation)}static fromJSON(e,t){const i=t.generator.type.fromJSON(t.generator.params);return new W(i)}toJSON(e){return{generator:this.generator.toJSON(e)}}}class j extends O{constructor(e,t,i,s,o){super(),this.range=e,this.offset=t,this.uniformRange=i,this.uniformOffset=s,this.normalize=o,this.generator=new P(0,this.range,this.offset,this.uniformRange,this.uniformOffset,this.normalize)}initializeState(e){e.rotationalSpeed=this.generator.generate()}static fromJSON(e,t){return new j(t.range,t.offset,t.uniformRange,t.uniformOffset,t.normalize)}toJSON(){return{range:this.range,offset:this.offset,uniformRange:this.uniformRange,uniformOffset:this.uniformOffset,normalize:this.normalize}}}class R extends O{constructor(e,t){super(),this.randomGenerator=new P(r.Vector3,e,t,0,0,!1)}initializeState(e){this.randomGenerator.generate(e.position)}static fromJSON(e,t){return new R(new r.Vector3().fromArray(t.range),new r.Vector3().fromArray(t.offset))}toJSON(){return{range:this.randomGenerator.range.toArray(),offset:this.randomGenerator.offset.toArray()}}}class N extends O{constructor(e){super(),this.generator=e.clone()}initializeState(e){this.generator.generate(e.size),e.initialSize.copy(e.size)}static fromJSON(e,t){const i=t.generator.type.fromJSON(t.generator.params);return new N(i)}toJSON(e){return{generator:this.generator.toJSON(e)}}}class U extends O{constructor(e,t,i,s,o=!0){super(),this.directionGenerator=new P(r.Vector3,e,t,0,0,!0),this.speedGenerator=new P(0,i,s,0,0,!1),this.normalizeDirection=o}initializeState(e){this.directionGenerator.generate(e.velocity),this.normalizeDirection&&e.velocity.normalize(),e.velocity.multiplyScalar(this.speedGenerator.generate())}static fromJSON(e,t){return new U(new r.Vector3().fromArray(t.range),new r.Vector3().fromArray(t.offset),t.speedRange,t.speedOffset)}toJSON(){return{range:this.directionGenerator.range.toArray(),offset:this.directionGenerator.offset.toArray(),speedRange:this.speedGenerator.range,speedOffset:this.speedGenerator.offset}}}class k extends O{constructor(e,t=!1){super(),this.setParticleSequences(e),this.reverse=t}setParticleSequences(e){this.particleSequences=e}initializeState(e){const t=this.particleSequences.getSequenceIDs(),i=t.length*Math.random(),s=Math.floor(i),o=t[s],a=this.particleSequences.getSequence(o),l=e.sequenceElement;this.reverse?l.x=a.length-1:l.x=a.start,l.y=a.id,l.z=a.start,l.w=a.length,e.progressType=T.Sequence}static fromJSON(e,t){return new k(e.getParticleSequences(),t.reverse)}toJSON(){return{reverse:this.reverse}}}class L extends _{constructor(e,t,i=!1,s=!1){super(),this.particleSequences=e,this.speed=t,this.loop=i,this.reverse=s}updateState(e,t){const i=e.sequenceElement,s=this.particleSequences.getSequence(i.y),o=t/this.speed;if(this.reverse){if(i.x-=o,i.x<s.start&&(i.x=s.start+s.length,!this.loop))return!1}else if(i.x+=o,i.x>=s.start+s.length&&(i.x=s.start,!this.loop))return!1;return!0}static fromJSON(e,t){return new L(e.getParticleSequences(),t.speed,t.loop,t.reverse)}toJSON(){return{speed:this.speed,loop:this.loop,reverse:this.reverse}}}class H{constructor(e,t){this.elements=[],this.tValues=[],this.elementTypeID=g.getTypeID(e),t?this.interpolator=t:this.interpolator=this.getInterpolatorForTypeID(this.elementTypeID)}*[Symbol.iterator](){let e=0;for(;e<this.getElementCount();)yield{element:this.elements[e],tValue:this.tValues[e]},e++}getElementCount(){return this.elements.length}getElement(e){if(e>=this.getElementCount())throw new Error('ContinuousArray::getElement() -> "index" is out of bounds.');return this.elements[e]}getTValue(e){if(e>=this.getElementCount())throw new Error('ContinuousArray::getTValue() -> "index" is out of bounds.');return this.tValues[e]}addElement(e,t){this.elements.push(e),this.tValues.push(t)}getInterpolatedElement(e,t){return this.interpolator(e,this.elements,this.tValues,t)}getInterpolatorForTypeID=function(){const e={lowerIndex:0,upperIndex:0,localT:0},t=new r.Vector2,i=new r.Vector3,s=new r.Vector4,o=new r.Color,a=l=>(h,m,p,u)=>{H.getInterpolationValuesForTValue(p,h,e),l.copy(m[e.upperIndex]).multiplyScalar(e.localT),u.copy(m[e.lowerIndex]).multiplyScalar(1-e.localT).add(l)};return function(l){switch(l){case g.Default:return(h,m,p)=>(H.getInterpolationValuesForTValue(p,h,e),(1-e.localT)*m[e.lowerIndex]+e.localT*m[e.upperIndex]);case g.Vector2:return a(t);case g.Vector3:return a(i);case g.Vector4:return a(s);case g.Color:return a(o)}}}();static getInterpolationValuesForTValue(e,t,i){const s=e.length;if(s===0){i.lowerIndex=-1,i.upperIndex=-1,i.localT=-1;return}let o=0,a=-1,l=0;for(let p=0;p<s&&(o=e[p],!(o>t));p++)a++,l++;i.lowerIndex=z.clamp(a,0,s-1),i.upperIndex=z.clamp(l,0,s-1);const h=e[a],m=e[l];i.localT=(t-h)/(m-h)}}class te extends _{constructor(e,t=!1){super(),this.relativeToInitialValue=t,this.interpolationElements=new H(e)}addElement(e,t){this.interpolationElements.addElement(e,t)}addElements(e){for(const t of e)this.interpolationElements.addElement(t[0],t[1])}addElementsFromElementClassAndParameters(e,t){for(const i of t){const[...s]=i[0];this.interpolationElements.addElement(new e(...s),i[1])}}getInterpolatedValue(e,t){let i=0;switch(e.progressType){case T.Time:e.lifetime!=0?i=e.age/e.lifetime:i=e.age;break;case T.Sequence:i=e.sequenceElement.x/e.sequenceElement.w;break}return this.interpolationElements.getInterpolatedElement(i,t)}}class D extends te{constructor(e=!1){super(0,e)}addElementsFromParameters(e){super.addElements(e)}updateState(e){return this.relativeToInitialValue?e.alpha=e.initialAlpha*this.getInterpolatedValue(e,e.alpha):e.alpha=this.getInterpolatedValue(e,e.alpha),!0}static fromJSON(e,t){return new D(t.relativeToInitialValue)}toJSON(){const e={relativeToInitialValue:this.relativeToInitialValue},t=[...this.interpolationElements].map(i=>[i.element,i.tValue]);return{params:e,elements:t}}}class Z extends te{constructor(e=!1){super(r.Vector2,e)}addElementsFromParameters(e){super.addElementsFromElementClassAndParameters(r.Vector2,e)}updateState=function(){const e=new r.Vector2;return function(t){return this.getInterpolatedValue(t,e),this.relativeToInitialValue?t.size.set(t.initialSize.x*e.x,t.initialSize.y*e.y):t.size.copy(e),!0}}();static fromJSON(e,t){return new Z(t.relativeToInitialValue)}toJSON(){const e={relativeToInitialValue:this.relativeToInitialValue},t=[...this.interpolationElements].map(i=>[i.element.toArray(),i.tValue]);return{params:e,elements:t}}}class B extends te{constructor(e=!1){super(r.Color,e)}addElementsFromParameters(e){super.addElementsFromElementClassAndParameters(r.Color,e)}updateState=function(){const e=new r.Color;return function(t){return this.getInterpolatedValue(t,e),this.relativeToInitialValue?t.color.setRGB(t.initialColor.r*e.r,t.initialColor.g*e.g,t.initialColor.b*e.b):t.color.copy(e),!0}}();static fromJSON(e,t){return new B(t.relativeToInitialValue)}toJSON(){const e={relativeToInitialValue:this.relativeToInitialValue},t=[...this.interpolationElements].map(i=>[i.element.toArray(),i.tValue]);return{params:e,elements:t}}}class M extends _{constructor(e){super(),this.generator=e.clone()}addElementsFromParameters(e){super.addElementsFromElementClassAndParameters(THREE.Vector3,e)}updateState(e){return this.generator.generate(e.acceleration),!0}static fromJSON(e,t){const i=t.generator.type.fromJSON(t.generator.params);return new M(i)}toJSON(e){return{generator:this.generator.toJSON(e)}}}class X extends ae{constructor(e,t,i,s,o,a,l,h,m,p,u,f){super(r.Vector3),this.rangeTheta=e,this.offsetTheta=t,this.rangePhi=i,this.offsetPhi=s,this.rangeRadius=o,this.offsetRadius=a,this.scaleX=l,this.scaleY=h,this.scaleZ=m,this.offsetX=p,this.offsetY=u,this.offsetZ=f,this.tempUp=new r.Vector3().set(0,1,0)}generate(e){this.tempUp.set(0,1,0);const t=Math.random()*this.rangeTheta+this.offsetTheta,i=Math.random()*this.rangePhi+this.offsetPhi,s=Math.cos(t),o=Math.sin(t),a=Math.cos(i),l=Math.sin(i);e.set(s,0,-o),e.multiplyScalar(a),this.tempUp.multiplyScalar(l),e.add(this.tempUp),e.normalize();const h=Math.random()*this.rangeRadius+this.offsetRadius;e.multiplyScalar(h),e.x*=this.scaleX,e.y*=this.scaleY,e.z*=this.scaleZ,e.x+=this.offsetX,e.y+=this.offsetY,e.z+=this.offsetZ}clone(){return new X(this.rangeTheta,this.offsetTheta,this.rangePhi,this.offsetPhi,this.rangeRadius,this.offsetRadius,this.scaleX,this.scaleY,this.scaleZ,this.offsetX,this.offsetY,this.offsetZ)}static fromJSON(e){return new X(e.rangeTheta,e.offsetTheta,e.rangePhi,e.offsetPhi,e.rangeRadius,e.offsetRadius,e.scaleX,e.scaleY,e.scaleZ,e.offsetX,e.offsetY,e.offsetZ)}toJSON(e){return{type:e.getTypePath(X),params:{rangeTheta:this.rangeTheta,offsetTheta:this.offsetTheta,rangePhi:this.rangePhi,offsetPhi:this.offsetPhi,rangeRadius:this.rangeRadius,offsetRadius:this.offsetRadius,scaleX:this.scaleX,scaleY:this.scaleY,scaleZ:this.scaleZ,offsetX:this.offsetX,offsetY:this.offsetY,offsetZ:this.offsetZ}}}}class we{constructor(){}}class oe extends we{constructor(e,t,i,s,o,a,l=void 0){super(),this.owner=null,this.light=null,this.lastUpdateTime=performance.now()/1e3,this.lastIntensityFlickerTime=this.lastUpdateTime,this.lastPositionFlickerTime=this.lastUpdateTime,this.lastIntensityAdjuster=1,this.nextIntensityAdjuster=1,this.lastPositionAdjuster=new r.Vector3,this.positionAdjuster=new r.Vector3,this.intensity=1,this.intensityFlux=2,this.parent=e,this.init(e,t,i,s,o,a,l)}init(e,t,i,s,o,a,l=void 0){this.owner=new r.Object3D,e.add(this.owner),s=s||new r.Color,o=o||0,(a==null||a==null)&&(a=2);const h=!!l;return this.light=new r.PointLight(16777215,2,0,1),this.light.color.copy(s),this.light.distance=o,this.light.decay=a,this.light.castShadow=h,h&&(this.light.shadow.mapSize.width=l.mapSize||512,this.light.shadow.mapSize.height=l.mapSize||512,this.light.shadow.camera.near=l.cameraNear||.5,this.light.shadow.camera.far=l.cameraFar||500,this.light.shadow.bias=l.bias||1e-4,this.light.shadow.radius=l.edgeRadius||1),this.owner.add(this.light),this.intensity=t,this.intensityFlux=i,this.light}dispose(){this.parent.remove(this.owner)}getLight(){return this.light}setIntensity(e){this.intensity=e}update(e){const t=e-this.lastIntensityFlickerTime,s=1/8,o=this.intensityFlux,a=.25,l=1.5;if(t>s){this.lastIntensityFlickerTime=e;let f=1+(Math.random()-.5)*2*o*s;const n=f-this.lastIntensityAdjuster;f=this.lastIntensityAdjuster+n,this.lastIntensityAdjuster=this.nextIntensityAdjuster,this.nextIntensityAdjuster=z.clamp(f,a,l)}else{const u=t/s,f=(1-u)*this.lastIntensityAdjuster+u*this.nextIntensityAdjuster;this.light.intensity=f*this.intensity}const h=e-this.lastPositionFlickerTime,p=1/16;if(h>p){this.lastPositionFlickerTime=e;const u=e-this.lastUpdateTime;this.positionAdjuster.set(Math.random()-.5,Math.random()-.5,Math.random()-.5),this.positionAdjuster.multiplyScalar(u),this.positionAdjuster.add(this.lastPositionAdjuster),this.positionAdjuster.multiplyScalar(.5),this.owner.position.copy(this.positionAdjuster),this.lastPositionAdjuster.copy(this.positionAdjuster),this.lastUpdateTime=e}}}class le{constructor(){this.jsonTypes={default:{}},this.jsonTypeNames={},this.typeIDGen=0}addType(e,t){this.addTypeToNamespace("default",e,t)}addTypeToNamespace(e,t,i){if(!this.jsonTypes[e])throw new Error("JSONTypeStore::addTypeToNamespace() -> namespace does not exist");if(this.jsonTypes[e][t])throw new Error("JSONTypeStore::addTypeToNamespace() -> typeName already exists");this.checkAndAddTypeName(i,t,e)&&(this.jsonTypes[e][t]=i)}addNamespace(e,t){if(this.jsonTypes[e])throw new Error("JSONTypeStore::addNamespace() -> namespace already exists");this.jsonTypes[e]=t;for(const i in t)if(!t.hasOwnProperty||t.hasOwnProperty(i)){const s=t[i];this.checkAndAddTypeName(s,i,e)}}checkAndAddTypeName(e,t,i){if(typeof e=="function"){const s=this.typeIDGen++;e.___photonsTypeID=s,this.jsonTypeNames[s]={namespace:i,typeName:t}}}getType(e,t){if(!this.jsonTypes[e])throw new Error("JSONTypeStore::getType() -> namespace does not exist");if(!this.jsonTypes[e][t])throw new Error("JSONTypeStore::getType() -> typeName does not exist");return this.jsonTypes[e][t]}getTypeNames(e){return this.jsonTypeNames[e.___photonsTypeID]}getTypePath(e){const t=this.getTypeNames(e);if(t)return`${t.namespace}.${t.typeName}`}parseNamespaceAndTypename(e){const t=e.split("."),i=t[0];t.splice(0,1);const s=t.join(".");return{namespace:i,typeName:s}}parseTypeString(e){const{namespace:t,typeName:i}=this.parseNamespaceAndTypename(e);return this.getType(t,i)}}const ve=Object.freeze(Object.defineProperty({__proto__:null,AccelerationOperator:M,AnimatedSpriteRenderer:F,Atlas:Y,BaseParticleStateInitializer:K,BaseParticleStateOperator:Q,BoxPositionInitializer:R,ColorInterpolatorOperator:B,ConstantParticleEmitter:E,FlickerLight:oe,JSONTypeStore:le,LifetimeInitializer:q,Manager:re,OpacityInterpolatorOperator:D,ParticleStateArray:ee,ParticleSystem:C,ParticleSystemState:x,RandomGenerator:P,RandomVelocityInitializer:U,Renderer:ne,RotationInitializer:W,RotationalSpeedInitializer:j,SequenceInitializer:k,SequenceOperator:L,SizeInitializer:N,SizeInterpolatorOperator:Z,SphereRandomGenerator:X},Symbol.toStringTag,{value:"Module"})),{defineComponent:Pe}=await J("vue"),d=await J("three"),xe=Pe({__name:"fireF",props:{position:{default:[0,0,0]},scale:{default:1}},setup(S){const e=S,t=new re,i=new le;i.addNamespace("THREE",d),i.addNamespace("Photons",ve);const{renderer:s,camera:o,scene:a}=he(),l=(n,w)=>{const y=new d.Object3D;y.position.copy(w);const v="./plugins/digitalCity/image/fireF/ember.png",b=new d.TextureLoader().load(v),V=new Y(b,v);V.addFrameSet(1,0,0,1,1);const I=new F(!0,V,!0,d.AdditiveBlending),c=new C(y,I,s);c.init(150),c.setEmitter(new E(6));const A=new P(d.Vector2,new d.Vector2(0,0),new d.Vector2(n*.15,n*.15),0,0,!1);c.addParticleStateInitializer(new q(3,1,0,0,!1)),c.addParticleStateInitializer(new N(A)),c.addParticleStateInitializer(new R(new d.Vector3(.05*n,0,.05*n),new d.Vector3(-.025*n,0,-.025*n))),c.addParticleStateInitializer(new U(new d.Vector3(.4*n,.5*n,.4*n),new d.Vector3(-.2*n,.8*n,-.2*n),.6*n,.8*n,!1)),c.addParticleStateOperator(new D).addElements([[0,0],[.7,.25],[.9,.75],[0,1]]),c.addParticleStateOperator(new B(!0)).addElementsFromParameters([[[1,.7,0],0],[[1,.6,0],.5],[[1,.4,0],1]]);const $=new X(Math.PI*2,0,Math.PI,-Math.PI/2,20,-8,n,n,n,0,0,0);return c.addParticleStateOperator(new M($)),c.setSimulateInWorldSpace(!0),c.start(),c},h=(n,w)=>{const y=new d.Object3D;y.position.copy(w);const v="./plugins/digitalCity/image/fireF/base_flame.png",b=new d.TextureLoader().load(v),V=new Y(b,v);V.addFrameSet(18,0,0,128/1024,128/512);const I=new F(!0,V,!0),c=new C(y,I,s);c.init(50),c.setEmitter(new E(10)),c.addParticleSequence(0,18);const A=c.getParticleSequences();return c.addParticleStateInitializer(new q(0,0,0,0,!1)),c.addParticleStateInitializer(new W(new P(0,Math.PI/2,-Math.PI/2,0,0,!1))),c.addParticleStateInitializer(new j(1,-1,0,0,!1)),c.addParticleStateInitializer(new N(new P(d.Vector2,new d.Vector2(.25*n,.25*n),new d.Vector2(.5*n,.5*n),0,0,!1))),c.addParticleStateInitializer(new R(new d.Vector3(.05*n,0,.05*n),new d.Vector3(-.025*n,0,-.025*n))),c.addParticleStateInitializer(new U(new d.Vector3(.05*n,.4*n,.05*n),new d.Vector3(-.025*n,.8*n,-.025*n),.35*n,.5*n,!1)),c.addParticleStateInitializer(new k(A)),c.addParticleStateOperator(new L(A,.07,!1)),c.addParticleStateOperator(new D).addElements([[0,0],[.3,.25],[.3,.5],[0,1]]),c.addParticleStateOperator(new Z(!0)).addElementsFromParameters([[[.6,.6],0],[[1,1],.4],[[1,1],1]]),c.addParticleStateOperator(new B(!0)).addElementsFromParameters([[[1,1,1],0],[[1.5,1.5,1.5],.5],[[1,1,1],1]]),c.addParticleStateOperator(new M(new P(d.Vector3,new d.Vector3(0,0,0),new d.Vector3(0,1.5*n,0),0,0,!1))),c.setSimulateInWorldSpace(!0),c.start(),c},m=(n,w)=>{const y=new d.Object3D;y.position.copy(w);const v="./plugins/digitalCity/image/fireF/bright_flame.png",b=new d.TextureLoader().load(v),V=new Y(b,v);V.addFrameSet(16,0,0,212/1024,256/1024);const I=new F(!0,V,!0),c=new C(y,I,s);c.init(20),c.setEmitter(new E(5)),c.addParticleSequence(0,16);const A=c.getParticleSequences();return c.addParticleStateInitializer(new q(0,0,0,0,!1)),c.addParticleStateInitializer(new W(new P(0,Math.PI,-Math.PI/2,0,0,!1))),c.addParticleStateInitializer(new j(Math.PI/2,-Math.PI/4,0,0,!1)),c.addParticleStateInitializer(new N(new P(d.Vector2,new d.Vector2(0,0),new d.Vector2(0,0),.2*n,.65*n,!1))),c.addParticleStateInitializer(new R(new d.Vector3(.1*n,0,.1*n),new d.Vector3(-.05*n,0,-.05*n))),c.addParticleStateInitializer(new U(new d.Vector3(.02*n,.4*n,.02*n),new d.Vector3(-.01*n,.4*n,-.01*n),.1*n,.2*n,!1)),c.addParticleStateInitializer(new k(A)),c.addParticleStateOperator(new L(A,.1,!1)),c.addParticleStateOperator(new D).addElements([[0,0],[.6,.2],[.5,.75],[0,1]]),c.addParticleStateOperator(new Z(!0)).addElementsFromParameters([[[.3,.3],0],[[1,1],.4],[[1,1],.55],[[.65,.65],.75],[[.1,.1],1]]),c.addParticleStateOperator(new B(!0)).addElementsFromParameters([[[1,1,1],0],[[2,2,2],.3],[[2,2,2],.4],[[.9,.6,.3],.65],[[.75,0,0],1]]),c.addParticleStateOperator(new M(new P(d.Vector3,new d.Vector3(0,0,0),new d.Vector3(0,1.5*n,0),0,0,!1))),c.setSimulateInWorldSpace(!0),c.start(),c},p=(n,w=10)=>{const y=new d.Object3D;a.value.add(y),y.position.copy(n);const v={mapSize:1024,cameraNear:.1,cameraFar:5e3,bias:9e-6,edgeRadius:3};return new oe(y,w,2,new d.Color().setRGB(1,.8,.4),0,1,v)},u=new d.Vector3(...e.position);t.addParticleSystem(l(e.scale,u)),t.addParticleSystem(h(e.scale,u)),t.addParticleSystem(m(e.scale,u)),t.addComponent(p(u,100));const{onRender:f}=ue();return f(()=>{t.update(),t.render(s,o.value)}),(n,w)=>null}}),{defineComponent:Ae}=await J("vue"),{createVNode:Ie,withCtx:be,openBlock:Ve,createBlock:Fe}=await J("vue"),{ref:Te,watch:Oe}=await J("vue"),qe=Ae({__name:"fireF",setup(S){const e=Te();return Oe(()=>e.value?.contextReady,t=>{t&&e.value.context.context.camera.activeCamera.value.position.set(580,360,500)}),(t,i)=>(Ve(),Fe(ce,{ref_key:"pagesShowRef",ref:e},{ability:be(()=>[Ie(xe,{position:[0,20,10],scale:40})]),_:1},512))}});export{qe as default};
