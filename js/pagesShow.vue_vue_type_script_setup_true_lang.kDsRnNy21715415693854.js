import{cd as S,a1 as C,l as _,a6 as T,w as B,o as d,c as p,L as f,az as m,ap as M,a9 as L,ce as x,ax as A,a2 as b,a3 as O,a4 as D,a5 as R,aD as G,r as N,x as E,E as P,a8 as H,Y as w,a as h,aa as W,ab as k,ac as F,G as j,Z as g,a0 as I}from"./vendor.bbi2JiG-1715415693854.js";import{C as U}from"./vanilla.S7F0bJrE1715415693854.js";import{L as $,a as V,b as z}from"./LineSegments2.8xxKgZUV1715415693854.js";const Y=async()=>{const e=await S("./plugins/digitalCity/model/shanghai.FBX");let t=null,o=null,i=null;return e.traverse(a=>{a.name==="CITY_UNTRIANGULATED"&&(t=a),a.name==="LANDMASS"&&(o=a),a.name==="ROADS"&&(i=a)}),{model:e,city:t,land:o,roads:i}};var X="varying vec4 vPosition;\nvoid main(){\n	vPosition=modelMatrix*vec4(position,1.);\n	csm_Position=position*vec3(1.);\n}",Z="uniform mat4 modelMatrix;\nvarying vec4 vPosition;\nuniform vec3 uMax;\nuniform vec3 uMin;\nuniform float uOpacity;\nuniform float uBorderWidth;\nuniform vec3 uLightColor;\nuniform vec3 uColor;\nuniform float uCircleTime;\nuniform float uTime;\nuniform vec3 uTopColor;\nuniform bool uGradient;\nvec4 uMax_world;\nvec4 uMin_world;\nvoid main(){\n	\n	uMax_world=modelMatrix*vec4(uMax,1.);\n	uMin_world=modelMatrix*vec4(uMin,1.);\n	vec3 distColor=uColor;\n	float residue=uTime-floor(uTime/uCircleTime)*uCircleTime;\n	float rate=residue/uCircleTime;\n	float lightOffset=rate*(uMax_world.y-uMin_world.y);\n	\n	if(uMin_world.y+lightOffset<vPosition.y&&uMin_world.y+lightOffset+uBorderWidth>vPosition.y){\n		csm_DiffuseColor=vec4(uLightColor,uOpacity);\n	}else{\n		csm_DiffuseColor=vec4(distColor,uOpacity);\n	}\n	\n	\n	if(uGradient){\n		float rateHight=(vPosition.y-uMin_world.y)/(uMax_world.y-uMin_world.y);\n		vec3 outColor=mix(csm_DiffuseColor.xyz,uTopColor,rateHight*2.);\n		csm_DiffuseColor=vec4(outColor,uOpacity);\n	}\n}";const q=["object"],J=C({__name:"buildingsModelCustomShader",props:{model:{},bulidingsColor:{default:"#e523ff"},landColor:{default:"#112233"},topColor:{default:"#ffff00"},opacity:{default:.9},gradient:{type:Boolean,default:!0}},setup(l){const e=l,t=_(0),o=e.model.city;o.renderOrder=1001;const i=e.model.land,a=(r,u)=>{let c;r==="cu"||r==="land"&&(c=Array.isArray(i.material)?i.material:[i.material],c.forEach(y=>{y[u].setStyle(e.landColor),y.side=M}))};(()=>{const{geometry:r}=o;r.computeBoundingBox(),r.computeBoundingSphere();const{max:u,min:c}=r.boundingBox;if(o.material.__csm)return;const y=new U({baseMaterial:o.material,vertexShader:X,fragmentShader:Z,silent:!0,uniforms:{uMax:{value:u},uMin:{value:c},uBorderWidth:{value:5},uCircleTime:{value:5},uColor:{value:new m(e.bulidingsColor)},uOpacity:{value:e.opacity},uLightColor:{value:new m("#ffffff")},uTopColor:{value:new m(e.topColor)},uTime:t,uGradient:{value:e.gradient}},depthWrite:!0,depthTest:!0,transparent:!0,side:M});o.material.dispose(),o.material=y})();const{onLoop:s}=L();s(({delta:r})=>{t.value+=r}),T(()=>{e.bulidingsColor&&o.material.uniforms.uColor.value.setStyle(e.bulidingsColor),e.landColor&&a("land","color"),e.opacity&&(o.material.uniforms.uOpacity.value=e.opacity)}),B(e,(r,u)=>{o.material.uniforms.uGradient.value=r.gradient});const v=e.model.model.clone();return(r,u)=>(d(),p("primitive",{object:f(v)},null,8,q))}}),K=["object"],Q=C({__name:"buildingsLines",props:{builds:{},width:{default:1},color:{default:"#FFF"},opacity:{default:1},style:{default:"Wireframe"}},setup(l){const e=l;let t=null,o=null;if(e.style==="Wireframe"){const i=new x(e.builds.geometry);let n=new $().fromEdgesGeometry(i),s=new V({color:e.color,linewidth:e.width,opacity:e.opacity,transparent:!0,depthWrite:!0,depthTest:!0});s.resolution.set(window.innerWidth,window.innerHeight),t=new z(n,s),t.applyMatrix4(e.builds.matrix.clone())}else{o={transparent:!0,uniforms:{uColor:{value:new m(e.color)},uOpacity:{value:e.opacity}},vertexShader:"\n       void main() {\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:" \n        uniform vec3 uColor;\n				uniform float uOpacity;\n        void main() {\n          gl_FragColor = vec4(uColor, uOpacity);\n        }\n      "};const i=new x(e.builds.geometry),a=new A(o);t=new LineSegments(i,a),t.applyMatrix4(e.builds.matrix.clone()),t.material.linewidth=e.width,t.renderOrder=1e3}return T(()=>{e.style==="Shader"&&(e.color&&(o.uniforms.uColor.value=new m(e.color)),e.opacity&&(o.uniforms.uOpacity.value=e.opacity)),e.style==="Wireframe"&&(e.color&&(t.material.color=new m(e.color)),e.opacity&&(t.material.opacity=e.opacity)),e.width&&(t.material.linewidth=e.width)}),(i,a)=>(d(),p("primitive",{object:f(t)},null,8,K))}}),ee=w("TresAmbientLight",{color:"#ffffff"},null,-1),oe=w("TresDirectionalLight",{position:[100,100,0],intensity:.5,color:"#ffffff"},null,-1),te={key:1,args:[1e3],position:[0,19,0]},ae={key:2,args:[6e3,100],position:[0,19,0]},le=C({__name:"pagesShow",props:{showBuildings:{type:Boolean,default:!0},autoRotate:{type:Boolean,default:!0},showAxesHelper:{type:Boolean,default:!0},showGridHelper:{type:Boolean,default:!0},disableRender:{type:Boolean,default:!1}},async setup(l){let e,t;const o=l,i=b({clearColor:"#000000",shadows:!0,alpha:!1,useLegacyLights:!0,shadowMapType:O,outputColorSpace:D,toneMapping:R,disableRender:o.disableRender}),a=b({autoRotate:o.autoRotate,enableDamping:!0});let n=null;o.showBuildings&&(n=([e,t]=G(()=>Y()),e=await e,t(),e));const s=_(),v=_();return(r,u)=>{const c=N("TresCanvas");return d(),E(c,H({ref_key:"tcRef",ref:v},i,{"window-size":""}),{default:P(()=>[w("TresPerspectiveCamera",{ref_key:"perspectiveCameraRef",ref:s,position:[600,750,-1221],fov:45,near:1,far:1e5},null,512),h(f(F),W(k(a)),null,16),ee,oe,o.showBuildings&&f(n)?(d(),p(j,{key:0},[h(J,{model:f(n)},null,8,["model"]),h(Q,{builds:f(n).city,color:"#000"},null,8,["builds"])],64)):g("",!0),I(r.$slots,"ability"),o.showAxesHelper?(d(),p("TresAxesHelper",te)):g("",!0),o.showGridHelper?(d(),p("TresGridHelper",ae)):g("",!0)]),_:3},16)}}});export{le as _,J as a,Q as b,Y as l};
