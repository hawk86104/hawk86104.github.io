import{_ as e,F as o}from"./@tresjs.BCHtwiaC1763540743861.js";import{L as t}from"./three-subdivide.BHifASQC1763540743861.js";import{d as a,a as n,a6 as i,w as r,H as s,o as l,J as u,ac as v,ao as c}from"./@vue.Co_gxueH1763540743861.js";import{b8 as m,ag as f,l as d,V as p}from"./three.rXKzP9fQ1763540743861.js";const g=["scale"],y=a({__name:"shineShader",props:{srcMesh:{},scale:{default:1.2},color:{default:"#ffff00"},subdivision:{type:Boolean,default:!0},c:{default:1.1},p:{default:1.4},side:{default:f},blending:{default:m}},setup(a){const m=a,f=n(),y={uniforms:{c:{type:"f",value:m.c},p:{type:"f",value:m.p},glowColor:{type:"c",value:new d(m.color)},viewVector:{type:"v3",value:{x:0,y:0,z:0}}},vertexShader:"\n          uniform vec3 viewVector;\n          uniform float c;\n          uniform float p;\n          varying float intensity;\n          void main() {\n            vec3 vNormal = normalize( normalMatrix * normal);\n            vec3 vNormel = normalize( normalMatrix * viewVector);\n            intensity = pow( c - dot(vNormal, vNormel), p );\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0);\n          }\n            ",fragmentShader:"\n          uniform vec3 glowColor;\n          varying float intensity;\n          void main() \n          {\n          \tvec3 glow = glowColor * intensity;\n\t\t\t\t\t\tif(intensity < 1.0){\n            \tgl_FragColor = vec4( glow, 1.0 );\n\t\t\t\t\t\t}\n          }\n        ",side:m.side,transparent:!0,depthWrite:!1,depthTest:!0,blending:m.blending};i(()=>{if(m.srcMesh&&f.value&&!f.value.geometry.attributes.position){let e=m.srcMesh.geometry.clone();m.subdivision&&(e=t.modify(e,2)),f.value.geometry=e,f.value.position.copy(m.srcMesh.position)}m.color&&(y.uniforms.glowColor.value=new d(m.color)),m.c&&(y.uniforms.c.value=m.c),m.p&&(y.uniforms.p.value=m.p)}),r(()=>m.subdivision,e=>{let o=m.srcMesh.geometry.clone();e&&(o=t.modify(o,2)),f.value.geometry=o}),r(()=>m.side,e=>{f.value.material.side=e}),r(()=>m.blending,e=>{f.value.material.blending=e});const{onRender:w}=e(),{camera:h}=o();return w(()=>{h.value&&f.value&&(y.uniforms.viewVector.value=(new p).subVectors(h.value.position,f.value.position))}),(e,o)=>(l(),s("TresMesh",{ref_key:"TSGref",ref:f,scale:m.scale},[u("TresShaderMaterial",v(c(y)),null,16)],8,g))}});export{y as _};
