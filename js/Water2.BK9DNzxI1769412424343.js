import{importShared as t}from"./3d-tiles-renderer.DFcJBJdg1769412424343.js";import{Reflector as e}from"./Reflector.diy2KwhZ1769412424343.js";const{Color:r,Matrix4:n,Mesh:o,PerspectiveCamera:a,Plane:i,Quaternion:l,ShaderMaterial:s,UniformsUtils:c,Vector3:m,Vector4:f,WebGLRenderTarget:u,HalfFloatType:v}=await t("three");class d extends o{constructor(t,e={}){super(t),this.isRefractor=!0,this.type="Refractor",this.camera=new a;const o=this,p=void 0!==e.color?new r(e.color):new r(8355711),x=e.textureWidth||512,h=e.textureHeight||512,g=e.clipBias||0,w=e.shader||d.RefractorShader,y=void 0!==e.multisample?e.multisample:4,M=this.camera;M.matrixAutoUpdate=!1,M.userData.refractor=!0;const b=new i,W=new n,R=new u(x,h,{samples:y,type:v});this.material=new s({name:void 0!==w.name?w.name:"unspecified",uniforms:c.clone(w.uniforms),vertexShader:w.vertexShader,fragmentShader:w.fragmentShader,transparent:!0}),this.material.uniforms.color.value=p,this.material.uniforms.tDiffuse.value=R.texture,this.material.uniforms.textureMatrix.value=W;const _=function(){const t=new m,e=new m,r=new n,a=new m,i=new m;return function(n){return t.setFromMatrixPosition(o.matrixWorld),e.setFromMatrixPosition(n.matrixWorld),a.subVectors(t,e),r.extractRotation(o.matrixWorld),i.set(0,0,1),i.applyMatrix4(r),a.dot(i)<0}}(),C=function(){const t=new m,e=new m,r=new l,n=new m;return function(){o.matrixWorld.decompose(e,r,n),t.set(0,0,1).applyQuaternion(r).normalize(),t.negate(),b.setFromNormalAndCoplanarPoint(t,e)}}(),S=function(){const t=new i,e=new f,r=new f;return function(n){M.matrixWorld.copy(n.matrixWorld),M.matrixWorldInverse.copy(M.matrixWorld).invert(),M.projectionMatrix.copy(n.projectionMatrix),M.far=n.far,t.copy(b),t.applyMatrix4(M.matrixWorldInverse),e.set(t.normal.x,t.normal.y,t.normal.z,t.constant);const o=M.projectionMatrix;r.x=(Math.sign(e.x)+o.elements[8])/o.elements[0],r.y=(Math.sign(e.y)+o.elements[9])/o.elements[5],r.z=-1,r.w=(1+o.elements[10])/o.elements[14],e.multiplyScalar(2/e.dot(r)),o.elements[2]=e.x,o.elements[6]=e.y,o.elements[10]=e.z+1-g,o.elements[14]=e.w}}();this.onBeforeRender=function(t,e,r){!0!==r.userData.refractor&&!0!=!_(r)&&(C(),function(t){W.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),W.multiply(t.projectionMatrix),W.multiply(t.matrixWorldInverse),W.multiply(o.matrixWorld)}(r),S(r),function(t,e,r){o.visible=!1;const n=t.getRenderTarget(),a=t.xr.enabled,i=t.shadowMap.autoUpdate;t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.setRenderTarget(R),!1===t.autoClear&&t.clear(),t.render(e,M),t.xr.enabled=a,t.shadowMap.autoUpdate=i,t.setRenderTarget(n);const l=r.viewport;void 0!==l&&t.state.viewport(l),o.visible=!0}(t,e,r))},this.getRenderTarget=function(){return R},this.dispose=function(){R.dispose(),o.material.dispose()}}}d.RefractorShader={name:"RefractorShader",uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}"};const{Clock:p,Color:x,Matrix4:h,Mesh:g,RepeatWrapping:w,ShaderMaterial:y,TextureLoader:M,UniformsLib:b,UniformsUtils:W,Vector2:R,Vector4:_}=await t("three");class C extends g{constructor(t,r={}){super(t),this.isWater=!0,this.type="Water";const n=this,o=void 0!==r.color?new x(r.color):new x(16777215),a=void 0!==r.textureWidth?r.textureWidth:512,i=void 0!==r.textureHeight?r.textureHeight:512,l=void 0!==r.clipBias?r.clipBias:0,s=void 0!==r.flowDirection?r.flowDirection:new R(1,0),c=void 0!==r.flowSpeed?r.flowSpeed:.03,m=void 0!==r.reflectivity?r.reflectivity:.02,f=void 0!==r.scale?r.scale:1,u=void 0!==r.shader?r.shader:C.WaterShader,v=new M,g=r.flowMap||void 0,_=r.normalMap0||v.load("textures/water/Water_1_M_Normal.jpg"),S=r.normalMap1||v.load("textures/water/Water_2_M_Normal.jpg"),D=.15,U=.075,P=new h,T=new p;if(void 0===e)return void console.error("THREE.Water: Required component Reflector not found.");if(void 0===d)return void console.error("THREE.Water: Required component Refractor not found.");const O=new e(t,{textureWidth:a,textureHeight:i,clipBias:l}),E=new d(t,{textureWidth:a,textureHeight:i,clipBias:l});O.matrixAutoUpdate=!1,E.matrixAutoUpdate=!1,this.material=new y({name:u.name,uniforms:W.merge([b.fog,u.uniforms]),vertexShader:u.vertexShader,fragmentShader:u.fragmentShader,transparent:!0,fog:!0}),void 0!==g?(this.material.defines.USE_FLOWMAP="",this.material.uniforms.tFlowMap={type:"t",value:g}):this.material.uniforms.flowDirection={type:"v2",value:s},_.wrapS=_.wrapT=w,S.wrapS=S.wrapT=w,this.material.uniforms.tReflectionMap.value=O.getRenderTarget().texture,this.material.uniforms.tRefractionMap.value=E.getRenderTarget().texture,this.material.uniforms.tNormalMap0.value=_,this.material.uniforms.tNormalMap1.value=S,this.material.uniforms.color.value=o,this.material.uniforms.reflectivity.value=m,this.material.uniforms.textureMatrix.value=P,this.material.uniforms.config.value.x=0,this.material.uniforms.config.value.y=U,this.material.uniforms.config.value.z=U,this.material.uniforms.config.value.w=f,this.onBeforeRender=function(t,e,r){!function(t){P.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),P.multiply(t.projectionMatrix),P.multiply(t.matrixWorldInverse),P.multiply(n.matrixWorld)}(r),function(){const t=T.getDelta(),e=n.material.uniforms.config;e.value.x+=c*t,e.value.y=e.value.x+U,e.value.x>=D?(e.value.x=0,e.value.y=U):e.value.y>=D&&(e.value.y=e.value.y-D)}(),n.visible=!1,O.matrixWorld.copy(n.matrixWorld),E.matrixWorld.copy(n.matrixWorld),O.onBeforeRender(t,e,r),E.onBeforeRender(t,e,r),n.visible=!0}}}C.WaterShader={name:"WaterShader",uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new _}},vertexShader:"\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}",fragmentShader:"\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}"};export{C as Water};
