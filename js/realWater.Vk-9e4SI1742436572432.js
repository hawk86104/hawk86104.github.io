import{m as n,e,a as t,o as r,f as o}from"./@tresjs.Uh9iM8du1742436572432.js";import{P as i}from"./tweakpane.yDiyAAkA1742436572432.js";import{_ as c,c as a,r as l,O as s,o as u,V as f,s as p}from"./three.RUAk_tvU1742436572432.js";import{d as v,a3 as g,b as d,o as x,f as h,u as m,g as y,j as w,al as b,r as I,N as R,aj as C,ak as _}from"./@vue.deO5D3Lf1742436572432.js";import"./postprocessing.5QD_59xS1742436572432.js";import"./@vueuse.F4UpVCIS1742436572432.js";var M="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const z=L;!function(n,e){const t=L,r=F();for(;;)try{if(440802===parseInt(t(178))/1*(parseInt(t(166))/2)+parseInt(t(150))/3*(-parseInt(t(187))/4)+-parseInt(t(173))/5*(-parseInt(t(147))/6)+parseInt(t(174))/7*(parseInt(t(193))/8)+-parseInt(t(154))/9*(parseInt(t(161))/10)+parseInt(t(153))/11+-parseInt(t(175))/12)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const D=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){D(this,(function(){const n=L,e=new RegExp(n(176)),t=new RegExp(n(167),"i"),r=O(n(185));e[n(183)](r+"chain")&&t.test(r+n(186))?O():r("0")}))()}();const A=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[L(151)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();A(void 0,(function(){const n=L,e=function(){const n=L;let e;try{e=Function(n(165)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e.console=e[n(182)]||{},r=[n(149),n(162),n(168),"error",n(157),n(189),n(156)];for(let o=0;o<r.length;o++){const e=A[n(181)][n(158)][n(188)](A),i=r[o],c=t[i]||e;e.__proto__=A[n(188)](A),e.toString=c.toString.bind(c),t[i]=e}}))();const T=v({__name:z(146),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=z,o=t,i=new(c[r(159)]),s=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),u=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(179)](r(163),new a(s,3)),i.setIndex(new(c[r(152)])(u,1));const f=new(c[r(177)])({uniforms:{light:{value:o[r(143)]},tiles:{value:o[r(148)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(190)]}),p=new l(i,f),{renderer:v,camera:g}=n(),{onAfterLoop:d}=e();return d((()=>{const n=r;((n,e)=>{const t=r;f[t(171)][t(191)][t(180)]=n,f[t(171)].causticTex[t(180)]=e,v[t(180)][t(164)](p,g.value)})(o[n(145)],o[n(172)])})),(n,e)=>null}});function L(n,e){const t=F();return(L=function(n,e){return t[n-=143]})(n,e)}function F(){const n=["bind","table","FrontSide","water","debu","1634936jyQjZy","light","while (true) {}","waterTexture","pool","12oSkYix","tiles","log","2372373TUltOF","apply","BufferAttribute","226259wqVBKe","36kZHEiN","string","trace","exception","prototype","BufferGeometry","length","998380FatqeW","warn","position","render","return (function() ","171870BNhJcI","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","info","gger","action","uniforms","causticsTexture","1967710ArUEuW","28MUnjEE","961332DBohCq","function *\\( *\\)","RawShaderMaterial","1eRteRP","setAttribute","value","constructor","console","test","stateObject","init","input","4YpnGWv"];return(F=function(){return n})()}function O(n){function e(n){const t=L;if(typeof n===t(155))return function(n){}.constructor(t(144))[t(151)]("counter");1!==(""+n/n)[t(160)]||n%20==0?function(){return!0}[t(181)]("debu"+t(169)).call(t(170)):function(){return!1}[t(181)](t(192)+t(169))[t(151)](t(184)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const E=P;function S(){const n=["render","stateObject","trace","1204380AJZewK","geometry","7nBiPti","resource.cos","side","exception","/images/skyBox/6jpg/","call","5RuwHta","1964DZWwDa","neg-z.jpg","clear","function *\\( *\\)","action","waterTexture","RawShaderMaterial","constructor","FrontSide","counter","underwater","chain","light","causticTex","init","328974xYYIgc","setClearColor","table","Color","debu","tiles","water","causticsTexture","4392954PKgynX","test","apply","setPath","CubeTextureLoader","BackSide","neg-y.jpg","https://opensource.cdn.icegl.cn","uniforms","toString","Mesh","47443SUDcbx","pos-x.jpg","length","3045112GeAfIH","bind","1710003iAbFtt","prototype","gger","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","pooRef","string",'{}.constructor("return this")( )',"warn","1370HRtQEn","1142IsxdGv","value","pos-y.jpg","while (true) {}"];return(S=function(){return n})()}!function(n,e){const t=P,r=S();for(;;)try{if(583041===parseInt(t(472))/1*(parseInt(t(520))/2)+-parseInt(t(511))/3+-parseInt(t(527))/4+parseInt(t(471))/5*(parseInt(t(487))/6)+-parseInt(t(529))/7*(-parseInt(t(509))/8)+parseInt(t(495))/9+-parseInt(t(519))/10*(parseInt(t(506))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){j(this,(function(){const n=P,e=new RegExp(n(475)),t=new RegExp(n(514),"i"),r=H(n(486));e[n(496)](r+n(483))&&t[n(496)](r+"input")?H():r("0")}))()}();const W=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[P(497)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function P(n,e){const t=S();return(P=function(n,e){return t[n-=467]})(n,e)}W(void 0,(function(){const n=P,e=function(){const n=P;let e;try{e=Function("return (function() "+n(517)+");")()}catch(t){e=window}return e}(),t=e.console=e.console||{},r=["log",n(518),"info","error",n(468),n(489),n(526)];for(let o=0;o<r[n(508)];o++){const e=W.constructor[n(512)][n(510)](W),i=r[o],c=t[i]||e;e.__proto__=W[n(510)](W),e[n(504)]=c[n(504)][n(510)](c),t[i]=e}}))();const V=v({__name:E(493),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=E;let i,a;const l=r,s=l[o(528)],u=(new(c[o(499)]))[o(498)](o(502)+o(469)).load([o(507),"neg-x.jpg",o(522),o(501),"pos-z.jpg",o(473)]),f=([i,a]=g((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,a(),i),p=new(c[o(478)])({uniforms:{light:{value:l[o(484)]},tiles:{value:f},sky:{value:u},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),v=new(c[o(505)])(s,p),y=d(null),w=new(c[o(490)])("white"),{renderer:b,camera:I}=n(),{onLoop:R}=e();return R((()=>{const n=o;b[n(521)].setRenderTarget(null),b.value[n(488)](w,1),b.value[n(474)](),p[n(503)][n(493)].value=l[n(477)],p[n(503)][n(485)][n(521)]=l[n(494)],p[n(467)]=c[n(480)],p[n(503)][n(482)].value=!0,b[n(521)][n(524)](v,I[n(521)]),p.side=c[n(500)],p[n(503)][n(482)][n(521)]=!1,b.value.render(v,I[n(521)])})),(n,e)=>{const t=o;return x(),h(T,{tiles:m(f),light:n.light,waterTexture:n.waterTexture,causticsTexture:n[t(494)],ref_key:t(515),ref:y},null,8,[t(492),"light","waterTexture",t(494)])}}});function H(n){function e(n){const t=P;if(typeof n===t(516))return function(n){}[t(479)](t(523))[t(497)](t(481));1!==(""+n/n)[t(508)]||n%20==0?function(){return!0}.constructor("debugger")[t(470)](t(476)):function(){return!1}.constructor(t(491)+t(513))[t(497)](t(525)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const k=N;!function(n,e){const t=N,r=G();for(;;)try{if(290271===-parseInt(t(168))/1+-parseInt(t(149))/2*(parseInt(t(141))/3)+parseInt(t(185))/4*(parseInt(t(147))/5)+parseInt(t(178))/6*(-parseInt(t(162))/7)+parseInt(t(148))/8+-parseInt(t(150))/9+parseInt(t(154))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[N(187)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){Z(this,(function(){const n=N,e=new RegExp("function *\\( *\\)"),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=Y(n(166));e[n(159)](r+n(170))&&t.test(r+"input")?Y():r("0")}))()}();const B=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[N(187)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function N(n,e){const t=G();return(N=function(n,e){return t[n-=141]})(n,e)}function G(){const n=["PlaneGeometry","info","while (true) {}","4252utKZmW","value","apply","light","98856zmvXGy","waterTexture","material","bind","length","uniforms","1950cYZzXq","1534896rAqCXM","12QDaWth","1450512gOrAIk","setClearColor","call","console","6151010nJhMZE","warn","constructor","setRenderTarget",'{}.constructor("return this")( )',"test","toString","counter","865165DcBtKf","error","caustics","gger","init","ShaderMaterial","448787XYtqrM","texture","chain","Color","prototype","WebGLRenderTarget","string","stateObject","causticsTexture","return (function() ","6XIRoLp","black","__proto__","table"];return(G=function(){return n})()}B(void 0,(function(){const n=N,e=function(){const n=N;let e;try{e=Function(n(177)+n(158)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(153)]||{},r=["log",n(155),n(183),n(163),"exception",n(181),"trace"];for(let o=0;o<r[n(145)];o++){const e=B.constructor[n(172)].bind(B),i=r[o],c=t[i]||e;e[n(180)]=B.bind(B),e[n(160)]=c[n(160)][n(144)](c),t[i]=e}}))();const q=v({__name:k(164),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=k,o=t,i=new s(0,1,1,0,0,2e3),a=new(c[r(182)])(2,2,200,200),u=new(c[r(173)])(1024,1024),f=new(c[r(167)])({uniforms:{light:{value:o[r(188)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),p=new l(a,f),v=new(c[r(171)])(r(179)),{renderer:g}=n(),{onBeforeLoop:d}=e();return d((()=>{const n=r;p[n(143)][n(146)].water.value=o[n(142)],g.value[n(157)](u),g[n(186)][n(151)](v,0),g[n(186)].clear(),g[n(186)].render(p,i)})),(n,e)=>{const t=r;return x(),h(b,null,{default:y((()=>[w(V,{waterTexture:n[t(142)],causticsTexture:m(u)[t(169)],light:n[t(188)],geometry:m(a)},null,8,["waterTexture",t(176),"light","geometry"])])),_:1})}}});function Y(n){function e(n){const t=N;if(typeof n===t(174))return function(n){}[t(156)](t(184))[t(187)](t(161));1!==(""+n/n)[t(145)]||n%20==0?function(){return!0}.constructor("debugger")[t(152)]("action"):function(){return!1}[t(156)]("debu"+t(165))[t(187)](t(175)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const $=J;!function(n,e){const t=J,r=K();for(;;)try{if(557841===parseInt(t(263))/1*(-parseInt(t(223))/2)+parseInt(t(225))/3+-parseInt(t(282))/4*(parseInt(t(260))/5)+parseInt(t(249))/6*(-parseInt(t(219))/7)+parseInt(t(212))/8+-parseInt(t(243))/9*(parseInt(t(244))/10)+parseInt(t(268))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const X=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[J(273)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function K(){const n=["light","while (true) {}","console","init",'{}.constructor("return this")( )',"setZ","147684KSolFV","point","464168VxizrV","width","bind","top","call","setRenderTarget","strength","700301uBQFNv","counter","attributes","length","12yRZULL","trace","1140933jaOOqF","Mesh","FloatType","clientX","waterSimulation","constructor","toString","setFromCamera","exception","action","return (function() ","getBoundingClientRect","log","debu","uniforms","OrthographicCamera","waterTexture","prototype","1836522tDxPRo","20ilJhDd","function *\\( *\\)","count","setY","domElement","18aqhupL","material","value","RawShaderMaterial","addEventListener","__proto__","mousemove","lightFrontGeometry","height","intersectObject","gger","80uQigtt","radius","input","165742BHfEwa","texture","PlaneGeometry","left","stateObject","26542362aHcvlL","autoClear","test","getY","WebGLRenderTarget","apply","position","removeEventListener"];return(K=function(){return n})()}!function(){X(this,(function(){const n=J,e=new RegExp(n(245)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=nn(n(279));e[n(270)](r+"chain")&&t[n(270)](r+n(262))?nn():r("0")}))()}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[J(273)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function J(n,e){const t=K();return(J=function(n,e){return t[n-=212]})(n,e)}U(void 0,(function(){const n=J,e=function(){const n=J;let e;try{e=Function(n(235)+n(280)+");")()}catch(t){e=window}return e}(),t=e[n(278)]=e[n(278)]||{},r=[n(237),"warn","info","error",n(233),"table",n(224)];for(let o=0;o<r[n(222)];o++){const e=U.constructor[n(242)].bind(U),i=r[o],c=t[i]||e;e[n(254)]=U.bind(U),e[n(231)]=c.toString[n(214)](c),t[i]=e}}))();const Q=v({__name:$(229),props:{light:{}},setup(t,{expose:r}){const o=$,i=new(c[o(240)])(0,1,1,0,0,2e3),a=new(c[o(265)])(2,2),l=new(c[o(272)])(256,256,{type:c[o(227)]}),s=new(c[o(272)])(256,256,{type:u}),v=new(c[o(252)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),g=new(c[o(252)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),d=new(c[o(252)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:M,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),y=new(c[o(226)])(a,v),w=new(c[o(226)])(a,g),b=new(c[o(226)])(a,d);let I=l;const R=(n,e)=>{const t=o,r=I,c=I===l?s:l;e[t(250)][t(239)].texture[t(251)]=r[t(264)],n[t(217)](c),n.render(e,i),I=c},{renderer:C,camera:_,raycaster:z}=n();C[o(251)][o(269)]=!1;const{onBeforeLoop:D}=e();D((()=>{const n=o;var e,t;t=C[n(251)],R(t,b),e=C[n(251)],R(e,w)}));const A=(n,e,t,r)=>{const i=o;y[i(250)].uniforms.center.value=[n,e],y.material.uniforms[i(261)][i(251)]=t,y[i(250)].uniforms[i(218)][i(251)]=r,R(C[i(251)],y)},T=new f,L=new p(2,2),F=L[o(221)][o(274)];for(let n=0;n<F[o(246)];n++){const e=-F[o(271)](n);F[o(247)](n,0),F[o(281)](n,e)}F.needsUpdate=!0;const O=new(c[o(226)])(L),E={handleEvent:n=>{const e=o,t=C.value[e(248)][e(236)](),r=t[e(213)],i=t[e(257)];T.x=2*(n[e(228)]-t[e(266)])/r-1,T.y=2*-(n.clientY-t[e(215)])/i+1,z.value[e(232)](T,_[e(251)]);const c=z[e(251)][e(258)](O);for(let o of c)A(o[e(283)].x,o[e(283)].z,.03,.04)}};return r({addDrop:A,mouseEvent:n=>{const e=o;n?C[e(251)][e(248)][e(253)](e(255),E):C[e(251)][e(248)][e(275)](e(255),E)}}),(n,e)=>{const t=o;return x(),h(q,{lightFrontGeometry:m(a),waterTexture:m(I)[t(264)],light:n[t(276)]},null,8,[t(256),t(241),t(276)])}}});function nn(n){function e(n){const t=J;if("string"==typeof n)return function(n){}.constructor(t(277))[t(273)](t(220));1!==(""+n/n)[t(222)]||n%20==0?function(){return!0}[t(230)](t(238)+t(259))[t(216)](t(234)):function(){return!1}[t(230)]("debu"+t(259))[t(273)](t(267)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=rn,r=on();for(;;)try{if(116405===-parseInt(t(333))/1+parseInt(t(335))/2*(-parseInt(t(331))/3)+-parseInt(t(350))/4+parseInt(t(352))/5+parseInt(t(309))/6*(-parseInt(t(327))/7)+parseInt(t(304))/8*(-parseInt(t(338))/9)+-parseInt(t(353))/10*(-parseInt(t(325))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[rn(347)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){en(this,(function(){const n=rn,e=new RegExp(n(337)),t=new RegExp(n(306),"i"),r=an("init");e[n(340)](r+n(330))&&t[n(340)](r+n(316))?an():r("0")}))()}();const tn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function rn(n,e){const t=on();return(rn=function(n,e){return t[n-=304]})(n,e)}function on(){const n=["14xVwqXc","click","function *\\( *\\)","340731uHStGC","点击按钮","test","while (true) {}","length","__proto__","constructor","随机增加波纹","value","apply","addBinding","toString","479828MAMwVy","return (function() ","494950GmIOKc","523610MlYKqV","8HNatUN","counter","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","warn","mouseEvent","3354hWmoya","random","addButton","exception","TresPerspectiveCamera","stateObject","bind","input","console","鼠标波纹","debu","manual","waterSimulationRef","action","addDrop","prototype","110vVVFDn",'{}.constructor("return this")( )',"2261buCBAX","log","table","chain","65640mWWkiJ","error","14662pqFuwP","gger"];return(on=function(){return n})()}tn(void 0,(function(){const n=rn,e=function(){const n=rn;let e;try{e=Function(n(351)+n(326)+");")()}catch(t){e=window}return e}(),t=e[n(317)]=e[n(317)]||{},r=[n(328),n(307),"info",n(332),n(312),n(329),"trace"];for(let o=0;o<r[n(342)];o++){const e=tn[n(344)][n(324)][n(315)](tn),i=r[o],c=t[i]||e;e[n(343)]=tn[n(315)](tn),e[n(349)]=c[n(349)][n(315)](c),t[i]=e}}))();const cn=v({__name:"realWater",setup(n){const e=rn,t=I({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(320)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=d(null),l=new i;l[e(311)]({label:e(339),title:e(345)}).on(e(336),(()=>{const n=e;for(var t=0;t<10;t++)a[n(346)][n(323)](2*Math[n(310)]()-1,2*Math[n(310)]()-1,.03,1&t?.02:-.02)}));const s=d(!1);return l[e(348)](s,e(346),{label:e(318)}).on("change",(n=>{const t=e;a[t(346)][t(308)](n[t(346)])})),(n,i)=>{const l=e;return x(),h(m(o),C(_(t)),{default:y((()=>[i[0]||(i[0]=R(l(313),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),w(m(r)),w(Q,{light:c,ref_key:l(321),ref:a},null,512)])),_:1},16)}}});function an(n){function e(n){const t=rn;if("string"==typeof n)return function(n){}[t(344)](t(341)).apply(t(305));1!==(""+n/n)[t(342)]||n%20==0?function(){return!0}[t(344)]("debu"+t(334)).call(t(322)):function(){return!1}[t(344)](t(319)+t(334))[t(347)](t(314)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{cn as default};
