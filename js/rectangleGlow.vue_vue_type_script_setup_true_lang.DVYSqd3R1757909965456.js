import{d as t,a2 as e,G as r,o,I as n,a7 as a,a8 as i}from"./@vue.pEDXJ_3Z1757909965456.js";import{C as l,a as d,a3 as s}from"./three.BsQcsDwn1757909965456.js";const f={renderOrder:9999},v=["rotation"],u=["args"],h=["rotation"],m=["args"],p=t({__name:"rectangleGlow",props:{w:{default:100},h:{default:100},pColor:{default:"#ffff00"},gradientWidth:{default:.99},glowWidth:{default:.99},nNumber:{default:8},lineWidth:{default:2},lColor:{default:"#ffff00"}},setup(t){const p=t,g={vertexShader:"\n \t\tvarying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    varying vec2 vUv;\n\t\tuniform vec3 color;\n\t\tuniform float gradientWidth;\n\t\tuniform float glowWidth;\n\t\tuniform float nNumber;\n\n    void main() {\n \t\t\tfloat distX = abs(vUv.x - 0.5) / 0.5;\n      float distY = abs(vUv.y - 0.5) / 0.5;\n\n      // 使用 Minkowski 距离，平滑矩形感 + 中心无交叉线 + 对角线也平滑\n      float dist = pow(pow(distX, nNumber) + pow(distY, nNumber), 1.0 / nNumber);\n\n      float cutoff = 1.0 - gradientWidth;\n  \t\tfloat alpha = smoothstep(cutoff, cutoff + glowWidth, dist);\n\n      gl_FragColor = vec4(color, alpha);\n    }\n  ",transparent:!0,side:s,depthWrite:!1,depthTest:!0,uniforms:{color:{type:"uvs",value:new l(p.pColor)},gradientWidth:{type:"f",value:p.gradientWidth},glowWidth:{type:"f",value:p.glowWidth},nNumber:{type:"f",value:p.nNumber}}},b={transparent:!0,side:s,depthWrite:!1,depthTest:!0,uniforms:{borderWidth:{value:p.lineWidth},borderColor:{value:new l(p.lColor)},size:{value:new d(p.w,p.h)}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    uniform float borderWidth;\n    uniform vec3 borderColor;\n    varying vec2 vUv;\n\t\tuniform vec2 size;\n\n    void main() {\n\t\t \tfloat borderX = borderWidth / size.x;\n  \t\tfloat borderY = borderWidth / size.y;\n\n      float left   = step(vUv.x, borderX);\n      float right  = step(1.0 - borderX, vUv.x);\n      float bottom = step(vUv.y, borderY);\n      float top    = step(1.0 - borderY, vUv.y);\n\n      float edge = max(max(left, right), max(bottom, top)); // 只保留边缘线\n      float alpha = edge;\n\n      gl_FragColor = vec4(borderColor, alpha);\n    }\n  "};return e((()=>{g.uniforms.color.value=new l(p.pColor),g.uniforms.gradientWidth.value=p.gradientWidth,g.uniforms.glowWidth.value=p.glowWidth,g.uniforms.nNumber.value=p.nNumber,b.uniforms.borderColor.value=new l(p.lColor),b.uniforms.borderWidth.value=p.lineWidth,b.uniforms.size.value.set(p.w,p.h)})),(t,e)=>(o(),r("TresGroup",f,[n("TresMesh",{rotation:[Math.PI/2,0,0]},[n("TresPlaneGeometry",{args:[t.w,t.h]},null,8,u),n("TresShaderMaterial",a(i(g)),null,16)],8,v),n("TresMesh",{rotation:[Math.PI/2,0,0]},[n("TresPlaneGeometry",{args:[t.w+t.lineWidth,t.h+t.lineWidth]},null,8,m),n("TresShaderMaterial",a(i(b)),null,16)],8,h)]))}});export{p as _};
