import{p as e,dI as n,V as t,a8 as o,aE as a,Q as r,d as i}from"./three.F31Lz30M1766394917683.js";import{F as s,_ as l}from"./@tresjs.CC-VM6g11766394917683.js";import{d as c,a as u,w as v,G as f,o as m,I as d,u as p}from"./@vue.BxPWGdWw1766394917683.js";const h=["object","rotation-x"],w=c({__name:"gerstnerWater",props:{distortionScale:{default:3.7},size:{default:1},wireframe:{default:!1},sunDirection:{default:{x:0,y:0,z:0}},sunColor:{default:"#ffffff"},waterColor:{default:"#001e0f"},waves:{type:Object,default:{A:{direction:0,steepness:.4,wavelength:60},B:{direction:30,steepness:.4,wavelength:30},C:{direction:60,steepness:.4,wavelength:15}}},meshUUIDList:{default:()=>[]}},setup(c){const w=c,{scene:g}=s(),x=new e(1024,1024,256,256),y=new n(x,{textureWidth:256,textureHeight:256,waterNormals:(new o).load("./plugins/water/images/waternormals.jpg",function(e){e.wrapS=e.wrapT=a}),sunDirection:(new t).fromArray([w.sunDirection.x,w.sunDirection.y,w.sunDirection.z]),sunColor:w.sunColor,waterColor:w.waterColor,distortionScale:w.distortionScale,fog:void 0!==g.value.fog}),M=u(null);Object.defineProperty(g.value,"environment",{get:()=>M.value,set(e){M.value=e}}),v(M,e=>{console.log("环境贴图变化 :",e),g.value.background=g.value.environment}),y.material.onBeforeCompile=function(e){e.uniforms.waveA={value:[Math.sin(w.waves.A.direction*Math.PI/180),Math.cos(w.waves.A.direction*Math.PI/180),w.waves.A.steepness,w.waves.A.wavelength]},e.uniforms.waveB={value:[Math.sin(w.waves.B.direction*Math.PI/180),Math.cos(w.waves.B.direction*Math.PI/180),w.waves.B.steepness,w.waves.B.wavelength]},e.uniforms.waveC={value:[Math.sin(w.waves.C.direction*Math.PI/180),Math.cos(w.waves.C.direction*Math.PI/180),w.waves.C.steepness,w.waves.C.wavelength]},e.vertexShader="uniform mat4 textureMatrix;\n            uniform float time;\n\n            varying vec4 mirrorCoord;\n            varying vec4 worldPosition;\n\n            #include <common>\n            #include <fog_pars_vertex>\n            #include <shadowmap_pars_vertex>\n            #include <logdepthbuf_pars_vertex>\n\n            uniform vec4 waveA;\n            uniform vec4 waveB;\n            uniform vec4 waveC;\n\n            vec3 GerstnerWave (vec4 wave, vec3 p) {\n            \tfloat steepness = wave.z;\n            \tfloat wavelength = wave.w;\n            \tfloat k = 2.0 * PI / wavelength;\n            \tfloat c = sqrt(9.8 / k);\n            \tvec2 d = normalize(wave.xy);\n            \tfloat f = k * (dot(d, p.xy) - c * time);\n            \tfloat a = steepness / k;\n\n            \treturn vec3(\n            \t\td.x * (a * cos(f)),\n            \t\td.y * (a * cos(f)),\n            \t\ta * sin(f)\n            \t);\n            }\n\n            void main() {\n            \tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n            \tworldPosition = mirrorCoord.xyzw;\n            \tmirrorCoord = textureMatrix * mirrorCoord;\n\n            \tvec3 p = position.xyz;\n            \tp += GerstnerWave(waveA, position.xyz);\n            \tp += GerstnerWave(waveB, position.xyz);\n            \tp += GerstnerWave(waveC, position.xyz);\n            \tgl_Position = projectionMatrix * modelViewMatrix * vec4( p.x, p.y, p.z, 1.0);\n\n            \t#include <beginnormal_vertex>\n            \t#include <defaultnormal_vertex>\n            \t#include <logdepthbuf_vertex>\n            \t#include <fog_vertex>\n            \t#include <shadowmap_vertex>\n            }",e.fragmentShader="uniform sampler2D mirrorSampler;\n            uniform float alpha;\n            uniform float time;\n            uniform float size;\n            uniform float distortionScale;\n            uniform sampler2D normalSampler;\n            uniform vec3 sunColor;\n            uniform vec3 sunDirection;\n            uniform vec3 eye;\n            uniform vec3 waterColor;\n\n            varying vec4 mirrorCoord;\n            varying vec4 worldPosition;\n\n            vec4 getNoise( vec2 uv ) {\n                vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n                vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n                vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n                vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n                vec4 noise = texture2D( normalSampler, uv0 ) +\n                    texture2D( normalSampler, uv1 ) +\n                    texture2D( normalSampler, uv2 ) +\n                    texture2D( normalSampler, uv3 );\n                return noise * 0.5 - 1.0;\n            }\n\n            void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n                vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n                float direction = max( 0.0, dot( eyeDirection, reflection ) );\n                specularColor += pow( direction, shiny ) * sunColor * spec;\n                diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n            }\n\n            #include <common>\n            #include <packing>\n            #include <bsdfs>\n            #include <fog_pars_fragment>\n            #include <logdepthbuf_pars_fragment>\n            #include <lights_pars_begin>\n            #include <shadowmap_pars_fragment>\n            #include <shadowmask_pars_fragment>\n\n            void main() {\n\n                #include <logdepthbuf_fragment>\n                vec4 noise = getNoise( worldPosition.xz * size );\n                vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n                vec3 diffuseLight = vec3(0.0);\n                vec3 specularLight = vec3(0.0);\n\n                vec3 worldToEye = eye-worldPosition.xyz;\n                vec3 eyeDirection = normalize( worldToEye );\n                sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n                float distance = length(worldToEye);\n\n                vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n                vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n                float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n                float rf0 = 0.3;\n                float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n                vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n                vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n                vec3 outgoingLight = albedo;\n                gl_FragColor = vec4( outgoingLight, alpha );\n\n                #include <tonemapping_fragment>\n                #include <fog_fragment>\n            }"},v(()=>[w.size,w.waterColor],([e,n])=>{y.material.uniforms.size.value=e,y.material.uniforms.waterColor.value.set(n)},{immediate:!0}),v(()=>w.wireframe,e=>{y.material.wireframe=e},{immediate:!0}),v(()=>w.waves,e=>{y.material.uniforms.waveA.value=[Math.sin(e.A.direction*Math.PI/180),Math.cos(e.A.direction*Math.PI/180),e.A.steepness,e.A.wavelength],y.material.uniforms.waveB.value=[Math.sin(e.B.direction*Math.PI/180),Math.cos(e.B.direction*Math.PI/180),e.B.steepness,e.B.wavelength],y.material.uniforms.waveC.value=[Math.sin(e.C.direction*Math.PI/180),Math.cos(e.C.direction*Math.PI/180),e.C.steepness,e.C.wavelength]},{deep:!0});const C=[];window.globalTvtFun=window.globalTvtFun||{},window.globalTvtFun.gerstnerWater_updateMeshList=(e=!1)=>{!e&&C.length>0&&w.meshUUIDList.forEach(e=>{const n=g.value.getObjectByProperty("uuid",e.uuid);if(n){const t=C.find(n=>n.mesh.uuid===e.uuid);t&&(n.position.copy(t.defaultPosition),n.quaternion.copy(t.defaultQuaternion))}}),C.length=0,w.meshUUIDList.forEach(e=>{const n=g.value.getObjectByProperty("uuid",e.uuid);if(n){let t=1,o=1;null!=e.floatScale&&""!==e.floatScale&&(t=e.floatScale),null!=e.yOffsetScale&&""!==e.yOffsetScale&&(o=e.yOffsetScale),C.push({mesh:n,floatScale:t,yOffsetScale:o,defaultPosition:n.position.clone(),defaultQuaternion:n.quaternion.clone()})}})},v(()=>w.meshUUIDList,()=>{window.globalTvtFun.gerstnerWater_updateMeshList()},{immediate:!0,deep:!0});const _=new t(0,1,0),{onBeforeRender:S}=l();return S(()=>{y.material.uniforms.time.value+=.01,C.forEach(e=>{const n=e.mesh,o=e.floatScale,a=function(e,n,o){const a=new t,r=new t(1,0,0),s=new t(0,0,1);Object.keys(w.waves).forEach(t=>{const l=w.waves[t],c=2*Math.PI/l.wavelength,u=Math.sqrt(9.8/c),v=new i(Math.sin(l.direction*Math.PI/180),-Math.cos(l.direction*Math.PI/180)),f=c*(v.dot(new i(e,n))-u*o),m=l.steepness/c;a.x+=v.y*(m*Math.cos(f)),a.y+=m*Math.sin(f),a.z+=v.x*(m*Math.cos(f)),r.x+=-v.x*v.x*(l.steepness*Math.sin(f)),r.y+=v.x*(l.steepness*Math.cos(f)),r.z+=-v.x*v.y*(l.steepness*Math.sin(f)),s.x+=-v.x*v.y*(l.steepness*Math.sin(f)),s.y+=v.y*(l.steepness*Math.cos(f)),s.z+=-v.y*v.y*(l.steepness*Math.sin(f))});const l=s.cross(r).normalize();return{position:a,normal:l}}(n.position.x,n.position.z,y.material.uniforms.time.value);n.position.y=a.position.y*e.yOffsetScale;const s=a.normal.clone().normalize(),l=(new r).setFromUnitVectors(_,s);if(1!==o){const e=n.quaternion.clone();l.slerp(e,1-o)}n.quaternion.slerp(l,.01*e.floatScale)})}),(e,n)=>(m(),f("TresGroup",null,[d("primitive",{object:p(y),"rotation-x":-Math.PI/2},null,8,h)]))}});export{w as _};
