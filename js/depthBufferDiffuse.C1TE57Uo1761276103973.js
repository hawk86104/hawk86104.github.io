import"./@fesjs.DnM7nINA1761276103973.js";import"./Resource.CSaxGSPI1761276103973.js";/* empty css                                                                             */import{_ as e}from"./default.vue_vue_type_script_setup_true_lang.Yv2Tq32Z1761276103973.js";import"./three-mesh-ui.module.C--P1h9b1761276103973.js";import"./global.BkM2LKCv1761276103973.js";/* empty css                                                              */import"./vanilla.esm.5.5.0.CRlEbOMK1761276103973.js";import{F as o,_ as r}from"./@tresjs.B_KjVy0E1761276103973.js";import{u as a}from"./index.DzBQ5WCR1761276103973.js";import{d as i,ad as n,w as t,G as s,o as l,I as u,a9 as m,aa as d,r as p,t as v,h as f,u as h,e as c,m as g,F as j}from"./@vue.CKlgtJke1761276103973.js";import{k as _,d as C,a6 as y,bd as x}from"./three.Bhn4-0ry1761276103973.js";import"./SPE.D1gwy86C1761276103973.js";import"./Fetch.CIMEiaKn1761276103973.js";import"./three-custom-shader-material.DSmV-ApW1761276103973.js";import{P as b}from"./tweakpane.CqZAnw7f1761276103973.js";import{b as w}from"./pagesShow.vue_vue_type_script_setup_true_lang.CD6zj33S1761276103973.js";import"./vue-router.BFHj2xRz1761276103973.js";import"./lodash-es.DWe8oqPO1761276103973.js";import"./pinia.C8YT0eOZ1761276103973.js";import"./@qlin.y-0Z8WnK1761276103973.js";import"./@babel.BPq7uOAK1761276103973.js";import"./@floating-ui.Bhq4ibgf1761276103973.js";import"./@juggle.Vc7cP4_P1761276103973.js";import"./color.zjyo9y-T1761276103973.js";import"./color-string.Cb0Nf94v1761276103973.js";import"./color-name.gyPnsvCn1761276103973.js";import"./lodash.B8Sqzhuz1761276103973.js";import"./@amap.fjyZdsU91761276103973.js";import"./object-hash.1qNYTrnD1761276103973.js";import"./jszip.y_yjJ09m1761276103973.js";import"./postprocessing.CeTFUAN_1761276103973.js";import"./@vueuse.wtfleElW1761276103973.js";import"./buildingsCustomShaderMaterial.DyBo--wu1761276103973.js";const D={renderOrder:2200},z=["args"],F=i({__name:"depthBufferDiffuse",props:{radius:{default:100},shieldColor:{default:"#ffff00"},rimColor:{default:"#ffffff"},threshold:{default:.005}},setup(e){const i=e,{sizes:p,camera:v}=o(),f=p.aspectRatio.value,h=p.width.value,c=p.height.value,g=a({height:h*f,width:c*f,depth:!0,isLoop:!0}),j={blending:x,transparent:!0,depthWrite:!1,depthTest:!0,side:y,vertexShader:"\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n        void main() {\n            vUv = uv;\n            vec4 worldPos = modelMatrix * vec4(position, 1.0);\n            vec4 modelNormal = modelMatrix * vec4(normal, 0.0);\n            vec4 mvPosition = viewMatrix * worldPos;\n            gl_Position = projectionMatrix * mvPosition;\n            vNormal = modelNormal.xyz;\n            vPosition = worldPos.xyz;\n        }\n    ",fragmentShader:"\n        uniform sampler2D uDepthTexture; \n        uniform vec2 uResolution;\n        uniform float uNear;\n        uniform float uFar;\n        uniform float uThreshold;\n        uniform vec3 uShieldColor;\n        uniform vec3 uRimColor;\n\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n\n        #include <packing>\n\n        float LinearizeDepth(float depth) {\n            float zNdc = 2.0 * depth - 1.0;\n            float zEye = (2.0 * uFar * uNear) / ((uFar + uNear) - zNdc * (uFar - uNear));\n            float linearDepth = (zEye - uNear) / (uFar - uNear);\n            return linearDepth;\n        }\n\n        void main() {\n            vec3 normal = normalize(vNormal);\n            if(gl_FrontFacing) {\n                normal *= -1.0;\n            }\n\n            vec3 viewDirection = normalize(cameraPosition - vPosition);\n            float fresnel = 1. + dot(normal, viewDirection);\n            fresnel = pow(fresnel, 4.0);\n\n            vec2 worldCoords = gl_FragCoord.xy/uResolution;\n\n            float sceneDepth = LinearizeDepth(texture2D(uDepthTexture, worldCoords).r);\n            float bubbleDepth = LinearizeDepth(gl_FragCoord.z);\n\n            float difference = abs(sceneDepth - bubbleDepth);\n            float normalizedDistance = clamp(difference / uThreshold, 0.0, 1.0);\n            vec4 intersection = mix(vec4(1.0), vec4(0.0), normalizedDistance);\n            intersection.rgb *= uRimColor;\n\n            vec4 color = vec4(uShieldColor, 0.3);\n            gl_FragColor = color + intersection + vec4(uRimColor, 1.0) * fresnel;\n        }\n    ",uniforms:{uDepthTexture:{value:n(g?.value?.depthTexture)},uResolution:{value:new C(h,c)},uNear:{value:v.value?.near??1},uFar:{value:v.value?.far??1e4},uThreshold:{value:i.threshold},uShieldColor:{value:new _(i.shieldColor)},uRimColor:{value:new _(i.rimColor)}}},{onRender:b}=r();return b(()=>{}),t(()=>[i.rimColor,i.shieldColor,i.threshold],([e,o,r])=>{j.uniforms.uRimColor.value.setStyle(e),j.uniforms.uShieldColor.value.setStyle(o),j.uniforms.uThreshold.value=r}),(e,o)=>(l(),s("TresMesh",D,[u("TresSphereGeometry",{args:[i.radius,64,64]},null,8,z),u("TresShaderMaterial",m(d(j)),null,16)]))}}),N=i({__name:"depthBufferDiffuse",setup(o){const r=p({shieldColor:"#ffff00",rimColor:"#ffffff",threshold:2e-4,radius:100}),a=new b;a.addBinding(r,"shieldColor",{label:"圈颜色"}),a.addBinding(r,"rimColor",{label:"条颜色"}),a.addBinding(r,"threshold",{label:"线条参数",min:1e-5,max:.002,step:1e-5}),a.addBinding(r,"radius",{label:"大小",min:10,max:200,step:1});const i=v(null);return t(()=>i.value?.contextReady,e=>{e&&i.value.context.context.camera.activeCamera.value.position.set(-135,250,320)}),(o,a)=>(l(),s(j,null,[f(h(e)),f(w,{ref_key:"pagesShowRef",ref:i},{ability:c(()=>[f(h(F),g({position:[0,30,0]},r),null,16)]),_:1},512)],64))}});export{N as default};
