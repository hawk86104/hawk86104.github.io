import{importShared as e}from"./3d-tiles-renderer.6uaxtGOi1769565599278.js";import{useTextures as t,useLoop as i,useTres as r,useTexture as a,component_default$18 as n}from"./index.CG-C7MIu1769565599278.js";import{useFBO as s,useTexture as o}from"./customShaderMaterial.vue_vue_type_script_setup_true_lang.deADwUYZ1769565599278.js";import"./index.vue_vue_type_script_setup_true_lang.Ce0FTFfR1769565599278.js";import{SPE as l}from"./SPE.CEqzAso81769565599278.js";import{getcenterPoint as c,loadGeojson as u}from"./utils.DGRMVp2O1769565599278.js";import{lonLatToUtm as h}from"./TerrainMeshProvider.CTSj0Q9_1769565599278.js";import{useGLTF as d}from"./index.DydYGDKP1769565599278.js";const p=await e("three"),m=({startFrame:e,endFrame:t,fps:i,frameName:r,textureDataURL:a,textureImageURL:n,loop:s,numberOfFrames:o,autoPlay:l,animationNames:c,onStart:u,onEnd:h,onLoopEnd:d,onFrame:m,play:f,pause:g,flipX:S,alphaTest:y,asSprite:w})=>{let v={frames:[],meta:{version:"1.0",size:{w:1,h:1},scale:"1"}},x=new p.Texture;const P=new p.SpriteMaterial({toneMapped:!1,transparent:!0,map:x,alphaTest:y}),T=new p.MeshBasicMaterial({toneMapped:!1,side:p.DoubleSide,map:x,transparent:!0,alphaTest:y}),C=new p.Sprite(P),b=new p.Mesh(new p.PlaneGeometry(1,1),T);let A=P,I=C;const V=new p.Group;V.add(I);let z=window.performance.now(),E=0,F=r||"";const O=1e3/i,N=new p.Vector3(1,1,1),R=e=>{N.copy(e)},M=S?-1:1;let U=w;U=U,U?(A=P,I=C,V.add(C),V.remove(b)):(A=T,I=b,V.remove(C),V.add(b));const B=(e,t)=>{const i=t/e;return I.scale.set(1,i,1),I.scale},q=(e,t)=>{if(null===e){if(t&&o){const e=t.image.width,i=t.image.height,r=e/o,a=i;if(v={frames:[],meta:{version:"1.0",size:{w:e,h:i},scale:"1"}},parseInt(r.toString(),10)===r)for(let t=0;t<o;t++)v.frames.push({frame:{x:t*r,y:0,w:r,h:a},rotated:!1,trimmed:!1,spriteSourceSize:{x:0,y:0,w:r,h:a},sourceSize:{w:r,h:i}})}}else if(t){v=e,v.frames=Array.isArray(e.frames)?e.frames:D();const{w:i,h:r}=W(e.frames).sourceSize,a=B(i,r);R(a),A&&(A.map=t)}var i;t.premultiplyAlpha=!1,x=i=t,A&&(A.map=i),_()},D=()=>{const e={},t=v,i=c;if(i)for(let r=0;r<i.length;r++){e[i[r]]=[];for(const a in t.frames){const n=t.frames[a],s=n.frame,o=s.x,l=s.y,c=s.w,u=s.h,h=n.sourceSize.w,d=n.sourceSize.h;"string"==typeof a&&-1!==a.toLowerCase().indexOf(i[r].toLowerCase())&&e[i[r]].push({x:o,y:l,w:c,h:u,frame:s,sourceSize:{w:h,h:d}})}}return e},_=()=>{if(!v||!A.map)return;const{meta:{size:e},frames:t}=v,{w:i,h:a}=Array.isArray(t)?t[0].sourceSize:r&&t[r]?t[r][0].sourceSize:{w:0,h:0};A.map.wrapS=A.map.wrapT=p.RepeatWrapping,A.map.center.set(0,0),A.map.repeat.set(1*M/(e.w/i),1/(e.h/a));const n=1/((e.h-1)/a);A.map.offset.x=0,A.map.offset.y=1-n,u&&u({currentFrameName:r,currentFrame:E})},W=e=>{if(Array.isArray(e))return e[0];if("object"==typeof e&&null!==e){return e[Object.keys(e)[0]][0]}return{w:0,h:0}};return{group:V,init:async()=>{await async function(e,t,i){const r=new p.TextureLoader,a=fetch(e).then(e=>e.json()),n=new Promise(e=>{r.load(t,e)});await Promise.all([a,n]).then(e=>{i(e[0],e[1])})}(a,n,q)},update:()=>{var i,a;null!=(i=v)&&i.frames&&null!=(a=A)&&a.map&&(g||((()=>{if(!v||!A.map)return;const i=window.performance.now(),a=i-z,{meta:{size:n},frames:s}=v,{w:o,h:l}=W(s).sourceSize,c=Array.isArray(s)?s:r?s[r]:[];let u=0,h=0;const p=t||c.length-1;if(E>p&&(E=e,null==d||d({currentFrameName:r,currentFrame:E})),a<=O)return;z=i-a%O,B(o,l);const m=(n.w-1)/o,f=(n.h-1)/l,{frame:{x:g,y:S},sourceSize:{w:y,h:w}}=c[E],x=1/m,P=1/f;u=M>0?x*(g/y):x*(g/y)-A.map.repeat.x,h=Math.abs(1-P)-P*(S/w),A.map.offset.x=u,A.map.offset.y=h,E+=1})(),m&&m({currentFrameName:F,currentFrame:E})))},playAnimation:()=>{g=!1},pauseAnimation:()=>{g=!0},setFrameName:e=>{F!==(r=e)&&r&&(E=0,F=r)}}},{defineComponent:f}=await e("vue"),{createElementVNode:g,unref:S,openBlock:y,createElementBlock:w}=await e("vue"),v=["scale"],x={renderOrder:2200},P=["args"],T=["side","map","color","opacity"],C=["position"],b=["args"],A=["side","map","color","opacity"],I=await e("three"),{ref:V,watch:z}=await e("vue"),E=f({__name:"diffuseCircle",props:{radius:{default:100},ballColor:{default:"#ffff00"},wallColor:{default:"#ffffff"},speed:{default:1}},setup(e){const r=e,{textures:a,isLoading:n}=t(["./plugins/digitalCity/image/diffuseCircle1.png","./plugins/digitalCity/image/diffuseCircle2.png"]);z([a,n],([e,t])=>{e&&!t&&e[1].offset.set(.5,.5)});const s=V(0),o=V(1),{onBeforeRender:l}=i();return l(({delta:e})=>{s.value>1&&(s.value=0),s.value+=e*r.speed,o.value=1.4-s.value}),(e,t)=>(y(),w("TresGroup",{scale:s.value},[g("TresMesh",x,[g("TresSphereGeometry",{args:[r.radius,64,64,0,2*Math.PI,0,Math.PI/2]},null,8,P),g("TresMeshBasicMaterial",{side:I.DoubleSide,transparent:"",map:S(a)[0],color:e.ballColor,opacity:o.value},null,8,T)]),g("TresMesh",{renderOrder:2201,position:[0,.3*r.radius,0]},[g("TresCylinderGeometry",{args:[1.02*r.radius,1.02*r.radius,.6*r.radius,32,1,!0],openEnded:!0},null,8,b),g("TresMeshBasicMaterial",{side:I.DoubleSide,transparent:"",map:S(a)[1],color:e.wallColor,opacity:o.value},null,8,A)],8,C)],8,v))}}),{defineComponent:F}=await e("vue"),{createElementVNode:O,normalizeProps:N,guardReactiveProps:R,openBlock:M,createElementBlock:U}=await e("vue"),B={renderOrder:2200},q=["args"],{toRaw:D,watch:_}=await e("vue"),W=await e("three"),X=F({__name:"depthBufferDiffuse",props:{radius:{default:100},shieldColor:{default:"#ffff00"},rimColor:{default:"#ffffff"},threshold:{default:.005}},setup(e){const t=e,{sizes:a,camera:n}=r(),o=a.aspectRatio.value,l=a.width.value,c=a.height.value,u=s({height:l*o,width:c*o,depth:!0,isLoop:!0}),h={blending:W.NormalBlending,transparent:!0,depthWrite:!1,depthTest:!0,side:W.DoubleSide,vertexShader:"\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n        void main() {\n            vUv = uv;\n            vec4 worldPos = modelMatrix * vec4(position, 1.0);\n            vec4 modelNormal = modelMatrix * vec4(normal, 0.0);\n            vec4 mvPosition = viewMatrix * worldPos;\n            gl_Position = projectionMatrix * mvPosition;\n            vNormal = modelNormal.xyz;\n            vPosition = worldPos.xyz;\n        }\n    ",fragmentShader:"\n        uniform sampler2D uDepthTexture; \n        uniform vec2 uResolution;\n        uniform float uNear;\n        uniform float uFar;\n        uniform float uThreshold;\n        uniform vec3 uShieldColor;\n        uniform vec3 uRimColor;\n\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n\n        #include <packing>\n\n        float LinearizeDepth(float depth) {\n            float zNdc = 2.0 * depth - 1.0;\n            float zEye = (2.0 * uFar * uNear) / ((uFar + uNear) - zNdc * (uFar - uNear));\n            float linearDepth = (zEye - uNear) / (uFar - uNear);\n            return linearDepth;\n        }\n\n        void main() {\n            vec3 normal = normalize(vNormal);\n            if(gl_FrontFacing) {\n                normal *= -1.0;\n            }\n\n            vec3 viewDirection = normalize(cameraPosition - vPosition);\n            float fresnel = 1. + dot(normal, viewDirection);\n            fresnel = pow(fresnel, 4.0);\n\n            vec2 worldCoords = gl_FragCoord.xy/uResolution;\n\n            float sceneDepth = LinearizeDepth(texture2D(uDepthTexture, worldCoords).r);\n            float bubbleDepth = LinearizeDepth(gl_FragCoord.z);\n\n            float difference = abs(sceneDepth - bubbleDepth);\n            float normalizedDistance = clamp(difference / uThreshold, 0.0, 1.0);\n            vec4 intersection = mix(vec4(1.0), vec4(0.0), normalizedDistance);\n            intersection.rgb *= uRimColor;\n\n            vec4 color = vec4(uShieldColor, 0.3);\n            gl_FragColor = color + intersection + vec4(uRimColor, 1.0) * fresnel;\n        }\n    ",uniforms:{uDepthTexture:{value:D(u?.value?.depthTexture)},uResolution:{value:new W.Vector2(l,c)},uNear:{value:n.value?.near??1},uFar:{value:n.value?.far??1e4},uThreshold:{value:t.threshold},uShieldColor:{value:new W.Color(t.shieldColor)},uRimColor:{value:new W.Color(t.rimColor)}}},{onRender:d}=i();return d(()=>{}),_(()=>[t.rimColor,t.shieldColor,t.threshold],([e,t,i])=>{h.uniforms.uRimColor.value.setStyle(e),h.uniforms.uShieldColor.value.setStyle(t),h.uniforms.uThreshold.value=i}),(e,i)=>(M(),U("TresMesh",B,[O("TresSphereGeometry",{args:[t.radius,64,64]},null,8,q),O("TresShaderMaterial",N(R(h)),null,16)]))}}),{withAsyncContext:j,defineComponent:k}=await e("vue"),{unref:J,openBlock:L,createBlock:G}=await e("vue"),{watch:Y}=await e("vue");await e("three");const{defineComponent:Z}=await e("vue"),{openBlock:H,createElementBlock:$,createCommentVNode:K}=await e("vue"),{watch:Q,watchEffect:ee,toRaw:te,ref:ie}=await e("vue");await e("three");const{defineComponent:re}=await e("vue"),{openBlock:ae,createElementBlock:ne,createCommentVNode:se}=await e("vue"),oe=["object"],{watch:le,ref:ce,toRaw:ue,useAttrs:he}=await e("vue"),de=await e("three"),pe=re({__name:"fireB",props:{color:{default:"#ff0000"},particleCount:{default:150}},setup(e){const t=e;const{state:r}=a("./plugins/digitalCity/image/smokeparticle.png");let n=null;const s=ce(null),o=()=>{const e=function(e,t=[0,0,0]){if("number"==typeof e)return[e,e,e];if(Array.isArray(e)){const[t=0,i=0,r=0]=e;return[t,i,r]}if(e&&"object"==typeof e){const{x:t=0,y:i=0,z:r=0}=e;return[t,i,r]}return t}(c?.scale,[1,1,1]),i=e[0],r=e[1],a=e[2],s=new l.Emitter({type:l.distributions.SPHERE,particleCount:t.particleCount,maxAge:{value:3},position:{value:new de.Vector3(0,0,0),spread:new de.Vector3(1,1,1),radius:1},velocity:{value:new de.Vector3(0,20,0),spread:new de.Vector3(12,40,12),distribution:l.distributions.BOX},size:{value:[200*i,100*r,10*a]},color:{value:new de.Color(t.color),spread:new de.Vector3(.05,.05,.01)}});n.addEmitter(s)};le(()=>r.value,e=>{e&&(n=new l.Group({blending:de.AdditiveBlending,depthTest:!0,depthWrite:!1,maxParticleCount:1500,texture:{value:e}}),o(),s.value=n.mesh)}),le(()=>[t.color,t.particleCount],()=>{n.emitters[0]&&(n.emitters[0].remove(),o())});const c=he();le(()=>c.scale,e=>{n?.emitters[0]&&(n.emitters[0].remove(),o())},{deep:!0});const{onBeforeRender:u}=i();return u(()=>{n&&n.tick()}),(e,t)=>(ae(),ne("TresGroup",null,[s.value?(ae(),ne("primitive",{key:0,object:ue(s.value),renderOrder:3001},null,8,oe)):se("",!0)]))}}),{withAsyncContext:me,defineComponent:fe}=await e("vue"),{unref:ge,openBlock:Se,createElementBlock:ye}=await e("vue"),we=["object"],ve=await e("three"),{watch:xe}=await e("vue"),Pe=fe({__name:"fireC",props:{color:{default:"#f5d26b"}},async setup(e){let t,r;const a=e,n=m({startFrame:0,fps:40,autoPlay:!0,loop:!0,textureImageURL:"./plugins/digitalCity/image/spriteAnimator/flame.png",textureDataURL:"./plugins/digitalCity/image/spriteAnimator/flame.json",alphaTest:.101,asSprite:!0});[t,r]=me(()=>n.init()),await t,r(),n.group.children[0].material.map.colorSpace=ve.SRGBColorSpace,n.group.children[0].material.blending=ve.NormalBlending,n.group.children[0].material.color.set(a.color),n.group.children[0].geometry.translate(0,.344,0);const{onBeforeRender:s}=i();return s(()=>{n.update()}),xe(()=>[a.color],()=>{n.group&&n.group.children[0].material.color.set(a.color)}),(e,t)=>(Se(),ye("primitive",{object:ge(n).group,renderOrder:9999},null,8,we))}}),Te=await e("three");class Ce{static Time=new Ce("Time");static Sequence=new Ce("Sequence");constructor(e){this.name=e}}class be{constructor(){this.init()}init(){this.progressType=Ce.Time,this.lifetime=1,this.age=0,this.sequenceElement=new Te.Vector4,this.position=new Te.Vector3,this.velocity=new Te.Vector3,this.acceleration=new Te.Vector3,this.normal=new Te.Vector3,this.rotation=0,this.rotationalSpeed=0,this.size=new Te.Vector2,this.color=new Te.Color,this.alpha=1,this.initialSize=new Te.Vector2,this.initialColor=new Te.Color,this.initialAlpha=1}setAll(e,t,i,r,a,n,s,o,l,c,u,h,d,p,m,f){this.progressType=e,this.lifetime=t,this.age=i,this.sequenceElement.copy(r),this.position.copy(a),this.velocity.copy(n),this.acceleration.copy(s),this.normal.copy(o),this.rotation=l,this.rotationalSpeed=c,this.size=u,this.color.copy(h),this.alpha=d,this.initialSize.copy(p),this.initialColor.copy(m),this.initialAlpha=f}copyTo(e){e.setAll(this.progressType,this.lifetime,this.age,this.sequenceElement,this.position,this.velocity,this.acceleration,this.normal,this.rotation,this.rotationalSpeed,this.size,this.color,this.alpha,this.initialSize,this.initialColor,this.initialAlpha)}copy(e){this.setAll(e.progressType,e.lifetime,e.age,e.sequenceElement,e.position,e.velocity,e.acceleration,e.normal,e.rotation,e.rotationalSpeed,e.size,e.color,e.alpha,e.initialSize,e.initialColor,e.initialAlpha)}}class Ae{constructor(){this.particleCount=0,this.activeParticleCount=0,this.particleStates=[]}init(e){this.setParticleCount(e)}setParticleCount(e){this.particleCount!=e&&(this.dispose(),this.allocate(e)),this.particleCount=e}setActiveParticleCount(e){this.activeParticleCount=e}allocate(e){this.particleStates=[],this.particleCount=e;for(let t=0;t<e;t++)this.particleStates[t]=new be}dispose(){}getParticleCount(){return this.particleCount}flushParticleStateToBuffers(){}copyState(e,t){if(e>=this.particleCount)throw new Error('ParticleStateArray::copyState() -> "srcIndex" is out of range.');if(t>=this.particleCount)throw new Error('ParticleStateArray::copyState() -> "destIndex" is out of range.');const i=this.particleStates[e],r=this.particleStates[t];i.copyTo(r)}setState(e,t){if(e>=this.particleCount)throw new Error('ParticleStateArray::setState() -> "index" is out of range.');return this.particleStates[e].copy(t)}getState(e){if(e>=this.particleCount)throw new Error('ParticleStateArray::getState() -> "index" is out of range.');return this.particleStates[e]}computeBoundingBox=function(){const e=new Te.Vector3;return function(t=new Te.Box3,i=null){const r=t.min,a=t.max;for(let n=0;n<this.activeParticleCount;n++){const t=this.getState(n);let s=t.position;i&&(e.copy(s),e.applyMatrix4(i),s=e);const o=Math.max(t.size.x,t.size.y),l=s.x-o,c=s.x+o,u=s.y-o,h=s.y+o,d=s.z-o,p=s.z+o;(0==n||s.x<r.x)&&(r.x=l),(0==n||s.x>a.x)&&(a.x=c),(0==n||s.y<r.y)&&(r.y=u),(0==n||s.y>a.y)&&(a.y=h),(0==n||s.z<r.z)&&(r.z=d),(0==n||s.z>a.z)&&(a.z=p)}return t}}();computeBoundingSphere=function(){const e=new Te.Vector3,t=new Te.Vector3,i=new Te.Vector3;return function(r=new Te.Sphere,a=null){let n=0;for(let s=0;s<this.activeParticleCount;s++){const r=this.getState(s);let o=r.position;a&&(i.copy(o),i.applyMatrix4(a),o=i);const l=Math.max(r.size.x,r.size.y);if(0==s)e.copy(o),n=l;else{t.copy(o).sub(e);const i=t.length()+l;if(i>n){const r=(i-n)/2;t.normalize().multiplyScalar(r),e.add(t),n+=r}}}return r.center.copy(e),r.radius=n,r}}()}class Ie{constructor(e,t,i=0){this.start=e,this.length=t,this.id=i}}class Ve{constructor(){this.sequences={},this.ids=[]}addSequence(e,t,i){if(this.hasID(i))throw new Error("ParticleSequenceGroup::addParticleSequence -> Tried to add sequence with duplicate ID.");const r=new Ie(e,t,i);return this.sequences[i]=r,this.ids.push(i),r}getSequence(e){if(!this.hasID(e))throw new Error("ParticleSequenceGroup::getSequence -> Invalid ID.");return this.sequences[e]}getSequenceIDs(){return this.ids}hasID(e){return!!this.sequences[e]}}class ze{constructor(){}initializeState(e){e.initialColor.set(1,1,1),e.initialSize.set(1,1),e.initialAlpha=1,e.progressType=Ce.Time,e.lifetime=0,e.age=0,e.sequenceElement.set(0,0,0,0),e.position.set(0,0,0),e.velocity.set(0,0,0),e.acceleration.set(0,0,0),e.normal.set(0,0,1),e.rotation=0,e.rotationalSpeed=0,e.size.copy(e.initialSize),e.color.copy(e.initialColor),e.alpha=1}}class Ee extends ze{constructor(){super()}initializeState(e){super.initializeState(e)}}class Fe{constructor(){}updateState(){}}class Oe extends Fe{constructor(){super(),this.timeScaledVelocity=new Te.Vector3,this.timeScaledAcceleration=new Te.Vector3,this.stateAcceleration=new Te.Vector3,this.stateVelocity=new Te.Vector3}updateState(e,t){return super.updateState(e,t),this.stateAcceleration.copy(e.acceleration),this.timeScaledAcceleration.copy(this.stateAcceleration),this.timeScaledAcceleration.multiplyScalar(t),e.velocity.add(this.timeScaledAcceleration),this.stateVelocity.copy(e.velocity),this.timeScaledVelocity.copy(this.stateVelocity),this.timeScaledVelocity.multiplyScalar(t),e.position.add(this.timeScaledVelocity),e.age=e.age+t,e.rotation=e.rotation+t*e.rotationalSpeed,!0}}class Ne{static clamp(e,t,i){return Math.min(Math.max(e,t),i)}static currentTime(){return performance.now()/1e3}}class Re{constructor(){this.components=[]}addComponent(e){this.components.push(e)}update(e,t){for(const i of this.components)i.update(e,t)}getComponent(e){if(e>=this.components.length)throw new Error('ComponentContainer::getComponent() -> "index" is out of range.');return this.components[e]}}class Me{static NotStarted=new Me("NotStarted");static Running=new Me("Running");static Paused=new Me("Paused");static Done=new Me("Done");constructor(e){this.name=e}}class Ue{constructor(e,t){this.owner=e,this.owner.visible=!1,this.visible=!0,this.particleSystemRenderer=t,this.initialized=!1,this.maximumActiveParticles=0,this.activeParticleCount=0,this.simulateInWorldSpace=!0,this.emitterInitialized=!1,this.particleEmitter=null,this.componentContainer=new Re,this.particleStateInitializers=[],this.particleStateOperators=[],this.particleStates=null,this.systemState=Me.NotStarted,this.particleSequences=new Ve,this.onUpdateCallback=null,this.transformInitialDirectionInWorldSpace=!0,this.boundingBox=new Te.Box3,this.boundingSphere=new Te.Sphere}init(e){if(this.initialized)throw new Error("ParticleSystem::init() -> trying to intialize more than once.");this.maximumActiveParticles=e,this.particleSystemRenderer?(this.particleSystemRenderer.setOwner(this.owner),this.particleSystemRenderer.init(this.maximumActiveParticles,this.simulateInWorldSpace),this.particleSystemRenderer.setSimulateInWorldSpace(this.simulateInWorldSpace),this.particleStates=this.particleSystemRenderer.getParticleStateArray()):(this.particleStates=new Ae,this.particleStates.init(this.maximumActiveParticles)),this.addParticleStateInitializer(new Ee),this.addParticleStateOperator(new Oe),this.initialized=!0}getVisible(){return this.visible}setVisibile(e){return this.visible=e}onUpdate(e){this.onUpdateCallback=e}update(e,t){if(this.systemState==Me.Running){if(this.owner.updateWorldMatrix(!0),e=null==e||null==e?Ne.currentTime():e,t=null==t||null==t?e-this.lastUpdateTime:t,this.emitterInitialized&&this.systemState==Me.Running){const e=this.particleEmitter.update(t);e>0&&this.activateParticles(e),this.advanceActiveParticles(t),this.onUpdateCallback&&this.onUpdateCallback(this.activeParticleCount),this.updateBounds()}this.componentContainer.update(e,t),this.lastUpdateTime=e}}render(e,t){if(this.getVisible()&&this.particleSystemRenderer){const i=e.autoClear;e.autoClear=!1,this.owner.visible=!0,this.owner.matrixWorldNeedsUpdate=!0,this.particleSystemRenderer.render(this.owner,e,t),this.owner.visible=!1,e.autoClear=i}}start(){this.systemState!=Me.NotStarted&&this.systemState!=Me.Paused||(this.systemState=Me.Running,this.startTime=Ne.currentTime(),this.lastUpdateTime=this.startTime)}pause(){this.systemState==Me.Running&&(this.systemState=Me.Paused)}stop(){}getSystemState(){return this.systemState}setEmitter(e){return this.particleEmitter=e,this.particleEmitter.maximumActiveParticles=this.maximumActiveParticles,this.emitterInitialized=!0,this.particleEmitter}addComponent(e){this.componentContainer.addComponent(e)}getComponent(e){return this.componentContainer.getComponent(e)}addParticleStateInitializer(e){return this.particleStateInitializers.push(e),e}getParticleStateInitializerCount(){return this.particleStateInitializers.length}getParticleStateInitializer(e){if(e>=this.particleStateInitializers.length)throw new Error('ParticleSystem::getParticleStateInitializer() -> "index" is out of range.');return this.particleStateInitializers[e]}addParticleStateOperator(e){return this.particleStateOperators.push(e),e}getParticleStateOperatorCount(){return this.particleStateOperators.length}getParticleStateOperator(e){if(e>=this.particleStateOperators.length)throw new Error('ParticleSystem::getParticleStateOperator() -> "index" is out of range.');return this.particleStateOperators[e]}getMaximumActiveParticles(){return this.maximumActiveParticles}getActiveParticleCount(){return this.activeParticleCount}getParticleState(e){if(e>=this.activeParticleCount)throw new Error('ParticleSystem::getParticleState() -> "index" is out of range.');return this.particleStates.getState(e)}getParticleStates(){return this.particleStates}getParticleSystemRenderer(){return this.particleSystemRenderer}getSimulateInWorldSpace(){return this.simulateInWorldSpace}setSimulateInWorldSpace(e){this.simulateInWorldSpace=e,this.particleSystemRenderer&&this.particleSystemRenderer.setSimulateInWorldSpace(this.simulateInWorldSpace)}setTransformInitialDirectionInWorldSpace(e){this.transformInitialDirectionInWorldSpace=e}addParticleSequence(e,t,i=0){this.particleSequences.addSequence(e,t,i)}getParticleSequences(){return this.particleSequences}getEmitter(){return this.particleEmitter}updateBounds=function(){const e=new Te.Matrix4;return function(){let t=null;this.transformInitialDirectionInWorldSpace&&(t=e,t.copy(this.owner.matrixWorld).invert()),this.particleSystemRenderer.calculatingBoundingSphereFromBox()?(this.particleStates.computeBoundingBox(this.boundingBox,t),this.particleSystemRenderer.setBoundingBox(this.boundingBox)):(this.particleStates.computeBoundingSphere(this.boundingSphere,t),this.particleSystemRenderer.setBoundingSphere(this.boundingSphere))}}();activateParticles(e){if(this.systemState==Me.Running){const t=Ne.clamp(this.activeParticleCount+e,0,this.maximumActiveParticles);for(let e=this.activeParticleCount;e<t;e++)this.activateParticle(e);this.activeParticleCount=t,this.particleStates.setActiveParticleCount(this.activeParticleCount)}}activateParticle(e){if(this.systemState==Me.Running){const t=this.particleStates.getState(e);t.age=0;for(let e=0;e<this.particleStateInitializers.length;e++){this.particleStateInitializers[e].initializeState(t)}if(this.simulateInWorldSpace){t.position.applyMatrix4(this.owner.matrixWorld);const e=t.velocity.length();if(this.transformInitialDirectionInWorldSpace){t.velocity.transformDirection(this.owner.matrixWorld).multiplyScalar(e);const i=t.acceleration.length();t.acceleration.transformDirection(this.owner.matrixWorld).multiplyScalar(i)}}this.particleStates.flushParticleStateToBuffers(e)}}advanceActiveParticles(e){if(this.systemState==Me.Running){let t=0;for(;t<this.activeParticleCount;){this.advanceActiveParticle(t,e)?t++:(t<this.activeParticleCount-1&&this.copyParticleInArray(this.activeParticleCount-1,t),this.activeParticleCount--)}this.particleStates.setActiveParticleCount(this.activeParticleCount)}}advanceActiveParticle(e,t){if(this.systemState==Me.Running){const i=this.particleStates.getState(e);for(let e=0;e<this.particleStateOperators.length;e++){const r=this.particleStateOperators[e].updateState(i,t),a=i.lifetime;if(!r||0!=a&&i.age>=a)return!1}return this.particleStates.flushParticleStateToBuffers(e),!0}return!1}copyParticleInArray(e,t){this.particleStates.copyState(e,t),this.particleStates.flushParticleStateToBuffers(t)}static fromJSON(e,t,i){const r=(e,t,i)=>{t(e);for(const a in e)if(e.hasOwnProperty(a)){const i=e[a];"object"==typeof i&&r(i,t)}};r(e,e=>{e.type&&(e.type=t.parseTypeString(e.type))});const a=e.maxParticleCount,n=e.simulateInWorldSpace,s=e.renderer,o=s.type.fromJSON(s.params),l=new Te.Object3D,c=new Ue(l,o,i);c.init(a),c.setSimulateInWorldSpace(n);const u=e.emitter,h=u.type.fromJSON(u.params);if(c.setEmitter(h),e.sequences)for(const d of e.sequences)c.addParticleSequence(d.start,d.length,d.id);if(e.initializers)for(const d of e.initializers)c.addParticleStateInitializer(d.type.fromJSON(c,d.params));if(e.operators)for(const d of e.operators){const e=c.addParticleStateOperator(d.type.fromJSON(c,d.params));d.elements&&e.addElementsFromParameters(d.elements)}return[c,l]}toJSON(e){const t=this.getParticleSystemRenderer(),i=this.getEmitter(),r=this.getParticleSequences(),a=r.getSequenceIDs().map(e=>{const t=r.getSequence(e);return{id:e,start:t.start,length:t.length}}),n=[],s=this.getParticleStateInitializerCount();for(let c=0;c<s;c++){const t=this.getParticleStateInitializer(c);t.constructor!==Ee&&n.push({type:e.getTypePath(t.constructor),params:t.toJSON(e)})}const o=[],l=this.getParticleStateOperatorCount();for(let c=0;c<l;c++){const t=this.getParticleStateOperator(c);if(t.constructor!==Oe){const i=t.toJSON(e),r=i.params||i,a=i.params?i.elements:null,n={type:e.getTypePath(t.constructor),params:r};a&&(n.elements=a),o.push(n)}}return{maxParticleCount:this.getMaximumActiveParticles(),simulateInWorldSpace:this.getSimulateInWorldSpace(),renderer:{type:e.getTypePath(t.constructor),params:t.toJSON()},emitter:{type:e.getTypePath(i.constructor),params:i.toJSON()},sequences:a,initializers:n,operators:o}}}class Be{constructor(){this.particleSystems=[],this.startupTime=performance.now()/1e3,this.lastUpdateTime=this.startupTime,this.componentContainer=new Re}update(){const e=Ne.currentTime(),t=e-this.lastUpdateTime;for(const i of this.particleSystems)i.update(e,t);this.componentContainer.update(e,t),this.lastUpdateTime=e}render(e,t){for(const i of this.particleSystems)i.render(e,t)}addParticleSystem(e){this.particleSystems.push(e)}addComponent(e){this.componentContainer.addComponent(e)}getComponent(e){return this.componentContainer.getComponent(e)}}class qe{constructor(){this.initialized=!1,this.particleCount=0,this.owner=null,this.simulateInWorldSpace=!1}setSimulateInWorldSpace(e){this.simulateInWorldSpace=e}getParticleStateArray(){}setOwner(e){this.owner=e}init(e){if(this.particleCount=e,!this.initialized)return this.initialized=!0,!0;throw new Error("Renderer::init() -> trying to intialize more than once.")}render(){}}class De extends Ae{constructor(){super(),this.geometry=null,this.progressTypes=null,this.lifetimes=null,this.ages=null,this.sequenceElements=null,this.positions=null,this.velocities=null,this.accelerations=null,this.normals=null,this.rotations=null,this.rotationalSpeeds=null,this.sizes=null,this.colors=null,this.initialSizes=null,this.initialColors=null,this.instanced=!1,this.verticesPerParticle=6}init(e,t=!1){this.instanced=t,this.instanced?this.verticesPerParticle=1:this.verticesPerParticle=6,super.init(e),this.allocate(e)}setParticleCount(e){super.setParticleCount(e)}setActiveParticleCount(e){super.setActiveParticleCount(e),e>0?this.instanced?this.geometry.instanceCount=e:this.geometry.setDrawRange(0,this.verticesPerParticle*e):this.instanced?this.geometry.instanceCount=0:this.geometry.setDrawRange(0,0)}flushParticleStateToBuffers(e){if(e>=this.particleCount)throw new Error('ParticleStateAttributeArray::flushParticleStateToBuffers() -> "index" is out of range.');const t=this.getState(e),i=e*this.verticesPerParticle;for(let r=0;r<this.verticesPerParticle;r++)this.lifetimes.setX(i+r,t.lifetime),this.lifetimes.needsUpdate=!0,this.ages.setX(i+r,t.age),this.ages.needsUpdate=!0,this.sequenceElements.setXYZW(i+r,t.sequenceElement.x,t.sequenceElement.y,t.sequenceElement.z,t.sequenceElement.w),this.sequenceElements.needsUpdate=!0,this.positions.setXYZ(i+r,t.position.x,t.position.y,t.position.z),this.positions.needsUpdate=!0,this.velocities.setXYZ(i+r,t.velocity.x,t.velocity.y,t.velocity.z),this.velocities.needsUpdate=!0,this.accelerations.setXYZ(i+r,t.acceleration.x,t.acceleration.y,t.acceleration.z),this.accelerations.needsUpdate=!0,this.normals.setXYZ(i+r,t.normal.x,t.normal.y,t.normal.z),this.normals.needsUpdate=!0,this.rotations.setX(i+r,t.rotation),this.rotations.needsUpdate=!0,this.rotationalSpeeds.setX(i+r,t.rotationalSpeed),this.rotationalSpeeds.needsUpdate=!0,this.sizes.setXY(i+r,t.size.x,t.size.y),this.sizes.needsUpdate=!0,this.colors.setXYZ(i+r,t.color.r,t.color.g,t.color.b),this.colors.needsUpdate=!0,this.alphas.setX(i+r,t.alpha),this.alphas.needsUpdate=!0,this.initialSizes.setXY(i+r,t.initialSize.x,t.initialSize.y),this.initialSizes.needsUpdate=!0,this.initialAlphas.setX(i+r,t.initialAlpha),this.initialAlphas.needsUpdate=!0}copyState(e,t){super.copyState(e,t),this.flushParticleStateToBuffers(t)}setState(e,t){if(e>=this.particleCount)throw new Error('ParticleStateAttributeArray::setState() -> "index" is out of range.');super.setState(e,t),this.flushParticleStateToBuffers(e)}getPositions(){return this.positions}getSizes(){return this.sizes}getRotations(){return this.rotations}getSequenceElements(){return this.sequenceElements}getColors(){return this.colors}getGeometry(){return this.geometry}allocate(e){super.allocate(e);const t=(e,t)=>this.instanced?new Te.InstancedBufferAttribute(e,t):new Te.BufferAttribute(e,t),i=this.verticesPerParticle*this.particleCount;if(this.instanced){const e=new Te.BufferGeometry,t=new Float32Array(18);this.basePositions=new Te.BufferAttribute(t,3),e.setAttribute("position",this.basePositions),this.basePositions.needsUpdate=!0,this.basePositions.setXYZ(0,-1,1,0),this.basePositions.setXYZ(1,-1,-1,0),this.basePositions.setXYZ(2,1,1,0),this.basePositions.setXYZ(3,-1,-1,0),this.basePositions.setXYZ(4,1,-1,0),this.basePositions.setXYZ(5,1,1,0);const i=new Float32Array(12);this.baseUVs=new Te.BufferAttribute(i,2),e.setAttribute("baseUV",this.baseUVs),this.baseUVs.needsUpdate=!0,this.baseUVs.setXY(0,0,1),this.baseUVs.setXY(1,0,0),this.baseUVs.setXY(2,1,1),this.baseUVs.setXY(3,0,0),this.baseUVs.setXY(4,1,0),this.baseUVs.setXY(5,1,1);const r=new Float32Array(6);this.customIndexes=new Te.BufferAttribute(r,1),e.setAttribute("customIndex",this.customIndexes),this.customIndexes.needsUpdate=!0,this.customIndexes.setX(0,0),this.customIndexes.setX(1,1),this.customIndexes.setX(2,3),this.customIndexes.setX(3,1),this.customIndexes.setX(4,2),this.customIndexes.setX(5,3),this.geometry=(new Te.InstancedBufferGeometry).copy(e),this.geometry.instanceCount=0}else{this.geometry=new Te.BufferGeometry;const e=new Float32Array(i);this.customIndexes=new Te.BufferAttribute(e,1),this.geometry.setAttribute("customIndex",this.customIndexes),this.customIndexes.needsUpdate=!0;for(let t=0;t<this.particleCount;t++){const e=t*this.verticesPerParticle;this.customIndexes.setX(e,0),this.customIndexes.setX(e+1,1),this.customIndexes.setX(e+2,3),this.customIndexes.setX(e+3,1),this.customIndexes.setX(e+4,2),this.customIndexes.setX(e+5,3)}}const r=new Float32Array(i),a=new Float32Array(i),n=new Float32Array(4*i),s=new Float32Array(3*i),o=new Float32Array(3*i),l=new Float32Array(3*i),c=new Float32Array(3*i),u=new Float32Array(i),h=new Float32Array(i),d=new Float32Array(2*i),p=new Float32Array(3*i),m=new Float32Array(i),f=new Float32Array(2*i),g=new Float32Array(3*i),S=new Float32Array(i);this.positions=t(s,3),this.positions.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("particlePosition",this.positions),this.lifetimes=t(r,1),this.lifetimes.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("lifetime",this.lifetimes),this.ages=t(a,1),this.ages.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("age",this.ages),this.sequenceElements=t(n,4),this.sequenceElements.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("sequenceElement",this.sequenceElements),this.velocities=t(o,3),this.velocities.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("velocity",this.velocities),this.accelerations=t(l,3),this.accelerations.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("acceleration",this.accelerations),this.normals=t(c,3),this.normals.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("normal",this.normals),this.rotations=t(u,1),this.rotations.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("rotation",this.rotations),this.rotationalSpeeds=t(h,1),this.rotationalSpeeds.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("rotationalSpeed",this.rotationalSpeeds),this.sizes=t(d,2),this.sizes.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("size",this.sizes),this.colors=t(p,3),this.colors.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("color",this.colors),this.alphas=t(m,1),this.alphas.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("alpha",this.alphas),this.initialSizes=t(f,2),this.initialSizes.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("initialSize",this.initialSizes),this.initialColors=t(g,3),this.initialColors.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("initialColor",this.initialColors),this.initialAlphas=t(S,1),this.initialAlphas.setUsage(Te.DynamicDrawUsage),this.geometry.setAttribute("initialAlpha",this.initialAlphas)}dispose(){super.dispose(),this.geometry&&(this.geometry.dispose(),this.geometry=null)}}class _e{constructor(e,t,i,r,a){this.length=e,this.x=t,this.y=i,this.width=r,this.height=a}}class We{constructor(e,t){this.texture=e,this.texturePath=t,this.frameSets=[]}getTexture(){return this.texture}getTexturePath(){return this.texturePath}getFrameSetCount(){return this.frameSets.length}addFrameSet(e,t,i,r,a){this.frameSets.push(new _e(e,t,i,r,a))}getFrameSet(e){if(e>=this.frameSets.length)throw new Error('Atlas::getFrameSet -> "index" is out of range.');return this.frameSets[e]}}class Xe extends qe{constructor(e,t,i=!1,r=Te.NormalBlending,a=!0,n){super(),this.instanced=e,this.particleStateArray=null,this.material=null,this.mesh=null,this.atlas=t,this.interpolateAtlasFrames=i,this.blending=r,this.boundingBox=new Te.Box3,this.boundingSphere=new Te.Sphere,this.calculateBoundingSphereFromBox=a,this.renderOrder=n}setOwner(e){super.setOwner(e)}getParticleStateArray(){return this.particleStateArray}setSimulateInWorldSpace(e){super.setSimulateInWorldSpace(e),this.material&&(this.material.uniforms.simulateInWorldSpace.value=e?1:0,this.material.uniformsNeedUpdate=!0)}calculatingBoundingSphereFromBox(){return this.calculateBoundingSphereFromBox}setBoundingBox(e){this.boundingBox.copy(e),this.mesh&&this.updateMeshBounds()}setBoundingSphere(e){this.boundingSphere.copy(e),this.mesh&&this.updateMeshBounds()}render(e,t,i){t.render(e,i)}updateMeshBounds=function(){const e=new Te.Vector3;return function(){const t=this.particleStateArray.getGeometry();if(this.calculateBoundingSphereFromBox){t.boundingBox||(t.boundingBox=new Te.Box3),t.boundingBox.copy(this.boundingBox),t.boundingSphere||(t.boundingSphere=new Te.Sphere),e.x=(this.boundingBox.min.x+this.boundingBox.max.x)/2,e.y=(this.boundingBox.min.y+this.boundingBox.max.y)/2,e.z=(this.boundingBox.min.z+this.boundingBox.max.z)/2;const i=this.boundingBox.max.x-e.x,r=this.boundingBox.max.y-e.y,a=this.boundingBox.max.z-e.z,n=Math.max(Math.max(i,r),a);t.boundingSphere.center.copy(e),t.boundingSphere.radius=Math.sqrt(2*n*n)}else t.boundingSphere||(t.boundingSphere=new Te.Sphere),t.boundingSphere.copy(this.boundingSphere)}}();init(e){super.init(e)&&(this.particleStateArray=new De,this.particleStateArray.init(e,this.instanced),this.material=this.createMaterial(null,null,null,!0,!1),this.material.blending=this.blending,this.mesh=new Te.Mesh(this.particleStateArray.getGeometry(),this.material),this.mesh.frustumCulled=!0,void 0!==this.renderOrder&&(this.mesh.renderOrder=this.renderOrder),this.updateMeshBounds(),this.owner.add(this.mesh))}dispose(){this.particleStateArray.dispose()}createMaterial(e,t,i,r,a){const n=[...Array(16).keys()].map(e=>new Te.Vector4);if(this.atlas)for(let h=0;h<this.atlas.getFrameSetCount();h++){const e=this.atlas.getFrameSet(h);n[h]=new Te.Vector4(e.x,e.y,e.width,e.height)}const s=this.atlas?this.atlas.getTexture():null,o=this.interpolateAtlasFrames,l=this.simulateInWorldSpace,c=this.instanced?1:0,u={atlasFrameSet:{type:"v4v",value:n},atlasTexture:{type:"t",value:s},interpolateAtlasFrames:{value:o},uvOffset:{type:"v2",value:new Te.Vector2},simulateInWorldSpace:{value:l},instanced:{value:c}};return i=i||{},Object.assign(i,u),e=e||Xe.Shader.getVertexShader(a),t=t||Xe.Shader.getFragmentShader(r,a),new Te.ShaderMaterial({uniforms:i,vertexShader:e,fragmentShader:t,transparent:!0,alphaTest:1,blending:Te.NormalBlending,blendDstAlpha:Te.OneMinusSrcAlphaFactor,blendSrcAlpha:Te.SrcAlphaFactor,depthTest:!0,depthWrite:!1})}static Shader={get VertexVars(){return["const int MAX_ATLAS_FRAME_SETS = 16; \n","uniform vec4 atlasFrameSet[MAX_ATLAS_FRAME_SETS]; \n","uniform int interpolateAtlasFrames; \n","uniform int simulateInWorldSpace; \n","uniform int instanced; \n","attribute vec2 baseUV;\n","attribute float customIndex;\n","attribute vec4 particlePosition;\n","attribute float rotation;\n","attribute vec2 size;\n","attribute vec4 sequenceElement;\n","attribute vec3 color;\n","attribute float alpha;\n","varying vec2 vUV1;\n","varying vec2 vUV2;\n","varying vec3 vFragColor;\n","varying float vFragAlpha;\n","varying float vSequenceElementT; \n"].join("\n")},get FragmentVars(){return["uniform int interpolateAtlasFrames; \n","uniform sampler2D atlasTexture;\n","uniform vec2 uvOffset;\n","varying vec2 vUV1;\n","varying vec2 vUV2;\n","varying vec3 vFragColor;\n","varying float vFragAlpha;\n","varying float vSequenceElementT;\n"].join("\n")},getVertexShader(e){let t=["#include <common>",this.VertexVars].join("\n");return e&&(t+="  \n #include <logdepthbuf_pars_vertex> \n"),t+=["void getUV(in int sequenceElement, in int sequenceNumber, in vec4 atlasFrames, out vec2 uv) { \n","   float atlasFrameWidth = atlasFrames.z; \n","   float atlasFrameHeight = atlasFrames.w; \n","   float atlasFrameX = atlasFrames.x; \n","   float atlasFrameY = atlasFrames.y; \n","   int firstRowSections = int((1.0 - atlasFrameX) / atlasFrameWidth); \n","   int maxRowSections = int(1.0 / atlasFrameWidth); \n","   float firstRowX = atlasFrameX + atlasFrameWidth * float(sequenceElement); \n","   float firstRowY = 1.0 - (atlasFrameY + atlasFrameHeight); \n","   int nRowSequenceElement = sequenceElement - firstRowSections; \n","   float SNOverHS = float(nRowSequenceElement) / float(maxRowSections);\n","   int nRowYTile = int(SNOverHS);\n","   int nRowXTile = int((SNOverHS - float(nRowYTile)) * float(maxRowSections));\n","   float nRowX = float(nRowXTile) * atlasFrameWidth;\n","   float nRowY = 1.0 - ((float(nRowYTile) + 1.0) * (atlasFrameHeight) + atlasFrameY + atlasFrameHeight);\n","   float nRow = step(float(firstRowSections), float(sequenceElement)); \n","   uv.x = nRow * nRowX + (1.0 - nRow) * firstRowX; \n","   uv.y = nRow * nRowY + (1.0 - nRow) * firstRowY; \n","} \n","void main()\n","{\n","   const vec2 right = vec2(1.0, 0.0);\n","   const vec2 up = vec2(0.0, 1.0);\n","   const vec2 left = vec2(-1.0, 0.0);\n","   const vec2 down = vec2(0.0, -1.0);\n","   const vec2 uRight = vec2(1.0, 1.0);\n","   const vec2 uLeft = vec2(-1.0, 1.0);\n","   const vec2 dLeft = vec2(-1.0, -1.0);\n","   const vec2 dRight = vec2(1.0, -1.0);\n","   vec4 viewPosition; \n","   if (simulateInWorldSpace == 1) { \n","       viewPosition = viewMatrix * particlePosition;\n","   } else { \n","       viewPosition = viewMatrix * modelMatrix * particlePosition;\n","   } \n","   float sequenceElementF = sequenceElement.x;\n","   int sequenceNumber = int(sequenceElement.y);\n","   int sequenceStart = int(sequenceElement.z);\n","   int sequenceLength = int(sequenceElement.w);\n","   vec4 atlasFrames = atlasFrameSet[sequenceNumber]; \n","   vec2 uv1; \n","   vec2 uv2; \n","   vSequenceElementT = sequenceElementF - float(int(sequenceElementF)); \n","   int firstSequenceElement = int(sequenceElementF); \n","   int secondSequenceElement = clamp(firstSequenceElement + 1, sequenceStart, sequenceStart + sequenceLength - 1); \n","   getUV(firstSequenceElement, sequenceNumber, atlasFrames, uv1); \n","   if (interpolateAtlasFrames == 1 && firstSequenceElement != secondSequenceElement) { \n ","       getUV(secondSequenceElement, sequenceNumber, atlasFrames, uv2); \n","   } \n","   float atlasFrameWidth = atlasFrames.z; \n","   float atlasFrameHeight = atlasFrames.w; \n","   float rotMag = rotation; \n","   mat2 rotMat = mat2(cos(rotMag), -sin(rotMag), sin(rotMag), cos(rotMag)) * mat2(size.x, 0.0, 0.0, size.y);\n","   float rightSide; \n","   float upperSide; \n","   if (instanced != 1) { \n","       rightSide = step(2.0, customIndex); \n","       vec2 upperSideStep = step(vec2(customIndex, 3.0), vec2(0.0, customIndex));\n","       upperSide = upperSideStep.x + upperSideStep.y;\n","   }  else { \n","       rightSide = baseUV.x; \n","       upperSide = baseUV.y; \n","   } \n","   float uvXOffset = atlasFrameWidth * rightSide; \n","   float uvYOffset = atlasFrameHeight * upperSide; \n","   vec2 rotVec; \n","   if (instanced != 1) { \n","       vec4 rotVecStep = step(vec4(customIndex, customIndex, 3.0, 2.0), vec4(0.0, 1.0, customIndex, customIndex)); \n","       float uLeftV = rotVecStep.x; \n","       float dLeftV = rotVecStep.y - rotVecStep.x; \n","       float uRightV = rotVecStep.z; \n","       float dRightV = rotVecStep.w - rotVecStep.z; \n","       rotVec = uLeft * uLeftV + dLeft * dLeftV + dRight * dRightV + uRight * uRightV; \n","   }  else { \n","       rotVec = position.xy; \n ","   } \n","   gl_Position = projectionMatrix * (vec4(rotMat * rotVec, 0.0, 0.0) + viewPosition);\n","   vUV1 = vec2(uv1.x + uvXOffset, uv1.y + uvYOffset);\n","   vUV2 = vec2(uv2.x + uvXOffset, uv2.y + uvYOffset);\n","   vFragColor = color; \n","   vFragAlpha = alpha; \n"].join("\n"),e&&(t+="   \n  #include <logdepthbuf_vertex> \n"),t+="} \n",t},getFragmentShader(e,t){let i=`#include <common> \n${this.FragmentVars}\n`;return t&&(i+="  \n #include <logdepthbuf_pars_fragment> \n"),i+="void main() { \n",t&&(i+="    \n  #include <logdepthbuf_fragment> \n"),i+=e?["   vec4 color1 = texture(atlasTexture, vUV1 + uvOffset) * vec4(vFragColor, 1.0);\n","   vec4 color2 = color1; \n","   if (interpolateAtlasFrames == 1) color2 = texture(atlasTexture, vUV2 + uvOffset) * vec4(vFragColor, 1.0);\n","   gl_FragColor = mix(color1, color2, vSequenceElementT);\n","   gl_FragColor.a *= vFragAlpha; \n"].join("\n"):["   vec4 color1 = texture2D(atlasTexture, vUV1 + uvOffset) * vec4(vFragColor, 1.0);\n","   vec4 color2 = color1; \n","   if (interpolateAtlasFrames == 1) color2 = texture(atlasTexture, vUV2 + uvOffset) * vec4(vFragColor, 1.0);\n","   gl_FragColor = mix(color1, color2, vSequenceElementT);\n","   gl_FragColor.a *= vFragAlpha; \n"].join("\n"),i+="}\n",i}};static fromJSON(e){const t=e.atlas,i=(new Te.TextureLoader).load(t.texturePath),r=new We(i,t.texturePath),a=t.framesets;for(const s of a)r.addFrameSet(s.length,s.x,s.y,s.width,s.height);const n=new Xe(e.instanced,r,t.interpolateFrames);return"Additive"==e.blending?n.blending=Te.AdditiveBlending:n.blending=Te.NormalBlending,n}toJSON(e){e=e||(e=>{if(e.texturePath)return e.texturePath;const t=e.getTexture().source;if(t){const e=t.data;if(e){const t=e.baseURI,i=e.currentSrc;return i.indexOf(t)>=0?i.substr(t.length,i.length-t.length):i}}});const t=[];for(let r=0;r<this.atlas.getFrameSetCount();r++){const e=this.atlas.getFrameSet(r);t.push(e)}let i="Normal";this.material.blending===Te.AdditiveBlending&&(i="Additive");return{instanced:this.instanced,blending:i,atlas:{interpolateFrames:this.interpolateAtlasFrames,texturePath:e(this.atlas),framesets:t}}}}class je{constructor(){this.emissionRelativeStartTime=0,this.emissionDuration=0,this.emitCount=0,this.age=0,this.timeActive=0,this.activeCount=0,this.maximumActiveParticles=0}update(e){return this.internalUpdate(e),0}internalUpdate(e){return this.age+=e,this.timeActive=Math.max(this.age-this.emissionRelativeStartTime,0),this.age>=this.emissionRelativeStartTime&&(0==this.emissionDuration||this.timeActive<=emissionDuration)}updateEmitCount(e){this.emitCount+=e}}class ke extends je{constructor(){super(),this.emissionMinimum=0,this.emissionMaximum=0}}class Je extends ke{constructor(e=0){super(),this.emissionRate=e}update(e){if(this.internalUpdate(e)){const e=this.emissionRate*this.timeActive-this.emitCount;if(e>=1){const t=Math.floor(e);return this.updateEmitCount(t),t}}return 0}static fromJSON(e){const t=new Je;return t.emissionRate=e.emissionRate||0,t}toJSON(){return{emissionRate:this.emissionRate}}}class Le{static Default=new Le("Default");static Vector2=new Le("Vector2");static Vector3=new Le("Vector3");static Vector4=new Le("Vector4");static Color=new Le("Color");constructor(e){this.name=e}static getTypeID(e){let t=Le.Default;return e===Te.Vector2?t=Le.Vector2:e===Te.Vector3?t=Le.Vector3:e===Te.Vector4?t=Le.Vector4:e===Te.Color&&(t=Le.Color),t}static loadJSONParameter(e,t){switch(t){case Te.Vector2:return(new Te.Vector2).fromArray(e);case Te.Vector3:return(new Te.Vector3).fromArray(e);case Te.Vector4:return(new Te.Vector4).fromArray(e);case Te.Color:return(new Te.Color).fromArray(e)}return e}}class Ge{constructor(e){this.outType=e,this.outTypeID=Le.getTypeID(e)}}class Ye extends Ge{constructor(e,t,i,r,a,n){super(e),this.range=t,this.offset=i,this.uniformRange=r,this.uniformOffset=a,this.normalize=n}generate(e){const t=Math.random()*this.uniformRange;switch(this.outTypeID){case Le.Default:e=Math.random()*this.range+this.offset,this.normalize&&(e=e<0?-1:1);break;case Le.Vector2:e.set(this.generateForElement(t,"x"),this.generateForElement(t,"y"));break;case Le.Vector3:e.set(this.generateForElement(t,"x"),this.generateForElement(t,"y"),this.generateForElement(t,"z"));break;case Le.Vector4:e.set(this.generateForElement(t,"x"),this.generateForElement(t,"y"),this.generateForElement(t,"z"),this.generateForElement(t,"w"))}return this.normalize&&e.normalize(),e}generateForElement(e,t){return e+Math.random()*this.range[t]+this.offset[t]+this.uniformOffset}clone(){return new Ye(this.outType,this.range,this.offset,this.uniformRange,this.uniformOffset,this.normalize)}static getParameterJSON(e){return e instanceof Te.Vector2||e instanceof Te.Vector3||e instanceof Te.Vector4||e instanceof Te.Color?e.toArray():e}static fromJSON(e){return new Ye(e.type,Le.loadJSONParameter(e.range,e.type),Le.loadJSONParameter(e.offset,e.type),e.uniformRange||0,e.uniformOffset||0,e.normalize)}toJSON(e){const t={range:Ye.getParameterJSON(this.range),offset:Ye.getParameterJSON(this.offset),uniformRange:this.uniformRange,uniformOffset:this.uniformOffset},i=e.getTypePath(this.range.constructor);return null!=i&&(t.type=i),{type:e.getTypePath(Ye),params:t}}}class Ze extends ze{constructor(e,t,i,r,a){super(),this.range=e,this.offset=t,this.uniformRange=i,this.uniformOffset=r,this.normalize=a,this.generator=new Ye(0,this.range,this.offset,this.uniformRange,this.uniformOffset,this.normalize)}initializeState(e){e.lifetime=this.generator.generate()}static fromJSON(e,t){return new Ze(t.range,t.offset,t.uniformRange,t.uniformOffset,t.normalize)}toJSON(){return{range:this.range,offset:this.offset,uniformRange:this.uniformRange,uniformOffset:this.uniformOffset,normalize:this.normalize}}}class He extends ze{constructor(e){super(),this.generator=e.clone()}initializeState(e){e.rotation=this.generator.generate(e.rotation)}static fromJSON(e,t){const i=t.generator.type.fromJSON(t.generator.params);return new He(i)}toJSON(e){return{generator:this.generator.toJSON(e)}}}class $e extends ze{constructor(e,t,i,r,a){super(),this.range=e,this.offset=t,this.uniformRange=i,this.uniformOffset=r,this.normalize=a,this.generator=new Ye(0,this.range,this.offset,this.uniformRange,this.uniformOffset,this.normalize)}initializeState(e){e.rotationalSpeed=this.generator.generate()}static fromJSON(e,t){return new $e(t.range,t.offset,t.uniformRange,t.uniformOffset,t.normalize)}toJSON(){return{range:this.range,offset:this.offset,uniformRange:this.uniformRange,uniformOffset:this.uniformOffset,normalize:this.normalize}}}class Ke extends ze{constructor(e,t){super(),this.randomGenerator=new Ye(Te.Vector3,e,t,0,0,!1)}initializeState(e){this.randomGenerator.generate(e.position)}static fromJSON(e,t){return new Ke((new Te.Vector3).fromArray(t.range),(new Te.Vector3).fromArray(t.offset))}toJSON(){return{range:this.randomGenerator.range.toArray(),offset:this.randomGenerator.offset.toArray()}}}class Qe extends ze{constructor(e){super(),this.generator=e.clone()}initializeState(e){this.generator.generate(e.size),e.initialSize.copy(e.size)}static fromJSON(e,t){const i=t.generator.type.fromJSON(t.generator.params);return new Qe(i)}toJSON(e){return{generator:this.generator.toJSON(e)}}}class et extends ze{constructor(e,t,i,r,a=!0){super(),this.directionGenerator=new Ye(Te.Vector3,e,t,0,0,!0),this.speedGenerator=new Ye(0,i,r,0,0,!1),this.normalizeDirection=a}initializeState(e){this.directionGenerator.generate(e.velocity),this.normalizeDirection&&e.velocity.normalize(),e.velocity.multiplyScalar(this.speedGenerator.generate())}static fromJSON(e,t){return new et((new Te.Vector3).fromArray(t.range),(new Te.Vector3).fromArray(t.offset),t.speedRange,t.speedOffset)}toJSON(){return{range:this.directionGenerator.range.toArray(),offset:this.directionGenerator.offset.toArray(),speedRange:this.speedGenerator.range,speedOffset:this.speedGenerator.offset}}}class tt extends ze{constructor(e,t=!1){super(),this.setParticleSequences(e),this.reverse=t}setParticleSequences(e){this.particleSequences=e}initializeState(e){const t=this.particleSequences.getSequenceIDs(),i=t.length*Math.random(),r=t[Math.floor(i)],a=this.particleSequences.getSequence(r),n=e.sequenceElement;this.reverse?n.x=a.length-1:n.x=a.start,n.y=a.id,n.z=a.start,n.w=a.length,e.progressType=Ce.Sequence}static fromJSON(e,t){return new tt(e.getParticleSequences(),t.reverse)}toJSON(){return{reverse:this.reverse}}}class it extends Fe{constructor(e,t,i=!1,r=!1){super(),this.particleSequences=e,this.speed=t,this.loop=i,this.reverse=r}updateState(e,t){const i=e.sequenceElement,r=this.particleSequences.getSequence(i.y),a=t/this.speed;if(this.reverse){if(i.x-=a,i.x<r.start&&(i.x=r.start+r.length,!this.loop))return!1}else if(i.x+=a,i.x>=r.start+r.length&&(i.x=r.start,!this.loop))return!1;return!0}static fromJSON(e,t){return new it(e.getParticleSequences(),t.speed,t.loop,t.reverse)}toJSON(){return{speed:this.speed,loop:this.loop,reverse:this.reverse}}}class rt{constructor(e,t){this.elements=[],this.tValues=[],this.elementTypeID=Le.getTypeID(e),this.interpolator=t||this.getInterpolatorForTypeID(this.elementTypeID)}*[Symbol.iterator](){let e=0;for(;e<this.getElementCount();)yield{element:this.elements[e],tValue:this.tValues[e]},e++}getElementCount(){return this.elements.length}getElement(e){if(e>=this.getElementCount())throw new Error('ContinuousArray::getElement() -> "index" is out of bounds.');return this.elements[e]}getTValue(e){if(e>=this.getElementCount())throw new Error('ContinuousArray::getTValue() -> "index" is out of bounds.');return this.tValues[e]}addElement(e,t){this.elements.push(e),this.tValues.push(t)}getInterpolatedElement(e,t){return this.interpolator(e,this.elements,this.tValues,t)}getInterpolatorForTypeID=function(){const e={lowerIndex:0,upperIndex:0,localT:0},t=new Te.Vector2,i=new Te.Vector3,r=new Te.Vector4,a=new Te.Color,n=t=>(i,r,a,n)=>{rt.getInterpolationValuesForTValue(a,i,e),t.copy(r[e.upperIndex]).multiplyScalar(e.localT),n.copy(r[e.lowerIndex]).multiplyScalar(1-e.localT).add(t)};return function(s){switch(s){case Le.Default:return(t,i,r)=>(rt.getInterpolationValuesForTValue(r,t,e),(1-e.localT)*i[e.lowerIndex]+e.localT*i[e.upperIndex]);case Le.Vector2:return n(t);case Le.Vector3:return n(i);case Le.Vector4:return n(r);case Le.Color:return n(a)}}}();static getInterpolationValuesForTValue(e,t,i){const r=e.length;if(0===r)return i.lowerIndex=-1,i.upperIndex=-1,void(i.localT=-1);let a=0,n=-1,s=0;for(let c=0;c<r&&(a=e[c],!(a>t));c++)n++,s++;i.lowerIndex=Ne.clamp(n,0,r-1),i.upperIndex=Ne.clamp(s,0,r-1);const o=e[n],l=e[s];i.localT=(t-o)/(l-o)}}class at extends Fe{constructor(e,t=!1){super(),this.relativeToInitialValue=t,this.interpolationElements=new rt(e)}addElement(e,t){this.interpolationElements.addElement(e,t)}addElements(e){for(const t of e)this.interpolationElements.addElement(t[0],t[1])}addElementsFromElementClassAndParameters(e,t){for(const i of t){const[...t]=i[0];this.interpolationElements.addElement(new e(...t),i[1])}}getInterpolatedValue(e,t){let i=0;switch(e.progressType){case Ce.Time:i=0!=e.lifetime?e.age/e.lifetime:e.age;break;case Ce.Sequence:i=e.sequenceElement.x/e.sequenceElement.w}return this.interpolationElements.getInterpolatedElement(i,t)}}class nt extends at{constructor(e=!1){super(0,e)}addElementsFromParameters(e){super.addElements(e)}updateState(e){return this.relativeToInitialValue?e.alpha=e.initialAlpha*this.getInterpolatedValue(e,e.alpha):e.alpha=this.getInterpolatedValue(e,e.alpha),!0}static fromJSON(e,t){return new nt(t.relativeToInitialValue)}toJSON(){return{params:{relativeToInitialValue:this.relativeToInitialValue},elements:[...this.interpolationElements].map(e=>[e.element,e.tValue])}}}class st extends at{constructor(e=!1){super(Te.Vector2,e)}addElementsFromParameters(e){super.addElementsFromElementClassAndParameters(Te.Vector2,e)}updateState=function(){const e=new Te.Vector2;return function(t){return this.getInterpolatedValue(t,e),this.relativeToInitialValue?t.size.set(t.initialSize.x*e.x,t.initialSize.y*e.y):t.size.copy(e),!0}}();static fromJSON(e,t){return new st(t.relativeToInitialValue)}toJSON(){return{params:{relativeToInitialValue:this.relativeToInitialValue},elements:[...this.interpolationElements].map(e=>[e.element.toArray(),e.tValue])}}}class ot extends at{constructor(e=!1){super(Te.Color,e)}addElementsFromParameters(e){super.addElementsFromElementClassAndParameters(Te.Color,e)}updateState=function(){const e=new Te.Color;return function(t){return this.getInterpolatedValue(t,e),this.relativeToInitialValue?t.color.setRGB(t.initialColor.r*e.r,t.initialColor.g*e.g,t.initialColor.b*e.b):t.color.copy(e),!0}}();static fromJSON(e,t){return new ot(t.relativeToInitialValue)}toJSON(){return{params:{relativeToInitialValue:this.relativeToInitialValue},elements:[...this.interpolationElements].map(e=>[e.element.toArray(),e.tValue])}}}class lt extends Fe{constructor(e){super(),this.generator=e.clone()}addElementsFromParameters(e){super.addElementsFromElementClassAndParameters(THREE.Vector3,e)}updateState(e){return this.generator.generate(e.acceleration),!0}static fromJSON(e,t){const i=t.generator.type.fromJSON(t.generator.params);return new lt(i)}toJSON(e){return{generator:this.generator.toJSON(e)}}}class ct extends Ge{constructor(e,t,i,r,a,n,s,o,l,c,u,h){super(Te.Vector3),this.rangeTheta=e,this.offsetTheta=t,this.rangePhi=i,this.offsetPhi=r,this.rangeRadius=a,this.offsetRadius=n,this.scaleX=s,this.scaleY=o,this.scaleZ=l,this.offsetX=c,this.offsetY=u,this.offsetZ=h,this.tempUp=(new Te.Vector3).set(0,1,0)}generate(e){this.tempUp.set(0,1,0);const t=Math.random()*this.rangeTheta+this.offsetTheta,i=Math.random()*this.rangePhi+this.offsetPhi,r=Math.cos(t),a=Math.sin(t),n=Math.cos(i),s=Math.sin(i);e.set(r,0,-a),e.multiplyScalar(n),this.tempUp.multiplyScalar(s),e.add(this.tempUp),e.normalize();const o=Math.random()*this.rangeRadius+this.offsetRadius;e.multiplyScalar(o),e.x*=this.scaleX,e.y*=this.scaleY,e.z*=this.scaleZ,e.x+=this.offsetX,e.y+=this.offsetY,e.z+=this.offsetZ}clone(){return new ct(this.rangeTheta,this.offsetTheta,this.rangePhi,this.offsetPhi,this.rangeRadius,this.offsetRadius,this.scaleX,this.scaleY,this.scaleZ,this.offsetX,this.offsetY,this.offsetZ)}static fromJSON(e){return new ct(e.rangeTheta,e.offsetTheta,e.rangePhi,e.offsetPhi,e.rangeRadius,e.offsetRadius,e.scaleX,e.scaleY,e.scaleZ,e.offsetX,e.offsetY,e.offsetZ)}toJSON(e){return{type:e.getTypePath(ct),params:{rangeTheta:this.rangeTheta,offsetTheta:this.offsetTheta,rangePhi:this.rangePhi,offsetPhi:this.offsetPhi,rangeRadius:this.rangeRadius,offsetRadius:this.offsetRadius,scaleX:this.scaleX,scaleY:this.scaleY,scaleZ:this.scaleZ,offsetX:this.offsetX,offsetY:this.offsetY,offsetZ:this.offsetZ}}}}class ut{constructor(){}}class ht extends ut{constructor(e,t,i,r,a,n,s=void 0){super(),this.owner=null,this.light=null,this.lastUpdateTime=performance.now()/1e3,this.lastIntensityFlickerTime=this.lastUpdateTime,this.lastPositionFlickerTime=this.lastUpdateTime,this.lastIntensityAdjuster=1,this.nextIntensityAdjuster=1,this.lastPositionAdjuster=new Te.Vector3,this.positionAdjuster=new Te.Vector3,this.intensity=1,this.intensityFlux=2,this.parent=e,this.init(e,t,i,r,a,n,s)}init(e,t,i,r,a,n,s=void 0){this.owner=new Te.Object3D,e.add(this.owner),r=r||new Te.Color,a=a||0,null!=n&&null!=n||(n=2);const o=!!s;return this.light=new Te.PointLight(16777215,2,0,1),this.light.color.copy(r),this.light.distance=a,this.light.decay=n,this.light.castShadow=o,o&&(this.light.shadow.mapSize.width=s.mapSize||512,this.light.shadow.mapSize.height=s.mapSize||512,this.light.shadow.camera.near=s.cameraNear||.5,this.light.shadow.camera.far=s.cameraFar||500,this.light.shadow.bias=s.bias||1e-4,this.light.shadow.radius=s.edgeRadius||1),this.owner.add(this.light),this.intensity=t,this.intensityFlux=i,this.light}dispose(){this.parent.remove(this.owner)}getLight(){return this.light}setIntensity(e){this.intensity=e}update(e){const t=e-this.lastIntensityFlickerTime,i=1/8,r=this.intensityFlux;if(t>i){this.lastIntensityFlickerTime=e;let t=1+2*(Math.random()-.5)*r*i;const a=t-this.lastIntensityAdjuster;t=this.lastIntensityAdjuster+a,this.lastIntensityAdjuster=this.nextIntensityAdjuster,this.nextIntensityAdjuster=Ne.clamp(t,.25,1.5)}else{const e=t/i,r=(1-e)*this.lastIntensityAdjuster+e*this.nextIntensityAdjuster;this.light.intensity=r*this.intensity}if(e-this.lastPositionFlickerTime>.0625){this.lastPositionFlickerTime=e;const t=e-this.lastUpdateTime;this.positionAdjuster.set(Math.random()-.5,Math.random()-.5,Math.random()-.5),this.positionAdjuster.multiplyScalar(t),this.positionAdjuster.add(this.lastPositionAdjuster),this.positionAdjuster.multiplyScalar(.5),this.owner.position.copy(this.positionAdjuster),this.lastPositionAdjuster.copy(this.positionAdjuster),this.lastUpdateTime=e}}}class dt{constructor(){this.jsonTypes={default:{}},this.jsonTypeNames={},this.typeIDGen=0}addType(e,t){this.addTypeToNamespace("default",e,t)}addTypeToNamespace(e,t,i){if(!this.jsonTypes[e])throw new Error("JSONTypeStore::addTypeToNamespace() -> namespace does not exist");if(this.jsonTypes[e][t])throw new Error("JSONTypeStore::addTypeToNamespace() -> typeName already exists");this.checkAndAddTypeName(i,t,e)&&(this.jsonTypes[e][t]=i)}addNamespace(e,t){if(this.jsonTypes[e])throw new Error("JSONTypeStore::addNamespace() -> namespace already exists");this.jsonTypes[e]=t;for(const i in t)if(!t.hasOwnProperty||t.hasOwnProperty(i)){const r=t[i];this.checkAndAddTypeName(r,i,e)}}checkAndAddTypeName(e,t,i){if("function"==typeof e){const r=this.typeIDGen++;e.___photonsTypeID=r,this.jsonTypeNames[r]={namespace:i,typeName:t}}}getType(e,t){if(!this.jsonTypes[e])throw new Error("JSONTypeStore::getType() -> namespace does not exist");if(!this.jsonTypes[e][t])throw new Error("JSONTypeStore::getType() -> typeName does not exist");return this.jsonTypes[e][t]}getTypeNames(e){return this.jsonTypeNames[e.___photonsTypeID]}getTypePath(e){const t=this.getTypeNames(e);if(t)return`${t.namespace}.${t.typeName}`}parseNamespaceAndTypename(e){const t=e.split("."),i=t[0];t.splice(0,1);return{namespace:i,typeName:t.join(".")}}parseTypeString(e){const{namespace:t,typeName:i}=this.parseNamespaceAndTypename(e);return this.getType(t,i)}}const pt=Object.freeze(Object.defineProperty({__proto__:null,AccelerationOperator:lt,AnimatedSpriteRenderer:Xe,Atlas:We,BaseParticleStateInitializer:Ee,BaseParticleStateOperator:Oe,BoxPositionInitializer:Ke,ColorInterpolatorOperator:ot,ConstantParticleEmitter:Je,FlickerLight:ht,JSONTypeStore:dt,LifetimeInitializer:Ze,Manager:Be,OpacityInterpolatorOperator:nt,ParticleStateArray:Ae,ParticleSystem:Ue,ParticleSystemState:Me,RandomGenerator:Ye,RandomVelocityInitializer:et,Renderer:qe,RotationInitializer:He,RotationalSpeedInitializer:$e,SequenceInitializer:tt,SequenceOperator:it,SizeInitializer:Qe,SizeInterpolatorOperator:st,SphereRandomGenerator:ct},Symbol.toStringTag,{value:"Module"})),{defineComponent:mt}=await e("vue"),{openBlock:ft,createElementBlock:gt}=await e("vue"),St=await e("three"),{watch:yt,onUnmounted:wt,computed:vt,useAttrs:xt}=await e("vue"),Pt=mt({__name:"fireF",props:{hasPointLight:{type:Boolean,default:!0},flickerLightIntensity:{default:2},flickerLightIntensityFlux:{default:.4},flickerLightColor:{default:"#f5d26b"},isEditor:{type:Boolean,default:!1}},setup(e,{expose:t}){const a=e;function n(e,t=[0,0,0]){if("number"==typeof e)return[e,e,e];if(Array.isArray(e)){const[t=0,i=0,r=0]=e;return[t,i,r]}if(e&&"object"==typeof e){const{x:t=0,y:i=0,z:r=0}=e;return[t,i,r]}return t}const s=xt(),o=vt(()=>s.position?new St.Vector3(...n(s.position)):new St.Vector3(0,0,0)),l=vt(()=>s.scale?n(s.scale)[0]:1),c=new Be,u=new dt;u.addNamespace("THREE",St),u.addNamespace("Photons",pt);const{renderer:h,camera:d,scene:p}=r();let m=null,f=null;const g=e=>{m=new St.Object3D,window.globalTvtExtendMeshScenes?window.globalTvtExtendMeshScenes.add(m):p.value.add(m),m.position.copy(e);return f=new ht(m,a.flickerLightIntensity,a.flickerLightIntensityFlux,(new St.Color).set(a.flickerLightColor),0,1,{mapSize:1024,cameraNear:.1,cameraFar:5e3,bias:9e-6,edgeRadius:3}),f},S=()=>{const e=new St.Vector3(...o.value);c.addParticleSystem(((e,t)=>{const i=new St.Object3D;i.position.copy(t);const r="./plugins/digitalCity/image/fireF/ember.png",a=(new St.TextureLoader).load(r),n=new We(a,r);n.addFrameSet(1,0,0,1,1);const s=new Xe(!0,n,!0,1),o=new Ue(i,s);o.init(150),o.setEmitter(new Je(6));const l=new Ye(St.Vector2,new St.Vector2(0,0),new St.Vector2(.15*e,.15*e),0,0,!1);o.addParticleStateInitializer(new Ze(3,1,0,0,!1)),o.addParticleStateInitializer(new Qe(l)),o.addParticleStateInitializer(new Ke(new St.Vector3(.05*e,0,.05*e),new St.Vector3(-.025*e,0,-.025*e))),o.addParticleStateInitializer(new et(new St.Vector3(.4*e,.5*e,.4*e),new St.Vector3(-.2*e,.8*e,-.2*e),.6*e,.8*e,!1)),o.addParticleStateOperator(new nt).addElements([[0,0],[.7,.25],[.9,.75],[0,1]]),o.addParticleStateOperator(new ot(!0)).addElementsFromParameters([[[1,.7,0],0],[[1,.6,0],.5],[[1,.4,0],1]]);const c=new ct(2*Math.PI,0,Math.PI,-Math.PI/2,20,-8,e,e,e,0,0,0);return o.addParticleStateOperator(new lt(c)),o.setSimulateInWorldSpace(!0),o.start(),o})(l.value,e)),c.addParticleSystem(((e,t)=>{const i=new St.Object3D;i.position.copy(t);const r="./plugins/digitalCity/image/fireF/base_flame.png",a=(new St.TextureLoader).load(r),n=new We(a,r);n.addFrameSet(18,0,0,.125,.25);const s=new Xe(!0,n,!0),o=new Ue(i,s);o.init(50),o.setEmitter(new Je(10)),o.addParticleSequence(0,18);const l=o.getParticleSequences();return o.addParticleStateInitializer(new Ze(0,0,0,0,!1)),o.addParticleStateInitializer(new He(new Ye(0,Math.PI/2,-Math.PI/2,0,0,!1))),o.addParticleStateInitializer(new $e(1,-1,0,0,!1)),o.addParticleStateInitializer(new Qe(new Ye(St.Vector2,new St.Vector2(.25*e,.25*e),new St.Vector2(.5*e,.5*e),0,0,!1))),o.addParticleStateInitializer(new Ke(new St.Vector3(.05*e,0,.05*e),new St.Vector3(-.025*e,0,-.025*e))),o.addParticleStateInitializer(new et(new St.Vector3(.05*e,.4*e,.05*e),new St.Vector3(-.025*e,.8*e,-.025*e),.35*e,.5*e,!1)),o.addParticleStateInitializer(new tt(l)),o.addParticleStateOperator(new it(l,.07,!1)),o.addParticleStateOperator(new nt).addElements([[0,0],[.3,.25],[.3,.5],[0,1]]),o.addParticleStateOperator(new st(!0)).addElementsFromParameters([[[.6,.6],0],[[1,1],.4],[[1,1],1]]),o.addParticleStateOperator(new ot(!0)).addElementsFromParameters([[[1,1,1],0],[[1.5,1.5,1.5],.5],[[1,1,1],1]]),o.addParticleStateOperator(new lt(new Ye(St.Vector3,new St.Vector3(0,0,0),new St.Vector3(0,1.5*e,0),0,0,!1))),o.setSimulateInWorldSpace(!0),o.start(),o})(l.value,e)),c.addParticleSystem(((e,t)=>{const i=new St.Object3D;i.position.copy(t);const r="./plugins/digitalCity/image/fireF/bright_flame.png",a=(new St.TextureLoader).load(r),n=new We(a,r);n.addFrameSet(16,0,0,212/1024,.25);const s=new Xe(!0,n,!0),o=new Ue(i,s);o.init(20),o.setEmitter(new Je(5)),o.addParticleSequence(0,16);const l=o.getParticleSequences();return o.addParticleStateInitializer(new Ze(0,0,0,0,!1)),o.addParticleStateInitializer(new He(new Ye(0,Math.PI,-Math.PI/2,0,0,!1))),o.addParticleStateInitializer(new $e(Math.PI/2,-Math.PI/4,0,0,!1)),o.addParticleStateInitializer(new Qe(new Ye(St.Vector2,new St.Vector2(0,0),new St.Vector2(0,0),.2*e,.65*e,!1))),o.addParticleStateInitializer(new Ke(new St.Vector3(.1*e,0,.1*e),new St.Vector3(-.05*e,0,-.05*e))),o.addParticleStateInitializer(new et(new St.Vector3(.02*e,.4*e,.02*e),new St.Vector3(-.01*e,.4*e,-.01*e),.1*e,.2*e,!1)),o.addParticleStateInitializer(new tt(l)),o.addParticleStateOperator(new it(l,.1,!1)),o.addParticleStateOperator(new nt).addElements([[0,0],[.6,.2],[.5,.75],[0,1]]),o.addParticleStateOperator(new st(!0)).addElementsFromParameters([[[.3,.3],0],[[1,1],.4],[[1,1],.55],[[.65,.65],.75],[[.1,.1],1]]),o.addParticleStateOperator(new ot(!0)).addElementsFromParameters([[[1,1,1],0],[[2,2,2],.3],[[2,2,2],.4],[[.9,.6,.3],.65],[[.75,0,0],1]]),o.addParticleStateOperator(new lt(new Ye(St.Vector3,new St.Vector3(0,0,0),new St.Vector3(0,1.5*e,0),0,0,!1))),o.setSimulateInWorldSpace(!0),o.start(),o})(l.value,e)),a.hasPointLight&&c.addComponent(g(e))};S();const y=()=>{for(const e of c.particleSystems)e.particleSystemRenderer.dispose();c.particleSystems=[],m&&(window.globalTvtExtendMeshScenes?window.globalTvtExtendMeshScenes.remove(m):p.value.remove(m),f=null)};wt(()=>{y()}),yt(()=>a.hasPointLight,e=>{e?f||c.addComponent(g(new St.Vector3(...o.value))):f&&(f.dispose(),window.globalTvtExtendMeshScenes?window.globalTvtExtendMeshScenes.remove(m):p.value.remove(m),f=null,c.componentContainer.components=[])},{immediate:!0}),yt(()=>[s.scale,s.position],([e,t],[i,r])=>{JSON.stringify(e)===JSON.stringify(i)&&JSON.stringify(t)===JSON.stringify(r)||(y(),S())},{deep:!0}),yt(()=>[a.flickerLightIntensity,a.flickerLightIntensityFlux,a.flickerLightColor],()=>{f&&(console.log("update light"),f.intensity=a.flickerLightIntensity,f.intensityFlux=a.flickerLightIntensityFlux,f.light.color.set(a.flickerLightColor))});const w=()=>{c.update(),c.render(h,d.value)};if(!a.isEditor){const{onRender:e}=i();e(()=>{w()})}return t({curRender:w}),(e,t)=>(ft(),gt("TresGroup"))}}),{defineComponent:Tt}=await e("vue"),{createElementVNode:Ct,normalizeProps:bt,guardReactiveProps:At,openBlock:It,createElementBlock:Vt}=await e("vue"),zt={renderOrder:9999},Et=["rotation"],Ft=["args"],Ot=["rotation"],Nt=["args"],Rt=await e("three"),{watchEffect:Mt}=await e("vue"),Ut=Tt({__name:"rectangleGlow",props:{w:{default:100},h:{default:100},pColor:{default:"#ffff00"},gradientWidth:{default:.99},glowWidth:{default:.99},nNumber:{default:8},lineWidth:{default:2},lColor:{default:"#ffff00"}},setup(e){const t=e,i={vertexShader:"\n \t\tvarying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    varying vec2 vUv;\n\t\tuniform vec3 color;\n\t\tuniform float gradientWidth;\n\t\tuniform float glowWidth;\n\t\tuniform float nNumber;\n\n    void main() {\n \t\t\tfloat distX = abs(vUv.x - 0.5) / 0.5;\n      float distY = abs(vUv.y - 0.5) / 0.5;\n\n      //  Minkowski  +  + \n      float dist = pow(pow(distX, nNumber) + pow(distY, nNumber), 1.0 / nNumber);\n\n      float cutoff = 1.0 - gradientWidth;\n  \t\tfloat alpha = smoothstep(cutoff, cutoff + glowWidth, dist);\n\n      gl_FragColor = vec4(color, alpha);\n    }\n  ",transparent:!0,side:Rt.DoubleSide,depthWrite:!1,depthTest:!0,uniforms:{color:{type:"uvs",value:new Rt.Color(t.pColor)},gradientWidth:{type:"f",value:t.gradientWidth},glowWidth:{type:"f",value:t.glowWidth},nNumber:{type:"f",value:t.nNumber}}},r={transparent:!0,side:Rt.DoubleSide,depthWrite:!1,depthTest:!0,uniforms:{borderWidth:{value:t.lineWidth},borderColor:{value:new Rt.Color(t.lColor)},size:{value:new Rt.Vector2(t.w,t.h)}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    uniform float borderWidth;\n    uniform vec3 borderColor;\n    varying vec2 vUv;\n\t\tuniform vec2 size;\n\n    void main() {\n\t\t \tfloat borderX = borderWidth / size.x;\n  \t\tfloat borderY = borderWidth / size.y;\n\n      float left   = step(vUv.x, borderX);\n      float right  = step(1.0 - borderX, vUv.x);\n      float bottom = step(vUv.y, borderY);\n      float top    = step(1.0 - borderY, vUv.y);\n\n      float edge = max(max(left, right), max(bottom, top)); // \n      float alpha = edge;\n\n      gl_FragColor = vec4(borderColor, alpha);\n    }\n  "};return Mt(()=>{i.uniforms.color.value=new Rt.Color(t.pColor),i.uniforms.gradientWidth.value=t.gradientWidth,i.uniforms.glowWidth.value=t.glowWidth,i.uniforms.nNumber.value=t.nNumber,r.uniforms.borderColor.value=new Rt.Color(t.lColor),r.uniforms.borderWidth.value=t.lineWidth,r.uniforms.size.value.set(t.w,t.h)}),(e,t)=>(It(),Vt("TresGroup",zt,[Ct("TresMesh",{rotation:[Math.PI/2,0,0]},[Ct("TresPlaneGeometry",{args:[e.w,e.h]},null,8,Ft),Ct("TresShaderMaterial",bt(At(i)),null,16)],8,Et),Ct("TresMesh",{rotation:[Math.PI/2,0,0]},[Ct("TresPlaneGeometry",{args:[e.w+e.lineWidth,e.h+e.lineWidth]},null,8,Nt),Ct("TresShaderMaterial",bt(At(r)),null,16)],8,Ot)]))}}),{defineComponent:Bt}=await e("vue"),{unref:qt,createElementVNode:Dt,normalizeProps:_t,guardReactiveProps:Wt,openBlock:Xt,createElementBlock:jt}=await e("vue"),kt=["position","uv"],Jt=await e("three"),{watchEffect:Lt,ref:Gt,watch:Yt}=await e("vue"),Zt=Bt({__name:"wave",props:{positionSrc:{default:[{x:0,y:0},{x:10,y:10}]},color:{default:"#ffff00"},opacity:{default:.8},height:{default:100},frequencyNum:{default:8},speed:{default:1}},setup(e){const t=e,r=Gt(),a={side:Jt.DoubleSide,transparent:!0,depthWrite:!1,depthTest:!0,vertexShader:"\nvarying vec2 vUv; \nvoid main(){\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n}\n",fragmentShader:"\n\tuniform float uTime;\n\tvarying vec2 vUv;\n\t#define PI 3.14159265\n  uniform float speed;\n  uniform vec3 color;\n  uniform float opacity;\n  uniform float frequencyNum;\n\tvoid main(){\n\t\t\t\n\tfloat amplitude = 1.;\n\n\tfloat x = vUv.x;\n\tfloat y = sin(x * frequencyNum) ;\n\tfloat t = 0.01*(-uTime*130.0*speed);\n\ty += sin(x*frequencyNum*2.1 + t)*4.5;\n\ty += sin(x*frequencyNum*1.72 + t*1.121)*4.0;\n\ty += sin(x*frequencyNum*2.221 + t*0.437)*5.0;\n\ty += sin(x*frequencyNum*3.1122+ t*4.269)*2.5;\n\ty *= amplitude*0.06;\n\ty /= 3.;\n\ty += 0.55;\n\n\tfloat ap = step(vUv.y,y) * (y-vUv.y)/y;\n\n\tgl_FragColor = vec4(color,ap*opacity);\n}\n\t",uniforms:{uTime:{type:"pv2",value:0},color:{type:"uvs",value:new Jt.Color(t.color)},opacity:{type:"pv2",value:t.opacity},frequencyNum:{type:"pv2",value:t.frequencyNum},speed:{type:"pv2",value:t.speed}}};let n=null,s=null;function o(e=[],t){const i=[],r=[];for(let a=0,n=i.length,s=r.length;a<e.length-1;a++){let o=1,l=e[a],c=e[a+1];i[n++]=l.x,i[n++]=0,i[n++]=l.y,r[s++]=0,r[s++]=0,i[n++]=c.x,i[n++]=0,i[n++]=c.y,r[s++]=1,r[s++]=0,i[n++]=l.x,i[n++]=t,i[n++]=l.y,r[s++]=0,r[s++]=o,i[n++]=l.x,i[n++]=t,i[n++]=l.y,r[s++]=0,r[s++]=o,i[n++]=c.x,i[n++]=0,i[n++]=c.y,r[s++]=1,r[s++]=0,i[n++]=c.x,i[n++]=t,i[n++]=c.y,r[s++]=1,r[s++]=o}n=new Float32Array(i),s=new Float32Array(r)}const{centerPoint:l,points:u}=c(t.positionSrc);o(u,t.height);const{onBeforeRender:h}=i();return h(({delta:e})=>{a.uniforms.uTime.value+=e}),Lt(()=>{t.color&&(a.uniforms.color.value=new Jt.Color(t.color)),t.opacity&&(a.uniforms.opacity.value=t.opacity),t.frequencyNum&&(a.uniforms.frequencyNum.value=t.frequencyNum),t.speed&&(a.uniforms.speed.value=t.speed),r.value&&r.value.position.set(l.x,r.value.position.y,l.y)}),Yt(()=>t.height,e=>{o(u,t.height),r.value&&r.value.position.set(l.x,r.value.position.y,l.y)}),(e,t)=>(Xt(),jt("TresMesh",{renderOrder:2200,ref_key:"tresMeshRef",ref:r},[Dt("TresBufferGeometry",{position:[qt(n),3],uv:[qt(s),2]},null,8,kt),Dt("TresShaderMaterial",_t(Wt(a)),null,16)],512))}}),{withAsyncContext:Ht,defineComponent:$t}=await e("vue"),{unref:Kt,renderList:Qt,Fragment:ei,openBlock:ti,createElementBlock:ii,createElementVNode:ri}=await e("vue"),ai=["args"],ni=["map","side","color"],{watch:si}=await e("vue"),{CatmullRomCurve3:oi,Vector3:li,RepeatWrapping:ci,DoubleSide:ui}=await e("three"),hi=$t({__name:"roadLightByLonLat",props:{geoJson:{},color:{default:"#ffff00"},radius:{default:2},speed:{default:1}},async setup(e){let t,r;const n=e,{state:s}=a("./plugins/digitalCity/image/line.png");si(s,e=>{e&&(e.needsUpdate=!0,e.wrapS=e.wrapT=ci,e.repeat.set(1,1))});const o=([t,r]=Ht(()=>u(n.geoJson)),t=await t,r(),t);let l=[];for(let i=0;i<o.length;i++){const e=o[i],t=[];e.geometry.coordinates.forEach(e=>{const i=h(e[0],e[1],50);t.push(new li(i[0],0,-i[1]))});let r=n.color;r="primary"===e.properties.highway?"#7eff10":"tertiary"===e.properties.highway?"#0eeeee":"secondary"===e.properties.highway?"#ffffff":"#ff0ffe",l.push({cr3:new oi(t),color:r})}const{onBeforeRender:c}=i();return c(()=>{s.value&&(s.value.offset.x-=Math.random()/20*n.speed)}),(e,t)=>(ti(),ii("TresGroup",null,[(ti(!0),ii(ei,null,Qt(Kt(l),(e,t)=>(ti(),ii("TresMesh",{key:t,renderOrder:3e3},[ri("TresTubeGeometry",{args:[e.cr3,64,n.radius,20,!1]},null,8,ai),ri("TresMeshBasicMaterial",{map:Kt(s),side:Kt(ui),transparent:!0,color:e.color},null,8,ni)]))),128))]))}}),{defineComponent:di}=await e("vue"),{createElementVNode:pi,unref:mi,withCtx:fi,createVNode:gi,openBlock:Si,createElementBlock:yi}=await e("vue"),wi=["rotateX"],vi=["rotateX","position"],xi=["args"],Pi=["map","depthTest","side","color"],Ti=["rotateX","position"],Ci=["args"],bi=["map","depthTest","side","color"],{ref:Ai}=await e("vue"),Ii=await e("three"),Vi=di({__name:"coneAnchorMeshA",props:{height:{default:40},color:{default:"#b0ffff"},occlusion:{type:Boolean,default:!0},speed:{default:.05}},setup(e){const t=e,r=Ai(),{onBeforeRender:a}=i();return a(()=>{r.value?.rotateZ(t.speed)}),(e,t)=>(Si(),yi("TresGroup",{rotateX:-Math.PI/2,ref_key:"coneGroup",ref:r,renderOrder:1e4},[gi(mi(n),{path:"./plugins/digitalCity/image/midGradient.png"},{default:fi(({state:t})=>[pi("TresMesh",{rotateX:Math.PI/2,position:[0,0,1.25*e.height],"scale-y":.5},[pi("TresConeGeometry",{args:[15,e.height,4,1,!0]},null,8,xi),pi("TresMeshLambertMaterial",{map:t,transparent:!0,depthTest:e.occlusion,side:Ii.DoubleSide,color:e.color,depthWrite:!0},null,8,Pi)],8,vi),pi("TresMesh",{rotateX:-Math.PI/2,position:[0,0,e.height/2]},[pi("TresConeGeometry",{args:[15,e.height,4,1,!0]},null,8,Ci),pi("TresMeshLambertMaterial",{map:t,transparent:!0,depthTest:e.occlusion,side:Ii.DoubleSide,color:e.color,depthWrite:!0},null,8,bi)],8,Ti)]),_:1})],8,wi))}}),{withAsyncContext:zi,defineComponent:Ei}=await e("vue"),{unref:Fi,createElementVNode:Oi,openBlock:Ni,createElementBlock:Ri}=await e("vue"),Mi=["rotateX"],Ui=["object"],Bi=["args"],qi=["color","depthTest","map"],{ref:Di,watch:_i}=await e("vue"),Wi=await e("three"),Xi=Ei({__name:"coneAnchorMeshB",props:{anchorColor:{default:"#b0ffff"},rotateSpeed:{default:.05},depthTest:{type:Boolean,default:!0},floorSize:{default:12},floorColor:{default:"#b0ffff"},floorSpeed:{default:.6}},async setup(e){let t,r;const a=e,{scene:n}=([t,r]=zi(()=>d("./plugins/digitalCity/model/coneAnchorB.glb")),t=await t,r(),t),s=n?.clone(),l=s.children[0].material.clone();l.color.set(a.anchorColor),l.metalness=0,l.roughness=.5,l.transparent=!0,l.opacity=1,l.depthTest=a.depthTest,s.children[0].renderOrder=0,s.children[0].material=l;const c=([t,r]=zi(()=>o("./plugins/digitalCity/image/waveCircle.png")),t=await t,r(),t),{width:u,height:h}=c.image;c.wrapS=c.wrapT=Wi.RepeatWrapping,c.repeat.set(1/(u/h),1),_i(()=>[a.anchorColor,a.depthTest],([e,t])=>{l.color.set(e),l.depthTest=t});const p=Di(null),{onRender:m}=i();let f=0;return m(()=>{p.value?.children[0].rotateZ(a.rotateSpeed),c&&(f+=a.floorSpeed,c.offset.x=Math.floor(f)/(c.image.width/c.image.height))}),(e,t)=>(Ni(),Ri("TresGroup",null,[Oi("TresGroup",{rotateX:-Math.PI/2,ref_key:"coneGroup",ref:p},[Oi("primitive",{object:Fi(s)},null,8,Ui),Oi("TresMesh",null,[Oi("TresCircleGeometry",{args:[e.floorSize,32]},null,8,Bi),Oi("TresMeshStandardMaterial",{color:e.floorColor,metalness:0,roughness:.6,transparent:"",opacity:.8,depthTest:a.depthTest,depthWrite:!1,map:Fi(c)},null,8,qi)])],8,Mi)]))}});export{Vi as _sfc_main,Xi as _sfc_main$1,X as _sfc_main$2,E as _sfc_main$3,Zt as _sfc_main$4,pe as _sfc_main$5,Pe as _sfc_main$6,Pt as _sfc_main$7,Ut as _sfc_main$8,hi as _sfc_main$9};
