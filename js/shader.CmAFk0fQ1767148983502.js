import{importShared as L}from"./3d-tiles-renderer.DZNovkLO1767148983502.js";import{_l as Se,Fs as Be,Kk as _e,sz as be,Tz as Te}from"./index.DTe2qqjO1767148983502.js";import{Pane as xe}from"./tweakpane.BQRZXf8M1767148983502.js";/**
 * @description Loop Subdivision Surface
 * @about       Smooth subdivision surface modifier for use with three.js BufferGeometry.
 * @author      Stephens Nunnally <@stevinz>
 * @license     MIT - Copyright (c) 2022 Stephens Nunnally
 * @source      https://github.com/stevinz/three-subdivide
 */const w=await L("three"),Me=2,R=new w.Vector3,_=new w.Vector3,V=new w.Vector3,fe=new w.Vector3,ae=new w.Vector3,g=new w.Vector3,v=new w.Vector3,b=new w.Vector3,Y=new w.Vector3,Z=new w.Vector3,ee=new w.Vector3,ie=[new w.Vector3,new w.Vector3,new w.Vector3],T=[new w.Vector3,new w.Vector3,new w.Vector3],Ve=new w.Triangle;class j{static modify(e,t=1,n={}){if(arguments.length>3&&console.warn("LoopSubdivision.modify() now uses a parameter object. See readme for more info!"),typeof n!="object"&&(n={}),n.split===void 0&&(n.split=!0),n.uvSmooth===void 0&&(n.uvSmooth=!1),n.preserveEdges===void 0&&(n.preserveEdges=!1),n.flatOnly===void 0&&(n.flatOnly=!1),n.maxTriangles===void 0&&(n.maxTriangles=1/0),n.weight===void 0&&(n.weight=1),(isNaN(n.weight)||!isFinite(n.weight))&&(n.weight=1),n.weight=Math.max(0,Math.min(1,n.weight)),!re(e))return e;let f=e.clone();if(n.split){const u=j.edgeSplit(f);f.dispose(),f=u}for(let u=0;u<t;u++)if(f.attributes.position.count/3<n.maxTriangles){let p;n.flatOnly?p=j.flat(f,n):p=j.smooth(f,n),f.groups.forEach(l=>{p.addGroup(l.start*4,l.count*4,l.materialIndex)}),f.dispose(),f=p}return f}static edgeSplit(e){if(!re(e))return e;const t=e.index!==null?e.toNonIndexed():e.clone(),n=new w.BufferGeometry,f=de(t),u=t.attributes.position.count,h=t.getAttribute("position"),p=t.getAttribute("normal"),l={},S=[],x={},E=[];for(let m=0;m<u;m+=3){g.fromBufferAttribute(h,m+0),v.fromBufferAttribute(h,m+1),b.fromBufferAttribute(h,m+2),fe.fromBufferAttribute(p,m);const C=k(g),M=k(v),$=k(b),W=Ve.set(g,v,b).getArea();if(E.push(!Ce(W,0)),!E[m/3]){S.push([]);continue}ze(fe,g,v,b);const o=k(fe),s=[`${C}_${M}_${o}`,`${M}_${C}_${o}`,`${M}_${$}_${o}`,`${$}_${M}_${o}`,`${$}_${C}_${o}`,`${C}_${$}_${o}`],d=m/3;for(let a=0;a<s.length;a++)l[s[a]]||(l[s[a]]=[]),l[s[a]].push(d),x[s[a]]||((a===0||a===1)&&(x[s[a]]=g.distanceTo(v)),(a===2||a===3)&&(x[s[a]]=v.distanceTo(b)),(a===4||a===5)&&(x[s[a]]=b.distanceTo(g)));S.push([s[0],s[2],s[4]])}f.forEach(m=>{const C=t.getAttribute(m);if(!C)return;const M=Q(C,m);n.setAttribute(m,new w.BufferAttribute(M,C.itemSize))});const I=t.morphAttributes;for(const m in I){const C=[],M=I[m];for(let $=0,W=M.length;$<W;$++){if(M[$].count!==u)continue;const o=Q(M[$],m,!0);C.push(new w.BufferAttribute(o,M[$].itemSize))}n.morphAttributes[m]=C}return n.morphTargetsRelative=t.morphTargetsRelative,t.dispose(),n;function Q(m,C,M=!1){const W=u*m.itemSize*4,o=new m.array.constructor(W),s=C==="position"&&!M&&t.groups.length>0;let d,a,r=0,N=0,i=m.itemSize;for(let B=0;B<u;B+=3){if(!E[B/3]){N+=3;continue}g.fromBufferAttribute(m,B+0),v.fromBufferAttribute(m,B+1),b.fromBufferAttribute(m,B+2);const G=B/3,z=S[G][0],O=S[G][1],q=S[G][2],F=l[z].length,U=l[O].length,P=l[q].length,K=F+U+P-3,J=r*3/i/3;if(K===0)A(o,r,i,g,v,b),r+=i*3;else{const oe=x[z],ge=x[O],ve=x[q];(oe>ge||U<=1)&&(oe>ve||P<=1)&&F>1?(_.copy(g).add(v).divideScalar(2),P>1?(V.copy(b).add(g).divideScalar(2),A(o,r,i,g,_,V),r+=i*3,A(o,r,i,_,b,V),r+=i*3):(A(o,r,i,g,_,b),r+=i*3),U>1?(V.copy(v).add(b).divideScalar(2),A(o,r,i,_,v,V),r+=i*3,A(o,r,i,V,b,_),r+=i*3):(A(o,r,i,v,b,_),r+=i*3)):(ge>ve||P<=1)&&U>1?(_.copy(v).add(b).divideScalar(2),F>1?(V.copy(g).add(v).divideScalar(2),A(o,r,i,_,V,v),r+=i*3,A(o,r,i,V,_,g),r+=i*3):(A(o,r,i,v,_,g),r+=i*3),P>1?(V.copy(b).add(g).divideScalar(2),A(o,r,i,_,b,V),r+=i*3,A(o,r,i,V,g,_),r+=i*3):(A(o,r,i,b,g,_),r+=i*3)):P>1?(_.copy(b).add(g).divideScalar(2),U>1?(V.copy(v).add(b).divideScalar(2),A(o,r,i,b,_,V),r+=i*3,A(o,r,i,_,v,V),r+=i*3):(A(o,r,i,b,_,v),r+=i*3),F>1?(V.copy(g).add(v).divideScalar(2),A(o,r,i,g,V,_),r+=i*3,A(o,r,i,V,v,_),r+=i*3):(A(o,r,i,g,v,_),r+=i*3)):(A(o,r,i,g,v,b),r+=i*3)}s&&t.groups.forEach(oe=>{oe.start===B-N&&(d!==void 0&&a!==void 0&&n.addGroup(d,J-d,a),d=J,a=oe.materialIndex)}),N=0}const y=r*3/i,D=new m.array.constructor(y);for(let B=0;B<y;B++)D[B]=o[B];return s&&d!==void 0&&a!==void 0&&n.addGroup(d,r*3/i/3-d,a),D}}static flat(e,t={}){if(!re(e))return e;const n=e.index!==null?e.toNonIndexed():e.clone(),f=new w.BufferGeometry,u=de(n),h=n.attributes.position.count;u.forEach(l=>{const S=n.getAttribute(l);S&&f.setAttribute(l,j.flatAttribute(S,h,t))});const p=n.morphAttributes;for(const l in p){const S=[],x=p[l];for(let E=0,I=x.length;E<I;E++)x[E].count===h&&S.push(j.flatAttribute(x[E],h,t));f.morphAttributes[l]=S}return f.morphTargetsRelative=n.morphTargetsRelative,n.dispose(),f}static flatAttribute(e,t,n={}){const u=t*e.itemSize*4,h=new e.array.constructor(u);let p=0,l=e.itemSize;for(let S=0;S<t;S+=3)g.fromBufferAttribute(e,S+0),v.fromBufferAttribute(e,S+1),b.fromBufferAttribute(e,S+2),Y.copy(g).add(v).divideScalar(2),Z.copy(v).add(b).divideScalar(2),ee.copy(b).add(g).divideScalar(2),A(h,p,l,g,Y,ee),p+=l*3,A(h,p,l,v,Z,Y),p+=l*3,A(h,p,l,b,ee,Z),p+=l*3,A(h,p,l,Y,Z,ee),p+=l*3;return new w.BufferAttribute(h,e.itemSize)}static smooth(e,t={}){if(typeof t!="object"&&(t={}),t.uvSmooth===void 0&&(t.uvSmooth=!1),t.preserveEdges===void 0&&(t.preserveEdges=!1),!re(e))return e;const n=e.index!==null?e.toNonIndexed():e.clone(),f=j.flat(n,t),u=new w.BufferGeometry,h=de(n),p=n.attributes.position.count,l=n.getAttribute("position"),S=f.getAttribute("position"),x={},E={},I={},Q={};function m(o,s,d){E[o]||(E[o]={}),E[o][s]||(E[o][s]=[]),E[o][s].push(d)}function C(o,s){I[o]||(I[o]=[]),I[o].push(s)}function M(o,s){Q[o]||(Q[o]=new Set),Q[o].add(s)}for(let o=0;o<p;o+=3){const s=k(T[0].fromBufferAttribute(l,o+0)),d=k(T[1].fromBufferAttribute(l,o+1)),a=k(T[2].fromBufferAttribute(l,o+2));m(s,d,o+1),m(s,a,o+2),m(d,s,o+0),m(d,a,o+2),m(a,s,o+0),m(a,d,o+1),Y.copy(T[0]).add(T[1]).divideScalar(2),Z.copy(T[1]).add(T[2]).divideScalar(2),ee.copy(T[2]).add(T[0]).divideScalar(2);const r=k(Y),N=k(Z),i=k(ee);C(r,o+2),C(N,o+0),C(i,o+1),M(s,r),M(s,i),M(d,r),M(d,N),M(a,N),M(a,i)}for(let o=0;o<f.attributes.position.count;o++){const s=k(ae.fromBufferAttribute(S,o));x[s]||(x[s]=[]),x[s].push(o)}h.forEach(o=>{const s=n.getAttribute(o),d=f.getAttribute(o);if(s===void 0||d===void 0)return;const a=W(o,s,d);u.setAttribute(o,new w.BufferAttribute(a,d.itemSize))});const $=n.morphAttributes;for(const o in $){const s=[],d=$[o];for(let a=0,r=d.length;a<r;a++){if(d[a].count!==p)continue;const N=d[a],i=j.flatAttribute(d[a],d[a].count,t),y=W(o,N,i);s.push(new w.BufferAttribute(y,i.itemSize))}u.morphAttributes[o]=s}return u.morphTargetsRelative=n.morphTargetsRelative,f.dispose(),n.dispose(),u;function W(o,s,d){const a=f.attributes.position.count*d.itemSize,r=new s.array.constructor(a);let N=0;for(let i=0;i<f.attributes.position.count;i+=3){for(let y=0;y<3;y++)if(o==="uv"&&!t.uvSmooth)T[y].fromBufferAttribute(d,i+y);else if(o==="normal"){ie[y].fromBufferAttribute(S,i+y);const D=k(ie[y]),B=x[D],G=Object.keys(B).length,z=.75/G,O=1-z*G;T[y].fromBufferAttribute(d,i+y),T[y].multiplyScalar(O),B.forEach(q=>{R.fromBufferAttribute(d,q),R.multiplyScalar(z),T[y].add(R)})}else{T[y].fromBufferAttribute(d,i+y),ie[y].fromBufferAttribute(S,i+y);const D=k(ie[y]),B=E[D],G=I[D];if(B){if(t.preserveEdges){const P=Q[D];let K=!0;for(const J of P)I[J].length%2!==0&&(K=!1);if(!K)continue}const z=Object.keys(B).length,O=1/z*(5/8-Math.pow(3/8+1/4*Math.cos(2*Math.PI/z),2)),q=1/z/z,F=Ee(q,O,t.weight),U=1-F*z;T[y].multiplyScalar(U);for(let P in B){const K=B[P];R.set(0,0,0);for(let J=0;J<K.length;J++)R.add(ae.fromBufferAttribute(s,K[J]));R.divideScalar(K.length),R.multiplyScalar(F),T[y].add(R)}}else if(G&&G.length===2){const z=G.length,O=.125,q=1-O*z;T[y].multiplyScalar(q),G.forEach(F=>{R.fromBufferAttribute(s,F),R.multiplyScalar(O),T[y].add(R)})}}A(r,N,d.itemSize,T[0],T[1],T[2]),N+=d.itemSize*3}return r}}}const Ae=Math.pow(10,Me);function Ce(c,e,t=1e-5){return c<e+t&&c>e-t}function ue(c,e=Ae){let t=$e(c*e);return t==0&&(t=0),`${t}`}function k(c,e=Ae){return`${ue(c.x,e)},${ue(c.y,e)},${ue(c.z,e)}`}function Ee(c,e,t){return(1-t)*c+t*e}function $e(c){return c+(c>0?.5:-.5)<<0}function ze(c,e,t,n){ae.subVectors(e,t),c.subVectors(t,n),c.cross(ae).normalize()}function de(c){const e=["position","normal","uv"],t=Object.keys(c.attributes);return Array.from(new Set(e.concat(t)))}function A(c,e,t,n,f,u){t>=1&&(c[e+0+t*0]=n.x,c[e+0+t*1]=f.x,c[e+0+t*2]=u.x),t>=2&&(c[e+1+t*0]=n.y,c[e+1+t*1]=f.y,c[e+1+t*2]=u.y),t>=3&&(c[e+2+t*0]=n.z,c[e+2+t*1]=f.z,c[e+2+t*2]=u.z),t>=4&&(c[e+3+t*0]=n.w,c[e+3+t*1]=f.w,c[e+3+t*2]=u.w)}function re(c){return c===void 0?(console.warn("LoopSubdivision: Geometry provided is undefined"),!1):c.isBufferGeometry?c.attributes.position===void 0?(console.warn("LoopSubdivision: Geometry provided missing required 'position' attribute"),!1):(c.attributes.normal===void 0&&c.computeVertexNormals(),!0):(console.warn("LoopSubdivision: Geometry provided is not 'BufferGeometry' type"),!1)}const{defineComponent:ke}=await L("vue"),{normalizeProps:Ne,guardReactiveProps:Ge,createElementVNode:Re,openBlock:Ie,createElementBlock:Pe}=await L("vue"),He=["scale"],ne=await L("three"),{ref:je,watchEffect:Oe,watch:he}=await L("vue"),me=ke({__name:"shineShader",props:{srcMesh:{},scale:{default:1.2},color:{default:"#ffff00"},subdivision:{type:Boolean,default:!0},c:{default:1.1},p:{default:1.4},side:{default:ne.FrontSide},blending:{default:ne.AdditiveBlending}},setup(c){const e=c,t=je(),n={uniforms:{c:{type:"f",value:e.c},p:{type:"f",value:e.p},glowColor:{type:"c",value:new ne.Color(e.color)},viewVector:{type:"v3",value:{x:0,y:0,z:0}}},vertexShader:`
          uniform vec3 viewVector;
          uniform float c;
          uniform float p;
          varying float intensity;
          void main() {
            vec3 vNormal = normalize( normalMatrix * normal);
            vec3 vNormel = normalize( normalMatrix * viewVector);
            intensity = pow( c - dot(vNormal, vNormel), p );
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0);
          }
            `,fragmentShader:`
          uniform vec3 glowColor;
          varying float intensity;
          void main() 
          {
          	vec3 glow = glowColor * intensity;
						if(intensity < 1.0){
            	gl_FragColor = vec4( glow, 1.0 );
						}
          }
        `,side:e.side,transparent:!0,depthWrite:!1,depthTest:!0,blending:e.blending};Oe(()=>{if(e.srcMesh&&t.value&&!t.value.geometry.attributes.position){let h=e.srcMesh.geometry.clone();e.subdivision&&(h=j.modify(h,2)),t.value.geometry=h,t.value.position.copy(e.srcMesh.position)}e.color&&(n.uniforms.glowColor.value=new ne.Color(e.color)),e.c&&(n.uniforms.c.value=e.c),e.p&&(n.uniforms.p.value=e.p)}),he(()=>e.subdivision,h=>{let p=e.srcMesh.geometry.clone();h&&(p=j.modify(p,2)),t.value.geometry=p}),he(()=>e.side,h=>{t.value.material.side=h}),he(()=>e.blending,h=>{t.value.material.blending=h});const{onRender:f}=Se(),{camera:u}=Be();return f(()=>{u.value&&t.value&&(n.uniforms.viewVector.value=new ne.Vector3().subVectors(u.value.position,t.value.position))}),(h,p)=>(Ie(),Pe("TresMesh",{ref_key:"TSGref",ref:t,scale:e.scale},[Re("TresShaderMaterial",Ne(Ge(n)),null,16)],8,He))}}),{defineComponent:Fe}=await L("vue"),{createElementVNode:H,unref:se,createVNode:te,withCtx:ce,mergeProps:le,openBlock:we,createBlock:ye,createCommentVNode:Le,resolveComponent:We}=await L("vue"),De=["map"],qe=["map"],X=await L("three"),{reactive:Ke,ref:pe}=await L("vue"),Xe=Fe({__name:"shader",setup(c){const e={clearColor:"#222"},t=pe(),n=pe(),f=pe(),u=Ke({scale:1.6,color:"#00dfff",subdivision:!0,c:1.1,p:1.4,side:X.FrontSide,blending:X.AdditiveBlending}),h=new xe({title:"参数",expanded:!0});return h.addBinding(u,"color",{label:"颜色"}),h.addBinding(u,"scale",{label:"大小",min:1,max:3,step:.2}),h.addBinding(u,"subdivision",{label:"边缘处理"}),h.addBinding(u,"c",{label:"c",min:0,max:2,step:.1}),h.addBinding(u,"p",{label:"p",min:0,max:8,step:.2}),h.addBinding(u,"side",{options:{FrontSide:X.FrontSide,BackSide:X.BackSide,DoubleSide:X.DoubleSide}}),h.addBinding(u,"blending",{options:{AdditiveBlending:X.AdditiveBlending,NormalBlending:X.NormalBlending}}),(p,l)=>{const S=We("TresCanvas");return we(),ye(S,le(e,{"window-size":""}),{default:ce(()=>[l[2]||(l[2]=H("TresPerspectiveCamera",{position:[5,5,5]},null,-1)),l[3]||(l[3]=H("TresAmbientLight",{intensity:1},null,-1)),te(se(_e)),l[4]||(l[4]=H("TresGridHelper",{args:[10,10]},null,-1)),te(se(be),{path:"./plugins/earthSample/image/earthA/earth.jpg"},{default:ce(({state:x})=>[H("TresMesh",{ref_key:"TresMeshRefA",ref:t,position:[-2,1,0]},[l[0]||(l[0]=H("TresSphereGeometry",{args:[1,32,16]},null,-1)),H("TresMeshBasicMaterial",{map:x},null,8,De)],512)]),_:1}),te(me,le({srcMesh:t.value},u),null,16,["srcMesh"]),te(se(be),{path:"./logo.png"},{default:ce(({state:x})=>[te(se(Te),{ref_key:"TreBoxRef",ref:f,args:[1,1,1],position:[2,1,0]},{default:ce(()=>[H("TresMeshBasicMaterial",{map:x},null,8,qe)]),_:2},1536)]),_:1}),f.value&&f.value.instance?(we(),ye(me,le({key:0,srcMesh:f.value.instance},u),null,16,["srcMesh"])):Le("",!0),H("TresMesh",{ref_key:"TresMeshRefB",ref:n,position:[0,1,-2]},[...l[1]||(l[1]=[H("TresBoxGeometry",{args:[1,1,1,1,1]},null,-1),H("TresMeshBasicMaterial",{color:"#0ff"},null,-1)])],512),te(me,le({srcMesh:n.value},u),null,16,["srcMesh"])]),_:1},16)}}});export{Xe as default};
