import{ar as t,aL as e,b5 as a,as as o,C as r,a3 as n}from"./three.CMHPKQCP1757651394539.js";import{b as s}from"./@tresjs.DIdO2Yiu1757651394539.js";import{d as l,b as i,aa as d,w as m,G as u,o as v,I as f,a7 as p,a8 as h}from"./@vue.pEDXJ_3Z1757651394539.js";const g=["rotation-x"],c=["args"],w=l({__name:"whiteFloorMesh",props:{size:{default:[20,20]},color:{default:"#990"},shadowColor:{default:"#999"},edge:{default:.35}},async setup(l){let w,_;const x=l,$=i(),{map:C}=([w,_]=d((()=>s({map:"./plugins/floor/image/whiteFloor.jpg"}))),w=await w,_(),w);C.wrapS=C.wrapT=e;const S={uniforms:a.merge([o.lights,{uTexture:{type:"t",value:C},uColor:{value:new r(x.color)},uShadowColor:{value:new r(x.shadowColor)},fEdge:{type:"f",value:x.edge}}]),side:n,vertexShader:`\n       varying vec2 vUv;\n\t\t\t \t${t.common}\n      \t${t.bsdfs}\n      \t${t.shadowmap_pars_vertex}\n       void main() {\n\t\t\t\t\t${t.beginnormal_vertex}\n          ${t.defaultnormal_vertex}\n          ${t.begin_vertex}\n          ${t.project_vertex}\n          ${t.worldpos_vertex}\n          ${t.shadowmap_vertex}\n\n           gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    \n           vUv = uv;\n       }`,fragmentShader:`\n\tvarying vec2 vUv;\n\tuniform sampler2D uTexture;\n\tuniform vec3 uShadowColor;\n\tuniform vec3 uColor;\n\tuniform float fEdge;\n\t// ShaderMaterial 下的 纹理参数重复无效 要在着色器中增加\n\tfloat repeatTime = 100.0;\n\n\tfloat smoothsteps(float t) {\n\t\t\treturn t * t * (3.0 - 2.0 * t);\n\t}\n\n\t ${t.common}\n\t ${t.packing}\n\t ${t.bsdfs}\n\t ${t.lights_pars_begin}\n\t ${t.shadowmap_pars_fragment}\n\t ${t.shadowmask_pars_fragment}\n\n\tvoid main() {\n\t\t\tvec4 col = texture2D(uTexture, vUv * repeatTime);\n\t\t\tcol.rgb = mix( uColor , col.rgb ,0.5);\n\t\t\t\n\t\t\tfloat alpha = 1.0;\n\t\t\tfloat d = length(vUv - vec2(0.5));\n\t\t\tif(d > 0.35) {\n\t\t\t\t\talpha = 1.0 - smoothsteps( clamp( (d - 0.35) / (fEdge-0.2), 0.0, 1.0) );\n\t\t\t}\n\n\t\t vec3 addShadow = mix( uShadowColor , col.rgb ,getShadowMask());\n\n\t\t\tgl_FragColor = vec4(addShadow, alpha);  \n\t}`,lights:!0,transparent:!0};return m((()=>x.edge),(t=>{S.uniforms.fEdge.value=t})),m((()=>x.color),(t=>{S.uniforms.uColor.value=new r(x.color)})),m((()=>x.shadowColor),(t=>{S.uniforms.uShadowColor.value=new r(x.shadowColor)})),(t,e)=>(v(),u("TresMesh",{ref_key:"tmRef",ref:$,"rotation-x":-Math.PI/2},[f("TresPlaneGeometry",{args:x.size},null,8,c),f("TresShaderMaterial",p(h(S)),null,16)],8,g))}});export{w as _};
