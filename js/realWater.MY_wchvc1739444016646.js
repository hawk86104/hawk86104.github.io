import{m as n,e,a as t,o as r,f as o}from"./@tresjs.Q4_KYO2a1739444016646.js";import{P as i}from"./tweakpane.yDiyAAkA1739444016646.js";import{B as c,_ as a,c as l,l as s,aW as u,r as f}from"./three.W6GmiHfn1739444016646.js";import{d as p,a3 as v,b as g,o as d,f as x,u as h,g as m,j as y,al as w,r as b,N as C,aj as R,ak as I}from"./@vue.NRI7TcgI1739444016646.js";import"./@vueuse.6yH4xZkk1739444016646.js";var _="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const M=A;!function(n,e){const t=A,r=D();for(;;)try{if(953102===-parseInt(t(510))/1+parseInt(t(519))/2*(parseInt(t(517))/3)+-parseInt(t(479))/4+-parseInt(t(523))/5*(-parseInt(t(504))/6)+parseInt(t(514))/7*(parseInt(t(478))/8)+-parseInt(t(508))/9+parseInt(t(500))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function D(){const n=["exception","value","length","console","FrontSide","render","table","action","apply","Mesh","waterTexture",'{}.constructor("return this")( )',"debu","while (true) {}","causticTex","string","stateObject","setIndex","causticsTexture","position","25924360giPVpE","toString","chain","RawShaderMaterial","860310LQqvCQ","tiles","function *\\( *\\)","input","11252853UCTWCa","error","1401502fuQbdr","init","trace","constructor","7tMZqmz","bind","log","12kPZKrU","prototype","122418TJEPjh","pool","uniforms","BufferAttribute","60dDNHkK","call","__proto__","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","warn","6131512hczZVe","6877640faoQci"];return(D=function(){return n})()}!function(){z(this,(function(){const n=A,e=new RegExp(n(506)),t=new RegExp(n(476),"i"),r=E(n(511));e.test(r+n(502))&&t.test(r+n(507))?E():r("0")}))()}();const T=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[A(488)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function A(n,e){const t=D();return(A=function(n,e){return t[n-=474]})(n,e)}T(void 0,(function(){const n=A;let e;try{e=Function("return (function() "+n(491)+");")()}catch(o){e=window}const t=e.console=e[n(483)]||{},r=[n(516),n(477),"info",n(509),n(480),n(486),n(512)];for(let i=0;i<r.length;i++){const e=T[n(513)][n(518)].bind(T),o=r[i],c=t[o]||e;e[n(475)]=T[n(515)](T),e[n(501)]=c.toString[n(515)](c),t[o]=e}}))();const L=p({__name:M(520),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=M,o=t,i=new c,s=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),u=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i.setAttribute(r(499),new(a[r(522)])(s,3)),i[r(497)](new l(u,1));const f=new(a[r(503)])({uniforms:{light:{value:o.light},tiles:{value:o[r(505)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:a[r(484)]}),p=new(a[r(489)])(i,f),{renderer:v,camera:g}=n(),{onAfterLoop:d}=e();return d((()=>{const n=r;((n,e)=>{const t=r;f[t(521)].water.value=n,f[t(521)][t(494)][t(481)]=e,v[t(481)][t(485)](p,g.value)})(o[n(490)],o[n(498)])})),(n,e)=>null}});function E(n){function e(n){const t=A;if(typeof n===t(495))return function(n){}[t(513)](t(493))[t(488)]("counter");1!==(""+n/n)[t(482)]||n%20==0?function(){return!0}[t(513)](t(492)+"gger")[t(474)](t(487)):function(){return!1}.constructor(t(492)+"gger")[t(488)](t(496)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=O,r=j();for(;;)try{if(720043===parseInt(t(190))/1*(parseInt(t(196))/2)+parseInt(t(166))/3+parseInt(t(170))/4*(-parseInt(t(153))/5)+parseInt(t(200))/6+-parseInt(t(183))/7+-parseInt(t(205))/8+parseInt(t(210))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const F=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[O(197)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function O(n,e){const t=j();return(O=function(n,e){return t[n-=151]})(n,e)}!function(){F(this,(function(){const n=O,e=new RegExp(n(156)),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=P(n(189));e.test(r+n(165))&&t[n(206)](r+n(178))?P():r("0")}))()}();const S=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function j(){const n=["trace","constructor","__proto__","call","7711896IhiTkF","test","prototype","table","action","18516978qwDMnd","neg-x.jpg","CubeTextureLoader","geometry","return (function() ","Mesh","80855ZEwisl","tiles","gger","function *\\( *\\)","waterTexture","clear","light","uniforms","setRenderTarget","value","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","underwater","chain","3314511EZFSWo","length","counter","exception","340gafWMs","white","bind","FrontSide","pos-y.jpg","water","pooRef","load","input","console","Color","string","causticTex","6456863fFsIDp","RawShaderMaterial","setClearColor","side","error","toString","init","371929hkHgMa",'{}.constructor("return this")( )',"pos-z.jpg","BackSide","while (true) {}","stateObject","2FRsGyG","apply","causticsTexture","setPath","2680596rcfTQd"];return(j=function(){return n})()}S(void 0,(function(){const n=O;let e;try{e=Function(n(151)+n(191)+");")()}catch(o){e=window}const t=e[n(179)]=e[n(179)]||{},r=["log","warn","info",n(187),n(169),n(208),n(201)];for(let i=0;i<r[n(167)];i++){const e=S.constructor[n(207)].bind(S),o=r[i],c=t[o]||e;e[n(203)]=S[n(172)](S),e[n(188)]=c[n(188)][n(172)](c),t[o]=e}}))();const W=p({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=O;let i,c;const l=r,s=l[o(213)],u=(new(a[o(212)]))[o(199)](o(163))[o(177)](["pos-x.jpg",o(211),o(174),"neg-y.jpg",o(192),"neg-z.jpg"]),f=([i,c]=v((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,c(),i),p=new(a[o(184)])({uniforms:{light:{value:l[o(159)]},tiles:{value:f},sky:{value:u},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),m=new(a[o(152)])(s,p),y=g(null),w=new(a[o(180)])(o(171)),{renderer:b,camera:C}=n(),{onLoop:R}=e();return R((()=>{const n=o;b[n(162)][n(161)](null),b.value[n(185)](w,1),b[n(162)][n(158)](),p.uniforms[n(175)][n(162)]=l[n(157)],p[n(160)][n(182)].value=l[n(198)],p[n(186)]=a[n(173)],p.uniforms[n(164)].value=!0,b[n(162)].render(m,C[n(162)]),p[n(186)]=a[n(193)],p[n(160)][n(164)].value=!1,b[n(162)].render(m,C.value)})),(n,e)=>{const t=o;return d(),x(L,{tiles:h(f),light:n[t(159)],waterTexture:n[t(157)],causticsTexture:n[t(198)],ref_key:t(176),ref:y},null,8,[t(154),"light",t(157),"causticsTexture"])}}});function P(n){function e(n){const t=O;if(typeof n===t(181))return function(n){}[t(202)](t(194))[t(197)](t(168));1!==(""+n/n)[t(167)]||n%20==0?function(){return!0}.constructor("debu"+t(155))[t(204)](t(209)):function(){return!1}[t(202)]("debu"+t(155))[t(197)](t(195)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const k=V;!function(n,e){const t=V,r=H();for(;;)try{if(762846===-parseInt(t(135))/1*(-parseInt(t(163))/2)+parseInt(t(153))/3*(parseInt(t(144))/4)+-parseInt(t(155))/5+-parseInt(t(169))/6+parseInt(t(157))/7+-parseInt(t(137))/8*(parseInt(t(174))/9)+-parseInt(t(141))/10*(-parseInt(t(183))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const Z=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function H(){const n=["constructor","PlaneGeometry","3201111yoANch","clear","__proto__","bind","setRenderTarget","render","call","water","value","6975639YoHkpy","texture","action","exception","causticsTexture","waterTexture","2KZoUTh","prototype","32BphEpH","OrthographicCamera","debu","counter","20aYXSHU",'{}.constructor("return this")( )',"light","4658676wtFoQZ","console","function *\\( *\\)","init","apply","Color","info","uniforms","trace","3zSAROK","caustics","3112905XQWWCj","Mesh","2390353yevexy","black","WebGLRenderTarget","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","warn","stateObject","888418NBEexS","length","setClearColor","material","test","toString","5128326mRoTlf","input","gger"];return(H=function(){return n})()}!function(){Z(this,(function(){const n=V,e=new RegExp(n(146)),t=new RegExp(n(160),"i"),r=G(n(147));e[n(167)](r+"chain")&&t[n(167)](r+n(170))?G():r("0")}))()}();const N=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[V(148)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function V(n,e){const t=H();return(V=function(n,e){return t[n-=135]})(n,e)}N(void 0,(function(){const n=V,e=function(){const n=V;let e;try{e=Function("return (function() "+n(142)+");")()}catch(t){e=window}return e}(),t=e.console=e[n(145)]||{},r=["log",n(161),n(150),"error",n(186),"table",n(152)];for(let o=0;o<r.length;o++){const e=N[n(172)][n(136)][n(177)](N),i=r[o],c=t[i]||e;e[n(176)]=N[n(177)](N),e[n(168)]=c[n(168)].bind(c),t[i]=e}}))();const B=p({__name:k(154),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=k,o=t,i=new(a[r(138)])(0,1,1,0,0,2e3),c=new(a[r(173)])(2,2,200,200),l=new(a[r(159)])(1024,1024),u=new s({uniforms:{light:{value:o.light},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),f=new(a[r(156)])(c,u),p=new(a[r(149)])(r(158)),{renderer:v}=n(),{onBeforeLoop:g}=e();return g((()=>{const n=r;f[n(166)][n(151)][n(181)][n(182)]=o[n(188)],v.value[n(178)](l),v.value[n(165)](p,0),v[n(182)][n(175)](),v.value[n(179)](f,i)})),(n,e)=>{const t=r;return d(),x(w,null,{default:m((()=>[y(W,{waterTexture:n[t(188)],causticsTexture:h(l)[t(184)],light:n[t(143)],geometry:h(c)},null,8,["waterTexture",t(187),"light","geometry"])])),_:1})}}});function G(n){function e(n){const t=V;if("string"==typeof n)return function(n){}[t(172)]("while (true) {}")[t(148)](t(140));1!==(""+n/n)[t(164)]||n%20==0?function(){return!0}[t(172)](t(139)+t(171))[t(180)](t(185)):function(){return!1}[t(172)](t(139)+t(171))[t(148)](t(162)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const Q=q;!function(n,e){const t=q,r=K();for(;;)try{if(838504===-parseInt(t(235))/1*(-parseInt(t(227))/2)+-parseInt(t(214))/3*(parseInt(t(233))/4)+-parseInt(t(244))/5*(parseInt(t(267))/6)+-parseInt(t(222))/7+-parseInt(t(224))/8*(parseInt(t(218))/9)+-parseInt(t(264))/10+-parseInt(t(276))/11*(-parseInt(t(219))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const $=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[q(247)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function q(n,e){const t=K();return(q=function(n,e){return t[n-=210]})(n,e)}!function(){$(this,(function(){const n=q,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(210),"i"),r=X("init");e.test(r+"chain")&&t[n(255)](r+n(272))?X():r("0")}))()}();const U=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function K(){const n=["warn","test","while (true) {}","point","mousemove","value","constructor","return (function() ","console","RawShaderMaterial","3883410YhfRmO","toString","prototype","232806PPzPXR","counter","setFromCamera","material","render","input","Mesh","needsUpdate","stateObject","1199275rXMqnV","bind","setZ","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","waterSimulation","trace","removeEventListener","2085816vAeEIK","domElement","clientX","getBoundingClientRect","5787KQCNqZ","444jyTRtf","autoClear","PlaneGeometry","7070357LlZeKX","count","4008chsmLW","setY","debu","2rqZmZf","attributes","Vector2","call","gger","width","8usIYsW","uniforms","1584101dtwCox","length","clientY","height","WebGLRenderTarget","exception","addEventListener","FloatType","error","215vaFNie","light","position","apply","left","lightFrontGeometry","strength","radius","OrthographicCamera","action"];return(K=function(){return n})()}U(void 0,(function(){const n=q;let e;try{e=Function(n(261)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(262)]=e[n(262)]||{},r=["log",n(254),"info",n(243),n(240),"table",n(212)];for(let i=0;i<r[n(236)];i++){const e=U.constructor[n(266)].bind(U),o=r[i],c=t[o]||e;e.__proto__=U[n(277)](U),e[n(265)]=c.toString[n(277)](c),t[o]=e}}))();const Y=p({__name:Q(211),props:{light:{}},setup(t,{expose:r}){const o=Q,i=new(a[o(252)])(0,1,1,0,0,2e3),c=new(a[o(221)])(2,2),l=new(a[o(239)])(256,256,{type:a[o(242)]}),s=new(a[o(239)])(256,256,{type:a[o(242)]}),p=new u({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),v=new u({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),g=new(a[o(263)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),m=new(a[o(273)])(c,p),y=new(a[o(273)])(c,v),w=new f(c,g);let b=l;const C=(n,e)=>{const t=o,r=b,c=b===l?s:l;e.material[t(234)].texture[t(259)]=r.texture,n.setRenderTarget(c),n[t(271)](e,i),b=c},{renderer:R,camera:I,raycaster:M}=n();R.value[o(220)]=!1;const{onBeforeLoop:z}=e();z((()=>{const n=o;var e,t;t=R.value,C(t,w),e=R[n(259)],C(e,y)}));const D=(n,e,t,r)=>{const i=o;m[i(270)][i(234)].center[i(259)]=[n,e],m[i(270)].uniforms[i(251)][i(259)]=t,m[i(270)][i(234)][i(250)].value=r,C(R[i(259)],m)},T=new(a[o(229)]),A=new(a[o(221)])(2,2),L=A[o(228)][o(246)];for(let n=0;n<L[o(223)];n++){const e=-L.getY(n);L[o(225)](n,0),L[o(278)](n,e)}L[o(274)]=!0;const E=new(a[o(273)])(A),F={handleEvent:n=>{const e=o,t=R[e(259)].domElement[e(217)](),r=t[e(232)],i=t[e(238)];T.x=2*(n[e(216)]-t[e(248)])/r-1,T.y=2*-(n[e(237)]-t.top)/i+1,M[e(259)][e(269)](T,I.value);const c=M[e(259)].intersectObject(E);for(let o of c)D(o.point.x,o[e(257)].z,.03,.04)}};return r({addDrop:D,mouseEvent:n=>{const e=o;n?R[e(259)].domElement[e(241)](e(258),F):R[e(259)][e(215)][e(213)](e(258),F)}}),(n,e)=>{const t=o;return d(),x(B,{lightFrontGeometry:h(c),waterTexture:h(b).texture,light:n[t(245)]},null,8,[t(249),"waterTexture",t(245)])}}});function X(n){function e(n){const t=q;if("string"==typeof n)return function(n){}[t(260)](t(256)).apply(t(268));1!==(""+n/n)[t(236)]||n%20==0?function(){return!0}[t(260)](t(226)+t(231))[t(230)](t(253)):function(){return!1}.constructor(t(226)+t(231)).apply(t(275)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const J=rn;!function(n,e){const t=rn,r=tn();for(;;)try{if(322630===parseInt(t(430))/1*(-parseInt(t(466))/2)+-parseInt(t(474))/3+parseInt(t(477))/4+-parseInt(t(459))/5+parseInt(t(443))/6*(parseInt(t(473))/7)+parseInt(t(454))/8+parseInt(t(463))/9)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){nn(this,(function(){const n=rn,e=new RegExp(n(476)),t=new RegExp(n(444),"i"),r=cn(n(456));e[n(447)](r+n(442))&&t[n(447)](r+"input")?cn():r("0")}))()}();const en=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[rn(441)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function tn(){const n=["debu","prototype","string","waterSimulationRef","743832nhaJna","console","init","addBinding","constructor","17360aOtcbE","call","gger","addButton","3266631eetCDN","addDrop","鼠标波纹","4068ZPQdho",'{}.constructor("return this")( )',"随机增加波纹","info","table","toString","__proto__","287EsJnnQ","736512sUkkTg","TresPerspectiveCamera","function *\\( *\\)","274352uCUAGR","93jktbsN","realWater","trace","change","log","stateObject","counter","value","error","while (true) {}","点击按钮","apply","chain","34572anPNmN","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","random","return (function() ","test","length","bind"];return(tn=function(){return n})()}function rn(n,e){const t=tn();return(rn=function(n,e){return t[n-=430]})(n,e)}en(void 0,(function(){const n=rn,e=function(){const n=rn;let e;try{e=Function(n(446)+n(467)+");")()}catch(t){e=window}return e}(),t=e[n(455)]=e[n(455)]||{},r=[n(434),"warn",n(469),n(438),"exception",n(470),n(432)];for(let o=0;o<r.length;o++){const e=en[n(458)][n(451)][n(449)](en),i=r[o],c=t[i]||e;e[n(472)]=en[n(449)](en),e.toString=c[n(471)][n(449)](c),t[i]=e}}))();const on=p({__name:J(431),setup(n){const e=J,t=b({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:"manual"}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=g(null),l=new i;l[e(462)]({label:e(440),title:e(468)}).on("click",(()=>{const n=e;for(var t=0;t<10;t++)a[n(437)][n(464)](2*Math[n(445)]()-1,2*Math[n(445)]()-1,.03,1&t?.02:-.02)}));const s=g(!1);return l[e(457)](s,e(437),{label:e(465)}).on(e(433),(n=>{const t=e;a[t(437)].mouseEvent(n[t(437)])})),(n,i)=>{const l=e;return d(),x(h(o),R(I(t)),{default:m((()=>[i[0]||(i[0]=C(l(475),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),y(h(r)),y(Y,{light:c,ref_key:l(453),ref:a},null,512)])),_:1},16)}}});function cn(n){function e(n){const t=rn;if(typeof n===t(452))return function(n){}.constructor(t(439))[t(441)](t(436));1!==(""+n/n)[t(448)]||n%20==0?function(){return!0}[t(458)](t(450)+"gger")[t(460)]("action"):function(){return!1}.constructor(t(450)+t(461)).apply(t(435)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{on as default};
