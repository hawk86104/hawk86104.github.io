import{i as e}from"./3d-tiles-renderer.CbgZh8zU1767066396612.js";import{L as o,a as t,b as n}from"./three.BD1hRFgo1767066396612.js";import{r}from"./utils.DguR31dd1767066396612.js";const{defineComponent:a}=await e("vue"),{unref:i,createElementVNode:l,openBlock:s,createElementBlock:c}=await e("vue"),v=["object","rotation-x"],p=["object","rotation-x"],m=await e("three"),{watchEffect:d}=await e("vue"),f=a({__name:"regionGlow",props:{positionSrc:{default:[[0,0],[1,1]]},color:{default:"#ffff00"}},setup(e){const a=e,f=new m.Shape;a.positionSrc.forEach((e,o)=>{0===o?f.moveTo(e[0],e[1]):f.lineTo(e[0],e[1])});const u=new m.ShaderMaterial({vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    varying vec2 vUv;\n\t\tuniform vec3 color;\n    void main() {\n\t\t\t// 计算距离四条边的最小距离\n        float distance = max(max(vUv.x, -vUv.x), max(vUv.y, -vUv.y));\n\n        // 将距离映射到透明度（从边缘到中心逐渐变透明）\n        float alpha = smoothstep(0.1, 0.9, distance*1.1);\n\n        // 设置最终颜色和透明度\n        gl_FragColor = vec4(color, alpha);\n    }\n  ",transparent:!0,side:m.DoubleSide,depthWrite:!1,depthTest:!0,uniforms:{color:{type:"uvs",value:new m.Color(a.color)}}});let w=new m.ShapeGeometry(f);r(w,!0);const h=new m.Mesh(w,u),x=f.getPoints(),g=new o;g.setPositions(x.flatMap(e=>[e.x,e.y,0]));var j=new t({color:new m.Color(a.color),linewidth:2});const S=new n(g,j);return d(()=>{u.uniforms.color.value=new m.Color(a.color),j.color=new m.Color(a.color)}),(e,o)=>(s(),c("TresGroup",null,[l("primitive",{object:i(h),renderOrder:9999,"rotation-x":Math.PI/2},null,8,v),l("primitive",{object:i(S),renderOrder:9999,"rotation-x":Math.PI/2},null,8,p)]))}});export{f as _};
