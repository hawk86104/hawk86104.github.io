import{P as e}from"./tweakpane.C0HtAJSg1755074079444.js";import"./vanilla.esm.5.5.0.CYwMwbT81755074079444.js";import"./SPE.DRpGJ3P21755074079444.js";import"./@fesjs.DpbLChem1755074079444.js";import{d as t,a2 as r,G as o,o as i,I as a,a7 as n,a8 as l,r as s,e as d,f as m,j as p,u,m as f}from"./@vue.BzMISRrV1755074079444.js";import{C as h,a as v,a3 as g}from"./three.QlBabAUP1755074079444.js";import"./HeightCorrection.Bq98L9tL1755074079444.js";import"./three-custom-shader-material.BkclajdY1755074079444.js";import{b}from"./pagesShow.vue_vue_type_script_setup_true_lang.BG9tU9D-1755074079444.js";import"./object-hash.B6ZuB-M81755074079444.js";import"./@amap.CGUF9xH41755074079444.js";import"./jszip.BmruoSQP1755074079444.js";import"./vue-router.JcHWg-wh1755074079444.js";import"./lodash-es.C7pWAXPe1755074079444.js";import"./pinia.PwbQelYZ1755074079444.js";import"./@qlin.q6OWdsQV1755074079444.js";import"./@babel.BPq7uOAK1755074079444.js";import"./@floating-ui.BFjFSAYt1755074079444.js";import"./@juggle.CcBCnTIR1755074079444.js";import"./@tresjs.B1VqNfqw1755074079444.js";import"./postprocessing.D49g_X_Q1755074079444.js";import"./@vueuse.C47q1p2Z1755074079444.js";import"./buildingsCustomShaderMaterial.DyBo--wu1755074079444.js";const w={renderOrder:9999},W=["rotation"],c=["args"],j=["rotation"],x=["args"],C=t({__name:"rectangleGlow",props:{w:{default:100},h:{default:100},pColor:{default:"#ffff00"},gradientWidth:{default:.99},glowWidth:{default:.99},nNumber:{default:8},lineWidth:{default:2},lColor:{default:"#ffff00"}},setup(e){const t=e,s={vertexShader:"\n \t\tvarying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    varying vec2 vUv;\n\t\tuniform vec3 color;\n\t\tuniform float gradientWidth;\n\t\tuniform float glowWidth;\n\t\tuniform float nNumber;\n\n    void main() {\n \t\t\tfloat distX = abs(vUv.x - 0.5) / 0.5;\n      float distY = abs(vUv.y - 0.5) / 0.5;\n\n      // 使用 Minkowski 距离，平滑矩形感 + 中心无交叉线 + 对角线也平滑\n      float dist = pow(pow(distX, nNumber) + pow(distY, nNumber), 1.0 / nNumber);\n\n      float cutoff = 1.0 - gradientWidth;\n  \t\tfloat alpha = smoothstep(cutoff, cutoff + glowWidth, dist);\n\n      gl_FragColor = vec4(color, alpha);\n    }\n  ",transparent:!0,side:g,depthWrite:!1,depthTest:!0,uniforms:{color:{type:"uvs",value:new h(t.pColor)},gradientWidth:{type:"f",value:t.gradientWidth},glowWidth:{type:"f",value:t.glowWidth},nNumber:{type:"f",value:t.nNumber}}},d={transparent:!0,side:g,depthWrite:!1,depthTest:!0,uniforms:{borderWidth:{value:t.lineWidth},borderColor:{value:new h(t.lColor)},size:{value:new v(t.w,t.h)}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    uniform float borderWidth;\n    uniform vec3 borderColor;\n    varying vec2 vUv;\n\t\tuniform vec2 size;\n\n    void main() {\n\t\t \tfloat borderX = borderWidth / size.x;\n  \t\tfloat borderY = borderWidth / size.y;\n\n      float left   = step(vUv.x, borderX);\n      float right  = step(1.0 - borderX, vUv.x);\n      float bottom = step(vUv.y, borderY);\n      float top    = step(1.0 - borderY, vUv.y);\n\n      float edge = max(max(left, right), max(bottom, top)); // 只保留边缘线\n      float alpha = edge;\n\n      gl_FragColor = vec4(borderColor, alpha);\n    }\n  "};return r((()=>{s.uniforms.color.value=new h(t.pColor),s.uniforms.gradientWidth.value=t.gradientWidth,s.uniforms.glowWidth.value=t.glowWidth,s.uniforms.nNumber.value=t.nNumber,d.uniforms.borderColor.value=new h(t.lColor),d.uniforms.borderWidth.value=t.lineWidth,d.uniforms.size.value.set(t.w,t.h)})),(e,t)=>(i(),o("TresGroup",w,[a("TresMesh",{rotation:[Math.PI/2,0,0]},[a("TresPlaneGeometry",{args:[e.w,e.h]},null,8,c),a("TresShaderMaterial",n(l(s)),null,16)],8,W),a("TresMesh",{rotation:[Math.PI/2,0,0]},[a("TresPlaneGeometry",{args:[e.w+e.lineWidth,e.h+e.lineWidth]},null,8,x),a("TresShaderMaterial",n(l(d)),null,16)],8,j)]))}}),y=t({__name:"rectangleGlowPage",setup(t){const r=s({pColor:"#00ffdd",w:160,h:90,gradientWidth:.99,glowWidth:.99,nNumber:8,lineWidth:2,lColor:"#0022ff"}),o=new e({title:"区域边界发光",expanded:!0});return o.addBinding(r,"pColor",{label:"颜色"}),o.addBinding(r,"w",{label:"矩形宽",min:1,max:500,step:1}),o.addBinding(r,"h",{label:"矩形高",min:1,max:500,step:1}),o.addBinding(r,"gradientWidth",{label:"作用宽度",min:0,max:1,step:.01}),o.addBinding(r,"glowWidth",{label:"渐变宽度",min:0,max:1,step:.01}),o.addBinding(r,"nNumber",{label:"nNumber",min:0,max:20,step:.1}),o.addBinding(r,"lineWidth",{label:"边框宽度",min:0,max:10,step:.1}),o.addBinding(r,"lColor",{label:"边框颜色"}),(e,t)=>(i(),d(b,{ref:"pagesShowRef"},{ability:m((()=>[p(u(C),{renderOrder:9998,position:[93,28,28],lColor:"#ff0000"}),p(u(C),f({"position-y":58},r),null,16)])),_:1},512))}});export{y as default};
