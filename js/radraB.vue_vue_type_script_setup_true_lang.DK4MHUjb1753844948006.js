import{e}from"./@tresjs.DRasrl5q1753844948006.js";import{C as o,M as n,a3 as t,bb as a,ap as i,V as l}from"./three.EZPPomHU1753844948006.js";import{d as r,b as s,w as u,a2 as d,G as f,o as c,I as v,a7 as g,a8 as p}from"./@vue.BzMISRrV1753844948006.js";const m=["position"],h=["args"],x=r({__name:"radraA",props:{position:{default:[0,0,0]},size:{default:300},radius:{default:240},color:{default:"#ffff00"},opacity:{default:.9},speed:{default:300},followWidth:{default:220}},setup(i,{expose:l}){const r=i,{onLoop:x}=e(),M={value:0},y=s();x((({delta:e})=>{M.value+=e}));const w={transparent:!0,blending:a,depthWrite:!1,side:t,depthTest:!0,vertexShader:"\n\tvarying vec3 vPosition;\n\tvoid main() {\n\t\tvPosition = position;\n\t\tvec4 modelPosition = modelMatrix * vec4(position, 1.0);\n\t\tvec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectionPosition = projectionMatrix * viewPosition;\n    gl_Position = projectionPosition;\n  }\n  ",fragmentShader:"\n\tuniform float uRadius;     \n  uniform float uTime;            \n  uniform float uSpeed; \n  uniform float uFollowWidth; \n  varying vec3 vPosition;\n\tuniform vec3 ncolor;\n  float calcAngle(vec3 oFrag){\n    float fragAngle;\n    const vec3 ox = vec3(1,0,0);\n    float dianji = oFrag.x * ox.x + oFrag.z*ox.z;\n    float oFrag_length = length(oFrag); // length是内置函数\n    float ox_length = length(ox); // length是内置函数\n    float yuxian = dianji / (oFrag_length * ox_length);\n    fragAngle = acos(yuxian);\n    fragAngle = degrees(fragAngle);\n    if(oFrag.z > 0.0) {\n      fragAngle = -fragAngle + 360.0;\n    }\n    float scanAngle = uTime * uSpeed - floor(uTime * uSpeed / 360.0) * 360.0;\n    float angle = scanAngle - fragAngle;\n    if(angle < 0.0){\n      angle = angle + 360.0;\n    }\n    return angle;\n  }\n  void main() {\n\t\t\t// length内置函数，取向量的长度\n\t\tif(length(vPosition) == 0.0 || length(vPosition) > uRadius-2.0){\n\t\t\tgl_FragColor = vec4( ncolor, 1.0 );\n\t\t} else {\n\t\t\tfloat angle = calcAngle(vPosition);\n\t\t\tif(angle < uFollowWidth){\n\t\t\t\t// 尾焰区域\n\t\t\t\tfloat opacity =  1.0 - angle / uFollowWidth; \n\t\t\t\tgl_FragColor = vec4( ncolor, 1.0 * opacity );  \n\t\t\t} else {\n\t\t\t\t// 其他位置的像素均为透明\n\t\t\t\tgl_FragColor = vec4( ncolor, 0.0 ); \n\t\t\t}\n\t\t}\n\t}\n  ",uniforms:{uSpeed:{value:r.speed},uRadius:{value:r.radius},uTime:M,uFollowWidth:{value:r.followWidth},ncolor:{value:new o(r.color)}}};u(y,((e,o)=>{if(e&&void 0===o){const e=(new n).makeRotationX(-Math.PI/180*90);y.value.applyMatrix4(e)}}));const _=s();return d((()=>{r.color&&(w.uniforms.ncolor.value=new o(r.color)),r.radius&&(w.uniforms.uRadius.value=r.radius)})),s(-Math.PI/180*90),l({MeshRef:_}),(e,o)=>(c(),f("TresMesh",{ref_key:"MeshRef",ref:_,position:r.position},[v("TresCircleGeometry",{ref_key:"TresCircleGeometryRef",ref:y,args:[r.size,1e3]},null,8,h),v("TresShaderMaterial",g(p(w)),null,16)],8,m))}}),M=["position"],y=["args"],w=r({__name:"radraB",props:{position:{default:[0,0,0]},radius:{default:10},maxRadius:{default:200},color:{default:"#ffff00"},opacity:{default:.5},period:{default:2},height:{default:100}},setup(a,{expose:r}){const m=a,h=s(),x=s(1),w=s(.1),_={color:m.color,opacity:m.opacity,transparent:!0,depthWrite:!1,depthTest:!0,side:t,vertexShader:"\n\tvarying vec4 vPosition;\n  void main() {\n    vPosition = modelMatrix * vec4(position,1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n  ",fragmentShader:"\n\tuniform vec3 uColor; // 光墙半径        \n  uniform vec3 uMax; \n  uniform vec3 uMin;\n  uniform mat4 modelMatrix; // 世界矩阵\n  varying vec4 vPosition; // 接收顶点着色传递进来的位置数据\n  void main() {\n    // 转世界坐标\n    vec4 uMax_world = modelMatrix * vec4(uMax,1.0);\n    vec4 uMin_world = modelMatrix * vec4(uMin,1.0);\n    // 根据像素点世界坐标的y轴高度,设置透明度\n    float opacity =1.0 - (vPosition.y - uMin_world.y) / (uMax_world.y -uMin_world.y) ; \n    gl_FragColor = vec4( uColor, opacity);\n  }\n  ",uniforms:{uMax:x,uMin:w,uColor:{value:new o(m.color)}}},P=s();let T=null;u(P,((e,o)=>{e&&void 0===o&&(P.value.computeBoundingBox(),x.value=P.value.boundingBox.max,w.value=P.value.boundingBox.min,T=h.value.scale.clone())}));const F=s(new i(new l(0,0,0),new l(0,m.height,0)));d((()=>{m.color&&(_.uniforms.uColor.value=new o(m.color))}));const{onLoop:R}=e(),A={value:0};return R((({delta:e})=>{A.value+=e;const o=(A.value%m.period/m.period*(m.maxRadius-m.radius)+m.radius)/m.radius,t=(new n).makeScale(o,1,o);T&&(h.value.scale.copy(T.clone().applyMatrix4(t)),h.value.updateMatrix())})),r({MeshRef:h}),(e,o)=>(c(),f("TresMesh",{ref_key:"MeshRef",ref:h,position:m.position,renderOrder:2e3},[v("TresTubeGeometry",{ref_key:"TresTubeGeometryRef",ref:P,args:[F.value,20,m.radius,100,!1]},null,8,y),v("TresShaderMaterial",g(p(_)),null,16)],8,M))}});export{x as _,w as a};
