import{b6 as V,aB as M,aC as I,bf as O,ax as _,bL as H,aH as b,a1 as D,l as h,a6 as N,ak as W,o as w,c as G,Y as t,G as k,a9 as Y,r as z,x as X,E as j,a as F,L as $,ac as q}from"./vendor.ydO6dH7Z1712722105506.js";import{P as K,F as R,R as J,E as g,S as P}from"./EffectComposer.bqkwQxZs1712722105506.js";import{U as Z}from"./UnrealBloomPass.AsnNldoj1712722105506.js";import{F as ee}from"./FilmPass.o_DBZPPL1712722105506.js";const te={name:"AfterimageShader",uniforms:{damp:{value:.96},tOld:{value:null},tNew:{value:null}},vertexShader:"\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}",fragmentShader:"\n\n		uniform float damp;\n\n		uniform sampler2D tOld;\n		uniform sampler2D tNew;\n\n		varying vec2 vUv;\n\n		vec4 when_gt( vec4 x, float y ) {\n\n			return max( sign( x - y ), 0.0 );\n\n		}\n\n		void main() {\n\n			vec4 texelOld = texture2D( tOld, vUv );\n			vec4 texelNew = texture2D( tNew, vUv );\n\n			texelOld *= damp * when_gt( texelOld, 0.1 );\n\n			gl_FragColor = max(texelNew, texelOld);\n\n		}"};class ae extends K{constructor(e=.96){super(),this.shader=te,this.uniforms=V.clone(this.shader.uniforms),this.uniforms.damp.value=e,this.textureComp=new M(window.innerWidth,window.innerHeight,{magFilter:I,type:O}),this.textureOld=new M(window.innerWidth,window.innerHeight,{magFilter:I,type:O}),this.compFsMaterial=new _({uniforms:this.uniforms,vertexShader:this.shader.vertexShader,fragmentShader:this.shader.fragmentShader}),this.compFsQuad=new R(this.compFsMaterial),this.copyFsMaterial=new H,this.copyFsQuad=new R(this.copyFsMaterial)}render(e,a,l){this.uniforms.tOld.value=this.textureOld.texture,this.uniforms.tNew.value=l.texture,e.setRenderTarget(this.textureComp),this.compFsQuad.render(e),this.copyFsQuad.material.map=this.textureComp.texture,this.renderToScreen?(e.setRenderTarget(null),this.copyFsQuad.render(e)):(e.setRenderTarget(a),this.clear&&e.clear(),this.copyFsQuad.render(e));const o=this.textureOld;this.textureOld=this.textureComp,this.textureComp=o}setSize(e,a){this.textureComp.setSize(e,a),this.textureOld.setSize(e,a)}dispose(){this.textureComp.dispose(),this.textureOld.dispose(),this.compFsMaterial.dispose(),this.copyFsMaterial.dispose(),this.compFsQuad.dispose(),this.copyFsQuad.dispose()}}const re={name:"FXAAShader",uniforms:{tDiffuse:{value:null},resolution:{value:new b(1/1024,1/512)}},vertexShader:"\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}",fragmentShader:"\n		precision highp float;\n\n		uniform sampler2D tDiffuse;\n\n		uniform vec2 resolution;\n\n		varying vec2 vUv;\n\n		// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n		//----------------------------------------------------------------------------------\n		// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n		// SDK Version: v3.00\n		// Email:       gameworks@nvidia.com\n		// Site:        http://developer.nvidia.com/\n		//\n		// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n		//\n		// Redistribution and use in source and binary forms, with or without\n		// modification, are permitted provided that the following conditions\n		// are met:\n		//  * Redistributions of source code must retain the above copyright\n		//    notice, this list of conditions and the following disclaimer.\n		//  * Redistributions in binary form must reproduce the above copyright\n		//    notice, this list of conditions and the following disclaimer in the\n		//    documentation and/or other materials provided with the distribution.\n		//  * Neither the name of NVIDIA CORPORATION nor the names of its\n		//    contributors may be used to endorse or promote products derived\n		//    from this software without specific prior written permission.\n		//\n		// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY\n		// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n		// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n		// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n		// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n		// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n		// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n		// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n		// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n		// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n		// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n		//\n		//----------------------------------------------------------------------------------\n\n		#ifndef FXAA_DISCARD\n			//\n			// Only valid for PC OpenGL currently.\n			// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n			//\n			// 1 = Use discard on pixels which don't need AA.\n			//     For APIs which enable concurrent TEX+ROP from same surface.\n			// 0 = Return unchanged color on pixels which don't need AA.\n			//\n			#define FXAA_DISCARD 0\n		#endif\n\n		/*--------------------------------------------------------------------------*/\n		#define FxaaTexTop(t, p) texture2D(t, p, -100.0)\n		#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)\n		/*--------------------------------------------------------------------------*/\n\n		#define NUM_SAMPLES 5\n\n		// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha\n		float contrast( vec4 a, vec4 b ) {\n			vec4 diff = abs( a - b );\n			return max( max( max( diff.r, diff.g ), diff.b ), diff.a );\n		}\n\n		/*============================================================================\n\n									FXAA3 QUALITY - PC\n\n		============================================================================*/\n\n		/*--------------------------------------------------------------------------*/\n		vec4 FxaaPixelShader(\n			vec2 posM,\n			sampler2D tex,\n			vec2 fxaaQualityRcpFrame,\n			float fxaaQualityEdgeThreshold,\n			float fxaaQualityinvEdgeThreshold\n		) {\n			vec4 rgbaM = FxaaTexTop(tex, posM);\n			vec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);\n			vec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);\n			vec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);\n			vec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);\n			// . S .\n			// W M E\n			// . N .\n\n			bool earlyExit = max( max( max(\n					contrast( rgbaM, rgbaN ),\n					contrast( rgbaM, rgbaS ) ),\n					contrast( rgbaM, rgbaE ) ),\n					contrast( rgbaM, rgbaW ) )\n					< fxaaQualityEdgeThreshold;\n			// . 0 .\n			// 0 0 0\n			// . 0 .\n\n			#if (FXAA_DISCARD == 1)\n				if(earlyExit) FxaaDiscard;\n			#else\n				if(earlyExit) return rgbaM;\n			#endif\n\n			float contrastN = contrast( rgbaM, rgbaN );\n			float contrastS = contrast( rgbaM, rgbaS );\n			float contrastE = contrast( rgbaM, rgbaE );\n			float contrastW = contrast( rgbaM, rgbaW );\n\n			float relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );\n			relativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n			bool horzSpan = relativeVContrast > 0.;\n			// . 1 .\n			// 0 0 0\n			// . 1 .\n\n			// 45 deg edge detection and corners of objects, aka V/H contrast is too similar\n			if( abs( relativeVContrast ) < .3 ) {\n				// locate the edge\n				vec2 dirToEdge;\n				dirToEdge.x = contrastE > contrastW ? 1. : -1.;\n				dirToEdge.y = contrastS > contrastN ? 1. : -1.;\n				// . 2 .      . 1 .\n				// 1 0 2  ~=  0 0 1\n				// . 1 .      . 0 .\n\n				// tap 2 pixels and see which ones are \"outside\" the edge, to\n				// determine if the edge is vertical or horizontal\n\n				vec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);\n				float matchAlongH = contrast( rgbaM, rgbaAlongH );\n				// . 1 .\n				// 0 0 1\n				// . 0 H\n\n				vec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);\n				float matchAlongV = contrast( rgbaM, rgbaAlongV );\n				// V 1 .\n				// 0 0 1\n				// . 0 .\n\n				relativeVContrast = matchAlongV - matchAlongH;\n				relativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n				if( abs( relativeVContrast ) < .3 ) { // 45 deg edge\n					// 1 1 .\n					// 0 0 1\n					// . 0 1\n\n					// do a simple blur\n					return mix(\n						rgbaM,\n						(rgbaN + rgbaS + rgbaE + rgbaW) * .25,\n						.4\n					);\n				}\n\n				horzSpan = relativeVContrast > 0.;\n			}\n\n			if(!horzSpan) rgbaN = rgbaW;\n			if(!horzSpan) rgbaS = rgbaE;\n			// . 0 .      1\n			// 1 0 1  ->  0\n			// . 0 .      1\n\n			bool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );\n			if(!pairN) rgbaN = rgbaS;\n\n			vec2 offNP;\n			offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n			offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\n			bool doneN = false;\n			bool doneP = false;\n\n			float nDist = 0.;\n			float pDist = 0.;\n\n			vec2 posN = posM;\n			vec2 posP = posM;\n\n			int iterationsUsed = 0;\n			int iterationsUsedN = 0;\n			int iterationsUsedP = 0;\n			for( int i = 0; i < NUM_SAMPLES; i++ ) {\n				iterationsUsed = i;\n\n				float increment = float(i + 1);\n\n				if(!doneN) {\n					nDist += increment;\n					posN = posM + offNP * nDist;\n					vec4 rgbaEndN = FxaaTexTop(tex, posN.xy);\n					doneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );\n					iterationsUsedN = i;\n				}\n\n				if(!doneP) {\n					pDist += increment;\n					posP = posM - offNP * pDist;\n					vec4 rgbaEndP = FxaaTexTop(tex, posP.xy);\n					doneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );\n					iterationsUsedP = i;\n				}\n\n				if(doneN || doneP) break;\n			}\n\n\n			if ( !doneP && !doneN ) return rgbaM; // failed to find end of edge\n\n			float dist = min(\n				doneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,\n				doneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.\n			);\n\n			// hacky way of reduces blurriness of mostly diagonal edges\n			// but reduces AA quality\n			dist = pow(dist, .5);\n\n			dist = 1. - dist;\n\n			return mix(\n				rgbaM,\n				rgbaN,\n				dist * .5\n			);\n		}\n\n		void main() {\n			const float edgeDetectionQuality = .2;\n			const float invEdgeDetectionQuality = 1. / edgeDetectionQuality;\n\n			gl_FragColor = FxaaPixelShader(\n				vUv,\n				tDiffuse,\n				resolution,\n				edgeDetectionQuality, // [0,1] contrast needed, otherwise early discard\n				invEdgeDetectionQuality\n			);\n\n		}\n	"},se=t("TresBoxGeometry",{args:[1,1,1]},null,-1),oe=t("TresMeshNormalMaterial",null,null,-1),ie=[se,oe],ne=t("TresBoxGeometry",{args:[1,1,1]},null,-1),le=t("TresMeshNormalMaterial",null,null,-1),de=[ne,le],ce=t("TresBoxGeometry",{args:[1,1,1]},null,-1),fe=t("TresMeshNormalMaterial",null,null,-1),ue=[ce,fe],me=t("TresSphereGeometry",{args:[.8,32,16]},null,-1),he=t("TresMeshNormalMaterial",null,null,-1),ve=[me,he],pe=D({__name:"ecLayerMultiple",setup(A){const e=h(),a=h(),l=h(),o=h();N(()=>{e.value&&e.value.layers.set(0),a.value&&a.value.layers.set(1),l.value&&l.value.layers.set(2),o.value&&o.value.layers.set(3)});const{camera:i,renderer:d,scene:y,sizes:x}=W(),T={strength:.572,radius:.51,threshold:0};let m=null,n=null;const C=(r,s,v,E,S)=>{m=new J(r,s),n=new g(v),n.renderToScreen=!1,n.addPass(m);const p=new Z(new b(E,S),T.strength,T.radius,T.threshold);n.addPass(p)};let c=null;const U=r=>{c=new g(r),c.renderToScreen=!1,c.addPass(m);const s=new ee;c.addPass(s)};let f=null;const L=r=>{f=new g(r),f.renderToScreen=!1,f.addPass(m);const s=new ae;f.addPass(s)};let u=null;const B=r=>{u=new g(r),u.addPass(m);const s=new _({uniforms:{baseTexture:{value:null},bloomTexture:{value:n.renderTarget2.texture},filmTexture:{value:c.renderTarget2.texture},glitchTexture:{value:f.renderTarget2.texture}},vertexShader:"\n            varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n            }\n        ",fragmentShader:"\n            uniform sampler2D baseTexture;\n            uniform sampler2D bloomTexture;\n						uniform sampler2D filmTexture;\n						uniform sampler2D glitchTexture;\n            varying vec2 vUv;\n            void main() {\n                gl_FragColor = ( \n									vec4( 1.0 ) * texture2D( baseTexture, vUv )  + \n									vec4( 1.0 ) * texture2D( bloomTexture, vUv ) + \n									vec4( 1.0 ) * texture2D( filmTexture, vUv ) + \n									vec4( 1.0 ) * texture2D( glitchTexture, vUv ) \n								);\n            }\n        ",defines:{}}),v=new P(s,"baseTexture");v.needsSwap=!0,u.addPass(v);const{width:E,height:S}=r.getDrawingBufferSize(new b),p=new P(re);p.uniforms.resolution.value.set(1/E,1/S),u.addPass(p)};N(()=>{x.width.value&&(C(y.value,i.value,d.value,x.width.value,x.height.value),L(d.value),U(d.value),B(d.value))});const{onLoop:Q}=Y();return Q(()=>{n&&u&&i.value&&(d.value.clear(),i.value.layers.set(1),n.render(),i.value.layers.set(2),c.render(),i.value.layers.set(3),f.render(),d.value.clearDepth(),i.value.layers.set(0),u.render(y.value,i.value))}),(r,s)=>(w(),G(k,null,[t("TresMesh",{ref_key:"normalBox",ref:e,position:[3,2,1]},ie,512),t("TresMesh",{ref_key:"shineBox",ref:a,position:[0,2,-4]},de,512),t("TresMesh",{ref_key:"filmBox",ref:l,position:[1,2,3]},ue,512),t("TresMesh",{ref_key:"glitchSphere",ref:o,position:[-3,2,0]},ve,512)],64))}}),ge=t("TresPerspectiveCamera",{position:[10,10,10]},null,-1),xe=t("TresAmbientLight",{intensity:1},null,-1),Te=t("TresGridHelper",{args:[10,10]},null,-1),Ae=D({__name:"effectComposerMultiple",setup(A){const e=h();return N(()=>{if(e.value){let a=e.value.context.renderer.value;a.autoClear=!1}}),(a,l)=>{const o=z("TresCanvas");return w(),X(o,{disableRender:"","window-size":"",ref_key:"tcRef",ref:e},{default:j(()=>[ge,xe,F($(q)),Te,F(pe)]),_:1},512)}}});export{Ae as default};
