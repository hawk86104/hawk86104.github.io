import{m as n,e,a as t,o as r,f as o}from"./@tresjs.tqalU7S21741683274763.js";import{P as i}from"./tweakpane.yDiyAAkA1741683274763.js";import{_ as c,aM as a,r as l,O as s,W as u,o as f}from"./three.3wvNjL8W1741683274763.js";import{d as p,a3 as v,b as g,o as x,f as d,u as h,g as m,j as y,al as w,r as b,N as C,aj as I,ak as R}from"./@vue.NRI7TcgI1741683274763.js";import"./postprocessing.D4QJINSY1741683274763.js";import"./@vueuse.lt4-M8RL1741683274763.js";var _="attribute vec3 position;\nvarying vec2 coord;\n\nvoid main() {\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\n}";const z=T;!function(n,e){const t=T,r=L();for(;;)try{if(598478===-parseInt(t(222))/1+parseInt(t(193))/2+-parseInt(t(182))/3*(parseInt(t(219))/4)+-parseInt(t(230))/5*(-parseInt(t(205))/6)+-parseInt(t(211))/7*(-parseInt(t(218))/8)+-parseInt(t(204))/9+-parseInt(t(220))/10*(-parseInt(t(212))/11))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const M=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[T(191)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){M(this,(function(){const n=T,e=new RegExp(n(224)),t=new RegExp(n(190),"i"),r=O(n(195));e[n(208)](r+n(203))&&t[n(208)](r+n(202))?O():r("0")}))()}();const D=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[T(191)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function T(n,e){const t=L();return(T=function(n,e){return t[n-=182]})(n,e)}function L(){const n=["causticsTexture","uniforms","waterTexture","pool","BufferGeometry","7610312NmVDgb","1514592PayCly","368450fFWqqj","RawShaderMaterial","87332JGvEQc","FrontSide","function *\\( *\\)","prototype","Mesh","warn","console","value","40lVCDcl","tiles","6nuvdzx","exception","error","stateObject","length","action","counter","bind","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","apply","trace","5280vnsUuX","render","init","string","constructor","position","__proto__","gger","BufferAttribute","input","chain","4822497DTuknw","50280NoTqph","return (function() ","log","test","setAttribute","toString","7CxGvIL","286KrnbgX"];return(L=function(){return n})()}D(void 0,(function(){const n=T;let e;try{e=Function(n(206)+'{}.constructor("return this")( ));')()}catch(o){e=window}const t=e[n(228)]=e[n(228)]||{},r=[n(207),n(227),"info",n(184),n(183),"table",n(192)];for(let i=0;i<r[n(186)];i++){const e=D[n(197)][n(225)].bind(D),o=r[i],c=t[o]||e;e[n(199)]=D[n(189)](D),e.toString=c[n(210)][n(189)](c),t[o]=e}}))();const A=p({__name:z(216),props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(t){const r=z,o=t,i=new(c[r(217)]),a=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),l=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);i[r(209)](r(198),new(c[r(201)])(a,3)),i.setIndex(new(c[r(201)])(l,1));const s=new(c[r(221)])({uniforms:{light:{value:o.light},tiles:{value:o[r(231)]},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\n\nvoid main() {\n  pos = position.xyz;\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}",side:c[r(223)]}),u=new(c[r(226)])(i,s),{renderer:f,camera:p}=n(),{onAfterLoop:v}=e();return v((()=>{const n=r;((n,e)=>{const t=r;s[t(214)].water.value=n,s[t(214)].causticTex[t(229)]=e,f[t(229)][t(194)](u,p.value)})(o[n(215)],o[n(213)])})),(n,e)=>null}});function O(n){function e(n){const t=T;if(typeof n===t(196))return function(n){}[t(197)]("while (true) {}")[t(191)](t(188));1!==(""+n/n)[t(186)]||n%20==0?function(){return!0}[t(197)]("debu"+t(200)).call(t(187)):function(){return!1}[t(197)]("debu"+t(200))[t(191)](t(185)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const F=S;!function(n,e){const t=S,r=E();for(;;)try{if(826658===parseInt(t(330))/1+parseInt(t(328))/2*(-parseInt(t(331))/3)+parseInt(t(325))/4*(-parseInt(t(350))/5)+parseInt(t(321))/6*(parseInt(t(354))/7)+-parseInt(t(352))/8*(-parseInt(t(346))/9)+parseInt(t(363))/10+parseInt(t(361))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const j=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[S(329)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){j(this,(function(){const n=S,e=new RegExp(n(340)),t=new RegExp(n(372),"i"),r=V(n(358));e[n(337)](r+"chain")&&t[n(337)](r+n(367))?V():r("0")}))()}();const P=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[S(329)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function E(){const n=["gger","input","pos-z.jpg","clear","light","setClearColor","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","neg-y.jpg","causticsTexture","error","toString","value","table","pos-x.jpg","neg-x.jpg","geometry","log","constructor","tiles","30rrwXoI","neg-z.jpg","prototype","white","6188vXLcHU","info","stateObject","4322howJHj","apply","377104xtWnDs","1539sHLvXw","bind","while (true) {}","exception","Mesh","underwater","test","warn","uniforms","function *\\( *\\)","debu","call","waterTexture","pos-y.jpg","side","349011PJHYPW","https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/images/skyBox/6jpg/","water","length","4930gEvZYz","trace","72TTilxi","BackSide","1023750PvCBbY","setRenderTarget","load","pooRef","init","FrontSide","__proto__","9969982dBPKGO","Color","10968660gUlTpV","RawShaderMaterial","action"];return(E=function(){return n})()}function S(n,e){const t=E();return(S=function(n,e){return t[n-=309]})(n,e)}P(void 0,(function(){const n=S,e=function(){let n;try{n=Function('return (function() {}.constructor("return this")( ));')()}catch(e){n=window}return n}(),t=e.console=e.console||{},r=[n(318),n(338),n(326),n(311),n(334),n(314),n(351)];for(let o=0;o<r[n(349)];o++){const e=P[n(319)][n(323)][n(332)](P),i=r[o],c=t[i]||e;e[n(360)]=P[n(332)](P),e[n(312)]=c.toString[n(332)](c),t[i]=e}}))();const W=p({__name:F(348),props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(r){const o=F;let i,l;const s=r,u=s[o(317)],f=(new a).setPath(o(347))[o(356)]([o(315),o(316),o(344),o(309),o(368),o(322)]),p=([i,l]=v((()=>t(["./plugins/water/images/tiles.jpg"]))),i=await i,l(),i),m=new(c[o(364)])({uniforms:{light:{value:s[o(370)]},tiles:{value:p},sky:{value:f},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  pos = position.xzy;\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nuniform float underwater;\nuniform samplerCube sky;\n\nvarying vec3 eye;\nvarying vec3 pos;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 7.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\n}\n\nvoid main() {\n  vec2 coord = pos.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n\n  \n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}"}),y=new(c[o(335)])(u,m),w=g(null),b=new(c[o(362)])(o(324)),{renderer:C,camera:I}=n(),{onLoop:R}=e();return R((()=>{const n=o;C[n(313)][n(355)](null),C[n(313)][n(371)](b,1),C[n(313)][n(369)](),m.uniforms[n(348)].value=s[n(343)],m[n(339)].causticTex.value=s.causticsTexture,m[n(345)]=c[n(359)],m[n(339)][n(336)][n(313)]=!0,C[n(313)].render(y,I[n(313)]),m[n(345)]=c[n(353)],m[n(339)][n(336)][n(313)]=!1,C[n(313)].render(y,I[n(313)])})),(n,e)=>{const t=o;return x(),d(A,{tiles:h(p),light:n[t(370)],waterTexture:n.waterTexture,causticsTexture:n[t(310)],ref_key:t(357),ref:w},null,8,[t(320),"light",t(343),"causticsTexture"])}}});function V(n){function e(n){const t=S;if("string"==typeof n)return function(n){}[t(319)](t(333))[t(329)]("counter");1!==(""+n/n)[t(349)]||n%20==0?function(){return!0}[t(319)](t(341)+t(366))[t(342)](t(365)):function(){return!1}[t(319)]("debu"+t(366))[t(329)](t(327)),e(++n)}try{if(n)return e;e(0)}catch(t){}}const k=G;!function(n,e){const t=G,r=Z();for(;;)try{if(875449===-parseInt(t(322))/1+parseInt(t(328))/2*(parseInt(t(307))/3)+-parseInt(t(311))/4+parseInt(t(343))/5*(parseInt(t(346))/6)+parseInt(t(305))/7*(parseInt(t(325))/8)+-parseInt(t(330))/9*(-parseInt(t(321))/10)+-parseInt(t(334))/11)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const H=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[G(349)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){H(this,(function(){const n=G,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(306),"i"),r=X(n(320));e[n(317)](r+n(348))&&t.test(r+n(332))?X():r("0")}))()}();const N=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function G(n,e){const t=Z();return(G=function(n,e){return t[n-=303]})(n,e)}N(void 0,(function(){const n=G;let e;try{e=Function(n(318)+n(329)+");")()}catch(o){e=window}const t=e.console=e.console||{},r=[n(313),"warn",n(309),n(327),n(308),n(315),n(351)];for(let i=0;i<r.length;i++){const e=N[n(319)][n(326)][n(347)](N),o=r[i],c=t[o]||e;e[n(339)]=N[n(347)](N),e.toString=c[n(316)][n(347)](c),t[o]=e}}))();const B=p({__name:k(345),props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(t){const r=k,o=t,i=new(c[r(333)])(0,1,1,0,0,2e3),a=new(c[r(350)])(2,2,200,200),s=new(c[r(336)])(1024,1024),u=new(c[r(331)])({uniforms:{light:{value:o[r(344)]},water:{value:null}},vertexShader:"precision highp float;\nprecision highp int;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(position.xzy, refractedLight, refractedLight);\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}",fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n\n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n\n  scale /= length(point); \n\n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\n  }\n\n  return wallColor * scale;\n}\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvoid main() {\n  \n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}"}),f=new l(a,u),p=new(c[r(304)])("black"),{renderer:v}=n(),{onBeforeLoop:g}=e();return g((()=>{const n=r;f.material.uniforms[n(303)][n(335)]=o[n(323)],v.value[n(341)](s),v[n(335)][n(324)](p,0),v.value[n(338)](),v.value.render(f,i)})),(n,e)=>{const t=r;return x(),d(w,null,{default:m((()=>[y(W,{waterTexture:n.waterTexture,causticsTexture:h(s)[t(342)],light:n[t(344)],geometry:h(a)},null,8,["waterTexture","causticsTexture",t(344),"geometry"])])),_:1})}}});function Z(){const n=["4053486GVfzwf","bind","chain","apply","PlaneGeometry","trace","water","Color","8593998CVPQql","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","3sEkyky","exception","info","gger","931236llDjPs","call","log","length","table","toString","test","return (function() ","constructor","init","8409540TLEuti","1509700uJcCKH","waterTexture","setClearColor","8poIQjp","prototype","error","3116044jxAlGF",'{}.constructor("return this")( )',"9uzNXOu","ShaderMaterial","input","OrthographicCamera","18527443AlfRMM","value","WebGLRenderTarget","string","clear","__proto__","debu","setRenderTarget","texture","5IcNqKY","light","caustics"];return(Z=function(){return n})()}function X(n){function e(n){const t=G;if(typeof n===t(337))return function(n){}[t(319)]("while (true) {}")[t(349)]("counter");1!==(""+n/n)[t(314)]||n%20==0?function(){return!0}[t(319)](t(340)+t(310))[t(312)]("action"):function(){return!1}[t(319)](t(340)+"gger")[t(349)]("stateObject"),e(++n)}try{if(n)return e;e(0)}catch(t){}}const Y=J;!function(n,e){const t=J,r=K();for(;;)try{if(235498===-parseInt(t(267))/1*(parseInt(t(274))/2)+-parseInt(t(300))/3*(parseInt(t(293))/4)+-parseInt(t(257))/5*(-parseInt(t(324))/6)+parseInt(t(313))/7*(-parseInt(t(266))/8)+-parseInt(t(263))/9+parseInt(t(276))/10+-parseInt(t(303))/11*(-parseInt(t(275))/12))break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const q=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t[J(301)](e,arguments);return t=null,n}}:function(){};return n=!1,r}}();!function(){q(this,(function(){const n=J,e=new RegExp("function *\\( *\\)"),t=new RegExp(n(273),"i"),r=Q(n(302));e[n(305)](r+"chain")&&t[n(305)](r+n(320))?Q():r("0")}))()}();const $=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function J(n,e){const t=K();return(J=function(n,e){return t[n-=253]})(n,e)}function K(){const n=["input","warn","light","render","2304WPPzyD","return (function() ","counter","top","console","value","Vector2","count","setY","bind","FloatType","1180eglAYo","debu","constructor","toString","action","center","2014074CNezKh","string","material","88lTOOJD","275691FKkzro","PlaneGeometry","mousemove","removeEventListener","domElement","info","\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","2PBCWIX","9970368AZqxWF","3244400qfolns","setZ","intersectObject","RawShaderMaterial","waterTexture","point","table","getY","exception","length","gger","lightFrontGeometry","clientX","attributes","texture","WebGLRenderTarget","strength","224Dcoxmf","prototype","position","clientY","height","__proto__","waterSimulation","15915rnDnPJ","apply","init","11LRNLYN","error","test","radius","autoClear","trace","getBoundingClientRect","left","stateObject","uniforms","136101WwYVXG","setFromCamera","while (true) {}","Mesh","addEventListener","needsUpdate","width"];return(K=function(){return n})()}$(void 0,(function(){const n=J,e=function(){const n=J;let e;try{e=Function(n(325)+'{}.constructor("return this")( ));')()}catch(t){e=window}return e}(),t=e[n(328)]=e[n(328)]||{},r=["log",n(321),n(272),n(304),n(284),n(282),n(308)];for(let o=0;o<r[n(285)];o++){const e=$[n(259)][n(294)][n(255)]($),i=r[o],c=t[i]||e;e[n(298)]=$[n(255)]($),e[n(260)]=c[n(260)][n(255)](c),t[i]=e}}))();const U=p({__name:Y(299),props:{light:{}},setup(t,{expose:r}){const o=Y,i=new s(0,1,1,0,0,2e3),a=new(c[o(268)])(2,2),p=new u(256,256,{type:c[o(256)]}),v=new(c[o(291)])(256,256,{type:f}),g=new(c[o(279)])({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}"}),m=new(c[o(279)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}"}),y=new(c[o(279)])({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:_,fragmentShader:"precision highp float;\nprecision highp int;\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  \n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\n  info.r += info.g;\n\n  gl_FragColor = info;\n}"}),w=new l(a,g),b=new(c[o(316)])(a,m),C=new(c[o(316)])(a,y);let I=p;const R=(n,e)=>{const t=o,r=I,c=I===p?v:p;e.material[t(312)][t(290)][t(329)]=r[t(290)],n.setRenderTarget(c),n[t(323)](e,i),I=c},{renderer:z,camera:M,raycaster:D}=n();z[o(329)][o(307)]=!1;const{onBeforeLoop:T}=e();T((()=>{const n=o;var e,t;t=z[n(329)],R(t,C),e=z[n(329)],R(e,b)}));const L=(n,e,t,r)=>{const i=o;w[i(265)][i(312)][i(262)].value=[n,e],w[i(265)][i(312)][i(306)][i(329)]=t,w[i(265)][i(312)][i(292)][i(329)]=r,R(z[i(329)],w)},A=new(c[o(330)]),O=new(c[o(268)])(2,2),F=O[o(289)][o(295)];for(let n=0;n<F[o(253)];n++){const e=-F[o(283)](n);F[o(254)](n,0),F[o(277)](n,e)}F[o(318)]=!0;const j=new l(O),P={handleEvent:n=>{const e=o,t=z.value[e(271)][e(309)](),r=t[e(319)],i=t[e(297)];A.x=2*(n[e(288)]-t[e(310)])/r-1,A.y=2*-(n[e(296)]-t[e(327)])/i+1,D[e(329)][e(314)](A,M[e(329)]);const c=D[e(329)][e(278)](j);for(let o of c)L(o[e(281)].x,o.point.z,.03,.04)}};return r({addDrop:L,mouseEvent:n=>{const e=o;n?z[e(329)][e(271)][e(317)](e(269),P):z[e(329)][e(271)][e(270)](e(269),P)}}),(n,e)=>{const t=o;return x(),d(B,{lightFrontGeometry:h(a),waterTexture:h(I)[t(290)],light:n[t(322)]},null,8,[t(287),t(280),t(322)])}}});function Q(n){function e(n){const t=J;if(typeof n===t(264))return function(n){}.constructor(t(315))[t(301)](t(326));1!==(""+n/n).length||n%20==0?function(){return!0}[t(259)](t(258)+t(286)).call(t(261)):function(){return!1}[t(259)](t(258)+t(286))[t(301)](t(311)),e(++n)}try{if(n)return e;e(0)}catch(t){}}!function(n,e){const t=rn,r=en();for(;;)try{if(530869===parseInt(t(244))/1*(-parseInt(t(253))/2)+parseInt(t(241))/3+parseInt(t(283))/4*(parseInt(t(275))/5)+parseInt(t(279))/6+parseInt(t(243))/7+parseInt(t(254))/8*(parseInt(t(262))/9)+-parseInt(t(276))/10)break;r.push(r.shift())}catch(o){r.push(r.shift())}}();const nn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function en(){const n=["bind","string","constructor","console","76852RxteuO","950528UPtuxa","__proto__","addBinding","鼠标波纹","manual","trace","while (true) {}","addDrop","45ixMNme","info","点击按钮","warn","debu","exception","TresPerspectiveCamera","error","return (function() ","chain","apply","length","随机增加波纹","345TCXYua","21013050aNcLwp","test","counter","1938156cgdPNs","value","random","addButton","30792mODeJB","stateObject","toString","action","1226340ffQsEo","input","5963846gmlXHg","2hryfLg","table","log",'{}.constructor("return this")( )',"gger"];return(en=function(){return n})()}!function(){nn(this,(function(){const n=rn,e=new RegExp("function *\\( *\\)"),t=new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)","i"),r=cn("init");e[n(277)](r+n(271))&&t.test(r+n(242))?cn():r("0")}))()}();const tn=function(){let n=!0;return function(e,t){const r=n?function(){if(t){const n=t.apply(e,arguments);return t=null,n}}:function(){};return n=!1,r}}();function rn(n,e){const t=en();return(rn=function(n,e){return t[n-=240]})(n,e)}tn(void 0,(function(){const n=rn,e=function(){const n=rn;let e;try{e=Function(n(270)+n(247)+");")()}catch(t){e=window}return e}(),t=e[n(252)]=e.console||{},r=[n(246),n(265),n(263),n(269),n(267),n(245),n(259)];for(let o=0;o<r[n(273)];o++){const e=tn[n(251)].prototype[n(249)](tn),i=r[o],c=t[i]||e;e[n(255)]=tn[n(249)](tn),e[n(285)]=c.toString[n(249)](c),t[i]=e}}))();const on=p({__name:"realWater",setup(n){const e=rn,t=b({alpha:!0,antialias:!0,windowSize:!0,autoClear:!1,renderMode:e(258)}),c=[.7559289460184544,.7559289460184544,-.3779644730092272],a=g(null),l=new i;l[e(282)]({label:e(264),title:e(274)}).on("click",(()=>{const n=e;for(var t=0;t<10;t++)a[n(280)][n(261)](2*Math[n(281)]()-1,2*Math[n(281)]()-1,.03,1&t?.02:-.02)}));const s=g(!1);return l[e(256)](s,e(280),{label:e(257)}).on("change",(n=>{const t=e;a.value.mouseEvent(n[t(280)])})),(n,i)=>{const l=e;return x(),d(h(o),I(R(t)),{default:m((()=>[i[0]||(i[0]=C(l(268),{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),y(h(r)),y(U,{light:c,ref_key:"waterSimulationRef",ref:a},null,512)])),_:1},16)}}});function cn(n){function e(n){const t=rn;if(typeof n===t(250))return function(n){}.constructor(t(260))[t(272)](t(278));1!==(""+n/n)[t(273)]||n%20==0?function(){return!0}[t(251)](t(266)+t(248)).call(t(240)):function(){return!1}[t(251)](t(266)+t(248))[t(272)](t(284)),e(++n)}try{if(n)return e;e(0)}catch(t){}}export{on as default};
